<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <style>
            .borders {
                fill: none;
                stroke: black;
                stroke-width: 0.3px;
                stroke-linejoin: round;
            }
            .regions {
                /* stroke: white;
                stroke-width: 0.1px; */
            }
        </style>
    </head>

    <body>
        <svg id="map"></svg>
        <script src="../build/eurostatmap.js"></script>
        <script src="https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
        <script src="https://d3js.org/d3.v4.js"></script>
        <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

        <script>
            const width = 600
            const height = 600

            Promise.all([
                fetch('./data/paro_por_municipio.csv').then((response) => response.text()),
                fetch('./data/poblacion.csv').then((response) => response.text()),
            ])
                .then(([firstCsvText, secondCsvText]) => {
                    const firstCsv = d3.csvParse(firstCsvText)
                    const secondCsv = d3.csvParse(secondCsvText)

                    // Convert the second CSV to a lookup object based on the standardized code
                    const secondDataLookup = secondCsv.reduce((lookup, row) => {
                        const code = row.id.split(' ')[0].replace(/^0+/, '') // Remove leading zeros from the code
                        lookup[code] = row
                        return lookup
                    }, {})

                    // Merge data based on matching standardized codes
                    const mergedData = firstCsv.map((row) => {
                        const code = row['Codigo Municipio'].replace(/^0+/, '') // Remove leading zeros from the first CSV code
                        const matchingRow = secondDataLookup[code]
                        return matchingRow ? { ...row, ...matchingRow } : row
                    })

                    // Parse value by removing thousands delimiter
                    function parseThousandsDelimiter(value) {
                        if (value) {
                            return parseInt(value.replace('.', ''), 10) // Remove the dot and parse as integer
                        }
                    }
                    // Transform merged data to code:value object
                    const statisticalData = mergedData.reduce((acc, row) => {
                        // Handle unemployment value, setting "<5" to "5" and parsing as an integer
                        let unemployment =
                            row['total Paro Registrado'] === '<5' ? 5 : parseThousandsDelimiter(row['total Paro Registrado'])

                        // Parse population
                        const population = parseThousandsDelimiter(row.total)

                        // Calculate percentage unemployed and add to accumulator
                        const unemploymentRate = Math.round((unemployment / population) * 100)
                        acc[row['Codigo Municipio']] = isNaN(unemploymentRate) ? ':' : unemploymentRate

                        return acc
                    }, {})

                    return Promise.all([
                        fetch('./geometries/spain_borders.json').then((response) => response.json()),
                        fetch('./geometries/spain-municipalities.topojson.json').then((response) => response.json()),
                        statisticalData, // Pass statisticalData forward in the chain
                    ])
                })
                .then(([bordersTopoJSON, topoJSON, statisticalData]) => {
                    const geoJSON = topojson.feature(topoJSON, topoJSON.objects[Object.keys(topoJSON.objects)[0]])
                    const bordersGeoJSON = topojson.feature(
                        bordersTopoJSON,
                        bordersTopoJSON.objects[Object.keys(bordersTopoJSON.objects)[0]]
                    )

                    // Add IDs to feature properties
                    geoJSON.features.forEach((feature) => {
                        feature.properties.id = feature.id
                    })

                    // Set up the projection
                    const projection = d3.geoAzimuthalEqualArea().rotate([-1, -40.55]).scale(3000)

                    // Initialize the map
                    const map = eurostatmap
                        .map('choropleth')
                        .geoCenter([2, 47])
                        .zoomExtent([1, 10])
                        .width(width)
                        .height(height)
                        .title('Custom Geometries Test')
                        .projectionFunction(projection)
                        .geometries([
                            {
                                id: 'regions',
                                class: 'regions',
                                regions: true,
                                features: geoJSON.features,
                                onEach: (elements) => {
                                    // Add any D3 custom styling or behavior here
                                },
                            },
                            {
                                id: 'borders',
                                features: bordersGeoJSON.features,
                                class: 'borders',
                            },
                        ])
                        .legend({ title: 'Unemployment %', x: 10, y: 180, boxOpacity: 0.6, decimals: 0 })
                        .bottomText(
                            'Source: <a href="https://datos.gob.es/en/catalogo/ea0021425-paro-registrado-por-municipios">datos.gob.es</a>'
                        )

                    // Set statistical data for the map
                    map.statData().setData(statisticalData)

                    // Build the map
                    map.build()
                })
                .catch((error) => console.error('Error loading data or TopoJSON:', error))

            // Optional function for creating a progressive ID-value map
            function createProgressiveIdValueMap(features) {
                const idValueMap = {}
                const step = 1000 / features.length

                features.forEach((feature, index) => {
                    const id = feature.properties.id
                    const value = Math.floor(step * (index + 1))
                    idValueMap[id] = value
                })

                return idValueMap
            }
        </script>
    </body>
</html>
