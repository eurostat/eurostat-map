<!doctype html>
<html lang="en">

<head>
    <title>Maritime ports map</title>
    <meta charset="UTF-8" />
    <meta name="author" content="GISCO - Eurostat" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./static.css" />
</head>

<body style="margin:0">
    <div>

        <button id="toggle-edit-mode-btn" type="button">Toggle edit mode</button>
        <button id="export-annotations-btn" type="button">Export Annotations</button>
        |
        <button id="export-png-btn" type="button">Export map as PNG</button>
        <button id="export-svg-btn" type="button">Export map as SVG</button>
    </div>
    <div>
        <svg id="ports-map"></svg>
    </div>

    <svg style='display:none;'>
        <!-- used for country borders -->
        <defs>
            <filter id="blur-effect" x="-50%" y="-50%" width="150%" height="150%">
                <feGaussianBlur in="SourceGraphic" stdDeviation=".6" />
            </filter>
        </defs>
    </svg>

    <script src="../../../../../build/eurostatmap.js"></script>
    <script src="../../../d3.v7.min.js"></script>
    <script src="../../../proj4-src.js"></script>
    <script src="../portsData.js"></script>
    <script src="./insetsStatic.js"></script>
    <script src="../projections.js"></script>
    <script src="./exportAnnotations.js"></script>

    <script type="module" id="our-map">
        const portsAnnotations = await(await fetch('./ports-annotations.json')).json();
        window.portsAnnotations = portsAnnotations;
        const portsWidth = 1080; //social media size
        const portsHeight = 850;
        const insetsX = portsWidth - 120;
        const insetsY = 10;

        const getApproxCurrentGeoBbox = function () {
            const defaultPosition = { x: 4790000, y: 3420000 };
            const halfWidth = 0.5 * defaultPosition.z * portsWidth;
            const halfHeight = 0.5 * defaultPosition.z * portsHeight;
            return [
                defaultPosition.x - halfWidth,
                defaultPosition.y - halfHeight,
                defaultPosition.x + halfWidth,
                defaultPosition.y + halfHeight
            ];
        }

        const portsProjection = d3
            .geoIdentity()
            .reflectY(true)
            .fitSize(
                [portsWidth, portsHeight],
                getBBOXAsGeoJSON(getApproxCurrentGeoBbox())
            )
        const portsSizeData = indexByCode([...portsData])
        let editMode = false;
        const map = eurostatmap
            .map("ps")
            .header(true).footer(true)
            .svgId("ports-map")
            .height(portsHeight) //social media size
            .width(portsWidth)
            .hoverColor('#ffc700')
            .insets(insets)
            .insetBoxPosition([insetsX, insetsY])
            .showEstatLogo(true)
            .showEstatRibbon(true)
            .logoPosition([0, portsHeight + 45])
            .ribbonPosition([portsWidth - 180, portsHeight + 30])
            .ribbonWidth(300).ribbonHeight(50)
            .nutsLevel(0)
            .psMinSize(3)
            .psMaxSize(30)
            .psStrokeWidth(0.9)
            .title("Main cargo ports by gross weight of goods handled, 2024")
            .subtitle("(million tonnes)")
            .footnote(
                "Note: the map shows data for the ports with at least 2 million tonnes of freight handled (inward and outward combined). Ports reporting more than 47 million tonnes are labelled."
            )
            .footnoteWrap(100)
            //.footnotePosition([15, portsHeight - 15])
            .legend({
                title: "Million tonnes",
                x: 10,
                y: 240,
                sizeLegend: {
                    values: [397000000, 100000000, 2000000],
                    labels: ['397 (Rotterdam)', '100 ', '2 (Umea)']
                }
            })
            .filterGeometriesFunction((geometries) => {
                //remove greenland to stop title overlap
                let nuts2json = geometries[0];
                let countries = nuts2json.objects.cntrg.geometries;
                countries = countries.filter((f) => {
                    if (f.properties.id !== "GL" && f.properties.na !== "Greenland") {
                        return f;
                    } else {
                        return false;
                    }
                });
                nuts2json.objects.cntrg.geometries = countries;

                // add ports to centroids array
                // each port location must be reprojected to the map projection
                let centroids = geometries[1];
                [...portsData].forEach((d) => {
                    let newCentroid
                    if (d.code == 'ES02ESLPA') {
                        // handle canarias (inset map)
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32628([d.lon, d.lat]), // IC_32628 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else if (d.code == 'FR04GPPTP') {
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32620([d.lon, d.lat]), // GP_32620 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else if (d.code == 'FR04MQFDF') {
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32620([d.lon, d.lat]), // MQ_32620 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else if (d.code == 'FR05RELPT') {
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32740([d.lon, d.lat]), // RE_32740 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else {
                        let coords = to3035([d.lon, d.lat]);
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: coords,
                                type: "Point"
                            },
                            properties: {
                                centroid: portsProjection(coords),
                                id: d.code,
                                na: d.name
                            }
                        };
                    }

                    centroids.features.push(newCentroid);
                });
                return geometries;
            })
            .zoomButtons(false)
            .callback(() => {
                const portKeys = Object.keys(portsSizeData);
                //color regions
                d3.selectAll("#ports-map .em-nutsrg path").style("fill", (d) => {
                    const iso = d.properties.id; // e.g. "NL"

                    // Check if ANY port key starts with this ISO
                    const hasPort = portKeys.some((k) => k.startsWith(iso)) || iso == "EL";

                    return hasPort ? "rgba(178, 232, 215,0.4)" : "#F2F2F2";
                });
                // --- REMOVE if it already exists ---
                d3.select("#ports-map #em-footnote-2").remove();

                d3.selectAll("#ports-map")
                    .append('text')
                    .attr('x', portsWidth - 315)
                    .attr('y', portsHeight + 100)
                    .attr('class', 'em-footnote').attr('id', 'em-footnote-2')
                    .append('tspan')
                    .html('Cartography: GISCO. Boundaries: ©EuroGeographics ©OSM');
            })
            .annotations({ editMode: editMode, annotations: portsAnnotations }).tooltip({
                textFunction: tooltipTextFunction
            })
            .build();

        map.statData("size").setData(portsSizeData);


        var editModeBtn = document.getElementById("toggle-edit-mode-btn");
        editModeBtn.addEventListener("click", function () {
            editMode = !editMode;
            map.annotations({ editMode: editMode, annotations: window.portsAnnotations })
        });

        var exportBtnPNG = document.getElementById("export-png-btn");
        exportBtnPNG.addEventListener("click", function () {
            map.exportMapToPNG(1080, 900);
        });

        var exportBtnSVG = document.getElementById("export-svg-btn");
        exportBtnSVG.addEventListener("click", function () {
            map.exportMapToSVG(1080, 900);
        });


        function tooltipTextFunction(region, map) {
            if (map.tooltip_.omitRegions && map.tooltip_.omitRegions.includes(region.properties.id)) {
                return ''; // Skip tooltip for omitted regions
            }

            const regionName = region.properties.na;
            const regionId = region.properties.id;

            // Stat 1
            const v1 = map.statData('size').getArray() ? map.statData('size') : map.statData();
            const sv1 = v1.get(region.properties.id);
            const unit1 = v1.unitText?.() || '';
            const row1 = `<tr><td>${(sv1?.value / 1000000).toFixed(1) + ' million tonnes'}</td></tr>`;

            return `
    <div class="em-tooltip-bar">
      <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
    </div>
    <div class="em-tooltip-text">
      <table class="em-tooltip-table">
        <tbody>
          ${row1}
        </tbody>
      </table>
    </div>
  `.trim();
        };
    </script>
</body>

</html>