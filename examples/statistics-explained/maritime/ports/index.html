<!doctype html>
<html lang="en">

<head>
    <title>Maritime ports map</title>
    <meta charset="UTF-8" />
    <meta name="author" content="GISCO - Eurostat" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./ports.css" />
</head>

<body style="margin:0">
    <svg id="ports-map"></svg>

    <svg style='display:none;'>
        <!-- used for country borders -->
        <defs>
            <filter id="blur-effect" x="-50%" y="-50%" width="150%" height="150%">
                <feGaussianBlur in="SourceGraphic" stdDeviation=".6" />
            </filter>
        </defs>
    </svg>
    <script src="../../../../build/eurostatmap.js"></script>
    <script src="../../d3.v7.min.js"></script>
    <script src="../../proj4-src.js"></script>
    <script src="./portsData.js"></script>
    <script src="./annotations.js"></script>
    <script src="./ranking.js"></script>
    <script src="./insets.js"></script>
    <script src="./projections.js"></script>

    <script id="'our-map">
        const portsWidth = 795;
        const portsHeight = 437;
        const insetsX = 699;
        const insetsY = 170;

        const getApproxCurrentGeoBbox = function () {
            const defaultPosition = { x: 4790000, y: 3420000 };
            const halfWidth = 0.5 * defaultPosition.z * portsWidth;
            const halfHeight = 0.5 * defaultPosition.z * portsHeight;
            return [
                defaultPosition.x - halfWidth,
                defaultPosition.y - halfHeight,
                defaultPosition.x + halfWidth,
                defaultPosition.y + halfHeight
            ];
        }
        const portsProjection = d3
            .geoIdentity()
            .reflectY(true)
            .fitSize(
                [portsWidth, portsHeight],
                getBBOXAsGeoJSON(getApproxCurrentGeoBbox())
            )
        const portsSizeData = indexByCode([...portsData])

        const map = eurostatmap
            .map("ps")
            .svgId("ports-map")
            .hoverColor('#ffc700')
            .insets(insets)
            .insetBoxPosition([insetsX, insetsY])
            .nutsLevel(0)
            .psMinSize(3)
            .psMaxSize(30)
            .title("Main cargo ports by gross weight of goods handled, 2024")
            .subtitle("million tonnes")
            .footnote(
                "Note: the map shows data for the ports with at least 2 million tonnes of freight handled (inward and outward combined). EU ports reporting more than 47 million tonnes are labelled."
            )
            .footnoteWrap(90)
            .footnotePosition([10, 665])
            .legend({
                title: "Tonnes of freight",
                x: portsWidth - 205,
                y: 40,
                sizeLegend: {
                    values: [397000000, 100000000, 2000000],
                    labels: ['397 million (max)', '100 million', '2 million (min)']
                }
            })
            .filterGeometriesFunction((geometries) => {
                //remove greenland to stop title overlap
                let nuts2json = geometries[0];
                let countries = nuts2json.objects.cntrg.geometries;
                countries = countries.filter((f) => {
                    if (f.properties.id !== "GL" && f.properties.na !== "Greenland") {
                        return f;
                    } else {
                        return false;
                    }
                });
                nuts2json.objects.cntrg.geometries = countries;

                // add ports to centroids array
                // each port location must be reprojected to the map projection
                let centroids = geometries[1];
                [...portsData].forEach((d) => {
                    let newCentroid
                    if (d.code == 'ES02ESLPA') {
                        // handle canarias (inset map)
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32628([d.lon, d.lat]), // IC_32628 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else if (d.code == 'FR04GPPTP') {
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32620([d.lon, d.lat]), // GP_32620 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else if (d.code == 'FR04MQFDF') {
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32620([d.lon, d.lat]), // MQ_32620 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else if (d.code == 'FR05RELPT') {
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: to32740([d.lon, d.lat]), // RE_32740 fixed position in inset
                                type: "Point"
                            },
                            properties: {
                                centroid: undefined,
                                id: d.code,
                                na: d.name
                            }
                        };
                    } else {
                        let coords = to3035([d.lon, d.lat]);
                        newCentroid = {
                            type: "Feature",
                            geometry: {
                                coordinates: coords,
                                type: "Point"
                            },
                            properties: {
                                centroid: portsProjection(coords),
                                id: d.code,
                                na: d.name
                            }
                        };
                    }

                    centroids.features.push(newCentroid);
                });
                return geometries;
            })
            .zoomButtons(true)
            .callback(() => {
                const portKeys = Object.keys(portsSizeData);
                //color regions
                d3.selectAll("#ports-map .em-nutsrg path").style("fill", (d) => {
                    const iso = d.properties.id; // e.g. "NL"

                    // Check if ANY port key starts with this ISO
                    const hasPort = portKeys.some((k) => k.startsWith(iso)) || iso == "EL";

                    return hasPort ? "rgba(178, 232, 215,0.4)" : "#F2F2F2";
                });

                // --- REMOVE if it already exists ---
                d3.select("#ports-map #em-footnote-2").remove();
                d3.selectAll("#ports-map")
                    .append('text')
                    .attr('x', 480)
                    .attr('y', 675)
                    .attr('class', 'em-footnote')
                    .attr('id', 'em-footnote-2')
                    .html('Cartography: GISCO. Boundaries: ©EuroGeographics ©OSM');

                //createTopCountriesOverlay("#ports-map", sums, rankingX, rankingY);
            })
            .annotations({ annotations: portsAnnotations })
            .build();

        map.statData("size").setData(portsSizeData);

    </script>
</body>

</html>