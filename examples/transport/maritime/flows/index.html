<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./flows.css" />
</head>

<body style="margin:0">
    <svg id="maritime-flow-map"></svg>

    <script src="../../../../build/eurostatmap.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/proj4"></script>
    <script src="./maritimeFlowGraph.js"></script>

    <script id="our-map-code">
        const width = 1080
        const height = width / 1.5
        const euCoords = [12, 49];
        const worldProjection = d3
            .geoAzimuthalEquidistant()
            .rotate([0, 0])
            //.center([10, 52])       // center on Europe
            .scale(270)
            .translate([width / 2.4, width / 2.3])
        const spaceAsThousandSeparator = function (number) {
            return number.toLocaleString("en").replace(/,/gi, " ");
        }
        const getRegionLabels = function (graph) {
            let labs = [];
            let offsets = { x: -2, y: 0 };
            graph.nodes.forEach((d) => {
                labs.push({ text: d.name, x: d.x + offsets.x, y: d.y + offsets.y });
            });
            return labs;
        }


        const map = eurostatmap
            .map("flow")
            .svgId("maritime-flow-map")
            .width(width)
            .height(height)
            .title("Maritime freight")
            .subtitle("Top 15 flows of goods handled by EU ports")

            //projection
            .projectionFunction(worldProjection)

            //geometries
            .geo("WORLD")
            .proj("4326")
            .scale("60M")

            // flow settings
            .flowGraph(maritimeFlowGraph)
            .flowColor((d) => {
                if (d.meta.direction =='Outwards') {
                    return map.flowRegionColors_[1];
                }
                return map.flowRegionColors_[0];
            })
            .flowMinWidth(5)
            .flowMaxWidth(30)
            //.flowLineType("straight")
            .flowLineType("curved")
            .flowDonuts(false)
            .flowOpacity(0.9)
            .flowArrows(false)
            .flowOutlines(true)
            .flowOutlineColor('white')
            .flowOutlineWidth(1)
            .flowColorGradient(false)
            .flowWidthGradient(false)
            //.flowTopLocations(0)
            //.flowWidthGradient(true)
            .flowStack(true)
            .flowCurvatureSettings({
                gapX: 1,        // how far before/after node to begin/end curve
                padX: 0,         // horizontal clearance near node stems
                padY: 1,         // vertical collision detection padding
                bumpY: 5,        // extra height for hop
                curvature: 0.3   // 0..1; default sankey smoothness
            }).flowOrder((a, b) => {
                // Prefer originId if present (from expandRoutesToSankeyMidpointGraph),
                // fall back to link.source.id.
                const srcA = a.link.originId ?? (a.link.source && a.link.source.id);
                const srcB = b.link.originId ?? (b.link.source && b.link.source.id);
                const morocco = a.link.target.id === 'MA' || b.link.target.id === 'MA';

                // Edge case: move India flow above Turkey
                if (srcA === 'IN' && srcB === 'TR') return -1; // IN above TR
                if (srcA === 'TR' && srcB === 'IN') return 1;  // TR below IN

                //brasil above algeria and morocco
                if (srcA === 'BR' && (srcB === 'DZ' || morocco)) return -1;
                if ((srcA === 'DZ' || morocco) && srcB === 'BR') return 1;

                // Default ordering: by otherY (pulls toward the other end of the link)
                const dy = a.otherY - b.otherY;
                if (dy !== 0) return dy;

                // Tie-break by source id so sort is stable/deterministic
                if (srcA && srcB && srcA !== srcB) {
                    return srcA < srcB ? -1 : 1;
                }

                return 0;
            })


            .labels({
                labels: getRegionLabels(maritimeFlowGraph),
                shadows: true
            })

            // legend
            .legend({
                x: width - 140,
                y: height - 190,
                boxPadding: 10,
                title: "Freight carried",
                subtitle: "(tonnes)",
                flowWidthLegend: {
                    marginTop: -10,
                    //values: [3, 500, 2600],
                    labelFormatter: (value) => spaceAsThousandSeparator(value * 1000)
                },
                flowColorLegend: false,
                regionColorLegend: {
                    marginTop: 20,
                    title: " ",
                    labels: ["Imports", "Exports"]
                }
            })

            .footnote(
                "Freight includes both loaded and unloaded. Administrative boundaries: ©EuroGeographics ©UN-FAO @OpenStreetMap"
            )
            // zoom min/max
            .zoomExtent([0.6, 10])
            .zoomButtons(true)
            .lockPanUntilZoom(false)

            .build();


    </script>
</body>

</html>