(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["eurostatmap"] = factory();
	else
		root["eurostatmap"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* STYLING OF NUTS REGIONS AND BOUNDARIES */
/* Default region fill */
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    fill: #e1e1e1;
}

.em-nutsrg,
.em-cntrg,
.em-grid-cell,
#em-user-regions {
    cursor: pointer;
}

/*  boundaries stroke-width */
.em-bn-0 {
    stroke: none;
}
.em-bn-1,
.em-bn-2,
.em-bn-3,
/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-bn-co {
    stroke-width: 0.2;
}

/* all boudnaries and regions linecap/linejoin */
#em-nutsbn,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-co,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* national boundaries */
.em-cntbn {
    stroke: #000;
    stroke-width: 0.6px;
}

/* NUTS boundaries stroke color */
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'] {
    stroke: #696969;
}

/* coastal boundaries */
.em-bn-co {
    stroke: white;
}

/* kosovo */
.em-kosovo-bn {
    stroke: #000;
    stroke-width: 0.15;
}



/* dont fill certain elements */
.em-frame,
.em-graticule,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-co {
    fill: none;
}

/* target non cc/eu/efta borders */
/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {
    stroke-width: 0;
} */
`, "",{"version":3,"sources":["webpack://./src/css/NUTS.css"],"names":[],"mappings":"AAAA,2CAA2C;AAC3C,wBAAwB;AACxB;;;IAGI,aAAa;AACjB;;AAEA;;;;IAII,eAAe;AACnB;;AAEA,6BAA6B;AAC7B;IACI,YAAY;AAChB;AACA;;;;;;;;IAQI,iBAAiB;AACrB;;AAEA,gDAAgD;AAChD;;;;;;;;;;;;;;IAcI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA,wBAAwB;AACxB;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA,iCAAiC;AACjC;;;;;;IAMI,eAAe;AACnB;;AAEA,uBAAuB;AACvB;IACI,aAAa;AACjB;;AAEA,WAAW;AACX;IACI,YAAY;IACZ,kBAAkB;AACtB;;;;AAIA,+BAA+B;AAC/B;;;;;;;;;IASI,UAAU;AACd;;AAEA,kCAAkC;AAClC;;GAEG","sourcesContent":["/* STYLING OF NUTS REGIONS AND BOUNDARIES */\r\n/* Default region fill */\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    fill: #e1e1e1;\r\n}\r\n\r\n.em-nutsrg,\r\n.em-cntrg,\r\n.em-grid-cell,\r\n#em-user-regions {\r\n    cursor: pointer;\r\n}\r\n\r\n/*  boundaries stroke-width */\r\n.em-bn-0 {\r\n    stroke: none;\r\n}\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-bn-co {\r\n    stroke-width: 0.2;\r\n}\r\n\r\n/* all boudnaries and regions linecap/linejoin */\r\n#em-nutsbn,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-co,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n/* national boundaries */\r\n.em-cntbn {\r\n    stroke: #000;\r\n    stroke-width: 0.6px;\r\n}\r\n\r\n/* NUTS boundaries stroke color */\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'] {\r\n    stroke: #696969;\r\n}\r\n\r\n/* coastal boundaries */\r\n.em-bn-co {\r\n    stroke: white;\r\n}\r\n\r\n/* kosovo */\r\n.em-kosovo-bn {\r\n    stroke: #000;\r\n    stroke-width: 0.15;\r\n}\r\n\r\n\r\n\r\n/* dont fill certain elements */\r\n.em-frame,\r\n.em-graticule,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-co {\r\n    fill: none;\r\n}\r\n\r\n/* target non cc/eu/efta borders */\r\n/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {\r\n    stroke-width: 0;\r\n} */\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-annotation-group {
    /* pointer-events: none; */
}
`, "",{"version":3,"sources":["webpack://./src/css/annotations.css"],"names":[],"mappings":"AAAA;IACI,0BAA0B;AAC9B","sourcesContent":[".em-annotation-group {\r\n    /* pointer-events: none; */\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/index.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./map.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./tooltip.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./legend.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./labels.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./annotations.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./NUTS.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./world.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css");
// Imports









var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `
`, "",{"version":3,"sources":[],"names":[],"mappings":"","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/labels.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#em-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}

.em-label {
    font-size: 12px;
}
.em-label-background {
    fill: #ffffff;
    pointer-events: none;
}
.em-label-shadow {
    font-size: 12px;
    stroke-width: 2px;
    stroke: white;
}
.em-stat-label {
    opacity: 1;
    font-size: 13px;
    stroke-width: 3px;
    fill: #313131;
    font-weight: bold;
}
.em-stat-label-shadow {
    opacity: 1;
    font-size: 13px;
    stroke-width: 4px;
    stroke: white;
}
.em-label-cc {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-cc {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-countries {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-countries {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-seas {
    font-size: 9px;
    fill: #003399;
    stroke: #003399;
    stroke-width: 0.2px;
    letter-spacing: 3px;
}
.em-label-shadow-seas {
    font-size: 9px;
    letter-spacing: 3px;
    stroke: white;
    stroke-width: 3px;
}

.em-flow-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}
.em-flow-label {
    font-size: 13px;
    fill: black;
    font-weight: bold;
}
.em-flow-label-shadow {
    font-size: 13px;
    stroke-width: 4px;
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/labels.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;;AAEA;IACI,eAAe;AACnB;AACA;IACI,aAAa;IACb,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB;AACA;IACI,UAAU;IACV,eAAe;IACf,iBAAiB;IACjB,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,UAAU;IACV,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,cAAc;IACd,aAAa;IACb,eAAe;IACf,mBAAmB;IACnB,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;IACnB,aAAa;IACb,iBAAiB;AACrB;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;AACA;IACI,eAAe;IACf,WAAW;IACX,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB","sourcesContent":["#em-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n\r\n.em-label {\r\n    font-size: 12px;\r\n}\r\n.em-label-background {\r\n    fill: #ffffff;\r\n    pointer-events: none;\r\n}\r\n.em-label-shadow {\r\n    font-size: 12px;\r\n    stroke-width: 2px;\r\n    stroke: white;\r\n}\r\n.em-stat-label {\r\n    opacity: 1;\r\n    font-size: 13px;\r\n    stroke-width: 3px;\r\n    fill: #313131;\r\n    font-weight: bold;\r\n}\r\n.em-stat-label-shadow {\r\n    opacity: 1;\r\n    font-size: 13px;\r\n    stroke-width: 4px;\r\n    stroke: white;\r\n}\r\n.em-label-cc {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-cc {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-countries {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-countries {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-seas {\r\n    font-size: 9px;\r\n    fill: #003399;\r\n    stroke: #003399;\r\n    stroke-width: 0.2px;\r\n    letter-spacing: 3px;\r\n}\r\n.em-label-shadow-seas {\r\n    font-size: 9px;\r\n    letter-spacing: 3px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n\r\n.em-flow-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n.em-flow-label {\r\n    font-size: 13px;\r\n    fill: black;\r\n    font-weight: bold;\r\n}\r\n.em-flow-label-shadow {\r\n    font-size: 13px;\r\n    stroke-width: 4px;\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/legend.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-legend-background {
    fill: white;
    opacity: 0.7;
    rx: 0;
    ry: 0;
    pointer-events: none;
}
.em-legend-label {
    font-size: 15px;
    stroke: none;
    fill: black;
    dominant-baseline: unset;
}
.em-legend-title {
    font-size: 16px;
    fill: black;
}
.em-legend-separator {
    stroke: white;
    stroke-width: 1;
}
.em-legend-tick {
    stroke: #d8d8d8;
    stroke-width: 1;
}
.em-bivariate-frame {
    fill: none;
    stroke: black;
}
.em-bivariate-nodata {
    stroke: black;
    stroke-width: 0.5;
    cursor: pointer;
}
.em-bivariate-axis-title {
    font-size: 15px;
}
.em-bivariate-nodata-label {
    font-size: 14px;
    dominant-baseline: middle;
}
.em-bivariate-tick {
    stroke: black;
    stroke-width: 1;
}
.em-bivariate-tick-label {
    text-anchor: middle;
    font-size: 12px;
}
.em-bivariate-square,
.em-legend-rect {
    cursor: pointer;
    stroke: white;
}

.em-bivariate-square:hover,
.em-legend-rect:hover {
    stroke-width: 2;
    stroke: red;
}

.em-pie-size-legend-line {
    stroke-dasharray: 2;
    stroke: grey;
}

.em-legend-diverging-line {
    stroke: black;
}

.em-legend-histogram-bar {
    cursor: pointer;
}
`, "",{"version":3,"sources":["webpack://./src/css/legend.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,YAAY;IACZ,KAAK;IACL,KAAK;IACL,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,YAAY;IACZ,WAAW;IACX,wBAAwB;AAC5B;AACA;IACI,eAAe;IACf,WAAW;AACf;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,eAAe;IACf,eAAe;AACnB;AACA;IACI,UAAU;IACV,aAAa;AACjB;AACA;IACI,aAAa;IACb,iBAAiB;IACjB,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,yBAAyB;AAC7B;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,eAAe;AACnB;AACA;;IAEI,eAAe;IACf,aAAa;AACjB;;AAEA;;IAEI,eAAe;IACf,WAAW;AACf;;AAEA;IACI,mBAAmB;IACnB,YAAY;AAChB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,eAAe;AACnB","sourcesContent":[".em-legend-background {\r\n    fill: white;\r\n    opacity: 0.7;\r\n    rx: 0;\r\n    ry: 0;\r\n    pointer-events: none;\r\n}\r\n.em-legend-label {\r\n    font-size: 15px;\r\n    stroke: none;\r\n    fill: black;\r\n    dominant-baseline: unset;\r\n}\r\n.em-legend-title {\r\n    font-size: 16px;\r\n    fill: black;\r\n}\r\n.em-legend-separator {\r\n    stroke: white;\r\n    stroke-width: 1;\r\n}\r\n.em-legend-tick {\r\n    stroke: #d8d8d8;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-frame {\r\n    fill: none;\r\n    stroke: black;\r\n}\r\n.em-bivariate-nodata {\r\n    stroke: black;\r\n    stroke-width: 0.5;\r\n    cursor: pointer;\r\n}\r\n.em-bivariate-axis-title {\r\n    font-size: 15px;\r\n}\r\n.em-bivariate-nodata-label {\r\n    font-size: 14px;\r\n    dominant-baseline: middle;\r\n}\r\n.em-bivariate-tick {\r\n    stroke: black;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-tick-label {\r\n    text-anchor: middle;\r\n    font-size: 12px;\r\n}\r\n.em-bivariate-square,\r\n.em-legend-rect {\r\n    cursor: pointer;\r\n    stroke: white;\r\n}\r\n\r\n.em-bivariate-square:hover,\r\n.em-legend-rect:hover {\r\n    stroke-width: 2;\r\n    stroke: red;\r\n}\r\n\r\n.em-pie-size-legend-line {\r\n    stroke-dasharray: 2;\r\n    stroke: grey;\r\n}\r\n\r\n.em-legend-diverging-line {\r\n    stroke: black;\r\n}\r\n\r\n.em-legend-histogram-bar {\r\n    cursor: pointer;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/map.css ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* General text settings */
text {
    pointer-events: none;
}

a text {
    pointer-events: all;
}

/* Main map */
.em-map,
.em-legend {
    font-family: Arial, Helvetica, sans-serif;
}

/* Coastal margin */
#em-coast-margin {
    filter: url(#em-coastal-blur);
    stroke-linejoin: round;
    stroke-linecap: round;
    fill: none;
    stroke-width: 5;
    stroke: rgb(161, 198, 237);
}

/* Title and subtitle styling */
.em-title,
.em-inset-title {
    fill: black;
    stroke: none;
}

.em-title {
    font-size: 21px;
    font-weight: bold;
}

.em-inset-title {
    font-size: 12px;
}

.em-subtitle,
.em-inset-subtitle {
    fill: #848280;
    stroke: none;
    stroke-linejoin: round;
    paint-order: stroke;
}

.em-subtitle {
    font-size: 18px;
    font-weight: 100;
}

.em-inset-subtitle {
    font-size: 12px;
}

.em-source-pretext {
    font-size: 11px;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link {
    font-size: 11px;
    fill: #0e47cb;
    cursor: pointer;
    text-decoration: underline;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link:hover {
    fill: #082b7a;
    cursor: pointer;
    text-decoration: underline;
}

.em-frame {
    stroke-width: 0;
    stroke: grey;
}

.em-insets .em-frame {
    /* this will give a frame to inset maps */
    stroke: grey;
    stroke-width: 0.3px !important;
}

.em-sea {
    fill: white;
    /* pointer-events: none; */
}
.em-scalebar-line {
    stroke: black;
    stroke-width: 0.8px;
}
.em-scalebar-label {
    font-size: 9px;
    text-anchor: middle;
}

/* Bottom text and symbol styling */
.em-footnote {
    pointer-events: all;
    cursor: default;
    font-size: 11px;
    transform: translate(5px, -5px);
}
.em-footnote a {
    fill: #0e47cb;
    text-decoration: underline;
}
.em-footnote a:hover {
    fill: #0a328e;
}

.em-centroid {
    cursor: pointer;
}

/* Graticule styling */
.em-graticule {
    stroke: lightgray;
    stroke-width: 1;
}

.em-flow-link {
    cursor: pointer;
}
.em-flow-link-outline {
    cursor: pointer;
}
.em-flow-labels {
    font-size: 15px;
    stroke-width: 1px;
    fill: black;
    pointer-events: none;
}
.em-flow-labels-halo {
    font-size: 15px;
    stroke-width: 2px;
    fill: white;
    pointer-events: none;
}

.em-grid-rect,
.em-grid-hexagon {
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/map.css"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B;IACI,oBAAoB;AACxB;;AAEA;IACI,mBAAmB;AACvB;;AAEA,aAAa;AACb;;IAEI,yCAAyC;AAC7C;;AAEA,mBAAmB;AACnB;IACI,6BAA6B;IAC7B,sBAAsB;IACtB,qBAAqB;IACrB,UAAU;IACV,eAAe;IACf,0BAA0B;AAC9B;;AAEA,+BAA+B;AAC/B;;IAEI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,iBAAiB;AACrB;;AAEA;IACI,eAAe;AACnB;;AAEA;;IAEI,aAAa;IACb,YAAY;IACZ,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,eAAe;IACf,gBAAgB;AACpB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,gCAAgC;AACpC;AACA;IACI,eAAe;IACf,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,gCAAgC;AACpC;AACA;IACI,aAAa;IACb,eAAe;IACf,0BAA0B;AAC9B;;AAEA;IACI,eAAe;IACf,YAAY;AAChB;;AAEA;IACI,yCAAyC;IACzC,YAAY;IACZ,8BAA8B;AAClC;;AAEA;IACI,WAAW;IACX,0BAA0B;AAC9B;AACA;IACI,aAAa;IACb,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;AACvB;;AAEA,mCAAmC;AACnC;IACI,mBAAmB;IACnB,eAAe;IACf,eAAe;IACf,+BAA+B;AACnC;AACA;IACI,aAAa;IACb,0BAA0B;AAC9B;AACA;IACI,aAAa;AACjB;;AAEA;IACI,eAAe;AACnB;;AAEA,sBAAsB;AACtB;IACI,iBAAiB;IACjB,eAAe;AACnB;;AAEA;IACI,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;;AAEA;;IAEI,aAAa;AACjB","sourcesContent":["/* General text settings */\r\ntext {\r\n    pointer-events: none;\r\n}\r\n\r\na text {\r\n    pointer-events: all;\r\n}\r\n\r\n/* Main map */\r\n.em-map,\r\n.em-legend {\r\n    font-family: Arial, Helvetica, sans-serif;\r\n}\r\n\r\n/* Coastal margin */\r\n#em-coast-margin {\r\n    filter: url(#em-coastal-blur);\r\n    stroke-linejoin: round;\r\n    stroke-linecap: round;\r\n    fill: none;\r\n    stroke-width: 5;\r\n    stroke: rgb(161, 198, 237);\r\n}\r\n\r\n/* Title and subtitle styling */\r\n.em-title,\r\n.em-inset-title {\r\n    fill: black;\r\n    stroke: none;\r\n}\r\n\r\n.em-title {\r\n    font-size: 21px;\r\n    font-weight: bold;\r\n}\r\n\r\n.em-inset-title {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-subtitle,\r\n.em-inset-subtitle {\r\n    fill: #848280;\r\n    stroke: none;\r\n    stroke-linejoin: round;\r\n    paint-order: stroke;\r\n}\r\n\r\n.em-subtitle {\r\n    font-size: 18px;\r\n    font-weight: 100;\r\n}\r\n\r\n.em-inset-subtitle {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-source-pretext {\r\n    font-size: 11px;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link {\r\n    font-size: 11px;\r\n    fill: #0e47cb;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link:hover {\r\n    fill: #082b7a;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n}\r\n\r\n.em-frame {\r\n    stroke-width: 0;\r\n    stroke: grey;\r\n}\r\n\r\n.em-insets .em-frame {\r\n    /* this will give a frame to inset maps */\r\n    stroke: grey;\r\n    stroke-width: 0.3px !important;\r\n}\r\n\r\n.em-sea {\r\n    fill: white;\r\n    /* pointer-events: none; */\r\n}\r\n.em-scalebar-line {\r\n    stroke: black;\r\n    stroke-width: 0.8px;\r\n}\r\n.em-scalebar-label {\r\n    font-size: 9px;\r\n    text-anchor: middle;\r\n}\r\n\r\n/* Bottom text and symbol styling */\r\n.em-footnote {\r\n    pointer-events: all;\r\n    cursor: default;\r\n    font-size: 11px;\r\n    transform: translate(5px, -5px);\r\n}\r\n.em-footnote a {\r\n    fill: #0e47cb;\r\n    text-decoration: underline;\r\n}\r\n.em-footnote a:hover {\r\n    fill: #0a328e;\r\n}\r\n\r\n.em-centroid {\r\n    cursor: pointer;\r\n}\r\n\r\n/* Graticule styling */\r\n.em-graticule {\r\n    stroke: lightgray;\r\n    stroke-width: 1;\r\n}\r\n\r\n.em-flow-link {\r\n    cursor: pointer;\r\n}\r\n.em-flow-link-outline {\r\n    cursor: pointer;\r\n}\r\n.em-flow-labels {\r\n    font-size: 15px;\r\n    stroke-width: 1px;\r\n    fill: black;\r\n    pointer-events: none;\r\n}\r\n.em-flow-labels-halo {\r\n    font-size: 15px;\r\n    stroke-width: 2px;\r\n    fill: white;\r\n    pointer-events: none;\r\n}\r\n\r\n.em-grid-rect,\r\n.em-grid-hexagon {\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.estat-vis-tooltip-text {
    background: #ffffff;
    color: #171a22;
    padding: 4px;
    font-size: 16px;
}
.estat-vis-tooltip-bar {
    background: #515560;
    color: #ffffff;
    padding: 6px;
    font-size: 16px;
}
.tooltip-eurostat {
    font-family: Arial;
    max-width: 250px;
    overflow: hidden;
    background: white;
    padding: 0px;
    border: 0px;
    border-radius: 0px;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);
    position: absolute;
    font-family: Helvetica, Arial, sans-serif;
    pointer-events: none;
    opacity: 0;
    z-index: 99999999;
}
.em-tooltip-piechart-breakdown {
    padding: 10px;
    font-size: 14px;
}
.em-tooltip-piechart-container {
    text-align: center;
}
`, "",{"version":3,"sources":["webpack://./src/css/tooltip.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,gBAAgB;IAChB,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,kBAAkB;IAClB,2EAA2E;IAC3E,kBAAkB;IAClB,yCAAyC;IACzC,oBAAoB;IACpB,UAAU;IACV,iBAAiB;AACrB;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,kBAAkB;AACtB","sourcesContent":[".estat-vis-tooltip-text {\r\n    background: #ffffff;\r\n    color: #171a22;\r\n    padding: 4px;\r\n    font-size: 16px;\r\n}\r\n.estat-vis-tooltip-bar {\r\n    background: #515560;\r\n    color: #ffffff;\r\n    padding: 6px;\r\n    font-size: 16px;\r\n}\r\n.tooltip-eurostat {\r\n    font-family: Arial;\r\n    max-width: 250px;\r\n    overflow: hidden;\r\n    background: white;\r\n    padding: 0px;\r\n    border: 0px;\r\n    border-radius: 0px;\r\n    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);\r\n    position: absolute;\r\n    font-family: Helvetica, Arial, sans-serif;\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    z-index: 99999999;\r\n}\r\n.em-tooltip-piechart-breakdown {\r\n    padding: 10px;\r\n    font-size: 14px;\r\n}\r\n.em-tooltip-piechart-container {\r\n    text-align: center;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/world.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#g_worldbn,
.em-worldrg,
.em-worldbn {
    stroke-linecap: round;
    stroke-linejoin: round;
}

.em-worldbn {
    stroke: #000;
    stroke-width: 0.3px;
}

.em-worldbn {
    fill: none;
}

.em-worldrg {
    fill: #efefef;
    cursor: pointer;
}

.em-bn-d {
    /* disputed */
    stroke: #000;
    stroke-width: 0.1;
    fill: none;
}
`, "",{"version":3,"sources":["webpack://./src/css/world.css"],"names":[],"mappings":"AAAA;;;IAGI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA;IACI,UAAU;AACd;;AAEA;IACI,aAAa;IACb,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,iBAAiB;IACjB,UAAU;AACd","sourcesContent":["#g_worldbn,\r\n.em-worldrg,\r\n.em-worldbn {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n.em-worldbn {\r\n    stroke: #000;\r\n    stroke-width: 0.3px;\r\n}\r\n\r\n.em-worldbn {\r\n    fill: none;\r\n}\r\n\r\n.em-worldrg {\r\n    fill: #efefef;\r\n    cursor: pointer;\r\n}\r\n\r\n.em-bn-d {\r\n    /* disputed */\r\n    stroke: #000;\r\n    stroke-width: 0.1;\r\n    fill: none;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bisectCenter: () => (/* binding */ bisectCenter),
/* harmony export */   bisectLeft: () => (/* binding */ bisectLeft),
/* harmony export */   bisectRight: () => (/* binding */ bisectRight),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_number_js__WEBPACK_IMPORTED_MODULE_2__["default"]).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-array/src/descending.js");



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"] || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extent)
/* harmony export */ });
function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}


/***/ }),

/***/ "./node_modules/d3-array/src/fsum.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/fsum.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adder: () => (/* binding */ Adder),
/* harmony export */   fcumsum: () => (/* binding */ fcumsum),
/* harmony export */   fsum: () => (/* binding */ fsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "./node_modules/d3-array/src/greatest.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/greatest.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ greatest)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");


function greatest(values, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, maxValue) > 0
          : (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/maxIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/maxIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxIndex)
/* harmony export */ });
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/minIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/minIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minIndex)
/* harmony export */ });
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number),
/* harmony export */   numbers: () => (/* binding */ numbers)
/* harmony export */ });
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ permute)
/* harmony export */ });
function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   quantileIndex: () => (/* binding */ quantileIndex),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maxIndex.js */ "./node_modules/d3-array/src/maxIndex.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./minIndex.js */ "./node_modules/d3-array/src/minIndex.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "./node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");
/* harmony import */ var _greatest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./greatest.js */ "./node_modules/d3-array/src/greatest.js");









function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantileIndex(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)));
  if (p <= 0) return (0,_minIndex_js__WEBPACK_IMPORTED_MODULE_4__["default"])(numbers);
  if (p >= 1) return (0,_maxIndex_js__WEBPACK_IMPORTED_MODULE_5__["default"])(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  (0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(index, i, 0, j, (i, j) => (0,_sort_js__WEBPACK_IMPORTED_MODULE_6__.ascendingDefined)(numbers[i], numbers[j]));
  i = (0,_greatest_js__WEBPACK_IMPORTED_MODULE_7__["default"])(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/quickselect.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-array/src/quickselect.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? _sort_js__WEBPACK_IMPORTED_MODULE_0__.ascendingDefined : (0,_sort_js__WEBPACK_IMPORTED_MODULE_0__.compareDefined)(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ range)
/* harmony export */ });
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sort.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/sort.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascendingDefined: () => (/* binding */ ascendingDefined),
/* harmony export */   compareDefined: () => (/* binding */ compareDefined),
/* harmony export */   "default": () => (/* binding */ sort)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _permute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./permute.js */ "./node_modules/d3-array/src/permute.js");



function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return (0,_permute_js__WEBPACK_IMPORTED_MODULE_0__["default"])(values, index);
  }
  return values.sort(compareDefined(f));
}

function compareDefined(compare = _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
  if (compare === _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}


/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sum)
/* harmony export */ });
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ticks),
/* harmony export */   tickIncrement: () => (/* binding */ tickIncrement),
/* harmony export */   tickStep: () => (/* binding */ tickStep)
/* harmony export */ });
const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log10(step)),
      error = step / Math.pow(10, power),
      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}

function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
  }
  return ticks;
}

function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}

function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/axis.js":
/*!******************************************!*\
  !*** ./node_modules/d3-axis/src/axis.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   axisBottom: () => (/* binding */ axisBottom),
/* harmony export */   axisLeft: () => (/* binding */ axisLeft),
/* harmony export */   axisRight: () => (/* binding */ axisRight),
/* harmony export */   axisTop: () => (/* binding */ axisTop)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-axis/src/identity.js");


var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + x + ",0)";
}

function translateY(y) {
  return "translate(0," + y + ")";
}

function number(scale) {
  return d => +scale(d);
}

function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return d => +scale(d) + offset;
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + offset,
        range1 = +range[range.length - 1] + offset,
        position = (scale.bandwidth ? center : number)(scale.copy(), offset),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient === right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d) + offset); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = Array.from(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  axis.offset = function(_) {
    return arguments.length ? (offset = +_, axis) : offset;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/identity.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-axis/src/identity.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ brighter),
/* harmony export */   darker: () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hcl: () => (/* binding */ Hcl),
/* harmony export */   Lab: () => (/* binding */ Lab),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   gray: () => (/* binding */ gray),
/* harmony export */   hcl: () => (/* binding */ hcl),
/* harmony export */   lch: () => (/* binding */ lch)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   radians: () => (/* binding */ radians)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csvFormat: () => (/* binding */ csvFormat),
/* harmony export */   csvFormatBody: () => (/* binding */ csvFormatBody),
/* harmony export */   csvFormatRow: () => (/* binding */ csvFormatRow),
/* harmony export */   csvFormatRows: () => (/* binding */ csvFormatRows),
/* harmony export */   csvFormatValue: () => (/* binding */ csvFormatValue),
/* harmony export */   csvParse: () => (/* binding */ csvParse),
/* harmony export */   csvParseRows: () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tsvFormat: () => (/* binding */ tsvFormat),
/* harmony export */   tsvFormatBody: () => (/* binding */ tsvFormatBody),
/* harmony export */   tsvFormatRow: () => (/* binding */ tsvFormatRow),
/* harmony export */   tsvFormatRows: () => (/* binding */ tsvFormatRows),
/* harmony export */   tsvFormatValue: () => (/* binding */ tsvFormatValue),
/* harmony export */   tsvParse: () => (/* binding */ tsvParse),
/* harmony export */   tsvParseRows: () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csv: () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   tsv: () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_3__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-force/src/collide.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/jiggle.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force/src/lcg.js":
/*!******************************************!*\
  !*** ./node_modules/d3-force/src/lcg.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force/src/simulation.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["default"])("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/x.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/y.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatPrefix: () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatDecimalParts: () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   prefixExponent: () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatSpecifier: () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionFixed.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionFixed.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionPrefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionPrefix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionRound.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionRound.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(step)) + 1;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adder: () => (/* binding */ Adder),
/* harmony export */   fcumsum: () => (/* binding */ fcumsum),
/* harmony export */   fsum: () => (/* binding */ fsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cartesian: () => (/* binding */ cartesian),
/* harmony export */   cartesianAddInPlace: () => (/* binding */ cartesianAddInPlace),
/* harmony export */   cartesianCross: () => (/* binding */ cartesianCross),
/* harmony export */   cartesianDot: () => (/* binding */ cartesianDot),
/* harmony export */   cartesianNormalizeInPlace: () => (/* binding */ cartesianNormalizeInPlace),
/* harmony export */   cartesianScale: () => (/* binding */ cartesianScale),
/* harmony export */   spherical: () => (/* binding */ spherical)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circleStream: () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   haversin: () => (/* binding */ haversin),
/* harmony export */   hypot: () => (/* binding */ hypot),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");




function longitude(point) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi)
    return point[0];
  else
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  var sum = new d3_array__WEBPACK_IMPORTED_MODULE_1__.Adder();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) ^ (winding & 1);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fitExtent: () => (/* binding */ fitExtent),
/* harmony export */   fitHeight: () => (/* binding */ fitHeight),
/* harmony export */   fitSize: () => (/* binding */ fitSize),
/* harmony export */   fitWidth: () => (/* binding */ fitWidth)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   projectionMutator: () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"], // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"], // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"]), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rotateRadians: () => (/* binding */ rotateRadians)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   arcosh: () => (/* binding */ arcosh),
/* harmony export */   arsinh: () => (/* binding */ arsinh),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   cosh: () => (/* binding */ cosh),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sinci: () => (/* binding */ sinci),
/* harmony export */   sinh: () => (/* binding */ sinh),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   sqrt1_2: () => (/* binding */ sqrt1_2),
/* harmony export */   sqrt2: () => (/* binding */ sqrt2),
/* harmony export */   sqrtPi: () => (/* binding */ sqrtPi),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tanh: () => (/* binding */ tanh),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/robinson.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/robinson.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   robinsonRaw: () => (/* binding */ robinsonRaw)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/src/math.js");



var K = [
  [0.9986, -0.062],
  [1.0000, 0.0000],
  [0.9986, 0.0620],
  [0.9954, 0.1240],
  [0.9900, 0.1860],
  [0.9822, 0.2480],
  [0.9730, 0.3100],
  [0.9600, 0.3720],
  [0.9427, 0.4340],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.8350, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1.0000]
];

K.forEach(function(d) {
  d[1] *= 1.0144;
});

function robinsonRaw(lambda, phi) {
  var i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) * 36 / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i),
      di = i - i0,
      ax = (k = K[i0])[0],
      ay = k[1],
      bx = (k = K[++i0])[0],
      by = k[1],
      cx = (k = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, ++i0)])[0],
      cy = k[1],
      k;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    (phi > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}

robinsonRaw.invert = function(x, y) {
  var yy = y / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
      phi = yy * 90,
      i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi / 5)),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i));
  do {
    var ay = K[i0][1],
        by = K[i0 + 1][1],
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1],
        u = cy - ay,
        v = cy - 2 * by + ay,
        t = 2 * ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(yy) - by) / u,
        c = v / u,
        di = t * (1 - c * t * (1 - 2 * c * t));
    if (di >= 0 || i0 === 1) {
      phi = (y >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) / 5);
        i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i);
        di = i - i0;
        ay = K[i0][1];
        by = K[i0 + 1][1];
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1];
        phi -= (delta = (y >= 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
      } while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K[i0][0],
      bx = K[i0 + 1][0],
      cx = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][0];
  return [
    x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])(robinsonRaw)
      .scale(152.63);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/cartesian.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/cartesian.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cartesian: () => (/* binding */ cartesian),
/* harmony export */   cartesianAddInPlace: () => (/* binding */ cartesianAddInPlace),
/* harmony export */   cartesianCross: () => (/* binding */ cartesianCross),
/* harmony export */   cartesianDot: () => (/* binding */ cartesianDot),
/* harmony export */   cartesianNormalizeInPlace: () => (/* binding */ cartesianNormalizeInPlace),
/* harmony export */   cartesianScale: () => (/* binding */ cartesianScale),
/* harmony export */   spherical: () => (/* binding */ spherical)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "./node_modules/d3-geo/src/stream.js");





var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(cx, cy, cz),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 = 0;
  X2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Y2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Z2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, centroidStream);

  var x = +X2,
      y = +Y2,
      z = +Z2,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) x = X0, y = Y0, z = Z0;
    m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / m) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
}


/***/ }),

/***/ "./node_modules/d3-geo/src/circle.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/circle.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circleStream: () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "./node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(2),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/antimeridian.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/antimeridian.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/circle.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/circle.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "./node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 2 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/merge.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rectangle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rectangle.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rejoin.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rejoin.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/compose.js":
/*!********************************************!*\
  !*** ./node_modules/d3-geo/src/compose.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/constant.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/constant.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graticule),
/* harmony export */   graticule10: () => (/* binding */ graticule10)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X)
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function(x) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(x))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function(y) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   haversin: () => (/* binding */ haversin),
/* harmony export */   hypot: () => (/* binding */ hypot),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
    areaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(areaRingSum));
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (areaStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (centroidStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathContext)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};


/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure.js */ "./node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-geo/src/path/string.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  let digits = 3,
      pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
    return _area_js__WEBPACK_IMPORTED_MODULE_1__["default"].result();
  };

  path.measure = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _measure_js__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.bounds = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function(_) {
    if (!arguments.length) return projection;
    projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_5__["default"]) : (projection = _).stream;
    return path;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_6__["default"](digits)) : new _context_js__WEBPACK_IMPORTED_MODULE_7__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  path.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) digits = null;
    else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    if (context === null) contextStream = new _string_js__WEBPACK_IMPORTED_MODULE_6__["default"](digits);
    return path;
  };

  return path.projection(projection).digits(digits).context(context);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/measure.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lengthStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathString)
/* harmony export */ });
// Simple caching for constant-radius points.
let cacheDigits, cacheAppend, cacheRadius, cacheCircle;

class PathString {
  constructor(digits) {
    this._append = digits == null ? append : appendRound(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x, y) {
    switch (this._point) {
      case 0: {
        this._append`M${x},${y}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x},${y}`;
        break;
      }
      default: {
        this._append`M${x},${y}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s = this._;
          this._ = ""; // stash the old string so we can cache the circle path fragment
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
}

function append(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15) return append;
  if (d !== cacheDigits) {
    const k = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k) / k + strings[i];
      }
    };
  }
  return cacheAppend;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/polygonContains.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo/src/polygonContains.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");




function longitude(point) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? point[0] : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  var sum = new d3_array__WEBPACK_IMPORTED_MODULE_1__.Adder();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) ^ (winding & 1);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthal.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   azimuthalInvert: () => (/* binding */ azimuthalInvert),
/* harmony export */   azimuthalRaw: () => (/* binding */ azimuthalRaw)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x),
        cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y),
        k = scale(cx * cy);
        if (k === Infinity) return [2, 0];
    return [
      k * cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x),
      k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + y * y),
        c = angle(z),
        sc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(c),
        cc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(c);
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x * sc, z * cc),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(z && y * sc / z)
    ];
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fitExtent: () => (/* binding */ fitExtent),
/* harmony export */   fitHeight: () => (/* binding */ fitHeight),
/* harmony export */   fitSize: () => (/* binding */ fitSize),
/* harmony export */   fitWidth: () => (/* binding */ fitWidth)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians, sa = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.sin)(alpha), ca = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.cos)(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_3__.degrees;
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitExtent)(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitSize)(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitWidth)(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitHeight)(projection, height, object);
  };

  return projection;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   projectionMutator: () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "./node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "./node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "./node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"], // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"], // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"]), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/orthographic.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/orthographic.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   orthographicRaw: () => (/* binding */ orthographicRaw)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");




function orthographicRaw(x, y) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)];
}

orthographicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math_js__WEBPACK_IMPORTED_MODULE_0__.asin);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/resample.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/resample.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/rotation.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/rotation.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rotateRadians: () => (/* binding */ rotateRadians)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) lambda -= Math.round(lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  return [lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    lambda += deltaLambda;
    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) lambda -= Math.round(lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    return [lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   genericArray: () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return ((0,_numberArray_js__WEBPACK_IMPORTED_MODULE_0__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ piecewise)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_2__["default"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_4__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_2__["default"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_6__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_6__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_7__.genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathRound: () => (/* binding */ pathRound)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}

class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x, y) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y) {
    this._append`L${this._x1 = +x},${this._y1 = +y}`;
  }
  quadraticCurveTo(x1, y1, x, y) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    }

    // Otherwise, draw an arc!
    else {
      let x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }

      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
    }
  }
  rect(x, y, w, h) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}

function path() {
  return new Path;
}

// Allow instanceof d3.path
path.prototype = Path.prototype;

function pathRound(digits = 3) {
  return new Path(+digits);
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set3.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/category10.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/category10.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/colors.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/colors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/ramp.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/ramp.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scheme => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.rgbBasis)(scheme[scheme.length - 1]));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale/src/band.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/band.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ band),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _ordinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ordinal.js */ "./node_modules/d3-scale/src/ordinal.js");




function band() {
  var scale = (0,_ordinal_js__WEBPACK_IMPORTED_MODULE_0__["default"])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}


/***/ }),

/***/ "./node_modules/d3-scale/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constants)
/* harmony export */ });
function constants(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-scale/src/continuous.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/continuous.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (/* binding */ continuous),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/src/number.js");





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"],
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initInterpolator: () => (/* binding */ initInterpolator),
/* harmony export */   initRange: () => (/* binding */ initRange)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/linear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/linear.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ linear),
/* harmony export */   linearish: () => (/* binding */ linearish)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickFormat.js */ "./node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat_js__WEBPACK_IMPORTED_MODULE_1__["default"])(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, linear());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number)
/* harmony export */ });
function number(x) {
  return +x;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/ordinal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/ordinal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ordinal),
/* harmony export */   implicit: () => (/* binding */ implicit)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/internmap/src/index.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



const implicit = Symbol("implicit");

function ordinal() {
  var index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    let i = index.get(d);
    if (i === undefined) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap();
    for (const value of _) {
      if (index.has(value)) continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/pow.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/pow.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pow),
/* harmony export */   powish: () => (/* binding */ powish),
/* harmony export */   sqrt: () => (/* binding */ sqrt)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantize.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantize.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantize)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_linear_js__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/threshold.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/threshold.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ threshold)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/tickFormat.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/tickFormat.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tickFormat)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");



function tickFormat(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__["default"])(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__["default"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__["default"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_creator_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([(0,_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(arc);

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle. If this
        // intersection fails, it’s probably because the arc is too small, so
        // disable the corner radius entirely.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
                lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
            rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(area);

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bump.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bump.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpRadial: () => (/* binding */ bumpRadial),
/* harmony export */   bumpX: () => (/* binding */ bumpX),
/* harmony export */   bumpY: () => (/* binding */ bumpY)
/* harmony export */ });
/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");


class Bump {
  constructor(context, x) {
    this._context = context;
    this._x = x;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x, y);
        else this._context.moveTo(x, y);
        break;
      }
      case 1: this._point = 2; // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
        break;
      }
    }
    this._x0 = x, this._y0 = y;
  }
}

class BumpRadial {
  constructor(context) {
    this._context = context;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {}
  point(x, y) {
    x = +x, y = +y;
    if (this._point === 0) {
      this._point = 1;
    } else {
      const p0 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0);
      const p1 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0 = (this._y0 + y) / 2);
      const p2 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, this._y0);
      const p3 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, y);
      this._context.moveTo(...p0);
      this._context.bezierCurveTo(...p1, ...p2, ...p3);
    }
    this._x0 = x, this._y0 = y;
  }
}

function bumpX(context) {
  return new Bump(context, true);
}

function bumpY(context) {
  return new Bump(context, false);
}

function bumpRadial(context) {
  return new BumpRadial(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/identity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(line);

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/link.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   link: () => (/* binding */ link),
/* harmony export */   linkHorizontal: () => (/* binding */ linkHorizontal),
/* harmony export */   linkRadial: () => (/* binding */ linkRadial),
/* harmony export */   linkVertical: () => (/* binding */ linkVertical)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_bump_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curve/bump.js */ "./node_modules/d3-shape/src/curve/bump.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  let source = linkSource,
      target = linkTarget,
      x = _point_js__WEBPACK_IMPORTED_MODULE_0__.x,
      y = _point_js__WEBPACK_IMPORTED_MODULE_0__.y,
      context = null,
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.withPath)(link);

  function link() {
    let buffer;
    const argv = _array_js__WEBPACK_IMPORTED_MODULE_2__.slice.call(arguments);
    const s = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null) output = curve(buffer = path());
    output.lineStart();
    argv[0] = s, output.point(+x.apply(this, argv), +y.apply(this, argv));
    argv[0] = t, output.point(+x.apply(this, argv), +y.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
  };

  return link;
}

function linkHorizontal() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpX);
}

function linkVertical() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpY);
}

function linkRadial() {
  const l = link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/path.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   withPath: () => (/* binding */ withPath)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");


function withPath(shape) {
  let digits = 3;

  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };

  return () => new d3_path__WEBPACK_IMPORTED_MODULE_0__.Path(digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pie.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/pie.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      sortValues = _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0),
      endAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0);

  function pie(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pointRadial.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/pointRadial.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-shape/src/symbol.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Symbol),
/* harmony export */   symbolsFill: () => (/* binding */ symbolsFill),
/* harmony export */   symbolsStroke: () => (/* binding */ symbolsStroke)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/asterisk.js */ "./node_modules/d3-shape/src/symbol/asterisk.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/diamond2.js */ "./node_modules/d3-shape/src/symbol/diamond2.js");
/* harmony import */ var _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbol/plus.js */ "./node_modules/d3-shape/src/symbol/plus.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/square2.js */ "./node_modules/d3-shape/src/symbol/square2.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/triangle2.js */ "./node_modules/d3-shape/src/symbol/triangle2.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol/times.js */ "./node_modules/d3-shape/src/symbol/times.js");
















// These symbols are designed to be filled.
const symbolsFill = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__["default"]
];

// These symbols are designed to be stroked (with a width of 1.5px and round caps).
const symbolsStroke = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__["default"]
];

function Symbol(type, size) {
  let context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_13__.withPath)(symbol);

  type = typeof type === "function" ? type : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  size = typeof size === "function" ? size : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(size === undefined ? 64 : +size);

  function symbol() {
    let buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/asterisk.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/asterisk.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u = t * sqrt3;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u, -t);
    context.lineTo(u, t);
    context.moveTo(-u, t);
    context.lineTo(u, -t);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/circle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/cross.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/cross.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const tan30 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(1 / 3);
const tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / tan30_2);
    const x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond2.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond2.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/plus.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/plus.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const w = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size);
    const x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square2.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square2.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/star.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/star.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const ka = 0.89081309152928522810;
const kr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10);
const kx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;
const ky = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size * ka);
    const x = kx * r;
    const y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (let i = 1; i < 5; ++i) {
      const a = _math_js__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5;
      const c = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a);
      const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/times.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/times.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle2.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle2.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.6824;
    const t = s  / 2;
    const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
    context.moveTo(0, -s);
    context.lineTo(u, t);
    context.lineTo(-u, t);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/wye.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/wye.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const c = -0.5;
const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3) / 2;
const k = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(12);
const a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / a);
    const x0 = r / 2, y0 = r * k;
    const x1 = x0, y1 = r * k + r;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/indexRollupNext.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-svg-annotation/indexRollupNext.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotation: () => (/* binding */ annotation),
/* harmony export */   annotationBadge: () => (/* binding */ d3Badge),
/* harmony export */   annotationCallout: () => (/* binding */ d3Callout),
/* harmony export */   annotationCalloutCircle: () => (/* binding */ d3CalloutCircle),
/* harmony export */   annotationCalloutCurve: () => (/* binding */ d3CalloutCurve),
/* harmony export */   annotationCalloutElbow: () => (/* binding */ d3CalloutElbow),
/* harmony export */   annotationCalloutRect: () => (/* binding */ d3CalloutRect),
/* harmony export */   annotationCustomType: () => (/* binding */ customType),
/* harmony export */   annotationLabel: () => (/* binding */ d3Label),
/* harmony export */   annotationTypeBase: () => (/* binding */ Type),
/* harmony export */   annotationXYThreshold: () => (/* binding */ d3XYThreshold),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js");
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");





var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Annotation = function () {
  function Annotation(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === undefined ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === undefined ? 0 : _ref$y,
        nx = _ref.nx,
        ny = _ref.ny,
        _ref$dy = _ref.dy,
        dy = _ref$dy === undefined ? 0 : _ref$dy,
        _ref$dx = _ref.dx,
        dx = _ref$dx === undefined ? 0 : _ref$dx,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? "grey" : _ref$color,
        data = _ref.data,
        type = _ref.type,
        subject = _ref.subject,
        connector = _ref.connector,
        note = _ref.note,
        disable = _ref.disable,
        id = _ref.id,
        className = _ref.className;
    classCallCheck(this, Annotation);

    this._dx = nx !== undefined ? nx - x : dx;
    this._dy = ny !== undefined ? ny - y : dy;
    this._x = x;
    this._y = y;
    this._color = color;
    this.id = id;
    this._className = className || "";

    this._type = type || "";
    this.data = data;

    this.note = note || {};
    this.connector = connector || {};
    this.subject = subject || {};

    this.disable = disable || [];
  }

  createClass(Annotation, [{
    key: "updatePosition",
    value: function updatePosition() {
      if (this.type.setPosition) {
        this.type.setPosition();
        if (this.type.subject && this.type.subject.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawSubject();
        }
      }
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.type.clearComponents && this.type.clearComponents();
    }
  }, {
    key: "updateOffset",
    value: function updateOffset() {
      if (this.type.setOffset) {
        this.type.setOffset();

        if (this.type.connector.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawConnector();
        }

        this.type.redrawNote();
      }
    }
  }, {
    key: "className",
    get: function get$$1() {
      return this._className;
    },
    set: function set$$1(className) {
      this._className = className;
      if (this.type.setClassName) this.type.setClassName();
    }
  }, {
    key: "type",
    get: function get$$1() {
      return this._type;
    },
    set: function set$$1(type) {
      this._type = type;
      this.clearComponents();
    }
  }, {
    key: "x",
    get: function get$$1() {
      return this._x;
    },
    set: function set$$1(x) {
      this._x = x;
      this.updatePosition();
    }
  }, {
    key: "y",
    get: function get$$1() {
      return this._y;
    },
    set: function set$$1(y) {
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "color",
    get: function get$$1() {
      return this._color;
    },
    set: function set$$1(color) {
      this._color = color;
      this.updatePosition();
    }
  }, {
    key: "dx",
    get: function get$$1() {
      return this._dx;
    },
    set: function set$$1(dx) {
      this._dx = dx;
      this.updateOffset();
    }
  }, {
    key: "dy",
    get: function get$$1() {
      return this._dy;
    },
    set: function set$$1(dy) {
      this._dy = dy;
      this.updateOffset();
    }
  }, {
    key: "nx",
    set: function set$$1(nx) {
      this._dx = nx - this._x;
      this.updateOffset();
    }
  }, {
    key: "ny",
    set: function set$$1(ny) {
      this._dy = ny - this._y;
      this.updateOffset();
    }
  }, {
    key: "offset",
    get: function get$$1() {
      return { x: this._dx, y: this._dy };
    },
    set: function set$$1(_ref2) {
      var x = _ref2.x,
          y = _ref2.y;

      this._dx = x;
      this._dy = y;
      this.updateOffset();
    }
  }, {
    key: "position",
    get: function get$$1() {
      return { x: this._x, y: this._y };
    },
    set: function set$$1(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      this._x = x;
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "translation",
    get: function get$$1() {
      return {
        x: this._x + this._dx,
        y: this._y + this._dy
      };
    }
  }, {
    key: "json",
    get: function get$$1() {
      var json = {
        x: this._x,
        y: this._y,
        dx: this._dx,
        dy: this._dy
      };

      if (this.data && Object.keys(this.data).length > 0) json.data = this.data;
      if (this.type) json.type = this.type;
      if (this._className) json.className = this._className;

      if (Object.keys(this.connector).length > 0) json.connector = this.connector;
      if (Object.keys(this.subject).length > 0) json.subject = this.subject;
      if (Object.keys(this.note).length > 0) json.note = this.note;

      return json;
    }
  }]);
  return Annotation;
}();

var AnnotationCollection = function () {
  function AnnotationCollection(_ref) {
    var annotations = _ref.annotations,
        accessors = _ref.accessors,
        accessorsInverse = _ref.accessorsInverse;
    classCallCheck(this, AnnotationCollection);

    this.accessors = accessors;
    this.accessorsInverse = accessorsInverse;
    this.annotations = annotations;
  }

  createClass(AnnotationCollection, [{
    key: "clearTypes",
    value: function clearTypes(newSettings) {
      this.annotations.forEach(function (d) {
        d.type = undefined;
        d.subject = newSettings && newSettings.subject || d.subject;
        d.connector = newSettings && newSettings.connector || d.connector;
        d.note = newSettings && newSettings.note || d.note;
      });
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors() {
      var _this = this;

      this.annotations.forEach(function (d) {
        d.type.setPositionWithAccessors(_this.accessors);
      });
    }
  }, {
    key: "editMode",
    value: function editMode(_editMode) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.editMode = _editMode;
          a.type.updateEditMode();
        }
      });
    }
  }, {
    key: "updateDisable",
    value: function updateDisable(disable) {
      this.annotations.forEach(function (a) {
        a.disable = disable;
        if (a.type) {
          disable.forEach(function (d) {
            if (a.type[d]) {
              a.type[d].remove && a.type[d].remove();
              a.type[d] = undefined;
            }
          });
        }
      });
    }
  }, {
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.updateTextWrap) {
          a.type.updateTextWrap(textWrap);
        }
      });
    }
  }, {
    key: "updateText",
    value: function updateText() {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.drawText) {
          a.type.drawText();
        }
      });
    }
  }, {
    key: "updateNotePadding",
    value: function updateNotePadding(notePadding) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.notePadding = notePadding;
        }
      });
    }
  }, {
    key: "json",
    get: function get$$1() {
      var _this2 = this;

      return this.annotations.map(function (a) {
        var json = a.json;
        if (_this2.accessorsInverse && a.data) {
          json.data = {};
          Object.keys(_this2.accessorsInverse).forEach(function (k) {
            json.data[k] = _this2.accessorsInverse[k]({ x: a.x, y: a.y });

            //TODO make this feasible to map back to data for other types of subjects
          });
        }
        return json;
      });
    }
  }, {
    key: "noteNodes",
    get: function get$$1() {
      return this.annotations.map(function (a) {
        return _extends({}, a.type.getNoteBBoxOffset(), { positionX: a.x, positionY: a.y });
      });
    }

    //TODO: come back and rethink if a.x and a.y are applicable in all situations
    // get connectorNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))
    // }

    // get subjectNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))
    // }

    // get annotationNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))
    // }

  }]);
  return AnnotationCollection;
}();

var pointHandle = function pointHandle(_ref) {
  var _ref$cx = _ref.cx,
      cx = _ref$cx === undefined ? 0 : _ref$cx,
      _ref$cy = _ref.cy,
      cy = _ref$cy === undefined ? 0 : _ref$cy;

  return { move: { x: cx, y: cy } };
};

var circleHandles = function circleHandles(_ref2) {
  var _ref2$cx = _ref2.cx,
      cx = _ref2$cx === undefined ? 0 : _ref2$cx,
      _ref2$cy = _ref2.cy,
      cy = _ref2$cy === undefined ? 0 : _ref2$cy,
      r1 = _ref2.r1,
      r2 = _ref2.r2,
      padding = _ref2.padding;

  var h = { move: { x: cx, y: cy } };

  if (r1 !== undefined) {
    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
  }

  if (r2 !== undefined) {
    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
  }

  if (padding !== undefined) {
    h.padding = { x: cx + r1 + padding, y: cy };
  }

  return h;
};





//arc handles
var addHandles = function addHandles(_ref5) {
  var group = _ref5.group,
      handles = _ref5.handles,
      _ref5$r = _ref5.r,
      r = _ref5$r === undefined ? 10 : _ref5$r;

  //give it a group and x,y to draw handles
  //then give it instructions on what the handles change
  var h = group.selectAll("circle.handle").data(handles);

  h.enter().append("circle").attr("class", "handle").attr("fill", "grey").attr("fill-opacity", 0.1).attr("cursor", "move").attr("stroke-dasharray", 5).attr("stroke", "grey").call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
    return d.start && d.start(d);
  }).on("drag", function (d) {
    return d.drag && d.drag(d);
  }).on("end", function (d) {
    return d.end && d.end(d);
  }));

  group.selectAll("circle.handle").attr("cx", function (d) {
    return d.x;
  }).attr("cy", function (d) {
    return d.y;
  }).attr("r", function (d) {
    return d.r || r;
  }).attr("class", function (d) {
    return "handle " + (d.className || "");
  });

  h.exit().remove();
};

var leftRightDynamic = function leftRightDynamic(align, y) {
  if (align === "dynamic" || align === "left" || align === "right") {
    if (y < 0) {
      align = "top";
    } else {
      align = "bottom";
    }
  }
  return align;
};

var topBottomDynamic = function topBottomDynamic(align, x) {
  if (align === "dynamic" || align === "top" || align === "bottom") {
    if (x < 0) {
      align = "right";
    } else {
      align = "left";
    }
  }
  return align;
};

var orientationTopBottom = ["topBottom", "top", "bottom"];
var orientationLeftRight = ["leftRight", "left", "right"];

var noteAlignment = (function (_ref) {
  var _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$bbox = _ref.bbox,
      bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
      align = _ref.align,
      orientation = _ref.orientation,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

  var x = -bbox.x;
  var y = 0; //-bbox.y
  if (orientationTopBottom.indexOf(orientation) !== -1) {
    align = topBottomDynamic(align, offset.x);
    if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
      y -= bbox.height + padding;
    } else {
      y += padding;
    }

    if (align === "middle") {
      x -= bbox.width / 2;
    } else if (align === "right") {
      x -= bbox.width;
    }
  } else if (orientationLeftRight.indexOf(orientation) !== -1) {
    align = leftRightDynamic(align, offset.y);
    if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
      x -= bbox.width + padding;
    } else {
      x += padding;
    }

    if (align === "middle") {
      y -= bbox.height / 2;
    } else if (align === "top") {
      y -= bbox.height;
    }
  }

  return { x: x, y: y };
});

var lineBuilder = function lineBuilder(_ref) {
  var data = _ref.data,
      _ref$curve = _ref.curve,
      curve = _ref$curve === undefined ? d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveLinear : _ref$curve,
      canvasContext = _ref.canvasContext,
      className = _ref.className,
      classID = _ref.classID;

  var lineGen = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.line)().curve(curve);

  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {
    builder.attrs = {
      d: lineGen(data)
    };
  }

  return builder;
};

var arcBuilder = function arcBuilder(_ref2) {
  var data = _ref2.data,
      canvasContext = _ref2.canvasContext,
      className = _ref2.className,
      classID = _ref2.classID;


  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  var arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.arc)().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

  if (canvasContext) {
    arcShape.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {

    builder.attrs = {
      d: arcShape()
    };
  }

  return builder;
};

var noteVertical = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      bbox = _ref.bbox,
      offset = _ref.offset;

  align = leftRightDynamic(align, offset.y);

  if (align === "top") {
    y -= bbox.height;
  } else if (align === "middle") {
    y -= bbox.height / 2;
  }

  var data = [[x, y], [x, y + bbox.height]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var noteHorizontal = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      offset = _ref.offset,
      bbox = _ref.bbox;

  align = topBottomDynamic(align, offset.x);

  if (align === "right") {
    x -= bbox.width;
  } else if (align === "middle") {
    x -= bbox.width / 2;
  }

  var data = [[x, y], [x + bbox.width, y]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var lineSetup = function lineSetup(_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;

  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    var angle = Math.asin(-y2 / h);
    var r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0);

    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
  }

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  return [[x1, y1], [x2, y2]];
};

var connectorLine = (function (connectorData) {
  var data = lineSetup(connectorData);
  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorElbow = (function (_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;


  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  var data = [[x1, y1], [x2, y2]];

  var diffY = y2 - y1;
  var diffX = x2 - x1;
  var xe = x2;
  var ye = y2;
  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

  if (Math.abs(diffX) < Math.abs(diffY)) {
    xe = x2;
    ye = y1 + diffX * opposite;
  } else {
    ye = y2;
    xe = x1 + diffY * opposite;
  }

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0);
    var length = r / Math.sqrt(2);

    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
      x1 = length * (x2 < 0 ? -1 : 1);
      y1 = length * (y2 < 0 ? -1 : 1);
      data = [[x1, y1], [xe, ye], [x2, y2]];
    } else if (Math.abs(diffX) > Math.abs(diffY)) {
      var angle = Math.asin(-y2 / r);
      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      data = [[x1, y2], [x2, y2]];
    } else {
      var _angle = Math.acos(x2 / r);
      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
      data = [[x2, y1], [x2, y2]];
    }
  } else {
    data = [[x1, y1], [xe, ye], [x2, y2]];
  }

  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorCurve = (function (_ref) {
  var type = _ref.type,
      connectorData = _ref.connectorData,
      subjectType = _ref.subjectType;


  if (!connectorData) {
    connectorData = {};
  }
  if (!connectorData.points || typeof connectorData.points === "number") {
    connectorData.points = createPoints(type.annotation.offset, connectorData.points);
  }
  if (!connectorData.curve) {
    connectorData.curve = d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveCatmullRom;
  }

  var handles = [];

  if (type.editMode) {
    var cHandles = connectorData.points.map(function (c, i) {
      return _extends({}, pointHandle({ cx: c[0], cy: c[1] }), { index: i });
    });

    var updatePoint = function updatePoint(index) {
      connectorData.points[index][0] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      connectorData.points[index][1] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      type.redrawConnector();
    };

    handles = type.mapHandles(cHandles.map(function (h) {
      return _extends({}, h.move, { drag: updatePoint.bind(type, h.index) });
    }));
  }

  var data = lineSetup({ type: type, subjectType: subjectType });
  data = [data[0]].concat(toConsumableArray(connectorData.points), [data[1]]);
  var components = [lineBuilder({ data: data, curve: connectorData.curve, className: "connector" })];

  return { components: components, handles: handles };
});

var createPoints = function createPoints(offset) {
  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
  var p = [];

  var i = 1;
  for (; i <= anchors; i++) {
    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
  }
  return p;
};

var connectorArrow = (function (_ref) {
  var annotation = _ref.annotation,
      start = _ref.start,
      end = _ref.end,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var offset = annotation.position;
  if (!start) {
    start = [annotation.dx, annotation.dy];
  } else {
    start = [-end[0] + start[0], -end[1] + start[1]];
  }
  if (!end) {
    end = [annotation.x - offset.x, annotation.y - offset.y];
  }

  var x1 = end[0],
      y1 = end[1];

  var dx = start[0];
  var dy = start[1];

  var size = 10 * scale;
  var angleOffset = 16 / 180 * Math.PI;
  var angle = Math.atan(dy / dx);

  if (dx < 0) {
    angle += Math.PI;
  }

  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

  //TODO add in reverse
  // if (canvasContext.arrowReverse){
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // } else {
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // }

  return {
    components: [lineBuilder({
      data: data,
      className: "connector-end connector-arrow",
      classID: "connector-end"
    })]
  };
});

var connectorDot = (function (_ref) {
  var line$$1 = _ref.line,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var dot = arcBuilder({
    className: "connector-end connector-dot",
    classID: "connector-end",
    data: { radius: 3 * Math.sqrt(scale) }
  });
  dot.attrs.transform = "translate(" + line$$1.data[0][0] + ", " + line$$1.data[0][1] + ")";

  return { components: [dot] };
});

var subjectCircle = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.radius && !subjectData.outerRadius) {
    subjectData.radius = 20;
  }

  var handles = [];
  var c = arcBuilder({ data: subjectData, className: "subject" });
  if (type.editMode) {
    var h = circleHandles({
      r1: c.data.outerRadius || c.data.radius,
      r2: c.data.innerRadius,
      padding: subjectData.radiusPadding
    });

    var updateRadius = function updateRadius(attr) {
      var r = subjectData[attr] + d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx * Math.sqrt(2);
      subjectData[attr] = r;
      type.redrawSubject();
      type.redrawConnector();
    };

    var cHandles = [_extends({}, h.r1, {
      drag: updateRadius.bind(type, subjectData.outerRadius !== undefined ? "outerRadius" : "radius")
    })];

    if (subjectData.innerRadius) {
      cHandles.push(_extends({}, h.r2, { drag: updateRadius.bind(type, "innerRadius") }));
    }
    handles = type.mapHandles(cHandles);
  }

  c.attrs["fill-opacity"] = 0;

  return { components: [c], handles: handles };
});

var subjectRect = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.width) {
    subjectData.width = 100;
  }
  if (!subjectData.height) {
    subjectData.height = 100;
  }

  var handles = [];
  var width = subjectData.width,
      height = subjectData.height;


  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
  var rect = lineBuilder({ data: data, className: "subject" });

  if (type.editMode) {
    var updateWidth = function updateWidth() {
      subjectData.width = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x;
      type.redrawSubject();
      type.redrawConnector();
    };

    var updateHeight = function updateHeight() {
      subjectData.height = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y;
      type.redrawSubject();
      type.redrawConnector();
    };

    var rHandles = [{ x: width, y: height / 2, drag: updateWidth.bind(type) }, { x: width / 2, y: height, drag: updateHeight.bind(type) }];

    handles = type.mapHandles(rHandles);
  }
  rect.attrs["fill-opacity"] = 0.1;
  return { components: [rect], handles: handles };
});

var subjectThreshold = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  var offset = type.annotation.position;

  var x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x,
      x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x,
      y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y,
      y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y;

  var data = [[x1, y1], [x2, y2]];
  return { components: [lineBuilder({ data: data, className: 'subject' })] };
});

var subjectBadge = (function (_ref) {
  var _ref$subjectData = _ref.subjectData,
      subjectData = _ref$subjectData === undefined ? {} : _ref$subjectData,
      _ref$type = _ref.type,
      type = _ref$type === undefined ? {} : _ref$type;
  var annotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var typeSettings = type.typeSettings && type.typeSettings.subject;

  if (!subjectData.radius) {
    if (typeSettings && typeSettings.radius) {
      subjectData.radius = typeSettings.radius;
    } else {
      subjectData.radius = 14;
    }
  }
  if (!subjectData.x) {
    if (typeSettings && typeSettings.x) {
      subjectData.x = typeSettings.x;
    }
  }
  if (!subjectData.y) {
    if (typeSettings && typeSettings.y) {
      subjectData.y = typeSettings.y;
    }
  }

  var handles = [];
  var components = [];
  var radius = subjectData.radius;
  var innerRadius = radius * 0.7;
  var x = 0;
  var y = 0;

  var notCornerOffset = Math.sqrt(2) * radius;
  var placement = {
    xleftcorner: -radius,
    xrightcorner: radius,
    ytopcorner: -radius,
    ybottomcorner: radius,
    xleft: -notCornerOffset,
    xright: notCornerOffset,
    ytop: -notCornerOffset,
    ybottom: notCornerOffset
  };

  if (subjectData.x && !subjectData.y) {
    x = placement["x" + subjectData.x];
  } else if (subjectData.y && !subjectData.x) {
    y = placement["y" + subjectData.y];
  } else if (subjectData.x && subjectData.y) {
    x = placement["x" + subjectData.x + "corner"];
    y = placement["y" + subjectData.y + "corner"];
  }

  var transform = "translate(" + x + ", " + y + ")";
  var circlebg = arcBuilder({ className: "subject", data: { radius: radius } });
  circlebg.attrs.transform = transform;
  circlebg.attrs.fill = annotation.color;
  circlebg.attrs["stroke-linecap"] = "round";
  circlebg.attrs["stroke-width"] = "3px";

  var circle = arcBuilder({
    className: "subject-ring",
    data: { outerRadius: radius, innerRadius: innerRadius }
  });

  circle.attrs.transform = transform;
  // circle.attrs.fill = annotation.color
  circle.attrs["stroke-width"] = "3px";
  circle.attrs.fill = "white";

  var pointer = void 0;
  if (x && y || !x && !y) {
    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
    });
  } else if (x || y) {
    var notCornerPointerXY = function notCornerPointerXY(v) {
      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
    };

    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
    });
  }

  if (pointer) {
    pointer.attrs.fill = annotation.color;
    pointer.attrs["stroke-linecap"] = "round";
    pointer.attrs["stroke-width"] = "3px";
    components.push(pointer);
  }

  if (type.editMode) {
    var dragBadge = function dragBadge() {
      subjectData.x = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x < -radius * 2 ? "left" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x > radius * 2 ? "right" : undefined;
      subjectData.y = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y < -radius * 2 ? "top" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y > radius * 2 ? "bottom" : undefined;

      type.redrawSubject();
    };

    var bHandles = { x: x * 2, y: y * 2, drag: dragBadge.bind(type) };
    if (!bHandles.x && !bHandles.y) {
      bHandles.y = -radius;
    }

    handles = type.mapHandles([bHandles]);
  }

  var text = void 0;
  if (subjectData.text) {
    text = {
      type: "text",
      className: "badge-text",
      attrs: {
        fill: "white",
        stroke: "none",
        "font-size": ".7em",
        text: subjectData.text,
        "text-anchor": "middle",
        dy: ".25em",
        x: x,
        y: y
      }
    };
  }

  components.push(circlebg);
  components.push(circle);
  components.push(text);

  return { components: components, handles: handles };
});

//Note options
//Connector options
//Subject options
var Type = function () {
  function Type(_ref) {
    var a = _ref.a,
        annotation = _ref.annotation,
        editMode = _ref.editMode,
        dispatcher = _ref.dispatcher,
        notePadding = _ref.notePadding,
        accessors = _ref.accessors;
    classCallCheck(this, Type);

    this.a = a;

    this.note = annotation.disable.indexOf("note") === -1 && a.select("g.annotation-note");
    this.noteContent = this.note && a.select("g.annotation-note-content");
    this.connector = annotation.disable.indexOf("connector") === -1 && a.select("g.annotation-connector");
    this.subject = annotation.disable.indexOf("subject") === -1 && a.select("g.annotation-subject");
    this.dispatcher = dispatcher;

    if (dispatcher) {
      var handler = addHandlers.bind(null, dispatcher, annotation);
      handler({ component: this.note, name: "note" });
      handler({ component: this.connector, name: "connector" });
      handler({ component: this.subject, name: "subject" });
    }

    this.annotation = annotation;
    this.editMode = annotation.editMode || editMode;
    this.notePadding = notePadding !== undefined ? notePadding : 3;
    this.offsetCornerX = 0;
    this.offsetCornerY = 0;

    if (accessors && annotation.data) {
      this.init(accessors);
    }
  }

  createClass(Type, [{
    key: "init",
    value: function init(accessors) {
      if (!this.annotation.x) {
        this.mapX(accessors);
      }
      if (!this.annotation.y) {
        this.mapY(accessors);
      }
    }
  }, {
    key: "mapY",
    value: function mapY(accessors) {
      if (accessors.y) {
        this.annotation.y = accessors.y(this.annotation.data);
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      if (accessors.x) {
        this.annotation.x = accessors.x(this.annotation.data);
      }
    }
  }, {
    key: "updateEditMode",
    value: function updateEditMode() {
      this.a.selectAll("circle.handle").remove();
    }
  }, {
    key: "drawOnSVG",
    value: function drawOnSVG(component, builders) {
      var _this = this;

      if (!Array.isArray(builders)) {
        builders = [builders];
      }

      builders.filter(function (b) {
        return b;
      }).forEach(function (_ref2) {
        var type = _ref2.type,
            className = _ref2.className,
            attrs = _ref2.attrs,
            handles = _ref2.handles,
            classID = _ref2.classID;

        if (type === "handle") {
          addHandles({ group: component, r: attrs && attrs.r, handles: handles });
        } else {
          newWithClass(component, [_this.annotation], type, className, classID);
          var el = component.select(type + "." + (classID || className));
          var addAttrs = Object.keys(attrs);
          var removeAttrs = [];

          var currentAttrs = el.node().attributes;
          for (var i = currentAttrs.length - 1; i >= 0; i--) {
            var name = currentAttrs[i].name;
            if (addAttrs.indexOf(name) === -1 && name !== "class") removeAttrs.push(name);
          }

          addAttrs.forEach(function (attr) {
            if (attr === "text") {
              el.text(attrs[attr]);
            } else {
              el.attr(attr, attrs[attr]);
            }
          });

          removeAttrs.forEach(function (attr) {
            return el.attr(attr, null);
          });
        }
      });
    }

    //TODO: how to extend this to a drawOnCanvas mode?

  }, {
    key: "getNoteBBox",
    value: function getNoteBBox() {
      return bboxWithoutHandles(this.note, ".annotation-note-content text");
    }
  }, {
    key: "getNoteBBoxOffset",
    value: function getNoteBBoxOffset() {
      var bbox = bboxWithoutHandles(this.note, ".annotation-note-content");
      var transform = this.noteContent.attr("transform").split(/\(|\,|\)/g);
      bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx;
      bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy;
      bbox.offsetX = this.annotation.dx;
      bbox.offsetY = this.annotation.dy;
      return bbox;
    }
  }, {
    key: "drawSubject",
    value: function drawSubject() {
      var _this2 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var subjectData = this.annotation.subject;
      var type = context.type;
      var subjectParams = { type: this, subjectData: subjectData };

      var subject = {};
      if (type === "circle") subject = subjectCircle(subjectParams);else if (type === "rect") subject = subjectRect(subjectParams);else if (type === "threshold") subject = subjectThreshold(subjectParams);else if (type === "badge") subject = subjectBadge(subjectParams, this.annotation);

      var _subject = subject,
          _subject$components = _subject.components,
          components = _subject$components === undefined ? [] : _subject$components,
          _subject$handles = _subject.handles,
          handles = _subject$handles === undefined ? [] : _subject$handles;

      components.forEach(function (c) {
        if (c && c.attrs && !c.attrs.stroke) {
          c.attrs.stroke = _this2.annotation.color;
        }
      });

      if (this.editMode) {
        handles = handles.concat(this.mapHandles([{ drag: this.dragSubject.bind(this) }]));
        components.push({ type: "handle", handles: handles });
      }

      return components;
    }
  }, {
    key: "drawConnector",
    value: function drawConnector() {
      var _this3 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var connectorData = this.annotation.connector;
      var type = connectorData.type || context.type;
      var connectorParams = { type: this, connectorData: connectorData };
      connectorParams.subjectType = this.typeSettings && this.typeSettings.subject && this.typeSettings.subject.type;

      var connector = {};
      if (type === "curve") connector = connectorCurve(connectorParams);else if (type === "elbow") connector = connectorElbow(connectorParams);else connector = connectorLine(connectorParams);
      var _connector = connector,
          _connector$components = _connector.components,
          components = _connector$components === undefined ? [] : _connector$components,
          _connector$handles = _connector.handles,
          handles = _connector$handles === undefined ? [] : _connector$handles;

      var line$$1 = components[0];
      //TODO: genericize this into fill t/f stroke t/f
      if (line$$1) {
        line$$1.attrs.stroke = this.annotation.color;
        line$$1.attrs.fill = "none";
      }
      var endType = connectorData.end || context.end;
      var end = {};
      if (endType === "arrow") {
        var s = line$$1.data[1];
        var e = line$$1.data[0];
        var distance = Math.sqrt(Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2));
        if (distance < 5 && line$$1.data[2]) {
          s = line$$1.data[2];
        }
        end = connectorArrow({
          annotation: this.annotation,
          start: s,
          end: e,
          scale: connectorData.endScale
        });
      } else if (endType === "dot") {
        end = connectorDot({ line: line$$1, scale: connectorData.endScale });
      } else if (!endType || endType === "none") {
        this.connector && this.connector.select(".connector-end").remove();
      }

      if (end.components) {
        end.components.forEach(function (c) {
          c.attrs.fill = _this3.annotation.color;
          c.attrs.stroke = _this3.annotation.color;
        });
        components = components.concat(end.components);
      }

      if (this.editMode) {
        if (handles.length !== 0) components.push({ type: "handle", handles: handles });
      }
      return components;
    }
  }, {
    key: "drawNote",
    value: function drawNote() {
      var _this4 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var noteData = this.annotation.note;
      var align = noteData.align || context.align || "dynamic";
      var noteParams = {
        bbox: context.bbox,
        align: align,
        offset: this.annotation.offset
      };
      var lineType = noteData.lineType || context.lineType;
      var note = {};
      if (lineType === "vertical") note = noteVertical(noteParams);else if (lineType === "horizontal") note = noteHorizontal(noteParams);

      var _note = note,
          _note$components = _note.components,
          components = _note$components === undefined ? [] : _note$components,
          _note$handles = _note.handles,
          handles = _note$handles === undefined ? [] : _note$handles;

      components.forEach(function (c) {
        c.attrs.stroke = _this4.annotation.color;
      });

      if (this.editMode) {
        handles = this.mapHandles([{ x: 0, y: 0, drag: this.dragNote.bind(this) }]);
        components.push({ type: "handle", handles: handles });

        var dragging = this.dragNote.bind(this),
            start = this.dragstarted.bind(this),
            end = this.dragended.bind(this);
        this.note.call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
          return start(d);
        }).on("drag", function (d) {
          return dragging(d);
        }).on("end", function (d) {
          return end(d);
        }));
      } else {
        this.note.on("mousedown.drag", null);
      }
      return components;
    }
  }, {
    key: "drawNoteContent",
    value: function drawNoteContent(context) {
      var noteData = this.annotation.note;
      var padding = noteData.padding !== undefined ? noteData.padding : this.notePadding;
      var orientation = noteData.orientation || context.orientation || "topBottom";
      var lineType = noteData.lineType || context.lineType;
      var align = noteData.align || context.align || "dynamic";

      if (lineType === "vertical") orientation = "leftRight";else if (lineType === "horizontal") orientation = "topBottom";

      var noteParams = {
        padding: padding,
        bbox: context.bbox,
        offset: this.annotation.offset,
        orientation: orientation,
        align: align
      };

      var _noteAlignment = noteAlignment(noteParams),
          x = _noteAlignment.x,
          y = _noteAlignment.y;

      this.offsetCornerX = x + this.annotation.dx;
      this.offsetCornerY = y + this.annotation.dy;
      this.note && this.noteContent.attr("transform", "translate(" + x + ", " + y + ")");

      return [];
    }
  }, {
    key: "drawOnScreen",
    value: function drawOnScreen(component, drawFunction) {
      return this.drawOnSVG(component, drawFunction);
    }
  }, {
    key: "redrawSubject",
    value: function redrawSubject() {
      this.subject && this.drawOnScreen(this.subject, this.drawSubject());
    }
  }, {
    key: "redrawConnector",
    value: function redrawConnector() {
      this.connector && this.drawOnScreen(this.connector, this.drawConnector());
    }
  }, {
    key: "redrawNote",
    value: function redrawNote() {
      var bbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNoteBBox();

      this.noteContent && this.drawOnScreen(this.noteContent, this.drawNoteContent({ bbox: bbox }));
      this.note && this.drawOnScreen(this.note, this.drawNote({ bbox: bbox }));
    }
  }, {
    key: "setPosition",
    value: function setPosition() {
      var position = this.annotation.position;
      this.a.attr("transform", "translate(" + position.x + ", " + position.y + ")");
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.subject && this.subject.select("*").remove();
      this.connector && this.connector.select("*").remove();
      // this.note && this.note.select("*").remove()
    }
  }, {
    key: "setOffset",
    value: function setOffset() {
      if (this.note) {
        var offset = this.annotation.offset;
        this.note.attr("transform", "translate(" + offset.x + ", " + offset.y + ")");
      }
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors(accessors) {
      if (accessors && this.annotation.data) {
        this.mapX(accessors);
        this.mapY(accessors);
      }
      this.setPosition();
    }
  }, {
    key: "setClassName",
    value: function setClassName() {
      this.a.attr("class", "annotation " + (this.className && this.className()) + " " + (this.editMode ? "editable" : "") + " " + (this.annotation.className || ""));
    }
  }, {
    key: "draw",
    value: function draw() {
      this.setClassName();
      this.setPosition();
      this.setOffset();
      this.redrawSubject();
      this.redrawConnector();
      this.redrawNote();
    }
  }, {
    key: "dragstarted",
    value: function dragstarted() {
      d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.sourceEvent.stopPropagation();
      this.dispatcher && this.dispatcher.call("dragstart", this.a, this.annotation);
      this.a.classed("dragging", true);
      this.a.selectAll("circle.handle").style("pointer-events", "none");
    }
  }, {
    key: "dragended",
    value: function dragended() {
      this.dispatcher && this.dispatcher.call("dragend", this.a, this.annotation);
      this.a.classed("dragging", false);
      this.a.selectAll("circle.handle").style("pointer-events", "all");
    }
  }, {
    key: "dragSubject",
    value: function dragSubject() {
      var position = this.annotation.position;
      position.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      position.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.position = position;
    }
  }, {
    key: "dragNote",
    value: function dragNote() {
      var offset = this.annotation.offset;
      offset.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      offset.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.offset = offset;
    }
  }, {
    key: "mapHandles",
    value: function mapHandles(handles) {
      var _this5 = this;

      return handles.map(function (h) {
        return _extends({}, h, {
          start: _this5.dragstarted.bind(_this5),
          end: _this5.dragended.bind(_this5)
        });
      });
    }
  }]);
  return Type;
}();

var customType = function customType(initialType, typeSettings, _init) {
  return function (_initialType) {
    inherits(customType, _initialType);

    function customType(settings) {
      classCallCheck(this, customType);

      var _this6 = possibleConstructorReturn(this, (customType.__proto__ || Object.getPrototypeOf(customType)).call(this, settings));

      _this6.typeSettings = typeSettings;

      if (typeSettings.disable) {
        typeSettings.disable.forEach(function (d) {
          _this6[d] && _this6[d].remove();

          _this6[d] = undefined;
          if (d === "note") {
            _this6.noteContent = undefined;
          }
        });
      }
      return _this6;
    }

    createClass(customType, [{
      key: "className",
      value: function className() {
        return "" + (typeSettings.className || get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this) && get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this).call(this) || "");
      }
    }, {
      key: "drawSubject",
      value: function drawSubject(context) {
        this.typeSettings.subject = _extends({}, typeSettings.subject, this.typeSettings.subject);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawSubject", this).call(this, _extends({}, context, this.typeSettings.subject));
      }
    }, {
      key: "drawConnector",
      value: function drawConnector(context) {
        this.typeSettings.connector = _extends({}, typeSettings.connector, this.typeSettings.connector);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawConnector", this).call(this, _extends({}, context, typeSettings.connector, this.typeSettings.connector));
      }
    }, {
      key: "drawNote",
      value: function drawNote(context) {
        this.typeSettings.note = _extends({}, typeSettings.note, this.typeSettings.note);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNote", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }, {
      key: "drawNoteContent",
      value: function drawNoteContent(context) {
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNoteContent", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }], [{
      key: "init",
      value: function init(annotation, accessors) {
        get(customType.__proto__ || Object.getPrototypeOf(customType), "init", this).call(this, annotation, accessors);
        if (_init) {
          annotation = _init(annotation, accessors);
        }
        return annotation;
      }
    }]);
    return customType;
  }(initialType);
};

var d3NoteText = function (_Type) {
  inherits(d3NoteText, _Type);

  function d3NoteText(params) {
    classCallCheck(this, d3NoteText);

    var _this7 = possibleConstructorReturn(this, (d3NoteText.__proto__ || Object.getPrototypeOf(d3NoteText)).call(this, params));

    _this7.textWrap = params.textWrap || 120;
    _this7.drawText();
    return _this7;
  }

  createClass(d3NoteText, [{
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.textWrap = textWrap;
      this.drawText();
    }

    //TODO: add update text functionality

  }, {
    key: "drawText",
    value: function drawText() {
      if (this.note) {
        newWithClass(this.note, [this.annotation], "g", "annotation-note-content");

        var noteContent = this.note.select("g.annotation-note-content");
        newWithClass(noteContent, [this.annotation], "rect", "annotation-note-bg");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-label");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-title");

        var titleBBox = { height: 0 };
        var label = this.a.select("text.annotation-note-label");
        var wrapLength = this.annotation.note && this.annotation.note.wrap || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrap || this.textWrap;

        var wrapSplitter = this.annotation.note && this.annotation.note.wrapSplitter || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrapSplitter;

        var bgPadding = this.annotation.note && this.annotation.note.bgPadding || this.typeSettings && this.typeSettings.note && this.typeSettings.note.bgPadding;

        var bgPaddingFinal = { top: 0, bottom: 0, left: 0, right: 0 };
        if (typeof bgPadding === "number") {
          bgPaddingFinal = {
            top: bgPadding,
            bottom: bgPadding,
            left: bgPadding,
            right: bgPadding
          };
        } else if (bgPadding && (typeof bgPadding === "undefined" ? "undefined" : _typeof(bgPadding)) === "object") {
          bgPaddingFinal = _extends(bgPaddingFinal, bgPadding);
        }

        if (this.annotation.note.title) {
          var title = this.a.select("text.annotation-note-title");
          title.text(this.annotation.note.title);
          title.attr("fill", this.annotation.color);
          title.attr("font-weight", "bold");
          title.call(wrap, wrapLength, wrapSplitter);
          titleBBox = title.node().getBBox();
        }

        label.text(this.annotation.note.label).attr("dx", "0");
        label.call(wrap, wrapLength, wrapSplitter);

        label.attr("y", titleBBox.height * 1.1 || 0);
        label.attr("fill", this.annotation.color);

        var bbox = this.getNoteBBox();

        this.a.select("rect.annotation-note-bg").attr("width", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right).attr("height", bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom).attr("x", bbox.x - bgPaddingFinal.left).attr("y", -bgPaddingFinal.top).attr("fill", "white").attr("fill-opacity", 0);
      }
    }
  }]);
  return d3NoteText;
}(Type);

var d3Label = customType(d3NoteText, {
  className: "label",
  note: { align: "middle" }
});

var d3Callout = customType(d3NoteText, {
  className: "callout",
  note: { lineType: "horizontal" }
});

var d3CalloutElbow = customType(d3Callout, {
  className: "callout elbow",
  connector: { type: "elbow" }
});

var d3CalloutCurve = customType(d3Callout, {
  className: "callout curve",
  connector: { type: "curve" }
});

var d3Badge = customType(Type, {
  className: "badge",
  subject: { type: "badge" },
  disable: ["connector", "note"]
});

var d3CalloutCircle = customType(d3NoteText, {
  className: "callout circle",
  subject: { type: "circle" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var d3CalloutRect = customType(d3NoteText, {
  className: "callout rect",
  subject: { type: "rect" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var ThresholdMap = function (_d3Callout) {
  inherits(ThresholdMap, _d3Callout);

  function ThresholdMap() {
    classCallCheck(this, ThresholdMap);
    return possibleConstructorReturn(this, (ThresholdMap.__proto__ || Object.getPrototypeOf(ThresholdMap)).apply(this, arguments));
  }

  createClass(ThresholdMap, [{
    key: "mapY",
    value: function mapY(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapY", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {
        a.y = accessors.y(a.data);
      }
      if ((a.subject.x1 || a.subject.x2) && !a.x) {
        a.x = a.subject.x1 || a.subject.x2;
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapX", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {
        a.x = accessors.x(a.data);
      }
      if ((a.subject.y1 || a.subject.y2) && !a.y) {
        a.y = a.subject.y1 || a.subject.y2;
      }
    }
  }]);
  return ThresholdMap;
}(d3Callout);

var d3XYThreshold = customType(ThresholdMap, {
  className: "callout xythreshold",
  subject: { type: "threshold" }
});

var newWithClass = function newWithClass(a, d, type, className, classID) {
  var group = a.selectAll(type + "." + (classID || className)).data(d);
  group.enter().append(type).merge(group).attr("class", className);

  group.exit().remove();
  return a;
};

var addHandlers = function addHandlers(dispatcher, annotation, _ref3) {
  var component = _ref3.component,
      name = _ref3.name;

  if (component) {
    component.on("mouseover.annotations", function () {
      dispatcher.call(name + "over", component, annotation);
    }).on("mouseout.annotations", function () {
      return dispatcher.call(name + "out", component, annotation);
    }).on("click.annotations", function () {
      return dispatcher.call(name + "click", component, annotation);
    });
  }
};

//Text wrapping code adapted from Mike Bostock
var wrap = function wrap(text, width, wrapSplitter) {
  var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.2;

  text.each(function () {
    var text = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this),
        words = text.text().split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
      return w !== "";
    });
    var word = void 0,
        line$$1 = [],
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", 0.8 + "em");

    while (word = words.pop()) {
      line$$1.push(word);
      tspan.text(line$$1.join(" "));
      if (tspan.node().getComputedTextLength() > width && line$$1.length > 1) {
        line$$1.pop();
        tspan.text(line$$1.join(" "));
        line$$1 = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + "em").text(word);
      }
    }
  });
};

var bboxWithoutHandles = function bboxWithoutHandles(selection) {
  var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ":not(.handle)";

  if (!selection) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }

  return selection.selectAll(selector).nodes().reduce(function (p, c) {
    var bbox = c.getBBox();
    p.x = Math.min(p.x, bbox.x);
    p.y = Math.min(p.y, bbox.y);
    p.width = Math.max(p.width, bbox.width);

    var yOffset = c && c.attributes && c.attributes.y;
    p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
    return p;
  }, { x: 0, y: 0, width: 0, height: 0 });
};

function annotation() {
  var annotations = [],
      collection = void 0,
      context = void 0,
      //TODO: add canvas functionality
  disable = [],
      accessors = {},
      accessorsInverse = {},
      editMode = false,
      ids = void 0,
      type = d3Callout,
      textWrap = void 0,
      notePadding = void 0,
      annotationDispatcher = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_3__.dispatch)("subjectover", "subjectout", "subjectclick", "connectorover", "connectorout", "connectorclick", "noteover", "noteout", "noteclick", "dragend", "dragstart"),
      sel = void 0;

  var annotation = function annotation(selection) {
    sel = selection;
    //TODO: check to see if this is still needed
    if (!editMode) {
      selection.selectAll("circle.handle").remove();
    }

    var translatedAnnotations = annotations.map(function (a) {
      if (!a.type) {
        a.type = type;
      }
      if (!a.disable) {
        a.disable = disable;
      }
      return new Annotation(a);
    });

    collection = collection || new AnnotationCollection({
      annotations: translatedAnnotations,
      accessors: accessors,
      accessorsInverse: accessorsInverse,
      ids: ids
    });

    var annotationG = selection.selectAll("g").data([collection]);
    annotationG.enter().append("g").attr("class", "annotations");

    var group = selection.select("g.annotations");
    newWithClass(group, collection.annotations, "g", "annotation");

    var annotation = group.selectAll("g.annotation");

    annotation.each(function (d) {
      var a = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this);

      a.attr("class", "annotation");

      newWithClass(a, [d], "g", "annotation-connector");
      newWithClass(a, [d], "g", "annotation-subject");
      newWithClass(a, [d], "g", "annotation-note");
      newWithClass(a.select("g.annotation-note"), [d], "g", "annotation-note-content");
      d.type = d.type.toString() === "[object Object]" ? d.type : new d.type({
        a: a,
        annotation: d,
        textWrap: textWrap,
        notePadding: notePadding,
        editMode: editMode,
        dispatcher: annotationDispatcher,
        accessors: accessors
      });
      d.type.draw();
      d.type.drawText && d.type.drawText();
    });
  };

  annotation.json = function () {
    /* eslint-disable no-console */
    console.log("Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.", collection.json);
    /* eslint-enable no-console */
    window.copy(JSON.stringify(collection.json.map(function (a) {
      delete a.type;
      return a;
    })));
    return annotation;
  };

  annotation.update = function () {
    if (annotations && collection) {
      annotations = collection.annotations.map(function (a) {
        a.type.draw();
        return a;
      });
    }
    return annotation;
  };

  annotation.updateText = function () {
    if (collection) {
      collection.updateText(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.updatedAccessors = function () {
    collection.setPositionWithAccessors();
    annotations = collection.annotations;
    return annotation;
  };

  annotation.disable = function (_) {
    if (!arguments.length) return disable;
    disable = _;
    if (collection) {
      collection.updateDisable(disable);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    if (collection) {
      collection.updateTextWrap(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.notePadding = function (_) {
    if (!arguments.length) return notePadding;
    notePadding = _;
    if (collection) {
      collection.updateNotePadding(notePadding);
      annotations = collection.annotations;
    }
    return annotation;
  };
  //todo think of how to handle when undefined is sent
  annotation.type = function (_, settings) {
    if (!arguments.length) return type;
    type = _;
    if (collection) {
      collection.annotations.map(function (a) {
        a.type.note && a.type.note.selectAll("*:not(.annotation-note-content)").remove();
        a.type.noteContent && a.type.noteContent.selectAll("*").remove();
        a.type.subject && a.type.subject.selectAll("*").remove();
        a.type.connector && a.type.connector.selectAll("*").remove();
        a.type.typeSettings = {};
        a.type = type;

        a.subject = settings && settings.subject || a.subject;
        a.connector = settings && settings.connector || a.connector;
        a.note = settings && settings.note || a.note;
      });

      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.annotations = function (_) {
    if (!arguments.length) return collection && collection.annotations || annotations;
    annotations = _;

    if (collection && collection.annotations) {
      var rerun = annotations.some(function (d) {
        return !d.type || d.type.toString() !== "[object Object]";
      });

      if (rerun) {
        collection = null;
        annotation(sel);
      } else {
        collection.annotations = annotations;
      }
    }
    return annotation;
  };

  annotation.context = function (_) {
    if (!arguments.length) return context;
    context = _;
    return annotation;
  };

  annotation.accessors = function (_) {
    if (!arguments.length) return accessors;
    accessors = _;
    return annotation;
  };

  annotation.accessorsInverse = function (_) {
    if (!arguments.length) return accessorsInverse;
    accessorsInverse = _;
    return annotation;
  };

  annotation.ids = function (_) {
    if (!arguments.length) return ids;
    ids = _;
    return annotation;
  };

  annotation.editMode = function (_) {
    if (!arguments.length) return editMode;
    editMode = _;

    if (sel) {
      sel.selectAll("g.annotation").classed("editable", editMode);
    }

    if (collection) {
      collection.editMode(editMode);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.collection = function (_) {
    if (!arguments.length) return collection;
    collection = _;
    return annotation;
  };

  annotation.on = function () {
    var value = annotationDispatcher.on.apply(annotationDispatcher, arguments);
    return value === annotationDispatcher ? annotation : value;
  };

  return annotation;
}

var index = {
  annotation: annotation,
  annotationTypeBase: Type,
  annotationLabel: d3Label,
  annotationCallout: d3Callout,
  annotationCalloutCurve: d3CalloutCurve,
  annotationCalloutElbow: d3CalloutElbow,
  annotationCalloutCircle: d3CalloutCircle,
  annotationCalloutRect: d3CalloutRect,
  annotationXYThreshold: d3XYThreshold,
  annotationBadge: d3Badge,
  annotationCustomType: customType
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);
//# sourceMappingURL=indexRollupNext.js.map


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dispatch: () => (/* reexport safe */ _src_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js");



/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.x, y: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__.dispatch)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__.mouse, this, arguments);
    if (!gesture) return;
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
    mousemoving = false;
    mousedownx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX;
    mousedowny = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    if (!mousemoving) {
      var dx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX - mousedownx, dy = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag mouseup.drag", null);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__.yesdrag)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view, mousemoving);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__.touch, this, arguments)) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragEvent)
/* harmony export */ });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drag: () => (/* reexport safe */ _drag__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   dragDisable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   dragEnable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__.yesdrag)
/* harmony export */ });
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");




/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (path);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clientPoint: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   create: () => (/* reexport safe */ _create__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   creator: () => (/* reexport safe */ _creator__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   customEvent: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.customEvent),
/* harmony export */   event: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.event),
/* harmony export */   local: () => (/* reexport safe */ _local__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   matcher: () => (/* reexport safe */ _matcher__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mouse: () => (/* reexport safe */ _mouse__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   namespace: () => (/* reexport safe */ _namespace__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   namespaces: () => (/* reexport safe */ _namespaces__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   select: () => (/* reexport safe */ _select__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   selectAll: () => (/* reexport safe */ _selectAll__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   selection: () => (/* reexport safe */ _selection_index__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   selector: () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   selectorAll: () => (/* reexport safe */ _selectorAll__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   style: () => (/* reexport safe */ _selection_style__WEBPACK_IMPORTED_MODULE_13__.styleValue),
/* harmony export */   touch: () => (/* reexport safe */ _touch__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   touches: () => (/* reexport safe */ _touches__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   window: () => (/* reexport safe */ _window__WEBPACK_IMPORTED_MODULE_16__["default"])
/* harmony export */ });
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js");
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mouse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js");
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _selection_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./touch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js");
/* harmony import */ var _touches__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./touches */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js");
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");




















/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ local)
/* harmony export */ });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  var event = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js");




var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./join */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sort */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./call */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodes */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./node */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./size */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./empty */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./each */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./property */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classed */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./text */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./html */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./raise */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lower */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./append */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./insert */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./datum */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js");
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  join: _join__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_8__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_9__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_10__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_11__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_12__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_13__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_14__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_15__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_16__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_17__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_18__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_19__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_20__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_21__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_22__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_23__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_24__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_25__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_26__["default"],
  clone: _clone__WEBPACK_IMPORTED_MODULE_27__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_28__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_29__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_30__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customEvent: () => (/* binding */ customEvent),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   event: () => (/* binding */ event)
/* harmony export */ });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches) {
  if (touches == null) touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arc: () => (/* reexport safe */ _src_arc__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   area: () => (/* reexport safe */ _src_area__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   curveBasis: () => (/* reexport safe */ _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   curveBasisClosed: () => (/* reexport safe */ _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   curveBasisOpen: () => (/* reexport safe */ _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   curveBundle: () => (/* reexport safe */ _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   curveCardinal: () => (/* reexport safe */ _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   curveCardinalClosed: () => (/* reexport safe */ _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   curveCardinalOpen: () => (/* reexport safe */ _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   curveCatmullRom: () => (/* reexport safe */ _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   curveCatmullRomClosed: () => (/* reexport safe */ _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   curveCatmullRomOpen: () => (/* reexport safe */ _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   curveLinear: () => (/* reexport safe */ _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   curveLinearClosed: () => (/* reexport safe */ _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   curveMonotoneX: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneX),
/* harmony export */   curveMonotoneY: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneY),
/* harmony export */   curveNatural: () => (/* reexport safe */ _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   curveStep: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   curveStepAfter: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepAfter),
/* harmony export */   curveStepBefore: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepBefore),
/* harmony export */   line: () => (/* reexport safe */ _src_line__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   pie: () => (/* reexport safe */ _src_pie__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   radialArea: () => (/* reexport safe */ _src_radialArea__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   radialLine: () => (/* reexport safe */ _src_radialLine__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   stack: () => (/* reexport safe */ _src_stack__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   stackOffsetExpand: () => (/* reexport safe */ _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   stackOffsetNone: () => (/* reexport safe */ _src_offset_none__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   stackOffsetSilhouette: () => (/* reexport safe */ _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   stackOffsetWiggle: () => (/* reexport safe */ _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   stackOrderAscending: () => (/* reexport safe */ _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   stackOrderDescending: () => (/* reexport safe */ _src_order_descending__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   stackOrderInsideOut: () => (/* reexport safe */ _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   stackOrderNone: () => (/* reexport safe */ _src_order_none__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   stackOrderReverse: () => (/* reexport safe */ _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   symbol: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   symbolCircle: () => (/* reexport safe */ _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   symbolCross: () => (/* reexport safe */ _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   symbolDiamond: () => (/* reexport safe */ _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   symbolSquare: () => (/* reexport safe */ _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   symbolStar: () => (/* reexport safe */ _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   symbolTriangle: () => (/* reexport safe */ _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   symbolWye: () => (/* reexport safe */ _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   symbols: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__.symbols)
/* harmony export */ });
/* harmony import */ var _src_arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/arc */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js");
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _src_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _src_pie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pie */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js");
/* harmony import */ var _src_radialArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/radialArea */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js");
/* harmony import */ var _src_radialLine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");
/* harmony import */ var _src_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/symbol */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/curve/basisClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/curve/basisOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/curve/basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/curve/bundle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/curve/cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/curve/cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/curve/cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/curve/catmullRomClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/curve/catmullRomOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/curve/catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/curve/linearClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/curve/monotone */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/curve/natural */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var _src_curve_step__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/curve/step */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var _src_stack__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/stack */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js");
/* harmony import */ var _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/offset/expand */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js");
/* harmony import */ var _src_offset_none__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/offset/silhouette */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js");
/* harmony import */ var _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/offset/wiggle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js");
/* harmony import */ var _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/order/ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");
/* harmony import */ var _src_order_descending__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/order/descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js");
/* harmony import */ var _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/order/insideOut */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js");
/* harmony import */ var _src_order_none__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/order/reverse */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js");












































/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function asin(x) {
  return x >= 1 ? _math__WEBPACK_IMPORTED_MODULE_1__.halfPi : x <= -1 ? -_math__WEBPACK_IMPORTED_MODULE_1__.halfPi : Math.asin(x);
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        da = Math.abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_2__["default"])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math__WEBPACK_IMPORTED_MODULE_1__.tau - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
      context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
          rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var p0 = asin(rp / r0 * Math.sin(ap)),
            p1 = asin(rp / r1 * Math.sin(ap));
        if ((da0 -= p0 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Math.cos(a01),
          y01 = r1 * Math.sin(a01),
          x10 = r0 * Math.cos(a10),
          y10 = r0 * Math.sin(a10);

      // Apply rounded corners?
      if (rc > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var x11 = r1 * Math.cos(a11),
            y11 = r1 * Math.sin(a11),
            x00 = r0 * Math.cos(a00),
            y00 = r0 * Math.sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < _math__WEBPACK_IMPORTED_MODULE_1__.pi) {
          var oc = da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
              lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) || !(da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math__WEBPACK_IMPORTED_MODULE_1__.pi / 2;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x0 = _point__WEBPACK_IMPORTED_MODULE_3__.x,
      x1 = null,
      y0 = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      y1 = _point__WEBPACK_IMPORTED_MODULE_3__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line__WEBPACK_IMPORTED_MODULE_2__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Basis: () => (/* binding */ Basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Basis(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisOpen(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cardinal: () => (/* binding */ Cardinal),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalClosed: () => (/* binding */ CardinalClosed),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalOpen: () => (/* binding */ CardinalOpen),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal__WEBPACK_IMPORTED_MODULE_1__.Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_2__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new LinearClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   monotoneX: () => (/* binding */ monotoneX),
/* harmony export */   monotoneY: () => (/* binding */ monotoneY)
/* harmony export */ });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Natural(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   curveRadialLinear: () => (/* binding */ curveRadialLinear),
/* harmony export */   "default": () => (/* binding */ curveRadial)
/* harmony export */ });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");


var curveRadialLinear = curveRadial(_linear__WEBPACK_IMPORTED_MODULE_0__["default"]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   stepAfter: () => (/* binding */ stepAfter),
/* harmony export */   stepBefore: () => (/* binding */ stepBefore)
/* harmony export */ });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x = _point__WEBPACK_IMPORTED_MODULE_2__.x,
      y = _point__WEBPACK_IMPORTED_MODULE_2__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_3__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sum: () => (/* binding */ sum)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var sums = series.map(sum);
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending__WEBPACK_IMPORTED_MODULE_1__.sum),
      order = (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_2__["default"],
      sortValues = _descending__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      endAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(_math__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _radialLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var a = (0,_area__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return a;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   radialLine: () => (/* binding */ radialLine)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");



function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return radialLine((0,_line__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _offset_none__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _order_none__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var keys = (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([]),
      order = _order_none__WEBPACK_IMPORTED_MODULE_3__["default"],
      offset = _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"],
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? _order_none__WEBPACK_IMPORTED_MODULE_3__["default"] : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"] : _, stack) : offset;
  };

  return stack;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   symbols: () => (/* binding */ symbols)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _symbol_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_star__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye__WEBPACK_IMPORTED_MODULE_6__["default"]
];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var type = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"]),
      size = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_8__["default"])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / Math.sin(7 * _math__WEBPACK_IMPORTED_MODULE_0__.pi / 10),
    kx = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr,
    ky = -Math.cos(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var sqrt3 = Math.sqrt(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./node_modules/idb-keyval/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/idb-keyval/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   createStore: () => (/* binding */ createStore),
/* harmony export */   del: () => (/* binding */ del),
/* harmony export */   delMany: () => (/* binding */ delMany),
/* harmony export */   entries: () => (/* binding */ entries),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   getMany: () => (/* binding */ getMany),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   promisifyRequest: () => (/* binding */ promisifyRequest),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setMany: () => (/* binding */ setMany),
/* harmony export */   update: () => (/* binding */ update),
/* harmony export */   values: () => (/* binding */ values)
/* harmony export */ });
function promisifyRequest(request) {
    return new Promise((resolve, reject) => {
        // @ts-ignore - file size hacks
        request.oncomplete = request.onsuccess = () => resolve(request.result);
        // @ts-ignore - file size hacks
        request.onabort = request.onerror = () => reject(request.error);
    });
}
function createStore(dbName, storeName) {
    let dbp;
    const getDB = () => {
        if (dbp)
            return dbp;
        const request = indexedDB.open(dbName);
        request.onupgradeneeded = () => request.result.createObjectStore(storeName);
        dbp = promisifyRequest(request);
        dbp.then((db) => {
            // It seems like Safari sometimes likes to just close the connection.
            // It's supposed to fire this event when that happens. Let's hope it does!
            db.onclose = () => (dbp = undefined);
        }, () => { });
        return dbp;
    };
    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
    if (!defaultGetStoreFunc) {
        defaultGetStoreFunc = createStore('keyval-store', 'keyval');
    }
    return defaultGetStoreFunc;
}
/**
 * Get a value by its key.
 *
 * @param key
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function get(key, customStore = defaultGetStore()) {
    return customStore('readonly', (store) => promisifyRequest(store.get(key)));
}
/**
 * Set a value with a key.
 *
 * @param key
 * @param value
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function set(key, value, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        store.put(value, key);
        return promisifyRequest(store.transaction);
    });
}
/**
 * Set multiple values at once. This is faster than calling set() multiple times.
 * It's also atomic – if one of the pairs can't be added, none will be added.
 *
 * @param entries Array of entries, where each entry is an array of `[key, value]`.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function setMany(entries, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        entries.forEach((entry) => store.put(entry[1], entry[0]));
        return promisifyRequest(store.transaction);
    });
}
/**
 * Get multiple values by their keys
 *
 * @param keys
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function getMany(keys, customStore = defaultGetStore()) {
    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));
}
/**
 * Update a value. This lets you see the old value and update it as an atomic operation.
 *
 * @param key
 * @param updater A callback that takes the old value and returns a new value.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function update(key, updater, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => 
    // Need to create the promise manually.
    // If I try to chain promises, the transaction closes in browsers
    // that use a promise polyfill (IE10/11).
    new Promise((resolve, reject) => {
        store.get(key).onsuccess = function () {
            try {
                store.put(updater(this.result), key);
                resolve(promisifyRequest(store.transaction));
            }
            catch (err) {
                reject(err);
            }
        };
    }));
}
/**
 * Delete a particular key from the store.
 *
 * @param key
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function del(key, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        store.delete(key);
        return promisifyRequest(store.transaction);
    });
}
/**
 * Delete multiple keys at once.
 *
 * @param keys List of keys to delete.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function delMany(keys, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        keys.forEach((key) => store.delete(key));
        return promisifyRequest(store.transaction);
    });
}
/**
 * Clear all values in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function clear(customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        store.clear();
        return promisifyRequest(store.transaction);
    });
}
function eachCursor(store, callback) {
    store.openCursor().onsuccess = function () {
        if (!this.result)
            return;
        callback(this.result);
        this.result.continue();
    };
    return promisifyRequest(store.transaction);
}
/**
 * Get all keys in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function keys(customStore = defaultGetStore()) {
    return customStore('readonly', (store) => {
        // Fast path for modern browsers
        if (store.getAllKeys) {
            return promisifyRequest(store.getAllKeys());
        }
        const items = [];
        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
    });
}
/**
 * Get all values in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function values(customStore = defaultGetStore()) {
    return customStore('readonly', (store) => {
        // Fast path for modern browsers
        if (store.getAll) {
            return promisifyRequest(store.getAll());
        }
        const items = [];
        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);
    });
}
/**
 * Get all entries in the store. Each entry is an array of `[key, value]`.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function entries(customStore = defaultGetStore()) {
    return customStore('readonly', (store) => {
        // Fast path for modern browsers
        // (although, hopefully we'll get a simpler path some day)
        if (store.getAll && store.getAllKeys) {
            return Promise.all([
                promisifyRequest(store.getAllKeys()),
                promisifyRequest(store.getAll()),
            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));
        }
        const items = [];
        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));
    });
}




/***/ }),

/***/ "./node_modules/internmap/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/internmap/src/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternMap: () => (/* binding */ InternMap),
/* harmony export */   InternSet: () => (/* binding */ InternSet)
/* harmony export */ });
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (entries != null) for (const [key, value] of entries) this.set(key, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}

class InternSet extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (values != null) for (const value of values) this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
}

function intern_get({_intern, _key}, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}

function intern_delete({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}

function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}


/***/ }),

/***/ "./node_modules/jsonstat-toolkit/import.mjs":
/*!**************************************************!*\
  !*** ./node_modules/jsonstat-toolkit/import.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ r)
/* harmony export */ });
// jsonstat-toolkit v1.5.3 Copyright 2024 Xavier Badosa https://jsonstat.com
function t(i,r){var l,s,a,o,u=function(t,i,r){if(0===Object.entries(t).length)return null;var l,s=[];if(r&&!n(r.name)&&(r=null),"string"==typeof t&&(t=[t]),Array.isArray(t)||e(t)){if(t.length===i)return r&&-1===t.findIndex((function(t){return null==t}))?r.from(t):t;if(1===t.length){for(l=0;l<i;l++)s.push(t[0]);return s}}for(l=0;l<i;l++){var a=void 0===t[l]?null:t[l];s.push(a)}return s};if(this.length=0,this.id=[],null!=i)switch(this.class=i.class||"bundle",this.class){case"bundle":var h=[],f=0;if(this.error=null,this.length=0,null===i||"object"!=typeof i)return void(this.class=null);if(i.hasOwnProperty("error"))return void(this.error=i.error);if("dataset"===i.class||"collection"===i.class||"dimension"===i.class)return new t(i);for(s in i)f++,h.push(s);this.__tree__=i,this.length=f,this.id=h;break;case"dataset":i.hasOwnProperty("__tree__")?this.__tree__=l=i.__tree__:this.__tree__=l=i,this.label=l.label||null,this.note=l.note||null,this.link=l.link||null,this.href=l.href||null,this.updated=l.updated||null,this.source=l.source||null,this.extension=l.extension||null;var c,d=0,v=l.size||l.dimension&&l.dimension.size;if(this.size=v,this.value=l.hasOwnProperty("value")&&null!==l.value&&0!==l.value.length?l.value:{},Array.isArray(this.value)||e(this.value))d=this.value.length;else{var y=1;for(c=v.length;c--;)y*=v[c];d=y}if(this.value=u(this.value,d,r),this.status=l.hasOwnProperty("status")&&null!==l.status?u(l.status,d):null,l.hasOwnProperty("dimension")){var p=l.dimension,g=l.role||!l.version&&p.role||null,b=l.id||p.id,m=v.length,_=function(t){g.hasOwnProperty(t)||(g[t]=null)};if(!Array.isArray(b)||!Array.isArray(v)||b.length!=m)return;if(this.length=m,this.id=b,g&&(_("time"),_("geo"),_("metric"),_("classification")),g&&null===g.classification){var x=[],O=["time","geo","metric"],A=function(t,e){for(var n=e.length;n--;)if(t===e[n])return!0;return!1};for(c=0;c<3;c++){var w=g[O[c]];null!==w&&(x=x.concat(w))}for(g.classification=[],c=0;c<m;c++)A(b[c],x)||g.classification.push(b[c]);0===g.classification.length&&(g.classification=null)}this.role=g,this.n=d;for(var j=0,k=this.length;j<k;j++)if(p[b[j]].category.hasOwnProperty("index")){if(Array.isArray(p[b[j]].category.index)){var D={},P=p[b[j]].category.index;for(a=P.length,o=0;o<a;o++)D[P[o]]=o;p[b[j]].category.index=D}}else{var E=0;for(s in p[b[j]].category.index={},p[b[j]].category.label)p[b[j]].category.index[s]=E++}}else this.length=0;break;case"dimension":if(!i.hasOwnProperty("__tree__"))return new t({version:"2.0",class:"dataset",dimension:{d:i},id:["d"],size:[function(t){var e=void 0===t.index?t.label:t.index;return Array.isArray(e)?e.length:Object.keys(e).length}(i.category)],value:[null]}).Dimension(0);var z=[],S=(l=i.__tree__).category;if(!l.hasOwnProperty("category"))return;if(!S.hasOwnProperty("label"))for(s in S.label={},S.index)S.label[s]=s;for(s in S.index)z[S.index[s]]=s;this.__tree__=l,this.label=l.label||null,this.note=l.note||null,this.link=l.link||null,this.href=l.href||null,this.id=z,this.length=z.length,this.role=i.role,this.hierarchy=S.hasOwnProperty("child"),this.extension=l.extension||null;break;case"category":var I=i.child;this.id=I,this.length=null===I?0:I.length,this.index=i.index,this.label=i.label,this.note=i.note||null,this.unit=i.unit,this.coordinates=i.coord;break;case"collection":if(this.length=0,this.label=i.label||null,this.note=i.note||null,this.link=i.link||null,this.href=i.href||null,this.updated=i.updated||null,this.source=i.source||null,this.extension=i.extension||null,null!==this.link&&i.link.item){var C=i.link.item;if(this.length=Array.isArray(C)?C.length:0,this.length)for(o=0;o<this.length;o++)this.id[o]=C[o].href}}}function e(t){return"[object ArrayBuffer]"===Object.prototype.toString.call(t.buffer)}function n(t){return-1!==["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"].indexOf(t)}function i(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.json()}function r(e,n,r){var l="object"==typeof n?n:null;return"function"!=typeof r&&(r=null),r||"function"!=typeof n||(r=n),"object"==typeof e?new t(e,r):"version"===e?"1.5.3":fetch?fetch(e,l).then(i).then((function(e){return new t(e,r)})):void 0}t.prototype.Item=function(t){if(null===this||"collection"!==this.class||!this.length)return null;if("number"==typeof t)return t>this.length||t<0?null:this.link.item[t];var e,n=[];if("object"==typeof t){if(!t.class&&!t.follow)return null;t.class&&(e="dataset"===t.class&&"boolean"==typeof t.embedded?!0===t.embedded?function(t,e,i){var r=t.link.item[e];i.class===r.class&&r.id&&r.size&&r.dimension&&n.push(r)}:function(t,e,i){var r=t.link.item[e];i.class!==r.class||r.id&&r.size&&r.dimension||n.push(r)}:function(t,e,i){i.class===t.link.item[e].class&&n.push(t.link.item[e])})}else e=function(t,e){n.push(t.link.item[e])};for(var i=0;i<this.length;i++)e(this,i,t);return n},t.prototype.Dataset=function(e){if(null===this)return null;if("dataset"===this.class)return void 0!==e?this:[this];var n,i=[],r=0;if("collection"===this.class){var l=this.Item({class:"dataset",embedded:!0});if(void 0===e){for(n=l.length;r<n;r++)i.push(new t(l[r]));return i}if("number"==typeof e&&e>=0&&e<l.length)return new t(l[e]);if("string"==typeof e)for(n=l.length;r<n;r++)if(l[r].href===e)return new t(l[r]);return null}if("bundle"!==this.class)return null;if(void 0===e){for(n=this.id.length;r<n;r++)i.push(this.Dataset(this.id[r]));return i}if("number"==typeof e){var s=this.id[e];return void 0!==s?this.Dataset(s):null}var a=this.__tree__[e];return void 0===a?null:new t({class:"dataset",__tree__:a})},t.prototype.Dimension=function(e,n){n="boolean"!=typeof n||n;var i,r=[],l=this.id.length,s=function(t,e){if(null!==t)for(var n in t)for(var i=null!==t[n]?t[n].length:0;i--;)if(t[n][i]===e)return n;return null};if(null===this||"dataset"!==this.class)return null;if(void 0===e){for(i=0;i<l;i++)r.push(this.Dimension(this.id[i]));return r}if("number"==typeof e){var a=this.id[e];return void 0!==a?this.Dimension(a,n):null}var o=this.role;if("object"==typeof e){if(e.hasOwnProperty("role")){for(i=0;i<l;i++){var u=this.id[i];s(o,u)===e.role&&r.push(this.Dimension(u,n))}return void 0===r[0]?null:r}return null}var h=this.__tree__.dimension;if(void 0===h)return null;var f=h[e];return void 0===f?null:n?new t({class:"dimension",__tree__:f,role:s(o,e)}):function(t,e){var n=[];for(var i in t)n[t[i]]=e[i];return n}(f.category.index,f.category.label)},t.prototype.Category=function(e){if(null===this||"dimension"!==this.class)return null;if(void 0===e){for(var n=[],i=0,r=this.id.length;i<r;i++)n.push(this.Category(this.id[i]));return n}if("number"==typeof e){var l=this.id[e];return void 0!==l?this.Category(l):null}var s=this.__tree__.category;if(void 0===s)return null;var a=s.index[e];if(void 0===a)return null;var o=s.unit&&s.unit[e]||null,u=s.coordinates&&s.coordinates[e]||null,h=s.child&&s.child[e]||null,f=s.note&&s.note[e]||null;return new t({class:"category",index:a,label:s.label[e],note:f,child:h,unit:o,coord:u})},t.prototype.Dice=function(n,i,r){var l,s,a,o,u=function(t,e){return t.hasOwnProperty(e)&&!!t[e]};if(null===this||"dataset"!==this.class||null===this.value)return null;if("object"!=typeof n)return this;"object"!=typeof i?("boolean"==typeof i&&!0===i&&(l=!0),"boolean"==typeof r&&!0===r||(r=!1)):(l=u(i,"clone"),r=u(i,"drop"),s=u(i,"stringify"),a=u(i,"ovalue"),o=u(i,"ostatus"));var h,f=this.value,c=l?new t(JSON.parse(JSON.stringify(this))):this,d=c.status,v=[],y=[],p=function(t,e){var n,i,r,l=(n=t,i=e,r={},Array.isArray(n[i])?(n[i].forEach((function(t,e){null!==t&&(r[String(e)]=t)})),r):n[i]);delete t[e],t[e]=l};Array.isArray(n)&&(n=function(t){var e={};return t.forEach((function(t){e[t[0]]=t[1]})),e}(n)),null===n&&(n={});var g=Object.keys(n);return g.length>0&&(g.forEach((function(t){var e=n[t];Array.isArray(e)||(n[t]=[e]),0===n[t].length&&delete n[t]})),r&&(n=function(t){var e={};return Object.keys(t).forEach((function(n){e[n]=c.Dimension(n).id.filter((function(e){return-1===t[n].indexOf(e)}))})),e}(n)),c.toTable({type:"arrobj",content:"id",status:!0}).forEach((function(t,e){var i=[];g.forEach((function(e){var r=n[e],l=[];r.forEach((function(n){l.push(t[e]===n)})),i.push(-1!==l.indexOf(!0))})),-1===i.indexOf(!1)&&(v.push(t.value),y.push(t.status))})),g.forEach((function(t){var e=c.Dimension(t).id,i=0,r={};c.size[c.id.indexOf(t)]=n[t].length,e.forEach((function(e){-1!==n[t].indexOf(e)&&(r[e]=i,i++)})),c.__tree__.dimension[t].category.index=r})),c.n=v.length,c.value=c.__tree__.value=e(f)?function(t,e){return e.from(t)}(v,f.constructor):v,c.status=c.__tree__.status=null!==d?y:null),s?((h=c.__tree__).hasOwnProperty("id")||(h.version="2.0",h.hasOwnProperty("class")||(h.class="dataset"),h.id=h.dimension.id,h.size=h.dimension.size,delete h.dimension.id,delete h.dimension.size,h.dimension.hasOwnProperty("role")&&(h.role=h.dimension.role,delete h.dimension.role)),h.hasOwnProperty("status")&&-1!==["null","{}","[]"].indexOf(JSON.stringify(h.status))&&delete h.status,h.hasOwnProperty("role")&&(delete h.role.classification,["geo","time","metric"].forEach((function(t){null===h.role[t]&&delete h.role[t]}))),a&&p(h,"value"),o&&h.hasOwnProperty("status")&&p(h,"status"),JSON.stringify(h)):c},t.prototype.Slice=function(t){if(null===this||"dataset"!==this.class||0===Object.entries(this.value).length)return null;if(void 0===t)return this;if(!Array.isArray(t)){var e,n=[];for(e in t)n.push([e,t[e]]);t=n}return this.Dice(t.map((function(t){return[t[0],[t[1]]]})))},t.prototype.Data=function(t,e){var n,i,r=[],l=function(t){for(var e in t)if(t.hasOwnProperty(e))return e};if(null===this||"dataset"!==this.class||null===this.value)return null;if(void 0===t){for(i=this.value.length,n=0;n<i;n++)r.push(this.Data(n));return r}if("boolean"!=typeof e&&(e=!0),"number"==typeof t){var s=this.value[t];return void 0===s?null:e?{value:s,status:this.status?this.status[t]:null}:s}var a="object",o=this.__tree__,u=o.size||o.dimension&&o.dimension.size,h=u.length;if(Array.isArray(t)){if(!Array.isArray(t[0])){if(this.length!==t.length)return null;var f=1,c=0,d=[],v=[];for(n=0;n<h;n++)if(void 0!==t[n]){if("number"!=typeof t[n]||t[n]>=u[n])return null;c+=(f*=n>0?u[h-n]:1)*t[h-n-1]}else d.push(n),v.push(u[n]);if(d.length>1)return null;if(1===d.length){for(var y=0,p=v[0];y<p;y++){var g=[];for(n=0;n<h;n++)n!==d[0]?g.push(t[n]):g.push(y);r.push(this.Data(g,e))}return r}return e?{value:this.value[c],status:this.status?this.status[c]:null}:this.value[c]}a="array"}var b=function(t,e,n){var i,r=[],s={},a=t.dimension,o=t.id||a.id,u=t.size||a&&a.size;if("array"===n){for(i=e.length;i--;)s[e[i][0]]=e[i][1];e=s}for(var h=0,f=o.length;h<f;h++){var c=o[h],d=e[c];r.push("string"==typeof d?d:1===u[h]?l(a[c].category.index):null)}return r}(o,t,a),m=[],_=o.dimension,x=o.id||_.id;for(n=0,i=b.length;n<i;n++)m.push(_[x[n]].category.index[b[n]]);return this.Data(m,e)},t.prototype.toTable=function(t,e){if(null===this||"dataset"!==this.class||null===this.value)return null;1==arguments.length&&"function"==typeof t&&(e=t,t=null),"arrobj"!==(t=t||{field:"label",content:"label",vlabel:"Value",slabel:"Status",type:"array",status:!1,unit:!1,by:null,prefix:"",drop:[],meta:!1,comma:!1,bylabel:!1}).type&&"objarr"!==t.type||void 0!==t.field||(t.field="id");var i,r,l,s,a,o,u,h,f,c="id"===t.field,d=function(t){return(c?"value":t)||"Value"},v=function(t){return(c?"status":t)||"Status"},y=this.__tree__,p=!0===t.status;if("function"==typeof e){i=this.toTable(t);var g=[],b="array"!==t.type?0:1;for(a=(V="object"!==t.type?i.slice(b):i.rows.slice(0)).length,r=0;r<a;r++){var m=e.call(this,V[r],r);void 0!==m&&g.push(m)}return"object"===t.type?{cols:i.cols,rows:g}:("array"===t.type&&g.unshift(i[0]),g)}if("arrobj"===t.type||"objarr"===t.type){var _=[],x=y.role&&y.role.metric,O=function(){},A={},w=this,j=w.id,k=t.by&&-1!==j.indexOf(t.by)?t.by:null,D=!0===t.meta,P=void 0!==t.drop&&Array.isArray(t.drop)?t.drop:[],E=!0===t.comma,z=!0===t.bylabel,S=w.value.constructor,I=function(e){var i,r={},l=d(t.vlabel);if("objarr"===t.type&&(i=null===k&&n(S.name)?function(t){r[t]=t===l?S.from(e,(function(e){return e[t]})):e.map((function(e){return e[t]}))}:function(t){r[t]=e.map((function(e){return e[t]}))},Object.keys(e[0]).forEach(i),e=r),D){r={};return j.forEach((function(t){var e=w.Dimension(t);r[t]={label:e.label,role:e.role,categories:{id:e.id,label:w.Dimension(t,!1)}}})),{meta:{label:w.label,source:w.source,updated:w.updated,id:j,status:p,unit:t.unit,by:k,bylabel:z,drop:null!==k&&P.length>0?P:null,prefix:null!==k?G||"":null,comma:E,dimensions:r},data:e}}return e};k&&(t.field="id");var C=(i=this.toTable({field:t.field,vlabel:t.vlabel,slabel:t.slabel,content:t.content,status:p})).shift();if(null===k&&t.unit&&x){if("id"!==t.content)for(var T=x.length;T--;){var U=this.Dimension(x[T]);A[x[T]]={};for(var J=U.length;J--;)A[x[T]][U.Category(J).label]=U.id[J]}O=function(e,n){if(-1!==x.indexOf(e)){var i=y.dimension[e].category;i.unit?N.unit=i.unit["id"!==t.content?A[e][n]:n]:N.unit=null}},t.unit=!0}else t.unit=!1;for(a=i.length,r=0;r<a;r++){var N={};for(l=i[r].length;l--;)N[C[l]]=i[r][l],O(C[l],i[r][l]);_.push(N)}if(E&&_.forEach((function(t){null!==t.value&&(t.value=(""+t.value).replace(".",","))})),null!==k){var B,F={},V=[],q={},G=void 0!==t.prefix?t.prefix:"";P.forEach((function(t,e){(!w.Dimension(t)||w.Dimension(t).length>1)&&(P[e]="")}));var H=j.filter((function(t){return t!==k&&-1===P.indexOf(t)})),K=w.Dimension(k);for(var L in"id"!==t.content?z?B=function(t,e,n){t[e][G+n[k]]=n.value}:(K.Category().forEach((function(t,e){q[t.label]=K.id[e]})),B=function(t,e,n){t[e][G+q[n[k]]]=n.value}):B=function(t,e,n){t[e][G+n[k]]=n.value},_.forEach((function(t){var e=function(t,e){var n=[];return e.forEach((function(e){n.push(t[e])})),n.join("\t")}(t,H);void 0===F[e]&&(F[e]=function(t,e){var n={};return e.forEach((function(e){n[e]=t[e]})),n}(t,H)),B(F,e,t,k)})),F)V.push(F[L]);return p=!1,I(V)}return I(_)}if("object"===t.type){var M="number"==typeof this.value[0]||null===this.value[0]?"number":"string";o=function(t,e){var n=c&&t||e||t;it.push({id:t,label:n,type:"string"})},u=function(t,e,n){var i=d(t),r=v(e);n&&it.push({id:"status",label:r,type:"string"}),it.push({id:"value",label:i,type:M})},h=function(t){yt.push({v:t})},f=function(t){yt.push({v:t}),rt.push({c:yt})}}else o=function(t,e){var n=c&&t||e||t;it.push(n)},u=function(t,e,n){var i=d(t),r=v(e);n&&it.push(r),it.push(i),nt.push(it)},h=function(t){yt.push(t)},f=function(t){yt.push(t),nt.push(yt)};var Q=y.dimension,R=y.id||Q.id,W=y.size||Q.size,X=R.length;if(X!=W.length)return!1;var Y=[],Z=1,$=(T=1,[]),tt=[],et=[],nt=[],it=[],rt=[];for(r=0;r<X;r++){var lt=R[r];o(lt,Q[lt].label),Z*=W[r],T*=W[r];var st=[];for(l=0;l<W[r];l++)for(var at in Q[R[r]].category.index)if(Q[R[r]].category.index[at]===l){var ot="id"!==t.content&&Q[R[r]].category.label?Q[R[r]].category.label[at]:at;st.push(ot)}Y.push(st),$.push(T)}for(u(t.vlabel,t.slabel,p),a=Y.length,r=0;r<a;r++){for(var ut=[],ht=0,ft=Y[r].length;ht<ft;ht++)for(var ct=0;ct<Z/$[r];ct++)ut.push(Y[r][ht]);tt.push(ut)}for(a=tt.length,r=0;r<a;r++){var dt=[],vt=0;for(s=0;s<Z;s++)dt.push(tt[r][vt]),++vt===tt[r].length&&(vt=0);et.push(dt)}for(s=0;s<Z;s++){var yt=[];a=tt.length;for(var pt=0;pt<a;pt++)h(et[pt][s]);p&&h(this.status?this.status[s]:null),f(this.value[s])}return"object"===t.type?{cols:it,rows:rt}:nt},t.prototype.node=function(){return this.__tree__},t.prototype.toString=function(){return this.class};


/***/ }),

/***/ "./node_modules/simple-statistics/dist/simple-statistics.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/simple-statistics/dist/simple-statistics.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BayesianClassifier: () => (/* binding */ BayesianClassifier),
/* harmony export */   PerceptronModel: () => (/* binding */ PerceptronModel),
/* harmony export */   addToMean: () => (/* binding */ addToMean),
/* harmony export */   approxEqual: () => (/* binding */ approxEqual),
/* harmony export */   average: () => (/* binding */ mean),
/* harmony export */   averageSimple: () => (/* binding */ meanSimple),
/* harmony export */   bayesian: () => (/* binding */ BayesianClassifier),
/* harmony export */   bernoulliDistribution: () => (/* binding */ bernoulliDistribution),
/* harmony export */   binomialDistribution: () => (/* binding */ binomialDistribution),
/* harmony export */   bisect: () => (/* binding */ bisect),
/* harmony export */   chiSquaredDistributionTable: () => (/* binding */ chiSquaredDistributionTable),
/* harmony export */   chiSquaredGoodnessOfFit: () => (/* binding */ chiSquaredGoodnessOfFit),
/* harmony export */   chunk: () => (/* binding */ chunk),
/* harmony export */   ckmeans: () => (/* binding */ ckmeans),
/* harmony export */   coefficientOfVariation: () => (/* binding */ coefficientOfVariation),
/* harmony export */   combinations: () => (/* binding */ combinations),
/* harmony export */   combinationsReplacement: () => (/* binding */ combinationsReplacement),
/* harmony export */   combineMeans: () => (/* binding */ combineMeans),
/* harmony export */   combineVariances: () => (/* binding */ combineVariances),
/* harmony export */   cumulativeStdLogisticProbability: () => (/* binding */ cumulativeStdLogisticProbability),
/* harmony export */   cumulativeStdNormalProbability: () => (/* binding */ cumulativeStdNormalProbability),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   equalIntervalBreaks: () => (/* binding */ equalIntervalBreaks),
/* harmony export */   erf: () => (/* binding */ errorFunction),
/* harmony export */   errorFunction: () => (/* binding */ errorFunction),
/* harmony export */   extent: () => (/* binding */ extent),
/* harmony export */   extentSorted: () => (/* binding */ extentSorted),
/* harmony export */   factorial: () => (/* binding */ factorial),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   gammaln: () => (/* binding */ gammaln),
/* harmony export */   geometricMean: () => (/* binding */ geometricMean),
/* harmony export */   harmonicMean: () => (/* binding */ harmonicMean),
/* harmony export */   interquartileRange: () => (/* binding */ interquartileRange),
/* harmony export */   inverseErrorFunction: () => (/* binding */ inverseErrorFunction),
/* harmony export */   iqr: () => (/* binding */ interquartileRange),
/* harmony export */   jenks: () => (/* binding */ jenks),
/* harmony export */   kMeansCluster: () => (/* binding */ kMeansCluster),
/* harmony export */   kde: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   kernelDensityEstimation: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   linearRegression: () => (/* binding */ linearRegression),
/* harmony export */   linearRegressionLine: () => (/* binding */ linearRegressionLine),
/* harmony export */   logAverage: () => (/* binding */ logAverage),
/* harmony export */   logit: () => (/* binding */ logit),
/* harmony export */   mad: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   maxSorted: () => (/* binding */ maxSorted),
/* harmony export */   mean: () => (/* binding */ mean),
/* harmony export */   meanSimple: () => (/* binding */ meanSimple),
/* harmony export */   median: () => (/* binding */ median),
/* harmony export */   medianAbsoluteDeviation: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   medianSorted: () => (/* binding */ medianSorted),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   minSorted: () => (/* binding */ minSorted),
/* harmony export */   mode: () => (/* binding */ mode),
/* harmony export */   modeFast: () => (/* binding */ modeFast),
/* harmony export */   modeSorted: () => (/* binding */ modeSorted),
/* harmony export */   numericSort: () => (/* binding */ numericSort),
/* harmony export */   perceptron: () => (/* binding */ PerceptronModel),
/* harmony export */   permutationTest: () => (/* binding */ permutationTest),
/* harmony export */   permutationsHeap: () => (/* binding */ permutationsHeap),
/* harmony export */   poissonDistribution: () => (/* binding */ poissonDistribution),
/* harmony export */   probit: () => (/* binding */ probit),
/* harmony export */   product: () => (/* binding */ product),
/* harmony export */   quantile: () => (/* binding */ quantile),
/* harmony export */   quantileRank: () => (/* binding */ quantileRank),
/* harmony export */   quantileRankSorted: () => (/* binding */ quantileRankSorted),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted),
/* harmony export */   quickselect: () => (/* binding */ quickselect),
/* harmony export */   rSquared: () => (/* binding */ rSquared),
/* harmony export */   relativeError: () => (/* binding */ relativeError),
/* harmony export */   rms: () => (/* binding */ rootMeanSquare),
/* harmony export */   rootMeanSquare: () => (/* binding */ rootMeanSquare),
/* harmony export */   sample: () => (/* binding */ sample),
/* harmony export */   sampleCorrelation: () => (/* binding */ sampleCorrelation),
/* harmony export */   sampleCovariance: () => (/* binding */ sampleCovariance),
/* harmony export */   sampleKurtosis: () => (/* binding */ sampleKurtosis),
/* harmony export */   sampleRankCorrelation: () => (/* binding */ sampleRankCorrelation),
/* harmony export */   sampleSkewness: () => (/* binding */ sampleSkewness),
/* harmony export */   sampleStandardDeviation: () => (/* binding */ sampleStandardDeviation),
/* harmony export */   sampleVariance: () => (/* binding */ sampleVariance),
/* harmony export */   sampleWithReplacement: () => (/* binding */ sampleWithReplacement),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   shuffleInPlace: () => (/* binding */ shuffleInPlace),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   silhouette: () => (/* binding */ silhouette),
/* harmony export */   silhouetteMetric: () => (/* binding */ silhouetteMetric),
/* harmony export */   standardDeviation: () => (/* binding */ standardDeviation),
/* harmony export */   standardNormalTable: () => (/* binding */ standardNormalTable),
/* harmony export */   subtractFromMean: () => (/* binding */ subtractFromMean),
/* harmony export */   sum: () => (/* binding */ sum),
/* harmony export */   sumNthPowerDeviations: () => (/* binding */ sumNthPowerDeviations),
/* harmony export */   sumSimple: () => (/* binding */ sumSimple),
/* harmony export */   tTest: () => (/* binding */ tTest),
/* harmony export */   tTestTwoSample: () => (/* binding */ tTestTwoSample),
/* harmony export */   uniqueCountSorted: () => (/* binding */ uniqueCountSorted),
/* harmony export */   variance: () => (/* binding */ variance),
/* harmony export */   wilcoxonRankSum: () => (/* binding */ wilcoxonRankSum),
/* harmony export */   zScore: () => (/* binding */ zScore)
/* harmony export */ });
/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m;
    var b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0;
        var sumY = 0;
        var sumXX = 0;
        var sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point;
        var x;
        var y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    if (typeof sum !== "number") {
        return Number.NaN;
    }

    for (var i = 1; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    }
    if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0];
    // store the mode as we find new modes
    var value = Number.NaN;
    // store how many times we've seen the mode
    var maxSeen = 0;
    // how many times the current candidate for the mode
    // has been seen
    var seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n log(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // choose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample, randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0;
    var lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix[0].length - 1) {
        /* c8 ignore start */
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
        /* c8 ignore end */
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/*
 * Pull Breaks Values for Jenks
 *
 * the second part of the jenks recipe: take the calculated matrices
 * and derive an array of n breaks.
 *
 * @private
 */
function jenksBreaks(data, lowerClassLimits, nClasses) {
    var k = data.length;
    var kclass = [];
    var countNum = nClasses;

    // the calculation of classes will never include the upper
    // bound, so we need to explicitly set it
    kclass[nClasses] = data[data.length - 1];

    // the lowerClassLimits matrix is used as indices into itself
    // here: the `k` variable is reused in each iteration.
    while (countNum > 0) {
        kclass[countNum - 1] = data[lowerClassLimits[k][countNum] - 1];
        k = lowerClassLimits[k][countNum] - 1;
        countNum--;
    }

    return kclass;
}

/*
 * Compute Matrices for Jenks
 *
 * Compute the matrices required for Jenks breaks. These matrices
 * can be used for any classing of data with `classes <= nClasses`
 *
 * @private
 */
function jenksMatrices(data, nClasses) {
    // in the original implementation, these matrices are referred to
    // as `LC` and `OP`
    //
    // * lowerClassLimits (LC): optimal lower class limits
    // * varianceCombinations (OP): optimal variance combinations for all classes
    var lowerClassLimits = [];
    var varianceCombinations = [];
    // loop counters
    var i;
    var j;
    // the variance, as computed at each step in the calculation
    var variance = 0;

    // Initialize and fill each matrix with zeroes
    for (i = 0; i < data.length + 1; i++) {
        var tmp1 = [];
        var tmp2 = [];
        // despite these arrays having the same values, we need
        // to keep them separate so that changing one does not change
        // the other
        for (j = 0; j < nClasses + 1; j++) {
            tmp1.push(0);
            tmp2.push(0);
        }
        lowerClassLimits.push(tmp1);
        varianceCombinations.push(tmp2);
    }

    for (i = 1; i < nClasses + 1; i++) {
        lowerClassLimits[1][i] = 1;
        varianceCombinations[1][i] = 0;
        // in the original implementation, 9999999 is used but
        // since Javascript has `Infinity`, we use that.
        for (j = 2; j < data.length + 1; j++) {
            varianceCombinations[j][i] = Number.POSITIVE_INFINITY;
        }
    }

    for (var l = 2; l < data.length + 1; l++) {
        // `SZ` originally. this is the sum of the values seen thus
        // far when calculating variance.
        var sum = 0;
        // `ZSQ` originally. the sum of squares of values seen
        // thus far
        var sumSquares = 0;
        // `WT` originally. This is the number of
        var w = 0;
        // `IV` originally
        var i4 = 0;

        // in several instances, you could say `Math.pow(x, 2)`
        // instead of `x * x`, but this is slower in some browsers
        // introduces an unnecessary concept.
        for (var m = 1; m < l + 1; m++) {
            // `III` originally
            var lowerClassLimit = l - m + 1;
            var val = data[lowerClassLimit - 1];

            // here we're estimating variance for each potential classing
            // of the data, for each potential number of classes. `w`
            // is the number of data points considered so far.
            w++;

            // increase the current sum and sum-of-squares
            sum += val;
            sumSquares += val * val;

            // the variance at this point in the sequence is the difference
            // between the sum of squares and the total x 2, over the number
            // of samples.
            variance = sumSquares - (sum * sum) / w;

            i4 = lowerClassLimit - 1;

            if (i4 !== 0) {
                for (j = 2; j < nClasses + 1; j++) {
                    // if adding this element to an existing class
                    // will increase its variance beyond the limit, break
                    // the class at this point, setting the `lowerClassLimit`
                    // at this point.
                    if (
                        varianceCombinations[l][j] >=
                        variance + varianceCombinations[i4][j - 1]
                    ) {
                        lowerClassLimits[l][j] = lowerClassLimit;
                        varianceCombinations[l][j] =
                            variance + varianceCombinations[i4][j - 1];
                    }
                }
            }
        }

        lowerClassLimits[l][1] = 1;
        varianceCombinations[l][1] = variance;
    }

    // return the two matrices. for just providing breaks, only
    // `lowerClassLimits` is needed, but variances can be useful to
    // evaluate goodness of fit.
    return {
        lowerClassLimits: lowerClassLimits,
        varianceCombinations: varianceCombinations
    };
}

/**
 * The **[jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)**
 * is an algorithm commonly used in cartography and visualization to decide
 * upon groupings of data values that minimize variance within themselves
 * and maximize variation between themselves.
 *
 * For instance, cartographers often use jenks in order to choose which
 * values are assigned to which colors in a [choropleth](https://en.wikipedia.org/wiki/Choropleth_map)
 * map.
 *
 * @param {Array<number>} data input data, as an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * // split data into 3 break points
 * jenks([1, 2, 4, 5, 7, 9, 10, 20], 3) // = [1, 7, 20, 20]
 */
function jenks(data, nClasses) {
    if (nClasses > data.length) {
        return null;
    }

    // sort data in numerical order, since this is expected
    // by the matrices function
    data = data.slice().sort(function (a, b) {
        return a - b;
    });

    // get our basic matrices
    var matrices = jenksMatrices(data, nClasses);
    // we only need lower class limits here
    var lowerClassLimits = matrices.lowerClassLimits;

    // extract nClasses out of the computed matrices
    return jenksBreaks(data, lowerClassLimits, nClasses);
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_covariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * The [rank correlation](https://en.wikipedia.org/wiki/Rank_correlation) is
 * a measure of the strength of monotonic relationship between two arrays
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample rank correlation
 */
function sampleRankCorrelation(x, y) {
    var xIndexes = x
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });
    var yIndexes = y
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });

    // At this step, we have an array of indexes
    // that map from sorted numbers to their original indexes. We reverse
    // that so that it is an array of the sorted destination index.
    var xRanks = Array(xIndexes.length);
    var yRanks = Array(xIndexes.length);
    for (var i = 0; i < xIndexes.length; i++) {
        xRanks[xIndexes[i]] = i;
        yRanks[yIndexes[i]] = i;
    }

    return sampleCorrelation(xRanks, yRanks);
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] < 0) {
            throw new Error(
                "geometricMean requires only non-negative numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [log average](https://en.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Geometric_mean#Relationship_with_logarithms)
 * is an equivalent way of computing the geometric mean of an array suitable for large or small products.
 *
 * It's found by calculating the average logarithm of the elements and exponentiating.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 */
function logAverage(x) {
    if (x.length === 0) {
        throw new Error("logAverage requires at least one data point");
    }

    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (x[i] < 0) {
            throw new Error(
                "logAverage requires only non-negative numbers as input"
            );
        }
        value += Math.log(x[i]);
    }

    return Math.exp(value / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * The`coefficient of variation`_ is the ratio of the standard deviation to the mean.
 * .._`coefficient of variation`: https://en.wikipedia.org/wiki/Coefficient_of_variation
 *
 *
 * @param {Array} x input
 * @returns {number} coefficient of variation
 * @example
 * coefficientOfVariation([1, 2, 3, 4]).toFixed(3); // => 0.516
 * coefficientOfVariation([1, 2, 3, 4, 5]).toFixed(3); // => 0.527
 * coefficientOfVariation([-1, 0, 1, 2, 3, 4]).toFixed(3); // => 1.247
 */
function coefficientOfVariation(x) {
    return sampleStandardDeviation(x) / mean(x);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to reject](https://en.wikipedia.org/wiki/Exclusion_of_the_null_hypothesis)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * This function calculates the Wilcoxon rank sum statistic for the first sample
 * with respect to the second. The Wilcoxon rank sum test is a non-parametric
 * alternative to the t-test which is equivalent to the
 * [Mann-Whitney U test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).
 * The statistic is calculated by pooling all the observations together, ranking them,
 * and then summing the ranks associated with one of the samples. If this rank sum is
 * sufficiently large or small we reject the hypothesis that the two samples come
 * from the same distribution in favor of the alternative that one is shifted with
 * respect to the other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @returns {number} rank sum for sampleX
 *
 * @example
 * wilcoxonRankSum([1, 4, 8], [9, 12, 15]); // => 6
 */
function wilcoxonRankSum(sampleX, sampleY) {
    if (!sampleX.length || !sampleY.length) {
        throw new Error("Neither sample can be empty");
    }

    var pooledSamples = sampleX
        .map(function (x) { return ({ label: "x", value: x }); })
        .concat(sampleY.map(function (y) { return ({ label: "y", value: y }); }))
        .sort(function (a, b) { return a.value - b.value; });

    for (var rank = 0; rank < pooledSamples.length; rank++) {
        pooledSamples[rank].rank = rank;
    }

    var tiedRanks = [pooledSamples[0].rank];
    for (var i = 1; i < pooledSamples.length; i++) {
        if (pooledSamples[i].value === pooledSamples[i - 1].value) {
            tiedRanks.push(pooledSamples[i].rank);
            if (i === pooledSamples.length - 1) {
                replaceRanksInPlace(pooledSamples, tiedRanks);
            }
        } else if (tiedRanks.length > 1) {
            replaceRanksInPlace(pooledSamples, tiedRanks);
        } else {
            tiedRanks = [pooledSamples[i].rank];
        }
    }

    function replaceRanksInPlace(pooledSamples, tiedRanks) {
        var average = (tiedRanks[0] + tiedRanks[tiedRanks.length - 1]) / 2;
        for (var i = 0; i < tiedRanks.length; i++) {
            pooledSamples[tiedRanks[i]].rank = average;
        }
    }

    var rankSum = 0;

    for (var i$1 = 0; i$1 < pooledSamples.length; i$1++) {
        var sample = pooledSamples[i$1];
        if (sample.label === "x") {
            rankSum += sample.rank + 1;
        }
    }

    return rankSum;
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a naïve bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use `ε`, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return Number.NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
    14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
    0.46523628927048575665e-4, -0.98374475304879564677e-4,
    0.15808870322491248884e-3, -0.21026444172410488319e-3,
    0.2174396181152126432e-3, -0.16431810653676389022e-3,
    0.84418223983852743293e-4, -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Number.POSITIVE_INFINITY;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, `λ`.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the χ2 (Chi-Squared) Distribution**
 *
 * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    1: {
        0.995: 0,
        0.99: 0,
        0.975: 0,
        0.95: 0,
        0.9: 0.02,
        0.5: 0.45,
        0.1: 2.71,
        0.05: 3.84,
        0.025: 5.02,
        0.01: 6.63,
        0.005: 7.88
    },
    2: {
        0.995: 0.01,
        0.99: 0.02,
        0.975: 0.05,
        0.95: 0.1,
        0.9: 0.21,
        0.5: 1.39,
        0.1: 4.61,
        0.05: 5.99,
        0.025: 7.38,
        0.01: 9.21,
        0.005: 10.6
    },
    3: {
        0.995: 0.07,
        0.99: 0.11,
        0.975: 0.22,
        0.95: 0.35,
        0.9: 0.58,
        0.5: 2.37,
        0.1: 6.25,
        0.05: 7.81,
        0.025: 9.35,
        0.01: 11.34,
        0.005: 12.84
    },
    4: {
        0.995: 0.21,
        0.99: 0.3,
        0.975: 0.48,
        0.95: 0.71,
        0.9: 1.06,
        0.5: 3.36,
        0.1: 7.78,
        0.05: 9.49,
        0.025: 11.14,
        0.01: 13.28,
        0.005: 14.86
    },
    5: {
        0.995: 0.41,
        0.99: 0.55,
        0.975: 0.83,
        0.95: 1.15,
        0.9: 1.61,
        0.5: 4.35,
        0.1: 9.24,
        0.05: 11.07,
        0.025: 12.83,
        0.01: 15.09,
        0.005: 16.75
    },
    6: {
        0.995: 0.68,
        0.99: 0.87,
        0.975: 1.24,
        0.95: 1.64,
        0.9: 2.2,
        0.5: 5.35,
        0.1: 10.65,
        0.05: 12.59,
        0.025: 14.45,
        0.01: 16.81,
        0.005: 18.55
    },
    7: {
        0.995: 0.99,
        0.99: 1.25,
        0.975: 1.69,
        0.95: 2.17,
        0.9: 2.83,
        0.5: 6.35,
        0.1: 12.02,
        0.05: 14.07,
        0.025: 16.01,
        0.01: 18.48,
        0.005: 20.28
    },
    8: {
        0.995: 1.34,
        0.99: 1.65,
        0.975: 2.18,
        0.95: 2.73,
        0.9: 3.49,
        0.5: 7.34,
        0.1: 13.36,
        0.05: 15.51,
        0.025: 17.53,
        0.01: 20.09,
        0.005: 21.96
    },
    9: {
        0.995: 1.73,
        0.99: 2.09,
        0.975: 2.7,
        0.95: 3.33,
        0.9: 4.17,
        0.5: 8.34,
        0.1: 14.68,
        0.05: 16.92,
        0.025: 19.02,
        0.01: 21.67,
        0.005: 23.59
    },
    10: {
        0.995: 2.16,
        0.99: 2.56,
        0.975: 3.25,
        0.95: 3.94,
        0.9: 4.87,
        0.5: 9.34,
        0.1: 15.99,
        0.05: 18.31,
        0.025: 20.48,
        0.01: 23.21,
        0.005: 25.19
    },
    11: {
        0.995: 2.6,
        0.99: 3.05,
        0.975: 3.82,
        0.95: 4.57,
        0.9: 5.58,
        0.5: 10.34,
        0.1: 17.28,
        0.05: 19.68,
        0.025: 21.92,
        0.01: 24.72,
        0.005: 26.76
    },
    12: {
        0.995: 3.07,
        0.99: 3.57,
        0.975: 4.4,
        0.95: 5.23,
        0.9: 6.3,
        0.5: 11.34,
        0.1: 18.55,
        0.05: 21.03,
        0.025: 23.34,
        0.01: 26.22,
        0.005: 28.3
    },
    13: {
        0.995: 3.57,
        0.99: 4.11,
        0.975: 5.01,
        0.95: 5.89,
        0.9: 7.04,
        0.5: 12.34,
        0.1: 19.81,
        0.05: 22.36,
        0.025: 24.74,
        0.01: 27.69,
        0.005: 29.82
    },
    14: {
        0.995: 4.07,
        0.99: 4.66,
        0.975: 5.63,
        0.95: 6.57,
        0.9: 7.79,
        0.5: 13.34,
        0.1: 21.06,
        0.05: 23.68,
        0.025: 26.12,
        0.01: 29.14,
        0.005: 31.32
    },
    15: {
        0.995: 4.6,
        0.99: 5.23,
        0.975: 6.27,
        0.95: 7.26,
        0.9: 8.55,
        0.5: 14.34,
        0.1: 22.31,
        0.05: 25,
        0.025: 27.49,
        0.01: 30.58,
        0.005: 32.8
    },
    16: {
        0.995: 5.14,
        0.99: 5.81,
        0.975: 6.91,
        0.95: 7.96,
        0.9: 9.31,
        0.5: 15.34,
        0.1: 23.54,
        0.05: 26.3,
        0.025: 28.85,
        0.01: 32,
        0.005: 34.27
    },
    17: {
        0.995: 5.7,
        0.99: 6.41,
        0.975: 7.56,
        0.95: 8.67,
        0.9: 10.09,
        0.5: 16.34,
        0.1: 24.77,
        0.05: 27.59,
        0.025: 30.19,
        0.01: 33.41,
        0.005: 35.72
    },
    18: {
        0.995: 6.26,
        0.99: 7.01,
        0.975: 8.23,
        0.95: 9.39,
        0.9: 10.87,
        0.5: 17.34,
        0.1: 25.99,
        0.05: 28.87,
        0.025: 31.53,
        0.01: 34.81,
        0.005: 37.16
    },
    19: {
        0.995: 6.84,
        0.99: 7.63,
        0.975: 8.91,
        0.95: 10.12,
        0.9: 11.65,
        0.5: 18.34,
        0.1: 27.2,
        0.05: 30.14,
        0.025: 32.85,
        0.01: 36.19,
        0.005: 38.58
    },
    20: {
        0.995: 7.43,
        0.99: 8.26,
        0.975: 9.59,
        0.95: 10.85,
        0.9: 12.44,
        0.5: 19.34,
        0.1: 28.41,
        0.05: 31.41,
        0.025: 34.17,
        0.01: 37.57,
        0.005: 40
    },
    21: {
        0.995: 8.03,
        0.99: 8.9,
        0.975: 10.28,
        0.95: 11.59,
        0.9: 13.24,
        0.5: 20.34,
        0.1: 29.62,
        0.05: 32.67,
        0.025: 35.48,
        0.01: 38.93,
        0.005: 41.4
    },
    22: {
        0.995: 8.64,
        0.99: 9.54,
        0.975: 10.98,
        0.95: 12.34,
        0.9: 14.04,
        0.5: 21.34,
        0.1: 30.81,
        0.05: 33.92,
        0.025: 36.78,
        0.01: 40.29,
        0.005: 42.8
    },
    23: {
        0.995: 9.26,
        0.99: 10.2,
        0.975: 11.69,
        0.95: 13.09,
        0.9: 14.85,
        0.5: 22.34,
        0.1: 32.01,
        0.05: 35.17,
        0.025: 38.08,
        0.01: 41.64,
        0.005: 44.18
    },
    24: {
        0.995: 9.89,
        0.99: 10.86,
        0.975: 12.4,
        0.95: 13.85,
        0.9: 15.66,
        0.5: 23.34,
        0.1: 33.2,
        0.05: 36.42,
        0.025: 39.36,
        0.01: 42.98,
        0.005: 45.56
    },
    25: {
        0.995: 10.52,
        0.99: 11.52,
        0.975: 13.12,
        0.95: 14.61,
        0.9: 16.47,
        0.5: 24.34,
        0.1: 34.28,
        0.05: 37.65,
        0.025: 40.65,
        0.01: 44.31,
        0.005: 46.93
    },
    26: {
        0.995: 11.16,
        0.99: 12.2,
        0.975: 13.84,
        0.95: 15.38,
        0.9: 17.29,
        0.5: 25.34,
        0.1: 35.56,
        0.05: 38.89,
        0.025: 41.92,
        0.01: 45.64,
        0.005: 48.29
    },
    27: {
        0.995: 11.81,
        0.99: 12.88,
        0.975: 14.57,
        0.95: 16.15,
        0.9: 18.11,
        0.5: 26.34,
        0.1: 36.74,
        0.05: 40.11,
        0.025: 43.19,
        0.01: 46.96,
        0.005: 49.65
    },
    28: {
        0.995: 12.46,
        0.99: 13.57,
        0.975: 15.31,
        0.95: 16.93,
        0.9: 18.94,
        0.5: 27.34,
        0.1: 37.92,
        0.05: 41.34,
        0.025: 44.46,
        0.01: 48.28,
        0.005: 50.99
    },
    29: {
        0.995: 13.12,
        0.99: 14.26,
        0.975: 16.05,
        0.95: 17.71,
        0.9: 19.77,
        0.5: 28.34,
        0.1: 39.09,
        0.05: 42.56,
        0.025: 45.72,
        0.01: 49.59,
        0.005: 52.34
    },
    30: {
        0.995: 13.79,
        0.99: 14.95,
        0.975: 16.79,
        0.95: 18.49,
        0.9: 20.6,
        0.5: 29.34,
        0.1: 40.26,
        0.05: 43.77,
        0.025: 46.98,
        0.01: 50.89,
        0.005: 53.67
    },
    40: {
        0.995: 20.71,
        0.99: 22.16,
        0.975: 24.43,
        0.95: 26.51,
        0.9: 29.05,
        0.5: 39.34,
        0.1: 51.81,
        0.05: 55.76,
        0.025: 59.34,
        0.01: 63.69,
        0.005: 66.77
    },
    50: {
        0.995: 27.99,
        0.99: 29.71,
        0.975: 32.36,
        0.95: 34.76,
        0.9: 37.69,
        0.5: 49.33,
        0.1: 63.17,
        0.05: 67.5,
        0.025: 71.42,
        0.01: 76.15,
        0.005: 79.49
    },
    60: {
        0.995: 35.53,
        0.99: 37.48,
        0.975: 40.48,
        0.95: 43.19,
        0.9: 46.46,
        0.5: 59.33,
        0.1: 74.4,
        0.05: 79.08,
        0.025: 83.3,
        0.01: 88.38,
        0.005: 91.95
    },
    70: {
        0.995: 43.28,
        0.99: 45.44,
        0.975: 48.76,
        0.95: 51.74,
        0.9: 55.33,
        0.5: 69.33,
        0.1: 85.53,
        0.05: 90.53,
        0.025: 95.02,
        0.01: 100.42,
        0.005: 104.22
    },
    80: {
        0.995: 51.17,
        0.99: 53.54,
        0.975: 57.15,
        0.95: 60.39,
        0.9: 64.28,
        0.5: 79.33,
        0.1: 96.58,
        0.05: 101.88,
        0.025: 106.63,
        0.01: 112.33,
        0.005: 116.32
    },
    90: {
        0.995: 59.2,
        0.99: 61.75,
        0.975: 65.65,
        0.95: 69.13,
        0.9: 73.29,
        0.5: 89.33,
        0.1: 107.57,
        0.05: 113.14,
        0.025: 118.14,
        0.01: 124.12,
        0.005: 128.3
    },
    100: {
        0.995: 67.33,
        0.99: 70.06,
        0.975: 74.22,
        0.95: 77.93,
        0.9: 82.36,
        0.5: 99.33,
        0.1: 118.5,
        0.05: 124.34,
        0.025: 129.56,
        0.01: 135.81,
        0.005: 140.17
    }
};

/**
 * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the χ2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI$1;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z;
    var tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of Φ (phi), which are the values of
 * the [cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function)
 * of the normal distribution. It is used to find the probability that a
 * statistic is observed below, above, or between values on the standard
 * normal distribution, and by extension, any normal distribution.
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return Math.round((1 - standardNormalTable[index]) * 1e4) / 1e4;
    }
}

/**
 * **[Logistic Cumulative Distribution Function](https://en.wikipedia.org/wiki/Logistic_distribution)**
 *
 * @param {number} x
 * @returns {number} cumulative standard logistic probability
 */
function cumulativeStdLogisticProbability(x) {
    return 1 / (Math.exp(-x) + 1);
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of τ (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * The [Logit](https://en.wikipedia.org/wiki/Logit)
 * is the inverse of cumulativeStdLogisticProbability,
 * and is also known as the logistic quantile function.
 *
 * @param {number} p
 * @returns {number} logit
 */
function logit(p) {
    if (p <= 0 || p >= 1) {
        throw new Error("p must be strictly between zero and one");
    }
    return Math.log(p / (1 - p));
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @param {Function} [randomSource=Math.random] an optional entropy source
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k, randomSource) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'."
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData, randomSource);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            /* c8 ignore start */
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
            /* c8 ignore end */
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}

/**
 * Calculate Euclidean distance between two points.
 * @param {Array<number>} left First N-dimensional point.
 * @param {Array<number>} right Second N-dimensional point.
 * @returns {number} Distance.
 */
function euclideanDistance(left, right) {
    var sum = 0;
    for (var i = 0; i < left.length; i++) {
        var diff = left[i] - right[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

/**
 * @typedef {Object} kMeansReturn
 * @property {Array<number>} labels The labels.
 * @property {Array<Array<number>>} centroids The cluster centroids.
 */

/**
 * Perform k-means clustering.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points to be clustered.
 * @param {number} numCluster How many clusters to create.
 * @param {Function} randomSource An optional entropy source that generates uniform values in [0, 1).
 * @return {kMeansReturn} Labels (same length as data) and centroids (same length as numCluster).
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 *
 * @example
 * kMeansCluster([[0.0, 0.5], [1.0, 0.5]], 2); // => {labels: [0, 1], centroids: [[0.0, 0.5], [1.0 0.5]]}
 */
function kMeansCluster(points, numCluster, randomSource) {
    if ( randomSource === void 0 ) randomSource = Math.random;

    var oldCentroids = null;
    var newCentroids = sample(points, numCluster, randomSource);
    var labels = null;
    var change = Number.MAX_VALUE;
    while (change !== 0) {
        labels = labelPoints(points, newCentroids);
        oldCentroids = newCentroids;
        newCentroids = calculateCentroids(points, labels, numCluster);
        change = calculateChange(newCentroids, oldCentroids);
    }
    return {
        labels: labels,
        centroids: newCentroids
    };
}

/**
 * Label each point according to which centroid it is closest to.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<Array<number>>} centroids Current centroids.
 * @return {Array<number>} Group labels.
 */
function labelPoints(points, centroids) {
    return points.map(function (p) {
        var minDist = Number.MAX_VALUE;
        var label = -1;
        for (var i = 0; i < centroids.length; i++) {
            var dist = euclideanDistance(p, centroids[i]);
            if (dist < minDist) {
                minDist = dist;
                label = i;
            }
        }
        return label;
    });
}

/**
 * Calculate centroids for points given labels.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<number>} labels Which groups points belong to.
 * @param {number} numCluster Number of clusters being created.
 * @return {Array<Array<number>>} Centroid for each group.
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 */
function calculateCentroids(points, labels, numCluster) {
    // Initialize accumulators.
    var dimension = points[0].length;
    var centroids = makeMatrix(numCluster, dimension);
    var counts = Array(numCluster).fill(0);

    // Add points to centroids' accumulators and count points per centroid.
    var numPoints = points.length;
    for (var i = 0; i < numPoints; i++) {
        var point = points[i];
        var label = labels[i];
        var current = centroids[label];
        for (var j = 0; j < dimension; j++) {
            current[j] += point[j];
        }
        counts[label] += 1;
    }

    // Rescale centroids, checking for any that have no points.
    for (var i$1 = 0; i$1 < numCluster; i$1++) {
        if (counts[i$1] === 0) {
            throw new Error(("Centroid " + i$1 + " has no friends"));
        }
        var centroid = centroids[i$1];
        for (var j$1 = 0; j$1 < dimension; j$1++) {
            centroid[j$1] /= counts[i$1];
        }
    }

    return centroids;
}

/**
 * Calculate the difference between old centroids and new centroids.
 *
 * @private
 * @param {Array<Array<number>>} left One list of centroids.
 * @param {Array<Array<number>>} right Another list of centroids.
 * @return {number} Distance between centroids.
 */
function calculateChange(left, right) {
    var total = 0;
    for (var i = 0; i < left.length; i++) {
        total += euclideanDistance(left[i], right[i]);
    }
    return total;
}

/**
 * Calculate the [silhouette values](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for clustered data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<number>} The silhouette value for each point.
 *
 * @example
 * silhouette([[0.25], [0.75]], [0, 0]); // => [1.0, 1.0]
 */
function silhouette(points, labels) {
    if (points.length !== labels.length) {
        throw new Error("must have exactly as many labels as points");
    }
    var groupings = createGroups(labels);
    var distances = calculateAllDistances(points);
    var result = [];
    for (var i = 0; i < points.length; i++) {
        var s = 0;
        if (groupings[labels[i]].length > 1) {
            var a = meanDistanceFromPointToGroup(
                i,
                groupings[labels[i]],
                distances
            );
            var b = meanDistanceToNearestGroup(
                i,
                labels,
                groupings,
                distances
            );
            s = (b - a) / Math.max(a, b);
        }
        result.push(s);
    }
    return result;
}

/**
 * Create a lookup table mapping group IDs to point IDs.
 *
 * @private
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<Array<number>>} An array of length G, each of whose entries is an array
 * containing the indices of the points in that group.
 */
function createGroups(labels) {
    var numGroups = 1 + max(labels);
    var result = Array(numGroups);
    for (var i = 0; i < labels.length; i++) {
        var label = labels[i];
        if (result[label] === undefined) {
            result[label] = [];
        }
        result[label].push(i);
    }
    return result;
}

/**
 * Create a lookup table of all inter-point distances.
 *
 * @private
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @return {Array<Array<number>>} A symmetric square array of inter-point distances
 * (zero on the diagonal).
 */
function calculateAllDistances(points) {
    var numPoints = points.length;
    var result = makeMatrix(numPoints, numPoints);
    for (var i = 0; i < numPoints; i++) {
        for (var j = 0; j < i; j++) {
            result[i][j] = euclideanDistance(points[i], points[j]);
            result[j][i] = result[i][j];
        }
    }
    return result;
}

/**
 * Calculate the mean distance between this point and all the points in the
 * nearest group (as determined by which point in another group is closest).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} labels Labels of points.
 * @param {Array<Array<number>>} groupings An array whose entries are arrays
 * containing the indices of the points in that group.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the nearest
 * group.
 */
function meanDistanceToNearestGroup(which, labels, groupings, distances) {
    var label = labels[which];
    var result = Number.MAX_VALUE;
    for (var i = 0; i < groupings.length; i++) {
        if (i !== label) {
            var d = meanDistanceFromPointToGroup(
                which,
                groupings[i],
                distances
            );
            if (d < result) {
                result = d;
            }
        }
    }
    return result;
}

/**
 * Calculate the mean distance between a point and all the points in a group
 * (possibly its own).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} group The indices of all the points in the group in
 * question.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the
 * specified group.
 */
function meanDistanceFromPointToGroup(which, group, distances) {
    var total = 0;
    for (var i = 0; i < group.length; i++) {
        total += distances[which][group[i]];
    }
    return total / group.length;
}

/**
 * Calculate the [silhouette metric](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for a set of N-dimensional points arranged in groups. The metric is the largest
 * individual silhouette value for the data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {number} The silhouette metric for the groupings.
 *
 * @example
 * silhouetteMetric([[0.25], [0.75]], [0, 0]); // => 1.0
 */
function silhouetteMetric(points, labels) {
    var values = silhouette(points, labels);
    return max(values);
}

/**
 * Relative error.
 *
 * This is more difficult to calculate than it first appears [1,2].  The usual
 * formula for the relative error between an actual value A and an expected
 * value E is `|(A-E)/E|`, but:
 *
 * 1. If the expected value is 0, any other value has infinite relative error,
 *    which is counter-intuitive: if the expected voltage is 0, getting 1/10th
 *    of a volt doesn't feel like an infinitely large error.
 *
 * 2. This formula does not satisfy the mathematical definition of a metric [3].
 *    [4] solved this problem by defining the relative error as `|ln(|A/E|)|`,
 *    but that formula only works if all values are positive: for example, it
 *    reports the relative error of -10 and 10 as 0.
 *
 * Our implementation sticks with convention and returns:
 *
 * - 0 if the actual and expected values are both zero
 * - Infinity if the actual value is non-zero and the expected value is zero
 * - `|(A-E)/E|` in all other cases
 *
 * [1] https://math.stackexchange.com/questions/677852/how-to-calculate-relative-error-when-true-value-is-zero
 * [2] https://en.wikipedia.org/wiki/Relative_change_and_difference
 * [3] https://en.wikipedia.org/wiki/Metric_(mathematics)#Definition
 * [4] F.W.J. Olver: "A New Approach to Error Arithmetic." SIAM Journal on
 *     Numerical Analysis, 15(2), 1978, 10.1137/0715024.
 *
 * @param {number} actual The actual value.
 * @param {number} expected The expected value.
 * @return {number} The relative error.
 */
function relativeError(actual, expected) {
    // These lines are actually covered by tests, but it seems
    // like c8 has a bug that marks them as not covered.
    /* c8 ignore start */
    if (actual === 0 && expected === 0) {
        return 0;
    }
    /* c8 ignore end */
    return Math.abs((actual - expected) / expected);
}

/**
 * Approximate equality.
 *
 * @param {number} actual The value to be tested.
 * @param {number} expected The reference value.
 * @param {number} tolerance The acceptable relative difference.
 * @return {boolean} Whether numbers are within tolerance.
 */
function approxEqual(actual, expected, tolerance) {
    if ( tolerance === void 0 ) tolerance = epsilon;

    return relativeError(actual, expected) <= tolerance;
}


//# sourceMappingURL=simple-statistics.mjs.map


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   object: () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bbox: () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   feature: () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   merge: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mergeArcs: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   mesh: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   meshArcs: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   neighbors: () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   quantize: () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   transform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   untransform: () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "./node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "./node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mergeArcs: () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   meshArcs: () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "./node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"eurostat-map","version":"4.1.68","description":"Reusable library to quickly create and customise web maps showing Eurostat data directly retrieved from Eurostat database.","keywords":["eurostat","statistics","europe","SVG","NUTS","map","D3","cartography","thematic","mapping","eurostat-map","dataviz","data visualization"],"homepage":"https://github.com/eurostat/eurostat-map","author":"","license":"EUPL-1.2","repository":{"type":"git","url":"https://github.com/eurostat/eurostat-map.git"},"main":"build/eurostatmap.min.js","unpkg":"build/eurostatmap.min.js","files":["build"],"scripts":{"start":"webpack --config webpack/webpack.config.dev.js","server":"webpack-dev-server --open --watch","build-prod":"webpack --config webpack/webpack.config.prod.js","build-prod-debug":"webpack --config webpack/webpack.config.debug-size.js","format":"prettier --write .","test":"jest"},"dependencies":{"colorbrewer":"^1.3.0","d3":"^7.8.5","d3-geo-projection":"^3.0.0","d3-sankey":"^0.12.3","d3-svg-annotation":"^2.5.1","idb-keyval":"^6.2.2","jsonstat-toolkit":"^1.0.8","simple-statistics":"^7.8.7","topojson-client":"^3.1.0"},"overrides":{"d3-color":"3.1.0"},"devDependencies":{"@babel/core":"^7.22.6","@babel/plugin-transform-runtime":"^7.22.6","@babel/preset-env":"^7.22.6","@babel/runtime":"^7.12.1","babel-loader":"^9.1.2","css-loader":"^7.1.2","prettier":"^3.4.1","style-loader":"^4.0.0","webpack":"^5.88.1","webpack-bundle-analyzer":"^4.10.2","webpack-cli":"^5.0.0","webpack-dev-server":"^4.15.1","webpack-livereload-plugin":"^3.0.2"}}');

/***/ }),

/***/ "./src/core/annotations.js":
/*!*********************************!*\
  !*** ./src/core/annotations.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendAnnotations: () => (/* binding */ appendAnnotations)
/* harmony export */ });
/* harmony import */ var d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-svg-annotation */ "./node_modules/d3-svg-annotation/indexRollupNext.js");


function appendAnnotations(map) {
    if (map.svg_) {
        const zoomGroup = map.svg_.select('#em-zoom-group-' + map.svgId_)
        //clear previous
        zoomGroup.selectAll('.em-annotation-group').remove()

        const annotationsConfig = map.annotations_

        if (annotationsConfig) {
            // Define a map that maps the type string to the corresponding annotation function
            const annotationTypeMap = {
                annotationLabel: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel,
                annotationCallout: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCallout,
                annotationCalloutRect: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutRect,
                annotationCalloutCircle: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutCircle,
                annotationXYThreshold: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationXYThreshold, // Add any other types you need
            }

            // Map annotations data to ensure each annotation has the proper function
            const annotationsWithTypes = annotationsConfig.annotations.map((d) => {
                // Replace the 'type' string with the corresponding annotation function
                const annotationType = annotationTypeMap[d.type] || d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel // Default to annotationLabel
                return { ...d, type: annotationType } // Update 'type' with the function reference
            })
            const makeAnnotations = (0,d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotation)().type(d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel).annotations(annotationsWithTypes).editMode(annotationsConfig.editMode)

            // append new
            zoomGroup.append('g').attr('class', 'em-annotation-group').call(makeAnnotations)
        }
    }
}


/***/ }),

/***/ "./src/core/cartograms.js":
/*!********************************!*\
  !*** ./src/core/cartograms.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildGridCartogramBase: () => (/* binding */ buildGridCartogramBase)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");



// draw grid cartogram geometries
const buildGridCartogramBase = function (out) {
    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(`#em-zoom-group-${out.svgId_}`)
    const gridGroup = zoomGroup.append('g').attr('id', 'em-grid-container')

    // Ensure margins exist with default values
    out.gridCartogramMargins_ = out.gridCartogramMargins_ || { top: 80, right: 80, bottom: 80, left: 80 }

    // Get grid layout
    const gridLayout = getGridLayout(out)
    const position = parseGridLayout(gridLayout)
    const gridData = getGridData(position, out)

    // Draw the appropriate grid
    if (out.gridCartogramShape_ === 'hexagon') {
        drawHexagonGrid(gridGroup, gridData, out)
    } else {
        drawSquareGrid(gridGroup, gridData, out)
    }

    // Center the grid
    centerGrid(gridGroup, out.width_, out.height_, out.gridCartogramMargins_)
}

/** Determines the grid layout based on settings */
const getGridLayout = (out) => {
    const squareGrid = `
        ,IS,  ,  ,NO,SE,FI,  ,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    const hexagonGrid = `
        ,IS,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,
        ,  ,  ,  ,NO,SE,FI,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    return out.gridCartogramPositions_ || (out.gridCartogramShape_ === 'hexagon' ? hexagonGrid : squareGrid)
}

/** Parses the grid layout and maps each ID to its position */
const parseGridLayout = (gridLayout) => {
    const positionById = new Map()
    ;(0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__.csvParseRows)(gridLayout.trim(), (row, j) => {
        row.forEach((id, i) => {
            if ((id = id.trim())) {
                positionById.set(id, [i, j])
            }
        })
    })
    return positionById
}

/** Converts parsed positions into structured grid data */
const getGridData = (position, out) => {
    return Array.from(position, ([id, [col, row]]) => {
        const feature = out.Geometries.geoJSONs.nutsrg.find((rg) => rg.properties.id == id)
        return {
            id,
            col,
            row,
            properties: {
                id: id,
                name: feature ? feature.properties.na : '',
            },
        }
    })
}

/** Draws a square grid */
const drawSquareGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const cellWidth = (out.width_ - margins.left - margins.right) / numCols - cellPadding
    const cellHeight = (out.height_ - margins.top - margins.bottom) / numRows - cellPadding
    const cellSize = Math.min(cellWidth, cellHeight)

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => `translate(${d.col * (cellSize + cellPadding) + margins.left}, ${d.row * (cellSize + cellPadding) + margins.top})`)
        .each(function (d) {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('rect').attr('width', cellSize).attr('height', cellSize).attr('class', 'em-grid-rect')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('x', cellSize / 2)
                .attr('y', cellSize / 2 + 5)
        })
}

/** Draws a hexagon grid */
const drawHexagonGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const baseHexRadius = Math.min(
        (out.width_ - margins.left - margins.right) / (numCols * 1.5),
        (out.height_ - margins.top - margins.bottom) / (numRows * Math.sqrt(3))
    )

    const hexRadius = baseHexRadius
    const hexHeight = Math.sqrt(3) * hexRadius

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => {
            const x = d.col * (1.5 * hexRadius + cellPadding) + margins.left
            const y = d.row * (hexHeight + cellPadding) + (d.col % 2 === 1 ? (hexHeight + cellPadding) / 2 : 0) + margins.top
            return `translate(${x}, ${y})`
        })
        .each(function (d) {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('path').attr('d', drawHexagon(hexRadius)).attr('class', 'em-grid-hexagon')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('y', 5)
        })
}

/** Generates the hexagon path */
const drawHexagon = (r) => {
    const angle = Math.PI / 3
    return (
        Array.from({ length: 6 }, (_, i) => {
            const x = r * Math.cos(angle * i)
            const y = r * Math.sin(angle * i)
            return `${i === 0 ? 'M' : 'L'}${x},${y}`
        }).join(' ') + ' Z'
    )
}

/** Centers the grid within the SVG */
const centerGrid = (gridGroup, svgWidth, svgHeight, margins) => {
    gridGroup.each(function () {
        const bbox = this.getBBox()
        const dx = (svgWidth - margins.left - margins.right - bbox.width) / 2 - bbox.x + margins.left
        const dy = (svgHeight - margins.top - margins.bottom - bbox.height) / 2 - bbox.y + margins.top
        gridGroup.attr('transform', `translate(${dx}, ${dy})`)
    })
}


/***/ }),

/***/ "./src/core/deprecated.js":
/*!********************************!*\
  !*** ./src/core/deprecated.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defineDeprecatedFunctions: () => (/* binding */ defineDeprecatedFunctions)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/core/utils.js");


/* prettier-ignore */
// to keep track of deprecated functions whilst keeping the current version clean.
// also passes any important parameters to the new functions (if they exist) and overwrites any CSS style rules.
// To be removed when completely phased out.

const defineDeprecatedFunctions = (out) => {
    // styles
    out.seaFillStyle = (v) => (console.warn('seaFillStyle() is now DEPRECATED, please use the .em-sea CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-sea','fill',v), out);
    out.cntrgFillStyle = (v) => (console.warn('cntrgFillStyle() is now DEPRECATED, please use the .em-cntrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-cntrg','fill',v), out);
    out.nutsrgFillStyle = (v) => (console.warn('nutsrgFillStyle() is now DEPRECATED, please use the .em-nutsrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-nutsrg','fill',v), out);
    out.nutsbnStroke = (v) => {
        console.warn('nutsbnStroke() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke',v['3'])
        }
        return out
    };
    out.nutsbnStrokeWidth = (v) => {
        console.warn('nutsbnStrokeWidth() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke-width',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke-width',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke-width',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke-width',v['3'])
        }
        return out
    };
    out.graticuleStroke = (v) => (console.warn('graticuleStroke() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke',v), out);
    out.graticuleStrokeWidth = (v) => (console.warn('graticuleStrokeWidth() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke-width',v), out);
    out.nutsrgSelFillSty = (v) => (console.warn('nutsrgSelFillSty() is now DEPRECATED, please use hoverColor() instead'), out.hoverColor_ = v, out);
    out.titleFontSize = (v) => (console.warn('map.titleFontSize() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','font-size',v), out);
    out.subtitleFontSize = (v) => (console.warn('map.subtitleFontSize() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-size',v), out);
    out.subtitleFontWeight = (v) => (console.warn('map.subtitleFontWeight() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-weight',v), out);
    out.titleFill = (v) => (console.warn('map.titleFill() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','fill',v), out);
    out.subtitleFill = (v) => (console.warn('map.subtitleFill() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','fill',v), out);
    out.cntbnStroke = (v) => {
        console.warn('cntbnStroke() is now DEPRECATED, please use the .em-cntbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v['co'])
        }
        return out
    };
    out.cntbnStrokeWidth = (v) => {
        console.warn('cntbnStrokeWidth() is now DEPRECATED, please use the .em-cntbn .em-worldbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke-width',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke-width',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke-width',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke-width',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v['co'])
        }
        return out
    };
    out.worldStroke = (v) => (console.warn('map.worldStroke() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke',v), out);
    out.worldStrokeWidth = (v) => (console.warn('map.worldStrokeWidth() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke-width',v), out);
    out.worldCoastStroke = (v) => (console.warn('map.worldCoastStroke() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v), out);
    out.worldCoastStrokeWidth = (v) => (console.warn('map.worldCoastStrokeWidth() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v), out);
    out.worldFillStyle = (v) => (console.warn('map.worldFillStyle() is now DEPRECATED. please use the .em-worldrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldrg','fill',v), out); 
    out.coastalMarginWidth = (v) => (console.warn('map.coastalMarginWidth() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke-width',v), out);  
    out.coastalMarginColor = (v) => (console.warn('map.coastalMarginColor() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke',v), out);
    out.fontFamily = (v) => (console.warn('map.fontFamily() is now DEPRECATED. please use the .em-map CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-map','font-family',v), out);
    out.botTxtFontSize = (v) => (console.warn('map.botTxtFontSize() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','font-size',v), out);
    out.botTxtFill = (v) => (console.warn('map.botTxtFill() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','fill',v), out);
    out.scalebarFontSize = (v) => (console.warn('map.scalebarFontSize() is now DEPRECATED. please use the .em-scalebar-label CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-scalebar-label','font-size',v), out);
    out.frameStroke = (v)=> (console.warn('map.frameStroke() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke',v), out);
    out.frameStrokeWidth = (v)=> (console.warn('map.frameStrokeWidth() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke-width',v), out);

   //other
    out.psClassifMethod = (v) => (console.warn('psClassifMethod() is now DEPRECATED. please use psClassificationMethod instead'),out.psClassificationMethod_ = v, out);
    out.geoCenter = (v) => (console.warn('map.geoCenter() is now deprecated. Please use map.position({x,y,z}) instead.'), out.position_.x = v[0], out.position_.y = v[1], out);
    out.pixelSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.pixSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.tooltipText = (v) => (console.warn('map.tooltipText() is now deprecated. Please use map.tooltip(config.textFunction) instead. See API reference for details.'), out.tooltip_.textFunction = v, out);
    out.classifMethod = (v) => (console.warn('map.classifMethod() is now DEPRECATED. please use map.classificationMethod() instead.'), out.classificationMethod_ = v,out);
    out.threshold = (v) => (console.warn('map.threshold() is now DEPRECATED. please use map.thresholds() instead.'), out.thresholds_ = v,out);
    out.psThreshold = (v) => (console.warn('map.psThreshold() is now DEPRECATED. please use map.psThresholds() instead.'), out.psThresholds_ = v,out);
    out.clnb = (v) => (console.warn('map.clnb() is now DEPRECATED. please use map.numberOfClasses() instead.'), out.numberOfClasses_ = v,out);
    out.nutsLvl = (v) => (console.warn('map.nutsLvl() is now DEPRECATED. please use map.nutsLevel() instead.'), out.nutsLevel_ = v,out);
    out.lg = (v) => (console.warn('map.lg() is now DEPRECATED. please use map.language() instead.'), out.language_ = v,out);
    out.bottomText = (v) => (console.warn('bottomText is now DEPRECATED. Please use the footnote() method and em-footnote CSS class instead.'),out.footnote_ = v,out);
    out.botTxtFontSize = (v) => (console.warn('botTxtFontSize is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtFill = (v) => (console.warn('botTxtFill is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtPadding = (v) => (console.warn('botTxtPadding is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtTooltipTxt = (v) => (console.warn('botTxtTooltipTxt is now DEPRECATED. Please use footnoteTooltipText() instead.'),out);
    out.tooltipShowFlags = (v) =>(console.warn('tooltipShowFlags is now DEPRECATED. Please use out.tooltip({showFlags}) instead.'),out.tooltip_.showFlags = v,out);
    out.colorFun = (v) =>(console.warn('colorFun is now DEPRECATED. Please use out.colorFunction() instead.'),out.colorFunction_ = v,out);
    out.filtersDefinitionFun = (v)=>(console.warn('filtersDefinitionFun is now DEPRECATED. Please use out.filtersDefinitionFunction() instead.'),out.filtersDefinitionFunction_ = v,out);
    
    //labelling
    out.labelling = (v) =>(console.warn('labelling is now DEPRECATED. Please use out.labels({}) configuration object instead. See documentation for details.'),out);
    out.labelsConfig = (v) =>(console.warn('labelsConfig is now DEPRECATED. Please use out.labels({config:yourConfig}) configuration object instead. See documentation for details.'),out.labels_ =Object.assign(out.labels_ || {}, { config: v }),out);
    out.statLabelsPositions = (v) =>(console.warn('statLabelsPositions is now DEPRECATED. Please use out.labels({statLabelsPositions:yourPositions}) instead. See documentation for details.'),out.labels_ = Object.assign(out.labels_ || {}, { statLabelsPositions: v }),out);
    out.labelsToShow = (v) =>(console.warn('labelsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadowsToShow = (v) =>(console.warn('labelShadowsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadow = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelShadowWidth = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelFilterFunction =(v) =>(console.warn('labelFilterFunction is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) instead. See documentation for details.'),out);
    out.labelFill = (v) => (console.warn('map.labelFill() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStroke = (v) => (console.warn('map.labelStroke() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStrokeWidth = (v) => (console.warn('map.labelStrokeWidth() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelOpacity = (v) => (console.warn('map.labelOpacity() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelValuesFontSize = (v) => (console.warn('map.labelValuesFontSize() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelShadowWidth = (v) => (console.warn('map.labelShadowWidth() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);
    out.labelShadowColor = (v) => (console.warn('map.labelShadowColor() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);

    out.countriesToShow = (v) => (console.warn('map.countriesToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
    out.bordersToShow = (v) => (console.warn('map.bordersToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
}


/***/ }),

/***/ "./src/core/geometries.js":
/*!********************************!*\
  !*** ./src/core/geometries.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Geometries: () => (/* binding */ Geometries)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _kosovo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kosovo */ "./src/core/kosovo.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/graticule.js");
/* harmony import */ var idb_keyval__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! idb-keyval */ "./node_modules/idb-keyval/dist/index.js");
// takes care of the map's geometries







// Geometries class wrapped as a function
const Geometries = function (map, withCenterPoints) {
    let out = {}

    // defaults
    out.defaultGeoData = undefined
    out.allNUTSGeoData = undefined
    out.geoJSONs = {
        mixed: { rg0: undefined, rg1: undefined, rg2: undefined, rg3: undefined },
        cntbn: undefined,
        cntrg: undefined,
        nutsbn: undefined,
        nutsrg: undefined,
        gra: undefined,
        worldrg: undefined,
        worldbn: undefined,
        kosovo: undefined,
    }

    // user defined geometries (layers)
    out.userGeometries = undefined

    // user defined statistical regions
    out.statisticalRegions = undefined

    //centroids for prop symbols etc
    out.centroidsData = undefined //raw
    out.centroidsFeatures = undefined //geojson features

    // get geojson features of all statistical regions
    out.getRegionFeatures = function () {
        if (map.geo_ == 'WORLD') {
            return out.geoJSONs.worldrg
        } else {
            if (map.nutsLevel_ === 'mixed') {
                return [out.geoJSONs.mixed.rg0, out.geoJSONs.mixed.rg1, out.geoJSONs.mixed.rg2, out.geoJSONs.mixed.rg3]
            } else {
                return out.geoJSONs.nutsrg.concat(out.geoJSONs.cntrg)
            }
        }
    }

    /**
     * Retrieves and parses 'default' geo data (for NUTS or World maps)
     */
    out.getDefaultGeoData = function (geo, filterGeometriesFunction, nutsLevel) {
        const promises = out.getDefaultGeoDataPromise()
        return Promise.all(promises)
            .then((results) => {
                if (filterGeometriesFunction) {
                    results = filterGeometriesFunction(results)
                }
                out.allNUTSGeoData = results
                out.defaultGeoData = results[0]

                if (withCenterPoints) {
                    out.centroidsData = nutsLevel === 'mixed' ? [results[4], results[5], results[6], results[7]] : results[1]
                }

                const isWorld = geo === 'WORLD'
                // Decode TopoJSON to GeoJSON
                if (isWorld) {
                    out.geoJSONs.worldrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_RG_20M_2020_4326).features
                    out.geoJSONs.worldbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_BN_20M_2020_4326).features
                    out.geoJSONs.kosovo = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.NUTS_BN_20M_2021_RS_XK_border).features
                    out.geoJSONs.graticule = [(0,d3_geo__WEBPACK_IMPORTED_MODULE_3__["default"])().step([30, 30])()]
                } else {
                    out.geoJSONs.graticule = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.gra).features
                    out.geoJSONs.nutsrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsrg).features
                    out.geoJSONs.nutsbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsbn).features
                    out.geoJSONs.cntrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntrg).features
                    out.geoJSONs.cntbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntbn).features
                }

                return results
            })
            .catch((err) => {
                return Promise.reject(err)
            })
    }

    /**
     * Returns an array of promises for Nuts2JSON topojson data.
     */
    out.getDefaultGeoDataPromise = function () {
        const nutsLevels = [0, 1, 2, 3]
        const promises = []

        const buildUrl = (base, year, geo, proj, scale, level, withCenter = false) => {
            let path = `${base}/${year}`
            if (geo && geo !== 'EUR' && geo !== 'WORLD') path += `/${geo}`
            path += `/${geo == 'WORLD' ? '4326' : proj}`
            if (!withCenter && scale) path += `/${scale}`
            path += `/${withCenter ? 'nutspt_' : ''}${level}.json`
            return path
        }

        const TTL_MS = 24 * 60 * 60 * 1000 // cache refreshes every 24 hours

        const fetchWithCache = async (url) => {
            const cacheKey = `geojson-cache:${url}`

            try {
                const cached = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_4__.get)(cacheKey)
                if (cached) {
                    const { timestamp, data } = cached
                    const isFresh = Date.now() - timestamp < TTL_MS
                    if (isFresh) return data
                }
            } catch (e) {
                console.warn(`Error reading from IndexedDB cache for ${url}:`, e)
                throw e // Optionally allow failure to propagate
            }

            const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_5__["default"])(url)

            try {
                await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_4__.set)(cacheKey, {
                    timestamp: Date.now(),
                    data: data,
                })
            } catch (e) {
                console.warn(`Could not cache data in IndexedDB for ${url}:`, e)
                throw e // Optionally allow failure to propagate
            }

            return data
        }

        if (!map || !map.nuts2jsonBaseURL_) {
            throw new Error('Missing required map context or configuration')
        }

        if (map.nutsLevel_ === 'mixed' && map.geo_ !== 'WORLD') {
            nutsLevels.forEach((lvl) => {
                const url = buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl)
                promises.push(fetchWithCache(url))
            })
            if (withCenterPoints) {
                nutsLevels.forEach((lvl) => {
                    const url = buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl, true)
                    promises.push(fetchWithCache(url))
                })
            }
        } else if (map.geo_ === 'WORLD') {
            const worldMapTopojsonURL = window.location.hostname.includes('ec.europa.eu')
                ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/IMAGE/WORLD_4326.json'
                : 'https://raw.githubusercontent.com/eurostat/eurostat-map/master/src/assets/topojson/WORLD_4326.json'

            promises.push(fetchWithCache(worldMapTopojsonURL))
        } else {
            const mainUrl = buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_)
            promises.push(fetchWithCache(mainUrl))

            if (withCenterPoints) {
                const ptUrl = buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_, true)
                promises.push(fetchWithCache(ptUrl))
            }
        }

        return promises
    }

    /** Checks if all geo data is ready */
    out.isGeoReady = function () {
        if (!out.defaultGeoData && !out.userGeometries) return false

        let allReady = true

        ;(0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, null, (inset) => {
            if (!inset.Geometries.isGeoReady()) {
                allReady = false
            }
        })

        return allReady
    }

    out.setUserGeometries = function (geometries) {
        this.userGeometries = geometries

        // get regions that are linked to the statistics
        geometries.forEach((geometry) => {
            if (geometry.statisticalRegions) {
                this.statisticalRegions = geometry
            }
        })
    }

    out.addDefaultGeometriesToMap = function (container, drawGraticule, pathFunction, nutsLevel, nutsYear, geo, proj, scale) {
        if (this.geoJSONs.graticule && drawGraticule) {
            //draw graticule
            container
                .append('g')
                .attr('id', 'em-graticule')
                .attr('class', 'em-graticule')
                .selectAll('path')
                .data(this.geoJSONs.graticule)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw country regions
        if (this.geoJSONs.cntrg) {
            container
                .append('g')
                .attr('id', 'em-cntrg')
                .attr('class', 'em-cntrg')
                .selectAll('path')
                .data(this.geoJSONs.cntrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
                .attr('id', (cntrg) => {
                    // add ids for RS and EL so that we can choose not to add statistical data to them.
                    const id = cntrg.properties.id
                    if (id == 'RS' || id == 'EL') {
                        return 'em-cntrg-' + id
                    }
                })
        }

        //draw world map
        if (this.geoJSONs.worldrg) {
            container
                .append('g')
                .attr('id', 'em-worldrg')
                .attr('class', 'em-worldrg')
                .selectAll('path')
                .data(this.geoJSONs.worldrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw NUTS regions
        if (this.geoJSONs.nutsrg) {
            if (nutsLevel == 'mixed') {
                this.geoJSONs.mixed.rg0 = this.geoJSONs.nutsrg
                this.geoJSONs.mixed.rg1 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[1], out.allNUTSGeoData[1].objects.nutsrg).features
                this.geoJSONs.mixed.rg2 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[2], out.allNUTSGeoData[2].objects.nutsrg).features
                this.geoJSONs.mixed.rg3 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[3], out.allNUTSGeoData[3].objects.nutsrg).features

                //for mixed NUTS, we add every NUTS region across all levels and hide level 1,2,3 by default, only showing them when they have stat data
                // see updateClassification and updateStyle in map-choropleth.js for hiding/showing
                ;[this.geoJSONs.mixed.rg0, this.geoJSONs.mixed.rg1, this.geoJSONs.mixed.rg2, this.geoJSONs.mixed.rg3].forEach((r, i) => {
                    //append each nuts level to map
                    container
                        .append('g')
                        .attr('id', 'em-nutsrg')
                        .attr('class', `em-nutsrg em-nutsrg-${i}`)
                        .selectAll('path')
                        .data(r)
                        .enter()
                        .append('path')
                        .attr('d', pathFunction)
                        .attr('lvl', i) //to be able to distinguish nuts levels
                })

                //add kosovo
                if (geo == 'EUR' && (proj == '3035' || proj == '4326')) {
                    // add kosovo manually
                    addKosovoBorder(container, pathFunction, proj, scale, nutsYear)
                }
            } else {
                // when nutsLevel is not 'mixed'
                container
                    .append('g')
                    .attr('id', 'em-nutsrg')
                    .attr('class', 'em-nutsrg')
                    .selectAll('path')
                    .data(this.geoJSONs.nutsrg)
                    .enter()
                    .append('path')
                    .attr('d', pathFunction)
            }
        }

        //draw country boundaries
        if (this.geoJSONs.cntbn) {
            container
                .append('g')
                .attr('id', 'em-cntbn')
                .attr('class', 'em-cntbn')
                .selectAll('path')
                .data(this.geoJSONs.cntbn)
                .enter()
                .append('path')
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .attr('d', pathFunction)
                .attr('id', (bn) => 'em-bn-' + bn.properties.id)
                .attr('class', function (bn) {
                    let classList = []

                    if (bn.properties.eu === 'T') classList.push('em-bn-eu')
                    if (bn.properties.efta === 'T') classList.push('em-bn-efta')
                    if (bn.properties.cc === 'T') classList.push('em-bn-cc')
                    if (bn.properties.oth === 'T') classList.push('em-bn-oth')
                    if (bn.properties.co === 'T') classList.push('em-bn-co')

                    return classList.join(' ') // Use join with a space to create a valid class string
                })
        }

        //draw NUTS boundaries
        if (this.geoJSONs.nutsbn && nutsLevel !== 'mixed') {
            this.geoJSONs.nutsbn.sort(function (bn1, bn2) {
                return bn2.properties.lvl - bn1.properties.lvl
            })
            container
                .append('g')
                .attr('id', 'em-nutsbn')
                .attr('class', 'em-nutsbn')
                .selectAll('path')
                .data(this.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    let props = bn.properties
                    //KOSOVO
                    if (props.id > 100000) {
                        return 'em-kosovo-bn'
                    }
                    if (props.co === 'T') return 'em-bn-co'
                    const cl = ['em-bn-' + props.lvl]
                    //if (bn.oth === "T") cl.push("bn-oth");
                    return cl.join(' ')
                })
        }

        //draw world boundaries
        if (this.geoJSONs.worldbn) {
            container
                .append('g')
                .attr('id', 'em-worldbn')
                .attr('class', 'em-worldbn')
                .selectAll('path')
                .data(this.geoJSONs.worldbn)
                .enter()
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    if (bn.properties.POL_STAT > 0) {
                        //disputed
                        return 'em-bn-d'
                    }
                    return bn.properties.COAS_FLAG === 'T' ? 'em-bn-co' : 'em-worldbn'
                })
            //.attr("id", (bn) => bn.properties.CNTR_BN_ID)
        }

        if (this.geoJSONs.kosovo) {
            //add kosovo to world maps
            container
                .append('g')
                .attr('id', 'em-kosovo-bn')
                .attr('class', 'em-kosovo-bn')
                .selectAll('path')
                .data(this.geoJSONs.kosovo)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }
    }

    function addKosovoBorder(container, pathFunction, proj, scale, nutsYear) {
        let kosovoFeature = _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear] ? _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear][proj][scale] : _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[2024][proj][scale]
        let kosovoBn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(kosovoFeature, 'nutsbn_1').features
        container
            .append('g')
            .attr('id', 'em-kosovo-bn')
            .attr('class', 'em-kosovo-bn em-bn-cc')
            .selectAll('path')
            .data(kosovoBn)
            .enter()
            .append('path')
            .attr('d', pathFunction)
    }

    /**
     * @description Adds user-defined geometries to the map
     * E.g.
     * map.geometries([
     *  { id: 'regions', features: geoJSON.features, class: (feature) => 'region' },
     *  { id: 'borders', features: bordersData, class: (feature) => 'border' }
     * ])
     * @param geometries array of objects, each containing an array of geoJSON features
     * @param container d3 selection of the parent that we append the geometries to
     * @param pathFunction d3 path function
     */
    out.addUserGeometriesToMap = function (geometries, container, pathFunction) {
        geometries.forEach((geometry) => {
            let group = container
                .append('g')
                .attr('id', geometry.statisticalRegions ? 'em-user-regions' : '')
                .attr('class', geometry.class ? geometry.class : '')

            let elements = group.selectAll('path').data(geometry.features).enter().append('path').attr('d', pathFunction)

            // Allow custom call chain modifications through onEach
            if (typeof geometry.onEach === 'function') {
                geometry.onEach(elements)
            }
        })
    }

    return out
}


/***/ }),

/***/ "./src/core/insets.js":
/*!****************************!*\
  !*** ./src/core/insets.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildInsets: () => (/* binding */ buildInsets),
/* harmony export */   removeInsets: () => (/* binding */ removeInsets)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");



/**
 * Build inset maps for a map template
 */
const buildInsets = function (out, withCenterPoints) {
    if (!out.insetBoxPosition_) {
        out.insetBoxPosition_ = [out.width_ - out.insetBoxWidth_ - 2 * out.insetBoxPadding_, 2 * out.insetBoxPadding_]
    }

    // add container to drawing group
    // Cannot read properties of undefined (reading 'svgId')
    let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId_)
    let drawingGroup = svg.select('#em-drawing-' + out.svgId_)
    const ing = drawingGroup
        .append('g')
        .attr('id', 'em-insets-group')
        .attr('class', 'em-insets')
        .attr('transform', 'translate(' + out.insetBoxPosition_[0] + ',' + out.insetBoxPosition_[1] + ')')

    if (out.insets_ === 'default') {
        //if needed, use default inset config
        out.insets_ = defaultInsetConfig(out.insetBoxWidth_, out.insetBoxPadding_)
    }

    // append each inset to map
    for (let i = 0; i < out.insets_.length; i++) {
        const config = out.insets_[i]
        config.svgId = config.svgId || 'inset' + config.geo + Math.random().toString(36).substring(7)

        //get svg element.
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + config.svgId)
        if (svg.size() == 0) {
            // Create it as an embeded SVG if it does not exist
            const x = config.x == undefined ? out.insetBoxPadding_ : config.x
            const y = config.y == undefined ? out.insetBoxPadding_ + i * (out.insetBoxPadding_ + out.insetBoxWidth_) : config.y
            const ggeo = ing
                .append('g')
                .attr('id', 'em-inset-' + config.svgId)
                .attr('class', 'em-inset')
                .attr('transform', 'translate(' + x + ',' + y + ')')
            ggeo.append('svg').attr('id', config.svgId)
        }

        // build inset
        // GISCO-2676 - PT azores inset has 2 insets with the same Geo, so second was overriding first:
        if (out.insetTemplates_[config.geo]) {
            //if inset already exists in map with same geo, then push both to an array
            let inset = buildInset(config, out, withCenterPoints)
            inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = [out.insetTemplates_[config.geo], inset]
        } else {
            let inset = buildInset(config, out, withCenterPoints)
            let drawnInset = inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = drawnInset
        }
    }

    return out
}

/** Build template for inset, based on main one */
const buildInset = function (config, out, withCenterPoints) {
    //TODO find a better way to do that

    //copy map
    //for(let key__ in map) {
    //mt[key__] = map[key__];
    //}

    const mt = (0,_map_template__WEBPACK_IMPORTED_MODULE_0__.mapTemplate)(config, withCenterPoints)

    //define default values for inset configs
    config = config || {}
    config.proj = config.proj || _defaultCRS[config.geo]
    config.scale = config.scale || out.insetScale_
    config.footnote = config.footnote || ''
    config.showSourceLink = config.showSourceLink || false
    config.zoomExtent = config.zoomExtent || out.insetZoomExtent_
    config.width = config.width || out.insetBoxWidth_
    config.height = config.height || out.insetBoxWidth_
    config.insets = config.insets || []
    config.insetTemplates = config.insetTemplates || {}
    config.callback = config.callback || undefined

    //copy main map attributes
    ;[
        'nutsLevel_',
        'nutsYear_',
        'hoverColor_',
        //'nutsbnStroke_', // DEPRECATED
        // 'nutsbnStrokeWidth_', // DEPRECATED
        'cntrgFillStyle_', // DEPRECATED
        'cntbnStroke_', // DEPRECATED
        'cntbnStrokeWidth_', // DEPRECATED
        'seaFillStyle_', // DEPRECATED
        'drawCoastalMargin_',
        'coastalMarginColor_', // DEPRECATED
        'coastalMarginWidth_', // DEPRECATED
        'coastalMarginStdDev_',
        'graticuleStroke_', // DEPRECATED
        'graticuleStrokeWidth_', // DEPRECATED
        'lg_',
        'projectionFunction_',
        'filterGeometriesFunction_',
        'processCentroids_',
    ].forEach(function (att) {
        mt[att] = out[att]
    })

    //copy stat map attributes/methods
    ;['stat', 'statData', 'legend', 'legendObj', 'noDataText', 'language', 'transitionDuration', 'tooltip_', 'classToText_'].forEach(function (att) {
        mt[att] = out[att]
    })

    //apply config values for inset
    for (let key in config) mt[key + '_'] = config[key]

    mt.isInset = true // flag for inset-specific settings e.g. CSS class for titles
    return mt
}

/**
 * Remove insets maps from the DOM
 */
const removeInsets = function (out) {
    if (out.insetTemplates_) {
        for (let template in out.insetTemplates_) {
            let id = out.insetTemplates_[template].svgId_
            let existing = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + id)
            // if (existing) existing.remove()
            if (existing) existing.html('') // empty them, but dont remove them.
        }
        out.insetTemplates_ = {} //  GISCO-2676
    }
}

/**
 * Default inset setting.
 * @param {*} s The width of the inset box
 * @param {*} p The padding
 */
const defaultInsetConfig = function (s, p) {
    const out = [
        { geo: 'IC', x: 0, y: 0, width: s, height: 0.3 * s },
        { geo: 'CARIB', x: 0, y: 0.3 * s + p, width: 0.5 * s, height: s },
        { geo: 'GF', x: 0.5 * s, y: 0.3 * s + p, width: 0.5 * s, height: 0.75 * s },
        {
            geo: 'YT',
            x: 0.5 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'RE',
            x: 0.75 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT20',
            x: 0,
            y: 1.3 * s + 2 * p,
            width: 0.75 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT30',
            x: 0.75 * s,
            y: 1.3 * s + 2 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        { geo: 'MT', x: 0, y: 1.55 * s + 3 * p, width: 0.25 * s, height: 0.25 * s },
        {
            geo: 'LI',
            x: 0.25 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_SV',
            x: 0.5 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_JM',
            x: 0.75 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        /*{geo:"IC", x:0, y:0}, {geo:"RE", x:dd, y:0}, {geo:"YT", x:2*dd, y:0},
		{geo:"GP", x:0, y:dd}, {geo:"MQ", x:dd, y:dd}, {geo:"GF",scale:"10M", x:2*dd, y:dd},
		{geo:"PT20", x:0, y:2*dd}, {geo:"PT30", x:dd, y:2*dd}, {geo:"MT", x:2*dd, y:2*dd},
		{geo:"LI",scale:"01M", x:0, y:3*dd}, {geo:"SJ_SV", x:dd, y:3*dd}, {geo:"SJ_JM",scale:"01M", x:2*dd, y:3*dd},*/
        //{geo:"CARIB", x:0, y:330}, {geo:"IS", x:dd, y:330}
    ]
    //hide graticule for insets
    for (let i = 0; i < out.length; i++) out[i].drawGraticule = false
    return out
}

/** Default CRS for each geo area */
const _defaultCRS = {
    EUR: '3035',
    IC: '32628',
    GP: '32620',
    MQ: '32620',
    GF: '32622',
    RE: '32740',
    YT: '32738',
    MT: '3035',
    PT20: '32626',
    PT30: '32628',
    LI: '3035',
    IS: '3035',
    SJ_SV: '3035',
    SJ_JM: '3035',
    CARIB: '32620',
    WORLD: '54030',
}


/***/ }),

/***/ "./src/core/kosovo.js":
/*!****************************!*\
  !*** ./src/core/kosovo.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   kosovoBnFeatures: () => (/* binding */ kosovoBnFeatures)
/* harmony export */ });
// mixed nuts dont draw nutsbn so we add them manually
const kosovoBnFeatures = {
  2021:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[3061,1303],[-152,-59],[-32,-66],[-65,72],[-96,7],[-16,59],[-64,19],[-56,-39],[-120,39],[-184,-19],[-16,26],[32,52],[-16,72],[24,40],[8,183]],[[2885,0],[-8,46],[-65,85],[-40,-7],[-40,40],[0,111],[80,13],[25,46],[72,13],[40,98],[-56,118],[144,196],[-24,79],[88,59],[-24,98],[-8,20],[24,39],[8,52],[48,72],[-88,125]],[[825,2638],[-112,-98],[-72,-7],[-88,-118],[-176,-39],[56,-91],[88,-33],[24,-53],[56,-39],[24,-91],[-56,-46],[24,-105],[-56,-92],[-104,0],[-48,-104],[-16,-40],[-57,7],[-40,-53],[-16,-78],[113,-118],[-97,-65],[-88,-99],[-80,20],[-80,-39],[-24,-13]],[[1098,2304],[-193,66],[24,39],[-16,39],[65,13],[0,33],[-65,79],[-88,65]],[[2308,1689],[-153,-20],[-64,59],[-40,7],[-96,-27],[-104,138],[-8,92],[-32,78],[-64,26],[-32,-59],[-24,0],[-56,86],[-40,137],[-25,65],[-56,0],[-56,46],[-64,-72],[-120,53],[-88,-40],[-88,46]]],"transform":{"scale":[37.761044752777565,38.54734205626113],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[962,0],[-29,75],[48,131],[21,35],[11,38],[32,117],[-24,44]],[[1021,440],[-64,-29],[-70,36],[-120,2],[3,121]],[[770,570],[-126,16],[-40,91],[-45,4],[-51,93],[-142,4]],[[275,891],[-131,-99],[30,-36],[24,-31],[-6,-86],[-98,-86],[13,-64],[-27,-38],[-80,-31]],[[366,778],[-37,22],[-54,91]]],"transform":{"scale":[113.2099448513097,114.12782081303801],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[536,0],[-24,45],[15,30],[45,92],[-1,44],[-2,37]],[[569,248],[-130,9],[-10,64]],[[429,321],[-64,10],[-78,94],[-83,13]],[[153,502],[-73,-51],[26,-84],[-48,-53],[-3,-52],[-55,-25]],[[204,438],[-51,64]]],"transform":{"scale":[203.12309601494124,202.56551463031246],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[310,138],[-36,-2],[-40,42]],[[234,178],[-123,65]],[[84,278],[-84,-147]],[[111,243],[-27,35]],[[292,0],[18,138]]],"transform":{"scale":[372.84281730215633,364.87611898580536],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1900,1275],[-30,27],[-27,-13],[-34,23],[-87,6],[25,59],[1,70],[20,34],[24,167]],[[1792,1648],[-116,1],[-62,77],[-89,-8],[-60,148],[7,86],[-4,15],[-13,60],[-45,28],[-33,-48],[-26,4],[-31,142],[-11,53],[5,43],[-19,44],[-39,8],[-40,49],[-52,-59],[-93,71],[-38,-6],[-16,-26]],[[945,2388],[-54,27],[-20,28],[-22,-3],[-17,22],[-25,1],[-10,10],[4,17],[27,14],[-15,29],[1,16],[68,1],[-8,16],[-5,30],[-14,29],[-27,42],[-25,22],[-30,41]],[[773,2730],[-89,-69],[-64,-4],[-82,-92],[-133,-15],[27,-93],[64,-43],[16,-50],[38,-44],[9,-75],[-48,-51],[5,-41],[6,-50],[-52,-84],[-78,14],[-35,-66],[-33,-61],[-45,11],[-35,-42],[-18,-72],[33,-71],[48,-55]],[[1017,2330],[-72,58]],[[307,1677],[-36,-12],[-25,-21],[-26,-10],[-76,-90],[-17,4],[-30,31],[-52,-14],[-26,-23],[-19,1]],[[2319,1185],[-116,-32],[-39,-52],[-42,70],[-68,23],[-12,58],[-43,23],[-42,-23],[-57,23]],[[2044,0],[-4,43],[-38,82],[-34,9],[-24,43],[13,97],[61,4],[32,41],[49,0],[37,82],[-26,118],[130,167],[-8,73],[74,46],[-2,18],[-9,92],[24,35],[7,49],[48,52],[-55,134]]],"transform":{"scale":[0.0006038339283908974,0.00036983475567765975],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '10M':{"type":"Topology","arcs":[[[659,439],[-54,17],[17,111]],[[622,567],[-93,31],[-25,92],[-36,11],[-29,97],[-23,1],[-63,3]],[[328,822],[-33,74],[-27,44]],[[268,940],[-72,-44],[-38,-31],[27,-86],[-14,-65],[-81,-78],[16,-58]],[[353,802],[-25,20]],[[106,578],[-41,-19],[-65,-28]],[[805,408],[-54,-21],[-92,52]],[[709,0],[-22,72],[0,17],[40,36],[18,67],[53,101],[16,64],[-9,51]]],"transform":{"scale":[0.001740521547911524,0.0010740945563829907],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '20M':{"type":"Topology","arcs":[[[380,252],[-21,26],[0,48]],[[359,326],[-49,17],[-56,107],[-51,11]],[[189,472],[-34,68]],[[155,540],[-66,-39],[18,-66],[-54,-68],[8,-35]],[[61,332],[-21,-13],[-10,-12],[-13,5],[-17,-7]],[[464,234],[-84,18]],[[409,0],[-14,46],[61,110],[8,78]]],"transform":{"scale":[0.003018276831896498,0.0018697201537037245],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '60M':{"type":"Topology","arcs":[[[235,156],[-13,46]],[[222,202],[-96,84]],[[117,293],[-21,42]],[[96,335],[-58,-129]],[[126,286],[-9,7]],[[38,206],[-38,-17]],[[287,145],[-52,11]],[[253,0],[34,145]]],"transform":{"scale":[0.004879722822299564,0.0030138772626866006],"translate":[20.352928393000074,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}}
    }
  },
  2024:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[728,1508],[-48,12],[-22,18],[-15,-5],[-16,13],[-22,-4],[-10,8],[0,13],[21,13],[-16,17],[0,13],[58,9],[-5,8],[-10,22],[-16,17],[-27,25],[-21,13],[-32,26]],[[1912,0],[-6,30],[-42,51],[-32,0],[-21,30],[0,69],[53,8],[21,35],[43,4],[26,60],[-37,81],[96,129],[-16,51],[58,43],[0,9],[-21,64],[16,26],[5,34],[32,43],[-58,85]],[[250,942],[-27,-13],[-21,-17],[-21,-8],[-59,-73],[-16,0],[-26,17],[-43,-13],[-21,-21],[-16,0]],[[1657,861],[-27,13],[-21,-13],[-32,13],[-74,-9],[16,47],[-6,47],[11,26],[5,120]],[[1529,1105],[-100,-17],[-64,47],[-75,-17],[-63,94],[-6,60],[-5,13],[-16,38],[-42,13],[-22,-38],[-21,0],[-42,94],[-16,34],[0,30],[-21,30],[-32,0],[-38,30],[-42,-47],[-85,39],[-32,-9],[-10,-21]],[[547,1726],[-69,-60],[-53,-13],[-59,-73],[-111,-25],[32,-60],[58,-22],[16,-34],[37,-26],[16,-51],[-37,-39],[5,-30],[11,-34],[-37,-64],[-64,4],[-26,-51],[-22,-47],[-42,4],[-21,-34],[-11,-52],[37,-47],[43,-30]],[[797,1478],[-69,30]],[[2029,852],[-96,-38],[-32,-39],[-42,43],[-59,4],[-16,39],[-42,13],[-32,-22],[-53,9]]],"transform":{"scale":[56.97629608361119,58.91534666536319],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[242,508],[-33,47],[-27,27]],[[637,0],[-25,46],[-2,12],[30,29],[7,47],[34,75],[7,45],[-12,33]],[[83,318],[-32,-18],[-51,-26]],[[552,290],[-46,5],[3,78]],[[509,373],[-79,8],[-30,59],[-30,3],[-34,62],[-19,-1],[-52,-6]],[[182,582],[-55,-39],[-28,-25],[30,-56],[-5,-45],[-59,-62],[18,-37]],[[265,498],[-23,10]],[[676,287],[-43,-21],[-81,24]]],"transform":{"scale":[171.07449827433382,174.72145763645509],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[50,191],[-17,-11],[-8,-10],[-11,1],[-14,-6]],[[305,224],[-44,6],[-58,68],[-44,2]],[[109,350],[-52,-36],[21,-45],[-38,-54],[10,-24]],[[159,300],[-14,6]],[[145,306],[-36,44]],[[381,0],[-17,31],[41,85],[-1,57]],[[404,173],[-74,2]],[[330,175],[-20,15],[-5,34]]],"transform":{"scale":[286.13294356075795,290.536823841191],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[258,111],[-47,1]],[[32,123],[-32,-17]],[[211,112],[-16,32]],[[195,144],[-94,49]],[[70,225],[-38,-102]],[[101,193],[-8,4]],[[93,197],[-23,28]],[[243,0],[15,111]]],"transform":{"scale":[447.98943164212585,451.9461704196305],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1543,0],[-4,32],[-28,65],[-24,5],[-19,33],[10,70],[47,5],[23,33],[38,0],[28,59],[-19,92],[94,124],[-5,54],[56,37],[0,11],[-9,70],[19,27],[4,38],[38,38],[-42,102]],[[1750,895],[-85,-27],[-32,-37],[-29,54],[-56,16],[-5,43],[-32,16],[-33,-16],[-43,16]],[[1435,960],[-23,22],[-19,-11],[-28,16],[-66,5],[19,44],[0,54],[14,26],[19,125]],[[230,1262],[-24,-5],[-23,-16],[-19,-11],[-56,-65],[-14,0],[-24,27],[-37,-11],[-19,-21],[-14,5]],[[1351,1241],[-84,0],[-47,59],[-71,-6],[-42,114],[5,64],[-5,11],[-9,43],[-33,22],[-24,-38],[-23,6],[-23,108],[-5,37],[0,33],[-14,32],[-28,5],[-29,38],[-42,-43],[-70,54],[-28,-5],[-10,-22]],[[582,2055],[-66,-49],[-47,-5],[-61,-70],[-103,-11],[19,-70],[51,-32],[10,-38],[28,-32],[9,-54],[-37,-44],[4,-26],[5,-38],[-37,-65],[-61,11],[-29,-49],[-23,-48],[-33,11],[-28,-33],[-14,-54],[28,-54],[33,-43]],[[769,1753],[-56,48]],[[713,1801],[-42,17],[-14,21],[-19,0],[-9,16],[-19,0],[-10,6],[5,16],[19,11],[-9,21],[0,11],[51,0],[-5,11],[-4,22],[-10,26],[-23,27],[-19,22],[-23,27]]],"transform":{"scale":[0.0007994261320208862,0.0004913384355349169],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[539,0],[-17,52],[0,13],[30,27],[13,48],[41,74],[13,47],[-8,38]],[[611,299],[-41,-16],[-69,37]],[[501,320],[-41,13],[12,81]],[[80,421],[-31,-12],[-49,-20]],[[472,414],[-71,24],[-18,66],[-28,7],[-21,72],[-18,0],[-47,2]],[[203,686],[-54,-32],[-29,-22],[21,-63],[-12,-47],[-60,-57],[11,-44]],[[269,585],[-20,16]],[[249,601],[-25,53],[-21,32]]],"transform":{"scale":[0.002290098349828638,0.0014718665962452685],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[337,0],[-12,36],[51,84],[6,62]],[[382,182],[-69,13]],[[313,195],[-17,20],[-1,37]],[[50,256],[-17,-10],[-8,-8],[-11,3],[-14,-5]],[[295,252],[-40,13],[-46,82],[-41,9]],[[127,417],[-54,-30],[15,-51],[-44,-53],[6,-27]],[[168,356],[-12,10]],[[156,366],[-29,51]]],"transform":{"scale":[0.0036618323062750017,0.0024213440887871805],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[220,0],[29,116]],[[249,116],[-45,8]],[[204,124],[-12,37]],[[192,161],[-83,66]],[[109,227],[-8,6]],[[33,163],[-33,-12]],[[83,266],[-50,-103]],[[101,233],[-18,33]]],"transform":{"scale":[0.005617750767056427,0.003795866485053587],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}}
    }
  }
}

/***/ }),

/***/ "./src/core/labels.js":
/*!****************************!*\
  !*** ./src/core/labels.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULTLABELS: () => (/* binding */ DEFAULTLABELS),
/* harmony export */   addLabelsToMap: () => (/* binding */ addLabelsToMap),
/* harmony export */   statLabelsTextFunction: () => (/* binding */ statLabelsTextFunction),
/* harmony export */   updateLabels: () => (/* binding */ updateLabels),
/* harmony export */   updateValuesLabels: () => (/* binding */ updateValuesLabels)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");



// handles all map labels e.g. stat values, or labels specified in map.labels({labels:[text:'myLabel', x:123, y: 123]})

/**
 * @function addLabelsToMap
 * @param map eurostatmap map instance
 * @param zg zoomgroup (d3 selection of zoomable elements)
 * @description appends text labels to the map. Labels can be countries, country codes, ocean names or statistical values
 */
const addLabelsToMap = function (map, zg) {
    // set defaults
    if (!map.labels_.config) map.labels_.config = DEFAULTLABELS
    if (!map.labels_.statLabelsPositions) map.labels_.statLabelsPositions = DEFAULTSTATLABELPOSITIONS

    // clear existing or append new container
    let existing = zg.select('#em-labels')
    let labelsContainer = existing.empty() ? zg.append('g').attr('id', 'em-labels') : existing

    //for statistical values on maps without centroids, we need to add centroids initially, then add text to them later once the stat data is loaded
    if (map.labels_?.values && map._mapType !== 'ps') appendStatLabelCentroidsToMap(map, labelsContainer)

    // get labels array
    let labelsArray = map.labels_?.labels || DEFAULTLABELS[`${map.geo}_${map.proj_}.cc`]

    // append other labels to map
    if (labelsArray) {
        //common styles between all label shadows
        const shadowg = labelsContainer.append('g').attr('class', 'em-label-shadows').attr('text-anchor', 'middle')

        //common styles between all labels
        const labelg = labelsContainer.append('g').attr('class', 'em-labels').attr('text-anchor', 'middle')

        //SHADOWS
        if (map.labels_?.shadows) {
            let shadows = shadowg
                .selectAll('text')
                .data(labelsArray)
                .enter()
                .append('text')
                .attr('id', (d) => 'em-label-shadow-' + d.text.replace(/\s+/g, '-'))
                .attr('class', (d) => 'em-label-shadow em-label-shadow-' + d.class)
                .attr('x', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[0]
                })
                .attr('y', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[1]
                })
                .attr('dy', -7) // set y position of bottom of text
                .attr('transform', (d) => {
                    if (d.rotate) {
                        let pos = map._projection([d.x, d.y])
                        let x = pos[0]
                        let y = pos[1]
                        return `translate(${x},${y}) rotate(${d.rotate})`
                    } else {
                        return 'rotate(0)'
                    }
                })
                .text(function (d) {
                    return d.text
                }) // define the text to display
        }

        //LABEL texts
        labelg
            .selectAll('text')
            .data(labelsArray)
            .enter()
            .append('text')
            .attr('id', (d) => 'em-label-' + d.text.replace(/\s+/g, '-'))
            .attr('class', (d) => 'em-label em-label-' + d.class)
            //position label
            .attr('x', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[0]
            })
            .attr('y', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[1]
            })
            .attr('dy', -7) // set y position of bottom of text
            //transform labels which have a "rotate" property in the labels config. For rotated labels, their X,Y must also be set in the transform.
            // note: dont apply to country code labels
            .attr('transform', (d) => {
                if (d.rotate) {
                    let pos = map._projection([d.x, d.y])
                    let x = pos[0]
                    let y = pos[1]
                    return `translate(${x},${y}) rotate(${d.rotate})`
                } else {
                    return 'rotate(0)'
                }
            })
            .text(function (d) {
                return d.text
            }) // define the text to display
    }
}

/**
 * @function updateLabels
 * @description update existing map labels
 */
const updateLabels = function (map) {
    if (map.svg_) {
        // Clear previous labels
        let prevLabels = map.svg_.selectAll('#em-labels > *')
        if (prevLabels) prevLabels.remove()

        // Main map
        if (map.labels_) {
            const masterConfig = map.labels_
            let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
            addLabelsToMap(map, zg)
            if (masterConfig.values && map.updateValuesLabels) {
                map.updateValuesLabels(map)
            }

            // Define the callback to apply to each inset
            const applyLabelsCallback = (map) => {
                if (masterConfig) {
                    let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
                    if (map.labels_) addLabelsToMap(map, zg)
                    if (masterConfig.values && map.updateValuesLabels) {
                        map.updateValuesLabels(map)
                    }
                }
            }

            // Apply labels to all insets using the executeForAllInsets function
            if (map.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_0__.executeForAllInsets)(map.insetTemplates_, map.svgId_, applyLabelsCallback)
            }
        }
    }
}

/**
 * @description update the statistical values labels on the map
 * @param {Object} map eurostat-map map instance
 * @return {map} out
 * NOTE: THIS FUNCTION IS NOT CALLED FOR PROPORTIONAL SYMBOL MAPS
 */
const updateValuesLabels = function (map) {
    if (!map) {
        console.warn('No map specified')
        return
    }

    //clear previous labels
    let prevLabels = map.svg_.selectAll('g.em-stat-label > *')
    prevLabels.remove()
    let prevShadows = map.svg_.selectAll('g.em-stat-label-shadow > *')
    prevShadows.remove()
    let statLabels = map.svg_.selectAll('g.em-stat-label')

    // filter stat-label elements to only show those with data
    const filterFunction = map.labels_?.statLabelsFilterFunction ? map.labels_?.statLabelsFilterFunction : defaultStatLabelFilter
    const statData = map.statData()
    statLabels
        .filter((rg) => filterFunction(rg, map))
        // .append('text')
        .each(function (d) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this)
            const labelText = statLabelsTextFunction(d, statData) // Use 'd' directly for the label text

            // Append rectangle behind label
            if (map.labels_.backgrounds) appendRect(labelText, sel)

            // Append text after the rectangle
            sel.append('text').text(labelText).attr('class', 'em-stat-label-text')
        })

    // Function to append a rectangle behind the label
    function appendRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    //add shadows to labels
    if (map.labels_?.shadows) {
        map.svg_
            .selectAll('g.em-stat-label-shadow')
            .filter((rg) => filterFunction(rg, map))
            .append('text')
            .text((d) => statLabelsTextFunction(d, statData)) // Use 'd' directly for the label text)
    }
    return map
}

/**
 * @description text function for statistical labelling
 * @param {Object} d d3 selection json data element
 * @return {string}
 */
const statLabelsTextFunction = (d, statData) => {
    if (statData && statData?.get) {
        const sv = statData.get(d.properties.id)
        if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
            return ''
        } else {
            if (sv.value !== ':') {
                return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.spaceAsThousandSeparator)(sv.value)
            }
        }
    }
}

/**
 * @description function for filtering statistical labels
 * @param {Object} d d3 selection json data element
 * @return {boolean}
 */
const defaultStatLabelFilter = (region, map) => {
    const s = map.statData()
    const sv = s.get(region.properties.id)
    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
        return false
    } else {
        return true
    }
}

const appendStatLabelCentroidsToMap = function (map, labelsContainer) {
    //values label shadows parent <g>
    const gsls = labelsContainer.append('g').attr('class', 'em-stat-labels-shadows').attr('text-anchor', 'middle')

    // values labels parent <g>
    const statLabelsGroup = labelsContainer.append('g').attr('class', 'em-stat-labels').attr('text-anchor', 'middle')

    // our features array
    let statLabelRegions = []

    // deafult geometries
    if (map.Geometries.geoJSONs.nutsrg) {
        //allow for stat label positioning by adding a g element here, then adding the values in the mapType updateValuesLabels function
        if (map.nutsLevel_ == 'mixed') {
            statLabelRegions = map.Geometries.geoJSONs.mixed.rg0.concat(
                map.Geometries.geoJSONs.mixed.rg1,
                map.Geometries.geoJSONs.mixed.rg2,
                map.Geometries.geoJSONs.mixed.rg3,
                map.Geometries.geoJSONs.cntrg // NEW: allow labels for cntrg
            )
        } else {
            statLabelRegions = map.Geometries.geoJSONs.nutsrg.concat(map.Geometries.geoJSONs.cntrg)
        }
    } else if (map.Geometries.userGeometries) {
        // user defined geometries
        statLabelRegions = map.Geometries.statisticalRegions.features
    }

    //TODO: dont add labels for regions that are not visible? what about panning and zooming though. Only really an issue for mixed NUTS.

    // stats labels
    const filteredRegions = statLabelRegions.filter((d, i, self) => i === self.findIndex((t) => t.properties.id === d.properties.id))
    statLabelsGroup
        .selectAll('g')
        .data(filteredRegions)
        .enter()
        .append('g')
        .attr('transform', function (d) {
            // use predefined label positioning
            if (map.labels_.statLabelsPositions[d.properties.id]) {
                const position = map.labels_.statLabelsPositions[d.properties.id]
                let pos = map._projection([position.x, position.y])
                let x = pos[0].toFixed(3)
                let y = pos[1].toFixed(3)
                return `translate(${x},${y})`
            } else {
                let centroid = map._pathFunction.centroid(d)

                if (map.labels_.processValueLabelCentroids) {
                    centroid = map.labels_.processValueLabelCentroids(d, centroid)
                }
                // otherwise we calculate centroids
                return 'translate(' + centroid + ')'
            }
        })
        .attr('class', 'em-stat-label')

    // stat labels shadows
    if (map.labels_?.shadows) {
        gsls.selectAll('g')
            .data(statLabelRegions)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                // use predefined label positioning
                if (map.labels_.statLabelsPositions[d.properties.id]) {
                    let pos = map._projection([
                        map.labels_.statLabelsPositions[d.properties.id].x,
                        map.labels_.statLabelsPositions[d.properties.id].y,
                    ])
                    let x = pos[0].toFixed(3)
                    let y = pos[1].toFixed(3)
                    return `translate(${x},${y})`
                } else {
                    let centroid = map._pathFunction.centroid(d)

                    if (map.labels_.processValueLabelCentroids) {
                        centroid = map.labels_.processValueLabelCentroids(d, centroid)
                    }
                    // otherwise we calculate centroids
                    return 'translate(' + centroid + ')'
                }
            })

            .attr('class', 'em-stat-label-shadow')
    }
}

/**
 * Default labels for country / geographical names.
 * Using centroids would clash with proportional symbols, and are generally not ideal placements, so labels are positioned independently
 * Labels are provided for all supported languages: "en","fr" and "de" (defined using map.language())
 */
const DEFAULTLABELS = {
    EUR_3035: {
        cc: [
            { text: 'AL', x: 5150000, y: 2060000, class: 'cc', size: 7 },
            { text: 'AT', x: 4670000, y: 2690000, class: 'cc', size: 18 },
            { text: 'BE', x: 3930000, y: 3010000, class: 'cc', size: 17 },
            { text: 'BG', x: 5567000, y: 2250000, class: 'cc', size: 22 },
            { text: 'HR', x: 4840000, y: 2480000, class: 'cc', size: 10 },
            { text: 'CY', x: 6426000, y: 1480000, class: 'cc', size: 10 },
            { text: 'CZ', x: 4707000, y: 2920000, class: 'cc', size: 18 },
            { text: 'DK', x: 4316000, y: 3621000, class: 'cc', size: 20 },
            { text: 'EE', x: 5220000, y: 3990000, class: 'cc', size: 12 },
            { text: 'FI', x: 5150000, y: 4424000, class: 'cc', size: 20 },
            { text: 'FR', x: 3767740, y: 2662817, class: 'cc', size: 22 },
            { text: 'DE', x: 4347284, y: 3093276, class: 'cc', size: 22 },
            { text: 'EL', x: 5370000, y: 1750000, class: 'cc', size: 22 },
            { text: 'HU', x: 5020000, y: 2630000, class: 'cc', size: 17 },
            { text: 'IS', x: 3040000, y: 4833000, class: 'cc', size: 10 },
            { text: 'IE', x: 3136000, y: 3394000, class: 'cc', size: 17 },
            { text: 'IT', x: 4469967, y: 2181963, class: 'cc', size: 22 },
            { text: 'LV', x: 5290000, y: 3800000, class: 'cc', size: 12 },
            { text: 'LT', x: 5190000, y: 3630000, class: 'cc', size: 12 },
            { text: 'LU', x: 4120000, y: 2940000, class: 'cc', size: 12 },
            { text: 'MT', x: 4731000, y: 1300000, class: 'cc', size: 10 },
            { text: 'ME', x: 5073000, y: 2185000, class: 'cc', size: 7 },
            { text: 'GE', x: 6942680, y: 2660000, class: 'cc' },
            { text: 'UA', x: 5890000, y: 3050000, class: 'cc' },
            { text: 'BA', x: 4949262, y: 2338688, class: 'cc' },
            { text: 'MD', x: 5740000, y: 2790000, class: 'cc' },

            { text: 'MK', x: 5300000, y: 2080000, class: 'cc', size: 10 },
            { text: 'NL', x: 4020000, y: 3208000, class: 'cc', size: 17 },
            { text: 'NO', x: 4300000, y: 4147000, class: 'cc', size: 20 },
            { text: 'PL', x: 4964000, y: 3200000, class: 'cc', size: 22 },
            { text: 'PT', x: 2770000, y: 1990000, class: 'cc', size: 18 },
            { text: 'RO', x: 5451000, y: 2600000, class: 'cc', size: 22 },
            { text: 'RS', x: 5200000, y: 2350000, class: 'cc', size: 10 },
            { text: 'SK', x: 5040000, y: 2860000, class: 'cc', size: 12 },
            { text: 'SI', x: 4675000, y: 2500000, class: 'cc', size: 10 },
            { text: 'ES', x: 3160096, y: 1900000, class: 'cc', size: 22 },
            { text: 'SE', x: 4630000, y: 4000000, class: 'cc', size: 20 },
            { text: 'CH', x: 4170000, y: 2600000, class: 'cc', size: 16 },
            { text: 'TR', x: 6510000, y: 2100000, class: 'cc', size: 22 },
            { text: 'UK', x: 3558000, y: 3250000, class: 'cc', size: 17 },
        ],
        en: [
            { text: 'MEDITERRANEAN SEA', x: 3980000, y: 1600000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTIC OCEAN', x: 2820000, y: 2540000, class: 'seas', size: 12, letterSpacing: 2 },
            { text: 'NORTH SEA', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'BALTIC SEA', x: 4900000, y: 3730000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGIAN SEA', x: 3850000, y: 4800000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'BLACK SEA', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 4 },
            { text: 'ALBANIA', cc: 'AL', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUSTRIA', cc: 'AT', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIUM', cc: 'BE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIA', cc: 'BG', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIA', cc: 'HR', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CYPRUS', cc: 'CY', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'CZECHIA', cc: 'CZ', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DENMARK', cc: 'DK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIA', cc: 'EE', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINLAND', cc: 'FI', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', cc: 'FR', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'GERMANY', cc: 'DE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GREECE', cc: 'EL', x: 5470000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HUNGARY', cc: 'HU', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ICELAND', cc: 'IS', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRELAND', cc: 'IE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALY', cc: 'IT', x: 4469967, y: 2181963, class: 'countries', size: 12 },
            { text: 'LATVIA', cc: 'LV', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITHUANIA', cc: 'LT', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', cc: 'LU', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', cc: 'MT', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', cc: 'ME', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'N. MACEDONIA', cc: 'MK', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NETHERLANDS', cc: 'NL', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWAY', cc: 'NO', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLAND', cc: 'PL', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', cc: 'PT', x: 2830000, y: 1990000, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROMANIA', cc: 'RO', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIA', cc: 'RS', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAKIA', cc: 'SK', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVENIA', cc: 'SI', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPAIN', cc: 'ES', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SWEDEN', cc: 'SE', x: 4630000, y: 4100000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SWITZERLAND', cc: 'CH', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURKEY', cc: 'TR', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'U.K.', cc: 'UK', x: 3558000, y: 3250000, class: 'countries', size: 12 },
        ],
        fr: [
            { text: 'MER MÉDITERRANÉE', x: 5472000, y: 1242000, class: 'seas', size: 12 },
            { text: 'OCÈAN ATLANTIQUE', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'MER DU NORD', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'MER BALTIQUE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'MER DE NORVÈGE', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'MER NOIRE', x: 6265000, y: 2472000, class: 'seas', size: 12 },
            { text: 'ALBANIE', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUTRICHE', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIQUE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIE', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIE', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CHYPRE', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TCHÉQUIE', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DANEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIE', x: 5220000, y: 3990000, class: 'countries', size: 10 },
            { text: 'FINLANDE', x: 5125000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'ALLEMAGNE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GRÈCE', x: 5420000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HONGRIE', x: 5020000, y: 2654000, class: 'countries', size: 10 },
            { text: 'ISLANDE', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLANDE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIE', x: 4500000, y: 2181963, class: 'countries', size: 12 },
            { text: 'LETTONIE', x: 5290000, y: 3776000, class: 'countries', size: 10 },
            { text: 'LITUANIE', x: 5190000, y: 3630000, class: 'countries', size: 10 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTE', x: 4731000, y: 1335000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'MAC. DU NORD', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'PAYS-BAS', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORVEGE', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLOGNE', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROUMANIE', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIE', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAQUIE', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVÉNIE', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -35 },
            { text: 'ESPAGNE', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SUÈDE', x: 4700000, y: 4401000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SUISSE', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURQUIE', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'ROYAUME-UNI', x: 3558000, y: 3250000, class: 'countries', size: 10 },
        ],
        de: [
            { text: 'MITTELMEER', x: 5472000, y: 1200000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTISCHER OZEAN', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'NORDSEE', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'OSTSEE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGISCHE MEER', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'SCHWARZE MEER', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'ALBANIEN', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'ÖSTERREICH', x: 4650000, y: 2629000, class: 'countries', size: 7 },
            { text: 'BELGIEN', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIEN', x: 5567000, y: 2256000, class: 'countries', size: 10 },
            { text: 'KROATIEN', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'ZYPERN', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TSCHECHIEN', x: 4707000, y: 2885000, class: 'countries', size: 7 },
            { text: 'DÄNEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTLAND', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINNLAND', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANKREICH', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'DEUTSCHLAND', x: 4347284, y: 3093276, class: 'countries', size: 10 },
            { text: 'GRIECHENLAND', x: 5550000, y: 1500000, class: 'countries', size: 10 },
            { text: 'UNGARN', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ISLAND', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLAND', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIEN', x: 4469967, y: 2181963, class: 'countries', size: 12, rotate: 35 },
            { text: 'LETTLAND', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITAUEN', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'NORDMAZEDONIEN', x: 5350000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NIEDERLANDE', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWEGEN', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLEN', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'RUMÄNIEN', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIEN', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOWAKEI', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOWENIEN', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPANIEN', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SCHWEDEN', x: 4670000, y: 4180000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SCHWEIZ', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TRUTHAHN', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'VEREINIGTES', x: 3550000, y: 3520000, class: 'countries', size: 10 },
            { text: 'KÖNIGREICH', x: 3550000, y: 3420000, class: 'countries', size: 10 },
        ],
    },
    IC_32628: {
        cc: [{ text: 'ES', x: 420468, y: 3180647, class: 'cc', size: 12 }],
        en: [{ text: 'Canary Islands', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        fr: [{ text: 'Les îles Canaries', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        de: [{ text: 'Kanarische Inseln', x: 410000, y: 3180647, class: 'countries', size: 12 }],
    },
    GP_32620: {
        cc: [{ text: 'FR', x: 667000, y: 1740000, class: 'cc', size: 12 }],
        en: [{ text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 12 }],
    },
    MQ_32620: {
        cc: [{ text: 'FR', x: 716521, y: 1621322, class: 'cc', size: 12 }],
        en: [{ text: 'Martinique', x: 716521, y: 1621322, class: 'countries', size: 12 }],
    },
    GF_32622: {
        cc: [{ text: 'FR', x: 266852, y: 444074, class: 'cc', size: 12 }],
        en: [{ text: 'Guyane', x: 266852, y: 444074, class: 'countries', size: 12 }],
        de: [{ text: 'Guayana', x: 266852, y: 444074, class: 'countries', size: 12 }],
    },
    RE_32740: {
        cc: [{ text: 'FR', x: 348011, y: 7680000, class: 'cc', size: 10 }],
        en: [{ text: 'Réunion', x: 348011, y: 7680000, class: 'countries', size: 10 }],
    },
    YT_32738: {
        cc: [{ text: 'FR', x: 516549, y: 8593920, class: 'cc', size: 10 }],
        en: [{ text: 'Mayotte', x: 516549, y: 8593920, class: 'countries', size: 10 }],
    },
    MT_3035: {
        cc: [{ text: 'MT', x: 4719755, y: 1410701, class: 'cc', size: 10 }],
        en: [{ text: 'Malta', x: 4719755, y: 1410701, class: 'countries', size: 10 }],
    },
    PT20_32626: {
        cc: [{ text: 'PT', x: 397418, y: 4320000, class: 'cc', size: 10 }],
        en: [{ text: 'Azores', x: 397418, y: 4320000, class: 'countries', size: 10 }],
        fr: [{ text: 'Açores', x: 397418, y: 4271471, class: 'countries', size: 10 }],
        de: [{ text: 'Azoren', x: 397418, y: 4271471, class: 'countries', size: 10 }],
    },
    PT30_32628: {
        cc: [{ text: 'PT', x: 333586, y: 3624000, class: 'cc', size: 10, rotate: 30 }],
        en: [{ text: 'Madeira', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
        fr: [{ text: 'Madère', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
    },
    LI_3035: {
        cc: [{ text: 'LI', x: 4287060, y: 2660000, class: 'cc', size: 12 }],
        en: [{ text: 'Liechtenstein', x: 4287060, y: 2679000, class: 'countries', size: 7 }],
    },
    IS_3035: {
        cc: [{ text: 'IS', x: 3011804, y: 4960000, class: 'cc', size: 12 }],
        en: [{ text: 'Iceland', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        fr: [{ text: 'Islande', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        de: [{ text: 'Island', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
    },
    SJ_SV_3035: {
        cc: [{ text: 'NO', x: 4570000, y: 6260000, class: 'cc', size: 10 }],
        en: [{ text: 'Svalbard', x: 4570000, y: 6260000, class: 'countries', size: 10 }],
        de: [{ text: 'Spitzbergen', x: 4570000, y: 6260000, class: 'countries', size: 7 }],
    },
    SJ_JM_3035: {
        cc: [{ text: 'NO', x: 3647762, y: 5420300, class: 'cc', size: 10 }],
        en: [{ text: 'Jan Mayen', x: 3647762, y: 5420300, class: 'countries', size: 7 }],
    },
    CARIB_32620: {
        cc: [
            { text: 'FR', x: 700000, y: 1810000, class: 'cc', size: 10 },
            { text: 'FR', x: 640000, y: 1590000, class: 'cc', size: 10 },
            { text: 'FR', x: 540000, y: 1962000, class: 'cc', size: 7 },
        ],
        en: [
            { text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 10 },
            { text: 'Martinique', x: 570000, y: 1590000, class: 'countries', size: 10 },
            { text: 'Saint Martin', x: 597000, y: 1962000, class: 'countries', size: 7 },
        ],
    },
    // note: WORLD x/y are in EPSG:4326 then reprojected by d3 to EPSG:54030
    WORLD_54030: {
        en: [
            { text: 'NORTH ATLANTIC', x: -45, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH ATLANTIC', x: -15, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH PACIFIC', x: -126, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'NORTH', x: -136, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'PACIFIC', x: -134, y: 20, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'INDIAN OCEAN', x: 80, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTHERN OCEAN', x: -5, y: -67, class: 'seas', size: 10, letterSpacing: 6 },
        ],
    },
}

const DEFAULTSTATLABELPOSITIONS = {
    AL: { x: 5150000, y: 2000000 },
    AT: { x: 4670000, y: 2740000 },
    BE: { x: 3930000, y: 3060000 },
    BG: { x: 5567000, y: 2300000 },
    HR: { x: 4657718, y: 2400243 },
    CY: { x: 6426000, y: 1570000 },
    CH: { x: 4170000, y: 2600000 },
    CZ: { x: 4707000, y: 2950000 },
    DK: { x: 4316000, y: 3621000 },
    EE: { x: 5220000, y: 4050000 },
    FI: { x: 5150000, y: 4424000 },
    FR: { x: 3767740, y: 2662817 },
    DE: { x: 4347284, y: 3093276 },
    EL: { x: 5370000, y: 1750000 },
    HU: { x: 5020000, y: 2670000 },
    IS: { x: 3040000, y: 4833000 },
    IE: { x: 3136000, y: 3394000 },
    IT: { x: 4500000, y: 2181963 },
    LV: { x: 5290000, y: 3840000 },
    LT: { x: 5190000, y: 3670000 },
    LU: { x: 4120000, y: 2940000 },
    MT: { x: 4880000, y: 1480000 },
    GE: { x: 6912680, y: 2696554 },
    UA: { x: 5865507, y: 3130158 },
    BA: { x: 4959262, y: 2368688 },
    MD: { x: 5736016, y: 2835957 },
    ME: { x: 5073000, y: 2230000 },
    MK: { x: 5300000, y: 2130000 },
    NL: { x: 4020000, y: 3208000 },
    NO: { x: 4300000, y: 4147000 },
    PL: { x: 4964000, y: 3200000 },
    PT: { x: 2760000, y: 1990000 },
    RO: { x: 5451000, y: 2600000 },
    RS: { x: 5200000, y: 2370000 },
    SK: { x: 5040000, y: 2890000 },
    SI: { x: 4660000, y: 2550000 },
    ES: { x: 3200000, y: 2000000 },
    SE: { x: 4630000, y: 4000000 },
    TR: { x: 6510000, y: 2100000 },
    UK: { x: 3558000, y: 3250000 },
    RU: { x: 6842086, y: 3230517 },
}


/***/ }),

/***/ "./src/core/map-template.js":
/*!**********************************!*\
  !*** ./src/core/map-template.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapTemplate: () => (/* binding */ mapTemplate)
/* harmony export */ });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/src/robinson.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _annotations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotations */ "./src/core/annotations.js");
/* harmony import */ var _labels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels */ "./src/core/labels.js");
/* harmony import */ var _deprecated__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deprecated */ "./src/core/deprecated.js");
/* harmony import */ var _geometries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geometries */ "./src/core/geometries.js");
/* harmony import */ var _insets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./insets */ "./src/core/insets.js");
/* harmony import */ var _stamps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stamps */ "./src/core/stamps.js");
/* harmony import */ var _cartograms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cartograms */ "./src/core/cartograms.js");
/* harmony import */ var _minimaps__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./minimaps */ "./src/core/minimaps.js");















// set default d3 locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_10__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * The map template: only the geometrical part.
 * To be used as a base map for a statistical map.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const mapTemplate = function (config, withCenterPoints, mapType) {
    //build map template object
    const out = {}
    out._mapType = mapType

    // expose imported function to other modules
    out.updateValuesLabels = _labels__WEBPACK_IMPORTED_MODULE_3__.updateValuesLabels

    //map
    out.svgId_ = 'map'
    out.svg_ = undefined
    out.width_ = Math.min(795, window.innerWidth)
    out.height_ = 0
    out.containerId_ = undefined

    //geographical focus
    out.gridCartogram_ = false // draw geometries as grid cells
    out.gridCartogramShape_ = 'square' // square or hexagon
    out.gridCartogramMargins_ = { top: 80, right: 50, bottom: 80, left: 150 }
    out.gridCartogramCellPadding_ = 4
    out.gridCartogramPositions_ = undefined //user defined cartograms
    out.nutsLevel_ = 3 // 0,1,2,3, or 'mixed'
    out.nutsYear_ = 2024
    out.geo_ = 'EUR'
    out.proj_ = '3035'
    out.projectionFunction_ = undefined // e.g. d3.geoRobinson()
    out.filterGeometriesFunction_ = undefined // user defined filter function
    out.scale_ = '20M' //TODO choose automatically, depending on pixelSize ?
    out.zoomExtent_ = undefined
    out.maxBounds_ = { xMin: -Infinity, yMin: -Infinity, xMax: Infinity, yMax: Infinity }
    out.geometries_ = undefined // [{id:String, data:geojson, class:function}] user-defined geometries
    out.processCentroids_ = undefined // runs over symbol centroids
    out.position_ = { x: undefined, y: undefined, z: undefined } // map view

    //map title
    out.title_ = ''
    out.titlePosition_ = undefined

    //map subtitle
    out.subtitle_ = ''
    out.subtitlePosition_ = undefined

    //scalebar
    out.showScalebar_ = false
    out.scalebarPosition_ = []
    out.scalebarUnits_ = ' km' //label
    out.scalebarTextOffset_ = [0, 12]
    out.scalebarMaxWidth_ = 150 //px
    out.scalebarHeight_ = 90 //px
    out.scalebarStrokeWidth_ = 1 //px
    out.scalebarSegmentHeight_ = 6
    out.scalebarTickHeight_ = 8

    // stamp annotation
    out.stamp_ = undefined //e.g {x,y,text,size}

    //minimap
    out.minimap_ = undefined

    //tooltip
    out.tooltip_ = {
        fontSize: '14px',
        transitionDuration: 200,
        xOffset: 0,
        yOffset: 0,
        textFunction: null,
        showFlags: false,
        omitList: false, // if specified, tooltip will not show the list of regions
    } //  See tooltip.js for more details

    // region mouseover color
    out.hoverColor_ = 'red'

    //coastal margin
    out.drawCoastalMargin_ = false
    out.coastalMarginStdDev_ = 3

    //graticule
    out.drawGraticule_ = false

    //background map toggle (e.g. for dorling)
    out.backgroundMap_ = true

    //labelling
    // see docs\reference.md#labelling
    out.labels_ = undefined

    //annotations
    out.annotations_ = undefined
    out.annotationsAdded = false //simple flag to know when annotations have already been added

    //hatching
    out.patternFill_ = undefined // e.g. {pattern:'hatching',regionIds:['DE','FR']}

    //dataset source link
    out.showSourceLink_ = true

    //default copyright and disclaimer text
    out.footnote_ = 'Administrative boundaries: \u00A9EuroGeographics \u00A9UN-FAO \u00A9INSTAT \u00A9Turkstat' //"(C)EuroGeographics (C)UN-FAO (C)Turkstat";
    out.footnoteTooltipText_ =
        'The designations employed and the presentation of material on this map do not imply the expression of any opinion whatsoever on the part of the European Union concerning the legal status of any country, territory, city or area or of its authorities, or concerning the delimitation of its frontiers or boundaries. Kosovo*: This designation is without prejudice to positions on status, and is in line with UNSCR 1244/1999 and the ICJ Opinion on the Kosovo declaration of independence.'

    out.nuts2jsonBaseURL_ = window.location.hostname.includes('ec.europa.eu')
        ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/pub/nuts2json/v2'
        : 'https://raw.githubusercontent.com/eurostat/Nuts2json/master/pub/v2'

    //style for no data regions
    out.noDataFillStyle_ = '#bcbcbc'

    /**
     * Insets.
     * The map template has a recursive structure.
     */

    //insets to show, as a list of map template configs. Ex.: [{geo:"MT"},{geo:"LI"},{geo:"PT20"}]
    out.insets_ = []
    //inset templates - each inset is a map-template instance.
    out.insetTemplates_ = {}

    out.insetBoxPosition_ = undefined
    out.insetBoxPadding_ = 5
    out.insetBoxWidth_ = 210
    //out.insetZoomExtent_ = [1, 3];
    out.insetZoomExtent_ = null //zoom disabled as default
    out.insetScale_ = '03M'

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    for (const att in out) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    }

    // warn existing users of functions that have been banished to the shadow realm.
    (0,_deprecated__WEBPACK_IMPORTED_MODULE_4__.defineDeprecatedFunctions)(out)

    // convert geo to uppercase
    out.geo = function (v) {
        if (!arguments.length) return out.geo_
        out.geo_ = v.toUpperCase()
        return out
    }

    //special ones which affect also the insets
    ;['tooltip_', 'nuts2jsonBaseURL_', 'processCentroids_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]

            if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
                //override default properties
                for (const p in v) {
                    out[att][p] = v[p]
                }
            } else {
                out[att] = v
            }

            //recursive call to inset components
            if (out.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(
                    out.insetTemplates_,
                    out.svgId_,
                    (inset, value) => {
                        const fnName = att.substring(0, att.length - 1)
                        inset[fnName](value)
                    },
                    v
                )
            }
            return out
        }
    })

    //title getter and setter
    out.title = function (v) {
        if (!arguments.length) return out.title_
        out.title_ = v
        if (out.svg())
            out.svg()
                .select('#title' + out.geo())
                .text(v)
        return out
    }

    //subtitle getter and setter
    out.subtitle = function (v) {
        if (!arguments.length) return out.subtitle_
        out.subtitle_ = v
        if (out.svg())
            out.svg()
                .select('#subtitle' + out.geo())
                .text(v)
        return out
    }

    //insets getter/setter
    out.insets = function () {
        if (!arguments.length) return out.insets_
        if (arguments.length == 1 && arguments[0] === 'default') out.insets_ = 'default'
        else if (arguments.length == 1 && arguments[0] === false) out.insets_ = false
        else if (arguments.length == 1 && Array.isArray(arguments[0])) out.insets_ = arguments[0]
        else out.insets_ = arguments
        return out
    }

    // dynamic draw graticule
    out.drawGraticule = function (v) {
        if (!arguments.length) return out.drawGraticule_
        out.drawGraticule_ = v

        //update graticule
        let graticule = out.svg_ ? out.svg().select('#em-graticule') : null
        let zg = out.svg_ ? out.svg_.select('#em-zoom-group-' + out.svgId_) : null

        // if existing and argument is false
        if (graticule) {
            if (graticule._groups[0][0] && v == false) {
                //remove graticule
                graticule.remove()

                // if map already created and argument is true
            } else if (out.Geometries.geoJSONs.graticule && out._pathFunction && zg && v == true) {
                //remove existing graticule
                graticule.remove()
                // add new graticule
                zg.append('g')
                    .attr('id', 'em-graticule')
                    .selectAll('path')
                    .data(out.Geometries.geoJSONs.graticule)
                    .enter()
                    .append('path')
                    .attr('d', out._pathFunction)
                    .attr('class', 'em-graticule')

                out.svg()
                    .select('#em-graticule')
                    .each(function () {
                        // move graticule behind land mass
                        out.geo_ == 'WORLD'
                            ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                            : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                    })
            }
        }
        return out
    }

    //coastal margin override
    out.drawCoastalMargin = function (v) {
        if (!arguments.length) return out.drawCoastalMargin_
        out.drawCoastalMargin_ = v

        //update existing
        if (out.svg_) {
            let margin = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-coast-margin')
            let filter = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('#em-coastal-blur')
            let zg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('#em-zoom-group-' + out.svgId_) || null
            if (margin._groups[0][0] && v == false) {
                // remove existing
                margin.remove()
            } else if (v == true && out._pathFunction && zg) {
                //remove existing graticule
                margin.remove()
                filter.remove()
                //add filter
                out.svg_
                    .append('filter')
                    .attr('id', 'em-coastal-blur')
                    .attr('x', '-200%')
                    .attr('y', '-200%')
                    .attr('width', '400%')
                    .attr('height', '400%')
                    .append('feGaussianBlur')
                    .attr('in', 'SourceGraphic')
                    .attr('stdDeviation', out.coastalMarginStdDev_)

                //draw for main map - geometries are still in memory so no rebuild needed
                const drawNewCoastalMargin = (map) => {
                    // zoom group might not be inside main map (out.svg_)
                    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('#em-zoom-group-' + map.svgId_)
                    //draw new coastal margin
                    const cg = zoomGroup.append('g').attr('id', 'em-coast-margin')

                    //countries bn
                    if (map._geom.cntbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-cnt')
                            .selectAll('path')
                            .data(map._geom.cntbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //nuts bn
                    if (map._geom.nutsbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.nutsbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //world bn
                    if (map._geom.worldbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.worldbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.COAS_FLAG === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                }

                //draw for insets - requires geometries so we have to rebuild base template
                if (out.insetTemplates_ && out.drawCoastalMargin_) {
                    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, drawNewCoastalMargin)
                    drawNewCoastalMargin(out)
                }

                // move margin to back (in front of sea)
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-coast-margin').each(function () {
                    out.geo_ == 'WORLD'
                        ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                        : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                })
            }
        }
        return out
    }

    //annotations override (update after first call)
    out.annotations = function (v) {
        //get
        if (!arguments.length) return out.annotations_
        //set
        out.annotations_ = v
        //update
        ;(0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
        return out
    }

    //stamps override (update after first call)
    out.stamp = function (v) {
        //get
        if (!arguments.length) return out.stamp_
        //set
        out.stamp_ = v
        //update
        ;(0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        return out
    }

    //minimap override (update after first call)
    out.minimap = function (v) {
        //get
        if (!arguments.length) return out.minimap_
        //set
        out.minimap_ = v
        //update
        ;(0,_minimaps__WEBPACK_IMPORTED_MODULE_9__.appendMinimap)(out)
        return out
    }

    //labels override (update after first call)
    out.labels = function (v) {
        //get
        if (!arguments.length) return out.labels_
        //set
        out.labels_ = v
        //update
        ;(0,_labels__WEBPACK_IMPORTED_MODULE_3__.updateLabels)(out)
        return out
    }

    // initiate Geometries class
    out.Geometries = (0,_geometries__WEBPACK_IMPORTED_MODULE_5__.Geometries)(out, withCenterPoints)

    /**
     * Requests geographic data and then builds the map template
     */
    out.updateGeoMapTemplate = function (callback) {
        // Erase previous data
        out.Geometries.defaultGeoData = null
        out.Geometries.allNUTSGeoData = null
        out.Geometries.centroidsData = null

        if (out.geometries_) {
            out.Geometries.setUserGeometries(out.geometries_)
            // use custom user-defined geometries
            out.buildMapTemplate()

            // Execute callback if defined
            if (callback) callback()
        } else {
            // use default
            out.Geometries.getDefaultGeoData(out.geo_, out.filterGeometriesFunction_, out.nutsLevel_).then(() => {
                out.buildMapTemplate()

                // Execute callback if defined
                if (callback) callback()
            })
        }

        // Use executeForAllInsets for recursive inset updates
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, (inset) => {
            inset.updateGeoMapTemplate(callback)
        })

        return out
    }

    /**
     * Build a map object, including container, frame, map svg, insets and d3 zoom
     */
    out.buildMapTemplateBase = function () {
        //get svg element. Create it if it does not exists
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('#' + out.svgId())
        if (svg.size() == 0) {
            svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('body').append('svg').attr('id', out.svgId())
        }
        svg.attr('class', 'em-map')
        out.svg_ = svg

        //set container for cases where container contains various maps
        if (!out.containerId_) out.containerId_ = out.svgId_
        //tooltip needs to know container to prevent overflow
        if (!out.tooltip_.containerId) {
            out.tooltip_.containerId = out.containerId_
        }

        //clear SVG (to avoid building multiple svgs on top of each other during multiple build() calls)
        (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#' + out.svgId() + ' > *').remove()

        //set SVG dimensions
        if (out.geo_.toUpperCase() == 'WORLD') {
            //if no height was specified, use 45% of the width.
            if (!out.height()) out.height(0.55 * out.width())
            svg.attr('width', out.width()).attr('height', out.height())

            //WORLD geo only accepts proj 54030 (robinson) at the moment
            out.proj_ = 54030
        }
        //if no height was specified, use 85% of the width.
        if (!out.height()) out.height(0.85 * out.width())
        svg.attr('width', out.width()).attr('height', out.height())

        // each map template needs a clipPath to avoid overflow. See GISCO-2707
        svg.append('defs')
            .attr('class', 'em-defs')
            .append('clipPath')
            .attr('id', out.svgId_ + '-clip-path')
            .append('path')
            .attr('d', (0,_utils__WEBPACK_IMPORTED_MODULE_1__.convertRectanglesToPaths)(0, 0, out.width_, out.height_))

        if (out.drawCoastalMargin_) {
            //define filter for coastal margin
            svg.append('filter')
                .attr('id', 'em-coastal-blur')
                .attr('x', '-200%')
                .attr('y', '-200%')
                .attr('width', '400%')
                .attr('height', '400%')
                .append('feGaussianBlur')
                .attr('in', 'SourceGraphic')
                .attr('stdDeviation', out.coastalMarginStdDev_)
        }

        //create drawing group, as first child
        const dg = svg
            .insert('g', ':first-child')
            .attr('id', 'em-drawing-' + out.svgId_)
            .attr('class', 'em-drawing-group')
            .attr('clip-path', 'url(#' + out.svgId_ + '-clip-path' + ')')

        //create main zoom group
        const zg = dg
            .append('g')
            .attr('id', 'em-zoom-group-' + out.svgId_)
            .attr('class', 'em-zoom-group') //out.geo changed to out.svgId in order to be unique

        // build insets
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.removeInsets)(out) //remove existing
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.buildInsets)(out, withCenterPoints) //build new

        //draw frame
        dg.append('rect')
            .attr('id', 'em-frame-' + out.geo_)
            .attr('class', 'em-frame')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', out.width_)
            .attr('height', out.height_)

        if (out.stamp_) {
            (0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        }

        return out
    }

    /**
     * Buid an empty map template, based on the geometries only.
     */
    out.buildMapTemplate = function () {
        //prepare drawing group
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //remove all children
        zoomGroup.selectAll('*').remove()

        // separate logic for cartograms
        if (out.gridCartogram_ == true) {
            (0,_cartograms__WEBPACK_IMPORTED_MODULE_8__.buildGridCartogramBase)(out)
            out.footnote_ = false //dont need copyright
        } else {
            // default geographic logic

            // position
            if (!out.position_.x || !out.position_.y) {
                defineDefaultPosition()
            }
            out.position_.z = out.position_.z || getDefaultZ()

            // d3 projection/path functions
            defineProjection()
            definePathFunction()

            // d3 zoom
            if (out.zoomExtent()) {
                defineMapZoom()
            }

            if (out.backgroundMap_) {
                drawBackgroundMap(out)
            }
        }

        //prepare group for proportional symbols, with centroids
        if (withCenterPoints) {
            addCentroidsToMap(out)
        }

        // add geographical labels to map
        if (out.labels_) {
            (0,_labels__WEBPACK_IMPORTED_MODULE_3__.addLabelsToMap)(out, zoomGroup)
        }

        //annotations
        if (out.annotations_) {
            (0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
            out.annotationsAdded = true
        }

        //title
        if (out.title()) {
            //define default position
            let cssClass = out.isInset ? 'em-inset-title' : 'em-title'
            if (!out.titlePosition()) out.titlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssClass) + (out.isInset ? 0 : 10)])
            //draw title
            out.svg()
                .append('text')
                .attr('id', 'title' + out.geo_)
                .attr('class', cssClass)
                .attr('x', out.titlePosition()[0])
                .attr('y', out.titlePosition()[1])
                .html(out.title())
        }

        //subtitle
        if (out.subtitle()) {
            let cssSubtitleClass = out.isInset ? 'em-inset-subtitle' : 'em-subtitle'
            let cssTitleClass = out.isInset ? 'em-inset-title' : 'em-title'
            //define default position
            if (!out.subtitlePosition()) out.subtitlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssTitleClass) + (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssSubtitleClass) + 15])
            //draw subtitle
            out.svg()
                .append('text')
                .attr('id', 'subtitle' + out.geo_)
                .attr('class', cssSubtitleClass)
                .attr('x', out.subtitlePosition()[0])
                .attr('y', out.subtitlePosition()[1])
                .html(out.subtitle())
        }

        //bottom text
        if (out.footnote_) {
            addFootnote()
        }

        //source dataset URL
        if (out.showSourceLink_) {
            let stat
            if (withCenterPoints) {
                stat = out.stat('size')
            } else {
                stat = out.stat()
            }
            if (stat) {
                if (stat.eurostatDatasetCode) {
                    //dataset link
                    let code = stat.eurostatDatasetCode
                    let url = `https://ec.europa.eu/eurostat/databrowser/view/${code}/default/table?lang=en`
                    let link = out
                        .svg()
                        .append('a')
                        .attr('class', 'em-source-dataset-link')
                        .attr('href', url)
                        .attr('target', '_blank')
                        .append('text')
                        .attr('class', 'em-source-dataset-link-text')
                        .attr('x', out.width_)
                        .attr('y', out.height_)
                        .text('EUROSTAT')
                        .attr('text-anchor', 'end')

                    //pretext "Source:"
                    let linkW = link.node().getComputedTextLength()
                    out.svg()
                        .append('text')
                        .attr('class', 'em-source-pretext')
                        .attr('x', out.width_ - linkW - 2)
                        .attr('y', out.height_)
                        .text('Source:')
                        .attr('text-anchor', 'end')
                }
            }
        }

        // scalebar
        if (out.showScalebar_) {
            if (out.scalebarPosition_.length !== 2) {
                out.scalebarPosition_[0] = 15
                out.scalebarPosition_[1] = out.height_ - 50
            }
            addScalebarToMap()
        }

        //minimap
        if (out.minimap_) {
            (0,_minimaps__WEBPACK_IMPORTED_MODULE_9__.appendMinimap)(out)
        }

        return out
    }

    const drawBackgroundMap = function (out) {
        //draw background map
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw sea
        zoomGroup
            .append('rect')
            .attr('id', 'sea')
            .attr('class', 'em-sea')
            .attr('x', -5 * out.width_)
            .attr('y', -5 * out.height_)
            .attr('width', 11 * out.width_)
            .attr('height', 11 * out.height_)

        //sphere for world map
        if (out.geo_ == 'WORLD') {
            zoomGroup.append('path').datum({ type: 'Sphere' }).attr('id', 'sphere').attr('d', out._pathFunction).attr('class', 'em-graticule')
        }

        // coastal margin
        if (out.drawCoastalMargin_) {
            addCoastalMarginToMap()
        }

        // draw polygons and borders
        if (out.geometries_) {
            out.Geometries.addUserGeometriesToMap(out.geometries_, zoomGroup, out._pathFunction)
        } else {
            out.Geometries.addDefaultGeometriesToMap(
                zoomGroup,
                out.drawGraticule_,
                out._pathFunction,
                out.nutsLevel_,
                out.nutsYear_,
                out.geo_,
                out.proj_,
                out.scale_
            )
        }
    }

    const defineDefaultPosition = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            out.position_.x = out.position_.x || defaultPosition.geoCenter[0]
            out.position_.y = out.position_.y || defaultPosition.geoCenter[1]
        } else if (out.Geometries.defaultGeoData?.bbox) {
            // default to center of geoData bbox
            out.position_.x = out.position_.x || 0.5 * (out.Geometries.defaultGeoData.bbox[0] + out.Geometries.defaultGeoData.bbox[2])
            out.position_.y = out.position_.y || 0.5 * (out.Geometries.defaultGeoData.bbox[1] + out.Geometries.defaultGeoData.bbox[3])
        } else {
            //TODO: auto-define user=defined geometries geoCenter
            // out.position_.x = Geometries.userGeometries
            // out.position_.y = Geometries.userGeometries
        }

        // optional: set from URL
        setViewFromURL()
    }

    const getDefaultZ = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            return (defaultPosition.pixelSize * 800) / out.width_
        } else if (out.Geometries.defaultGeoData?.bbox) {
            return Math.min(
                (out.Geometries.defaultGeoData.bbox[2] - out.Geometries.defaultGeoData.bbox[0]) / out.width_,
                (out.Geometries.defaultGeoData.bbox[3] - out.Geometries.defaultGeoData.bbox[1]) / out.height_
            )
        } else {
            return 100
        }
    }

    const defineProjection = function () {
        // Define projection based on the geographical context

        if (out.geo_ === 'WORLD') {
            // Use Robinson projection for the world with optional custom projection function
            out._projection =
                out.projectionFunction_ ||
                (0,d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__["default"])()
                    .translate([out.width_ / 2, out.height_ / 2])
                    .scale((out.width_ - 20) / (2 * Math.PI))
        } else {
            // For non-WORLD geo, use custom or default identity projection with calculated bounding box
            out._projection =
                out.projectionFunction_ || (0,d3_geo__WEBPACK_IMPORTED_MODULE_14__["default"])().reflectY(true).fitSize([out.width_, out.height_], (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getBBOXAsGeoJSON)(getCurrentBbox()))
        }
    }

    // Helper function to calculate current view as bbox
    const getCurrentBbox = function () {
        const halfWidth = 0.5 * out.position_.z * out.width_
        const halfHeight = 0.5 * out.position_.z * out.height_
        const bbox = [out.position_.x - halfWidth, out.position_.y - halfHeight, out.position_.x + halfWidth, out.position_.y + halfHeight]
        return bbox
    }

    const definePathFunction = function () {
        out._pathFunction = (0,d3_geo__WEBPACK_IMPORTED_MODULE_15__["default"])().projection(out._projection)
    }

    const defineMapZoom = function () {
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('#' + out.svgId())
        let previousT = d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity
        const xoo = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()
            .scaleExtent(out.zoomExtent())
            .on('zoom', function (e) {
                const t = e.transform
                if (t.k !== previousT.k) {
                    zoomHandler(e, previousT)
                } else {
                    panHandler(e)
                }

                // apply default transform to map
                const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
                zoomGroup.attr('transform', t)
                previousT = t
            })

        svg.call(xoo)
    }

    // Zoom handler function
    const zoomHandler = function (event, previousT) {
        const transform = event.transform
        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k

        // Use the projection to get the projected center in EPSG:3035
        const [projectedX, projectedY] = out._projection.invert([centerX, centerY])

        // set new position
        out.position_.x = projectedX
        out.position_.y = projectedY
        out.position_.z = getMetresPerPixel(transform.k / previousT.k)

        // adjust stroke dynamically according to zoom
        scaleStrokeWidths(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.values) scaleLabelTexts(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.backgrounds) scaleLabelBackgrounds(transform)
    }

    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelBackgrounds = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('.em-label-background')
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
            // Get the original width, height, x, and y from data attributes or current attributes
            const originalWidth = parseFloat(element.attr('data-width')) || parseFloat(element.attr('width'))
            const originalHeight = parseFloat(element.attr('data-height')) || parseFloat(element.attr('height'))
            const originalX = parseFloat(element.attr('data-x')) || parseFloat(element.attr('x'))
            const originalY = parseFloat(element.attr('data-y')) || parseFloat(element.attr('y'))

            // Only process elements that have valid width, height, x, and y
            if (originalWidth > 0 && originalHeight > 0 && !isNaN(originalX) && !isNaN(originalY)) {
                // Store the original width, height, x, and y for the first time if not already stored
                if (!element.attr('data-width')) {
                    element.attr('data-width', originalWidth)
                    element.attr('data-height', originalHeight)
                    element.attr('data-x', originalX)
                    element.attr('data-y', originalY)
                }

                // Calculate the target width, height, x, and y based on zoom factor (inverse scaling)
                const targetWidth = originalWidth * (1 / zoomFactor) // Inverse scaling
                const targetHeight = originalHeight * (1 / zoomFactor) // Inverse scaling
                const targetX = originalX * (1 / zoomFactor) // Adjust x position
                const targetY = originalY * (1 / zoomFactor) // Adjust y position

                // Add the style change to a batch array
                updates.push({ element, targetWidth, targetHeight, targetX, targetY })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetWidth, targetHeight, targetX, targetY }) => {
            element.attr('width', targetWidth).attr('height', targetHeight).attr('x', targetX).attr('y', targetY)
        })
    }
    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelTexts = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const labels = zoomGroup.select('#em-labels')
        const elements = labels.selectAll('*') // Select all labels
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get font-size from inline or computed style
            const inlineFontSize = element.attr('font-size')
            const cssFontSize = computedStyle.fontSize
            const fontSize = inlineFontSize || cssFontSize

            // Only process elements that have a font size defined
            if (fontSize && parseFloat(fontSize) > 0) {
                const originalFontSize = parseFloat(element.attr('data-fs')) || parseFloat(inlineFontSize) || parseFloat(cssFontSize)

                // Store the original font size for the first time
                if (!element.attr('data-fs')) {
                    element.attr('data-fs', originalFontSize)
                }

                // Calculate the target font size based on zoom factor
                const targetFontSize = originalFontSize / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetFontSize })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetFontSize }) => {
            element.style.setProperty('font-size', `${targetFontSize}px`, 'important')
        })
    }

    /**
     * @description adjusts all stroke-widths dynamically according to zoom
     * @param {*} transform
     */
    const scaleStrokeWidths = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('*') // Select all elements in the zoom group
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get stroke-width from inline or computed style
            const inlineStrokeWidth = element.attr('stroke-width')
            const cssStrokeWidth = computedStyle.strokeWidth
            const strokeWidth = inlineStrokeWidth || cssStrokeWidth

            // Only process elements that have a stroke width defined
            if (strokeWidth && parseFloat(strokeWidth) > 0) {
                const originalStrokeWidth = parseFloat(element.attr('data-sw')) || parseFloat(inlineStrokeWidth) || parseFloat(cssStrokeWidth)

                // Store the original stroke width for the first time
                if (!element.attr('data-sw')) {
                    element.attr('data-sw', originalStrokeWidth)
                }

                // Calculate the target stroke width
                const targetStrokeWidth = originalStrokeWidth / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetStrokeWidth })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetStrokeWidth }) => {
            element.style.setProperty('stroke-width', `${targetStrokeWidth}px`, 'important')
        })
    }

    /**
     * @description get the current view's metres per pixel, based on a zoomFactor
     * @param {number} zoomFactor this zoom / previous zoom
     * @return {number}
     */
    const getMetresPerPixel = function (zoomFactor) {
        // Get current bounding box width in meters
        const bbox = getCurrentBbox()
        const bboxWidth = bbox[2] - bbox[0] // BBOX width in meters

        // Calculate meters per pixel
        const metersPerPixel = bboxWidth / (out.width_ * zoomFactor)

        return metersPerPixel
    }

    // Pan handler function
    const panHandler = function (event, previousT) {
        const transform = event.transform

        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k
        let [geoX, geoY] = out._projection.invert([centerX, centerY])

        // Clamp geoX and geoY to max bounds and adjust the event transform
        if (out.maxBounds_.xMin !== undefined && geoX < out.maxBounds_.xMin) {
            geoX = out.maxBounds_.xMin
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMin !== undefined && geoY < out.maxBounds_.yMin) {
            geoY = out.maxBounds_.yMin
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }
        if (out.maxBounds_.xMax !== undefined && geoX > out.maxBounds_.xMax) {
            geoX = out.maxBounds_.xMax
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMax !== undefined && geoY > out.maxBounds_.yMax) {
            geoY = out.maxBounds_.yMax
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }

        // set new position
        out.position_.x = geoX
        out.position_.y = geoY
    }

    /** Get x,y,z elements from URL and assign them to the view. */
    const setViewFromURL = function () {
        const x = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('x'),
            y = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('y'),
            z = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('z')
        if (x != null && x != undefined && !isNaN(+x)) out.position_.x = +x
        if (y != null && y != undefined && !isNaN(+y)) out.position_.y = +y
        if (z != null && z != undefined && !isNaN(+z)) out.position_.z = +z
    }

    const addFootnote = function () {
        out.svg()
            .append('text')
            .attr('id', 'em-footnote')
            .attr('class', 'em-footnote')
            .attr('x', 0)
            .attr('y', out.height_)
            .html(out.footnote_)
            .on('mouseover', function () {
                out._tooltip.mw___ = out._tooltip.style('max-width')
                out._tooltip.style('max-width', '400px')
                if (out.footnoteTooltipText_) out._tooltip.mouseover(out.footnoteTooltipText_)
            })
            .on('mousemove', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mouseout(e)
                out._tooltip.style('max-width', out._tooltip.mw___)
            })
    }

    const addCoastalMarginToMap = function () {
        const zg = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw coastal margin
        const cg = zg.append('g').attr('id', 'em-coast-margin').attr('class', 'em-coast-margin')

        //countries bn
        if (out.Geometries.geoJSONs.cntbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-cnt')
                .attr('class', 'em-coast-margin-cnt')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.cntbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //nuts bn
        if (out.Geometries.geoJSONs.nutsbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-nuts')
                .attr('class', 'em-coast-margin-nuts')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //world bn
        if (out.Geometries.geoJSONs.worldbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-world')
                .attr('class', 'em-coast-margin-world')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.worldbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.COAS_FLAG === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }
    }

    const addCentroidsToMap = function (map) {
        let centroidFeatures

        if (!map.Geometries.centroidsData) {
            // if centroids data is absent (e.g. for world maps) then calculate manually
            if (map.geo_ == 'WORLD') {
                centroidFeatures = []
                map.Geometries.geoJSONs.worldrg.forEach((feature) => {
                    let newFeature = { ...feature }
                    // exception for France (because guyane)
                    if (feature.properties.id == 'FR') {
                        newFeature.geometry = {
                            coordinates: [2.2, 46.2],
                            type: 'Point',
                        }
                    } else {
                        newFeature.geometry = {
                            coordinates: (0,d3_geo__WEBPACK_IMPORTED_MODULE_16__["default"])(feature),
                            type: 'Point',
                        }
                    }
                    centroidFeatures.push(newFeature)
                })
            }
        } else {
            if (map.nutsLevel_ == 'mixed') {
                centroidFeatures = [
                    ...map.Geometries.centroidsData[0].features,
                    ...map.Geometries.centroidsData[1].features,
                    ...map.Geometries.centroidsData[2].features,
                    ...map.Geometries.centroidsData[3].features,
                ]
            } else {
                centroidFeatures = map.Geometries.centroidsData.features
            }
        }

        if (map.processCentroids_) centroidFeatures = map.processCentroids_(centroidFeatures)

        // calculate screen coordinates and save centroids to map
        map.Geometries.centroidFeatures = centroidFeatures.map((d) => {
            let coords = map._projection(d.geometry.coordinates)
            d.properties.centroid = coords
            return d
        })

        // em-prop-symbols is the g element containing all proportional symbols for the map
        const zg = map.svg().select('#em-zoom-group-' + map.svgId_)
        const gcp = zg.append('g').attr('id', 'em-prop-symbols')

        // add centroid elements
        // then symbols are drawn/appended to these containers in the map-type js file
        const symbolContainers = gcp
            .selectAll('g')
            .data(map.Geometries.centroidFeatures)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                return 'translate(' + d.properties.centroid[0].toFixed(3) + ',' + d.properties.centroid[1].toFixed(3) + ')'
            })
            .attr('class', 'em-centroid') // OUR SYMBOL CONTAINER
            .attr('id', (d) => 'ps' + d.properties.id)
    }

    /**
     * @function addScalebarToMap
     * @description appends an SVG scalebar to the map. Uses pixelSize to calculate units in km
     */
    const addScalebarToMap = function () {
        // Julien's nice scalebars
        const marginLeft = 5
        const maxLengthPix = out.scalebarMaxWidth_
        const textOffsetX = out.scalebarTextOffset_[0]
        const textOffsetY = out.scalebarTextOffset_[1]
        const pixelSizeM = out.position_.z
        const maxLengthM = maxLengthPix * pixelSizeM
        const niceLengthM = niceScaleBarLength(maxLengthM)
        const niceLengthPixel = niceLengthM[0] / pixelSizeM
        const scaleBarStartDigit = niceLengthM[1]
        const subdivisionNbs = {
            1: 4,
            2: 2,
            5: 5,
        }

        const scalebarGroup = out
            .svg()
            .append('g')
            .attr('class', 'em-scalebar')
            .attr('transform', `translate(${out.scalebarPosition_[0]},${out.scalebarPosition_[1]})`)
            .attr('width', maxLengthPix + 20)
            .attr('height', out.scalebarHeight_)

        // top line full width
        // scalebarGroup
        //     .append('line')
        //     .attr('class', 'em-scalebar-line')
        //     .attr('x1', marginLeft)
        //     .attr('y1', 1)
        //     .attr('x2', niceLengthPixel + marginLeft)
        //     .attr('y2', 1)

        //bottom line full width
        // scalebarGroup
        //     .append('line')
        //     .attr('class', 'em-scalebar-line')
        //     .attr('x1', marginLeft)
        //     .attr('y1', out.scalebarSegmentHeight_)
        //     .attr('x2', niceLengthPixel + marginLeft)
        //     .attr('y2', out.scalebarSegmentHeight_)

        //first tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', marginLeft)
            .attr('y1', 1)
            .attr('x2', marginLeft)
            .attr('y2', out.scalebarTickHeight_)

        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text('0')

        //middle ticks
        const subdivisionNb = subdivisionNbs[scaleBarStartDigit]
        const divisionWidth = niceLengthPixel / subdivisionNb
        const divisionMinWidth = 15
        const midlineY = out.scalebarSegmentHeight_ / 2 + 1
        if (divisionWidth >= divisionMinWidth) {
            for (let i = 1; i < subdivisionNb; i++) {
                scalebarGroup
                    .append('line')
                    .attr('class', 'em-scalebar-line')
                    .attr('x1', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y1', 1)
                    .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y2', out.scalebarTickHeight_)
                scalebarGroup
                    .append('text')
                    .attr('class', 'em-scalebar-label')
                    .attr('x', marginLeft + textOffsetX + i * divisionWidth)
                    .attr('y', out.scalebarTickHeight_ + textOffsetY)
                    .text(getScalebarLabel((niceLengthM[0] / subdivisionNb) * i))

                if (i == 1) {
                    scalebarGroup
                        .append('line')
                        .attr('class', 'em-scalebar-line em-scalebar-midline')
                        .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                        .attr('y1', midlineY)
                        .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                        .attr('y2', midlineY)
                } else {
                    let x1 = marginLeft + out.scalebarStrokeWidth_ / 2 + (i - 1) * divisionWidth
                    if (x1 > 0) {
                        scalebarGroup
                            .append('line')
                            .attr('class', 'em-scalebar-line em-scalebar-midline')
                            .attr('x1', x1)
                            .attr('y1', midlineY)
                            .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                            .attr('y2', midlineY)
                    }
                }
            }

            // Draw final midline segment (last segment)
            if (divisionWidth >= divisionMinWidth) {
                scalebarGroup
                    .append('line')
                    .attr('class', 'em-scalebar-line em-scalebar-midline')
                    .attr('x1', marginLeft + (subdivisionNb - 1) * divisionWidth)
                    .attr('y1', midlineY)
                    .attr('x2', marginLeft + subdivisionNb * divisionWidth)
                    .attr('y2', midlineY)
            }
        } else {
            // single full-length horizontal mid-line
            scalebarGroup
                .append('line')
                .attr('class', 'em-scalebar-line em-scalebar-midline')
                .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                .attr('y1', midlineY)
                .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + divisionWidth * subdivisionNb)
                .attr('y2', midlineY)
        }

        //last tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', niceLengthPixel + marginLeft)
            .attr('y1', 1)
            .attr('x2', niceLengthPixel + marginLeft)
            .attr('y2', out.scalebarTickHeight_)
        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', niceLengthPixel + marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text(getScalebarLabel(niceLengthM[0]) + out.scalebarUnits_)
    }

    const niceScaleBarLength = function (scaleBarLength) {
        //compute the 'nice' power of ten
        const pow10 = Math.pow(10, Math.floor(Math.log(scaleBarLength) / Math.log(10)))

        //check if 5 times this value fits
        if (5 * pow10 <= scaleBarLength) return [5 * pow10, 5]

        //check if 2 times this value fits
        if (2 * pow10 <= scaleBarLength) return [2 * pow10, 2]

        //returns the power of ten
        return [pow10, 1]
    }

    const getScalebarLabel = function (valueM) {
        if (valueM < 0.01) return valueM * 1000 + 'mm'
        if (valueM < 1) return valueM * 100 + 'cm'
        if (valueM < 1000) return valueM * 1 + 'm'
        return valueM / 1000
    }

    return out
}

/** Default geocenter positions and pixelSize (for default width = 800px) for territories and projections. */
const _defaultPosition = {
    EUR_3035: { geoCenter: [4790000, 3420000], pixelSize: 6400 },
    IC_32628: { geoCenter: [443468, 3145647], pixelSize: 1000 },
    GP_32620: { geoCenter: [669498, 1784552], pixelSize: 130 },
    MQ_32620: { geoCenter: [716521, 1621322], pixelSize: 130 },
    GF_32622: { geoCenter: [266852, 444074], pixelSize: 500 },
    RE_32740: { geoCenter: [348011, 7661627], pixelSize: 130 },
    YT_32738: { geoCenter: [516549, 8583920], pixelSize: 70 },
    MT_3035: { geoCenter: [4719755, 1441701], pixelSize: 70 },
    PT20_32626: { geoCenter: [397418, 4271471], pixelSize: 1500 },
    PT30_32628: { geoCenter: [333586, 3622706], pixelSize: 150 },
    LI_3035: { geoCenter: [4287060, 2672000], pixelSize: 40 },
    IS_3035: { geoCenter: [3011804, 4960000], pixelSize: 700 },
    SJ_SV_3035: { geoCenter: [4570000, 6160156], pixelSize: 800 },
    SJ_JM_3035: { geoCenter: [3647762, 5408300], pixelSize: 100 },
    CARIB_32620: { geoCenter: [636345, 1669439], pixelSize: 500 },
    WORLD_54030: { geoCenter: [14, 17], pixelSize: 9000 },
}


/***/ }),

/***/ "./src/core/minimaps.js":
/*!******************************!*\
  !*** ./src/core/minimaps.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendMinimap: () => (/* binding */ appendMinimap)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/orthographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/src/index.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");





const appendMinimap = (map) => {
    if (!map.svg_) return

    const minimapConfig = map.minimap_ || {}
    const countryId = minimapConfig.countryId || 'DE' // default to China
    const x = minimapConfig.x || 80 // default x position
    const y = minimapConfig.y || 80 // default y position
    const z = minimapConfig.z || 160 // default zoom level
    const color = minimapConfig.color || '#3792B6' // default color

    const drawMinimap = (geometries) => {
        const container = map.svg_.append('g').attr('id', 'em-minimap').attr('transform', `translate(${x},${y})`) // adjust as needed
        // diameter
        const size = 160
        // Draw inner circle
        container
            .append('circle')
            .attr('r', size / 2)
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('fill', 'white')
            .attr('stroke', color)
            .attr('stroke-width', 3)

        const projection = (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])().scale(z).translate([0, 0])

        const path = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__["default"])().projection(projection)

        const target = geometries.find((d) => d.properties.id === countryId)
        if (!target) return console.warn(`Country ID ${countryId} not found in geometries`)

        // Center the globe on the selected country
        const [[x0, y0], [x1, y1]] = path.bounds(target)
        const centroid = [(x0 + x1) / 2, (y0 + y1) / 2]
        const [lon, lat] = projection.invert(centroid)
        projection.rotate([-lon, -lat])

        // Define circular clip
        container
            .append('defs')
            .append('clipPath')
            .attr('id', 'minimap-clip')
            .append('circle')
            .attr('r', size / 2)
            .attr('cx', 0)
            .attr('cy', 0)

        const globe = container.append('g').attr('clip-path', 'url(#minimap-clip)')

        // Draw all countries
        globe.selectAll('path.country').data(geometries).enter().append('path').attr('d', path).attr('fill', '#e0e0e0')
        // .attr('stroke', '#999')
        // .attr('stroke-width', 0.3)

        // Highlight selected country
        globe.append('path').datum(target).attr('d', path).attr('fill', color).attr('stroke', color).attr('stroke-width', 0.5)

        // Draw outer circle
        container
            .append('circle')
            .attr('r', size / 2)
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('fill', 'none')
            .attr('stroke', color)
            .attr('stroke-width', 3)
    }

    if (map.Geometries.geoJSONs.worldrg) {
        drawMinimap(map.Geometries.geoJSONs.worldrg)
    } else {
        (0,d3_fetch__WEBPACK_IMPORTED_MODULE_3__["default"])('https://raw.githubusercontent.com/eurostat/eurostat-map/master/src/assets/topojson/WORLD_4326.json')
            .then((topoData) => {
                const features = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(topoData, topoData.objects.CNTR_RG_20M_2020_4326).features
                drawMinimap(features)
            })
            .catch((err) => console.error('Failed to load WORLD_4326.json', err))
    }
}


/***/ }),

/***/ "./src/core/pattern-fill.js":
/*!**********************************!*\
  !*** ./src/core/pattern-fill.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyPatternFill: () => (/* binding */ applyPatternFill)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");



function applyPatternFill(map, configs = []) {
    if (!Array.isArray(configs)) {
        console.warn('patternFill expects an array of configs')
        return
    }

    let defs = map.svg().select('defs')
    if (defs.empty()) {
        defs = map.svg().append('defs')
    }

    // Prepare: map each regionId to an array of patternIds
    const regionToPatternIds = {}

    configs.forEach((config) => {
        const { pattern = 'hatching', regionIds = [], color = '#000', strokeWidth = 1, customPattern } = config

        let patternId

        if (customPattern) {
            const idMatch = customPattern.match(/id=['"]([^'"]+)['"]/)
            if (idMatch) {
                patternId = idMatch[1]

                if (map.svg().select(`#${patternId}`).empty()) {
                    defs.node().insertAdjacentHTML('beforeend', customPattern)
                }
            } else {
                console.warn('customPattern must include an id attribute.')
                return
            }
        } else {
            const colorKey = color.replace('#', '').toLowerCase()
            patternId = `${pattern}-${colorKey}-sw${strokeWidth}`
            definePattern(map, patternId, pattern, color, strokeWidth)
        }

        config.patternId = patternId

        regionIds.forEach((regionId) => {
            if (!regionToPatternIds[regionId]) {
                regionToPatternIds[regionId] = []
            }
            regionToPatternIds[regionId].push(patternId)
        })
    })

    // Apply all patterns for each region (stacking them)
    map.svg()
        .selectAll((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getRegionsSelector)(map))
        .each(function (d) {
            const id = d?.properties?.id
            const patternIds = regionToPatternIds[id]

            if (patternIds && patternIds.length) {
                const original = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this)

                patternIds.forEach((patternId) => {
                    const clone = original.node().cloneNode(true)

                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(clone)
                        .attr('fill', `url(#${patternId})`)
                        .attr('pointer-events', 'none')
                        .attr('class', (original.attr('class') || '') + ' pattern-fill-overlay')

                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parentNode).append(() => clone)
                })
            }
        })
}

function definePattern(map, patternId, patternName, color, strokeWidth) {
    const defs = map.svg().select('defs')

    if (
        map
            .svg()
            .select(`#${CSS.escape(patternId)}`)
            .empty()
    ) {
        const pattern = defs.append('pattern').attr('id', patternId).attr('patternUnits', 'userSpaceOnUse').attr('width', 8).attr('height', 8)

        if (patternName === 'hatching') {
            pattern.append('path').attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2').attr('stroke', color).attr('stroke-width', strokeWidth)
        } else if (patternName === 'crosshatch') {
            pattern.append('path').attr('d', 'M0,0 l8,8 M8,0 l-8,8').attr('stroke', color).attr('stroke-width', strokeWidth)
        } else if (patternName === 'dots') {
            pattern.append('circle').attr('cx', 4).attr('cy', 4).attr('r', strokeWidth).attr('fill', color)
        } else {
            console.warn(`Unknown pattern "${patternName}", defaulting to hatching.`)
            pattern.append('path').attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2').attr('stroke', color).attr('stroke-width', strokeWidth)
        }
    }
}


/***/ }),

/***/ "./src/core/stamps.js":
/*!****************************!*\
  !*** ./src/core/stamps.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendStamp: () => (/* binding */ appendStamp)
/* harmony export */ });
const appendStamp = (stampConfig, map) => {
    if (map.svg_) {
        const existing = map.svg_.select('#em-stamp')
        existing.remove()

        if (stampConfig) {
            const container = map.svg_.append('g').attr('id', 'em-stamp')

            // Set defaults
            if (!stampConfig.size) stampConfig.size = 60
            if (!stampConfig.x) stampConfig.x = 230
            if (!stampConfig.y) stampConfig.y = 100
            if (!stampConfig.textColor) stampConfig.textColor = '#000'
            if (!stampConfig.stampColor) stampConfig.stampColor = '#000'
            if (!stampConfig.strokeWidth) stampConfig.strokeWidth = 1
            if (!stampConfig.lineHeight) stampConfig.lineHeight = 15

            // Draw the circle
            container
                .append('circle')
                .attr('r', stampConfig.size)
                .attr('cx', stampConfig.x)
                .attr('cy', stampConfig.y)
                .attr('id', 'em-stamp-circle')
                .attr('fill', 'none')
                .attr('stroke', stampConfig.stampColor)
                .attr('stroke-width', stampConfig.strokeWidth)

            // Handle text
            const text = stampConfig.text
            const targetWidth = Math.sqrt(measureWidth(text.trim()) * stampConfig.lineHeight)
            const lines = getLines(getWords(text.trim()), targetWidth)
            const textRadius = getTextRadius(lines, stampConfig.lineHeight)

            // Append inside circle
            container
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('fill', stampConfig.textColor)
                .attr('id', 'em-stamp-text')
                .attr('transform', `translate(${stampConfig.x},${stampConfig.y}) scale(${stampConfig.size / textRadius})`)
                .selectAll('tspan')
                .data(lines)
                .enter()
                .append('tspan')
                .attr('x', 0)
                .attr('y', (d, i) => (i - lines.length / 2 + 0.8) * stampConfig.lineHeight)
                .text((d) => d.text.replaceAll('~', ' ').replaceAll('¶', '')) // Removes ¶ (line breaker) and ~ (non breaking space)
        }
    }
}

// Splitting by both spaces and pilcrows
const getWords = (text) => {
    return text
        .split(/(?<=¶)|\s+/g)
        .map((word) => word.trim())
        .filter((word) => word.length > 0)
}

// Computes text width
const measureWidth = (text) => {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text')

    textElement.textContent = text
    svg.appendChild(textElement)
    document.body.appendChild(svg)

    const width = textElement.getComputedTextLength()
    document.body.removeChild(svg)

    return width + 10
}

// Compute text radius
const getTextRadius = (lines, lineHeight) => {
    let radius = 0
    for (let i = 0, n = lines.length; i < n; ++i) {
        const dy = (Math.abs(i - n / 2 + 0.5) + 0.5) * lineHeight
        const dx = lines[i].width / 2
        radius = Math.max(radius, Math.sqrt(dx ** 2 + dy ** 2))
    }
    return radius
}

// Handles forced line breaks
const getLines = (words, targetWidth) => {
    let lines = []
    let line = { width: 0, text: '' }

    for (let i = 0, n = words.length; i < n; ++i) {
        if (words[i] === '¶') {
            // Push current line (if it has text)
            if (line.text) lines.push(line)
            // Start a new empty line
            line = { width: 0, text: '' }
            continue
        }

        let lineText1 = (line.text ? line.text + ' ' : '') + words[i]
        let lineWidth1 = measureWidth(lineText1)

        if ((line.width + lineWidth1) / 2 < targetWidth) {
            line.width = lineWidth1
            line.text = lineText1
        } else {
            lines.push(line)
            line = { width: measureWidth(words[i]), text: words[i] }
        }
    }

    if (line.text) lines.push(line) // Push last line if it exists

    return lines
}


/***/ }),

/***/ "./src/core/stat-data.js":
/*!*******************************!*\
  !*** ./src/core/stat-data.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   statData: () => (/* binding */ statData)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonstat-toolkit */ "./node_modules/jsonstat-toolkit/import.mjs");





/**
 * A statistical dataset, to be used for a statistical map.
 *
 * @param {*} config
 */
const statData = function (config) {
    //build stat data object
    const out = {}

    out.__data = undefined //for debugging

    //out.maxNumberOfDecimalsInDataset = undefined

    /**
     * The statistical values, indexed by NUTS id.
     * Each stat value is an object {value,status}.
     */
    out._data_ = undefined

    /**
     * Return the stat value {value,status} from a nuts id.
     * If no argument is specified, returns the entire index.
     * @param {*} nutsId
     */
    out.get = (nutsId) => {
        if (!nutsId) {
            return out._data_
        } else {
            if (out._data_) {
                return out._data_[nutsId]
            } else {
                return undefined
            }
        }
    }

    /**
     * Return the stat value from a nuts id.
     * @param {*} nutsId
     */
    out.getValue = (nutsId) => {
        const s = out.get(nutsId)
        return s ? s.value : undefined
    }

    /**
     * Set a stat value from a nuts id.
     *
     * @param {String} nutsId
     * @param {Object || String || Number} stat The new statistical data. The format can be either {value:34.324,status:"e"} or a the value only.
     */
    out.set = (nutsId, stat) => {
        out._data_ = out._data_ || {}
        const s = out._data_[nutsId]

        if (s) {
            if (stat.value) {
                s.value = stat.value
                s.status = stat.status
            } else {
                // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
                s.value = stat
                //s.value = isNaN(+stat) ? stat : +stat
            }
        } else {
            // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
            out._data_[nutsId] = stat.value ? stat : { value: stat }
            //out._data_[nutsId] = stat.value ? stat : { value: isNaN(+stat) ? stat : +stat}
        }
        return out
    }

    /**
     * Set statistical data, already indexed by nutsId.
     *
     * @param {Object} data Something like: { "PT":0.2, "LU":0.6, ...}, or with status: { "PT": {value:0.2, status:"e"}, "LU":0.6, ...}
     */
    out.setData = (data) => {
        out.__data = data // for debugging
        out._data_ = {} // overwrite existing data
        Object.keys(data).forEach((nutsId) => out.set(nutsId, data[nutsId]))
        return out
    }

    //eg for sparklines
    out.setManualMultiDate = function (dataObject) {
        out._data_ = out._data_ || {}

        for (const regionId in dataObject) {
            const dateValueMap = dataObject[regionId]
            out._data_[regionId] = {}

            for (const date in dateValueMap) {
                const value = dateValueMap[date]
                out._data_[regionId][date] = { value: value }
            }
        }

        return out
    }

    /** Return all stat values as an array. This can be used to classify the values. */
    out.getArray = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || s)
        }
    }

    /** Return stat unique values. This can be used for categorical maps. */
    out.getUniqueValues = function () {
        return Object.values(out._data_)
            .map((s) => s.value)
            .filter((item, i, ar) => ar.indexOf(item) === i)
    }

    /** Get min value. */
    out.getMin = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.min(acc, v))
        }
    }
    /** Get max value. */
    out.getMax = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.max(acc, v))
        }
    }

    /** Check if the stat data is ready. */
    out.isReady = function () {
        return out._data_ != undefined
    }

    /** Some metadata */
    out.metadata = undefined

    //a text for the statitics unit of measure, to be shown in the tooltip
    out.unitText_ = undefined

    /**
     * Retrieve stat data from remote data sources.
     *
     * @param {*} nutsLevel
     * @param {*} callback
     */
    out.retrieveFromRemote = function (nutsLevel, lang, callback) {
        if (out.eurostatDatasetCode_) updateEurobase(nutsLevel, lang, callback)
        else if (out.csvURL_) updateCSV(callback)
        return out
    }

    //TODO decompose into Eurobase/jsonstat and CSV types ?

    /**
     * Eurobase/jsonstat data source
     * See https://ec.europa.eu/eurostat/web/json-and-unicode-web-services/getting-started/rest-request
     */

    /** The Eurobase dataset code */
    out.eurostatDatasetCode_ = undefined
    /** The Eurobase code */
    out.filters_ = { lastTimePeriod: 1 }
    /** The precision (number of decimal places) */
    out.precision_ = 2

    /**
     * Return promise for Eurobase/jsonstat data.
     */
    const getEurobasePromise = function (nutsLevel, lang) {
        //set precision //DEPRECATED 16/11/2021 https://ec.europa.eu/eurostat/online-help/public/en/NAVIGATION_WDDSTranslator_migration_en/#DECOMMISSION
        //out.filters_["precision"] = out.precision_;
        //select only required geo groups, depending on the specified nuts level
        if (!out.filters_.geo) {
            out.filters_['geoLevel'] = nutsLevel + '' === '0' ? 'country' : 'nuts' + nutsLevel
        }

        //force filtering of euro-geo-aggregates
        //out.filters_["filterNonGeo"] = 1; //DEPRECATED 16/11/2021

        //retrieve stat data from Eurostat API
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getEstatDataURL)(out.eurostatDatasetCode_, out.filters_, lang))
    }

    //for eurobase statistical data to retrieve from Eurostat API
    const updateEurobase = function (nutsLevel, lang, callback) {
        //erase previous data
        out._data_ = null

        getEurobasePromise(nutsLevel, lang).then(function (data___) {
            //decode stat data
            const jsd = (0,jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__["default"])(data___)

            //store jsonstat metadata
            out.metadata = {
                label: jsd.label,
                href: jsd.href,
                source: jsd.source,
                updated: jsd.updated,
                extension: jsd.extension,
            }
            out.metadata.time = jsd.Dimension('time').id[0]

            //index
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.jsonstatToIndex)(jsd)
            //TODO: use maybe https://github.com/badosa/JSON-stat/blob/master/utils/fromtable.md to build directly an index ?

            if (callback) callback()
        })
    }

    /**
     * Return the time stamp of the jsonstat dataset.
     */
    out.getTime = function () {
        const t = out.filters_.time
        if (t) return t
        if (!out._data_) return
        return out.metadata.time
    }

    /**
     * CSV data source
     */

    /** The CSV file URL */
    out.csvURL_ = undefined
    /** The CSV column with the NUTS ids */
    out.geoCol_ = 'geo'
    /** The CSV column with the statistical values */
    out.valueCol_ = 'value'

    /**
     * Return promise for CSV data.
     */
    const getCSVPromise = function (nutsLevel) {
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_3__.csv)(out.csvURL_)
    }

    //for statistical data to retrieve from CSV file
    const updateCSV = function (callback) {
        //erase previous data
        out._data_ = null

        //retrieve csv data
        getCSVPromise().then(function (data___) {
            //decode stat data
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.csvToIndex)(data___, out.geoCol_, out.valueCol_)

            //store some metadata
            out.metadata = { href: out.csvURL_ }

            if (callback) callback()
        })
    }

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['unitText_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config) for (let key in config) out[key + '_'] = config[key]

    return out
}


/***/ }),

/***/ "./src/core/stat-map.js":
/*!******************************!*\
  !*** ./src/core/stat-map.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getURLParameters: () => (/* binding */ getURLParameters),
/* harmony export */   statMap: () => (/* binding */ statMap)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");
/* harmony import */ var _stat_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat-data */ "./src/core/stat-data.js");
/* harmony import */ var _legend_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../legend/legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tooltip/tooltip */ "./src/tooltip/tooltip.js");







/**
 * An abstract statistical map: A map template with statistical data, without any particular styling rule.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const statMap = function (config, withCenterPoints, mapType) {
    //build stat map from map template
    const out = _map_template__WEBPACK_IMPORTED_MODULE_1__.mapTemplate(config, withCenterPoints, mapType)

    //statistical data

    //the statistical data configuration.
    //A map can have several stat datasets. This is a dictionary of all stat configuration
    out.stat_ = { default: undefined }
    out.stat = function (k, v) {
        //no argument: getter - return the default stat
        if (!arguments.length) return out.stat_['default']
        //two arguments: setter - set the config k with value v
        if (arguments.length == 2) {
            out.stat_[k] = v
            return out
        }
        //one string argument: getter - return the config k
        if (typeof k === 'string' || k instanceof String) return out.stat_[k]
        //one non-string argument: setter - set the entire dictionnary
        out.stat_ = k.default ? k : { default: k }
        return out
    }

    //the statistical data, retrieved from the config information. As a dictionary.
    out.statData_ = {
        default: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        color: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        size: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v1: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v2: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //bivariate
        v3: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //trivariate
    }
    out.statData = function (k, v) {
        if (!arguments.length) return out.statData_['default']

        // lazy create if not exist
        if (arguments.length === 1) {
            if (!out.statData_[k]) out.statData_[k] = _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData()
            return out.statData_[k]
        }

        // setter
        out.statData_[k] = v
        return out
    }

    //test for no data case
    out.noDataText_ = 'No data available'
    //langage (currently used only for eurostat data API)
    out.language_ = 'en'
    //transition time for rendering
    out.transitionDuration_ = 500
    //specific tooltip text function
    out.tooltip_.textFunction = undefined
    //for maps using special fill patterns, this is the function to define them in the SVG image - See functions: getFillPatternLegend and getFillPatternDefinitionFun
    out.filtersDefinitionFunction_ = undefined
    //a callback function to execute after the map build is complete.
    out.callback_ = undefined

    //legend configuration
    out.legend_ = undefined
    //legend object
    out.legendObj_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['legend_', 'legendObj_', 'noDataText_', 'language_', 'transitionDuration_', 'tooltipText_', 'filtersDefinitionFunction_', 'callback_'].forEach(
        function (att) {
            out[att.substring(0, att.length - 1)] = function (v) {
                if (!arguments.length) return out[att]
                out[att] = v
                return out
            }
        }
    )

    //override attribute values with config values
    if (config) for (let key in config) if (out[key] && config[key] != undefined) out[key](config[key])

    // override legend for updating after build
    out.legend = function (v) {
        if (!arguments.length) return out.legend_

        // clear existing legend
        if (v == false) {
            const legend = out.legendObj()
            if (legend) {
                const legendSvg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#' + legend.svgId)
                if (legendSvg.size() > 0) {
                    legendSvg.selectAll('*').remove()
                }
            }
            out.legend_ = v
            return out
        }
        //set new legend config
        out.legend_ = v
        //update if existing legend
        if (out.legendObj_) out.updateLegend()
        return out
    }

    out.updateLegend = function (v) {
        if (out.legendObj_) out.legendObj().update()
        return out
    }

    /**
     * Build the map.
     * This method should be called once, preferably after the map attributes have been set to some initial values.
     */
    out.build = function () {
        if (out.projectionFunction_) out.proj('4326') //when using custom d3 projection function always request NUTS2JSON in WGS84

        //build map template base
        out.buildMapTemplateBase()

        //add additional filters for fill patterns for example
        if (out.filtersDefinitionFunction_) {
            out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        }

        //legend element
        if (out.legend()) {
            out.buildLegend()
        }

        //define tooltip
        //prepare map tooltip
        if (out.tooltip_) {
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip(out.tooltip_)
        } else {
            //no config specified, use default
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip()
        }

        //launch geo data retrieval
        out.updateGeoData()

        //launch stat data retrieval
        out.updateStatData()

        return out
    }

    out.buildLegend = function () {
        //create legend object
        out.legendObj(out.getLegendConstructor()(out, out.legend()))
        const legend = out.legendObj()

        //get legend svg. If it does not exist, create it embeded within the map
        let legendSvg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#' + legend.svgId)
        if (legendSvg.size() == 0) {
            //get legend position
            const x = legend.x == undefined ? out.width() - 100 - legend.boxPadding : legend.x
            const y = legend.y == undefined ? legend.boxPadding : legend.y

            //build legend SVG in a new group
            out.svg()
                .append('g')
                .attr('id', legend.svgId)
                .attr('class', 'em-legend')
                .attr('transform', 'translate(' + x + ',' + y + ')')
        }

        legend.build()
    }

    /** Check if all stat datasets have been loaded. */
    const isStatDataReady = function () {
        for (const key in out.statData_) {
            const hasConfig = !!out.stat_[key]
            const hasManualData = !!(out.statData_[key] && out.statData_[key].get())

            if (!hasConfig && !hasManualData) continue
            if (!out.statData_[key].isReady()) return false
        }
        return true
    }

    /**
     * Launch map geo data retrieval, and make/update the map once received.
     * This method should be called after attributes related to the map geometries have changed, to retrieve this new data and refresh the map.
     */
    out.updateGeoData = function () {
        out.updateGeoMapTemplate(() => {
            //if stat datasets have not been loaded, wait again
            if (!isStatDataReady()) return

            //proceed with map construction
            out.updateStatValues()
            //execute callback function
            if (out.callback()) out.callback()(out)
        })

        return out
    }

    /**
     * Launch map geo stat datasets retrieval, and make/update the map once received.
     * This method should be called after specifications on the stat data sources attached to the map have changed, to retrieve this new data and refresh the map.
     */
    out.updateStatData = function () {
        for (let statKey in out.stat_) {
            const config = out.stat(statKey)
            const manualData = out.statData(statKey).get?.()

            // Skip if neither stat config nor manual data
            if (!config && !manualData) continue

            // If there's a config, build the statData object (or replace existing)
            if (config) {
                const statData = _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(config)
                out.statData(statKey, statData)

                // Launch remote retrieval
                let nl = out.nutsLevel_
                if (nl === 'mixed') nl = 0

                statData.retrieveFromRemote(nl, out.language(), () => {
                    if (!out.Geometries.isGeoReady()) return
                    if (!isStatDataReady()) return

                    out.updateStatValues()
                    if (out.callback()) out.callback()(out)
                })
            }
        }

        return out
    }

    /**
     * Make/update the map with new stat data.
     * This method should be called after stat data attached to the map have changed, to refresh the map.
     * If the stat data sources have changed, call *updateStatData* instead.
     */
    out.updateStatValues = function () {
        //update classification and styles
        out.updateClassification()
        out.updateStyle()

        //update legend, if any
        if (out.legend_ && out.legendObj()) out.legendObj().update()

        return out
    }

    /**
     * Abstract method.
     * Make/update the map after classification attributes have been changed.
     * For example, if the number of classes, or the classification method has changed, call this method to update the map.
     */
    out.updateClassification = function () {
        console.log('Map updateClassification function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Make/update the map after styling attributes have been changed.
     * For example, if the style (color?) for one legend element has changed, call this method to update the map.
     */
    out.updateStyle = function () {
        console.log('Map updateStyle function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Function which return the legend constructor function for the map.
     */
    out.getLegendConstructor = function () {
        console.log('Map getLegendConstructor function not implemented')
        return _legend_legend__WEBPACK_IMPORTED_MODULE_3__.legend
    }

    /**
     * Retrieve the time stamp of the map, even if not specified in the dimension initially.
     * This applies only for stat data retrieved from Eurostat API.
     * This method is useful for example when the data retrieved is the freshest, and one wants to know what this date is, for example to display it in the map title.
     */
    out.getTime = function () {
        return out.statData('default').getTime()
    }

    /**
     * Set some map attributes based on the following URL parameters:
     * "w":width, "h":height, "x":xGeoCenter, "y":yGeoCenter, "z":pixGeoSize, "s":scale, "lvl":nuts level, "time":time,
     * "proj":CRS, "geo":geo territory, "ny":nuts version, "language":langage, "numberOfClasses":class number
     */
    out.setFromURL = function () {
        const opts = getURLParameters()
        if (opts.w) out.width(opts.w)
        if (opts.h) out.height(opts.h)
        if (opts.x && opts.y) out.geoCenter([opts.x, opts.y])
        if (opts.z) out.pixelSize(opts.z)
        if (opts.s) out.scale(opts.s)
        if (opts.lvl) out.nutsLevel(opts.lvl)
        if (opts.time) {
            out.filters_.time = opts.time
            delete out.filters_.lastTimePeriod
        }
        if (opts.proj) out.proj(opts.proj)
        if (opts.geo) out.geo(opts.geo)
        if (opts.ny) out.nutsYear(opts.ny)
        if (opts.language) out.language(opts.language)
        if (opts.numberOfClasses) out.numberOfClasses(+opts.numberOfClasses)
        return out
    }

    /**
     * @function exportMapToSVG
     * @description Exports the current map with styling to SVG and downloads it
     *
     */
    out.exportMapToSVG = function () {
        // Clone the original SVG node to avoid modifying the DOM
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Add XML namespaces if not already present
        if (!svgNodeClone.hasAttribute('xmlns')) {
            svgNodeClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
        }
        if (!svgNodeClone.hasAttribute('xmlns:xlink')) {
            svgNodeClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
        }

        // Temporarily append the clone to the document to compute styles
        document.body.appendChild(svgNodeClone)

        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Remove the cloned SVG from the document after applying styles
        document.body.removeChild(svgNodeClone)

        const svgUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getDownloadURL)(svgNodeClone)

        // Create a download link and trigger download
        const downloadLink = document.createElement('a')
        downloadLink.href = svgUrl
        downloadLink.download = 'eurostatmap.svg'
        document.body.appendChild(downloadLink)
        downloadLink.click()
        document.body.removeChild(downloadLink)

        return out
    }

    /**
     * @function exportMapToPNG
     * @description Exports the current map with styling to PNG and downloads it
     *
     */
    out.exportMapToPNG = function (width, height) {
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Step 1: Serialize the SVG node to a string
        const serializer = new XMLSerializer()
        const svgString = serializer.serializeToString(svgNodeClone)

        // Step 2: Create a Blob from the serialized SVG
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' })

        // Step 3: Create a URL for the Blob
        const url = URL.createObjectURL(svgBlob)

        // Get the width and height attributes from the SVG
        width = width || svgNodeClone.getAttribute('width')
        height = height || svgNodeClone.getAttribute('height')

        if (!width || !height) {
            throw new Error('SVG width or height attributes are missing or invalid.')
        }

        // Step 4: Create an Image element and load the Blob URL
        const img = new Image()
        img.onload = function () {
            // Step 5: Draw the image on a canvas
            const canvas = document.createElement('canvas')
            canvas.width = parseFloat(width) // Set canvas width from SVG's width attribute
            canvas.height = parseFloat(height) // Set canvas height from SVG's height attribute

            const context = canvas.getContext('2d')
            context.drawImage(img, 0, 0, canvas.width, canvas.height)

            // Step 6: Convert the canvas to a PNG blob
            canvas.toBlob(function (pngBlob) {
                // Step 7: Download the PNG file
                const pngUrl = URL.createObjectURL(pngBlob)
                const downloadLink = document.createElement('a')
                downloadLink.href = pngUrl
                downloadLink.download = 'eurostat-map.png'
                document.body.appendChild(downloadLink)
                downloadLink.click()
                document.body.removeChild(downloadLink)

                // Clean up URLs
                URL.revokeObjectURL(url)
                URL.revokeObjectURL(pngUrl)
            }, 'image/png')
        }

        // Set the image source to the Blob URL
        img.src = url
        return out
    }

    return out
}

/**
 * Retrieve some URL parameters, which could be then reused as map definition parameters.
 * This allow a quick map customisation by simply adding and changing some URL parameters.
 * See map method: setFromURL(...)
 */
const getURLParameters = function () {
    const ps = {}
    const p = ['w', 'h', 'x', 'y', 'z', 's', 'lvl', 'time', 'proj', 'geo', 'ny', 'language', 'sl', 'numberOfClasses']
    for (let i = 0; i < p.length; i++) ps[p[i]] = getURLParameterByName(p[i])
    return ps
}


/***/ }),

/***/ "./src/core/utils.js":
/*!***************************!*\
  !*** ./src/core/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyInlineStylesFromCSS: () => (/* binding */ applyInlineStylesFromCSS),
/* harmony export */   convertRectanglesToPaths: () => (/* binding */ convertRectanglesToPaths),
/* harmony export */   csvToIndex: () => (/* binding */ csvToIndex),
/* harmony export */   executeForAllInsets: () => (/* binding */ executeForAllInsets),
/* harmony export */   flags: () => (/* binding */ flags),
/* harmony export */   getBBOXAsGeoJSON: () => (/* binding */ getBBOXAsGeoJSON),
/* harmony export */   getCSSPropertyFromClass: () => (/* binding */ getCSSPropertyFromClass),
/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),
/* harmony export */   getEstatDataURL: () => (/* binding */ getEstatDataURL),
/* harmony export */   getEstatRestDataURLBase: () => (/* binding */ getEstatRestDataURLBase),
/* harmony export */   getFontSizeFromClass: () => (/* binding */ getFontSizeFromClass),
/* harmony export */   getLegendRegionsSelector: () => (/* binding */ getLegendRegionsSelector),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   getRegionsSelector: () => (/* binding */ getRegionsSelector),
/* harmony export */   getTextColorForBackground: () => (/* binding */ getTextColorForBackground),
/* harmony export */   getURLParameterByName: () => (/* binding */ getURLParameterByName),
/* harmony export */   hexToRgb: () => (/* binding */ hexToRgb),
/* harmony export */   jsonstatToIndex: () => (/* binding */ jsonstatToIndex),
/* harmony export */   lowerCaseAllWordsExceptFirstLetters: () => (/* binding */ lowerCaseAllWordsExceptFirstLetters),
/* harmony export */   multiplyBlendMultipleHex: () => (/* binding */ multiplyBlendMultipleHex),
/* harmony export */   rasterize: () => (/* binding */ rasterize),
/* harmony export */   serialize: () => (/* binding */ serialize),
/* harmony export */   spaceAsThousandSeparator: () => (/* binding */ spaceAsThousandSeparator),
/* harmony export */   updateCSSRule: () => (/* binding */ updateCSSRule),
/* harmony export */   upperCaseFirstLetter: () => (/* binding */ upperCaseFirstLetter)
/* harmony export */ });
// e.g. to be used with deprecated .style() functions. They will now update CSS classes.
function updateCSSRule(selector, property, value) {
    // Validate the selector
    if (!selector.startsWith('.') && !selector.startsWith('#')) {
        throw new Error('Invalid selector: Must start with "." for classes or "#" for IDs.')
    }

    // Check if the rule already exists in any stylesheet
    const styleSheets = Array.from(document.styleSheets)
    for (const styleSheet of styleSheets) {
        try {
            const rules = styleSheet.cssRules || styleSheet.rules
            for (const rule of rules) {
                if (rule.selectorText === selector) {
                    // Update the property if the rule exists
                    rule.style[property] = value
                    return
                }
            }
        } catch (e) {
            // Some stylesheets (e.g., cross-origin) may not be accessible
            console.warn(`Could not access rules in stylesheet:`, e)
        }
    }

    // If the rule doesn't exist, create a new stylesheet and add it
    let customSheet = document.getElementById('custom-styles')
    if (!customSheet) {
        customSheet = document.createElement('style')
        customSheet.id = 'custom-styles'
        document.head.appendChild(customSheet)
    }

    // Add the new rule to the custom stylesheet
    try {
        customSheet.sheet.insertRule(`${selector} { ${property}: ${value}; }`, customSheet.sheet.cssRules.length)
    } catch (e) {
        console.error(`Failed to insert rule: ${selector} { ${property}: ${value}; }`, e)
    }
}

const getFontSizeFromClass = function (className) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'
    tempElement.style.fontSize = 'initial'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed font-size property and parse it to a number
    const fontSize = parseFloat(window.getComputedStyle(tempElement).fontSize)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return fontSize || 0
}

const getCSSPropertyFromClass = function (className, propertyName) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed value of the specified property
    const propertyValue = window.getComputedStyle(tempElement).getPropertyValue(propertyName)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return propertyValue || null
}

// Helper function to get all CSS rules defined in the document
function getAllCSSRules() {
    let cssRules = []
    for (let sheet of document.styleSheets) {
        try {
            // Some stylesheets may not be accessible due to CORS, so we catch any errors
            for (let rule of sheet.cssRules) {
                cssRules.push(rule)
            }
        } catch (e) {
            console.warn('Unable to access stylesheet:', sheet.href, e)
        }
    }
    return cssRules
}

// Helper function to get explicitly defined styles from CSS for an element
function getStylesFromCSS(element) {
    let matchedRules = []
    const cssRules = getAllCSSRules()

    cssRules.forEach((rule) => {
        if (element.matches(rule.selectorText)) {
            matchedRules.push(rule.style)
        }
    })

    // Create an object of the explicitly set styles
    let explicitStyles = {}
    matchedRules.forEach((style) => {
        for (let i = 0; i < style.length; i++) {
            const property = style[i]
            explicitStyles[property] = style.getPropertyValue(property)
        }
    })

    return explicitStyles
}

// Helper function to apply inline styles explicitly set in CSS. Useful for exporting SVGs with CSS styles.
const applyInlineStylesFromCSS = (svgElement) => {
    const allElements = svgElement.querySelectorAll('*')

    allElements.forEach((element) => {
        const cssStyles = getStylesFromCSS(element)

        // Apply each explicitly defined CSS style as an inline style
        Object.keys(cssStyles).forEach((property) => {
            const value = cssStyles[property]

            // Check if the property already has an inline style
            const existingInlineStyle = element.style.getPropertyValue(property)

            if (!existingInlineStyle && value) {
                // If no existing inline style, set the new style
                element.style.setProperty(property, value)
            }
        })
    })
}

/**
 * Return a GeoJSON feature representing a bounding box, with multipoint geometry.
 * This bounding box is an array like the one in topojson bbox element.
 * [xmin,ymin,xmax,ymax]
 * This is useful for to call d3.fitSize([w, h], getTopoJSONExtentAsGeoJSON(topo.bbox)))
 *
 * @param {*} bb The bounding box [xmin,ymin,xmax,ymax]. For topojson data, just give the topojson.bbox element.
 */
const getBBOXAsGeoJSON = function (bb) {
    return {
        type: 'Feature',
        geometry: {
            type: 'MultiPoint',
            coordinates: [
                [bb[0], bb[1]],
                [bb[2], bb[3]],
            ],
        },
    }
}

// indexing

/**
 * Index JSONStat stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} jsData The JSONStat data to index
 */
const jsonstatToIndex = function (jsData) {
    const ind = {}
    const geos = jsData.Dimension('geo').id
    for (let i = 0; i < geos.length; i++) ind[geos[i]] = jsData.Data(i)
    return ind
}

/**
 * Index CSV stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} csvData The CSV data to index
 * @param {*} geoCol The name of the geo column in the CSV data
 * @param {*} valueCol The name of the statistical value column in the CSV file.
 */
const csvToIndex = function (csvData, geoCol, valueCol) {
    const ind = {}
    for (let i = 0; i < csvData.length; i++) {
        const d = csvData[i]
        const v = d[valueCol]
        if (!v) {
            ind[d[geoCol]] = { value: ':', status: '' }
        } else {
            ind[d[geoCol]] = { value: isNaN(+v) ? v : +v, status: '' }
        }
    }
    return ind
}

/**
 * @description returns string with space as thousand separator
 * @function spaceAsThousandSeparator
 * @param {number} number
 */
const spaceAsThousandSeparator = function (number) {
    return number.toLocaleString('en').replace(/,/gi, ' ')
}

//REST API
const getEstatRestDataURLBase = 'https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/'

/**
 * Build URL to fetch data from eurobase REST API.
 * @param {string} datasetCode The Eurobase dataset code
 * @param {object=} filters The filter parameters as for example: {key:value,key:[value1,value2,value3]}
 * @param {number=} lang
 * @param {number=} format
 * @param {number=} version
 */
const getEstatDataURL = function (datasetCode, filters, lang, format) {
    lang = lang || 'en'
    format = format || 'json'
    var url = []
    url.push(getEstatRestDataURLBase, datasetCode, '?', 'format=', format, '&lang=', lang)
    if (filters)
        for (var param in filters) {
            var o = filters[param]
            if (Array.isArray(o)) for (var i = 0; i < o.length; i++) url.push('&', param, '=', o[i])
            else url.push('&', param, '=', o)
        }
    return url.join('')
}

/**
 * @param {string} name
 * @returns {string}
 */
const getURLParameterByName = function (name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

//flags
const flags = {
    b: 'break in time series',
    c: 'confidential',
    d: 'definition differs, see metadata',
    e: 'estimated',
    f: 'forecast',
    n: 'not significant',
    p: 'provisional',
    r: 'revised',
    s: 'Eurostat estimate',
    u: 'low reliability',
    z: 'not applicable',
}

/**
 * @description Executes a function for all inset maps. Some insets might be external SVGs which is why this function was created.
 * @param {*} insets map.insets
 * @param {*} mainSvgId the ID of the map's svg
 * @param {*} callback the function to execute for each inset
 * @param {*} [parameter=null] the parameter to pass to the callback
 * @param {*} [parameter2=null] the parameter to pass to the callback
 */
const executeForAllInsets = function (insets, mainSvgId, callback, parameter = null, parameter2 = null) {
    for (const geo in insets) {
        const insetGroup = insets[geo]

        if (Array.isArray(insetGroup)) {
            insetGroup.forEach((inset) => {
                // Handle nested arrays for multiple insets with the same geo
                if (Array.isArray(inset)) {
                    inset.forEach((nestedInset) => {
                        if (nestedInset.svgId_ !== mainSvgId) {
                            callback(nestedInset, parameter, parameter2)
                        }
                    })
                } else {
                    if (inset.svgId_ !== mainSvgId) {
                        callback(inset, parameter, parameter2)
                    }
                }
            })
        } else {
            // Apply callback to unique inset
            if (insetGroup.svgId_ !== mainSvgId) {
                callback(insetGroup, parameter, parameter2)
            }
        }
    }
}

const upperCaseFirstLetter = (string) => `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`

const lowerCaseAllWordsExceptFirstLetters = (string) =>
    string.replaceAll(/\S*/g, (word) => `${word.slice(0, 1)}${word.slice(1).toLowerCase()}`)

function getDownloadURL(svgNode) {
    // Create XML header to ensure the SVG is recognized properly
    const xmlHeader = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'

    // create blob
    const svgContent = xmlHeader + svgNode.outerHTML
    const svgBlob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' })
    const svgUrl = URL.createObjectURL(svgBlob)
    return svgUrl
}

// Rasterize function with additional error handling
function serialize(svg) {
    const xmlns = 'http://www.w3.org/2000/xmlns/'
    const xlinkns = 'http://www.w3.org/1999/xlink'
    const svgns = 'http://www.w3.org/2000/svg'
    const fragment = window.location.href + '#'
    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false)
    while (walker.nextNode()) {
        for (const attr of walker.currentNode.attributes) {
            if (attr.value.includes(fragment)) {
                attr.value = attr.value.replace(fragment, '#')
            }
        }
    }
    svg.setAttributeNS(xmlns, 'xmlns', svgns)
    svg.setAttributeNS(xmlns, 'xmlns:xlink', xlinkns)
    const serializer = new window.XMLSerializer()
    const string = serializer.serializeToString(svg)
    return new Blob([string], { type: 'image/svg+xml' })
}

// adapted from https://observablehq.com/@mbostock/saving-sv
//svg to canvas blob promise
function rasterize(svg) {
    let resolve, reject
    const promise = new Promise((y, n) => ((resolve = y), (reject = n)))
    const image = new Image()
    image.onerror = reject
    image.onload = () => {
        const rect = svg.getBoundingClientRect()
        const canvas = document.createElement('canvas')
        canvas.width = rect.width
        canvas.height = rect.height
        const context = canvas.getContext('2d')
        context.drawImage(image, 0, 0, rect.width, rect.height)
        context.canvas.toBlob(resolve)
    }
    image.src = URL.createObjectURL(serialize(svg))
    return promise
}

/**
 * Get a URL parameter by name.
 *
 * @param {string} name
 * @returns {string | null}
 */
function getParameterByName(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    let regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

const hexToRgb = (hex) => {
    hex = hex.replace('#', '')
    if (hex.length === 3) {
        hex = hex
            .split('')
            .map((h) => h + h)
            .join('')
    }
    const int = parseInt(hex, 16)
    return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
}

//blends two colors using 'multiply' blending mode. Returns the blended color as an RGB string
const multiplyBlendMultipleHex = (colors) => {
    // Convert hex color to RGB
    const hexToRgb = (hex) => {
        hex = hex.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((h) => h + h)
                .join('')
        }
        const int = parseInt(hex, 16)
        return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
    }

    // Convert RGB to hex
    const rgbToHex = ([r, g, b]) => `#${[r, g, b].map((c) => c.toString(16).padStart(2, '0')).join('')}`

    // Convert all hex colors to RGB arrays
    const rgbColors = colors.map(hexToRgb)

    // Initialize the result with the first color
    let blended = [...rgbColors[0]]

    // Sequentially multiply each color with the result
    for (let i = 1; i < rgbColors.length; i++) {
        blended = blended.map((v, idx) => Math.round((v / 255) * (rgbColors[i][idx] / 255) * 255))
    }

    // Return the blended color as a hex code
    return rgbToHex(blended)
}

// convert rect attributes into an SVG path string
// used for workaround whereby clipPaths which use rect elements do not work in adobe illustrator
const convertRectanglesToPaths = function (x, y, width, height) {
    var x = parseFloat(x, 10)
    var y = parseFloat(y, 10)
    var width = parseFloat(width, 10)
    var height = parseFloat(height, 10)

    if (x < 0 || y < 0 || width < 0 || height < 0) {
        return ''
    }

    return 'M' + x + ',' + y + 'L' + (x + width) + ',' + y + ' ' + (x + width) + ',' + (y + height) + ' ' + x + ',' + (y + height) + 'z'
}

const getTextColorForBackground = function (backgroundColor) {
    let r, g, b

    // Create a temporary element to handle named colors
    if (!backgroundColor.startsWith('rgb') && !backgroundColor.startsWith('#')) {
        const tempDiv = document.createElement('div')
        tempDiv.style.color = backgroundColor
        document.body.appendChild(tempDiv)
        const computedColor = window.getComputedStyle(tempDiv).color
        document.body.removeChild(tempDiv)
        backgroundColor = computedColor // Convert named color to RGB
    }

    // Handle hex colors like '#FFFFFF' or '#FFF'
    if (backgroundColor.startsWith('#')) {
        let hex = backgroundColor.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((c) => c + c)
                .join('')
        }
        r = parseInt(hex.substring(0, 2), 16)
        g = parseInt(hex.substring(2, 4), 16)
        b = parseInt(hex.substring(4, 6), 16)
    }
    // Handle RGB colors like 'rgb(255,255,255)'
    else {
        const rgb = backgroundColor.match(/\d+/g)
        r = parseInt(rgb[0])
        g = parseInt(rgb[1])
        b = parseInt(rgb[2])
    }

    // Calculate luminance
    const luminance = 0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255)

    // Return black for light backgrounds, white for dark backgrounds
    return luminance > 0.5 ? 'black' : 'white'
}

// get css selector. Different maps have different selectors for their regions.
const getRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions path'
    if (map.gridCartogram_) return '#em-grid-container .em-grid-cell'
    if (map.geo_ === 'WORLD') return '#em-worldrg path'
    return '#em-nutsrg path:not(#em-cntrg-RS):not(#em-cntrg-EL), #em-cntrg path:not(#em-cntrg-RS):not(#em-cntrg-EL)'
}

// get css selector for legend mouse hover. Different maps have different selectors for their regions
const getLegendRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions'
    if (map.gridCartogram_) return '#em-grid-container'
    if (map.geo_ === 'WORLD') return '#em-worldrg'
    return '#em-nutsrg, #em-cntrg'
}


/***/ }),

/***/ "./src/css/index.css":
/*!***************************!*\
  !*** ./src/css/index.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./index.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/eurostat-map.js":
/*!*****************************!*\
  !*** ./src/eurostat-map.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* binding */ getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* binding */ getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maptypes/map-choropleth */ "./src/maptypes/map-choropleth.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maptypes/map-categorical */ "./src/maptypes/map-categorical.js");
/* harmony import */ var _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./maptypes/map-choropleth-bivariate */ "./src/maptypes/map-choropleth-bivariate.js");
/* harmony import */ var _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./maptypes/map-choropleth-trivariate */ "./src/maptypes/map-choropleth-trivariate.js");
/* harmony import */ var _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maptypes/map-stripe-composition */ "./src/maptypes/map-stripe-composition.js");
/* harmony import */ var _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./maptypes/map-piecharts */ "./src/maptypes/map-piecharts.js");
/* harmony import */ var _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./maptypes/map-sparklines */ "./src/maptypes/map-sparklines.js");
/* harmony import */ var _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./maptypes/map-flow */ "./src/maptypes/map-flow.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _core_labels__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/labels */ "./src/core/labels.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../package.json */ "./package.json");












/**
 * Function returning a eurostat-map object.
 *
 * @param {*} type The type of map ('ch' for choropleth, etc.)
 * @param {*} config The configuration object. Ex.: { title: "Map title", geoCenter: [233,654], ...}
 */
const map = function (type, config) {
    try {
        //choropleth map
        if (type == 'choropleth' || type == 'ch') return _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__.map(config)
        //categorical map
        if (type == 'categorical' || type == 'ct') return _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__.map(config)
        //proportionnal symbols map
        if (type == 'proportionalSymbol' || type == 'ps') return _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.map(config)
        //bivariate choropleth
        if (type == 'bivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__.map(config)
        //trivariate choropleth
        if (type == 'trivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__.map(config)
        //stripes composition
        if (type == 'stripeComposition' || type == 'scomp') return _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__.map(config)
        //proportional pie charts
        if (type == 'pieChart' || type == 'pie') return _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__.map(config)
        //sparkline maps
        if (type == 'sparkline' || type == 'spark' || type == 'sparklines') return _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__.map(config)
        //flow maps
        if (type == 'flow' || type == 'flowmap') return _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__.map(config)

        //add new map types here
        //if(type == "XX") return mapXX.map(config);

        console.log('Unexpected map type: ' + type)
        return _core_stat_map__WEBPACK_IMPORTED_MODULE_9__.statMap(config, true, type)
    } catch (e) {
        console.error('Error in eurostat-map.map: ' + e.message)
        console.error(e)
    }
}

/**
 * Return a function which builds fill patterns style.
 * The returned function has for arguments the SVG element where to use the fill pattern, and the number of classes.
 *
 * @param {*} opts Various parameters on the fill pattern.
 * @returns {function}
 */
const getFillPatternDefinitionFunction = function (opts) {
    opts = opts || {}
    opts.shape = opts.shape || 'circle'
    const ps = opts.patternSize || 5
    const smin = opts.minSize || 1
    const smax = opts.maxSize || 5.5
    opts.bckColor = opts.bckColor || 'white'
    opts.symbColor = opts.symbColor || 'black'
    return function (svg, numberOfClasses) {
        //clear previous
        svg.selectAll('.em-fill-pattern').remove()
        for (let i = 0; i < numberOfClasses; i++) {
            const si = smin + ((smax - smin) * i) / (numberOfClasses - 1)
            const patt = svg
                .append('pattern')
                .attr('class', 'em-fill-pattern')
                .attr('id', 'pattern_' + i)
                .attr('x', '0')
                .attr('y', '0')
                .attr('width', ps)
                .attr('height', ps)
                .attr('patternUnits', 'userSpaceOnUse')
            patt.append('rect').attr('x', 0).attr('y', 0).attr('width', ps).attr('height', ps).style('stroke', 'none').style('fill', opts.bckColor)
            if (opts.shape == 'square')
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', si)
                    .attr('height', si)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
            else
                patt.append('circle')
                    .attr('cx', ps * 0.5)
                    .attr('cy', ps * 0.5)
                    .attr('r', si * 0.5)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
        }
    }
}

const getDefaultLabels = function () {
    return _core_labels__WEBPACK_IMPORTED_MODULE_10__.DEFAULTLABELS
}

;
const version = _package_json__WEBPACK_IMPORTED_MODULE_11__.version


/***/ }),

/***/ "./src/legend/legend-categorical.js":
/*!******************************************!*\
  !*** ./src/legend/legend-categorical.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");





/**
 * A legend for categorical maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 13
    //the height of the legend box elements
    out.shapeHeight = 15
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'
    // allow the user to define the order of the legend elements manually as an array
    out.order = undefined

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node() && out.map.classifier_) {
            const map = out.map
            const container = out.lgg

            //draw legend background box
            out.makeBackgroundBox()

            //draw title
            if (out.title) {
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + out.titleFontSize)
                    .text(out.title)
            }

            //get category codes
            const domain = map.classToFillStyle() ? Object.keys(map.classToFillStyle()) : map.classifier_.domain()
            const ecls = out.order ? out.order : domain

            //draw legend elements for classes: rectangle + label
            for (let i = 0; i < ecls.length; i++) {
                //the class
                const ecl_ = ecls[i]
                const ecl = map.classifier_(ecl_)
                const fillColor = map.classToFillStyle_[ecl_]

                //the vertical position of the legend element
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', fillColor)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, ecl)
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, ecl)
                        }
                    })

                //label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(map.classToText() ? map.classToText()[ecl_] : ecl_)
            }

            //'no data' legend box
            if (out.noData) {
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + ecls.length * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', map.noDataFillStyle_)
                    .on('mouseover', function () {
                        highlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, 'nd')
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, 'nd')
                        }
                    })

                //'no data' label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(out.noDataText)
            }

            // Append pattern fill legend items BELOW the main legend
            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-bivariate.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-choropleth-bivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth-bivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //size
    out.squareSize = 100

    //orientation
    out.rotation = 0

    //labels
    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'

    //get the font size of the texts
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')

    //breaks
    out.breaks1 = undefined
    out.breaks2 = undefined
    out.showBreaks = false // if set to true and breaks1 and breaks2 are undefined then breaks are automatically defined
    out.tickLength = 5 // length of the ticks

    //axis
    out.yAxisLabelsOffset = { x: 0, y: 0 }
    out.xAxisLabelsOffset = { x: 0, y: 0 }

    //axis titles
    out.yAxisTitleOffset = { x: 0, y: 0 }
    out.xAxisTitleOffset = { x: 0, y: 0 }

    //show no data
    out.noData = true
    //show no data
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25

    //no data text label
    out.noDataText = 'No data'

    //override padding
    out.boxPadding = out.labelFontSize

    //add extra distance between legend and no data item
    out.noDataYOffset = 30

    //arrows
    out.axisArrows = true // if set to true, arrows are drawn at the end of the axes
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10 // padding between arrow and axis label

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        // Horizontal shift to move everything right (adjust this value as needed)
        out._horizontalOffset = out.axisTitleFontSize + out.arrowPadding // Adjust this value to move the whole legend to the right

        // Remove previous content
        out.lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Draw title
        if (out.title) {
            out.lgg
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', xc + out._horizontalOffset)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        // The vertical position of the legend element
        out._y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0)

        // Square group with horizontal offset
        addSquares()

        // set breaks if user hasnt defined them but has enabled them
        if (!out.breaks1 && !out.breaks2 && out.showBreaks) {
            // Get quantiles for the first variable (X axis) and truncate to one decimal place
            out.breaks1 = map.classifier1_.quantiles().map((value) => parseFloat(value.toFixed(0)))

            // Get quantiles for the second variable (Y axis) and truncate to one decimal place
            out.breaks2 = map.classifier2_.quantiles().map((value) => parseFloat(value.toFixed(0)))
        }

        // Draw breaks labels 1 (X axis)
        addBreakLabels()

        out._xAxisArrowY = 0
        out._yAxisArrowX = 0
        if (out.axisArrows) {
            addAxisArrows()
        }

        addAxisTitles()

        // Arrow defs
        out.lgg
            .append('defs')
            .append('marker')
            .attr('viewBox', `0 0 ${out.arrowWidth} ${out.arrowHeight}`)
            .attr('id', 'arrowhead')
            .attr('refX', 0)
            .attr('refY', 5)
            .attr('markerWidth', out.arrowWidth)
            .attr('markerHeight', out.arrowHeight)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 5 5 L 0 10')
            .attr('marker-units', 'strokeWidth')

        // 'No data' legend box
        if (out.noData) {
            addNoDataElement()
        }

        // Set legend box dimensions
        out.setBoxDimension()
    }

    function addNoDataElement() {
        const noDataYOffset =
            out.rotation === 0 ? out.noDataYOffset + out.squareSize / out.map.numberOfClasses_ + out.arrowHeight / 2 : out.noDataYOffset

        let noDataY =
            out.rotation === 0 ? out._y + out.squareSize + noDataYOffset : out._y + 1.4142 * out.squareSize + out.boxPadding * 2 + noDataYOffset

        out.lgg
            .append('rect')
            .attr('class', 'em-bivariate-nodata')
            .attr('x', out.boxPadding + out.noDataShapeWidth / 2)
            .attr('y', noDataY + (out.rotation == 0 ? 0 : -10))
            .attr('width', out.noDataShapeWidth)
            .attr('height', out.noDataShapeHeight)
            .style('fill', out.map.noDataFillStyle())
            .on('mouseover', function () {
                const regions = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])('#em-nutsrg')
                const sel = regions.selectAll("[nd='nd']")
                sel.style('fill', 'red')
            })
            .on('mouseout', function () {
                const nRg = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])('#em-nutsrg')
                const sel = nRg.selectAll("[nd='nd']")
                sel.style('fill', function () {
                    return (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')
                })
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', out.map.noDataFillStyle())
            })
        out.lgg
            .append('text')
            .attr('class', 'em-bivariate-nodata-label')
            .attr('x', out.boxPadding + out.noDataShapeWidth + (out.noDataShapeWidth / 2 + 5))
            .attr('y', noDataY + out.noDataShapeHeight * 0.5 + 1 + (out.rotation == 0 ? 0 : -10))
            .text(out.noDataText)
    }

    function addSquares() {
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()
        const sz = out.squareSize / numberOfClasses
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        const square = lgg
            .append('g')
            .attr('class', 'bivariate-squares-chart')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // Draw rectangles
        for (let i = 0; i < numberOfClasses; i++) {
            for (let j = 0; j < numberOfClasses; j++) {
                const ecl1 = numberOfClasses - i - 1
                const ecl2 = numberOfClasses - j - 1
                const fill = out.map.classToFillStyle()(ecl1, ecl2)

                square
                    .append('rect')
                    .attr('class', 'em-bivariate-square')
                    .attr('x', initialX + (numberOfClasses - 1 - i) * sz)
                    .attr('y', j * sz)
                    .attr('width', sz)
                    .attr('height', sz)
                    .style('fill', fill)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl1, ecl2)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl1, ecl2)
                        }
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).raise() // raise legend square to avoid stroke issue
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl1, ecl2)
                        }
                    })
            }
        }

        // Frame
        square
            .append('rect')
            .attr('class', 'em-bivariate-frame')
            .attr('x', initialX)
            .attr('y', 0)
            .attr('width', out.squareSize)
            .attr('height', out.squareSize)
            .attr('stroke-width', 0.7)
    }

    function addBreakLabels() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0
        const numberOfClasses = out.map.numberOfClasses()
        const sz = out.squareSize / numberOfClasses

        // group with horizontal offset
        const breakLabels = out.lgg
            .append('g')
            .attr('class', 'bivariate-break-labels')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )
        if (out.breaks1) {
            for (let i = 0; i < out.breaks1.length; i++) {
                const x = initialX + sz * (i + 1)
                const y = out.squareSize + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label')

                breakLabels
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.xAxisLabelsOffset.x)
                    .attr('y', y + out.xAxisLabelsOffset.y)
                    .text(out.breaks1[i])

                breakLabels
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x)
                    .attr('x2', x)
                    .attr('y1', out.squareSize)
                    .attr('y2', out.squareSize + out.tickLength)
            }
        }

        // Draw breaks labels 2 (Y axis)
        if (out.breaks2) {
            for (let i = 0; i < out.breaks2.length; i++) {
                const x = initialX
                const y = sz * (i + 2) - sz

                breakLabels
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.yAxisLabelsOffset.x)
                    .attr('y', y - out.yAxisLabelsOffset.y - (out.tickLength + 2))
                    .text([...out.breaks2].reverse()[i])
                    .attr('text-anchor', 'middle')
                    .attr('transform', `rotate(-90, ${x}, ${y})`)

                breakLabels
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x)
                    .attr('x2', x - out.tickLength)
                    .attr('y1', y)
                    .attr('y2', y)
            }
        }
    }

    function addAxisTitles() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        const axisTitles = out.lgg
            .append('g')
            .attr('class', 'bivariate-axis-titles')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // X axis title
        let xAxisTitleY = out.squareSize + out.xAxisLabelsOffset.y + (out.axisArrows ? out.arrowPadding + out.arrowHeight : 7)
        let xAxisTitleX = initialX
        if (out.showBreaks || (out.breaks1 && out.breaks2)) xAxisTitleY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') // move over for tick labels
        if (out.xAxisTitleOffset) xAxisTitleY += out.xAxisTitleOffset.y
        if (out.xAxisTitleOffset) xAxisTitleX += out.xAxisTitleOffset.x
        axisTitles
            .append('text')
            .attr('class', 'em-bivariate-axis-title em-bivariate-axis-title-x')
            .attr('x', xAxisTitleX)
            .attr('y', xAxisTitleY)
            .text(out.label1)
            .attr('dominant-baseline', 'hanging')
            .attr('alignment-baseline', 'hanging')

        // Y axis title
        let yAxisTitleY = (out.axisArrows ? out._yAxisArrowX - out.arrowPadding : 7) + (out.rotation == -45 ? -4 : -10) // adjust for rotation
        if (out.showBreaks || (out.breaks1 && out.breaks2)) xAxisTitleY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') // move over for tick labels
        let yAxisTitleX = -out.squareSize
        //manual offsets
        if (out.yAxisTitleOffset) yAxisTitleY += out.yAxisTitleOffset.y
        if (out.yAxisTitleOffset) yAxisTitleX += out.yAxisTitleOffset.x
        axisTitles
            .append('text')
            .attr('class', 'em-bivariate-axis-title em-bivariate-axis-title-y')
            .attr('x', yAxisTitleX)
            .attr('y', yAxisTitleY)
            .text(out.label2)
            .style('transform', out.rotation < 0 ? `translate(${out.axisArrows ? -51 : -15}px, 95px) rotate(90deg)` : 'rotate(-90deg)')
    }

    function addAxisArrows() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        // group with horizontal offset
        const axisArrows = out.lgg
            .append('g')
            .attr('class', 'bivariate-axis-arrows')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // Append X axis arrow
        out._xAxisArrowY = out.squareSize + out.tickLength + out.arrowPadding
        if (out.showBreaks || (out.breaks1 && out.breaks2)) out._xAxisArrowY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') / 1.5 // move over for tick labels

        axisArrows
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__["default"])()([
                    [initialX, out._xAxisArrowY],
                    [initialX + out.squareSize, out._xAxisArrowY],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')

        // Append Y axis arrow
        out._yAxisArrowX = -out.tickLength - out.arrowPadding
        if (out.showBreaks || (out.breaks1 && out.breaks2)) out._yAxisArrowX -= out.labelFontSize / 2 // move over for tick labels

        axisArrows
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__["default"])()([
                    [out._yAxisArrowX, out.squareSize],
                    [out._yAxisArrowX, 0],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-trivariate.js":
/*!****************************************************!*\
  !*** ./src/legend/legend-choropleth-trivariate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");




/**
 * A legend for choropleth-trivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    // Default settings
    out.width = 230
    out.height = 230

    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'
    out.label3 = 'Variable 3' // Add a label for the third variable
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')
    out.showBreaks = false
    out.noData = true
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25
    out.noDataText = 'No data'
    out.boxPadding = 60 // depends on variable 1 label length really
    out.noDataYOffset = 20
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10

    if (config) for (let key in config) out[key] = config[key]

    /**
     * Override the update method to handle trivariate legends
     */
    out.update = function () {
        out.updateConfig()
        out.updateContainer()
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()

        // Remove previous content
        lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Apply padding to the main <g> group
        const paddedGroup = lgg.append('g').attr('transform', `translate(${out.boxPadding}, ${out.boxPadding})`)

        // Draw title
        if (out.title) {
            paddedGroup
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Start at 0 within the padded group
                .attr('y', out.titleFontSize) // Vertical positioning
                .text(out.title)
        }

        // Draw the trivariate Venn diagram
        const labels = [out.label1, out.label2, out.label3]
        const colors = [out.map.color1_, out.map.color2_, out.map.color3_]

        drawTrivariateVennDiagram(paddedGroup, colors, labels)

        // Handle trivariate (Venn Diagram) or bivariate (grid) legend
        // if (numberOfClasses === 7) {
        //     drawTrivariateVennDiagram(lgg, out)
        // } else {
        //     drawTrivariateTernaryPlot(lgg, out, numberOfClasses)
        // }
    }

    return out
}

function drawTrivariateVennDiagram(container, colors, labels) {
    //specs for Circle 1
    const xCenter1 = 50
    const yCenter1 = 50
    const circleRad = 30

    //draw Circle 1
    // const circle1 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter1 + ',' + yCenter1 + ')')

    //add'l specs for Circle 2
    const offsetFactor = 1.2
    const offset = offsetFactor * circleRad
    const xCenter2 = xCenter1 + offset
    const yCenter2 = yCenter1 //creating new var for clarity

    //draw Circle 2
    // const circle2 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter2 + ',' + yCenter2 + ')')

    //add'l specs for Circle 3
    const xCenter3 = xCenter1 + offset / 2
    const yCenter3 = yCenter1 + (Math.sqrt(3) * offset) / 2

    //draw Circle 3
    // const circle3 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter3 + ',' + yCenter3 + ')')

    //compute first points of intersection
    const triHeight = Math.sqrt(circleRad ** 2 - (offset / 2) ** 2)
    //outer intersection of Circles 1 and 2
    const xIsect1 = xCenter3
    const yIsect1 = yCenter1 - triHeight
    //inner intersection of Circles 1 and 2
    const xIsect4 = xCenter3
    const yIsect4 = yCenter1 + triHeight

    //treat "triHeight" as the hypoteneuse of a 30.60.90 triangle.
    //this tells us the shift from the midpoint of a leg of the triangle
    //to the point of intersection
    const xDelta = (triHeight * Math.sqrt(3)) / 2
    const yDelta = triHeight / 2

    const xMidpointC1C3 = (xCenter1 + xCenter3) / 2
    const xMidpointC2C3 = (xCenter2 + xCenter3) / 2
    const yMidpointBoth = (yCenter1 + yCenter3) / 2

    //find the rest of the points of intersection
    const xIsect2 = xMidpointC1C3 - xDelta
    const yIsect2 = yMidpointBoth + yDelta
    const xIsect3 = xMidpointC2C3 + xDelta
    const yIsect3 = yMidpointBoth + yDelta

    const xIsect5 = xMidpointC1C3 + xDelta
    const yIsect5 = yMidpointBoth - yDelta
    const xIsect6 = xMidpointC2C3 - xDelta
    const yIsect6 = yMidpointBoth - yDelta

    const xPoints = [xIsect1, xIsect2, xIsect3, xIsect4, xIsect5, xIsect6]
    const yPoints = [yIsect1, yIsect2, yIsect3, yIsect4, yIsect5, yIsect6]

    const makeIronShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const makeSunShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 0 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 1 1 ${x1} ${y1}`
        return path
    }

    const makeRoundedTri = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 1 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const ironPoints = [
        [1, 5, 6],
        [3, 4, 5],
        [2, 6, 4],
    ]
    const sunPoints = [
        [3, 5, 1],
        [2, 4, 3],
        [1, 6, 2],
    ]
    const roundedTriPoints = [[5, 4, 6]]

    // main circles (raw colors)
    sunPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeSunShapes(ptCycle)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', colors[index]).attr('opacity', 1)
    })

    // first intersects (combination of 2 colors)
    ironPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeIronShapes(ptCycle)

        let color
        if (index == 0) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[2], colors[0]]) // pink + cyan
        } else if (index == 1) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[0]]) // cyan + yellow
        } else if (index == 2) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[2]]) // pink + yellow
        }

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    // nucleus (combination of all 3 colors)
    roundedTriPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeRoundedTri(ptCycle)
        const color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)(colors)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    container
        .selectAll('path.segment')
        .on('mouseover', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 0.8).duration(500)
        })
        .on('mouseout', function () {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 1).duration(500)
        })

    // label intersects
    const yOffset = container
        .append('text')
        .text(labels[0])
        .attr('x', xCenter1 - circleRad - 3)
        .attr('y', xCenter1)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'end')
    container
        .append('text')
        .text(labels[1])
        .attr('x', xCenter2 + circleRad + 3)
        .attr('y', yCenter2)
        .attr('class', 'venn-label')
    container
        .append('text')
        .text(labels[2])
        .attr('x', xCenter3)
        .attr('y', yCenter3 + circleRad + 15)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'middle')
}

/**
 * Draws a trivariate legend as a Venn Diagram
 */
function drawTrivariateVennDiagram2(svg, containerWidth, containerHeight, labels, colors) {
    const radius = containerWidth / 5 // Radius of each circle
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    const offset = radius / 1.5

    // Define circle positions
    const circles = [
        { id: 'circle1', cx: centerX - offset, cy: centerY, label: labels[0], color: colors[0] },
        { id: 'circle2', cx: centerX + offset, cy: centerY, label: labels[1], color: colors[1] },
        { id: 'circle3', cx: centerX, cy: centerY + offset * 1.5, label: labels[2], color: colors[2] },
    ]

    // Draw circles
    circles.forEach(({ id, cx, cy, label, color }, index) => {
        svg.append('circle').attr('id', id).attr('cx', cx).attr('cy', cy).attr('r', radius).style('fill', color).style('opacity', 1)

        // Add labels with specific positioning
        const labelX =
            index === 0
                ? cx - radius - 10 // Left of the first circle
                : index === 1
                  ? cx + radius + 10 // Right of the second circle
                  : cx // Below the third circle

        const labelY = index < 2 ? cy : cy + radius + 20 // Same y for first two circles, below for the third

        svg.append('text')
            .attr('x', labelX)
            .attr('y', labelY)
            .attr('text-anchor', index < 2 ? (index === 0 ? 'end' : 'start') : 'middle') // Adjust alignment
            .attr('class', 'venn-label')
            .text(label)
            .style('font-size', '12px')
    })
}

/**
 * Draws a trivariate legend as a ternary plot
 */
function drawTrivariateTernaryPlot(lgg, out, numberOfClasses) {
    const size = out.squareSize // Size of the legend area
    const padding = 20 // Padding around the plot
    const radius = 5 // Radius of each class point
    const triangleHeight = (Math.sqrt(3) / 2) * size

    const ternaryGroup = lgg
        .append('g')
        .attr('class', 'trivariate-ternary-plot')
        .attr('transform', `translate(${out.boxPadding + size / 2}, ${out.boxPadding + triangleHeight / 2})`)

    // Draw the triangle
    const vertices = [
        { x: 0, y: -triangleHeight / 2 }, // Top vertex (Variable 1)
        { x: -size / 2, y: triangleHeight / 2 }, // Bottom-left vertex (Variable 2)
        { x: size / 2, y: triangleHeight / 2 }, // Bottom-right vertex (Variable 3)
    ]

    ternaryGroup
        .append('polygon')
        .attr('points', vertices.map((d) => `${d.x},${d.y}`).join(' '))
        .attr('fill', 'none')
        .attr('stroke', 'black')

    // Label the vertices
    const labels = [out.label1, out.label2, out.label3]
    vertices.forEach((vertex, i) => {
        ternaryGroup
            .append('text')
            .attr('x', vertex.x)
            .attr('y', vertex.y - (i === 0 ? 10 : -20)) // Offset labels
            .attr('class', 'ternary-label')
            .attr('text-anchor', 'middle')
            .text(labels[i])
    })

    // Plot the points inside the ternary plot
    for (let i = 0; i < numberOfClasses; i++) {
        for (let j = 0; j < numberOfClasses - i; j++) {
            const k = numberOfClasses - i - j - 1 // Ensure sum of i + j + k = numberOfClasses - 1
            const x = ((j - k) * size) / (2 * (numberOfClasses - 1)) // Horizontal position
            const y = (i * -triangleHeight) / (numberOfClasses - 1) // Vertical position

            const fill = out.map.classToFillStyle()(i, j, k)

            ternaryGroup
                .append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', radius)
                .attr('fill', fill)
                .on('mouseover', function () {
                    highlightRegions(out.map, i, j, k)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, i, j, k)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, i, j, k)
                    }
                })
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___'))
        })
    }
}


/***/ }),

/***/ "./src/legend/legend-choropleth.js":
/*!*****************************************!*\
  !*** ./src/legend/legend-choropleth.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");
/* harmony import */ var _legend_histogram__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legend-histogram */ "./src/legend/legend-histogram.js");







/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object (inherit)
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    out.labelType = 'thresholds' // thresholds || ranges
    //the order of the legend elements. Set to false to invert.
    out.ascending = true
    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the separation line length
    out.sepLineLength = out.shapeWidth
    //tick line length in pixels
    out.tickLength = 4
    //the number of decimal for the legend labels
    out.decimals = 0
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 3
    //labelFormatter function
    out.labelFormatter = null
    // manually define labels
    out.labels = null

    // Histogram config as nested object
    out.histogram = null

    //diverging line
    out.pointOfDivergenceLabel = undefined
    out.pointOfDivergence = undefined
    out.pointOfDivergencePadding = 7
    out.divergingLineLength = undefined
    out.divergingArrowLength = undefined

    //show no data
    out.noData = true
    //no data text label
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) {
        for (let key in config) {
            if (key === 'histogram' && typeof config[key] === 'object') {
                out.histogram = {
                    orientation: 'horizontal',
                    showCounts: false,
                    showPercentages: false,
                    labelRotation: 0,
                    ...config.histogram,
                }
            } else {
                out[key] = config[key]
            }
        }
    }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const map = out.map
            const container = out.lgg

            // Draw legend background box and title if provided
            out.makeBackgroundBox()
            if (out.title) {
                let cssFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title')
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + cssFontSize)
                    .text(out.title)
            }

            //exit early if no classifier
            if (!map.classToFillStyle()) return

            //set default point of divergence if applicable
            if (out.pointOfDivergenceLabel && !out.pointOfDivergence) out.pointOfDivergence = map.numberOfClasses_ / 2

            if (out.histogram) {
                (0,_legend_histogram__WEBPACK_IMPORTED_MODULE_3__.createHistogramLegend)(out, getThresholds(), getColors(), getData(), getLabelFormatter(), highlightRegions, unhighlightRegions)
            } else {
                if (out.labelType === 'ranges') createRangesLegend()
                else createThresholdsLegend()
            }

            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height

            // Append pattern fill legend items BELOW the main legend
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            // Set legend box dimensions
            out.setBoxDimension()
        }
    }

    function getThresholds() {
        const map = out.map
        const thresholds =
            map.thresholds_.length > 1
                ? map.thresholds_
                : Array.from({ length: map.numberOfClasses_ })
                      .map((_, index) => {
                          return map.classifier().invertExtent(index)[out.ascending ? 0 : 1]
                      })
                      .slice(1) // Remove the first entry and return the rest as an array
        return thresholds
    }

    function getColors() {
        const map = out.map
        return map.colors_
            ? map.colors_
            : Array.from({ length: map.numberOfClasses_ }).map((_, index) => {
                  return map.classToFillStyle()(index, map.numberOfClasses_)
              })
    }

    function getData() {
        const map = out.map
        return Object.values(map.statData()._data_).map((item) => item.value)
    }

    function getLabelFormatter() {
        if (out.labelType == 'ranges') {
            const thresholds = getThresholds()
            const defaultLabeller = (label, i) => {
                const decimalFormatter = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)(`.${out.decimals}f`)
                if (i === 0) return `> ${decimalFormatter(thresholds[thresholds.length - 1])}` //top
                if (i === thresholds.length) return `< ${decimalFormatter(thresholds[0])}` //bottom
                return `${decimalFormatter(thresholds[thresholds.length - i - 1])} - < ${decimalFormatter(thresholds[thresholds.length - i])}  ` //in-between
            }
            return out.labelFormatter || defaultLabeller
        } else if (out.labelType == 'thresholds') {
            return out.labelFormatter || (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)(`.${out.decimals}f`)
        } else {
            return out.labelFormatter || (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)(`.${out.decimals}f`)
        }
    }

    function createThresholdsLegend() {
        const m = out.map
        const lgg = out.lgg
        let baseY = out.boxPadding
        // Label formatter
        const labelFormatter = getLabelFormatter()
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding
        for (let i = 0; i < m.numberOfClasses_; i++) {
            const y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? m.numberOfClasses() - i - 1 : i
            const fillColor = m.classToFillStyle()(ecl, m.numberOfClasses_)

            // Append rectangle for each class
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append tick line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.boxPadding + out.sepLineLength)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength + out.tickLength)
                    .attr('y2', y)
            }

            // Append label
            if (i < m.numberOfClasses() - 1) {
                // mark label so we can move it in drawDivergingLine
                const label = lgg
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                    .attr('y', y + out.shapeHeight)
                    //.attr('dominant-baseline', 'middle')
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(out.labels ? out.labels[i] : labelFormatter(m.classifier().invertExtent(ecl)[out.ascending ? 0 : 1]))

                // mark label so we can move it in drawDivergingLine
                if (out.pointOfDivergenceLabel && i == out.pointOfDivergence - 1) label.attr('class', 'em-legend-label em-legend-label-divergence')
            }
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const y = baseY + m.numberOfClasses() * out.shapeHeight + out.boxPadding
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dy', '0.35em')
                .text(out.noDataText)
        }
    }

    function createRangesLegend() {
        const map = out.map
        const container = out.lgg
        const labelFormatter = getLabelFormatter()

        let baseY = out.boxPadding
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding

        // for each class
        for (let i = 0; i < map.numberOfClasses_; i++) {
            let y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? map.numberOfClasses() - i - 1 : i
            const fillColor = map.classToFillStyle()(ecl, map.numberOfClasses_)
            const itemContainer = container.append('g').attr('class', 'em-legend-item')

            // shift legend items down after point of divergence if applicable
            if (out.pointOfDivergenceLabel && i >= out.pointOfDivergence) y += out.pointOfDivergencePadding

            // Append rectangle
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).raise()
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append labels
            itemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                .attr('y', y + out.shapeHeight / 2)
                .attr('dy', '0.35em')
                .text(out.labels ? out.labels[i] : labelFormatter(map.classifier().invertExtent(ecl)[out.ascending ? 0 : 1], i))
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const noDataItemContainer = container.append('g').attr('class', 'em-legend-item')
            let y = baseY + map.numberOfClasses() * out.shapeHeight + out.boxPadding
            //if (out.pointOfDivergence) y += out.pointOfDivergencePadding // shift legend items down after point of divergence
            noDataItemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).raise()
                    highlightRegions(map, 'nd')
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(map)
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, unhighlightRegions)
                    }
                })

            noDataItemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dy', '0.35em')
                .text(out.noDataText)
        }
    }

    function drawDivergingLine(y) {
        const container = out.lgg.append('g').attr('class', 'em-legend-divergence-container')
        const markerHeight = 6
        const x = out.boxPadding
        if (out.labelType == 'ranges') y = y + out.pointOfDivergencePadding / 2 // move to the middle of the space between legend item
        let maxLabelLength = out.lgg
            .selectAll('.em-legend-label')
            .nodes()
            .reduce((max, node) => Math.max(max, node.getBBox().width), 0)
        const lineLength = out.divergingLineLength || maxLabelLength + out.boxPadding + out.shapeWidth + 10 // + padding

        // Draw the horizontal divergence line
        container
            .append('line')
            .attr('x1', x)
            .attr('y1', y)
            .attr('x2', x + lineLength)
            .attr('y2', y)
            .attr('class', 'em-legend-diverging-line')

        // divergence line with up and down arrows
        const labels = out.pointOfDivergenceLabel.split('|')
        if (labels.length > 1) {
            const directionLineLength = out.divergingArrowLength || 30
            const directionLineX = x + lineLength
            // Add arrowhead marker definition
            const defs = container.append('defs')
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('markerWidth', markerHeight)
                .attr('markerHeight', markerHeight)
                .attr('refX', 0)
                .attr('refY', markerHeight / 2)
                .attr('orient', 'auto')
                .append('polygon')
                .attr('points', `0 0, ${markerHeight} ${markerHeight / 2}, 0 ${markerHeight}`)
                .attr('fill', 'black')

            // Upward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y - directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Downward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y + directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Labels for upward and downward lines
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y - directionLineLength + 10)
                .attr('dy', '0.35em')
                .text(labels[0])

            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y + directionLineLength - 10)
                .attr('dy', '0.35em')
                .text(labels[1])
        } else {
            // just the single label
            container
                .append('text')
                .attr('class', 'em-legend-diverging-label em-legend-label')
                .attr('x', x + lineLength + 5)
                .attr('y', y)
                .attr('dy', '0.35em')
                .text(out.pointOfDivergenceLabel)
        }

        //move threshold label out of the way of the line
        if (out.labelType == 'thresholds') {
            if (labels.length > 1) {
                // move it to end of line
                out.lgg.selectAll('.em-legend-label-divergence').attr('x', x + lineLength + 10)
                // Append tick line
                // container
                //     .append('line')
                //     .attr('class', 'em-legend-tick')
                //     .attr('x1', x + lineLength)
                //     .attr('y1', y)
                //     .attr('x2', x + lineLength + 5)
                //     .attr('y2', y)
            } else {
                //remove it so it doesnt clash with pointOfDivergenceLabel
                out.lgg.selectAll('.em-legend-label-divergence').remove()
            }
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).attr('fill___'))
        })
    }

    //deprecated
    out.labelDecNb = (v) => (console.warn('labelDecNb is now DEPRECATED. Please use decimals instead.'), out)

    return out
}


/***/ }),

/***/ "./src/legend/legend-flow.js":
/*!***********************************!*\
  !*** ./src/legend/legend-flow.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");





//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const lgg = out.lgg

        // update legend parameters if necessary
        if (m.legend_)
            for (let key in m.legend_) {
                if (key == 'colorLegend' || key == 'sizeLegend') {
                    for (let p in out[key]) {
                        //override each property in size and color legend m.legend_
                        if (m.legend_[key][p] !== undefined) {
                            out[key][p] = m.legend_[key][p]
                        }
                    }
                } else {
                    out[key] = m.legend_[key]
                }
            }

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        buildFlowLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different flow symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildFlowLegend(m) {}

    return out
}


/***/ }),

/***/ "./src/legend/legend-histogram.js":
/*!****************************************!*\
  !*** ./src/legend/legend-histogram.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createHistogramLegend: () => (/* binding */ createHistogramLegend)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/band.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");






const createHistogramLegend = (legend, thresholds, colors, data, labelFormatter, highlightRegions, unhighlightRegions) => {
    const orientation = legend.histogram.orientation || 'horizontal'
    const showCounts = legend.histogram.showCounts
    const showPercentages = legend.histogram.showPercentages
    const labelRotation = legend.histogram.labelRotation || 0
    const margin = legend.histogram.margin || { top: 0, right: 0, bottom: 0, left: 0 }
    const height = legend.histogram.height || 200
    const width = legend.histogram.width || 270

    let counts = new Array(map.numberOfClasses_).fill(0)
    data.forEach((value) => {
        const classIndex = map.classifier()(value)
        if (typeof classIndex === 'number' && classIndex >= 0 && classIndex < counts.length) {
            counts[classIndex]++
        }
    })

    const reversedCounts = counts.slice().reverse()
    const total = counts.reduce((sum, d) => sum + d, 0)
    const reversedPercentages = reversedCounts.map((d) => (total > 0 ? (d / total) * 100 : 0))
    const baseY = legend.boxPadding + (legend.title ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-title') + 10 : 30)
    const barGroup = legend.lgg.append('g').attr('class', 'em-legend-histogram').attr('transform', `translate(0, ${baseY})`)

    if (orientation === 'vertical') {
        drawVerticalHistogram(barGroup)
    } else {
        drawHorizontalHistogram(barGroup)
    }

    function drawVerticalHistogram(barGroup) {
        const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__["default"])()
            .domain(reversedCounts.map((_, i) => i))
            .range([margin.top, height - margin.bottom])
            .padding(0.1)
        const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_2__["default"])()
            .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_3__["default"])(reversedCounts)])
            .nice()
            .range([margin.left, width - margin.right])

        // Bars
        barGroup
            .selectAll('rect')
            .data(reversedCounts)
            .join('rect')
            .attr('class', 'em-legend-histogram-bar')
            .attr('y', (_, i) => yScale(i))
            .attr('x', margin.left)
            .attr('height', yScale.bandwidth())
            .attr('width', (d) => xScale(d) - margin.left)
            .attr('fill', (_, i) => colors[colors.length - i - 1])
            .attr('ecl', (_, i) => i)
            .on('mouseover', handleMouseOver)
            .on('mouseout', handleMouseOut)

        // Bar labels
        if (showCounts || showPercentages) {
            barGroup
                .selectAll('text.em-histogram-label')
                .data(reversedCounts)
                .join('text')
                .attr('class', 'em-legend-label em-histogram-label')
                .attr('x', (d) => xScale(d) + 5)
                .attr('y', (_, i) => yScale(i) + yScale.bandwidth() / 2)
                .attr('alignment-baseline', 'middle')
                .text((_, i) => {
                    return showPercentages ? `${reversedPercentages[i].toFixed(1)}%` : reversedCounts[i]
                })
        }

        // Axis
        const axisGroup = barGroup.append('g').attr('id', 'em-legend-histogram-y-axis').attr('transform', `translate(${margin.left}, 0)`)

        axisGroup.call(
            (0,d3_axis__WEBPACK_IMPORTED_MODULE_4__.axisLeft)(yScale)
                .tickSizeOuter(0)
                .tickSize(0)
                .tickFormat((_, i) => (labelFormatter ? labelFormatter(thresholds[i], i) : thresholds[i]))
        )

        axisGroup.selectAll('text').attr('class', 'em-legend-label em-tick-label').attr('text-anchor', 'end')
        //.attr('transform', `rotate(-${labelRotation})`)
    }

    function drawHorizontalHistogram(barGroup) {
        const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__["default"])()
            .domain(reversedCounts.map((_, i) => i))
            .range([margin.left, width - margin.right])
            .padding(0.1)

        const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_2__["default"])()
            .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_3__["default"])(reversedCounts)])
            .nice()
            .range([height - margin.bottom, margin.top])

        // Bars
        barGroup
            .selectAll('rect')
            .data(reversedCounts)
            .join('rect')
            .attr('class', 'em-legend-histogram-bar')
            .attr('x', (_, i) => xScale(i))
            .attr('y', (d) => yScale(d))
            .attr('width', xScale.bandwidth())
            .attr('height', (d) => height - margin.bottom - yScale(d))
            .attr('fill', (_, i) => colors[colors.length - i - 1])
            .attr('ecl', (_, i) => i)
            .on('mouseover', handleMouseOver)
            .on('mouseout', handleMouseOut)

        // Bar labels (centered)
        if (showCounts || showPercentages) {
            barGroup
                .selectAll('text.em-histogram-label')
                .data(reversedCounts)
                .join('text')
                .attr('class', 'em-legend-label em-histogram-label')
                .attr('x', (_, i) => xScale(i) + xScale.bandwidth() / 2)
                .attr('y', (d) => yScale(d) - 5)
                .attr('text-anchor', 'middle')
                .text((_, i) => {
                    return showPercentages ? `${reversedPercentages[i].toFixed(1)}%` : reversedCounts[i]
                })
        }

        // Axis (only for labelType === 'thresholds')
        const axisGroup = barGroup
            .append('g')
            .attr('id', 'em-legend-histogram-x-axis')
            .attr('transform', `translate(0, ${height - margin.bottom})`)

        if (legend.labelType === 'thresholds') {
            const positions = []

            for (let i = 0; i < thresholds.length; i++) {
                const bandIndex = thresholds.length - i - 1
                const x = xScale(bandIndex)
                if (x !== undefined) positions.push(x + xScale.bandwidth())
            }

            const boundaryScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_2__["default"])().domain([0, width]).range([0, width])
            axisGroup.call(
                (0,d3_axis__WEBPACK_IMPORTED_MODULE_4__.axisBottom)(boundaryScale)
                    .tickValues(positions)
                    .tickFormat((_, i) => (labelFormatter ? labelFormatter(thresholds[i], i) : thresholds[i]))
                    .tickSize(0)
                    .tickSizeOuter(0)
            )
        } else if (legend.labelType === 'ranges') {
            axisGroup.call(
                (0,d3_axis__WEBPACK_IMPORTED_MODULE_4__.axisBottom)(xScale)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickFormat((_, i) => (labelFormatter ? labelFormatter(thresholds[i], i) : thresholds[i]))
            )
        }

        axisGroup
            .selectAll('text')
            .attr('class', 'em-legend-label em-tick-label')
            .attr('text-anchor', 'end')
            .attr('transform', `rotate(-${labelRotation})`)
    }

    function handleMouseOver(_, i) {
        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('stroke', 'black')
        const ecl = sel.attr('ecl')
        const reversedIndex = colors.length - 1 - parseInt(ecl, 10)
        highlightRegions(map, reversedIndex)
        if (map.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.executeForAllInsets)(map.insetTemplates_, map.svgId, highlightRegions, ecl)
        }
    }

    function handleMouseOut(_, i) {
        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('stroke', 'none')
        unhighlightRegions(map)
        if (map.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.executeForAllInsets)(map.insetTemplates_, map.svgId, unhighlightRegions)
        }
    }
}


/***/ }),

/***/ "./src/legend/legend-pattern-fill.js":
/*!*******************************************!*\
  !*** ./src/legend/legend-pattern-fill.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendPatternFillLegend: () => (/* binding */ appendPatternFillLegend)
/* harmony export */ });
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



function appendPatternFillLegend(map, container, options = {}) {
    const {
        shapeWidth = 25,
        shapeHeight = 20,
        labelOffset = 3,
        boxPadding = 5,
        offsetY = 0, // << new
    } = options

    if (!map.patternFill_) return

    map.patternFill_.forEach((cfg, index) => {
        if (!cfg.legendLabel) return // skip if no label

        const y = offsetY + index * (shapeHeight + boxPadding)

        const item = container.append('g').attr('class', 'em-legend-item pattern-fill-legend')

        const patternColor = cfg.color || '#000' // fallback to black if no color provided
        const isWhitePattern = patternColor.toLowerCase() === '#fff' || patternColor.toLowerCase() === 'white'

        // Add background if pattern is white
        if (isWhitePattern) {
            item.append('rect').attr('x', boxPadding).attr('y', y).attr('width', shapeWidth).attr('height', shapeHeight).attr('fill', '#ddd') // light gray background
        }

        // Add pattern overlay
        item.append('rect')
            .attr('x', boxPadding)
            .attr('y', y)
            .attr('width', shapeWidth)
            .attr('height', shapeHeight)
            .attr('fill', `url(#${cfg.patternId || cfg.pattern})`)

        // Add label
        item.append('text')
            .attr('class', 'em-legend-label')
            .attr('x', boxPadding + shapeWidth + labelOffset)
            .attr('y', y + shapeHeight / 2)
            .attr('dominant-baseline', 'middle')
            .attr('dy', '0.35em') // ~vertical centering
            .text(cfg.legendLabel)
    })
}


/***/ }),

/***/ "./src/legend/legend-piecharts.js":
/*!****************************************!*\
  !*** ./src/legend/legend-piecharts.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");






/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //spacing between color & size legends (if applicable)
    out.legendSpacing = 15

    //size legend config (legend illustrating the values of different pie sizes)
    out.sizeLegend = {
        title: null,
        titlePadding: 30, //padding between title and body
        values: null,
    }

    //colour legend config (legend illustrating the values of different pie colours)
    out.colorLegend = {
        title: null,
        labelOffset: 5, //the distance between the legend box elements to the corresponding text label
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 5, //the distance between consecutive legend box elements
        noData: true, //show no data
        noDataText: 'No data', //no data label text
    }

    out._sizeLegendHeight = 0

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const map = out.map
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        // legend for sizes
        if (map.sizeClassifier_) {
            buildSizeLegend()
        }

        // legend for ps color values
        buildColorLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different pie chart sizes
     *
     * @param {*} m map
     * @param {*} lgg parent legend object from core/legend.js
     * @param {*} config size legend config object (sizeLegend object specified as property of legend() config object)
     */
    function buildSizeLegend() {
        const map = out.map
        const config = out.sizeLegend
        const container = out.lgg.append('g').attr('class', 'em-pie-size-legend')

        const domain = map.sizeClassifier_.domain()

        // Assign default circle radii if none specified by user
        if (!config.values) {
            config.values = [Math.floor(domain[1]), Math.floor(domain[0])]
        }

        // Calculate the maximum circle size to be displayed in the legend
        let maxSize = map.sizeClassifier_((0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(config.values))

        // Add the title to the container if available
        if (!config.title && out.title) config.title = out.title // Allow root legend title
        let titleHeight = 0 // This will be adjusted based on whether the title exists
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Position the title at the left edge
                .attr('y', out.boxPadding + out.titleFontSize) // Title at top, within padding
                .text(config.title)

            // Adjust title height (using the title font size as a proxy)
            titleHeight = out.titleFontSize + out.boxPadding + config.titlePadding
        }

        // Now position the circles **below** the title
        let y = titleHeight + out.boxPadding + maxSize * 2 // Position circles after title height

        // Append the legend circles
        const legendItems = container
            .selectAll('g')
            .data(config.values)
            .join('g')
            .attr('class', 'em-pie-size-legend-item')
            .attr('transform', `translate(${maxSize + out.boxPadding}, ${y})`) // Dynamically move the circles down

        // Append circles to each group
        legendItems
            .append('circle')
            .attr('class', 'em-pie-size-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -map.sizeClassifier_(d)) // Position circles based on their size
            .attr('r', map.sizeClassifier_) // Radius is calculated from size classifier

        // Append labels to each group
        legendItems
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('y', (d) => -2 * map.sizeClassifier_(d) - out.labelFontSize - 2) // Position labels relative to circles
            .attr('x', 30) // Set the x-position for the labels
            .attr('dy', '1.2em')
            .attr('xml:space', 'preserve')
            .text((d) => d.toLocaleString('en').replace(/,/gi, ' ')) // Format the label text

        // Add lines pointing to the top of the corresponding circle
        legendItems
            .append('line')
            .attr('class', 'em-pie-size-legend-line')
            .attr('x1', 2)
            .attr('x2', 30)
            .attr('y1', (d) => -2 * map.sizeClassifier_(d)) // Position lines relative to circles
            .attr('y2', (d) => -2 * map.sizeClassifier_(d)) // Same position for the y2 to make a horizontal line

        // Save the height value for positioning the color legend (if needed)
        out._sizeLegendHeight = y
        return out
    }

    /**
     * Builds a legend illustrating the statistical values of the pie charts' different colours
     *
     */
    function buildColorLegend() {
        const map = out.map
        const config = out.colorLegend
        //container
        const container = out.lgg.append('g').attr('class', 'em-pie-color-legend')

        //draw title
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out._sizeLegendHeight + out.legendSpacing + out.boxPadding + out.titleFontSize)
                .text(config.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = map.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)
            //the color
            const col = map.catColors()[code] || 'lightgray'

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, code)
                    }
                })

            //label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .attr('dominant-baseline', 'middle')
                .text(map.catLabels()[code] || code)

            i++
        }

        //'no data' legend box
        if (config.noData) {
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', map.noDataFillStyle())
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                    }
                })

            //'no data' label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .text(config.noDataText)
        }
    }

    // Highlight selected segments on mouseover
    function highlightRegions(map, code) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Set all segments to white
        allSegments.style('fill', 'white')

        // Highlight only the selected segments by restoring their original color
        const selectedSegments = allSegments.filter("path[code='" + code + "']")
        selectedSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected segments
        })
    }

    // Reset all segments to their original colors on mouseout
    function unhighlightRegions(map) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Restore each segments's original color from the fill___ attribute
        allSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-proportional-symbols.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-proportional-symbols.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");










//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_4__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    out.ascending = false //the order of the legend elements. Set to false to invert.
    out.legendSpacing = 35 //spacing between color & size legends (if applicable)
    out.labelFontSize = 12 //the font size of the legend labels

    out.noDataShapeWidth = 25
    out.noDataShapeHeight = 20

    //size legend config (legend illustrating the values of different symbol sizes)
    out.sizeLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 5, //padding between title and legend body
        values: undefined, //manually define raw data values
        cellNb: 3, //number of elements in the legend
        shapePadding: 5, //the y distance between consecutive legend shape elements
        shapeOffset: { x: 0, y: 0 },
        shapeFill: 'white',
        shapeStroke: null,
        labelOffset: { x: 10, y: 0 }, //the distance between the legend box elements to the corresponding text label
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined,
        _totalBarsHeight: 0,
        _totalD3SymbolsHeight: 0,
        noData: false, // show no data legend item
        noDataText: 'No data', //no data text label
    }

    // color legend config (legend illustrating the data-driven colour classes)
    out.colorLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 10, //padding between title and legend body
        marginTop: 30, // margin top (distance between color and size legend)
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 1, //the distance between consecutive legend shape elements in the color legend
        labelOffset: { x: 5, y: 0 }, //distance (x) between label text and its corresponding shape element
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined, // user-defined d3 format function
        labelType: 'thresholds', // type of labels to show: thresholds or ranges
        labels: null, // user-defined labels for each class
        noData: true, //show no data
        noDataText: 'No data', //no data text label
        sepLineLength: 24, // //the separation line length
        sepLineStroke: 'black', //the separation line color
        sepLineStrokeWidth: 1, //the separation line width
        tickLength: 5, // threshold ticks length in px
    }

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const m = out.map
            const lgg = out.lgg

            //remove previous content
            lgg.selectAll('*').remove()

            //draw legend background box
            out.makeBackgroundBox()

            // reset height counters
            out.sizeLegend._totalBarsHeight = 0
            out.sizeLegend._totalD3SymbolsHeight = 0

            // legend for size
            out._sizeLegendNode = lgg.append('g').attr('class', 'size-legend-container')
            if (m.classifierSize_) {
                buildSizeLegend(m, out.sizeLegend)
            }
            // legend for ps color values
            out._colorLegendNode = lgg.append('g').attr('class', 'color-legend-container')

            // position it below size legend
            if (out._sizeLegendNode) {
                out._colorLegendNode.attr('transform', `translate(0,${out._sizeLegendNode.node().getBBox().height})`)
            }

            if (m.classifierColor_ && out.colorLegend) {
                buildColorLegend(m, out.colorLegend)
            }

            // Append pattern fill legend items BELOW the main legend
            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_3__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    /**
     * Builds a legend which illustrates the statistical values of different symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildSizeLegend(m) {
        if (!m.psCustomSVG_ && m.psShape_ == 'circle') {
            buildCircleLegend(m, out.sizeLegend)
            if (out.sizeLegend.noData) {
                let y = out._sizeLegendNode.node().getBBox().height + 25
                let x = out.boxPadding
                let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)
                buildNoDataLegend(container, out.sizeLegend.noDataText)
            }
            return
        } else if (m.psShape_ == 'spike') {
            buildSpikeLegend(m, out.sizeLegend)
            return
        }

        //define format for labels
        let labelFormatter = out.sizeLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        //draw title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let domain = m.classifierSize_.domain()
        let maxVal = domain[1] //maximum value of dataset (used for first or last symbol by default)

        // if user defines values for legend manually
        if (out.sizeLegend.values) {
            out.sizeLegend.cellNb = out.sizeLegend.values.length
        }

        //draw legend elements for classes: symbol + label

        // for custom paths
        m.customSymbols = { nodeHeights: 0 } // save some custom settings for buildCustomSVGItem

        for (let i = 1; i < out.sizeLegend.cellNb + 1; i++) {
            //define class number
            const c = out.ascending ? out.sizeLegend.cellNb - i + 1 : i
            //define raw value
            let val = out.sizeLegend.values ? out.sizeLegend.values[c - 1] : maxVal / c
            //calculate shape size
            let symbolSize = m.classifierSize_(val)

            if (m.psShape_ == 'bar') {
                buildBarsItem(map, val, symbolSize, i, labelFormatter)
            } else if (m.psShape_ == 'custom' || m.psCustomSVG_) {
                buildCustomSVGItem(map, val, symbolSize, i, labelFormatter)
            } else {
                buildD3SymbolItem(map, val, symbolSize, i, labelFormatter)
            }
        }

        if (out.sizeLegend.noData) {
            let y = out._sizeLegendNode.node().getBBox().height
            if (out.colorLegend) {
                y += out.colorLegend.shapeHeight + 5
            }
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    function buildSpikeLegend(map, sizeLegendConfig) {
        const spike = (length, width = map.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`

        let maxSize = map.classifierSize_(map.classifierSize_.domain()[1])

        // Determine values for the legend
        let legendValues = out.sizeLegend.values || map.classifierSize_.ticks(4).slice(1) // Use user-defined values or default ticks

        const fontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-label') // Adjust font size
        const labelSpacing = fontSize - 2 // Ensure labels are just below the spikes

        const legend = out._sizeLegendNode
            .append('g')
            .attr('id', 'em-spike-legend')
            .attr('transform', `translate(${out.boxPadding + 5},0)`)
            .attr('fill', 'black')
            .attr('text-anchor', 'middle')
            .style('font-size', `${fontSize}px`)
            .selectAll()
            .data(legendValues) // Now uses user-defined values if provided
            .join('g')
            .attr('transform', (d, i) => `translate(${40 * i + out.boxPadding},${maxSize + 5})`) // Increase spacing

        // Append spikes
        legend
            .append('path')
            .attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)
            .attr('d', (d) => spike(map.classifierSize_(d))) // Correctly maps values to spike size

        // Append labels directly below each spike
        legend
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', labelSpacing) // Ensure text is right below spikes
            .text((d) => map.classifierSize_.tickFormat(4, 's')(d))

        // 🔹 Add "No Data" item with more spacing
        if (out.sizeLegend.noData) {
            let lastLabelY = maxSize + labelSpacing + fontSize + 5 // Adjust position below the labels
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${lastLabelY})`)
            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    //'no data' legend box
    function buildNoDataLegend(container, noDataText) {
        let m = out.map

        //append symbol & style
        container
            .append('rect')
            .attr('class', 'em-legend-rect')
            .style('fill', m.noDataFillStyle())
            .attr('width', out.colorLegend ? out.colorLegend.shapeWidth : out.noDataShapeWidth)
            .attr('height', out.colorLegend ? out.colorLegend.shapeHeight : out.noDataShapeHeight)
            .on('mouseover', function () {
                highlightRegions(out.map, 'nd')
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                }
            })
            .on('mouseout', function () {
                unhighlightRegions(out.map)
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                }
            })

        //'no data' label
        container
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', out.colorLegend ? out.colorLegend.shapeWidth + out.colorLegend.labelOffset.x : out.noDataShapeWidth + 5)
            .attr('y', out.colorLegend ? out.colorLegend.shapeHeight / 2 : out.noDataShapeHeight / 2)
            .text(noDataText)
    }

    function highlightRegions(map, ecl) {
        // TODO: change this to estat logic of making all other classes transparent?
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', map.hoverColor())
        sel.attr('fill___', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('fill')
        })
    }

    function unhighlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).attr('fill___')
        })
    }

    /**
     * @description builds a size legend item for proportional D3 shapes (e.g. square, triangle, star)
     * @param {*} m map instance
     * @param {number} symbolSize the size of the symbol item
     */
    function buildD3SymbolItem(m, value, symbolSize, index, labelFormatter) {
        let symbolHeight = out.map.psShape_ == 'triangle' || out.map.psShape_ == 'diamond' ? symbolSize : symbolSize / 2
        if (out.sizeLegend._totalD3SymbolsHeight == 0) out.sizeLegend._totalD3SymbolsHeight += symbolHeight + out.boxPadding //add first item height to y
        let maxSize = m.classifierSize_(m.classifierSize_.domain()[1])
        // x and y position of item in legend
        let x = maxSize
        let y =
            (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) +
            out.sizeLegend._totalD3SymbolsHeight +
            (out.sizeLegend.shapePadding * index - 1)

        out.sizeLegend._totalD3SymbolsHeight += symbolSize

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw D3 symbol
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()
        itemContainer
            .append('g')
            // .attr('transform', `translate(${x},${y})`)
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = maxSize / 2 + out.sizeLegend.labelOffset.x + out.boxPadding

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', 0)
            .text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} value
     * @param {*} symbolSize
     * @param {*} index
     * @param {*} labelFormatter
     */
    function buildCustomSVGItem(m, value, symbolSize, index, labelFormatter) {
        let x = out.boxPadding //set X offset
        let y

        //first item
        if (!m.customSymbols.prevSymb) {
            y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20
            m.customSymbols.initialTranslateY = y
            m.customSymbols.prevScale = symbolSize
        }

        //following items
        if (m.customSymbols.prevSymb) {
            let prevNode = m.customSymbols.prevSymb.node()
            let bbox = prevNode.getBBox()
            m.customSymbols.nodeHeights = m.customSymbols.nodeHeights + bbox.height * m.customSymbols.prevScale
            y = m.customSymbols.initialTranslateY + m.customSymbols.nodeHeights + out.sizeLegend.shapePadding * (index - 1)
            m.customSymbols.prevScale = symbolSize
        }

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw standard symbol
        m.customSymbols.prevSymb = itemContainer
            .append('g')
            .attr('class', 'em-size-legend-symbol')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('g')
            .html(out.map.psCustomSVG_)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = x + m.classifierSize_(m.classifierSize_.domain()[0]) + out.sizeLegend.labelOffset.x
        let labelY = out.sizeLegend.shapeOffset.y / 2 + 1 //y + out.sizeLegend.labelOffset.y

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', labelY)
            .text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} symbolSize
     */
    function buildBarsItem(m, value, symbolSize, index, labelFormatter) {
        // for vertical bars we dont use a dynamic X offset because all bars have the same width
        let x = out.boxPadding
        //we also dont need the y offset
        let y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + out.sizeLegend._totalBarsHeight + 10

        out.sizeLegend._totalBarsHeight += symbolSize + 10

        //set shape size and define 'd' attribute
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw bar symbol
        itemContainer
            .append('g')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })
        //label position
        let labelX = x + out.map.psBarWidth_ + out.sizeLegend.labelOffset.x
        let labelY = symbolSize / 2 + out.sizeLegend.labelOffset.y

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', labelY)
            .text(labelFormatter(value))
    }

    /**
     * @description builds a nested circle legend for proportional circles
     * @param {*} m map
     */
    function buildCircleLegend(m) {
        //assign default circle radiuses if none specified by user
        let domain = m.classifierSize_.domain()
        if (!out.sizeLegend.values) {
            // default legend values
            out._sizeLegendValues = [Math.floor(domain[1]), Math.floor(domain[1] / 2), Math.floor(domain[0])]
        } else {
            // user defined legend values
            out._sizeLegendValues = out.sizeLegend.values
        }

        //draw title
        if (!out.sizeLegend.title && out.title) out.sizeLegend.title = out.title //if unspecified, set size legend title as root legend title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let maxRadius = m.classifierSize_((0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])(out._sizeLegendValues)) //maximum circle radius to be shown in legend
        let x = out.boxPadding + maxRadius
        let y = out.boxPadding + maxRadius * 2 + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20

        let itemContainer = out._sizeLegendNode
            .append('g')
            .attr('transform', `translate(${x},${y})`)
            .attr('class', 'circle-legend')
            .attr('text-anchor', 'right')
            .style('fill', 'black')
            .selectAll('g')
            .data(out._sizeLegendValues.filter((d) => m.classifierSize_(d))) // Filter data before binding
            .join('g')
            .attr('class', 'em-legend-item')

        //circles
        itemContainer
            .append('circle')
            .attr('class', 'em-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -m.classifierSize_(d))
            .attr('r', m.classifierSize_)

        //labels
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('y', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x', maxRadius + 5)
            .text((d) => {
                return d.toLocaleString('en').replace(/,/gi, ' ')
            })
        //line pointing to top of corresponding circle:
        itemContainer
            .append('line')
            .style('stroke-dasharray', 2)
            .style('stroke', 'grey')
            .attr('x1', 2)
            .attr('y1', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x2', maxRadius + 5)
            .attr('y2', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })

        return out
    }

    /**
     * Builds a legend illustrating the statistical values of different symbol colours
     *
     * @param {*} m map
     */
    function buildColorLegend(m) {
        if (out.colorLegend.labelType === 'ranges') {
            buildColorRangesLegend(m)
        } else {
            buildColorThresholdsLegend(m)
        }
    }

    function getColorThresholds() {
        const map = out.map
        const thresholds =
            map.psThresholds_.length > 1
                ? map.psThresholds_
                : Array.from({ length: map.psClasses_ })
                      .map((_, index) => {
                          return map.classifierColor_.invertExtent(index)[out.ascending ? 0 : 1]
                      })
                      .slice(1) // Remove the first entry and return the rest as an array
        return thresholds
    }

    function buildColorRangesLegend(m) {
        const f = out.colorLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        const thresholds = getColorThresholds()
        const numberOfClasses = m.psClasses_

        //title
        if (out.colorLegend.title) {
            out._colorLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.titleFontSize + out.colorLegend.marginTop)
                .text(out.colorLegend.title)
        }

        const x = out.boxPadding

        for (let i = 0; i < numberOfClasses; i++) {
            let y =
                out.titleFontSize +
                out.colorLegend.titlePadding +
                out.colorLegend.marginTop +
                i * (out.colorLegend.shapeHeight + out.colorLegend.shapePadding)

            const ecl = out.ascending ? i : numberOfClasses - i - 1

            const itemContainer = out._colorLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-legend-item')

            // Rectangle
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .style('fill', m.psClassToFillStyle()(ecl, numberOfClasses))
                .attr('width', out.colorLegend.shapeWidth)
                .attr('height', out.colorLegend.shapeHeight)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            // Label
            itemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('dy', '0.35em') // ~vertical centering
                .attr('x', out.colorLegend.shapeWidth + out.colorLegend.labelOffset.x)
                .attr('y', out.colorLegend.shapeHeight / 2)
                .text(() => {
                    if (out.colorLegend.labels) return out.colorLegend.labels[i] // user-defined labels
                    if (i === 0) return `> ${f(thresholds[thresholds.length - 1])}`
                    if (i === thresholds.length) return `< ${f(thresholds[0])}`
                    return `${f(thresholds[thresholds.length - i - 1])} - < ${f(thresholds[thresholds.length - i])}`
                })
        }

        // Optionally add no-data
        if (out.colorLegend.noData) {
            let y = out.titleFontSize + out.colorLegend.marginTop + numberOfClasses * out.colorLegend.shapeHeight + 20 // add 20 to separate it from the rest
            let container = out._colorLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.colorLegend.noDataText)
        }
    }

    function buildColorThresholdsLegend(m) {
        //define format for labels
        const labelFormatter = out.colorLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator

        //title
        if (out.colorLegend.title) {
            out._colorLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.titleFontSize + out.colorLegend.marginTop)
                .text(out.colorLegend.title)
        }

        // x position of color legend cells
        let x = out.boxPadding

        //draw legend elements for classes: rectangle + label
        let numberOfClasses = m.psClasses_

        for (let i = 0; i < numberOfClasses; i++) {
            //the vertical position of the legend element
            let y = out.titleFontSize + out.colorLegend.titlePadding + out.colorLegend.marginTop + i * out.colorLegend.shapeHeight // account for title + margin

            //the class number, depending on order
            const ecl = out.ascending ? i : numberOfClasses - i - 1

            let itemContainer = out._colorLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-legend-item')

            //append symbol & style
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .style('fill', m.psClassToFillStyle()(ecl, numberOfClasses))
                .attr('width', out.colorLegend.shapeWidth)
                .attr('height', out.colorLegend.shapeHeight)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            //separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', 0 + out.colorLegend.sepLineLength)
                    .attr('y2', 0)
            }

            // Append tick line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.colorLegend.shapeWidth)
                    .attr('y1', 0)
                    .attr('x2', out.colorLegend.sepLineLength + out.colorLegend.tickLength)
                    .attr('y2', 0)
            }

            //label
            if (i < numberOfClasses - 1) {
                itemContainer
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('dy', '0.35em') // ~vertical centering
                    .attr('x', out.colorLegend.sepLineLength + out.colorLegend.tickLength + out.colorLegend.labelOffset.x)
                    .attr('y', out.colorLegend.shapeHeight)
                    .text(
                        out.colorLegend.labels
                            ? out.colorLegend.labels[i]
                            : labelFormatter(m.classifierColor_.invertExtent(out.ascending ? ecl + 1 : ecl - 1)[out.ascending ? 0 : 1])
                    )
            }
        }

        //'no data' legend box
        if (out.colorLegend.noData) {
            let y = out.titleFontSize + out.colorLegend.marginTop + numberOfClasses * out.colorLegend.shapeHeight + 20 // add 20 to separate it from the rest
            let container = out._colorLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.colorLegend.noDataText)
        }
    }

    /**
     * @description returns the d3.symbol object chosen by the user
     * @return {d3.shape || SVG}
     */
    function getShape() {
        let shape
        if (out.map.psCustomSVG_) {
            shape = out.map.psCustomSVG_
        } else if (out.map.psCustomShape_) {
            shape = out.map.psCustomShape_
        } else if (out.map.psShape_ == 'bar') {
            //for rectangles, we use a custom d3 symbol
            let drawRectangle = (context, size) => {
                let height = Math.sqrt(size)
                context.moveTo(0, 0)
                context.lineTo(0, height)
                context.lineTo(out.map.psBarWidth_, height)
                context.lineTo(out.map.psBarWidth_, 0)
                context.lineTo(0, 0)
                context.closePath()
            }
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])().type({ draw: drawRectangle })
        } else {
            let symbolType = _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary[out.map.psShape_] || _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary['circle']
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])().type(symbolType)
        }
        return shape
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Set all symbols to white
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this.childNodes[0])
            symbol.style('fill', 'white')
        })

        // Highlight only the selected regions by restoring their original color
        const selectedSymbols = allSymbols.filter("[ecl='" + ecl + "']")
        selectedSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-stripe-composition.js":
/*!*************************************************!*\
  !*** ./src/legend/legend-stripe-composition.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const svgMap = m.svg()
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        //draw title
        if (out.title) {
            lgg.append('text')
                .attr('class', 'em-legnd-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = m.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //the color
            const col = m.catColors()[code] || 'lightgray'

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this)
                    sel.raise()
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            //label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(m.catLabels()[code] || code)
                .on('mouseover', function () {
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const col = m.catColors()[code] || 'lightgray'
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', col)
                })

            i++
        }

        //'no data' legend box
        if (out.noData) {
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', m.noDataFillStyle())
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.noDataFillStyle())
                })

            //'no data' label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(out.noDataText)
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                })
        }

        //set legend box dimensions
        out.setBoxDimension()
    }

    function highlightRegions(map, code) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Save original colors if not already stored
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            if (!el.attr('data-original-fill')) {
                el.attr('data-original-fill', el.style('fill'));
            }
            el.style('fill', 'white'); // Set all regions to white
        });
    
        // Highlight only the selected regions by restoring their original color
        const selectedRegions = map.svg_.selectAll("pattern").selectAll("rect[code='" + code + "']");
        selectedRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            el.style('fill', el.attr('data-original-fill')); // Restore original fill
        });
    }
    
    function unhighlightRegions(map) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Restore each region's original color from the stored attribute
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            const originalFill = el.attr('data-original-fill');
            if (originalFill) {
                el.style('fill', originalFill);
            }
        });
    }
    
    return out
}


/***/ }),

/***/ "./src/legend/legend.js":
/*!******************************!*\
  !*** ./src/legend/legend.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



/**
 * A eurostat-map legend. This is an abstract method.
 */
const legend = function (map) {
    //build legend object
    const out = {}

    //link map to legend
    out.map = map

    //the SVG where to make the legend
    out.svgId = 'legend_' + Math.round(10e15 * Math.random())
    out.svg = undefined
    out.lgg = undefined

    //the legend element position, in case it is embeded within the map SVG
    out.x = undefined
    out.y = undefined

    //the legend box
    out.boxPadding = 7
    out.boxOpacity = 0.7

    //legend title
    out.title = ''
    // we now use CSS instead of inline styles
    out.titleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-title')
    // we now use CSS instead of inline styles
    out.labelFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-label')

    /** Build legend. */
    out.build = function () {
        //set SVG element and add main drawing group
        out.svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId)
        // clear previous legend(s)
        out.svg.selectAll('#em-legend-' + out.svgId).remove()
        // append new legend group
        out.lgg = out.svg
            .append('g')
            .attr('id', 'em-legend-' + out.svgId)
            .attr('class', 'em-legend')
    }

    /**
     * Update the legend element.
     * This is an abstract method to be defined for each specific legend.
     */
    out.update = function () {
        console.log('Legend update function not implemented')
        return out
    }

    out.updateContainer = function () {
        const map = out.map
        const container = out.lgg
        // Remove previous content
        container.selectAll('*').remove()

        //check if provided external svgId has changed
        const legendSVG = out.svg
        if (legendSVG.attr('id') !== map.legend_.svgId) {
            out.build() // sets new svg and lgg
        }
    }

    out.updateConfig = function () {
        const map = out.map
        // Update legend parameters if necessary
        if (map.legend_) {
            deepMergeExistingKeys(out, map.legend_)
        }

        //ps
        // // update legend parameters if necessary
        // if (m.legend_)
        //     for (let key in m.legend_) {
        //         if (key == 'colorLegend' || key == 'sizeLegend') {
        //             for (let p in out[key]) {
        //                 //override each property in size and color legend m.legend_
        //                 if (m.legend_[key][p] !== undefined) {
        //                     out[key][p] = m.legend_[key][p]
        //                 }
        //             }
        //         } else {
        //             out[key] = m.legend_[key]
        //         }
        //     }
    }

    //It performs a shallow copy — nested objects will be copied by reference, not duplicated.
    //It modifies the target object (out) in place.
    //Useful for merging objects or extending existing ones.
    function deepMergeExistingKeys(target, source, options = {}, seen = new WeakSet(), depth = 0) {
        const MAX_DEPTH = options.maxDepth || 100

        if (seen.has(target)) return target
        seen.add(target)

        if (depth > MAX_DEPTH) {
            console.warn(`Max recursion depth (${MAX_DEPTH}) reached.`)
            return target
        }

        for (const key in source) {
            if (source.hasOwnProperty(key) && target.hasOwnProperty(key)) {
                const sourceVal = source[key]
                const targetVal = target[key]

                // Handle functions: overwrite directly
                if (typeof sourceVal === 'function') {
                    target[key] = sourceVal

                    // Handle nested plain objects
                } else if (isPlainObject(sourceVal) && isPlainObject(targetVal)) {
                    deepMergeExistingKeys(targetVal, sourceVal, options, seen, depth + 1)

                    // Handle arrays: overwrite (or merge if option set)
                } else if (Array.isArray(sourceVal) && Array.isArray(targetVal)) {
                    target[key] = options.mergeArrays ? [...new Set([...targetVal, ...sourceVal])] : [...sourceVal]

                    // Handle Dates
                } else if (sourceVal instanceof Date) {
                    target[key] = new Date(sourceVal.getTime())

                    // Handle RegExp
                } else if (sourceVal instanceof RegExp) {
                    target[key] = new RegExp(sourceVal)

                    // Handle Map and Set
                } else if (sourceVal instanceof Map) {
                    target[key] = new Map(sourceVal)
                } else if (sourceVal instanceof Set) {
                    target[key] = new Set(sourceVal)

                    // Overwrite primitives and other types
                } else {
                    target[key] = sourceVal
                }
            }
        }

        return target
    }

    // Helper to check for plain objects
    function isPlainObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]'
    }

    /** Draw legend background box */
    out.makeBackgroundBox = function () {
        out.lgg.append('rect').attr('id', 'legendBR').attr('class', 'em-legend-background').style('opacity', out.boxOpacity)
    }

    /** Set legend box dimensions, ensuring it has suitable dimensions to fit to all legend graphic elements */
    out.setBoxDimension = function () {
        if (out.lgg.node()) {
            //get legend elements bounding box
            const bb = out.lgg.node().getBBox({ stroke: true })
            //apply to legend box dimensions
            const p = out.boxPadding
            out.svg
                .select('#legendBR')
                .attr('x', bb.x - p)
                .attr('y', bb.y - p)
                .attr('width', bb.width + 2 * p)
                .attr('height', bb.height + 2 * p)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-categorical.js":
/*!*****************************************!*\
  !*** ./src/maptypes/map-categorical.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-categorical */ "./src/legend/legend-categorical.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");








/**
 * Returns a categorical map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'ct')

    /** Fill style for each category/class. Ex.: { urb: "#fdb462", int: "#ffffb3", rur: "#ccebc5" } */
    out.classToFillStyle_ = undefined
    /** Text label for each category/class. Ex.: { "urb": "Urban", "int": "Intermediate", "rur": "Rural" } */
    out.classToText_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunCat

    //the classifier: a function which returns a class number from a stat value.
    out.classifier_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['classToFillStyle_', 'classToText_', 'noDataFillStyle_', 'tooltipText_', 'classifier_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['classToFillStyle', 'classToText', 'noDataFillStyle', 'tooltipText', 'classifier'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //get domain (unique values)
        const domain = out.statData().getUniqueValues()

        //get range [0,1,2,3,...,domain.length-1]
        const range = [...Array(domain.length).keys()]

        //make classifier
        //only use user-define classes
        const ctfs = out.classToFillStyle_ ? out.classToFillStyle() : undefined
        if (ctfs) {
            const categories = Object.keys(ctfs)
            out.classifier(
                (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])()
                    .domain(categories) // Only classify known categories
                    .range(categories.map((_, i) => i)) // Assign numerical classes
            )
        } else {
            // Use all unique values if no user-defined classes exist
            out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])().domain(domain).range(range))
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const sv = out.statData().get(rg.properties.id)
                if (!sv) return

                const v = sv.value
                if (v === ':') return 'nd' // No data

                const value = isNaN(v) ? v : +v // Convert numbers, keep strings as is

                // 🔹 Ensure only known values are classified
                const classifierDomain = out.classifier().domain()
                if (!classifierDomain.includes(value)) return // Skip unknown values

                return out.classifier()(value)
            })
        }

        let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        classifyRegions(map.svg().selectAll(selector))

        // Handle mixed NUTS level, separating NUTS level 0
        if (map.nutsLevel_ === 'mixed') {
            const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
            classifyRegions(nuts0Regions)
        }
    }

    //@override
    out.updateStyle = function () {
        //if no color specified, use some default colors
        if (!out.classToFillStyle()) {
            const ctfs = {}
            const dom = out.classifier().domain()
            for (let i = 0; i < dom.length; i++) ctfs[dom[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__["default"][i % 12]
            out.classToFillStyle(ctfs)
        }

        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)
        return out
    }

    function applyStyleToMap(map) {
        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__.applyPatternFill)(map, out.patternFill_)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .style('display', function (rg) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')
                return ecl || lvl === '0' ? 'block' : 'none'
            })
            .style('stroke', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const stroke = sel.style('stroke')
                return ecl && lvl !== '0' ? stroke || '#777' : null
            })
            .style('stroke-width', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const strokeWidth = sel.style('stroke-width')
                return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle_[out.classifier().domain()[ecl]]
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_[out.classifier().domain()[ecl]]
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle_[out.classifier().domain()[ecl]]
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        // Set up mouse events
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunCat = function (rg, map) {
    const buf = []
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + '</div>')
    }
    //get stat value
    const sv = map.statData().get(rg.properties.id)
    //case when no data available
    if (!sv || (sv.value != 0 && !sv.value)) {
        buf.push(map.noDataText_)
        return buf.join('')
    }
    const val = sv.value
    if (map.classToText_) {
        const lbl = map.classToText_[val]
        //display label and value
        buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${lbl ? lbl : val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
        return buf.join('')
    }
    //display just value
    buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-bivariate.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-choropleth-bivariate.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-bivariate */ "./src/legend/legend-choropleth-bivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a bivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chbi')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#73ae80'
    out.color2_ = '#6c83b5'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined

    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunBiv

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        const setupClassifiers = () => {
            let stat1 = out.statData('v1').getArray()
            let stat2 = out.statData('v2').getArray()

            const range = [...Array(out.numberOfClasses()).keys()]
            if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
            if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))

            //define bivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleBivariate(out.numberOfClasses(), out.startColor(), out.color1(), out.color2(), out.endColor())
                out.classToFillStyle(scale)
            }
        }

        const classifyRegions = (regions) => {
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    if (rg.properties.id.length == 4) console.log(rg)
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('nd', function (rg) {
                    const sv1 = out.statData('v1').get(rg.properties.id)
                    const sv2 = out.statData('v2').get(rg.properties.id)
                    if (!sv1 || !sv2) return
                    let v = sv1.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    v = sv2.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return ''
                })
        }

        // Initialize classifier
        setupClassifiers()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    if (!ecl1 && !ecl2) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    let color = out.classToFillStyle()(+ecl1, +ecl2)
                    return color
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        // Set up mouse events
                        addMouseEventsToRegions(map, regions)

                        // update font color for grid cartograms (contrast)
                        if (out.gridCartogram_) {
                            map.svg()
                                .selectAll('.em-grid-text')
                                .each(function () {
                                    const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.parentNode).style('fill')
                                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                                })
                        }
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                const ecl1 = sel.attr('ecl1')
                const ecl2 = sel.attr('ecl2')
                const lvl = sel.attr('lvl')

                // Determine display visibilitys
                const isVisible = ecl1 || ecl2 || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if ((ecl1 || ecl2) && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.style('fill', map.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const scaleBivariate = function (numberOfClasses, startColor, color1, color2, endColor) {
    //color ramps, by row
    const cs = []
    //interpolate from first and last columns
    const rampS1 = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(startColor, color1)
    const ramp2E = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(color2, endColor)
    for (let i = 0; i < numberOfClasses; i++) {
        const t = i / (numberOfClasses - 1)
        const colFun = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(rampS1(t), ramp2E(t))
        const row = []
        for (let j = 0; j < numberOfClasses; j++) row.push(colFun(j / (numberOfClasses - 1)))
        cs.push(row)
    }
    //TODO compute other matrix based on rows, and average both?

    return function (ecl1, ecl2) {
        return cs[ecl1][ecl2]
    }
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunBiv = function (rg, map) {
    const buf = []
    //region name
    const regionName = rg.properties.na || rg.properties.name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
        ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-trivariate.js":
/*!***************************************************!*\
  !*** ./src/maptypes/map-choropleth-trivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-trivariate */ "./src/legend/legend-choropleth-trivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a trivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chtri')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#09F8FF'
    out.color2_ = '#F5D300'
    out.color3_ = '#FF1493'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined
    out.classifier3_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunctionTrivariate

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'color3_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
        'classifier3_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'color3', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        let stat1 = out.statData('v1').getArray()
        let stat2 = out.statData('v2').getArray()
        let stat3 = out.statData('v3').getArray()

        const range = [...Array(7).keys()]
        if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
        if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))
        if (!out.classifier3_) out.classifier3((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat3).range(range))

        //assign class to nuts regions, based on their value
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        if (map.svg_) {
            let regions = map.svg().selectAll(selector)
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('ecl3', function (rg) {
                    const sv = out.statData('v3').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier3_(+v)
                })
                .attr('regionClass', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')

                    if (ecl1 === 'nd' || ecl2 === 'nd' || ecl3 === 'nd') return 'nd' // Handle 'no data'

                    // Combine the classifier results into a single class (1-7)
                    if (ecl1 && !ecl2 && !ecl3) return 1 // only variable 1 present
                    if (!ecl1 && ecl2 && !ecl3) return 2 // only variable 2 present
                    if (!ecl1 && !ecl2 && ecl3) return 3 // only variable 3 present
                    if (ecl1 && ecl2 && !ecl3) return 4 // variables 1 & 2 present
                    if (ecl1 && !ecl2 && ecl3) return 5 // variables 1 & 3 present
                    if (!ecl1 && ecl2 && ecl3) return 6 // variables 2 & 3 present
                    if (ecl1 && ecl2 && ecl3) return 7 // all present
                })
            // .attr('nd', function (rg) {
            //     const sv1 = out.statData('v1').get(rg.properties.id) || out.statData().get(rg.properties.id)
            //     const sv2 = out.statData('v2').get(rg.properties.id)
            //     if (!sv1 || !sv2) return
            //     let v = sv1.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     v = sv2.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     return ''
            // })

            //when mixing NUTS, level 0 is separated from the rest (class nutsrg0)
            if (map.nutsLevel_ == 'mixed') {
                map.svg()
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v1').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }

            //define trivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleTrivariate(out.color1(), out.color2(), out.color3())
                out.classToFillStyle(scale)
            }

            //when mixing NUTS, level 0 is separated from the rest (using class nutsrg0)
            if (out.nutsLevel_ == 'mixed') {
                map.svg_
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }
        }
    }

    const scaleTrivariate = function (color1, color2, color3) {
        // Blending primary colors and their overlaps
        const overlapColors = [
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2]), // Class 4 (Overlap of color1 and color2)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color2, color3]), // Class 5 (Overlap of color2 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color3]), // Class 6 (Overlap of color1 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2, color3]), // Class 7 (Overlap of all three)
        ]

        // Class-to-color mapping
        const classColors = [
            color1, // Class 1 (First color)
            color2, // Class 2 (Second color)
            color3, // Class 3 (Third color)
            overlapColors[0], // Class 4 (Overlap of color1 and color2)
            overlapColors[1], // Class 5 (Overlap of color2 and color3)
            overlapColors[2], // Class 6 (Overlap of color1 and color3)
            overlapColors[3], // Class 7 (Overlap of all three)
        ]

        // Return function to get color based on region's class (1 to 7)
        return function (classIndex) {
            if (classIndex >= 1 && classIndex <= 7) {
                return classColors[classIndex - 1]
            } else {
                return null // Return null or a default color if the classIndex is out of range
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl3 === 'nd') return out.noDataFillStyle() || 'gray'

                    if (!ecl1 && !ecl2 && !ecl3) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.

                    let regionClass = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('regionClass')
                    let color = out.classToFillStyle_(regionClass)
                    return color

                    //return getCSSPropertyFromClass('em-nutsrg', 'fill')
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        regions
                            .on('mouseover', function (e, rg) {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                sel.style('fill', map.hoverColor_)
                                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                            })
                            .on('mousemove', function (e, rg) {
                                if (out._tooltip) out._tooltip.mousemove(e)
                            })
                            .on('mouseout', function () {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                let newFill = sel.attr('fill___')
                                if (newFill) {
                                    sel.style('fill', sel.attr('fill___'))
                                    if (out._tooltip) out._tooltip.mouseout()
                                }
                            })
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const styleMixedNUTS = function (map) {
    map.svg()
        .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
        .style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const ecl = sel.attr('ecl')
            const lvl = sel.attr('lvl')
            const countryId = rg.properties.id.slice(0, 2)
            return ecl || lvl === '0' ? 'block' : 'none'
        })
        .style('stroke', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const stroke = sel.style('stroke')
            return ecl && lvl !== '0' ? stroke || '#777' : null
        })
        .style('stroke-width', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const strokeWidth = sel.style('stroke-width')
            return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
        })
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunctionTrivariate = function (rg, map) {
    const buf = []
    //region name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()
    //stat 3 value
    const sv3 = map.statData('v3').get(rg.properties.id)
    const unit3 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        Variable 1: ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 2: ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 3: ${sv3 && sv3.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv3.value) : ''} ${unit3 && sv3 && sv3.value ? unit3 : ''}
        ${!sv3 || (sv3.value != 0 && !sv3.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-choropleth.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   getFillPatternLegend: () => (/* binding */ getFillPatternLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var simple_statistics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! simple-statistics */ "./node_modules/simple-statistics/dist/simple-statistics.mjs");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");












/**
 * Returns a chroropleth map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'ch')

    //the number of classes
    out.numberOfClasses_ = 7
    //the classification method
    out.classificationMethod_ = 'quantile' // or: equinter, threshold
    //the threshold, when the classification method is 'threshold'
    out.thresholds_ = [0]
    //colors to use for classes
    out.colors_ = null
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //the color function [0,1] -> color
    let eurostatMultihue = ['#FFEB99', '#D1E9B0', '#8DD6B9', '#58C1C0', '#3792B6', '#134891', '#1d2b6f']
    out.colorFunction_ = (t) => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["default"], eurostatMultihue)(Math.min(Math.max(0, t), 1)) // default
    //a function returning the color from the class i
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier_ = undefined
    // set tooltip function
    out.tooltip_.textFunction = choroplethTooltipFunction

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'classificationMethod_',
        'thresholds_',
        'makeClassifNice_',
        'colorFunction_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier_',
        'colors_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override of some special getters/setters
    out.colorFunction = function (v) {
        if (!arguments.length) {
            return out.colorFunction_
        }
        out.colorFunction_ = v
        // update class style function
        if (out.filtersDefinitionFunction_) {
            // if dot density
            out.classToFillStyle(getFillPatternLegend())
        } else {
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }
        return out
    }
    out.threshold = function (v) {
        if (!arguments.length) return out.thresholds_
        out.thresholds_ = v
        out.numberOfClasses(v.length + 1)
        return out
    }
    out.filtersDefinitionFunction = function (v) {
        if (!arguments.length) return out.filtersDefinitionFunction_
        out.filtersDefinitionFunction_ = v
        if (out.svg()) out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        return out
    }

    //override attribute values with config values
    if (config)
        [
            'numberOfClasses',
            'classificationMethod',
            'threshold',
            'makeClassifNice',
            'colorFunction',
            'classToFillStyle',
            'noDataFillStyle',
            'colors_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        try {
            // apply classification to all insets that are outside of the main map's SVG
            if (out.insetTemplates_) {
                (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
            }

            // apply to main map
            applyClassificationToMap(out)

            return out
        } catch (e) {
            console.error('Error in updateClassification:', e.message)
            console.error(e)
        }
    }

    function applyClassificationToMap(map) {
        // Helper function to generate a range [0, 1, 2, ..., nb-1]
        const generateRange = (nb) => [...Array(nb).keys()]

        // Configure classifier based on the selected classification method
        const setupClassifier = () => {
            const dataArray = out.statData().getArray()
            const range = generateRange(out.numberOfClasses_)

            switch (out.classificationMethod_) {
                case 'quantile': {
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])().domain(dataArray).range(range))
                    break
                }
                case 'equal-interval':
                case 'equinter': {
                    out.classifier(
                        (0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])()
                            .domain([(0,d3_array__WEBPACK_IMPORTED_MODULE_9__["default"])(dataArray), (0,d3_array__WEBPACK_IMPORTED_MODULE_10__["default"])(dataArray)])
                            .range(range)
                    )
                    if (out.makeClassifNice_) out.classifier().nice()
                    break
                }
                case 'threshold': {
                    out.numberOfClasses(out.thresholds_.length + 1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_11__["default"])().domain(out.thresholds_).range(generateRange(out.numberOfClasses_)))
                    break
                }
                case 'jenks': {
                    const jenksBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_3__.jenks)(dataArray, out.numberOfClasses_) // Calculate breaks for Jenks
                    const domain = jenksBreaks.slice(1, -1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_11__["default"])().domain(domain).range(range)) // Use Jenks breaks in scale
                    break
                }
                case 'ckmeans': {
                    // Calculate ckmeans breaks, extracting the maximum value from each cluster
                    const ckmeansBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_3__.ckmeans)(dataArray, out.numberOfClasses_).map((cluster) => cluster.pop())

                    // Set the domain for scaleThreshold excluding the last value, as it serves as the upper bound
                    const domain = ckmeansBreaks.slice(0, -1)

                    // Use the ckmeans breaks in the scaleThreshold and set the classifier
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_11__["default"])().domain(domain).range(range))
                    break
                }
            }
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const regionData = out.statData().get(rg.properties.id)
                if (!regionData) return // Lack of data is handled explicitly
                const value = regionData.value
                if (value === ':' || value === null) return 'nd'
                return value != null ? +out.classifier_(value) : undefined
            })
        }

        // Initialize classifier
        setupClassifier()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        try {
            // apply style to insets
            if (out.insetTemplates_) {
                (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
            }

            // apply to main map
            applyStyleToMap(out)

            return out
        } catch (e) {
            console.error('Error in updateStyle:', e.message)
            console.error(e)
        }
    }

    function applyStyleToMap(map) {
        // Define function to get a class' color
        if (out.filtersDefinitionFunction_) {
            // Dot density style
            out.classToFillStyle(getFillPatternLegend())
        } else {
            // Color legend style
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }

        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_4__.applyPatternFill)(map, out.patternFill_)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')

                // Determine display visibility
                const isVisible = ecl || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if (ecl && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle()(ecl, out.numberOfClasses_)
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_(ecl, out.numberOfClasses_)
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle()(ecl, out.numberOfClasses_)
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFunction, colorArray) {
    colorFunction = colorFunction || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_13__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFunction(ecl / (numberOfClasses - 1))
    }
}

/**
 * Build a fill pattern legend object { nd:"white", 0:"url(#pattern_0)", 1:"url(#pattern_1)", ... }
 */
const getFillPatternLegend = function () {
    return function (ecl) {
        return 'url(#pattern_' + ecl + ')'
    }
}

const choroplethTooltipFunction = function (region, map) {
    if (map.tooltip_.omitRegions && map.tooltip_.omitRegions.includes(region.properties.id)) {
        return '' // Skip tooltip for omitted regions
    }
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na || region.properties.name
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    // Retrieve region's data value and unit
    const statData = map.statData()
    const sv = statData.get(regionId)
    const unit = statData.unitText() || ''

    // No data case
    if (!sv || (sv.value !== 0 && !sv.value) || sv.value === ':') {
        buf.push(`
            <div class="estat-vis-tooltip-text no-data">
                <table class="nuts-table">
                    <tbody>
                        <tr><td>${map.noDataText_}</td></tr>
                    </tbody>
                </table>
            </div>
        `)
        return buf.join('')
    }

    // Data display
    buf.push(`
        <div class="estat-vis-tooltip-text">
            <table class="nuts-table">
                <tbody>
                    <tr><td>${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv.value)} ${unit}</td></tr>
                </tbody>
            </table>
        </div>
    `)

    // Optional status flag
    const statusFlag = sv.status
    if (statusFlag && map.tooltip_.showFlags) {
        const flagText = map.tooltip_.showFlags === 'short' ? statusFlag : flags[statusFlag] || statusFlag
        buf.push(` <span class="status-flag">${flagText}</span>`)
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-flow.js":
/*!**********************************!*\
  !*** ./src/maptypes/map-flow.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/link.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-flow */ "./src/legend/legend-flow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
// Import required D3 modules
// import { sankey, sankeyLinkHorizontal } from 'd3-sankey'









/**
 * Returns a flow map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'flow')
    out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])()
    out.labelOffsetX = 15
    out.labelOffsetY = 5
    out.labelFormatter = (d) => (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)('.2s')(d)
    out.tooltip_.textFunction = flowMapTooltipFunction
    out.flowColor_ = '#72bb6f'
    out.flowOverlayColors_ = ['#bbd7ee', '#c7e3c6'] // exporter, importers
    out.flowMaxWidth_ = 30
    out.flowMinWidth_ = 1
    out.flowArrows_ = true
    out.flowOutlines_ = true
    out.flowTargetOffset_ = 1 // Default to normal offset behavior
    out.flowGradient_ = true

    /**
     * flowmap-specific setters/getters
     */
    ;[
        'flowGraph_',
        'flowColor_',
        'flowOverlayColors_',
        'flowArrows_',
        'flowTargetOffset_',
        'flowMaxWidth_',
        'flowMinWidth_',
        'flowOutlines_',
        'flowGradient_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //@override
    out.updateStyle = function () {
        // type: "Feature"
        // properties: Object {id: "ES", na: "España"}
        // geometry: Object {type: "MultiPolygon", coordinates: Array(7)}
        // source: "FR"
        // target: "ES"
        // value: 45422327.56

        // update stroke width function
        const data = out.flowGraph_.links
        out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])()
            .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_5__["default"])(data, (d) => d.value)])
            .range([out.flowMinWidth_, out.flowMaxWidth_])

        createFlowMapSVG(out.flowGraph_)
    }

    //@override
    out.updateClassification = function () {}

    //@override
    out.getLegendConstructor = function () {
        //TODO: define legend
        return _legend_legend_flow__WEBPACK_IMPORTED_MODULE_1__.legend
    }
    /**
     * Function to create a map with Sankey diagram and other elements
     * @param {Object} graph - Configuration options and data for the map
     * exampleGraph = {
                nodes: [
                    { id: 'FR', x: 681.1851800759263, y: 230.31124763648583 },
                    { id: 'DE', x: 824.5437782154489, y: 123.70302649032199 },
                ],
                links: [
                    { source: 'FR', target: 'DE', value: 82018369.72 },
                ],
            }
     */
    function createFlowMapSVG(graph) {
        const svg = out.svg_

        // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
        addCoordinatesToGraph(graph)

        var { nodes, links } = sankey(graph)

        // Define marker and gradient IDs
        const defs = svg.append('defs')
        const arrowId = generateUniqueId('arrow')
        const arrowOutlineId = generateUniqueId('arrow-outline')
        const gradientIds = links.map(() => generateUniqueId('gradient'))

        // Add arrow markers
        if (out.flowArrows_) {
            addArrowMarker(defs, arrowId, out.flowColor_)
            addArrowMarker(defs, arrowOutlineId, '#ffffff')
        }

        // Add flow gradients
        if (out.flowGradient_) {
            addFlowGradients(defs, gradientIds, links)
        }

        // Define our container SVG
        const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])('#em-zoom-group-' + out.svgId_)
        const sankeyContainer = zoomGroup.append('g').attr('class', 'em-flow-container')

        // Add geographical layers
        addOverlayPolygons(sankeyContainer, graph)

        // Add Sankey flows
        addSankeyFlows(sankeyContainer, links, arrowId, arrowOutlineId, gradientIds)

        // Add additional nodes (fill gaps)
        addFillGaps(sankeyContainer, nodes)

        // Add labels to nodes
        if (out.labels_) addLabels(sankeyContainer, nodes)

        return svg.node()
    }

    /**
     * Adds geographical layers (regions, POI overlay, borders)
     * @param {Object} svg - D3 selection of SVG container
     */
    function addOverlayPolygons(svg, graph) {
        const importerIds = []
        const exporterIds = []
        const features = out.Geometries.getRegionFeatures()
        if (features) {
            graph.nodes.forEach((node) => {
                const overlay = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (overlay) {
                    let isImporter = graph.links.some((link) => link.source == node.id)
                    if (isImporter) {
                        importerIds.push(node.id)
                    } else {
                        exporterIds.push(node.id)
                    }
                } else {
                    console.error('could not find geometry for', node.id)
                }
            })

            //update existing region fills
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
            const allRegions = out.svg_.selectAll(selector)

            allRegions.each(function () {
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).style('fill', (region) => {
                    if (importerIds.includes(region.properties.id)) return out.flowOverlayColors_[0]
                    if (exporterIds.includes(region.properties.id)) return out.flowOverlayColors_[1]
                })
            })
        }
    }

    // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
    function addCoordinatesToGraph(graph) {
        graph.nodes.forEach((node) => {
            if (!node.x && !node.y && out.Geometries.centroidFeatures) {
                const centroid = out.Geometries.centroidFeatures.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (centroid) {
                    const screenCoords = out._projection([centroid.geometry.coordinates[0], centroid.geometry.coordinates[1]])
                    node.x = screenCoords[0]
                    node.y = screenCoords[1]
                } else {
                    console.error('could not find coordinates for', node.id)
                }
            } else {
                // no centroids data, calculate on the fly
                const features = out.Geometries.getRegionFeatures()
                const feature = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })
                const centroid = feature.properties.centroid || out._pathFunction.centroid(feature)
                const screenCoords = out._projection([centroid[0], centroid[1]])
                node.x = screenCoords[0]
                node.y = screenCoords[1]
            }
        })
        console.log(graph)
    }

    /**
     * Generates a unique DOM ID
     * @param {string} prefix - Prefix for the ID
     * @returns {string} Unique ID
     */
    function generateUniqueId(prefix) {
        return `${prefix}-${Math.random().toString(36).substr(2, 9)}`
    }

    /**
     * Adds an arrow marker to the defs section
     * @param {Object} defs - D3 selection of defs
     * @param {string} id - Marker ID
     * @param {string} color - Fill color of the marker
     */
    function addArrowMarker(defs, id, color) {
        defs.append('marker')
            .attr('id', id)
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', color)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')

        // add a copy for mouseover with hovered color
        defs.append('marker')
            .attr('id', id + 'mouseover')
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', out.hoverColor_)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')
    }

    /**
     * Adds linear gradient definitions for flow links
     * @param {Object} defs - D3 selection of defs
     * @param {Array} gradientIds - Array of gradient IDs
     * @param {Array} links - Sankey links data
     */
    function addFlowGradients(defs, gradientIds, links) {
        defs.selectAll('linearGradient')
            .data(links)
            .join('linearGradient')
            .attr('id', (_, i) => gradientIds[i])
            .attr('gradientUnits', 'userSpaceOnUse')
            .attr('x1', (d) => d.source.x1)
            .attr('x2', (d) => d.target.x0)
            .attr('y1', (d) => d.y0)
            .attr('y2', (d) => d.y1)
            .call((g) => g.append('stop').attr('offset', '5%').attr('stop-color', out.flowOverlayColors_[0]))
            .call((g) => g.append('stop').attr('offset', '50%').attr('stop-color', out.flowColor_))
    }

    /**
     * Adds Sankey flows (links with markers and gradients)
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} links - Sankey links data
     * @param {string} arrowId - Arrow marker ID
     * @param {string} arrowOutlineId - Arrow outline marker ID
     * @param {Array} gradientIds - Gradient IDs
     */
    function addSankeyFlows(svg, links, arrowId, arrowOutlineId, gradientIds) {
        const flowsGroup = svg.append('g').attr('class', 'em-flows-group')
        const flows = flowsGroup.append('g').attr('class', 'em-flow-flows')
        const outlines = flowsGroup.append('g').attr('class', 'em-flow-outlines')

        links.forEach((link, i) => {
            // Outline path
            if (out.flowOutlines_) {
                outlines
                    .append('path')
                    .attr('d', sankeyLinkHorizontal()(link))
                    .attr('fill', 'none')
                    .attr('stroke', '#ffffff')
                    .attr('class', 'em-flow-link-outline')
                    // .attr('stroke-width', link.width + 1.5)
                    .attr('marker-end', `url(#${arrowOutlineId})`)
            }

            // Main path
            flows
                .append('path')
                .attr('d', sankeyLinkHorizontal()(link))
                .attr('fill', 'none')
                .attr('class', 'em-flow-link')
                .attr('stroke', out.flowGradient_ ? `url(#${gradientIds[i]})` : out.flowColor_)
                .attr('stroke-width', link.width)
                .attr('marker-end', out.flowArrows_ ? `url(#${arrowId})` : '')
                // add hover effect
                .on('mouseover', function (e) {
                    const hoveredColor = out.hoverColor_

                    // Change the stroke color
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', hoveredColor)

                    // Update the marker-end dynamically
                    if (out.flowArrows_) (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId + 'mouseover'})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(link, out))
                })
                .on('mousemove', function (e) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    // Revert the stroke color
                    if (out.flowGradient_) {
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', `url(#${gradientIds[i]})`)
                    } else {
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', out.flowColor_)
                    }

                    // Revert the marker-end to the original
                    if (out.flowArrows_) (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    /**
     * Adds rectangles to fill gaps left by Sankey links
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} nodes - Sankey nodes data
     */
    function addFillGaps(svg, nodes) {
        svg.append('g')
            .attr('class', 'em-flow-fill-in-gaps')
            .selectAll('rect')
            .data(nodes)
            .join('rect')
            .filter((d) => d.depth && d.height)
            .attr('x', (d) => d.x0 - 0.5)
            .attr('y', (d) => d.y0)
            .attr('width', 1)
            .attr('height', (d) => d.y1 - d.y0)
            .attr('fill', out.flowColor_)
    }

    /**
     * Add labels for data points.
     * @param {Object} svg - D3 selection of the SVG element.
     */
    function addLabels(svg, nodes) {
        // Filter the nodes
        const filteredNodes = nodes.filter((node) => node.targetLinks && node.sourceLinks.length === 0)
        const container = svg.append('g').attr('class', 'em-flow-labels')

        // Add halo effect
        if (out.labels_?.shadows) {
            const labelsShadowGroup = container.append('g').attr('class', 'em-flow-label-shadow')
            labelsShadowGroup
                .selectAll('text')
                .data(filteredNodes)
                .join('text')
                .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
                .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? d.x + out.labelOffsetX : d.x - out.labelOffsetX))
                .attr('y', (d) => d.y + out.labelOffsetY)
                .text((d) => out.labelFormatter(d.value))
        }

        // Add labels
        const labelsGroup = container.append('g').attr('class', 'em-flow-label')
        //add background
        // Add background rectangles and text
        const labelElements = labelsGroup
            .selectAll('g') // Use a group for each label to combine rect and text
            .data(filteredNodes)
            .join('g') // Append a group for each label
            .attr('transform', (d) => `translate(${d.x}, ${d.y})`) // Position group at the node

        // Add text first to calculate its size
        labelElements
            .append('text')
            .attr('class', 'em-label-text')
            .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
            .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? out.labelOffsetX : -out.labelOffsetX))
            .attr('y', out.labelOffsetY)
            .text((d) => out.labelFormatter(d.value))

        // Add background rectangles after text is rendered

        if (out.labels_.backgrounds) {
            labelElements.each(function () {
                const textElement = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).select('text')
                const bbox = textElement.node().getBBox() // Get bounding box of the text

                const paddingX = 5 // Horizontal padding
                const paddingY = 2 // Vertical padding

                // Add rectangle centered behind the text
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                    .insert('rect', 'text') // Insert rect before text in DOM
                    .attr('class', 'em-label-background')
                    .attr('x', bbox.x - paddingX)
                    .attr('y', bbox.y - paddingY)
                    .attr('width', bbox.width + 2 * paddingX)
                    .attr('height', bbox.height + 2 * paddingY)
            })
        }
    }

    // Function to append a rectangle behind the label
    function appendLabelRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    // From this point on all code is related with spatial sankey. Adopted from this notebook: https://observablehq.com/@bayre/deconstructed-sankey-diagram
    // See https://observablehq.com/@joewdavies/flow-map-of-europe
    function clone({ nodes, links }) {
        return { nodes: nodes.map((d) => Object.assign({}, d)), links: links.map((d) => Object.assign({}, d)) }
    }

    function sankey({ nodes, links }) {
        const graph = clone({ nodes, links })
        computeNodeLinks(graph)
        computeNodeValues(graph)
        computeNodeDepths(graph)
        computeNodeHeights(graph)
        computeNodeBreadths(graph)
        computeLinkBreadths(graph)
        return graph
    }

    function computeNodeLinks({ nodes, links }) {
        for (const [i, node] of nodes.entries()) {
            node.index = i
            node.sourceLinks = []
            node.targetLinks = []
        }
        const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]))
        for (const [i, link] of links.entries()) {
            link.index = i
            let { source, target } = link
            if (typeof source !== 'object') source = link.source = find(nodeById, source)
            if (typeof target !== 'object') target = link.target = find(nodeById, target)
            source.sourceLinks.push(link)
            target.targetLinks.push(link)
        }
        // if (linkSort != null) {
        //     for (const { sourceLinks, targetLinks } of nodes) {
        //         sourceLinks.sort(linkSort)
        //         targetLinks.sort(linkSort)
        //     }
        // }
    }

    function find(nodeById, id) {
        const node = nodeById.get(id)
        if (!node) throw new Error('missing: ' + id)
        return node
    }

    function computeNodeDepths({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.depth = x
                for (const { target } of node.sourceLinks) {
                    next.add(target)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    function computeNodeHeights({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.height = x
                for (const { source } of node.targetLinks) {
                    next.add(source)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    function computeNodeBreadths({ nodes }) {
        for (const node of nodes) {
            // Compute link widths
            node.sourceLinks.forEach((link) => (link.width = out.strokeWidthScale(link.value)))
            node.targetLinks.forEach((link) => (link.width = out.strokeWidthScale(link.value)))

            // Use total space needed by links
            const totalLinkWidth = Math.max(
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.sourceLinks, (d) => d.width),
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.targetLinks, (d) => d.width)
            )

            node.x0 = node.x1 = node.x
            node.y0 = node.y - totalLinkWidth / 2
            node.y1 = node.y + totalLinkWidth / 2
        }

        reorderLinks(nodes)
    }

    function computeLinkBreadths({ nodes }) {
        for (const node of nodes) {
            let y0 = node.y0
            for (const link of node.sourceLinks) {
                link.y0 = y0 + link.width / 2
                y0 += link.width
            }

            let y1 = node.y0
            for (const link of node.targetLinks) {
                link.y1 = y1 + link.width / 2
                y1 += link.width
            }
        }
    }

    // Group nodes by depth and stack vertically
    function stackNodeYs(nodes) {
        const byDepth = new Map()
        for (const node of nodes) {
            if (!byDepth.has(node.depth)) byDepth.set(node.depth, [])
            byDepth.get(node.depth).push(node)
        }

        for (const [depth, group] of byDepth.entries()) {
            // Sort by value or id to ensure consistency
            group.sort((a, b) => b.value - a.value)

            let y = 100 // starting y position
            const padding = 5
            for (const node of group) {
                const nodeHeight = Math.max(
                    (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.sourceLinks, (d) => d.width),
                    (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.targetLinks, (d) => d.width)
                )
                node.y = y + nodeHeight / 2
                y += nodeHeight + padding
            }
        }
    }

    function horizontalSource(d) {
        return [d.source.x1, d.y0]
    }

    function horizontalTarget(d) {
        return [d.target.x0, d.y1]
    }

    function computeNodeValues({ nodes }) {
        for (const node of nodes) {
            node.value = Math.max(
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.sourceLinks, (d) => d.value),
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.targetLinks, (d) => d.value)
            )
        }
    }

    function reorderLinks(nodes) {
        for (const { sourceLinks, targetLinks } of nodes) {
            sourceLinks.sort(ascendingTargetY)
            targetLinks.sort(ascendingSourceY)
        }
    }

    const ascendingTargetY = (a, b) => a.target.y - b.target.y
    const ascendingSourceY = (a, b) => a.source.y - b.source.y

    const id = (d) => d.id // used in sankey import

    const sankeyLinkHorizontal = function () {
        return (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__.linkHorizontal)().source(horizontalSource).target(horizontalTarget)
    }

    return out
}

const flowMapTooltipFunction = function (link, map) {
    const buf = []

    // Header with region name and ID
    const title = `${link.source.name || link.source.id} to ${link.target.name || link.target.id}`
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${title}</b>
        </div>
    `)

    // Value
    buf.push(`<div class='estat-vis-tooltip-text'>
        ${link.value}
        </div>`)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-piecharts.js":
/*!***************************************!*\
  !*** ./src/maptypes/map-piecharts.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-piecharts */ "./src/legend/legend-piecharts.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");









/**
 * Returns a proportional pie chart map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'pie')

    // pie charts
    out.pieMinRadius_ = 5
    out.pieMaxRadius_ = 15
    out.pieChartInnerRadius_ = 0
    out.pieStrokeFill_ = 'white'
    out.pieStrokeWidth_ = 0.3

    //tooltip pie chart
    out.tooltipPieRadius_ = 40
    out.tooltipPieInnerRadius_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    // 'other' section of the pie chart for when 'out.totalCode_' is defined with statPie()
    out.pieOtherColor_ = '#FFCC80'
    out.pieOtherText_ = 'Other'

    //show piecharts only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    out.sizeClassifier_ = null //d3 scale for scaling pie sizes
    out.statPie_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieMaxRadius_',
        'pieMinRadius_',
        'pieChartInnerRadius_',
        'pieOtherColor_',
        'pieOtherText_',
        'pieStrokeFill_',
        'pieStrokeWidth_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieMaxRadius',
            'pieMinRadius',
            'pieChartInnerRadius',
            'pieOtherColor',
            'pieOtherText',
            'pieStrokeFill',
            'pieStrokeWidth',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /** The codes of the categories to consider for the composition. */
    out.statCodes_ = undefined
    /** The code of the "total" category in the eurostat database */
    out.totalCode__ = undefined

    /**
     * A function to define a pie chart map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension (defined in eurostat REST API) of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     * @param {string} tCode Optional: The category code of the total (used to calculate total & "other" values if codes array dont represent all possible categories)
     */
    out.statPie = function (stat, dim, codes, labels, colors, tCode) {
        //add one dataset (stat) config for each category (code)
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) {
                sc_[key] = stat[key]
            }
            sc_.filters = {}
            for (let key in stat.filters) {
                sc_.filters[key] = stat.filters[key]
            }
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set out.statCodes_
        out.statCodes_ = codes

        //set out.totalCode_
        if (tCode) {
            out.totalCode_ = tCode
            stat.filters[dim] = tCode
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(tCode, sc_)

            //when total code is used, an 'other' section is added to the pie
            out.catColors_['other'] = out.pieOtherColor_
            out.catLabels_['other'] = out.pieOtherText_
        }

        return out
    }

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //if not provided, get list of stat codes from the map stat data
        if (!out.statCodes_) {
            //get list of stat codes.
            out.statCodes_ = Object.keys(out.statData_)
            //remove "default", if present
            const index = out.statCodes_.indexOf('default')
            if (index > -1) out.statCodes_.splice(index, 1)
        }

        //define size scaling function
        let domain = getDatasetMaxMin()
        if (!isNaN(domain[0])) {
            out.sizeClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__.sqrt)().domain(domain).range([out.pieMinRadius_, out.pieMaxRadius_])
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors_) {
            out.catColors({})
            for (let i = 0; i < out.statCodes_.length; i++) out.catColors_[out.statCodes_[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of sharing regions with pies
        let regionFeatures = []
        if (out.svg_) {
            let s = out.svg_.selectAll('#em-prop-symbols')
            if (s) {
                let sym = s.selectAll('g.em-centroid')
                sym.append('g')
                    .attr('class', 'em-pie')
                    .attr('id', (rg) => {
                        regionFeatures.push(rg)
                        return 'pie_' + rg.properties.id
                    })

                // set region hover function
                const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
                let regions = out.svg().selectAll(selector)
                regions
                    .on('mouseover', function (e, rg) {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                        sel.style('fill', out.hoverColor_)
                        if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                    })
                    .on('mousemove', function (e, rg) {
                        if (out._tooltip) out._tooltip.mousemove(e)
                    })
                    .on('mouseout', function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                        let newFill = sel.attr('fill___')
                        if (newFill) {
                            sel.style('fill', sel.attr('fill___'))
                            if (out._tooltip) out._tooltip.mouseout()
                        }
                    })

                addPieChartsToMap(regionFeatures)
            }
        }
        return out
    }

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < out.statCodes_.length; i++) {
            //retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        // when out.totalCode_ is specified, use it as the sum instead of the sum of the specified categories.
        if (out.totalCode_) {
            let s = out.statData(out.totalCode_).get(id)
            if (s) {
                sum = s.value
            } else {
                sum == 0
            }
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < out.statCodes_.length; i++) {
            comp[out.statCodes_[i]] /= sum
        }

        //add "other" category when out.totalCode_ is used
        if (out.totalCode_) {
            let totalPerc = 0
            for (let key in comp) {
                totalPerc = totalPerc + comp[key]
            }
            comp['other'] = 1 - totalPerc
        }

        return comp
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum total of all dimensions combined for each region. Used to define the domain of the pie size scaling function.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        let totals = []
        let sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            let id = rg.properties.id
            let total = getRegionTotal(id)
            if (total) {
                totals.push(total)
            }
        })

        let minmax = (0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])(totals)
        return minmax
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionTotal = function (id) {
        let sum = 0
        let s
        if (out.totalCode_) {
            //when total is a stat code
            s = out.statData(out.totalCode_).get(id)
            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) {
                    sum = undefined
                }
            } else {
                sum = s.value
            }
        } else {
            //get stat value for each category. Compute the sum.
            for (let i = 0; i < out.statCodes_.length; i++) {
                //retrieve code and stat value
                const sc = out.statCodes_[i]
                s = out.statData(sc).get(id)
                //case when some data is missing
                if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                    if (out.showOnlyWhenComplete()) return undefined
                    else continue
                }
                sum += s.value
            }
        }

        //case when no data
        if (sum == 0) return undefined
        return sum
    }

    function addPieChartsToMap(regionFeatures) {
        regionFeatures.forEach((region) => {
            const regionId = region.properties.id
            //prepare data for pie chart
            const data = []
            const comp = getComposition(regionId)
            for (const key in comp) data.push({ code: key, value: comp[key] })

            //case of regions with no data
            if (!data || data.length == 0) {
                return
            }

            //create svg for pie chart
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let nodes = out.svg().selectAll('#pie_' + regionId)

            // define radius
            const r = out.sizeClassifier_(getRegionTotal(regionId))
            const ir = out.pieChartInnerRadius_

            //make pie chart. See https://observablehq.com/@d3/pie-chart
            const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
                .sort(null)
                .value((d) => d.value)
            nodes
                .append('g')
                .attr('stroke', out.pieStrokeFill_)
                .attr('stroke-width', out.pieStrokeWidth_ + 'px')
                .attr('class', 'piechart')
                .selectAll('path')
                .data(pie_(data))
                .join('path')
                .style('fill', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('fill___', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('code', (d) => d.data.code) //for mouseover legend highlighting function
                .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])().innerRadius(ir).outerRadius(r))
                .on('mouseover', function (e, rg) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    // Apply a thick stroke width to the parent element
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', '1px').style('stroke', 'black') // Set stroke
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(region, out))
                })
                .on('mousemove', function (e, rg) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    // Reset stroke
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', out.pieStrokeWidth_).style('stroke', out.pieStrokeFill_) // Set stroke
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        if (rg.properties.id) {
            //name and code
            tp.append('div')
                .attr('class', 'estat-vis-tooltip-bar')
                .html(rg.properties.na + ' (' + rg.properties.id + ')')
        } else {
            //region name
            tp.append('div').attr('class', 'estat-vis-tooltip-bar').html(rg.properties.na)
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        // set the dimensions and margins of the graph
        let width = 150
        let height = 150
        let margin = 25

        // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
        const radius = Math.min(width, height) / 2 - margin

        //width = tp.node().getBoundingClientRect().width
        const container = tp.append('div').attr('class', 'em-tooltip-piechart-container')
        const svg = container
            .append('svg')
            .attr('class', 'em-tooltip-piechart-svg')
            .attr('viewbox', `0, 0, ${width}, ${height}`)
            .attr('width', width)
            .attr('height', height - margin / 2)
            .append('g')
            .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
            .sort(null)
            .value((d) => d.value)

        const innerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(0) // This is the size of the donut hole
            .outerRadius(radius * 0.8)

        // Another arc that won't be drawn. Just for labels positioning
        const outerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(radius * 0.9)
            .outerRadius(radius * 0.9)

        const pieData = pie_(data)
        svg.selectAll('allSlices')
            .data(pieData)
            .enter()
            .append('path')
            .attr('d', innerArc)
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('stroke', 'white')
            .style('stroke-width', '1px')
            .style('opacity', 0.7)

        // Add the polylines between chart and labels:
        svg.selectAll('allPolylines')
            .data(pieData)
            .enter()
            .append('polyline')
            .attr('stroke', 'black')
            .style('fill', 'none')
            .attr('stroke-width', 1)
            .attr('points', function (d) {
                if (d.data.value > 0.02) {
                    const posA = innerArc.centroid(d) // line insertion in the slice
                    const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                    const posC = outerArc.centroid(d) // Label position = almost the same as posB
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                    posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1) // multiply by 1 or -1 to put it on the right or on the left
                    return [posA, posB, posC]
                }
            })

        // Add the labels:
        svg.selectAll('allLabels')
            .data(pieData)
            .enter()
            .append('text')
            .text(function (d) {
                if (d.data.value > 0.02) {
                    let n = (d.data.value * 100).toFixed()
                    if (!isNaN(n)) return n + '%'
                }
            })
            .attr('transform', function (d) {
                var pos = outerArc.centroid(d)
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1)
                return 'translate(' + pos + ')'
            })
            .style('text-anchor', function (d) {
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                return midangle < Math.PI ? 'start' : 'end'
            })
            .style('font-size', '12px')

        // add region values to tooltip
        let breakdownDiv = tp.append('div').attr('class', 'em-tooltip-piechart-breakdown')

        // show value for each category
        for (let i = 0; i < out.statCodes_.length; i++) {
            // retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(rg.properties.id)

            // check if s and s.value are valid (handle null, undefined, or 0)
            if (s && s.value !== undefined && s.value !== null) {
                let string = `<strong>${out.catLabels_[sc]}</strong>: ${s.value.toFixed()}<br>`
                breakdownDiv.html(breakdownDiv.html() + string) // safely update the HTML
            }
        }

        // write total (handle null, undefined, or 0 values for total)
        let total = getRegionTotal(rg.properties.id)
        if (total !== undefined && total !== null) {
            breakdownDiv.html(breakdownDiv.html() + `<strong>Total</strong>: ${total.toFixed()}<br>`)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-proportional-symbols.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-proportional-symbols.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   symbolsLibrary: () => (/* binding */ symbolsLibrary)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-proportional-symbols */ "./src/legend/legend-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");











/**
 * Returns a proportional symbol map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'ps')

    //shape
    out.psShape_ = 'circle' // accepted values: circle, bar, square, star, diamond, wye, cross
    out.psCustomShape_ // see http://using-d3js.com/05_10_symbols.html#h_66iIQ5sJIT
    out.psCustomSVG_ // see http://bl.ocks.org/jessihamel/9648495
    out.psSpikeWidth_ = 7 // 'spike' shape widths
    out.psOffset_ = { x: 0, y: 0 }

    //size
    out.psMaxSize_ = 30 // max symbol size
    out.psMinSize_ = 5 // min symbol size
    out.psBarWidth_ = 10 //for vertical bars
    out.psMaxValue_ = undefined // allow the user to manually define the domain of the sizing scale. E.g. if the user wants to use the same scale across different maps.
    out.psMinValue_ = undefined
    out.psSizeScale_ = undefined // 'sqrt' or 'linear'

    //colour
    out.psFill_ = '#2d50a0' //same fill for all symbols when no visual variable (setData()) for 'color' is specified
    out.psFillOpacity_ = 1
    out.psStroke_ = '#ffffff'
    out.psStrokeWidth_ = 0.2
    out.psClasses_ = 5 // number of classes to use for colouring
    out.psColors_ = null //colours to use for threshold colouring
    out.psColorFun_ = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__["default"]
    out.psClassToFillStyle_ = undefined //a function returning the color from the class i

    //the threshold, when the classification method is 'threshold'
    out.psThresholds_ = [0]
    //the classification method
    out.psClassificationMethod_ = 'quantile' // or: equinter, threshold
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //
    //the classifier: a function which return the symbol size/color from the stat value.
    out.classifierSize_ = undefined
    out.classifierColor_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunPs

    //dorling cartogram
    out.dorling_ = false
    out.dorlingStrength_ = { x: 1, y: 1 }
    out.dorlingIterations_ = 1
    out.psCodeLabels_ = false // show country codes in symbols

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'psMaxSize_',
        'psMinSize_',
        'psMaxValue_',
        'psMinValue_',
        'psFill_',
        'psFillOpacity_',
        'psStroke_',
        'psStrokeWidth_',
        'classifierSize_',
        'classifierColor_',
        'psShape_',
        'psCustomShape_',
        'psBarWidth_',
        'psClassToFillStyle_',
        'psColorFun_',
        'psSizeScale_',
        'noDataFillStyle_',
        'psThresholds_',
        'psColors_',
        'psCustomSVG_',
        'psOffset_',
        'psClassificationMethod_',
        'psClasses_',
        'dorling_',
        'dorlingStrength_',
        'psSpikeWidth_',
        'psCodeLabels_',
        'dorlingIterations_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'psMaxSize',
            'psMinSize',
            'psFill',
            'psFillOpacity',
            'psStroke',
            'psStrokeWidth',
            'classifierSize',
            'classifierColor',
            'psShape',
            'psCustomShape',
            'psBarWidth',
            'psClassToFillStyle',
            'psColorFun',
            'noDataFillStyle',
            'psThreshold',
            'psColors',
            'psCustomSVG',
            'psOffset',
            'psClassificationMethod',
            'psClasses',
            'dorlingIterations_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //override of some special getters/setters
    out.psColorFun = function (v) {
        if (!arguments.length) return out.psColorFun_
        out.psColorFun_ = v
        out.psClassToFillStyle_ = getColorLegend(out.psColorFun_, out.psColors_)
        return out
    }
    out.psThresholds = function (v) {
        if (!arguments.length) return out.psThresholds_
        out.psThresholds_ = v
        out.psClasses(v.length + 1)
        return out
    }

    //@override
    out.updateClassification = function () {
        try {
            //define classifiers for sizing and colouring (out.classifierSize_ & out.classifierColor_)
            defineClassifiers()

            // apply classification to all insets that are outside of the main map's SVG
            if (out.insetTemplates_) {
                (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
            }

            // apply to main map
            applyClassificationToMap(out)

            return out
        } catch (e) {
            console.error('Error in proportional symbols classification: ' + e.message)
            console.error(e)
        }
    }

    /**
     * @description assigns a color to each symbol, based on their statistical value
     * @param {*} map
     */
    function applyClassificationToMap(map) {
        if (map.svg_) {
            if (out.classifierColor_) {
                //assign color class to each symbol, based on their value
                // at this point, the symbol path hasnt been appended. Only the parent g element (.em-centroid)
                const colorData = map.statData('color')
                map.svg_.selectAll('.em-centroid').attr('ecl', function (rg) {
                    const sv = colorData.get(rg.properties.id)
                    if (!sv) {
                        return 'nd'
                    }
                    const v = sv.value
                    if ((v !== 0 && !v) || v == ':') {
                        return 'nd'
                    }
                    let c = +out.classifierColor_(+v)
                    return c
                })
            }
        }
    }

    /**
     * @description defines classifier functions (out.classifierColor and out.classifierSize) for both symbol size and color
     */
    function defineClassifiers() {
        // set default scale
        if (!out.psSizeScale_) {
            if (out.psShape_ == 'spike') {
                out.psSizeScale_ = 'linear'
            } else {
                out.psSizeScale_ = 'sqrt'
            }
        }

        //simply return the array [0,1,2,3,...,nb-1]
        const getA = function (nb) {
            return [...Array(nb).keys()]
        }

        // use size dataset
        let rawData = out.statData('size').getArray() || out.statData().getArray()
        let data = rawData.filter((d) => typeof d === 'number' && !isNaN(d) && isFinite(d))
        let [minVal, maxVal] = (0,d3_array__WEBPACK_IMPORTED_MODULE_5__["default"])(data)
        let min = out.psMinValue_ ?? minVal
        let max = out.psMaxValue_ ?? maxVal
        let sizeDomain = data ? [min, max] : [out.statData().getMin(), out.statData().getMax()]

        let scale = out.psSizeScale_ == 'sqrt' ? d3_scale__WEBPACK_IMPORTED_MODULE_6__.sqrt : d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"]
        out.classifierSize(scale().domain(sizeDomain).range([out.psMinSize_, out.psMaxSize_]))

        // colour
        if (out.statData('color').getArray()) {
            //use suitable classification type for colouring
            if (out.psClassificationMethod_ === 'quantile') {
                //https://github.com/d3/d3-scale#quantile-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])().domain(domain).range(range))
            } else if (out.psClassificationMethod_ === 'equinter') {
                //https://github.com/d3/d3-scale#quantize-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor(
                    (0,d3_scale__WEBPACK_IMPORTED_MODULE_9__["default"])()
                        .domain([min(domain), max(domain)])
                        .range(range)
                )
                if (out.makeClassifNice_) out.classifierColor().nice()
            } else if (out.psClassificationMethod_ === 'threshold') {
                //https://github.com/d3/d3-scale#threshold-scales
                out.psClasses(out.psThresholds().length + 1)
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(out.psThresholds()).range(range))
            }
        }
    }

    /**
     * Applies proportional symbol styling to a map object
     *
     * @param {*} map
     * @returns
     */
    function applyStyleToMap(map) {
        //see https://bl.ocks.org/mbostock/4342045 and https://bost.ocks.org/mike/bubble-map/
        //define style per class
        if (!out.psClassToFillStyle()) out.psClassToFillStyle(getColorLegend(out.psColorFun_, out.psColors_))

        // if size dataset not defined then use default
        let sizeData = map.statData('size').getArray() ? map.statData('size') : map.statData()

        if (map.svg_) {
            //clear previous centroids
            let prevSymbols = map.svg_.selectAll(':not(#em-insets-group) g.em-centroid > *')
            prevSymbols.remove()

            // 'small' centroids on top of big ones
            updateSymbolsDrawOrder(map)

            // append symbols to centroids
            let symb
            if (out.psCustomSVG_) {
                symb = appendCustomSymbolsToMap(map, sizeData)
            } else if (out.psShape_ == 'bar') {
                symb = appendBarsToMap(map, sizeData)
            } else if (out.psShape_ == 'circle') {
                symb = appendCirclesToMap(map, sizeData)
            } else if (out.psShape_ == 'spike') {
                symb = appendSpikesToMap(map, sizeData)
            } else {
                // circle, cross, star, triangle, diamond, square, wye or custom
                symb = appendD3SymbolsToMap(map, sizeData)
            }

            // dorling cartogram
            if (out.dorling_) {
                applyDorlingForce(map, sizeData)
            } else {
                if (out.simulation) stopSimulation()
            }

            appendLabelsToSymbols(map, sizeData)

            // set style of symbols
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)

            if (map.geo_ !== 'WORLD') {
                if (map.nutsLevel_ == 'mixed') {
                    addSymbolsToMixedNUTS(map, sizeData, regions)
                }

                // apply 'nd' class to no data regions for legend item hover
                regions.attr('ecl', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                        // NO INPUT
                        return 'ni'
                    } else if (sv && sv.value) {
                        if (sv.value == ':') {
                            // DATA NOT AVAILABLE (no data)
                            return 'nd'
                        }
                    }
                })
            }

            setSymbolStyles(symb)

            addMouseEvents(map)

            // Update labels for statistical values if required
            if (out.labels_?.values) {
                out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__.applyPatternFill)(map, out.patternFill_)
            }
        }
        return map
    }

    const appendLabelsToSymbols = function (map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')
        //country code labels
        if (out.psCodeLabels_) {
            const countryCodeLabel = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-code-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value === ':' ? '' : d.properties.id // Hide text if value is ':'
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    // size adjustment factor depends on symbol type, and whether stat values are also added to the circles
                    let factor = out.labels_?.values && sizeData.get(d.properties.id)?.value ? 0.8 : 0.9
                    if (out.psShape_ === 'square') factor = factor - 0.4
                    return `${radius * factor}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.labels_?.values && sizeData.get(d.properties.id)?.value ? '-0.3em' : '0'))
        }

        //stat labels
        if (out.labels_?.values) {
            const statLabels = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-stat-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    if (datum?.value) return datum.value
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    return `${radius * 0.4}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.psCodeLabels_ ? '0.6em' : '0'))
        }
    }

    const addMouseEvents = function (map) {
        let symbols = map.svg().selectAll('g.em-centroid')
        symbols
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.childNodes[0])
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.childNodes[0])
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', newFill)
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    /**
     * @description sets color/stroke/opacity styles of all symbols
     * @param {d3.selection} symb symbols d3 selection
     */
    function setSymbolStyles(symb) {
        symb.style('fill-opacity', out.psFillOpacity())
            .style('stroke', out.psStroke())
            .style('stroke-width', out.psStrokeWidth())
            .style('fill', function () {
                if (out.classifierColor_) {
                    //for ps, ecl attribute belongs to the parent g.em-centroid node created in map-template
                    const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.parentNode).attr('ecl')
                    if (!ecl || ecl === 'nd') return out.noDataFillStyle_ || 'gray'
                    let color = out.psClassToFillStyle_(ecl, out.psClasses_)
                    return color
                } else {
                    return out.psFill_
                }
            })
            .attr('fill___', function () {
                let fill = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this).style('fill')
                return fill // save for legend mouseover
            })
    }

    /**
     * @description Updates the draw order of the symbols according to their data values
     * @param {*} map map instance
     */
    function updateSymbolsDrawOrder(map) {
        const gcp = map.svg_.select('#em-prop-symbols')
        const sizeData = map.statData('size')?.getArray?.() ? map.statData('size') : map.statData()

        // 1. Filter and sort features with data
        if (map.Geometries.centroidFeatures) {
            const sorted = map.Geometries.centroidFeatures
                .filter((f) => {
                    const v = sizeData.get?.(f.properties.id)?.value
                    return v != null && v !== ':'
                })
                .sort((a, b) => {
                    return sizeData.get(b.properties.id).value - sizeData.get(a.properties.id).value
                })

            // 2. Clear and rebind
            gcp.selectAll('g.em-centroid').remove()

            gcp.selectAll('g.em-centroid')
                .data(sorted, (d) => d.properties.id)
                .enter()
                .append('g')
                .attr('class', 'em-centroid')
                .attr('id', (d) => 'ps' + d.properties.id)
                .attr('transform', (d) => `translate(${d.properties.centroid[0].toFixed(3)},${d.properties.centroid[1].toFixed(3)})`)

            // 3. add the ecl attribute back to the newly created g elements
            applyClassificationToMap(map) //
        }
    }

    function appendSpikesToMap(map, sizeData) {
        //The spike function creates a triangular path of the given length (height) with a base width of 7 pixels.
        const spike = (length, width = out.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        // Append circles to each symbol container
        const spikes = symbolContainers
            .append('path')
            .attr('d', (d) => {
                const datum = sizeData.get(d.properties.id)
                const value = datum ? out.classifierSize_(datum.value) : 0
                let path = spike(value)
                return path
            })
            .style('fill', (d) => d.color || 'steelblue') // Adjust color as needed
            //.attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)

        return spikes
    }

    /**
     * @description Appends <circle> elements for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData statistical data for size e.g. map.statData('size')
     * @return {void}
     */
    function appendCirclesToMap(map, sizeData) {
        // Append circles to each symbol container
        const circles = map
            .svg()
            .selectAll('g.em-centroid')
            .filter((d) => {
                const datum = sizeData.get(d.properties.id)
                if (d.properties.id == 'DE') console.log(datum)
                return datum && datum.value !== ':' && datum.value
            })
            .append('circle')
            .attr('r', function (d) {
                const datum = sizeData.get(d.properties.id)
                const radius = out.classifierSize_(datum.value)
                if (radius < 0) console.error('Negative radius for circle:', d.properties.id)
                if (isNaN(radius)) console.error('NaN radius for circle:', d.properties.id)
                return radius
            })

        return circles
    }

    function applyDorlingForce(map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        if (out.simulation) {
            stopSimulation()
        }

        // Initialize the force simulation
        console.log('new dorling simulation')
        out.simulation = (0,d3_force__WEBPACK_IMPORTED_MODULE_12__["default"])(map.Geometries.centroidFeatures)
            .force(
                'x',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_13__["default"])((d) => d.properties.centroid[0]).strength(out.dorlingStrength_.x) // Stronger pull to original x
            )
            .force(
                'y',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_14__["default"])((d) => d.properties.centroid[1]).strength(out.dorlingStrength_.y) // Stronger pull to original y
            )
            .force(
                'collide',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_15__["default"])((d) => {
                    const datum = sizeData.get(d.properties.id)
                    let size = datum ? out.classifierSize_(datum.value) : 0

                    if (out.psShape_ === 'square') {
                        return (size / 2) * Math.SQRT2 // Adjust for diagonal size
                    }

                    return size // Default for circles
                }).iterations(out.dorlingIterations_) // More iterations to improve collision handling
            )
            //.alphaTarget(0.3) // Helps keep centroids anchored
            .on('tick', () => {
                // Update elements with the new positions and radii
                symbolContainers.attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')')
            })

        //out.simulation.alpha(1).restart() // Ensures simulation starts with full strength
    }

    function stopSimulation() {
        out.simulation.stop() // Stops the internal tick loop
        out.simulation.on('tick', null) // Remove tick event listener
        out.simulation.on('end', null) // Remove end event listener
        out.simulation = null // Remove reference
    }

    /**
     * @description Appends <path> elements containing symbols for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendD3SymbolsToMap(map, sizeData) {
        return map
            .svg()
            .selectAll('g.em-centroid')
            .append('path')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .attr('d', (rg) => {
                //calculate size
                if (!sizeData) return
                const sv = sizeData.get(rg.properties.id)
                if (sv != 0 && !sv) return
                let size = out.classifierSize_(+sv.value) || 0

                //apply size to shape
                if (out.psCustomShape_) {
                    return out.psCustomShape_.size(size * size)()
                } else {
                    const symbolType = symbolsLibrary[out.psShape_] || symbolsLibrary['circle']
                    return (0,d3_shape__WEBPACK_IMPORTED_MODULE_16__["default"])()
                        .type(symbolType)
                        .size(size * size)()
                }
            })
    }

    /**
     * @description Appends <rect> elements containing bars for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendBarsToMap(map, sizeData) {
        return (
            map
                .svg()
                .select('#em-prop-symbols')
                .selectAll('g.em-centroid')
                .append('rect')
                .filter((rg) => {
                    const sv = sizeData.get(rg.properties.id)
                    if (sv && sv.value !== ':') return rg
                })
                .attr('width', out.psBarWidth_)
                //for vertical bars we scale the height attribute using the classifier
                .attr('height', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || !sv.value) {
                        return 0
                    }
                    let v = out.classifierSize_(+sv.value)
                    return v
                })
                .attr('transform', function () {
                    let bRect = this.getBoundingClientRect()
                    return `translate(${-this.getAttribute('width') / 2}` + `, -${this.getAttribute('height')})`
                })
            // to use transitions we need to refactor the drawing functions to promises e.g. appendBarsToMap().then(()=>{})
            //this is because .attr('fill___', function () {select(this).style('fill')}) doesnt work unless you execute it after the transition ends.
            // e.g.
            // .transition()
            // .duration(out.transitionDuration())
            // .style('fill', function (rg) {})
            // .end()
            // .then()
        )
    }

    /**
     * @description Appends custom SVG symbols for each region in the map
     * @param {*} map
     * @param {*} sizeData
     * @return {*}
     */
    function appendCustomSymbolsToMap(map, sizeData) {
        return map
            .svg()
            .select('#em-prop-symbols')
            .selectAll('g.em-centroid')
            .append('g')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .html(out.psCustomSVG_)
            .attr('transform', (rg) => {
                //calculate size
                const sv = sizeData.get(rg.properties.id)
                let size = out.classifierSize_(+sv.value)
                if (size) {
                    return `translate(${out.psOffset_.x * size},${out.psOffset_.y * size}) scale(${size})`
                }
            })
    }

    /**
     * @description adds proportional symbols to each regions in a map with mixed NUTS levels (IMAGE)
     * @param {*} map
     * @param {*} sizeData
     * @param {*} regions
     * @return {*}
     */
    function addSymbolsToMixedNUTS(map, sizeData, regions) {
        // toggle display of mixed NUTS levels
        regions.style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sv = sizeData.get(rg.properties.id)
            if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                // no symbol for no data
                return 'none'
            } else if (map.geo_ == 'WORLD') {
                return 'block'
            }
        })

        // nuts border stroke
        regions
            .style('stroke', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                const lvl = sel.attr('lvl')
                const stroke = sel.style('stroke')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else {
                    if (lvl !== '0') {
                        return stroke || '#777'
                    }
                }
            })

            // nuts border stroke width
            .style('stroke-width', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                const lvl = sel.attr('lvl')
                const strokeWidth = sel.style('stroke-width')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else if (out.geo_ == 'WORLD') {
                    if (lvl !== '0') {
                        return strokeWidth || '#777'
                    }
                }
            })
    }

    //@override
    out.updateStyle = function () {
        try {
            // apply to main map
            applyStyleToMap(out)

            // apply style to insets
            // apply classification to all insets
            if (out.insetTemplates_) {
                for (const geo in out.insetTemplates_) {
                    if (Array.isArray(out.insetTemplates_[geo])) {
                        for (var i = 0; i < out.insetTemplates_[geo].length; i++) {
                            // insets with same geo that do not share the same parent inset
                            if (Array.isArray(out.insetTemplates_[geo][i])) {
                                // this is the case when there are more than 2 different insets with the same geo. E.g. 3 insets for PT20
                                for (var c = 0; c < out.insetTemplates_[geo][i].length; c++) {
                                    if (out.insetTemplates_[geo][i][c].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i][c])
                                }
                            } else {
                                if (out.insetTemplates_[geo][i].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i])
                            }
                        }
                    } else {
                        // unique inset geo_
                        if (out.insetTemplates_[geo].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo])
                    }
                }
            }

            return out
        } catch (e) {
            console.error('Error in proportional symbols styling: ' + e.message)
            console.error(e)
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun, colorArray) {
    colorFun = colorFun || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}

/**
 * @description give a d3 symbol from a shape name
 */
const symbolsLibrary = {
    cross: d3_shape__WEBPACK_IMPORTED_MODULE_17__["default"],
    square: d3_shape__WEBPACK_IMPORTED_MODULE_18__["default"],
    diamond: d3_shape__WEBPACK_IMPORTED_MODULE_19__["default"],
    triangle: d3_shape__WEBPACK_IMPORTED_MODULE_20__["default"],
    star: d3_shape__WEBPACK_IMPORTED_MODULE_21__["default"],
    wye: d3_shape__WEBPACK_IMPORTED_MODULE_22__["default"],
    circle: d3_shape__WEBPACK_IMPORTED_MODULE_23__["default"],
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */

const tooltipTextFunPs = function (region, map) {
    if (map.tooltip_.omitRegions && map.tooltip_.omitRegions.includes(region.properties.id)) {
        return '' // Skip tooltip for omitted regions
    }
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    //stat 1 value
    const v1 = map.statData('size').getArray() ? map.statData('size') : map.statData()
    const sv1 = v1.get(region.properties.id)
    if (!sv1 || (sv1.value != 0 && !sv1.value)) {
        buf.push(map.noDataText_)
    } else {
        //unit 1
        const unit1 = v1.unitText()
        buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value)} ${unit1 ? unit1 : ' '}</div>`)
    }

    //stat 2 value
    if (map.statData('color').getArray()) {
        const sv2 = map.statData('color').get(region.properties.id)
        if (!sv2 || (sv2.value != 0 && !sv2.value)) buf.push(map.noDataText_)
        else {
            //stat 2
            const unit2 = map.statData('color').unitText()
            buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value)} ${unit2 ? unit2 : ' '}</div>`)
        }
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-sparklines.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-sparklines.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/create.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_stat_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/stat-data */ "./src/core/stat-data.js");









/**
 * Returns a sparkline map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'spark')

    out.sparkLineColor_ = 'black'
    out.sparkAreaColor_ = '#41afaa'
    out.sparkLineWidth_ = 30
    out.sparkLineHeight_ = 20
    out.sparkLineStrokeWidth_ = 0.4
    out.sparkLineOpacity_ = 0.6
    out.sparkType_ = 'line'
    out.sparkLineCircleRadius_ = 0
    out.sparkTooltipChart_ = {
        width: 100,
        height: 50,
        margin: { left: 60, right: 40, top: 40, bottom: 40 },
        circleRadius: 1.5,
    }

    //show sparklines only when data for all dates is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false
    out.sparkLineChartFunction_ = undefined

    out.statSpark_ = null
    out.sparkHeightClassifier_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'sparkLineColor_',
        'showOnlyWhenComplete_',
        'sparkType_',
        'sparkLineWidth_',
        'sparkLineHeight_',
        'sparkLineStrokeWidth_',
        'sparkLineOpacity_',
        'sparkLineCircleRadius_',
        'sparkLineAreaColor_',
        'sparkTooltipChart_',
        'sparkLineChartFunction_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'sparkLineColor',
            'showOnlyWhenComplete',
            'sparkType',
            'sparkLineWidth',
            'sparkLineHeight',
            'sparkLineStrokeWidth',
            'sparkLineOpacity',
            'sparkLineCircleRadius_',
            'sparkLineAreaColor',
            'sparkTooltipChart_',
            'sparkLineChartFunction_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    // Allow users manually add sparkline data
    out.sparklineData_ = undefined
    out.sparklineData = function (dataObject) {
        const dates = Object.keys(dataObject[Object.keys(dataObject)[0]])
        out._statDates = dates

        dates.forEach((date) => {
            const statData = _core_stat_data__WEBPACK_IMPORTED_MODULE_3__.statData()
            const perDateValues = {}

            for (const regionId in dataObject) {
                const regionValues = dataObject[regionId]
                perDateValues[regionId] = regionValues[date]
            }

            statData.setData(perDateValues)
            out.statData(date, statData)
        })

        return out
    }

    /**
     * A function to define a sparkline map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {Array} dates The dates of the composition (time parameter)
     * @param {Array} labels Optional: The labels for the dates
     */
    out.statSpark = function (stat, dates, labels) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < dates.length; i++) {
            //category code
            const date = dates[i]
            stat.filters.time = date
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(date, sc_)

            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[date] = labels[i]
            }
        }

        //set statCodes
        out._statDates = dates

        return out
    }

    /** The codes of the categories to consider for the composition. */
    out._statDates = undefined

    /**
     * Function to compute composition for region id, for each date.
     * Return an object with, for each date, its statistical value for the region
     * @param {*} id
     * @returns [{date,value}]
     */
    const getComposition = function (id) {
        let comp = [],
            sum = 0

        // Get stat value for each category and compute the sum.
        for (let i = 0; i < out._statDates.length; i++) {
            // Retrieve code and stat value
            const date = out._statDates[i]
            const s = out.statData(date).get(id)

            // Case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp.push({ date: date, value: s.value })
            sum += s.value
        }

        // Case when no data
        if (sum == 0) return undefined

        // Calculate year-on-year percentage change
        for (let i = 1; i < comp.length; i++) {
            const previousValue = comp[i - 1].value
            const currentValue = comp[i].value

            // Calculate percentage change from previous value
            comp[i].percentageChange = previousValue === 0 ? 0.001 : ((currentValue - previousValue) / previousValue) * 100
        }

        // The first data point doesn't have a previous value to compare with
        //comp[0].percentageChange = 0.001 // or you can leave it undefined or null, depending on how you want to handle it

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!out._statDates) {
            //get list of stat codes.
            out._statDates = Object.keys(out.statData_)
            //remove "default", if present
            const index = out._statDates.indexOf('default')
            if (index > -1) out._statDates.splice(index, 1)
        }

        // define size scaling function
        // Define the domain correctly for the log scale
        out.domain = getDatasetMaxMin() // Avoid 0 for log scale

        // for area charts
        out.widthClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__.sqrt)().domain(out.domain).range([0, out.sparkLineWidth_])
        out.heightClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__.sqrt)().domain(out.domain).range([0, out.sparkLineHeight_])

        return out
    }

    //@override
    out.updateStyle = function () {
        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of getting IDs
        let nutsIds = []
        let s = out.svg().selectAll('#em-prop-symbols')
        let sym = s.selectAll('g.em-centroid').attr('id', (rg) => {
            nutsIds.push(rg.properties.id)
            return 'spark_' + rg.properties.id
        })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    sel.attr('fill___', sel.style('fill'))
                    sel.style('fill', out.hoverColor_)
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                }
            })
            .on('mousemove', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                }
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        addSparkLinesToMap(nutsIds)
        return out
    }

    function addSparkLinesToMap(ids) {
        ids.forEach((nutsid) => {
            //create svg for sparkline
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let node = out.svg().select('#spark_' + nutsid)
            let data = getComposition(nutsid)

            if (data) {
                createSparkLineChart(node, data, out.sparkLineWidth_, out.sparkLineHeight_)
            }
        })
    }

    function createSparkLineChart(node, data, width, height, isForTooltip = false) {
        // call custom user function to draw the sparkline
        if (out.sparkLineChartFunction_ && out.sparkLineChartFunction_ !== createSparkLineChart) {
            return out.sparkLineChartFunction_(node, data, width, height, isForTooltip)
        }

        const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])()
            .domain([0, out._statDates.length - 1])
            .range([0.5, width - 0.5])

        const minValue = (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(data.map((d) => d.value)) || 0
        const maxValue = (0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(data.map((d) => d.value)) || 1

        const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])().domain([minValue, maxValue]).range([height, 0])

        const scaledData = data.map((d, i) => ({
            ...d,
            scaledXValue: xScale(i),
            scaledYValue: yScale(d.value),
        }))

        const zeroY = yScale(0)

        if (isForTooltip) {
            // X-axis at bottom
            node.append('g')
                .attr('class', 'axis-x')
                .attr('transform', `translate(0, ${height})`)
                .call(
                    (0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisBottom)(xScale)
                        .ticks(out._statDates.length)
                        .tickFormat((d, i) => out._statDates[i])
                )
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-65)')

            // Y-axis with raw value labels
            node.append('g').attr('class', 'axis-y').call((0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisLeft)(yScale).ticks(5))

            // Horizontal zero reference line → only if min < 0 and max > 0
            if (minValue < 0 && maxValue > 0) {
                node.append('line')
                    .attr('x1', 0)
                    .attr('x2', width)
                    .attr('y1', zeroY)
                    .attr('y2', zeroY)
                    .attr('stroke', 'gray')
                    .attr('stroke-dasharray', '2,2')
                    .attr('stroke-width', 1)
            }
        }

        const lineGenerator = (0,d3_shape__WEBPACK_IMPORTED_MODULE_10__["default"])()
            .x((d) => d.scaledXValue)
            .y((d) => d.scaledYValue)

        if (out.sparkType_ === 'area') {
            node.append('path')
                .datum(scaledData)
                .attr('fill', typeof out.sparkAreaColor_ === 'function' ? (d, i) => out.sparkAreaColor_(d, i) : out.sparkAreaColor_)
                .attr('stroke', 'none')
                .attr('opacity', out.sparkLineOpacity_)
                .attr('fill-opacity', 0.3)
                .attr(
                    'd',
                    (0,d3_shape__WEBPACK_IMPORTED_MODULE_11__["default"])()
                        .x((d) => d.scaledXValue)
                        .y0(zeroY)
                        .y1((d) => d.scaledYValue)
                )
        }

        node.append('path')
            .datum(scaledData)
            .attr('fill', 'none')
            .attr('opacity', out.sparkLineOpacity_)
            .attr('stroke', typeof out.sparkLineColor_ === 'function' ? (d, i) => out.sparkLineColor_(d, i) : out.sparkLineColor_)
            .attr(
                'stroke-width',
                typeof out.sparkLineStrokeWidth_ === 'function' ? (d, i) => out.sparkLineStrokeWidth_(d, i) : out.sparkLineStrokeWidth_ + 'px'
            )
            .attr('d', lineGenerator)

        node.selectAll('circle')
            .data(scaledData)
            .enter()
            .append('circle')
            .attr('cx', (d) => d.scaledXValue)
            .attr('cy', (d) => d.scaledYValue)
            .attr('r', out.sparkLineCircleRadius_)
            .attr('fill', 'red')
            .attr('stroke', 'none')
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (region, map) {
        const buf = []

        const regionName = region.properties.na
        const regionId = region.properties.id
        buf.push(`
                <div class="estat-vis-tooltip-bar">
                    <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
                </div>
            `)

        const chartHeight = out.sparkTooltipChart_.height
        const chartWidth = out.sparkTooltipChart_.width
        const margin = out.sparkTooltipChart_.margin
        const data = getComposition(region.properties.id)

        if (data) {
            // Total SVG size (including margins)
            const totalWidth = chartWidth + margin.left + margin.right
            const totalHeight = chartHeight + margin.top + margin.bottom

            // Create detached div
            const container = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('div').attr('class', 'em-tooltip-chart-container')

            // Create SVG with full size
            const svg = container.append('svg').attr('class', 'em-tooltip-chart-svg').attr('width', totalWidth).attr('height', totalHeight)

            // Inner group where chart is drawn
            const g = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`)

            // Call sparkline drawing on the inner area only
            createSparkLineChart(g, data, chartWidth, chartHeight, true)

            // Add result to tooltip buffer
            buf.push(container.node().outerHTML)
        }

        return buf.join('')
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum values of all dates for each region. Used to define the domain of the sparkline Y axis.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        const maxs = []
        const sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            const id = rg.properties.id
            const regionMax = getRegionMax(id)
            if (regionMax !== undefined) {
                maxs.push(regionMax)
            }
        })

        if (maxs.length === 0) {
            return [0, 1] // fallback if no data found
        }

        return (0,d3_array__WEBPACK_IMPORTED_MODULE_13__["default"])(maxs)
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionMax = function (id) {
        let max = 0

        // get stat value for each date and find the max
        for (let i = 0; i < out._statDates.length; i++) {
            const date = out._statDates[i]
            const statData = out.statData(date)

            if (!statData || typeof statData.get !== 'function') continue

            const s = statData.get(id)
            if (!s || (s.value !== 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                continue
            }

            if (s.value > max) max = s.value
        }

        if (max === 0) return undefined
        return max
    }

    //@override
    out.getLegendConstructor = function () {
        //TODO define legend
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun) {
    colorFun = colorFun || interpolateYlOrRd
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}


/***/ }),

/***/ "./src/maptypes/map-stripe-composition.js":
/*!************************************************!*\
  !*** ./src/maptypes/map-stripe-composition.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-stripe-composition */ "./src/legend/legend-stripe-composition.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



//schemeSet3 schemeDark2 schemePastel1 schemeTableau10



/**
 * Return a stripe composition map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'scomp')

    //width of the stripes serie
    out.stripeWidth_ = 50
    //orientation - vertical by default
    out.stripeOrientation_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    //show stripes only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    //tooltip pie chart
    out.pieChartRadius_ = 40
    out.pieChartInnerRadius_ = 15

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'stripeWidth_',
        'stripeOrientation_',
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieChartRadius_',
        'pieChartInnerRadius_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'stripeWidth',
            'stripeOrientation',
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieChartRadius',
            'pieChartInnerRadius',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /**
     * A function to define a stripe map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     */
    out.statComp = function (stat, dim, codes, labels, colors) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set statCodes
        statCodes = codes

        return out
    }

    /** The codes of the categories to consider for the composition. */
    let statCodes = undefined

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < statCodes.length; i++) {
            //retrieve code and stat value
            const sc = statCodes[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < statCodes.length; i++) comp[statCodes[i]] /= sum

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!statCodes) {
            //get list of stat codes.
            statCodes = Object.keys(out.statData_)
            //remove "default", if present
            const index = statCodes.indexOf('default')
            if (index > -1) statCodes.splice(index, 1)
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors()) {
            out.catColors({})
            for (let i = 0; i < statCodes.length; i++) out.catColors()[statCodes[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign texture to the regions
        out.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out))
            .style('fill', function (d) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const id = d.properties.id

                //compute composition
                const composition = getComposition(id)

                //case when no or missing data
                if (!composition) return out.noDataFillStyle() || 'gray'

                //make stripe pattern
                const patt = out
                    .svg()
                    .append('pattern')
                    .attr('id', 'pattern_' + id)
                    .attr('x', '0')
                    .attr('y', '0')
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .attr('patternUnits', 'userSpaceOnUse')
                //use orientation, if specified
                if (out.stripeOrientation()) patt.attr('patternTransform', 'rotate(' + out.stripeOrientation() + ')')

                //background
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .style('stroke', 'none')
                    .style('fill', 'lightgray')

                //make stripes, one per category
                let x = 0
                for (let code in composition) {
                    //get stripe size
                    let dx = composition[code]
                    if (!dx) continue
                    dx *= out.stripeWidth()

                    //get stripe color
                    const col = out.catColors()[code] || 'lightgray'

                    //add stripe to pattern: a thin rectangle
                    patt.append('rect')
                        .attr('x', x)
                        .attr('y', 0)
                        .attr('height', 1)
                        .style('stroke', 'none')
                        .attr('code', code)
                        .style('fill', col)
                        //transition along x
                        .transition()
                        .duration(out.transitionDuration())
                        .attr('width', dx)
                    x += dx
                }

                //return pattern reference
                return 'url(#pattern_' + id + ')'
            })
            .attr('nd', function (d) {
                return !getComposition(d.properties.id) ? 'nd' : ''
            })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        return out
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        //write region name
        const regionName = rg.properties.na || rg.properties.name
        if (rg.properties.id) {
            //name and code
            tp.append('div').html('<b>' + regionName + '</b> (' + rg.properties.id + ') <br>')
        } else {
            //region name
            tp.append('div').html('<b>' + regionName + '</b><br>')
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        const r = out.pieChartRadius(),
            ir = out.pieChartInnerRadius()
        const svg = tp
            .append('svg')
            .attr('viewBox', [-r, -r, 2 * r, 2 * r])
            .attr('width', 2 * r)

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_5__["default"])()
            .sort(null)
            .value((d) => d.value)
        svg.append('g')
            .attr('stroke', 'darkgray')
            .selectAll('path')
            .data(pie_(data))
            .join('path')
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().innerRadius(ir).outerRadius(r))
    }

    return out
}


/***/ }),

/***/ "./src/tooltip/tooltip.js":
/*!********************************!*\
  !*** ./src/tooltip/tooltip.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tooltip: () => (/* binding */ tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * @param {*} config
 * @returns
 */
const tooltip = function (config) {
    config = config || {}
    config.containerId = config.containerId || 'map'
    config.div = config.div || 'tooltip_eurostat'
    config.maxWidth = config.maxWidth || '200px'
    config.fontSize = config.fontSize || '14px'
    config.background = config.background || 'white'
    config.padding = config.padding || '0px'
    config.border = config.border || '0px'
    config.borderRadius = config.borderRadius || '0px'
    config.boxShadow = config.boxShadow || '0px 0px 0px grey'
    config.transitionDuration = config.transitionDuration || 0
    config.xOffset = config.xOffset || 30
    config.yOffset = config.yOffset || 20

    let tooltip

    function my() {
        tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + config.div)
        if (tooltip.empty()) tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('body').append('div').attr('id', config.div)

        tooltip.attr('class', 'tooltip-eurostat')
    }

    my.mouseover = function (html) {
        tooltip.html(html)
        if (html) {
            let x = event.pageX
            let y = event.pageY
            my.ensureTooltipOnScreen(x, y)
        }
    }

    my.mousemove = function (event) {
        let x = event.pageX
        let y = event.pageY
        this.ensureTooltipOnScreen(x, y)
    }

    my.mouseout = function () {
        tooltip.style('opacity', 0)
    }

    my.style = function (k, v) {
        if (arguments.length == 1) return tooltip.style(k)
        tooltip.style(k, v)
        return my
    }

    my.attr = function (k, v) {
        if (arguments.length == 1) return tooltip.attr(k)
        tooltip.attr(k, v)
        return my
    }

    /**
     * @function ensureTooltipOnScreen
     * @description Prevents the tooltip from overflowing off screen
     */
    my.ensureTooltipOnScreen = function (eventX, eventY) {
        tooltip.style('opacity', 1)
        let node = tooltip.node()

        node.style.left = eventX + config.xOffset + 'px'
        node.style.top = eventY - config.yOffset + 'px'

        let parent = document.getElementById(config.containerId)
        let rect = parent.getBoundingClientRect() // get the bounding rectangle
        let parentWidth = rect.width
        let parentHeight = rect.height

        //too far right
        //taking into account off screen space but shouldnt be
        if (node.offsetLeft > rect.left + parentWidth - node.clientWidth) {
            let left = eventX - node.clientWidth - config.xOffset
            node.style.left = left + 'px'
            // check if mouse covers tooltip
            if (node.offsetLeft + node.clientWidth > eventX) {
                //move tooltip left so it doesnt cover mouse
                let left2 = eventX - node.clientWidth - config.xOffset
                node.style.left = left2 + 'px'
            }
            // node.style.top = node.offsetTop + config.yOffset + "px";
        }

        //too far down
        if (node.offsetTop + node.clientHeight > rect.top + parentHeight) {
            node.style.top = node.offsetTop - node.clientHeight + 'px'
        }
    }

    my()
    return my
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.map),
/* harmony export */   version: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.version)
/* harmony export */ });
/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/index.css */ "./src/css/index.css");
/* harmony import */ var _eurostat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eurostat-map */ "./src/eurostat-map.js");


//export { statData } from "./core/stat-data.js";

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlGQUF5RixNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxVQUFVLE1BQU0sWUFBWSxPQUFPLFlBQVksTUFBTSxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxPQUFPLFlBQVksT0FBTyxVQUFVLFVBQVUsT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssVUFBVSxPQUFPLE1BQU0sVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFNLFdBQVcsa0RBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBUTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxvREFBTTs7QUFFcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFeUg7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsTWxIO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLGlCQUFpQixTQUFTLFlBQVk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLGlCQUFpQixTQUFTLFlBQVk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztVQ25HQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0F3QjtBQUNNO0FBQzlCLFdBQVcsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvTlVUUy5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL2Fubm90YXRpb25zLmNzcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvaW5kZXguY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9sYWJlbHMuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9sZWdlbmQuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9tYXAuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy90b29sdGlwLmNzcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3Mvd29ybGQuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Rlc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZnN1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZ3JlYXRlc3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21heC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4SW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lcmdlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21pbkluZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3Blcm11dGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1YW50aWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9xdWlja3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3NvcnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3N1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGlja3MuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXhpcy9zcmMvYXhpcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1heGlzL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2RlZmluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvbGFiLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2RyYWcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Nzdi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL3Rzdi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9jdWJpYy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvZHN2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZldGNoL3NyYy9qc29uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZldGNoL3NyYy90ZXh0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb2xsaWRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvamlnZ2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9sY2cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3NpbXVsYXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9kZWZhdWx0TG9jYWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZXhwb25lbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXREZWNpbWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0R3JvdXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXROdW1lcmFscy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFByZWZpeEF1dG8uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRSb3VuZGVkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0U3BlY2lmaWVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHJpbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFR5cGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9wcmVjaXNpb25GaXhlZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvblByZWZpeC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvblJvdW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZnN1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lcmdlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NhcnRlc2lhbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jaXJjbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9hbnRpbWVyaWRpYW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9jaXJjbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2xpbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9yZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9yZWpvaW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9tYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9ib3VuZHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcG9pbnRFcXVhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wb2x5Z29uQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9maXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL3Jlc2FtcGxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3JvdGF0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vc3JjL3JvYmluc29uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2FydGVzaWFuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jaXJjbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2FudGltZXJpZGlhbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvYnVmZmVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9jaXJjbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9yZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3Jlam9pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2dyYXRpY3VsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2FyZWEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2JvdW5kcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvY2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9tZWFzdXJlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wb2ludEVxdWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcG9seWdvbkNvbnRhaW5zLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hemltdXRoYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2ZpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9vcnRob2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL3Jlc2FtcGxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2FycmF5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXNDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2NvbG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvZGF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbGFiLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL251bWJlckFycmF5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3BpZWNld2lzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcmdiLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9yb3VuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vZGVjb21wb3NlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdmFsdWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcGF0aC9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvYWRkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9jb3Zlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZGF0YS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9maW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9xdWFkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9xdWFkdHJlZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcmVtb3ZlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9yb290LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9zaXplLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy92aXNpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvdmlzaXRBZnRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMveS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL2NhdGVnb3JpY2FsL1NldDMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9jYXRlZ29yaWNhbC9jYXRlZ29yeTEwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlLWNocm9tYXRpYy9zcmMvY29sb3JzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlLWNocm9tYXRpYy9zcmMvcmFtcC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL3NlcXVlbnRpYWwtbXVsdGkvT3JSZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL3NlcXVlbnRpYWwtbXVsdGkvWWxHbkJ1LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9iYW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29udGludW91cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5pdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbGluZWFyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL29yZGluYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3Bvdy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aXplLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aHJlc2hvbGQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL21hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXR0ci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NsYXNzZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xvbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXR1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VtcHR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VudGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2h0bWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5zZXJ0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbG93ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2Rlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yYWlzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zaXplLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3BhcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yQWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FyYy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJlYS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9idW1wLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2Rlc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5rLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9tYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9waWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3BvaW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludFJhZGlhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvYXN0ZXJpc2suanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jaXJjbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jcm9zcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9kaWFtb25kMi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3BsdXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zcXVhcmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zcXVhcmUyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3Rhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3RpbWVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC90cmlhbmdsZTIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC93eWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vaW5kZXhSb2xsdXBOZXh0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvc3JjL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvZHJhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2RyYWcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL25vZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbG9jYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tb3VzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NhbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NsYXNzZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Nsb25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXRhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXR1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VhY2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VtcHR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbnRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZXhpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9odG1sLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5zZXJ0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9qb2luLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9sb3dlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb3JkZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3Byb3BlcnR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yYWlzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmVtb3ZlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2l6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc29ydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3BhcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3RvckFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zb3VyY2VFdmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy90b3VjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy90b3VjaGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmVhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2Jhc2lzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpc09wZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9idW5kbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2FyZGluYWxPcGVuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tT3Blbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhckNsb3NlZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL21vbm90b25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbmF0dXJhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL3JhZGlhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL3N0ZXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvZXhwYW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb2Zmc2V0L25vbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvc2lsaG91ZXR0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC93aWdnbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9hc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvaW5zaWRlT3V0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvbm9uZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9waWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3JhZGlhbEFyZWEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9yYWRpYWxMaW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3RhY2suanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2Nyb3NzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3N0YXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lb3V0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW50ZXJydXB0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW50ZXJydXB0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0ci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHJUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2RlbGF5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9lYXNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZVZhcnlpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9lbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ludGVycG9sYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NjaGVkdWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zdHlsZVR3ZWVuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90d2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ldmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy96b29tLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2lkYi1rZXl2YWwvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9pbnRlcm5tYXAvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2pzb25zdGF0LXRvb2xraXQvaW1wb3J0Lm1qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmJveC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2ZlYXR1cmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9tZXNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbmVpZ2hib3JzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9yZXZlcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvc3RpdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdW50cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS9hbm5vdGF0aW9ucy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2NhcnRvZ3JhbXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS9kZXByZWNhdGVkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvZ2VvbWV0cmllcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2luc2V0cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2tvc292by5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2xhYmVscy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL21hcC10ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL21pbmltYXBzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvcGF0dGVybi1maWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvc3RhbXBzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvc3RhdC1kYXRhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvc3RhdC1tYXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS91dGlscy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvaW5kZXguY3NzP2Y3ZWEiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvZXVyb3N0YXQtbWFwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtY2F0ZWdvcmljYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLWJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGgtdHJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1mbG93LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtaGlzdG9ncmFtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcGF0dGVybi1maWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcGllY2hhcnRzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcHJvcG9ydGlvbmFsLXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1zdHJpcGUtY29tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9tYXB0eXBlcy9tYXAtY2F0ZWdvcmljYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWNob3JvcGxldGgtYml2YXJpYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLXRyaXZhcmlhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWNob3JvcGxldGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWZsb3cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXBpZWNoYXJ0cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXNwYXJrbGluZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXN0cmlwZS1jb21wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy90b29sdGlwL3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZXVyb3N0YXRtYXBcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXVyb3N0YXRtYXBcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC8qIFNUWUxJTkcgT0YgTlVUUyBSRUdJT05TIEFORCBCT1VOREFSSUVTICovXHJcbi8qIERlZmF1bHQgcmVnaW9uIGZpbGwgKi9cclxuLmVtLWNudHJnLFxyXG4uZW0tbnV0c3JnLFxyXG4uZW0tZ3JpZC1jZWxsIHtcclxuICAgIGZpbGw6ICNlMWUxZTE7XHJcbn1cclxuXHJcbi5lbS1udXRzcmcsXHJcbi5lbS1jbnRyZyxcclxuLmVtLWdyaWQtY2VsbCxcclxuI2VtLXVzZXItcmVnaW9ucyB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuXHJcbi8qICBib3VuZGFyaWVzIHN0cm9rZS13aWR0aCAqL1xyXG4uZW0tYm4tMCB7XHJcbiAgICBzdHJva2U6IG5vbmU7XHJcbn1cclxuLmVtLWJuLTEsXHJcbi5lbS1ibi0yLFxyXG4uZW0tYm4tMyxcclxuLyogd2hlbiB1c2luZyBNSVhFRCBOVVRTIGxldmVscywgd2UgYWRkIHN0cm9rZSB0byB0aGUgcmVnaW9ucywgdGhlbiBzaG93L2hpZGUgdGhvc2UgdGhhdCBoYXZlL2RvbnQgaGF2ZSBkYXRhICovXHJcbi5lbS1udXRzcmcgW2x2bD0nMyddLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcclxuLmVtLW51dHNyZyBbbHZsPScxJ10sXHJcbi5lbS1ibi1jbyB7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuMjtcclxufVxyXG5cclxuLyogYWxsIGJvdWRuYXJpZXMgYW5kIHJlZ2lvbnMgbGluZWNhcC9saW5lam9pbiAqL1xyXG4jZW0tbnV0c2JuLFxyXG4uZW0tY250Ym4sXHJcbi5lbS1ibi0wLFxyXG4uZW0tYm4tMSxcclxuLmVtLWJuLTIsXHJcbi5lbS1ibi0zLFxyXG4uZW0ta29zb3ZvLWJuLFxyXG4uZW0tYm4tY28sXHJcbi5lbS1udXRzcmcgW2x2bD0nMyddLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcclxuLmVtLW51dHNyZyBbbHZsPScxJ10sXHJcbi5lbS1jbnRyZyxcclxuLmVtLW51dHNyZyxcclxuLmVtLWdyaWQtY2VsbCB7XHJcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XHJcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xyXG59XHJcblxyXG4vKiBuYXRpb25hbCBib3VuZGFyaWVzICovXHJcbi5lbS1jbnRibiB7XHJcbiAgICBzdHJva2U6ICMwMDA7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuNnB4O1xyXG59XHJcblxyXG4vKiBOVVRTIGJvdW5kYXJpZXMgc3Ryb2tlIGNvbG9yICovXHJcbi5lbS1ibi0xLFxyXG4uZW0tYm4tMixcclxuLmVtLWJuLTMsXHJcbi5lbS1udXRzcmcgW2x2bD0nMyddLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcclxuLmVtLW51dHNyZyBbbHZsPScxJ10ge1xyXG4gICAgc3Ryb2tlOiAjNjk2OTY5O1xyXG59XHJcblxyXG4vKiBjb2FzdGFsIGJvdW5kYXJpZXMgKi9cclxuLmVtLWJuLWNvIHtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbn1cclxuXHJcbi8qIGtvc292byAqL1xyXG4uZW0ta29zb3ZvLWJuIHtcclxuICAgIHN0cm9rZTogIzAwMDtcclxuICAgIHN0cm9rZS13aWR0aDogMC4xNTtcclxufVxyXG5cclxuXHJcblxyXG4vKiBkb250IGZpbGwgY2VydGFpbiBlbGVtZW50cyAqL1xyXG4uZW0tZnJhbWUsXHJcbi5lbS1ncmF0aWN1bGUsXHJcbi5lbS1jbnRibixcclxuLmVtLWJuLTAsXHJcbi5lbS1ibi0xLFxyXG4uZW0tYm4tMixcclxuLmVtLWJuLTMsXHJcbi5lbS1rb3Nvdm8tYm4sXHJcbi5lbS1ibi1jbyB7XHJcbiAgICBmaWxsOiBub25lO1xyXG59XHJcblxyXG4vKiB0YXJnZXQgbm9uIGNjL2V1L2VmdGEgYm9yZGVycyAqL1xyXG4vKiAuZW0tYm4tb3RoOm5vdCguZW0tYm4tY28pOm5vdCguZW0tYm4tY2MpOm5vdCguZW0tYm4tZXUpOm5vdCguZW0tYm4tZWZ0YSkge1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xyXG59ICovXHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy9OVVRTLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSwyQ0FBMkM7QUFDM0Msd0JBQXdCO0FBQ3hCOzs7SUFHSSxhQUFhO0FBQ2pCOztBQUVBOzs7O0lBSUksZUFBZTtBQUNuQjs7QUFFQSw2QkFBNkI7QUFDN0I7SUFDSSxZQUFZO0FBQ2hCO0FBQ0E7Ozs7Ozs7O0lBUUksaUJBQWlCO0FBQ3JCOztBQUVBLGdEQUFnRDtBQUNoRDs7Ozs7Ozs7Ozs7Ozs7SUFjSSxxQkFBcUI7SUFDckIsc0JBQXNCO0FBQzFCOztBQUVBLHdCQUF3QjtBQUN4QjtJQUNJLFlBQVk7SUFDWixtQkFBbUI7QUFDdkI7O0FBRUEsaUNBQWlDO0FBQ2pDOzs7Ozs7SUFNSSxlQUFlO0FBQ25COztBQUVBLHVCQUF1QjtBQUN2QjtJQUNJLGFBQWE7QUFDakI7O0FBRUEsV0FBVztBQUNYO0lBQ0ksWUFBWTtJQUNaLGtCQUFrQjtBQUN0Qjs7OztBQUlBLCtCQUErQjtBQUMvQjs7Ozs7Ozs7O0lBU0ksVUFBVTtBQUNkOztBQUVBLGtDQUFrQztBQUNsQzs7R0FFR1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBTVFlMSU5HIE9GIE5VVFMgUkVHSU9OUyBBTkQgQk9VTkRBUklFUyAqL1xcclxcbi8qIERlZmF1bHQgcmVnaW9uIGZpbGwgKi9cXHJcXG4uZW0tY250cmcsXFxyXFxuLmVtLW51dHNyZyxcXHJcXG4uZW0tZ3JpZC1jZWxsIHtcXHJcXG4gICAgZmlsbDogI2UxZTFlMTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLW51dHNyZyxcXHJcXG4uZW0tY250cmcsXFxyXFxuLmVtLWdyaWQtY2VsbCxcXHJcXG4jZW0tdXNlci1yZWdpb25zIHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4vKiAgYm91bmRhcmllcyBzdHJva2Utd2lkdGggKi9cXHJcXG4uZW0tYm4tMCB7XFxyXFxuICAgIHN0cm9rZTogbm9uZTtcXHJcXG59XFxyXFxuLmVtLWJuLTEsXFxyXFxuLmVtLWJuLTIsXFxyXFxuLmVtLWJuLTMsXFxyXFxuLyogd2hlbiB1c2luZyBNSVhFRCBOVVRTIGxldmVscywgd2UgYWRkIHN0cm9rZSB0byB0aGUgcmVnaW9ucywgdGhlbiBzaG93L2hpZGUgdGhvc2UgdGhhdCBoYXZlL2RvbnQgaGF2ZSBkYXRhICovXFxyXFxuLmVtLW51dHNyZyBbbHZsPSczJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScyJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScxJ10sXFxyXFxuLmVtLWJuLWNvIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjI7XFxyXFxufVxcclxcblxcclxcbi8qIGFsbCBib3VkbmFyaWVzIGFuZCByZWdpb25zIGxpbmVjYXAvbGluZWpvaW4gKi9cXHJcXG4jZW0tbnV0c2JuLFxcclxcbi5lbS1jbnRibixcXHJcXG4uZW0tYm4tMCxcXHJcXG4uZW0tYm4tMSxcXHJcXG4uZW0tYm4tMixcXHJcXG4uZW0tYm4tMyxcXHJcXG4uZW0ta29zb3ZvLWJuLFxcclxcbi5lbS1ibi1jbyxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzEnXSxcXHJcXG4uZW0tY250cmcsXFxyXFxuLmVtLW51dHNyZyxcXHJcXG4uZW0tZ3JpZC1jZWxsIHtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBuYXRpb25hbCBib3VuZGFyaWVzICovXFxyXFxuLmVtLWNudGJuIHtcXHJcXG4gICAgc3Ryb2tlOiAjMDAwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuNnB4O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBOVVRTIGJvdW5kYXJpZXMgc3Ryb2tlIGNvbG9yICovXFxyXFxuLmVtLWJuLTEsXFxyXFxuLmVtLWJuLTIsXFxyXFxuLmVtLWJuLTMsXFxyXFxuLmVtLW51dHNyZyBbbHZsPSczJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScyJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScxJ10ge1xcclxcbiAgICBzdHJva2U6ICM2OTY5Njk7XFxyXFxufVxcclxcblxcclxcbi8qIGNvYXN0YWwgYm91bmRhcmllcyAqL1xcclxcbi5lbS1ibi1jbyB7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbi8qIGtvc292byAqL1xcclxcbi5lbS1rb3Nvdm8tYm4ge1xcclxcbiAgICBzdHJva2U6ICMwMDA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4xNTtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLyogZG9udCBmaWxsIGNlcnRhaW4gZWxlbWVudHMgKi9cXHJcXG4uZW0tZnJhbWUsXFxyXFxuLmVtLWdyYXRpY3VsZSxcXHJcXG4uZW0tY250Ym4sXFxyXFxuLmVtLWJuLTAsXFxyXFxuLmVtLWJuLTEsXFxyXFxuLmVtLWJuLTIsXFxyXFxuLmVtLWJuLTMsXFxyXFxuLmVtLWtvc292by1ibixcXHJcXG4uZW0tYm4tY28ge1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4vKiB0YXJnZXQgbm9uIGNjL2V1L2VmdGEgYm9yZGVycyAqL1xcclxcbi8qIC5lbS1ibi1vdGg6bm90KC5lbS1ibi1jbyk6bm90KC5lbS1ibi1jYyk6bm90KC5lbS1ibi1ldSk6bm90KC5lbS1ibi1lZnRhKSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMDtcXHJcXG59ICovXFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuZW0tYW5ub3RhdGlvbi1ncm91cCB7XHJcbiAgICAvKiBwb2ludGVyLWV2ZW50czogbm9uZTsgKi9cclxufVxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvYW5ub3RhdGlvbnMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksMEJBQTBCO0FBQzlCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5lbS1hbm5vdGF0aW9uLWdyb3VwIHtcXHJcXG4gICAgLyogcG9pbnRlci1ldmVudHM6IG5vbmU7ICovXFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9tYXAuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vdG9vbHRpcC5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzJfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWdlbmQuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8zX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGFiZWxzLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNF9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2Fubm90YXRpb25zLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNV9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL05VVFMuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF82X19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vd29ybGQuY3NzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMl9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfM19fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNV9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNl9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYFxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgI2VtLWxhYmVscyB7XHJcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xyXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IGNlbnRyYWw7XHJcbn1cclxuXHJcbi5lbS1sYWJlbCB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbn1cclxuLmVtLWxhYmVsLWJhY2tncm91bmQge1xyXG4gICAgZmlsbDogI2ZmZmZmZjtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG59XHJcbi5lbS1sYWJlbC1zaGFkb3cge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcbi5lbS1zdGF0LWxhYmVsIHtcclxuICAgIG9wYWNpdHk6IDE7XHJcbiAgICBmb250LXNpemU6IDEzcHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcclxuICAgIGZpbGw6ICMzMTMxMzE7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxufVxyXG4uZW0tc3RhdC1sYWJlbC1zaGFkb3cge1xyXG4gICAgb3BhY2l0eTogMTtcclxuICAgIGZvbnQtc2l6ZTogMTNweDtcclxuICAgIHN0cm9rZS13aWR0aDogNHB4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG4uZW0tbGFiZWwtY2Mge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgc3Ryb2tlOiAjNTA1MDUwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjVweDtcclxufVxyXG4uZW0tbGFiZWwtc2hhZG93LWNjIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcclxufVxyXG4uZW0tbGFiZWwtY291bnRyaWVzIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZTogIzUwNTA1MDtcclxuICAgIHN0cm9rZS13aWR0aDogMC41cHg7XHJcbn1cclxuLmVtLWxhYmVsLXNoYWRvdy1jb3VudHJpZXMge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xyXG59XHJcbi5lbS1sYWJlbC1zZWFzIHtcclxuICAgIGZvbnQtc2l6ZTogOXB4O1xyXG4gICAgZmlsbDogIzAwMzM5OTtcclxuICAgIHN0cm9rZTogIzAwMzM5OTtcclxuICAgIHN0cm9rZS13aWR0aDogMC4ycHg7XHJcbiAgICBsZXR0ZXItc3BhY2luZzogM3B4O1xyXG59XHJcbi5lbS1sYWJlbC1zaGFkb3ctc2VhcyB7XHJcbiAgICBmb250LXNpemU6IDlweDtcclxuICAgIGxldHRlci1zcGFjaW5nOiAzcHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XHJcbn1cclxuXHJcbi5lbS1mbG93LWxhYmVscyB7XHJcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xyXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IGNlbnRyYWw7XHJcbn1cclxuLmVtLWZsb3ctbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiAxM3B4O1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxufVxyXG4uZW0tZmxvdy1sYWJlbC1zaGFkb3cge1xyXG4gICAgZm9udC1zaXplOiAxM3B4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiA0cHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy9sYWJlbHMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksbUJBQW1CO0lBQ25CLHNCQUFzQjtJQUN0Qix5Q0FBeUM7SUFDekMsMEJBQTBCO0FBQzlCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjtBQUNBO0lBQ0ksYUFBYTtJQUNiLG9CQUFvQjtBQUN4QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixhQUFhO0FBQ2pCO0FBQ0E7SUFDSSxVQUFVO0lBQ1YsZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixhQUFhO0lBQ2IsaUJBQWlCO0FBQ3JCO0FBQ0E7SUFDSSxVQUFVO0lBQ1YsZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixhQUFhO0FBQ2pCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsZUFBZTtJQUNmLG1CQUFtQjtBQUN2QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGFBQWE7SUFDYixpQkFBaUI7QUFDckI7QUFDQTtJQUNJLGVBQWU7SUFDZixlQUFlO0lBQ2YsbUJBQW1CO0FBQ3ZCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsYUFBYTtJQUNiLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksY0FBYztJQUNkLGFBQWE7SUFDYixlQUFlO0lBQ2YsbUJBQW1CO0lBQ25CLG1CQUFtQjtBQUN2QjtBQUNBO0lBQ0ksY0FBYztJQUNkLG1CQUFtQjtJQUNuQixhQUFhO0lBQ2IsaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksbUJBQW1CO0lBQ25CLHNCQUFzQjtJQUN0Qix5Q0FBeUM7SUFDekMsMEJBQTBCO0FBQzlCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsV0FBVztJQUNYLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixhQUFhO0FBQ2pCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIiNlbS1sYWJlbHMge1xcclxcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbiAgICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IGNlbnRyYWw7XFxyXFxufVxcclxcblxcclxcbi5lbS1sYWJlbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLWJhY2tncm91bmQge1xcclxcbiAgICBmaWxsOiAjZmZmZmZmO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLXNoYWRvdyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxufVxcclxcbi5lbS1zdGF0LWxhYmVsIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcXHJcXG4gICAgZmlsbDogIzMxMzEzMTtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcbi5lbS1zdGF0LWxhYmVsLXNoYWRvdyB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiA0cHg7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1jYyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG4gICAgc3Ryb2tlOiAjNTA1MDUwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuNXB4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtc2hhZG93LWNjIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLWNvdW50cmllcyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG4gICAgc3Ryb2tlOiAjNTA1MDUwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuNXB4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtc2hhZG93LWNvdW50cmllcyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zZWFzIHtcXHJcXG4gICAgZm9udC1zaXplOiA5cHg7XFxyXFxuICAgIGZpbGw6ICMwMDMzOTk7XFxyXFxuICAgIHN0cm9rZTogIzAwMzM5OTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjJweDtcXHJcXG4gICAgbGV0dGVyLXNwYWNpbmc6IDNweDtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLXNoYWRvdy1zZWFzIHtcXHJcXG4gICAgZm9udC1zaXplOiA5cHg7XFxyXFxuICAgIGxldHRlci1zcGFjaW5nOiAzcHg7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tZmxvdy1sYWJlbHMge1xcclxcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbiAgICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IGNlbnRyYWw7XFxyXFxufVxcclxcbi5lbS1mbG93LWxhYmVsIHtcXHJcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcclxcbiAgICBmaWxsOiBibGFjaztcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcbi5lbS1mbG93LWxhYmVsLXNoYWRvdyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiA0cHg7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLmVtLWxlZ2VuZC1iYWNrZ3JvdW5kIHtcclxuICAgIGZpbGw6IHdoaXRlO1xyXG4gICAgb3BhY2l0eTogMC43O1xyXG4gICAgcng6IDA7XHJcbiAgICByeTogMDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG59XHJcbi5lbS1sZWdlbmQtbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiAxNXB4O1xyXG4gICAgc3Ryb2tlOiBub25lO1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbiAgICBkb21pbmFudC1iYXNlbGluZTogdW5zZXQ7XHJcbn1cclxuLmVtLWxlZ2VuZC10aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbiAgICBmaWxsOiBibGFjaztcclxufVxyXG4uZW0tbGVnZW5kLXNlcGFyYXRvciB7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xyXG59XHJcbi5lbS1sZWdlbmQtdGljayB7XHJcbiAgICBzdHJva2U6ICNkOGQ4ZDg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDE7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS1mcmFtZSB7XHJcbiAgICBmaWxsOiBub25lO1xyXG4gICAgc3Ryb2tlOiBibGFjaztcclxufVxyXG4uZW0tYml2YXJpYXRlLW5vZGF0YSB7XHJcbiAgICBzdHJva2U6IGJsYWNrO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjU7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS1heGlzLXRpdGxlIHtcclxuICAgIGZvbnQtc2l6ZTogMTVweDtcclxufVxyXG4uZW0tYml2YXJpYXRlLW5vZGF0YS1sYWJlbCB7XHJcbiAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtdGljayB7XHJcbiAgICBzdHJva2U6IGJsYWNrO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtdGljay1sYWJlbCB7XHJcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtc3F1YXJlLFxyXG4uZW0tbGVnZW5kLXJlY3Qge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG5cclxuLmVtLWJpdmFyaWF0ZS1zcXVhcmU6aG92ZXIsXHJcbi5lbS1sZWdlbmQtcmVjdDpob3ZlciB7XHJcbiAgICBzdHJva2Utd2lkdGg6IDI7XHJcbiAgICBzdHJva2U6IHJlZDtcclxufVxyXG5cclxuLmVtLXBpZS1zaXplLWxlZ2VuZC1saW5lIHtcclxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDI7XHJcbiAgICBzdHJva2U6IGdyZXk7XHJcbn1cclxuXHJcbi5lbS1sZWdlbmQtZGl2ZXJnaW5nLWxpbmUge1xyXG4gICAgc3Ryb2tlOiBibGFjaztcclxufVxyXG5cclxuLmVtLWxlZ2VuZC1oaXN0b2dyYW0tYmFyIHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvbGVnZW5kLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLFdBQVc7SUFDWCxZQUFZO0lBQ1osS0FBSztJQUNMLEtBQUs7SUFDTCxvQkFBb0I7QUFDeEI7QUFDQTtJQUNJLGVBQWU7SUFDZixZQUFZO0lBQ1osV0FBVztJQUNYLHdCQUF3QjtBQUM1QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLFdBQVc7QUFDZjtBQUNBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGVBQWU7SUFDZixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxVQUFVO0lBQ1YsYUFBYTtBQUNqQjtBQUNBO0lBQ0ksYUFBYTtJQUNiLGlCQUFpQjtJQUNqQixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxlQUFlO0FBQ25CO0FBQ0E7SUFDSSxlQUFlO0lBQ2YseUJBQXlCO0FBQzdCO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsZUFBZTtBQUNuQjtBQUNBO0lBQ0ksbUJBQW1CO0lBQ25CLGVBQWU7QUFDbkI7QUFDQTs7SUFFSSxlQUFlO0lBQ2YsYUFBYTtBQUNqQjs7QUFFQTs7SUFFSSxlQUFlO0lBQ2YsV0FBVztBQUNmOztBQUVBO0lBQ0ksbUJBQW1CO0lBQ25CLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSxhQUFhO0FBQ2pCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZW0tbGVnZW5kLWJhY2tncm91bmQge1xcclxcbiAgICBmaWxsOiB3aGl0ZTtcXHJcXG4gICAgb3BhY2l0eTogMC43O1xcclxcbiAgICByeDogMDtcXHJcXG4gICAgcnk6IDA7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4uZW0tbGVnZW5kLWxhYmVsIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbiAgICBzdHJva2U6IG5vbmU7XFxyXFxuICAgIGZpbGw6IGJsYWNrO1xcclxcbiAgICBkb21pbmFudC1iYXNlbGluZTogdW5zZXQ7XFxyXFxufVxcclxcbi5lbS1sZWdlbmQtdGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDE2cHg7XFxyXFxuICAgIGZpbGw6IGJsYWNrO1xcclxcbn1cXHJcXG4uZW0tbGVnZW5kLXNlcGFyYXRvciB7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMTtcXHJcXG59XFxyXFxuLmVtLWxlZ2VuZC10aWNrIHtcXHJcXG4gICAgc3Ryb2tlOiAjZDhkOGQ4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDE7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtZnJhbWUge1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbiAgICBzdHJva2U6IGJsYWNrO1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLW5vZGF0YSB7XFxyXFxuICAgIHN0cm9rZTogYmxhY2s7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC41O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtYXhpcy10aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS1ub2RhdGEtbGFiZWwge1xcclxcbiAgICBmb250LXNpemU6IDE0cHg7XFxyXFxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtdGljayB7XFxyXFxuICAgIHN0cm9rZTogYmxhY2s7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMTtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS10aWNrLWxhYmVsIHtcXHJcXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLXNxdWFyZSxcXHJcXG4uZW0tbGVnZW5kLXJlY3Qge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbi5lbS1iaXZhcmlhdGUtc3F1YXJlOmhvdmVyLFxcclxcbi5lbS1sZWdlbmQtcmVjdDpob3ZlciB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMjtcXHJcXG4gICAgc3Ryb2tlOiByZWQ7XFxyXFxufVxcclxcblxcclxcbi5lbS1waWUtc2l6ZS1sZWdlbmQtbGluZSB7XFxyXFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDI7XFxyXFxuICAgIHN0cm9rZTogZ3JleTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWxlZ2VuZC1kaXZlcmdpbmctbGluZSB7XFxyXFxuICAgIHN0cm9rZTogYmxhY2s7XFxyXFxufVxcclxcblxcclxcbi5lbS1sZWdlbmQtaGlzdG9ncmFtLWJhciB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAvKiBHZW5lcmFsIHRleHQgc2V0dGluZ3MgKi9cclxudGV4dCB7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG5cclxuYSB0ZXh0IHtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbn1cclxuXHJcbi8qIE1haW4gbWFwICovXHJcbi5lbS1tYXAsXHJcbi5lbS1sZWdlbmQge1xyXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XHJcbn1cclxuXHJcbi8qIENvYXN0YWwgbWFyZ2luICovXHJcbiNlbS1jb2FzdC1tYXJnaW4ge1xyXG4gICAgZmlsdGVyOiB1cmwoI2VtLWNvYXN0YWwtYmx1cik7XHJcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xyXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xyXG4gICAgZmlsbDogbm9uZTtcclxuICAgIHN0cm9rZS13aWR0aDogNTtcclxuICAgIHN0cm9rZTogcmdiKDE2MSwgMTk4LCAyMzcpO1xyXG59XHJcblxyXG4vKiBUaXRsZSBhbmQgc3VidGl0bGUgc3R5bGluZyAqL1xyXG4uZW0tdGl0bGUsXHJcbi5lbS1pbnNldC10aXRsZSB7XHJcbiAgICBmaWxsOiBibGFjaztcclxuICAgIHN0cm9rZTogbm9uZTtcclxufVxyXG5cclxuLmVtLXRpdGxlIHtcclxuICAgIGZvbnQtc2l6ZTogMjFweDtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG59XHJcblxyXG4uZW0taW5zZXQtdGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG59XHJcblxyXG4uZW0tc3VidGl0bGUsXHJcbi5lbS1pbnNldC1zdWJ0aXRsZSB7XHJcbiAgICBmaWxsOiAjODQ4MjgwO1xyXG4gICAgc3Ryb2tlOiBub25lO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxuICAgIHBhaW50LW9yZGVyOiBzdHJva2U7XHJcbn1cclxuXHJcbi5lbS1zdWJ0aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDE4cHg7XHJcbiAgICBmb250LXdlaWdodDogMTAwO1xyXG59XHJcblxyXG4uZW0taW5zZXQtc3VidGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG59XHJcblxyXG4uZW0tc291cmNlLXByZXRleHQge1xyXG4gICAgZm9udC1zaXplOiAxMXB4O1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTVweCwgLTVweCk7XHJcbn1cclxuLmVtLXNvdXJjZS1kYXRhc2V0LWxpbmsge1xyXG4gICAgZm9udC1zaXplOiAxMXB4O1xyXG4gICAgZmlsbDogIzBlNDdjYjtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTVweCwgLTVweCk7XHJcbn1cclxuLmVtLXNvdXJjZS1kYXRhc2V0LWxpbms6aG92ZXIge1xyXG4gICAgZmlsbDogIzA4MmI3YTtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG59XHJcblxyXG4uZW0tZnJhbWUge1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xyXG4gICAgc3Ryb2tlOiBncmV5O1xyXG59XHJcblxyXG4uZW0taW5zZXRzIC5lbS1mcmFtZSB7XHJcbiAgICAvKiB0aGlzIHdpbGwgZ2l2ZSBhIGZyYW1lIHRvIGluc2V0IG1hcHMgKi9cclxuICAgIHN0cm9rZTogZ3JleTtcclxuICAgIHN0cm9rZS13aWR0aDogMC4zcHggIWltcG9ydGFudDtcclxufVxyXG5cclxuLmVtLXNlYSB7XHJcbiAgICBmaWxsOiB3aGl0ZTtcclxuICAgIC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xyXG59XHJcbi5lbS1zY2FsZWJhci1saW5lIHtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuOHB4O1xyXG59XHJcbi5lbS1zY2FsZWJhci1sYWJlbCB7XHJcbiAgICBmb250LXNpemU6IDlweDtcclxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XHJcbn1cclxuXHJcbi8qIEJvdHRvbSB0ZXh0IGFuZCBzeW1ib2wgc3R5bGluZyAqL1xyXG4uZW0tZm9vdG5vdGUge1xyXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcclxuICAgIGN1cnNvcjogZGVmYXVsdDtcclxuICAgIGZvbnQtc2l6ZTogMTFweDtcclxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDVweCwgLTVweCk7XHJcbn1cclxuLmVtLWZvb3Rub3RlIGEge1xyXG4gICAgZmlsbDogIzBlNDdjYjtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG59XHJcbi5lbS1mb290bm90ZSBhOmhvdmVyIHtcclxuICAgIGZpbGw6ICMwYTMyOGU7XHJcbn1cclxuXHJcbi5lbS1jZW50cm9pZCB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuXHJcbi8qIEdyYXRpY3VsZSBzdHlsaW5nICovXHJcbi5lbS1ncmF0aWN1bGUge1xyXG4gICAgc3Ryb2tlOiBsaWdodGdyYXk7XHJcbiAgICBzdHJva2Utd2lkdGg6IDE7XHJcbn1cclxuXHJcbi5lbS1mbG93LWxpbmsge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcbi5lbS1mbG93LWxpbmstb3V0bGluZSB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuLmVtLWZsb3ctbGFiZWxzIHtcclxuICAgIGZvbnQtc2l6ZTogMTVweDtcclxuICAgIHN0cm9rZS13aWR0aDogMXB4O1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG4uZW0tZmxvdy1sYWJlbHMtaGFsbyB7XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDJweDtcclxuICAgIGZpbGw6IHdoaXRlO1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuXHJcbi5lbS1ncmlkLXJlY3QsXHJcbi5lbS1ncmlkLWhleGFnb24ge1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvbWFwLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSwwQkFBMEI7QUFDMUI7SUFDSSxvQkFBb0I7QUFDeEI7O0FBRUE7SUFDSSxtQkFBbUI7QUFDdkI7O0FBRUEsYUFBYTtBQUNiOztJQUVJLHlDQUF5QztBQUM3Qzs7QUFFQSxtQkFBbUI7QUFDbkI7SUFDSSw2QkFBNkI7SUFDN0Isc0JBQXNCO0lBQ3RCLHFCQUFxQjtJQUNyQixVQUFVO0lBQ1YsZUFBZTtJQUNmLDBCQUEwQjtBQUM5Qjs7QUFFQSwrQkFBK0I7QUFDL0I7O0lBRUksV0FBVztJQUNYLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjs7QUFFQTs7SUFFSSxhQUFhO0lBQ2IsWUFBWTtJQUNaLHNCQUFzQjtJQUN0QixtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjs7QUFFQTtJQUNJLGVBQWU7SUFDZixnQ0FBZ0M7QUFDcEM7QUFDQTtJQUNJLGVBQWU7SUFDZixhQUFhO0lBQ2IsZUFBZTtJQUNmLDBCQUEwQjtJQUMxQixnQ0FBZ0M7QUFDcEM7QUFDQTtJQUNJLGFBQWE7SUFDYixlQUFlO0lBQ2YsMEJBQTBCO0FBQzlCOztBQUVBO0lBQ0ksZUFBZTtJQUNmLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSx5Q0FBeUM7SUFDekMsWUFBWTtJQUNaLDhCQUE4QjtBQUNsQzs7QUFFQTtJQUNJLFdBQVc7SUFDWCwwQkFBMEI7QUFDOUI7QUFDQTtJQUNJLGFBQWE7SUFDYixtQkFBbUI7QUFDdkI7QUFDQTtJQUNJLGNBQWM7SUFDZCxtQkFBbUI7QUFDdkI7O0FBRUEsbUNBQW1DO0FBQ25DO0lBQ0ksbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixlQUFlO0lBQ2YsK0JBQStCO0FBQ25DO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsMEJBQTBCO0FBQzlCO0FBQ0E7SUFDSSxhQUFhO0FBQ2pCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjs7QUFFQSxzQkFBc0I7QUFDdEI7SUFDSSxpQkFBaUI7SUFDakIsZUFBZTtBQUNuQjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsV0FBVztJQUNYLG9CQUFvQjtBQUN4QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixXQUFXO0lBQ1gsb0JBQW9CO0FBQ3hCOztBQUVBOztJQUVJLGFBQWE7QUFDakJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogR2VuZXJhbCB0ZXh0IHNldHRpbmdzICovXFxyXFxudGV4dCB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG5hIHRleHQge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBNYWluIG1hcCAqL1xcclxcbi5lbS1tYXAsXFxyXFxuLmVtLWxlZ2VuZCB7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBDb2FzdGFsIG1hcmdpbiAqL1xcclxcbiNlbS1jb2FzdC1tYXJnaW4ge1xcclxcbiAgICBmaWx0ZXI6IHVybCgjZW0tY29hc3RhbC1ibHVyKTtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDU7XFxyXFxuICAgIHN0cm9rZTogcmdiKDE2MSwgMTk4LCAyMzcpO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBUaXRsZSBhbmQgc3VidGl0bGUgc3R5bGluZyAqL1xcclxcbi5lbS10aXRsZSxcXHJcXG4uZW0taW5zZXQtdGl0bGUge1xcclxcbiAgICBmaWxsOiBibGFjaztcXHJcXG4gICAgc3Ryb2tlOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tdGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDIxcHg7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0taW5zZXQtdGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxufVxcclxcblxcclxcbi5lbS1zdWJ0aXRsZSxcXHJcXG4uZW0taW5zZXQtc3VidGl0bGUge1xcclxcbiAgICBmaWxsOiAjODQ4MjgwO1xcclxcbiAgICBzdHJva2U6IG5vbmU7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxuICAgIHBhaW50LW9yZGVyOiBzdHJva2U7XFxyXFxufVxcclxcblxcclxcbi5lbS1zdWJ0aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWluc2V0LXN1YnRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tc291cmNlLXByZXRleHQge1xcclxcbiAgICBmb250LXNpemU6IDExcHg7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01cHgsIC01cHgpO1xcclxcbn1cXHJcXG4uZW0tc291cmNlLWRhdGFzZXQtbGluayB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXHJcXG4gICAgZmlsbDogIzBlNDdjYjtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTVweCwgLTVweCk7XFxyXFxufVxcclxcbi5lbS1zb3VyY2UtZGF0YXNldC1saW5rOmhvdmVyIHtcXHJcXG4gICAgZmlsbDogIzA4MmI3YTtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWZyYW1lIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xcclxcbiAgICBzdHJva2U6IGdyZXk7XFxyXFxufVxcclxcblxcclxcbi5lbS1pbnNldHMgLmVtLWZyYW1lIHtcXHJcXG4gICAgLyogdGhpcyB3aWxsIGdpdmUgYSBmcmFtZSB0byBpbnNldCBtYXBzICovXFxyXFxuICAgIHN0cm9rZTogZ3JleTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjNweCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tc2VhIHtcXHJcXG4gICAgZmlsbDogd2hpdGU7XFxyXFxuICAgIC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xcclxcbn1cXHJcXG4uZW0tc2NhbGViYXItbGluZSB7XFxyXFxuICAgIHN0cm9rZTogYmxhY2s7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC44cHg7XFxyXFxufVxcclxcbi5lbS1zY2FsZWJhci1sYWJlbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogOXB4O1xcclxcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBCb3R0b20gdGV4dCBhbmQgc3ltYm9sIHN0eWxpbmcgKi9cXHJcXG4uZW0tZm9vdG5vdGUge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoNXB4LCAtNXB4KTtcXHJcXG59XFxyXFxuLmVtLWZvb3Rub3RlIGEge1xcclxcbiAgICBmaWxsOiAjMGU0N2NiO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG59XFxyXFxuLmVtLWZvb3Rub3RlIGE6aG92ZXIge1xcclxcbiAgICBmaWxsOiAjMGEzMjhlO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tY2VudHJvaWQge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi8qIEdyYXRpY3VsZSBzdHlsaW5nICovXFxyXFxuLmVtLWdyYXRpY3VsZSB7XFxyXFxuICAgIHN0cm9rZTogbGlnaHRncmF5O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDE7XFxyXFxufVxcclxcblxcclxcbi5lbS1mbG93LWxpbmsge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcbi5lbS1mbG93LWxpbmstb3V0bGluZSB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGFiZWxzIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDFweDtcXHJcXG4gICAgZmlsbDogYmxhY2s7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4uZW0tZmxvdy1sYWJlbHMtaGFsbyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XFxyXFxuICAgIGZpbGw6IHdoaXRlO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWdyaWQtcmVjdCxcXHJcXG4uZW0tZ3JpZC1oZXhhZ29uIHtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuZXN0YXQtdmlzLXRvb2x0aXAtdGV4dCB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xyXG4gICAgY29sb3I6ICMxNzFhMjI7XHJcbiAgICBwYWRkaW5nOiA0cHg7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbn1cclxuLmVzdGF0LXZpcy10b29sdGlwLWJhciB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjNTE1NTYwO1xyXG4gICAgY29sb3I6ICNmZmZmZmY7XHJcbiAgICBwYWRkaW5nOiA2cHg7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbn1cclxuLnRvb2x0aXAtZXVyb3N0YXQge1xyXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsO1xyXG4gICAgbWF4LXdpZHRoOiAyNTBweDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICAgIHBhZGRpbmc6IDBweDtcclxuICAgIGJvcmRlcjogMHB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xyXG4gICAgYm94LXNoYWRvdzogMHB4IDRweCA2cHggcmdiYSgwLCAwLCAwLCAwLjEpLCAwcHggMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIG9wYWNpdHk6IDA7XHJcbiAgICB6LWluZGV4OiA5OTk5OTk5OTtcclxufVxyXG4uZW0tdG9vbHRpcC1waWVjaGFydC1icmVha2Rvd24ge1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIGZvbnQtc2l6ZTogMTRweDtcclxufVxyXG4uZW0tdG9vbHRpcC1waWVjaGFydC1jb250YWluZXIge1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy90b29sdGlwLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLG1CQUFtQjtJQUNuQixjQUFjO0lBQ2QsWUFBWTtJQUNaLGVBQWU7QUFDbkI7QUFDQTtJQUNJLG1CQUFtQjtJQUNuQixjQUFjO0lBQ2QsWUFBWTtJQUNaLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGtCQUFrQjtJQUNsQixnQkFBZ0I7SUFDaEIsZ0JBQWdCO0lBQ2hCLGlCQUFpQjtJQUNqQixZQUFZO0lBQ1osV0FBVztJQUNYLGtCQUFrQjtJQUNsQiwyRUFBMkU7SUFDM0Usa0JBQWtCO0lBQ2xCLHlDQUF5QztJQUN6QyxvQkFBb0I7SUFDcEIsVUFBVTtJQUNWLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGtCQUFrQjtBQUN0QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZXN0YXQtdmlzLXRvb2x0aXAtdGV4dCB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxyXFxuICAgIGNvbG9yOiAjMTcxYTIyO1xcclxcbiAgICBwYWRkaW5nOiA0cHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXHJcXG59XFxyXFxuLmVzdGF0LXZpcy10b29sdGlwLWJhciB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICM1MTU1NjA7XFxyXFxuICAgIGNvbG9yOiAjZmZmZmZmO1xcclxcbiAgICBwYWRkaW5nOiA2cHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXHJcXG59XFxyXFxuLnRvb2x0aXAtZXVyb3N0YXQge1xcclxcbiAgICBmb250LWZhbWlseTogQXJpYWw7XFxyXFxuICAgIG1heC13aWR0aDogMjUwcHg7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcclxcbiAgICBwYWRkaW5nOiAwcHg7XFxyXFxuICAgIGJvcmRlcjogMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAwcHg7XFxyXFxuICAgIGJveC1zaGFkb3c6IDBweCA0cHggNnB4IHJnYmEoMCwgMCwgMCwgMC4xKSwgMHB4IDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBmb250LWZhbWlseTogSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIHotaW5kZXg6IDk5OTk5OTk5O1xcclxcbn1cXHJcXG4uZW0tdG9vbHRpcC1waWVjaGFydC1icmVha2Rvd24ge1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgICBmb250LXNpemU6IDE0cHg7XFxyXFxufVxcclxcbi5lbS10b29sdGlwLXBpZWNoYXJ0LWNvbnRhaW5lciB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAjZ193b3JsZGJuLFxyXG4uZW0td29ybGRyZyxcclxuLmVtLXdvcmxkYm4ge1xyXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxufVxyXG5cclxuLmVtLXdvcmxkYm4ge1xyXG4gICAgc3Ryb2tlOiAjMDAwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjNweDtcclxufVxyXG5cclxuLmVtLXdvcmxkYm4ge1xyXG4gICAgZmlsbDogbm9uZTtcclxufVxyXG5cclxuLmVtLXdvcmxkcmcge1xyXG4gICAgZmlsbDogI2VmZWZlZjtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5cclxuLmVtLWJuLWQge1xyXG4gICAgLyogZGlzcHV0ZWQgKi9cclxuICAgIHN0cm9rZTogIzAwMDtcclxuICAgIHN0cm9rZS13aWR0aDogMC4xO1xyXG4gICAgZmlsbDogbm9uZTtcclxufVxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3Mvd29ybGQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7SUFHSSxxQkFBcUI7SUFDckIsc0JBQXNCO0FBQzFCOztBQUVBO0lBQ0ksWUFBWTtJQUNaLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLFVBQVU7QUFDZDs7QUFFQTtJQUNJLGFBQWE7SUFDYixlQUFlO0FBQ25COztBQUVBO0lBQ0ksYUFBYTtJQUNiLFlBQVk7SUFDWixpQkFBaUI7SUFDakIsVUFBVTtBQUNkXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIiNnX3dvcmxkYm4sXFxyXFxuLmVtLXdvcmxkcmcsXFxyXFxuLmVtLXdvcmxkYm4ge1xcclxcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxufVxcclxcblxcclxcbi5lbS13b3JsZGJuIHtcXHJcXG4gICAgc3Ryb2tlOiAjMDAwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuM3B4O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0td29ybGRibiB7XFxyXFxuICAgIGZpbGw6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5lbS13b3JsZHJnIHtcXHJcXG4gICAgZmlsbDogI2VmZWZlZjtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tYm4tZCB7XFxyXFxuICAgIC8qIGRpc3B1dGVkICovXFxyXFxuICAgIHN0cm9rZTogIzAwMDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjE7XFxyXFxuICAgIGZpbGw6IG5vbmU7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTtcblxuICAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT0gbnVsbCB8fCBiID09IG51bGwgPyBOYU4gOiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgYmlzZWN0b3IgZnJvbSBcIi4vYmlzZWN0b3IuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbmNvbnN0IGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG5leHBvcnQgY29uc3QgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG5leHBvcnQgY29uc3QgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuZXhwb3J0IGNvbnN0IGJpc2VjdENlbnRlciA9IGJpc2VjdG9yKG51bWJlcikuY2VudGVyO1xuZXhwb3J0IGRlZmF1bHQgYmlzZWN0UmlnaHQ7XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuaW1wb3J0IGRlc2NlbmRpbmcgZnJvbSBcIi4vZGVzY2VuZGluZy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaXNlY3RvcihmKSB7XG4gIGxldCBjb21wYXJlMSwgY29tcGFyZTIsIGRlbHRhO1xuXG4gIC8vIElmIGFuIGFjY2Vzc29yIGlzIHNwZWNpZmllZCwgcHJvbW90ZSBpdCB0byBhIGNvbXBhcmF0b3IuIEluIHRoaXMgY2FzZSB3ZVxuICAvLyBjYW4gdGVzdCB3aGV0aGVyIHRoZSBzZWFyY2ggdmFsdWUgaXMgKHNlbGYtKSBjb21wYXJhYmxlLiBXZSBjYW7igJl0IGRvIHRoaXNcbiAgLy8gZm9yIGEgY29tcGFyYXRvciAoZXhjZXB0IGZvciBzcGVjaWZpYywga25vd24gY29tcGFyYXRvcnMpIGJlY2F1c2Ugd2UgY2Fu4oCZdFxuICAvLyB0ZWxsIGlmIHRoZSBjb21wYXJhdG9yIGlzIHN5bW1ldHJpYywgYW5kIGFuIGFzeW1tZXRyaWMgY29tcGFyYXRvciBjYW7igJl0IGJlXG4gIC8vIHVzZWQgdG8gdGVzdCB3aGV0aGVyIGEgc2luZ2xlIHZhbHVlIGlzIGNvbXBhcmFibGUuXG4gIGlmIChmLmxlbmd0aCAhPT0gMikge1xuICAgIGNvbXBhcmUxID0gYXNjZW5kaW5nO1xuICAgIGNvbXBhcmUyID0gKGQsIHgpID0+IGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgICBkZWx0YSA9IChkLCB4KSA9PiBmKGQpIC0geDtcbiAgfSBlbHNlIHtcbiAgICBjb21wYXJlMSA9IGYgPT09IGFzY2VuZGluZyB8fCBmID09PSBkZXNjZW5kaW5nID8gZiA6IHplcm87XG4gICAgY29tcGFyZTIgPSBmO1xuICAgIGRlbHRhID0gZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8gPSAwLCBoaSA9IGEubGVuZ3RoKSB7XG4gICAgaWYgKGxvIDwgaGkpIHtcbiAgICAgIGlmIChjb21wYXJlMSh4LCB4KSAhPT0gMCkgcmV0dXJuIGhpO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlMihhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGhpID0gbWlkO1xuICAgICAgfSB3aGlsZSAobG8gPCBoaSk7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvID0gMCwgaGkgPSBhLmxlbmd0aCkge1xuICAgIGlmIChsbyA8IGhpKSB7XG4gICAgICBpZiAoY29tcGFyZTEoeCwgeCkgIT09IDApIHJldHVybiBoaTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA8PSAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9IHdoaWxlIChsbyA8IGhpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudGVyKGEsIHgsIGxvID0gMCwgaGkgPSBhLmxlbmd0aCkge1xuICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpO1xuICAgIHJldHVybiBpID4gbG8gJiYgZGVsdGEoYVtpIC0gMV0sIHgpID4gLWRlbHRhKGFbaV0sIHgpID8gaSAtIDEgOiBpO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0LCBjZW50ZXIsIHJpZ2h0fTtcbn1cblxuZnVuY3Rpb24gemVybygpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT0gbnVsbCB8fCBiID09IG51bGwgPyBOYU5cbiAgICA6IGIgPCBhID8gLTFcbiAgICA6IGIgPiBhID8gMVxuICAgIDogYiA+PSBhID8gMFxuICAgIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXh0ZW50KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBsZXQgbWF4O1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uL2NweXRob24vYmxvYi9hNzRlZWEyMzhmNWJhYmExNTc5N2UyZThiNTcwZDE1M2JjODY5MGE3L01vZHVsZXMvbWF0aG1vZHVsZS5jI0wxNDIzXG5leHBvcnQgY2xhc3MgQWRkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJ0aWFscyA9IG5ldyBGbG9hdDY0QXJyYXkoMzIpO1xuICAgIHRoaXMuX24gPSAwO1xuICB9XG4gIGFkZCh4KSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX3BhcnRpYWxzO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX24gJiYgaiA8IDMyOyBqKyspIHtcbiAgICAgIGNvbnN0IHkgPSBwW2pdLFxuICAgICAgICBoaSA9IHggKyB5LFxuICAgICAgICBsbyA9IE1hdGguYWJzKHgpIDwgTWF0aC5hYnMoeSkgPyB4IC0gKGhpIC0geSkgOiB5IC0gKGhpIC0geCk7XG4gICAgICBpZiAobG8pIHBbaSsrXSA9IGxvO1xuICAgICAgeCA9IGhpO1xuICAgIH1cbiAgICBwW2ldID0geDtcbiAgICB0aGlzLl9uID0gaSArIDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IG4gPSB0aGlzLl9uLCB4LCB5LCBsbywgaGkgPSAwO1xuICAgIGlmIChuID4gMCkge1xuICAgICAgaGkgPSBwWy0tbl07XG4gICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgeCA9IGhpO1xuICAgICAgICB5ID0gcFstLW5dO1xuICAgICAgICBoaSA9IHggKyB5O1xuICAgICAgICBsbyA9IHkgLSAoaGkgLSB4KTtcbiAgICAgICAgaWYgKGxvKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuID4gMCAmJiAoKGxvIDwgMCAmJiBwW24gLSAxXSA8IDApIHx8IChsbyA+IDAgJiYgcFtuIC0gMV0gPiAwKSkpIHtcbiAgICAgICAgeSA9IGxvICogMjtcbiAgICAgICAgeCA9IGhpICsgeTtcbiAgICAgICAgaWYgKHkgPT0geCAtIGhpKSBoaSA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgYWRkZXIgPSBuZXcgQWRkZXIoKTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlKSB7XG4gICAgICAgIGFkZGVyLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpIHtcbiAgICAgICAgYWRkZXIuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICthZGRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZjdW1zdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGNvbnN0IGFkZGVyID0gbmV3IEFkZGVyKCk7XG4gIGxldCBpbmRleCA9IC0xO1xuICByZXR1cm4gRmxvYXQ2NEFycmF5LmZyb20odmFsdWVzLCB2YWx1ZW9mID09PSB1bmRlZmluZWRcbiAgICAgID8gdiA9PiBhZGRlci5hZGQoK3YgfHwgMClcbiAgICAgIDogdiA9PiBhZGRlci5hZGQoK3ZhbHVlb2YodiwgKytpbmRleCwgdmFsdWVzKSB8fCAwKVxuICApO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JlYXRlc3QodmFsdWVzLCBjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIGxldCBtYXg7XG4gIGxldCBkZWZpbmVkID0gZmFsc2U7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbXBhcmUoZWxlbWVudCk7XG4gICAgICBpZiAoZGVmaW5lZFxuICAgICAgICAgID8gYXNjZW5kaW5nKHZhbHVlLCBtYXhWYWx1ZSkgPiAwXG4gICAgICAgICAgOiBhc2NlbmRpbmcodmFsdWUsIHZhbHVlKSA9PT0gMCkge1xuICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICBtYXhWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChkZWZpbmVkXG4gICAgICAgICAgPyBjb21wYXJlKHZhbHVlLCBtYXgpID4gMFxuICAgICAgICAgIDogY29tcGFyZSh2YWx1ZSwgdmFsdWUpID09PSAwKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICBkZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1heDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heEluZGV4KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWF4O1xuICBsZXQgbWF4SW5kZXggPSAtMTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgKytpbmRleDtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlLCBtYXhJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlLCBtYXhJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4SW5kZXg7XG59XG4iLCJmdW5jdGlvbiogZmxhdHRlbihhcnJheXMpIHtcbiAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcbiAgICB5aWVsZCogYXJyYXk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2UoYXJyYXlzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGZsYXR0ZW4oYXJyYXlzKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaW4odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaW5JbmRleCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1pbkluZGV4ID0gLTE7XG4gIGxldCBpbmRleCA9IC0xO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZSwgbWluSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZSwgbWluSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkluZGV4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBudW1iZXJzKHZhbHVlcywgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwZXJtdXRlKHNvdXJjZSwga2V5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShrZXlzLCBrZXkgPT4gc291cmNlW2tleV0pO1xufVxuIiwiaW1wb3J0IG1heCBmcm9tIFwiLi9tYXguanNcIjtcbmltcG9ydCBtYXhJbmRleCBmcm9tIFwiLi9tYXhJbmRleC5qc1wiO1xuaW1wb3J0IG1pbiBmcm9tIFwiLi9taW4uanNcIjtcbmltcG9ydCBtaW5JbmRleCBmcm9tIFwiLi9taW5JbmRleC5qc1wiO1xuaW1wb3J0IHF1aWNrc2VsZWN0IGZyb20gXCIuL3F1aWNrc2VsZWN0LmpzXCI7XG5pbXBvcnQgbnVtYmVyLCB7bnVtYmVyc30gZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge2FzY2VuZGluZ0RlZmluZWR9IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBncmVhdGVzdCBmcm9tIFwiLi9ncmVhdGVzdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSh2YWx1ZXMsIHAsIHZhbHVlb2YpIHtcbiAgdmFsdWVzID0gRmxvYXQ2NEFycmF5LmZyb20obnVtYmVycyh2YWx1ZXMsIHZhbHVlb2YpKTtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpIHx8IGlzTmFOKHAgPSArcCkpIHJldHVybjtcbiAgaWYgKHAgPD0gMCB8fCBuIDwgMikgcmV0dXJuIG1pbih2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gbWF4KHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gbWF4KHF1aWNrc2VsZWN0KHZhbHVlcywgaTApLnN1YmFycmF5KDAsIGkwICsgMSkpLFxuICAgICAgdmFsdWUxID0gbWluKHZhbHVlcy5zdWJhcnJheShpMCArIDEpKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGlsZVNvcnRlZCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpIHx8IGlzTmFOKHAgPSArcCkpIHJldHVybjtcbiAgaWYgKHAgPD0gMCB8fCBuIDwgMikgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLFxuICAgICAgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGlsZUluZGV4KHZhbHVlcywgcCwgdmFsdWVvZiA9IG51bWJlcikge1xuICBpZiAoaXNOYU4ocCA9ICtwKSkgcmV0dXJuO1xuICBudW1iZXJzID0gRmxvYXQ2NEFycmF5LmZyb20odmFsdWVzLCAoXywgaSkgPT4gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSk7XG4gIGlmIChwIDw9IDApIHJldHVybiBtaW5JbmRleChudW1iZXJzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuIG1heEluZGV4KG51bWJlcnMpO1xuICB2YXIgbnVtYmVycyxcbiAgICAgIGluZGV4ID0gVWludDMyQXJyYXkuZnJvbSh2YWx1ZXMsIChfLCBpKSA9PiBpKSxcbiAgICAgIGogPSBudW1iZXJzLmxlbmd0aCAtIDEsXG4gICAgICBpID0gTWF0aC5mbG9vcihqICogcCk7XG4gIHF1aWNrc2VsZWN0KGluZGV4LCBpLCAwLCBqLCAoaSwgaikgPT4gYXNjZW5kaW5nRGVmaW5lZChudW1iZXJzW2ldLCBudW1iZXJzW2pdKSk7XG4gIGkgPSBncmVhdGVzdChpbmRleC5zdWJhcnJheSgwLCBpICsgMSksIChpKSA9PiBudW1iZXJzW2ldKTtcbiAgcmV0dXJuIGkgPj0gMCA/IGkgOiAtMTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nRGVmaW5lZCwgY29tcGFyZURlZmluZWR9IGZyb20gXCIuL3NvcnQuanNcIjtcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcXVpY2tzZWxlY3Rcbi8vIElTQyBsaWNlbnNlLCBDb3B5cmlnaHQgMjAxOCBWbGFkaW1pciBBZ2Fmb25raW4uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWlja3NlbGVjdChhcnJheSwgaywgbGVmdCA9IDAsIHJpZ2h0ID0gSW5maW5pdHksIGNvbXBhcmUpIHtcbiAgayA9IE1hdGguZmxvb3Ioayk7XG4gIGxlZnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIGxlZnQpKTtcbiAgcmlnaHQgPSBNYXRoLmZsb29yKE1hdGgubWluKGFycmF5Lmxlbmd0aCAtIDEsIHJpZ2h0KSk7XG5cbiAgaWYgKCEobGVmdCA8PSBrICYmIGsgPD0gcmlnaHQpKSByZXR1cm4gYXJyYXk7XG5cbiAgY29tcGFyZSA9IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IGFzY2VuZGluZ0RlZmluZWQgOiBjb21wYXJlRGVmaW5lZChjb21wYXJlKTtcblxuICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgY29uc3QgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICBjb25zdCBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgY29uc3QgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICBjb25zdCBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGNvbnN0IG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgY29uc3QgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIHF1aWNrc2VsZWN0KGFycmF5LCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgfVxuXG4gICAgY29uc3QgdCA9IGFycmF5W2tdO1xuICAgIGxldCBpID0gbGVmdDtcbiAgICBsZXQgaiA9IHJpZ2h0O1xuXG4gICAgc3dhcChhcnJheSwgbGVmdCwgayk7XG4gICAgaWYgKGNvbXBhcmUoYXJyYXlbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyYXksIGxlZnQsIHJpZ2h0KTtcblxuICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgc3dhcChhcnJheSwgaSwgaiksICsraSwgLS1qO1xuICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyYXlbaV0sIHQpIDwgMCkgKytpO1xuICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyYXlbal0sIHQpID4gMCkgLS1qO1xuICAgIH1cblxuICAgIGlmIChjb21wYXJlKGFycmF5W2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnJheSwgbGVmdCwgaik7XG4gICAgZWxzZSArK2osIHN3YXAoYXJyYXksIGosIHJpZ2h0KTtcblxuICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBzd2FwKGFycmF5LCBpLCBqKSB7XG4gIGNvbnN0IHQgPSBhcnJheVtpXTtcbiAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgYXJyYXlbal0gPSB0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBwZXJtdXRlIGZyb20gXCIuL3Blcm11dGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc29ydCh2YWx1ZXMsIC4uLkYpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZXNbU3ltYm9sLml0ZXJhdG9yXSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsdWVzIGlzIG5vdCBpdGVyYWJsZVwiKTtcbiAgdmFsdWVzID0gQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICBsZXQgW2ZdID0gRjtcbiAgaWYgKChmICYmIGYubGVuZ3RoICE9PSAyKSB8fCBGLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBpbmRleCA9IFVpbnQzMkFycmF5LmZyb20odmFsdWVzLCAoZCwgaSkgPT4gaSk7XG4gICAgaWYgKEYubGVuZ3RoID4gMSkge1xuICAgICAgRiA9IEYubWFwKGYgPT4gdmFsdWVzLm1hcChmKSk7XG4gICAgICBpbmRleC5zb3J0KChpLCBqKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZiBvZiBGKSB7XG4gICAgICAgICAgY29uc3QgYyA9IGFzY2VuZGluZ0RlZmluZWQoZltpXSwgZltqXSk7XG4gICAgICAgICAgaWYgKGMpIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZiA9IHZhbHVlcy5tYXAoZik7XG4gICAgICBpbmRleC5zb3J0KChpLCBqKSA9PiBhc2NlbmRpbmdEZWZpbmVkKGZbaV0sIGZbal0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcm11dGUodmFsdWVzLCBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcy5zb3J0KGNvbXBhcmVEZWZpbmVkKGYpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVEZWZpbmVkKGNvbXBhcmUgPSBhc2NlbmRpbmcpIHtcbiAgaWYgKGNvbXBhcmUgPT09IGFzY2VuZGluZykgcmV0dXJuIGFzY2VuZGluZ0RlZmluZWQ7XG4gIGlmICh0eXBlb2YgY29tcGFyZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY29tcGFyZSBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgcmV0dXJuIChhLCBiKSA9PiB7XG4gICAgY29uc3QgeCA9IGNvbXBhcmUoYSwgYik7XG4gICAgaWYgKHggfHwgeCA9PT0gMCkgcmV0dXJuIHg7XG4gICAgcmV0dXJuIChjb21wYXJlKGIsIGIpID09PSAwKSAtIChjb21wYXJlKGEsIGEpID09PSAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzY2VuZGluZ0RlZmluZWQoYSwgYikge1xuICByZXR1cm4gKGEgPT0gbnVsbCB8fCAhKGEgPj0gYSkpIC0gKGIgPT0gbnVsbCB8fCAhKGIgPj0gYikpIHx8IChhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBzdW0gPSAwO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cbiIsImNvbnN0IGUxMCA9IE1hdGguc3FydCg1MCksXG4gICAgZTUgPSBNYXRoLnNxcnQoMTApLFxuICAgIGUyID0gTWF0aC5zcXJ0KDIpO1xuXG5mdW5jdGlvbiB0aWNrU3BlYyhzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgY29uc3Qgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoc3RlcCkpLFxuICAgICAgZXJyb3IgPSBzdGVwIC8gTWF0aC5wb3coMTAsIHBvd2VyKSxcbiAgICAgIGZhY3RvciA9IGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMTtcbiAgbGV0IGkxLCBpMiwgaW5jO1xuICBpZiAocG93ZXIgPCAwKSB7XG4gICAgaW5jID0gTWF0aC5wb3coMTAsIC1wb3dlcikgLyBmYWN0b3I7XG4gICAgaTEgPSBNYXRoLnJvdW5kKHN0YXJ0ICogaW5jKTtcbiAgICBpMiA9IE1hdGgucm91bmQoc3RvcCAqIGluYyk7XG4gICAgaWYgKGkxIC8gaW5jIDwgc3RhcnQpICsraTE7XG4gICAgaWYgKGkyIC8gaW5jID4gc3RvcCkgLS1pMjtcbiAgICBpbmMgPSAtaW5jO1xuICB9IGVsc2Uge1xuICAgIGluYyA9IE1hdGgucG93KDEwLCBwb3dlcikgKiBmYWN0b3I7XG4gICAgaTEgPSBNYXRoLnJvdW5kKHN0YXJ0IC8gaW5jKTtcbiAgICBpMiA9IE1hdGgucm91bmQoc3RvcCAvIGluYyk7XG4gICAgaWYgKGkxICogaW5jIDwgc3RhcnQpICsraTE7XG4gICAgaWYgKGkyICogaW5jID4gc3RvcCkgLS1pMjtcbiAgfVxuICBpZiAoaTIgPCBpMSAmJiAwLjUgPD0gY291bnQgJiYgY291bnQgPCAyKSByZXR1cm4gdGlja1NwZWMoc3RhcnQsIHN0b3AsIGNvdW50ICogMik7XG4gIHJldHVybiBbaTEsIGkyLCBpbmNdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aWNrcyhzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIGlmICghKGNvdW50ID4gMCkpIHJldHVybiBbXTtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wKSByZXR1cm4gW3N0YXJ0XTtcbiAgY29uc3QgcmV2ZXJzZSA9IHN0b3AgPCBzdGFydCwgW2kxLCBpMiwgaW5jXSA9IHJldmVyc2UgPyB0aWNrU3BlYyhzdG9wLCBzdGFydCwgY291bnQpIDogdGlja1NwZWMoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgaWYgKCEoaTIgPj0gaTEpKSByZXR1cm4gW107XG4gIGNvbnN0IG4gPSBpMiAtIGkxICsgMSwgdGlja3MgPSBuZXcgQXJyYXkobik7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKGluYyA8IDApIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB0aWNrc1tpXSA9IChpMiAtIGkpIC8gLWluYztcbiAgICBlbHNlIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB0aWNrc1tpXSA9IChpMiAtIGkpICogaW5jO1xuICB9IGVsc2Uge1xuICAgIGlmIChpbmMgPCAwKSBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgdGlja3NbaV0gPSAoaTEgKyBpKSAvIC1pbmM7XG4gICAgZWxzZSBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgdGlja3NbaV0gPSAoaTEgKyBpKSAqIGluYztcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgcmV0dXJuIHRpY2tTcGVjKHN0YXJ0LCBzdG9wLCBjb3VudClbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIGNvbnN0IHJldmVyc2UgPSBzdG9wIDwgc3RhcnQsIGluYyA9IHJldmVyc2UgPyB0aWNrSW5jcmVtZW50KHN0b3AsIHN0YXJ0LCBjb3VudCkgOiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gIHJldHVybiAocmV2ZXJzZSA/IC0xIDogMSkgKiAoaW5jIDwgMCA/IDEgLyAtaW5jIDogaW5jKTtcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG52YXIgdG9wID0gMSxcbiAgICByaWdodCA9IDIsXG4gICAgYm90dG9tID0gMyxcbiAgICBsZWZ0ID0gNCxcbiAgICBlcHNpbG9uID0gMWUtNjtcblxuZnVuY3Rpb24gdHJhbnNsYXRlWCh4KSB7XG4gIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwwKVwiO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVZKHkpIHtcbiAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyB5ICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIG51bWJlcihzY2FsZSkge1xuICByZXR1cm4gZCA9PiArc2NhbGUoZCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihzY2FsZSwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IE1hdGgubWF4KDAsIHNjYWxlLmJhbmR3aWR0aCgpIC0gb2Zmc2V0ICogMikgLyAyO1xuICBpZiAoc2NhbGUucm91bmQoKSkgb2Zmc2V0ID0gTWF0aC5yb3VuZChvZmZzZXQpO1xuICByZXR1cm4gZCA9PiArc2NhbGUoZCkgKyBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGVudGVyaW5nKCkge1xuICByZXR1cm4gIXRoaXMuX19heGlzO1xufVxuXG5mdW5jdGlvbiBheGlzKG9yaWVudCwgc2NhbGUpIHtcbiAgdmFyIHRpY2tBcmd1bWVudHMgPSBbXSxcbiAgICAgIHRpY2tWYWx1ZXMgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdCA9IG51bGwsXG4gICAgICB0aWNrU2l6ZUlubmVyID0gNixcbiAgICAgIHRpY2tTaXplT3V0ZXIgPSA2LFxuICAgICAgdGlja1BhZGRpbmcgPSAzLFxuICAgICAgb2Zmc2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgPyAwIDogMC41LFxuICAgICAgayA9IG9yaWVudCA9PT0gdG9wIHx8IG9yaWVudCA9PT0gbGVmdCA/IC0xIDogMSxcbiAgICAgIHggPSBvcmllbnQgPT09IGxlZnQgfHwgb3JpZW50ID09PSByaWdodCA/IFwieFwiIDogXCJ5XCIsXG4gICAgICB0cmFuc2Zvcm0gPSBvcmllbnQgPT09IHRvcCB8fCBvcmllbnQgPT09IGJvdHRvbSA/IHRyYW5zbGF0ZVggOiB0cmFuc2xhdGVZO1xuXG4gIGZ1bmN0aW9uIGF4aXMoY29udGV4dCkge1xuICAgIHZhciB2YWx1ZXMgPSB0aWNrVmFsdWVzID09IG51bGwgPyAoc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcy5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBzY2FsZS5kb21haW4oKSkgOiB0aWNrVmFsdWVzLFxuICAgICAgICBmb3JtYXQgPSB0aWNrRm9ybWF0ID09IG51bGwgPyAoc2NhbGUudGlja0Zvcm1hdCA/IHNjYWxlLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogaWRlbnRpdHkpIDogdGlja0Zvcm1hdCxcbiAgICAgICAgc3BhY2luZyA9IE1hdGgubWF4KHRpY2tTaXplSW5uZXIsIDApICsgdGlja1BhZGRpbmcsXG4gICAgICAgIHJhbmdlID0gc2NhbGUucmFuZ2UoKSxcbiAgICAgICAgcmFuZ2UwID0gK3JhbmdlWzBdICsgb2Zmc2V0LFxuICAgICAgICByYW5nZTEgPSArcmFuZ2VbcmFuZ2UubGVuZ3RoIC0gMV0gKyBvZmZzZXQsXG4gICAgICAgIHBvc2l0aW9uID0gKHNjYWxlLmJhbmR3aWR0aCA/IGNlbnRlciA6IG51bWJlcikoc2NhbGUuY29weSgpLCBvZmZzZXQpLFxuICAgICAgICBzZWxlY3Rpb24gPSBjb250ZXh0LnNlbGVjdGlvbiA/IGNvbnRleHQuc2VsZWN0aW9uKCkgOiBjb250ZXh0LFxuICAgICAgICBwYXRoID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbbnVsbF0pLFxuICAgICAgICB0aWNrID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEodmFsdWVzLCBzY2FsZSkub3JkZXIoKSxcbiAgICAgICAgdGlja0V4aXQgPSB0aWNrLmV4aXQoKSxcbiAgICAgICAgdGlja0VudGVyID0gdGljay5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKSxcbiAgICAgICAgbGluZSA9IHRpY2suc2VsZWN0KFwibGluZVwiKSxcbiAgICAgICAgdGV4dCA9IHRpY2suc2VsZWN0KFwidGV4dFwiKTtcblxuICAgIHBhdGggPSBwYXRoLm1lcmdlKHBhdGguZW50ZXIoKS5pbnNlcnQoXCJwYXRoXCIsIFwiLnRpY2tcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKSk7XG5cbiAgICB0aWNrID0gdGljay5tZXJnZSh0aWNrRW50ZXIpO1xuXG4gICAgbGluZSA9IGxpbmUubWVyZ2UodGlja0VudGVyLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJjdXJyZW50Q29sb3JcIilcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcikpO1xuXG4gICAgdGV4dCA9IHRleHQubWVyZ2UodGlja0VudGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiY3VycmVudENvbG9yXCIpXG4gICAgICAgIC5hdHRyKHgsIGsgKiBzcGFjaW5nKVxuICAgICAgICAuYXR0cihcImR5XCIsIG9yaWVudCA9PT0gdG9wID8gXCIwZW1cIiA6IG9yaWVudCA9PT0gYm90dG9tID8gXCIwLjcxZW1cIiA6IFwiMC4zMmVtXCIpKTtcblxuICAgIGlmIChjb250ZXh0ICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHBhdGggPSBwYXRoLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICB0aWNrID0gdGljay50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgbGluZSA9IGxpbmUudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIHRleHQgPSB0ZXh0LnRyYW5zaXRpb24oY29udGV4dCk7XG5cbiAgICAgIHRpY2tFeGl0ID0gdGlja0V4aXQudHJhbnNpdGlvbihjb250ZXh0KVxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBlcHNpbG9uKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGlzRmluaXRlKGQgPSBwb3NpdGlvbihkKSkgPyB0cmFuc2Zvcm0oZCArIG9mZnNldCkgOiB0aGlzLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTsgfSk7XG5cbiAgICAgIHRpY2tFbnRlclxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBlcHNpbG9uKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgdmFyIHAgPSB0aGlzLnBhcmVudE5vZGUuX19heGlzOyByZXR1cm4gdHJhbnNmb3JtKChwICYmIGlzRmluaXRlKHAgPSBwKGQpKSA/IHAgOiBwb3NpdGlvbihkKSkgKyBvZmZzZXQpOyB9KTtcbiAgICB9XG5cbiAgICB0aWNrRXhpdC5yZW1vdmUoKTtcblxuICAgIHBhdGhcbiAgICAgICAgLmF0dHIoXCJkXCIsIG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT09IHJpZ2h0XG4gICAgICAgICAgICA/ICh0aWNrU2l6ZU91dGVyID8gXCJNXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiLFwiICsgcmFuZ2UwICsgXCJIXCIgKyBvZmZzZXQgKyBcIlZcIiArIHJhbmdlMSArIFwiSFwiICsgayAqIHRpY2tTaXplT3V0ZXIgOiBcIk1cIiArIG9mZnNldCArIFwiLFwiICsgcmFuZ2UwICsgXCJWXCIgKyByYW5nZTEpXG4gICAgICAgICAgICA6ICh0aWNrU2l6ZU91dGVyID8gXCJNXCIgKyByYW5nZTAgKyBcIixcIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCJWXCIgKyBvZmZzZXQgKyBcIkhcIiArIHJhbmdlMSArIFwiVlwiICsgayAqIHRpY2tTaXplT3V0ZXIgOiBcIk1cIiArIHJhbmdlMCArIFwiLFwiICsgb2Zmc2V0ICsgXCJIXCIgKyByYW5nZTEpKTtcblxuICAgIHRpY2tcbiAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyYW5zZm9ybShwb3NpdGlvbihkKSArIG9mZnNldCk7IH0pO1xuXG4gICAgbGluZVxuICAgICAgICAuYXR0cih4ICsgXCIyXCIsIGsgKiB0aWNrU2l6ZUlubmVyKTtcblxuICAgIHRleHRcbiAgICAgICAgLmF0dHIoeCwgayAqIHNwYWNpbmcpXG4gICAgICAgIC50ZXh0KGZvcm1hdCk7XG5cbiAgICBzZWxlY3Rpb24uZmlsdGVyKGVudGVyaW5nKVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpXG4gICAgICAgIC5hdHRyKFwiZm9udC1zaXplXCIsIDEwKVxuICAgICAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsIFwic2Fucy1zZXJpZlwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIG9yaWVudCA9PT0gcmlnaHQgPyBcInN0YXJ0XCIgOiBvcmllbnQgPT09IGxlZnQgPyBcImVuZFwiIDogXCJtaWRkbGVcIik7XG5cbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7IHRoaXMuX19heGlzID0gcG9zaXRpb247IH0pO1xuICB9XG5cbiAgYXhpcy5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZSA9IF8sIGF4aXMpIDogc2NhbGU7XG4gIH07XG5cbiAgYXhpcy50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aWNrQXJndW1lbnRzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpLCBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0FyZ3VtZW50cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrQXJndW1lbnRzID0gXyA9PSBudWxsID8gW10gOiBBcnJheS5mcm9tKF8pLCBheGlzKSA6IHRpY2tBcmd1bWVudHMuc2xpY2UoKTtcbiAgfTtcblxuICBheGlzLnRpY2tWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1ZhbHVlcyA9IF8gPT0gbnVsbCA/IG51bGwgOiBBcnJheS5mcm9tKF8pLCBheGlzKSA6IHRpY2tWYWx1ZXMgJiYgdGlja1ZhbHVlcy5zbGljZSgpO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrRm9ybWF0ID0gXywgYXhpcykgOiB0aWNrRm9ybWF0O1xuICB9O1xuXG4gIGF4aXMudGlja1NpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVJbm5lciA9IHRpY2tTaXplT3V0ZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZUlubmVyO1xuICB9O1xuXG4gIGF4aXMudGlja1NpemVJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZUlubmVyID0gK18sIGF4aXMpIDogdGlja1NpemVJbm5lcjtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplT3V0ZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrUGFkZGluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrUGFkZGluZyA9ICtfLCBheGlzKSA6IHRpY2tQYWRkaW5nO1xuICB9O1xuXG4gIGF4aXMub2Zmc2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9ICtfLCBheGlzKSA6IG9mZnNldDtcbiAgfTtcblxuICByZXR1cm4gYXhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4aXNUb3Aoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXModG9wLCBzY2FsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzUmlnaHQoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXMocmlnaHQsIHNjYWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4aXNCb3R0b20oc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXMoYm90dG9tLCBzY2FsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzTGVmdChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhsZWZ0LCBzY2FsZSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2xvcigpIHt9XG5cbmV4cG9ydCB2YXIgZGFya2VyID0gMC43O1xuZXhwb3J0IHZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dPyg/OlxcXFxkKlxcXFwuKT9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIixcbiAgICByZVAgPSBcIlxcXFxzKihbKy1dPyg/OlxcXFxkKlxcXFwuKT9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKGBecmdiXFxcXCgke3JlSX0sJHtyZUl9LCR7cmVJfVxcXFwpJGApLFxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7cmVQfSwke3JlUH0sJHtyZVB9XFxcXCkkYCksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoYF5yZ2JhXFxcXCgke3JlSX0sJHtyZUl9LCR7cmVJfSwke3JlTn1cXFxcKSRgKSxcbiAgICByZVJnYmFQZXJjZW50ID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7cmVQfSwke3JlUH0sJHtyZVB9LCR7cmVOfVxcXFwpJGApLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5oc2xcXFxcKCR7cmVOfSwke3JlUH0sJHtyZVB9XFxcXCkkYCksXG4gICAgcmVIc2xhUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5oc2xhXFxcXCgke3JlTn0sJHtyZVB9LCR7cmVQfSwke3JlTn1cXFxcKSRgKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weShjaGFubmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCBjaGFubmVscyk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogY29sb3JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IGNvbG9yX2Zvcm1hdEhleCxcbiAgZm9ybWF0SGV4ODogY29sb3JfZm9ybWF0SGV4OCxcbiAgZm9ybWF0SHNsOiBjb2xvcl9mb3JtYXRIc2wsXG4gIGZvcm1hdFJnYjogY29sb3JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogY29sb3JfZm9ybWF0UmdiXG59KTtcblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4OCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4OCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gcmdiYShtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IHJnYmEoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZ2IoY2xhbXBpKHRoaXMuciksIGNsYW1waSh0aGlzLmcpLCBjbGFtcGkodGhpcy5iKSwgY2xhbXBhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKC0wLjUgPD0gdGhpcy5yICYmIHRoaXMuciA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmcgJiYgdGhpcy5nIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuYiAmJiB0aGlzLmIgPCAyNTUuNSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgaGV4OiByZ2JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IHJnYl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhleDg6IHJnYl9mb3JtYXRIZXg4LFxuICBmb3JtYXRSZ2I6IHJnYl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiByZ2JfZm9ybWF0UmdiXG59KSk7XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiBgIyR7aGV4KHRoaXMucil9JHtoZXgodGhpcy5nKX0ke2hleCh0aGlzLmIpfWA7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXg4KCkge1xuICByZXR1cm4gYCMke2hleCh0aGlzLnIpfSR7aGV4KHRoaXMuZyl9JHtoZXgodGhpcy5iKX0ke2hleCgoaXNOYU4odGhpcy5vcGFjaXR5KSA/IDEgOiB0aGlzLm9wYWNpdHkpICogMjU1KX1gO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0UmdiKCkge1xuICBjb25zdCBhID0gY2xhbXBhKHRoaXMub3BhY2l0eSk7XG4gIHJldHVybiBgJHthID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCJ9JHtjbGFtcGkodGhpcy5yKX0sICR7Y2xhbXBpKHRoaXMuZyl9LCAke2NsYW1waSh0aGlzLmIpfSR7YSA9PT0gMSA/IFwiKVwiIDogYCwgJHthfSlgfWA7XG59XG5cbmZ1bmN0aW9uIGNsYW1wYShvcGFjaXR5KSB7XG4gIHJldHVybiBpc05hTihvcGFjaXR5KSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvcGFjaXR5KSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1waSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IGNsYW1waSh2YWx1ZSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGNsYW1wKCkge1xuICAgIHJldHVybiBuZXcgSHNsKGNsYW1waCh0aGlzLmgpLCBjbGFtcHQodGhpcy5zKSwgY2xhbXB0KHRoaXMubCksIGNsYW1wYSh0aGlzLm9wYWNpdHkpKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbCgpIHtcbiAgICBjb25zdCBhID0gY2xhbXBhKHRoaXMub3BhY2l0eSk7XG4gICAgcmV0dXJuIGAke2EgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIn0ke2NsYW1waCh0aGlzLmgpfSwgJHtjbGFtcHQodGhpcy5zKSAqIDEwMH0lLCAke2NsYW1wdCh0aGlzLmwpICogMTAwfSUke2EgPT09IDEgPyBcIilcIiA6IGAsICR7YX0pYH1gO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIGNsYW1waCh2YWx1ZSkge1xuICB2YWx1ZSA9ICh2YWx1ZSB8fCAwKSAlIDM2MDtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IHZhbHVlICsgMzYwIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNsYW1wdCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUgfHwgMCkpO1xufVxuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdifSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWdyZWVzLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbi8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbmNvbnN0IEsgPSAxOCxcbiAgICBYbiA9IDAuOTY0MjIsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMC44MjUyMSxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gaGNsMmxhYihvKTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBuZXcgTGFiKGwsIDAsIDAsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBsYWJDb252ZXJ0KGwpIDogbmV3IExhYihsLCBhLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5hID0gK2E7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKExhYiwgbGFiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBscmdiMnJnYiggMy4xMzM4NTYxICogeCAtIDEuNjE2ODY2NyAqIHkgLSAwLjQ5MDYxNDYgKiB6KSxcbiAgICAgIGxyZ2IycmdiKC0wLjk3ODc2ODQgKiB4ICsgMS45MTYxNDE1ICogeSArIDAuMDMzNDU0MCAqIHopLFxuICAgICAgbHJnYjJyZ2IoIDAuMDcxOTQ1MyAqIHggLSAwLjIyODk5MTQgKiB5ICsgMS40MDUyNDI3ICogeiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24gbHJnYjJyZ2IoeCkge1xuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cblxuZnVuY3Rpb24gcmdiMmxyZ2IoeCkge1xuICByZXR1cm4gKHggLz0gMjU1KSA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gaGNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gbmV3IEhjbChvLmgsIG8uYywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XG4gIGlmIChvLmEgPT09IDAgJiYgby5iID09PSAwKSByZXR1cm4gbmV3IEhjbChOYU4sIDAgPCBvLmwgJiYgby5sIDwgMTAwID8gMCA6IE5hTiwgby5sLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogZGVncmVlcztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxjaChsLCBjLCBoLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChsKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5jID0gK2M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZnVuY3Rpb24gaGNsMmxhYihvKSB7XG4gIGlmIChpc05hTihvLmgpKSByZXR1cm4gbmV3IExhYihvLmwsIDAsIDAsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gby5oICogcmFkaWFucztcbiAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG59XG5cbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgcmV0dXJuIGhjbDJsYWIodGhpcykucmdiKCk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBjb25zdCByYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwiaW1wb3J0IHtzZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2V2ZW50LCB7bm9ucGFzc2l2ZWNhcHR1cmV9IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgaWYgKG5vY2xpY2spIHtcbiAgICBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcbiAgfVxuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gcm9vdC5fX25vc2VsZWN0O1xuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XG4gIH1cbn1cbiIsIi8vIFRoZXNlIGFyZSB0eXBpY2FsbHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG5vZXZlbnQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuXG4vLyBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZSA9IHtwYXNzaXZlOiBmYWxzZX07XG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZWNhcHR1cmUgPSB7Y2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogZmFsc2V9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJpbXBvcnQgZHN2IGZyb20gXCIuL2Rzdi5qc1wiO1xuXG52YXIgY3N2ID0gZHN2KFwiLFwiKTtcblxuZXhwb3J0IHZhciBjc3ZQYXJzZSA9IGNzdi5wYXJzZTtcbmV4cG9ydCB2YXIgY3N2UGFyc2VSb3dzID0gY3N2LnBhcnNlUm93cztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0ID0gY3N2LmZvcm1hdDtcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Qm9keSA9IGNzdi5mb3JtYXRCb2R5O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRSb3dzID0gY3N2LmZvcm1hdFJvd3M7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFJvdyA9IGNzdi5mb3JtYXRSb3c7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFZhbHVlID0gY3N2LmZvcm1hdFZhbHVlO1xuIiwidmFyIEVPTCA9IHt9LFxuICAgIEVPRiA9IHt9LFxuICAgIFFVT1RFID0gMzQsXG4gICAgTkVXTElORSA9IDEwLFxuICAgIFJFVFVSTiA9IDEzO1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdIHx8IFxcXCJcXFwiXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgd2lkdGgpIHtcbiAgdmFyIHMgPSB2YWx1ZSArIFwiXCIsIGxlbmd0aCA9IHMubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKDApICsgcyA6IHM7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciA8IDAgPyBcIi1cIiArIHBhZCgteWVhciwgNilcbiAgICA6IHllYXIgPiA5OTk5ID8gXCIrXCIgKyBwYWQoeWVhciwgNilcbiAgICA6IHBhZCh5ZWFyLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKSxcbiAgICAgIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IFwiSW52YWxpZCBEYXRlXCJcbiAgICAgIDogZm9ybWF0WWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDQpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ0RhdGUoKSwgMilcbiAgICAgICsgKG1pbGxpc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIi5cIiArIHBhZChtaWxsaXNlY29uZHMsIDMpICsgXCJaXCJcbiAgICAgIDogc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIlpcIlxuICAgICAgOiBtaW51dGVzIHx8IGhvdXJzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIlpcIlxuICAgICAgOiBcIlwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVsaW1pdGVyKSB7XG4gIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5cXHJdXCIpLFxuICAgICAgREVMSU1JVEVSID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgZnVuY3Rpb24gcGFyc2UodGV4dCwgZikge1xuICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gcGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgaWYgKGNvbnZlcnQpIHJldHVybiBjb252ZXJ0KHJvdywgaSAtIDEpO1xuICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgIH0pO1xuICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnMgfHwgW107XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgIHZhciByb3dzID0gW10sIC8vIG91dHB1dCByb3dzXG4gICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgSSA9IDAsIC8vIGN1cnJlbnQgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgIG4gPSAwLCAvLyBjdXJyZW50IGxpbmUgbnVtYmVyXG4gICAgICAgIHQsIC8vIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgZW9mID0gTiA8PSAwLCAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPRj9cbiAgICAgICAgZW9sID0gZmFsc2U7IC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgLy8gU3RyaXAgdGhlIHRyYWlsaW5nIG5ld2xpbmUuXG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IE5FV0xJTkUpIC0tTjtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gUkVUVVJOKSAtLU47XG5cbiAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgIGlmIChlb2YpIHJldHVybiBFT0Y7XG4gICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcblxuICAgICAgLy8gVW5lc2NhcGUgcXVvdGVzLlxuICAgICAgdmFyIGksIGogPSBJLCBjO1xuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gUVVPVEUpIHtcbiAgICAgICAgd2hpbGUgKEkrKyA8IE4gJiYgdGV4dC5jaGFyQ29kZUF0KEkpICE9PSBRVU9URSB8fCB0ZXh0LmNoYXJDb2RlQXQoKytJKSA9PT0gUVVPVEUpO1xuICAgICAgICBpZiAoKGkgPSBJKSA+PSBOKSBlb2YgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSAtIDEpLnJlcGxhY2UoL1wiXCIvZywgXCJcXFwiXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmUuXG4gICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KGkgPSBJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSBERUxJTUlURVIpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGxhc3QgdG9rZW4gYmVmb3JlIEVPRi5cbiAgICAgIHJldHVybiBlb2YgPSB0cnVlLCB0ZXh0LnNsaWNlKGosIE4pO1xuICAgIH1cblxuICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSByb3cucHVzaCh0KSwgdCA9IHRva2VuKCk7XG4gICAgICBpZiAoZiAmJiAocm93ID0gZihyb3csIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XG4gICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIFtjb2x1bW5zLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpXS5jb25jYXQocHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiXG4gICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZm9ybWF0RGF0ZSh2YWx1ZSlcbiAgICAgICAgOiByZUZvcm1hdC50ZXN0KHZhbHVlICs9IFwiXCIpID8gXCJcXFwiXCIgKyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHBhcnNlUm93czogcGFyc2VSb3dzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZvcm1hdEJvZHk6IGZvcm1hdEJvZHksXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93cyxcbiAgICBmb3JtYXRSb3c6IGZvcm1hdFJvdyxcbiAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWVcbiAgfTtcbn1cbiIsImltcG9ydCBkc3YgZnJvbSBcIi4vZHN2LmpzXCI7XG5cbnZhciB0c3YgPSBkc3YoXCJcXHRcIik7XG5cbmV4cG9ydCB2YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG5leHBvcnQgdmFyIHRzdlBhcnNlUm93cyA9IHRzdi5wYXJzZVJvd3M7XG5leHBvcnQgdmFyIHRzdkZvcm1hdCA9IHRzdi5mb3JtYXQ7XG5leHBvcnQgdmFyIHRzdkZvcm1hdEJvZHkgPSB0c3YuZm9ybWF0Qm9keTtcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Um93cyA9IHRzdi5mb3JtYXRSb3dzO1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRSb3cgPSB0c3YuZm9ybWF0Um93O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRWYWx1ZSA9IHRzdi5mb3JtYXRWYWx1ZTtcbiIsImV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufVxuIiwiaW1wb3J0IHtjc3ZQYXJzZSwgZHN2Rm9ybWF0LCB0c3ZQYXJzZX0gZnJvbSBcImQzLWRzdlwiO1xuaW1wb3J0IHRleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuXG5mdW5jdGlvbiBkc3ZQYXJzZShwYXJzZSkge1xuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGluaXQsIHJvdykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBwYXJzZShyZXNwb25zZSwgcm93KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZHN2KGRlbGltaXRlciwgaW5wdXQsIGluaXQsIHJvdykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgaW5pdCA9PT0gXCJmdW5jdGlvblwiKSByb3cgPSBpbml0LCBpbml0ID0gdW5kZWZpbmVkO1xuICB2YXIgZm9ybWF0ID0gZHN2Rm9ybWF0KGRlbGltaXRlcik7XG4gIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZvcm1hdC5wYXJzZShyZXNwb25zZSwgcm93KTtcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgY3N2ID0gZHN2UGFyc2UoY3N2UGFyc2UpO1xuZXhwb3J0IHZhciB0c3YgPSBkc3ZQYXJzZSh0c3ZQYXJzZSk7XG4iLCJmdW5jdGlvbiByZXNwb25zZUpzb24ocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNSkgcmV0dXJuO1xuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VKc29uKTtcbn1cbiIsImZ1bmN0aW9uIHJlc3BvbnNlVGV4dChyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlVGV4dCk7XG59XG4iLCJpbXBvcnQge3F1YWR0cmVlfSBmcm9tIFwiZDMtcXVhZHRyZWVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGppZ2dsZSBmcm9tIFwiLi9qaWdnbGUuanNcIjtcblxuZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLnggKyBkLnZ4O1xufVxuXG5mdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueSArIGQudnk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhZGl1cykge1xuICB2YXIgbm9kZXMsXG4gICAgICByYWRpaSxcbiAgICAgIHJhbmRvbSxcbiAgICAgIHN0cmVuZ3RoID0gMSxcbiAgICAgIGl0ZXJhdGlvbnMgPSAxO1xuXG4gIGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHJhZGl1cyA9IGNvbnN0YW50KHJhZGl1cyA9PSBudWxsID8gMSA6ICtyYWRpdXMpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICB0cmVlLFxuICAgICAgICBub2RlLFxuICAgICAgICB4aSxcbiAgICAgICAgeWksXG4gICAgICAgIHJpLFxuICAgICAgICByaTI7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xuICAgICAgdHJlZSA9IHF1YWR0cmVlKG5vZGVzLCB4LCB5KS52aXNpdEFmdGVyKHByZXBhcmUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHJpID0gcmFkaWlbbm9kZS5pbmRleF0sIHJpMiA9IHJpICogcmk7XG4gICAgICAgIHhpID0gbm9kZS54ICsgbm9kZS52eDtcbiAgICAgICAgeWkgPSBub2RlLnkgKyBub2RlLnZ5O1xuICAgICAgICB0cmVlLnZpc2l0KGFwcGx5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseShxdWFkLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgdmFyIGRhdGEgPSBxdWFkLmRhdGEsIHJqID0gcXVhZC5yLCByID0gcmkgKyByajtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmluZGV4ID4gbm9kZS5pbmRleCkge1xuICAgICAgICAgIHZhciB4ID0geGkgLSBkYXRhLnggLSBkYXRhLnZ4LFxuICAgICAgICAgICAgICB5ID0geWkgLSBkYXRhLnkgLSBkYXRhLnZ5LFxuICAgICAgICAgICAgICBsID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgICBpZiAobCA8IHIgKiByKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUocmFuZG9tKSwgbCArPSB5ICogeTtcbiAgICAgICAgICAgIGwgPSAociAtIChsID0gTWF0aC5zcXJ0KGwpKSkgLyBsICogc3RyZW5ndGg7XG4gICAgICAgICAgICBub2RlLnZ4ICs9ICh4ICo9IGwpICogKHIgPSAocmogKj0gcmopIC8gKHJpMiArIHJqKSk7XG4gICAgICAgICAgICBub2RlLnZ5ICs9ICh5ICo9IGwpICogcjtcbiAgICAgICAgICAgIGRhdGEudnggLT0geCAqIChyID0gMSAtIHIpO1xuICAgICAgICAgICAgZGF0YS52eSAtPSB5ICogcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgwID4geGkgKyByIHx8IHgxIDwgeGkgLSByIHx8IHkwID4geWkgKyByIHx8IHkxIDwgeWkgLSByO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmUocXVhZCkge1xuICAgIGlmIChxdWFkLmRhdGEpIHJldHVybiBxdWFkLnIgPSByYWRpaVtxdWFkLmRhdGEuaW5kZXhdO1xuICAgIGZvciAodmFyIGkgPSBxdWFkLnIgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAocXVhZFtpXSAmJiBxdWFkW2ldLnIgPiBxdWFkLnIpIHtcbiAgICAgICAgcXVhZC5yID0gcXVhZFtpXS5yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuICAgIHJhZGlpID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgcmFkaWlbbm9kZS5pbmRleF0gPSArcmFkaXVzKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfbm9kZXMsIF9yYW5kb20pIHtcbiAgICBub2RlcyA9IF9ub2RlcztcbiAgICByYW5kb20gPSBfcmFuZG9tO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9ICtfLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogcmFkaXVzO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFuZG9tKSB7XG4gIHJldHVybiAocmFuZG9tKCkgLSAwLjUpICogMWUtNjtcbn1cbiIsIi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9jb25ncnVlbnRpYWxfZ2VuZXJhdG9yI1BhcmFtZXRlcnNfaW5fY29tbW9uX3VzZVxuY29uc3QgYSA9IDE2NjQ1MjU7XG5jb25zdCBjID0gMTAxMzkwNDIyMztcbmNvbnN0IG0gPSA0Mjk0OTY3Mjk2OyAvLyAyXjMyXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgcyA9IDE7XG4gIHJldHVybiAoKSA9PiAocyA9IChhICogcyArIGMpICUgbSkgLyBtO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyfSBmcm9tIFwiZDMtdGltZXJcIjtcbmltcG9ydCBsY2cgZnJvbSBcIi4vbGNnLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55O1xufVxuXG52YXIgaW5pdGlhbFJhZGl1cyA9IDEwLFxuICAgIGluaXRpYWxBbmdsZSA9IE1hdGguUEkgKiAoMyAtIE1hdGguc3FydCg1KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGVzKSB7XG4gIHZhciBzaW11bGF0aW9uLFxuICAgICAgYWxwaGEgPSAxLFxuICAgICAgYWxwaGFNaW4gPSAwLjAwMSxcbiAgICAgIGFscGhhRGVjYXkgPSAxIC0gTWF0aC5wb3coYWxwaGFNaW4sIDEgLyAzMDApLFxuICAgICAgYWxwaGFUYXJnZXQgPSAwLFxuICAgICAgdmVsb2NpdHlEZWNheSA9IDAuNixcbiAgICAgIGZvcmNlcyA9IG5ldyBNYXAoKSxcbiAgICAgIHN0ZXBwZXIgPSB0aW1lcihzdGVwKSxcbiAgICAgIGV2ZW50ID0gZGlzcGF0Y2goXCJ0aWNrXCIsIFwiZW5kXCIpLFxuICAgICAgcmFuZG9tID0gbGNnKCk7XG5cbiAgaWYgKG5vZGVzID09IG51bGwpIG5vZGVzID0gW107XG5cbiAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICB0aWNrKCk7XG4gICAgZXZlbnQuY2FsbChcInRpY2tcIiwgc2ltdWxhdGlvbik7XG4gICAgaWYgKGFscGhhIDwgYWxwaGFNaW4pIHtcbiAgICAgIHN0ZXBwZXIuc3RvcCgpO1xuICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBzaW11bGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcblxuICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAxO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGFscGhhICs9IChhbHBoYVRhcmdldCAtIGFscGhhKSAqIGFscGhhRGVjYXk7XG5cbiAgICAgIGZvcmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIGZvcmNlKGFscGhhKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZnggPT0gbnVsbCkgbm9kZS54ICs9IG5vZGUudnggKj0gdmVsb2NpdHlEZWNheTtcbiAgICAgICAgZWxzZSBub2RlLnggPSBub2RlLmZ4LCBub2RlLnZ4ID0gMDtcbiAgICAgICAgaWYgKG5vZGUuZnkgPT0gbnVsbCkgbm9kZS55ICs9IG5vZGUudnkgKj0gdmVsb2NpdHlEZWNheTtcbiAgICAgICAgZWxzZSBub2RlLnkgPSBub2RlLmZ5LCBub2RlLnZ5ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2ltdWxhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVOb2RlcygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLmluZGV4ID0gaTtcbiAgICAgIGlmIChub2RlLmZ4ICE9IG51bGwpIG5vZGUueCA9IG5vZGUuZng7XG4gICAgICBpZiAobm9kZS5meSAhPSBudWxsKSBub2RlLnkgPSBub2RlLmZ5O1xuICAgICAgaWYgKGlzTmFOKG5vZGUueCkgfHwgaXNOYU4obm9kZS55KSkge1xuICAgICAgICB2YXIgcmFkaXVzID0gaW5pdGlhbFJhZGl1cyAqIE1hdGguc3FydCgwLjUgKyBpKSwgYW5nbGUgPSBpICogaW5pdGlhbEFuZ2xlO1xuICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hTihub2RlLnZ4KSB8fCBpc05hTihub2RlLnZ5KSkge1xuICAgICAgICBub2RlLnZ4ID0gbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZUZvcmNlKGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlLmluaXRpYWxpemUpIGZvcmNlLmluaXRpYWxpemUobm9kZXMsIHJhbmRvbSk7XG4gICAgcmV0dXJuIGZvcmNlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZU5vZGVzKCk7XG5cbiAgcmV0dXJuIHNpbXVsYXRpb24gPSB7XG4gICAgdGljazogdGljayxcblxuICAgIHJlc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIucmVzdGFydChzdGVwKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5zdG9wKCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIG5vZGVzOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlcyA9IF8sIGluaXRpYWxpemVOb2RlcygpLCBmb3JjZXMuZm9yRWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKSA6IG5vZGVzO1xuICAgIH0sXG5cbiAgICBhbHBoYTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYTtcbiAgICB9LFxuXG4gICAgYWxwaGFNaW46IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhTWluID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFNaW47XG4gICAgfSxcblxuICAgIGFscGhhRGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhRGVjYXkgPSArXywgc2ltdWxhdGlvbikgOiArYWxwaGFEZWNheTtcbiAgICB9LFxuXG4gICAgYWxwaGFUYXJnZXQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhVGFyZ2V0ID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFUYXJnZXQ7XG4gICAgfSxcblxuICAgIHZlbG9jaXR5RGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZlbG9jaXR5RGVjYXkgPSAxIC0gXywgc2ltdWxhdGlvbikgOiAxIC0gdmVsb2NpdHlEZWNheTtcbiAgICB9LFxuXG4gICAgcmFuZG9tU291cmNlOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5kb20gPSBfLCBmb3JjZXMuZm9yRWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKSA6IHJhbmRvbTtcbiAgICB9LFxuXG4gICAgZm9yY2U6IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICgoXyA9PSBudWxsID8gZm9yY2VzLmRlbGV0ZShuYW1lKSA6IGZvcmNlcy5zZXQobmFtZSwgaW5pdGlhbGl6ZUZvcmNlKF8pKSksIHNpbXVsYXRpb24pIDogZm9yY2VzLmdldChuYW1lKTtcbiAgICB9LFxuXG4gICAgZmluZDogZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeSxcbiAgICAgICAgICBkMixcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGNsb3Nlc3Q7XG5cbiAgICAgIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gICAgICBlbHNlIHJhZGl1cyAqPSByYWRpdXM7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBkeCA9IHggLSBub2RlLng7XG4gICAgICAgIGR5ID0geSAtIG5vZGUueTtcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGQyIDwgcmFkaXVzKSBjbG9zZXN0ID0gbm9kZSwgcmFkaXVzID0gZDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH0sXG5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKGV2ZW50Lm9uKG5hbWUsIF8pLCBzaW11bGF0aW9uKSA6IGV2ZW50Lm9uKG5hbWUpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHh6O1xuXG4gIGlmICh0eXBlb2YgeCAhPT0gXCJmdW5jdGlvblwiKSB4ID0gY29uc3RhbnQoeCA9PSBudWxsID8gMCA6ICt4KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnggKz0gKHh6W2ldIC0gbm9kZS54KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB4eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih4eltpXSA9ICt4KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeXo7XG5cbiAgaWYgKHR5cGVvZiB5ICE9PSBcImZ1bmN0aW9uXCIpIHkgPSBjb25zdGFudCh5ID09IG51bGwgPyAwIDogK3kpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eSArPSAoeXpbaV0gLSBub2RlLnkpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHl6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHl6W2ldID0gK3kobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJpbXBvcnQgZm9ybWF0TG9jYWxlIGZyb20gXCIuL2xvY2FsZS5qc1wiO1xuXG52YXIgbG9jYWxlO1xuZXhwb3J0IHZhciBmb3JtYXQ7XG5leHBvcnQgdmFyIGZvcm1hdFByZWZpeDtcblxuZGVmYXVsdExvY2FsZSh7XG4gIHRob3VzYW5kczogXCIsXCIsXG4gIGdyb3VwaW5nOiBbM10sXG4gIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZm9ybWF0UHJlZml4ID0gbG9jYWxlLmZvcm1hdFByZWZpeDtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsUGFydHMoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggPSBNYXRoLnJvdW5kKHgpKSA+PSAxZTIxXG4gICAgICA/IHgudG9Mb2NhbGVTdHJpbmcoXCJlblwiKS5yZXBsYWNlKC8sL2csIFwiXCIpXG4gICAgICA6IHgudG9TdHJpbmcoMTApO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsUGFydHMoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApIHtcbiAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICByZXR1cm4gW1xuICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgK3guc2xpY2UoaSArIDEpXG4gIF07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihncm91cGluZywgdGhvdXNhbmRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgdCA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgdmFyIHByZWZpeEV4cG9uZW50O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsUGFydHMoeCwgTWF0aC5tYXgoMCwgcCArIGkgLSAxKSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG4iLCIvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW35dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuICB2YXIgbWF0Y2g7XG4gIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHtcbiAgICBmaWxsOiBtYXRjaFsxXSxcbiAgICBhbGlnbjogbWF0Y2hbMl0sXG4gICAgc2lnbjogbWF0Y2hbM10sXG4gICAgc3ltYm9sOiBtYXRjaFs0XSxcbiAgICB6ZXJvOiBtYXRjaFs1XSxcbiAgICB3aWR0aDogbWF0Y2hbNl0sXG4gICAgY29tbWE6IG1hdGNoWzddLFxuICAgIHByZWNpc2lvbjogbWF0Y2hbOF0gJiYgbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgdHJpbTogbWF0Y2hbOV0sXG4gICAgdHlwZTogbWF0Y2hbMTBdXG4gIH0pO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5leHBvcnQgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICB0aGlzLmZpbGwgPSBzcGVjaWZpZXIuZmlsbCA9PT0gdW5kZWZpbmVkID8gXCIgXCIgOiBzcGVjaWZpZXIuZmlsbCArIFwiXCI7XG4gIHRoaXMuYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24gPT09IHVuZGVmaW5lZCA/IFwiPlwiIDogc3BlY2lmaWVyLmFsaWduICsgXCJcIjtcbiAgdGhpcy5zaWduID0gc3BlY2lmaWVyLnNpZ24gPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogc3BlY2lmaWVyLnNpZ24gKyBcIlwiO1xuICB0aGlzLnN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIuc3ltYm9sICsgXCJcIjtcbiAgdGhpcy56ZXJvID0gISFzcGVjaWZpZXIuemVybztcbiAgdGhpcy53aWR0aCA9IHNwZWNpZmllci53aWR0aCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci53aWR0aDtcbiAgdGhpcy5jb21tYSA9ICEhc3BlY2lmaWVyLmNvbW1hO1xuICB0aGlzLnByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIucHJlY2lzaW9uO1xuICB0aGlzLnRyaW0gPSAhIXNwZWNpZmllci50cmltO1xuICB0aGlzLnR5cGUgPSBzcGVjaWZpZXIudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci50eXBlICsgXCJcIjtcbn1cblxuRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsXG4gICAgICArIHRoaXMuYWxpZ25cbiAgICAgICsgdGhpcy5zaWduXG4gICAgICArIHRoaXMuc3ltYm9sXG4gICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKVxuICAgICAgKyB0aGlzLnR5cGU7XG59O1xuIiwiLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKCErc1tpXSkgYnJlYWsgb3V0OyBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTAgPiAwID8gcy5zbGljZSgwLCBpMCkgKyBzLnNsaWNlKGkxICsgMSkgOiBzO1xufVxuIiwiaW1wb3J0IGZvcm1hdERlY2ltYWwgZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuaW1wb3J0IGZvcm1hdFByZWZpeEF1dG8gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGZvcm1hdFJvdW5kZWQgZnJvbSBcIi4vZm9ybWF0Um91bmRlZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiJVwiOiAoeCwgcCkgPT4gKHggKiAxMDApLnRvRml4ZWQocCksXG4gIFwiYlwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKSxcbiAgXCJjXCI6ICh4KSA9PiB4ICsgXCJcIixcbiAgXCJkXCI6IGZvcm1hdERlY2ltYWwsXG4gIFwiZVwiOiAoeCwgcCkgPT4geC50b0V4cG9uZW50aWFsKHApLFxuICBcImZcIjogKHgsIHApID0+IHgudG9GaXhlZChwKSxcbiAgXCJnXCI6ICh4LCBwKSA9PiB4LnRvUHJlY2lzaW9uKHApLFxuICBcIm9cIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCksXG4gIFwicFwiOiAoeCwgcCkgPT4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKSxcbiAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICBcIlhcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksXG4gIFwieFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNilcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5pbXBvcnQgZm9ybWF0R3JvdXAgZnJvbSBcIi4vZm9ybWF0R3JvdXAuanNcIjtcbmltcG9ydCBmb3JtYXROdW1lcmFscyBmcm9tIFwiLi9mb3JtYXROdW1lcmFscy5qc1wiO1xuaW1wb3J0IGZvcm1hdFNwZWNpZmllciBmcm9tIFwiLi9mb3JtYXRTcGVjaWZpZXIuanNcIjtcbmltcG9ydCBmb3JtYXRUcmltIGZyb20gXCIuL2Zvcm1hdFRyaW0uanNcIjtcbmltcG9ydCBmb3JtYXRUeXBlcyBmcm9tIFwiLi9mb3JtYXRUeXBlcy5qc1wiO1xuaW1wb3J0IHtwcmVmaXhFeHBvbmVudH0gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obG9jYWxlKSB7XG4gIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IGxvY2FsZS50aG91c2FuZHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0R3JvdXAobWFwLmNhbGwobG9jYWxlLmdyb3VwaW5nLCBOdW1iZXIpLCBsb2NhbGUudGhvdXNhbmRzICsgXCJcIiksXG4gICAgICBjdXJyZW5jeVByZWZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVswXSArIFwiXCIsXG4gICAgICBjdXJyZW5jeVN1ZmZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVsxXSArIFwiXCIsXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwgPT09IHVuZGVmaW5lZCA/IFwiLlwiIDogbG9jYWxlLmRlY2ltYWwgKyBcIlwiLFxuICAgICAgbnVtZXJhbHMgPSBsb2NhbGUubnVtZXJhbHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0TnVtZXJhbHMobWFwLmNhbGwobG9jYWxlLm51bWVyYWxzLCBTdHJpbmcpKSxcbiAgICAgIHBlcmNlbnQgPSBsb2NhbGUucGVyY2VudCA9PT0gdW5kZWZpbmVkID8gXCIlXCIgOiBsb2NhbGUucGVyY2VudCArIFwiXCIsXG4gICAgICBtaW51cyA9IGxvY2FsZS5taW51cyA9PT0gdW5kZWZpbmVkID8gXCLiiJJcIiA6IGxvY2FsZS5taW51cyArIFwiXCIsXG4gICAgICBuYW4gPSBsb2NhbGUubmFuID09PSB1bmRlZmluZWQgPyBcIk5hTlwiIDogbG9jYWxlLm5hbiArIFwiXCI7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllcikge1xuICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgIHRyaW0gPSBzcGVjaWZpZXIudHJpbSxcbiAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gVGhlIFwiXCIgdHlwZSwgYW5kIGFueSBpbnZhbGlkIHR5cGUsIGlzIGFuIGFsaWFzIGZvciBcIi4xMn5nXCIuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCAmJiAocHJlY2lzaW9uID0gMTIpLCB0cmltID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5UHJlZml4IDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lTdWZmaXggOiAvWyVwXS8udGVzdCh0eXBlKSA/IHBlcmNlbnQgOiBcIlwiO1xuXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgIG1heWJlU3VmZml4ID0gL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNlxuICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpZ24uIC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMDtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgIHZhbHVlID0gaXNOYU4odmFsdWUpID8gbmFuIDogZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gVHJpbSBpbnNpZ25pZmljYW50IHplcm9zLlxuICAgICAgICBpZiAodHJpbSkgdmFsdWUgPSBmb3JtYXRUcmltKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiBhIG5lZ2F0aXZlIHZhbHVlIHJvdW5kcyB0byB6ZXJvIGFmdGVyIGZvcm1hdHRpbmcsIGFuZCBubyBleHBsaWNpdCBwb3NpdGl2ZSBzaWduIGlzIHJlcXVlc3RlZCwgaGlkZSB0aGUgc2lnbi5cbiAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUgJiYgK3ZhbHVlID09PSAwICYmIHNpZ24gIT09IFwiK1wiKSB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogbWludXMpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgdmFsdWVTdWZmaXggPSAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgdmFsdWVTdWZmaXggKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSBcIjxcIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nOyBicmVhaztcbiAgICAgICAgY2FzZSBcIj1cIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgICAgY2FzZSBcIl5cIjogdmFsdWUgPSBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdmFsdWUgPSBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWVyYWxzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcGVjaWZpZXIgKyBcIlwiO1xuICAgIH07XG5cbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICB2YXIgZiA9IG5ld0Zvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IG5ld0Zvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXAsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCwgbWF4KSB7XG4gIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XG4gIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChtYXgpIC0gZXhwb25lbnQoc3RlcCkpICsgMTtcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24vY3B5dGhvbi9ibG9iL2E3NGVlYTIzOGY1YmFiYTE1Nzk3ZTJlOGI1NzBkMTUzYmM4NjkwYTcvTW9kdWxlcy9tYXRobW9kdWxlLmMjTDE0MjNcbmV4cG9ydCBjbGFzcyBBZGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnRpYWxzID0gbmV3IEZsb2F0NjRBcnJheSgzMik7XG4gICAgdGhpcy5fbiA9IDA7XG4gIH1cbiAgYWRkKHgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbiAmJiBqIDwgMzI7IGorKykge1xuICAgICAgY29uc3QgeSA9IHBbal0sXG4gICAgICAgIGhpID0geCArIHksXG4gICAgICAgIGxvID0gTWF0aC5hYnMoeCkgPCBNYXRoLmFicyh5KSA/IHggLSAoaGkgLSB5KSA6IHkgLSAoaGkgLSB4KTtcbiAgICAgIGlmIChsbykgcFtpKytdID0gbG87XG4gICAgICB4ID0gaGk7XG4gICAgfVxuICAgIHBbaV0gPSB4O1xuICAgIHRoaXMuX24gPSBpICsgMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YWx1ZU9mKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wYXJ0aWFscztcbiAgICBsZXQgbiA9IHRoaXMuX24sIHgsIHksIGxvLCBoaSA9IDA7XG4gICAgaWYgKG4gPiAwKSB7XG4gICAgICBoaSA9IHBbLS1uXTtcbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICB4ID0gaGk7XG4gICAgICAgIHkgPSBwWy0tbl07XG4gICAgICAgIGhpID0geCArIHk7XG4gICAgICAgIGxvID0geSAtIChoaSAtIHgpO1xuICAgICAgICBpZiAobG8pIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG4gPiAwICYmICgobG8gPCAwICYmIHBbbiAtIDFdIDwgMCkgfHwgKGxvID4gMCAmJiBwW24gLSAxXSA+IDApKSkge1xuICAgICAgICB5ID0gbG8gKiAyO1xuICAgICAgICB4ID0gaGkgKyB5O1xuICAgICAgICBpZiAoeSA9PSB4IC0gaGkpIGhpID0geDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBjb25zdCBhZGRlciA9IG5ldyBBZGRlcigpO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgICAgYWRkZXIuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkge1xuICAgICAgICBhZGRlci5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gK2FkZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmN1bXN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgYWRkZXIgPSBuZXcgQWRkZXIoKTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIHJldHVybiBGbG9hdDY0QXJyYXkuZnJvbSh2YWx1ZXMsIHZhbHVlb2YgPT09IHVuZGVmaW5lZFxuICAgICAgPyB2ID0+IGFkZGVyLmFkZCgrdiB8fCAwKVxuICAgICAgOiB2ID0+IGFkZGVyLmFkZCgrdmFsdWVvZih2LCArK2luZGV4LCB2YWx1ZXMpIHx8IDApXG4gICk7XG59XG4iLCJmdW5jdGlvbiogZmxhdHRlbihhcnJheXMpIHtcbiAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcbiAgICB5aWVsZCogYXJyYXk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2UoYXJyYXlzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGZsYXR0ZW4oYXJyYXlzKSk7XG59XG4iLCJpbXBvcnQge2FzaW4sIGF0YW4yLCBjb3MsIHNpbiwgc3FydH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICByZXR1cm4gW2F0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgYXNpbihjYXJ0ZXNpYW5bMl0pXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgdmFyIGxhbWJkYSA9IHNwaGVyaWNhbFswXSwgcGhpID0gc3BoZXJpY2FsWzFdLCBjb3NQaGkgPSBjb3MocGhpKTtcbiAgcmV0dXJuIFtjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG59XG5cbi8vIFRPRE8gcmV0dXJuIGFcbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcbiAgYVswXSArPSBiWzBdLCBhWzFdICs9IGJbMV0sIGFbMl0gKz0gYlsyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICByZXR1cm4gW3ZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGtdO1xufVxuXG4vLyBUT0RPIHJldHVybiBkXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShkKSB7XG4gIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICBkWzBdIC89IGwsIGRbMV0gLz0gbCwgZFsyXSAvPSBsO1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UsIHNwaGVyaWNhbH0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YWNvcywgY29zLCBkZWdyZWVzLCBlcHNpbG9uLCByYWRpYW5zLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtyb3RhdGVSYWRpYW5zfSBmcm9tIFwiLi9yb3RhdGlvbi5qc1wiO1xuXG4vLyBHZW5lcmF0ZXMgYSBjaXJjbGUgY2VudGVyZWQgYXQgWzDCsCwgMMKwXSwgd2l0aCBhIGdpdmVuIHJhZGl1cyBhbmQgcHJlY2lzaW9uLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgdDAsIHQxKSB7XG4gIGlmICghZGVsdGEpIHJldHVybjtcbiAgdmFyIGNvc1JhZGl1cyA9IGNvcyhyYWRpdXMpLFxuICAgICAgc2luUmFkaXVzID0gc2luKHJhZGl1cyksXG4gICAgICBzdGVwID0gZGlyZWN0aW9uICogZGVsdGE7XG4gIGlmICh0MCA9PSBudWxsKSB7XG4gICAgdDAgPSByYWRpdXMgKyBkaXJlY3Rpb24gKiB0YXU7XG4gICAgdDEgPSByYWRpdXMgLSBzdGVwIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0MCA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQwKTtcbiAgICB0MSA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQxKTtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCA/IHQwIDwgdDEgOiB0MCA+IHQxKSB0MCArPSBkaXJlY3Rpb24gKiB0YXU7XG4gIH1cbiAgZm9yICh2YXIgcG9pbnQsIHQgPSB0MDsgZGlyZWN0aW9uID4gMCA/IHQgPiB0MSA6IHQgPCB0MTsgdCAtPSBzdGVwKSB7XG4gICAgcG9pbnQgPSBzcGhlcmljYWwoW2Nvc1JhZGl1cywgLXNpblJhZGl1cyAqIGNvcyh0KSwgLXNpblJhZGl1cyAqIHNpbih0KV0pO1xuICAgIHN0cmVhbS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICB9XG59XG5cbi8vIFJldHVybnMgdGhlIHNpZ25lZCBhbmdsZSBvZiBhIGNhcnRlc2lhbiBwb2ludCByZWxhdGl2ZSB0byBbY29zUmFkaXVzLCAwLCAwXS5cbmZ1bmN0aW9uIGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHBvaW50KSB7XG4gIHBvaW50ID0gY2FydGVzaWFuKHBvaW50KSwgcG9pbnRbMF0gLT0gY29zUmFkaXVzO1xuICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKHBvaW50KTtcbiAgdmFyIHJhZGl1cyA9IGFjb3MoLXBvaW50WzFdKTtcbiAgcmV0dXJuICgoLXBvaW50WzJdIDwgMCA/IC1yYWRpdXMgOiByYWRpdXMpICsgdGF1IC0gZXBzaWxvbikgJSB0YXU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VudGVyID0gY29uc3RhbnQoWzAsIDBdKSxcbiAgICAgIHJhZGl1cyA9IGNvbnN0YW50KDkwKSxcbiAgICAgIHByZWNpc2lvbiA9IGNvbnN0YW50KDYpLFxuICAgICAgcmluZyxcbiAgICAgIHJvdGF0ZSxcbiAgICAgIHN0cmVhbSA9IHtwb2ludDogcG9pbnR9O1xuXG4gIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgeFswXSAqPSBkZWdyZWVzLCB4WzFdICo9IGRlZ3JlZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgdmFyIGMgPSBjZW50ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgciA9IHJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucyxcbiAgICAgICAgcCA9IHByZWNpc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucztcbiAgICByaW5nID0gW107XG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucygtY1swXSAqIHJhZGlhbnMsIC1jWzFdICogcmFkaWFucywgMCkuaW52ZXJ0O1xuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHIsIHAsIDEpO1xuICAgIGMgPSB7dHlwZTogXCJQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBbcmluZ119O1xuICAgIHJpbmcgPSByb3RhdGUgPSBudWxsO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgY2lyY2xlLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjZW50ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFsrX1swXSwgK19bMV1dKSwgY2lyY2xlKSA6IGNlbnRlcjtcbiAgfTtcblxuICBjaXJjbGUucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcmFkaXVzO1xuICB9O1xuXG4gIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2lzaW9uID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiBwcmVjaXNpb247XG4gIH07XG5cbiAgcmV0dXJuIGNpcmNsZTtcbn1cbiIsImltcG9ydCBjbGlwIGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge2FicywgYXRhbiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIHBpLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsaXAoXG4gIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgY2xpcEFudGltZXJpZGlhbkxpbmUsXG4gIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZSxcbiAgWy1waSwgLWhhbGZQaV1cbik7XG5cbi8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXM6IDAgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vIGludGVyc2VjdGlvbnM7IDIgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIHNob3VsZCBiZSByZWpvaW5lZC5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5MaW5lKHN0cmVhbSkge1xuICB2YXIgbGFtYmRhMCA9IE5hTixcbiAgICAgIHBoaTAgPSBOYU4sXG4gICAgICBzaWduMCA9IE5hTixcbiAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgY2xlYW4gPSAxO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYTEsIHBoaTEpIHtcbiAgICAgIHZhciBzaWduMSA9IGxhbWJkYTEgPiAwID8gcGkgOiAtcGksXG4gICAgICAgICAgZGVsdGEgPSBhYnMobGFtYmRhMSAtIGxhbWJkYTApO1xuICAgICAgaWYgKGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24pIHsgLy8gbGluZSBjcm9zc2VzIGEgcG9sZVxuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCwgcGhpMCA9IChwaGkwICsgcGhpMSkgLyAyID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGExLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChzaWduMCAhPT0gc2lnbjEgJiYgZGVsdGEgPj0gcGkpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxuICAgICAgICBpZiAoYWJzKGxhbWJkYTAgLSBzaWduMCkgPCBlcHNpbG9uKSBsYW1iZGEwIC09IHNpZ24wICogZXBzaWxvbjsgLy8gaGFuZGxlIGRlZ2VuZXJhY2llc1xuICAgICAgICBpZiAoYWJzKGxhbWJkYTEgLSBzaWduMSkgPCBlcHNpbG9uKSBsYW1iZGExIC09IHNpZ24xICogZXBzaWxvbjtcbiAgICAgICAgcGhpMCA9IGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAgPSBsYW1iZGExLCBwaGkwID0gcGhpMSk7XG4gICAgICBzaWduMCA9IHNpZ24xO1xuICAgIH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgbGFtYmRhMCA9IHBoaTAgPSBOYU47XG4gICAgfSxcbiAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMiAtIGNsZWFuOyAvLyBpZiBpbnRlcnNlY3Rpb25zLCByZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSkge1xuICB2YXIgY29zUGhpMCxcbiAgICAgIGNvc1BoaTEsXG4gICAgICBzaW5MYW1iZGEwTGFtYmRhMSA9IHNpbihsYW1iZGEwIC0gbGFtYmRhMSk7XG4gIHJldHVybiBhYnMoc2luTGFtYmRhMExhbWJkYTEpID4gZXBzaWxvblxuICAgICAgPyBhdGFuKChzaW4ocGhpMCkgKiAoY29zUGhpMSA9IGNvcyhwaGkxKSkgKiBzaW4obGFtYmRhMSlcbiAgICAgICAgICAtIHNpbihwaGkxKSAqIChjb3NQaGkwID0gY29zKHBoaTApKSAqIHNpbihsYW1iZGEwKSlcbiAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcbiAgICAgIDogKHBoaTAgKyBwaGkxKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgdmFyIHBoaTtcbiAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGhhbGZQaTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIDApO1xuICAgIHN0cmVhbS5wb2ludChwaSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIDApO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGxhbWJkYSA9IGZyb21bMF0gPCB0b1swXSA/IHBpIDogLXBpO1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGxhbWJkYSAvIDI7XG4gICAgc3RyZWFtLnBvaW50KC1sYW1iZGEsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgfVxufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lcyA9IFtdLFxuICAgICAgbGluZTtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSwgbSkge1xuICAgICAgbGluZS5wdXNoKFt4LCB5LCBtXSk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgIH0sXG4gICAgbGluZUVuZDogbm9vcCxcbiAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgbGluZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5BZGRJblBsYWNlLCBjYXJ0ZXNpYW5Dcm9zcywgY2FydGVzaWFuRG90LCBjYXJ0ZXNpYW5TY2FsZSwgc3BoZXJpY2FsfSBmcm9tIFwiLi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2NpcmNsZVN0cmVhbX0gZnJvbSBcIi4uL2NpcmNsZS5qc1wiO1xuaW1wb3J0IHthYnMsIGNvcywgZXBzaWxvbiwgcGksIHJhZGlhbnMsIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgcG9pbnRFcXVhbCBmcm9tIFwiLi4vcG9pbnRFcXVhbC5qc1wiO1xuaW1wb3J0IGNsaXAgZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHZhciBjciA9IGNvcyhyYWRpdXMpLFxuICAgICAgZGVsdGEgPSA2ICogcmFkaWFucyxcbiAgICAgIHNtYWxsUmFkaXVzID0gY3IgPiAwLFxuICAgICAgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiBlcHNpbG9uOyAvLyBUT0RPIG9wdGltaXNlIGZvciB0aGlzIGNvbW1vbiBjYXNlXG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCBmcm9tLCB0byk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGNvcyhsYW1iZGEpICogY29zKHBoaSkgPiBjcjtcbiAgfVxuXG4gIC8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXMgdXNlZCBmb3IgcG9seWdvblxuICAvLyBjbGlwcGluZzogMCAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBub1xuICAvLyBpbnRlcnNlY3Rpb25zIDIgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgLy8gc2hvdWxkIGJlIHJlam9pbmVkLlxuICBmdW5jdGlvbiBjbGlwTGluZShzdHJlYW0pIHtcbiAgICB2YXIgcG9pbnQwLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICBjMCwgLy8gY29kZSBmb3IgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAsIC8vIHZpc2liaWxpdHkgb2YgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAwLCAvLyB2aXNpYmlsaXR5IG9mIGZpcnN0IHBvaW50XG4gICAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHYwMCA9IHYwID0gZmFsc2U7XG4gICAgICAgIGNsZWFuID0gMTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBvaW50MSA9IFtsYW1iZGEsIHBoaV0sXG4gICAgICAgICAgICBwb2ludDIsXG4gICAgICAgICAgICB2ID0gdmlzaWJsZShsYW1iZGEsIHBoaSksXG4gICAgICAgICAgICBjID0gc21hbGxSYWRpdXNcbiAgICAgICAgICAgICAgPyB2ID8gMCA6IGNvZGUobGFtYmRhLCBwaGkpXG4gICAgICAgICAgICAgIDogdiA/IGNvZGUobGFtYmRhICsgKGxhbWJkYSA8IDAgPyBwaSA6IC1waSksIHBoaSkgOiAwO1xuICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSkgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgIGlmICghcG9pbnQyIHx8IHBvaW50RXF1YWwocG9pbnQwLCBwb2ludDIpIHx8IHBvaW50RXF1YWwocG9pbnQxLCBwb2ludDIpKVxuICAgICAgICAgICAgcG9pbnQxWzJdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgZ29pbmcgaW5cbiAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnNpZGUgZ29pbmcgb3V0XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdLCAyKTtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgfSBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcbiAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAvLyBJZiB0aGUgY29kZXMgZm9yIHR3byBwb2ludHMgYXJlIGRpZmZlcmVudCwgb3IgYXJlIGJvdGggemVybyxcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgdGhpcyBzZWdtZW50IGludGVyc2VjdHMgd2l0aCB0aGUgc21hbGwgY2lyY2xlLlxuICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0sIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodjApIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgLy8gUmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIGlmIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBhbmQgbGFzdCBwb2ludHMgd2VyZSB2aXNpYmxlLlxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2xlYW4gfCAoKHYwMCAmJiB2MCkgPDwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVyc2VjdHMgdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIGEgYW5kIGIgd2l0aCB0aGUgY2xpcCBjaXJjbGUuXG4gIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICB2YXIgcGEgPSBjYXJ0ZXNpYW4oYSksXG4gICAgICAgIHBiID0gY2FydGVzaWFuKGIpO1xuXG4gICAgLy8gV2UgaGF2ZSB0d28gcGxhbmVzLCBuMS5wID0gZDEgYW5kIG4yLnAgPSBkMi5cbiAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBsaW5lIHAodCkgPSBjMSBuMSArIGMyIG4yICsgdCAobjEg4qivIG4yKS5cbiAgICB2YXIgbjEgPSBbMSwgMCwgMF0sIC8vIG5vcm1hbFxuICAgICAgICBuMiA9IGNhcnRlc2lhbkNyb3NzKHBhLCBwYiksXG4gICAgICAgIG4ybjIgPSBjYXJ0ZXNpYW5Eb3QobjIsIG4yKSxcbiAgICAgICAgbjFuMiA9IG4yWzBdLCAvLyBjYXJ0ZXNpYW5Eb3QobjEsIG4yKSxcbiAgICAgICAgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG5cbiAgICAvLyBUd28gcG9sYXIgcG9pbnRzLlxuICAgIGlmICghZGV0ZXJtaW5hbnQpIHJldHVybiAhdHdvICYmIGE7XG5cbiAgICB2YXIgYzEgPSAgY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LFxuICAgICAgICBuMXhuMiA9IGNhcnRlc2lhbkNyb3NzKG4xLCBuMiksXG4gICAgICAgIEEgPSBjYXJ0ZXNpYW5TY2FsZShuMSwgYzEpLFxuICAgICAgICBCID0gY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKEEsIEIpO1xuXG4gICAgLy8gU29sdmUgfHAodCl8XjIgPSAxLlxuICAgIHZhciB1ID0gbjF4bjIsXG4gICAgICAgIHcgPSBjYXJ0ZXNpYW5Eb3QoQSwgdSksXG4gICAgICAgIHV1ID0gY2FydGVzaWFuRG90KHUsIHUpLFxuICAgICAgICB0MiA9IHcgKiB3IC0gdXUgKiAoY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG5cbiAgICBpZiAodDIgPCAwKSByZXR1cm47XG5cbiAgICB2YXIgdCA9IHNxcnQodDIpLFxuICAgICAgICBxID0gY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShxLCBBKTtcbiAgICBxID0gc3BoZXJpY2FsKHEpO1xuXG4gICAgaWYgKCF0d28pIHJldHVybiBxO1xuXG4gICAgLy8gVHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gICAgdmFyIGxhbWJkYTAgPSBhWzBdLFxuICAgICAgICBsYW1iZGExID0gYlswXSxcbiAgICAgICAgcGhpMCA9IGFbMV0sXG4gICAgICAgIHBoaTEgPSBiWzFdLFxuICAgICAgICB6O1xuXG4gICAgaWYgKGxhbWJkYTEgPCBsYW1iZGEwKSB6ID0gbGFtYmRhMCwgbGFtYmRhMCA9IGxhbWJkYTEsIGxhbWJkYTEgPSB6O1xuXG4gICAgdmFyIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgIHBvbGFyID0gYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbixcbiAgICAgICAgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb247XG5cbiAgICBpZiAoIXBvbGFyICYmIHBoaTEgPCBwaGkwKSB6ID0gcGhpMCwgcGhpMCA9IHBoaTEsIHBoaTEgPSB6O1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZmlyc3QgcG9pbnQgaXMgYmV0d2VlbiBhIGFuZCBiLlxuICAgIGlmIChtZXJpZGlhblxuICAgICAgICA/IHBvbGFyXG4gICAgICAgICAgPyBwaGkwICsgcGhpMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gbGFtYmRhMCkgPCBlcHNpbG9uID8gcGhpMCA6IHBoaTEpXG4gICAgICAgICAgOiBwaGkwIDw9IHFbMV0gJiYgcVsxXSA8PSBwaGkxXG4gICAgICAgIDogZGVsdGEgPiBwaSBeIChsYW1iZGEwIDw9IHFbMF0gJiYgcVswXSA8PSBsYW1iZGExKSkge1xuICAgICAgdmFyIHExID0gY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHExLCBBKTtcbiAgICAgIHJldHVybiBbcSwgc3BoZXJpY2FsKHExKV07XG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGVzIGEgNC1iaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSBwb2ludCByZWxhdGl2ZSB0b1xuICAvLyB0aGUgc21hbGwgY2lyY2xlJ3MgYm91bmRpbmcgYm94LlxuICBmdW5jdGlvbiBjb2RlKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IHBpIC0gcmFkaXVzLFxuICAgICAgICBjb2RlID0gMDtcbiAgICBpZiAobGFtYmRhIDwgLXIpIGNvZGUgfD0gMTsgLy8gbGVmdFxuICAgIGVsc2UgaWYgKGxhbWJkYSA+IHIpIGNvZGUgfD0gMjsgLy8gcmlnaHRcbiAgICBpZiAocGhpIDwgLXIpIGNvZGUgfD0gNDsgLy8gYmVsb3dcbiAgICBlbHNlIGlmIChwaGkgPiByKSBjb2RlIHw9IDg7IC8vIGFib3ZlXG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cblxuICByZXR1cm4gY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWzAsIC1yYWRpdXNdIDogWy1waSwgcmFkaXVzIC0gcGldKTtcbn1cbiIsImltcG9ydCBjbGlwQnVmZmVyIGZyb20gXCIuL2J1ZmZlci5qc1wiO1xuaW1wb3J0IGNsaXBSZWpvaW4gZnJvbSBcIi4vcmVqb2luLmpzXCI7XG5pbXBvcnQge2Vwc2lsb24sIGhhbGZQaX0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBwb2x5Z29uQ29udGFpbnMgZnJvbSBcIi4uL3BvbHlnb25Db250YWlucy5qc1wiO1xuaW1wb3J0IHttZXJnZX0gZnJvbSBcImQzLWFycmF5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzdGFydCkge1xuICByZXR1cm4gZnVuY3Rpb24oc2luaykge1xuICAgIHZhciBsaW5lID0gY2xpcExpbmUoc2luayksXG4gICAgICAgIHJpbmdCdWZmZXIgPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHJpbmdTaW5rID0gY2xpcExpbmUocmluZ0J1ZmZlciksXG4gICAgICAgIHBvbHlnb25TdGFydGVkID0gZmFsc2UsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICByaW5nO1xuXG4gICAgdmFyIGNsaXAgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHN0YXJ0KTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHNpbmspO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIHNpbmsucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgaWYgKHBvaW50VmlzaWJsZShsYW1iZGEsIHBoaSkpIHNpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50TGluZShsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50UmluZyhsYW1iZGEsIHBoaSkge1xuICAgICAgcmluZy5wdXNoKFtsYW1iZGEsIHBoaV0pO1xuICAgICAgcmluZ1NpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIHJpbmdTaW5rLmxpbmVTdGFydCgpO1xuICAgICAgcmluZyA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XG4gICAgICByaW5nU2luay5saW5lRW5kKCk7XG5cbiAgICAgIHZhciBjbGVhbiA9IHJpbmdTaW5rLmNsZWFuKCksXG4gICAgICAgICAgcmluZ1NlZ21lbnRzID0gcmluZ0J1ZmZlci5yZXN1bHQoKSxcbiAgICAgICAgICBpLCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aCwgbSxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIHBvaW50O1xuXG4gICAgICByaW5nLnBvcCgpO1xuICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgcmluZyA9IG51bGw7XG5cbiAgICAgIGlmICghbikgcmV0dXJuO1xuXG4gICAgICAvLyBObyBpbnRlcnNlY3Rpb25zLlxuICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICBpZiAoKG0gPSBzZWdtZW50Lmxlbmd0aCAtIDEpID4gMCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHNpbmsucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlam9pbiBjb25uZWN0ZWQgc2VnbWVudHMuXG4gICAgICAvLyBUT0RPIHJldXNlIHJpbmdCdWZmZXIucmVqb2luKCk/XG4gICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG5cbiAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcih2YWxpZFNlZ21lbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbn1cblxuLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXG4vLyBhbmQgY2lyY2xlIGNsaXBwaW5nLCB0aGUgc2FtZSBjb21wYXJpc29uIGlzIHVzZWQuXG5mdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBhWzFdKVxuICAgICAgIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGJbMV0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIHQwID0gMCxcbiAgICAgIHQxID0gMSxcbiAgICAgIGR4ID0gYnggLSBheCxcbiAgICAgIGR5ID0gYnkgLSBheSxcbiAgICAgIHI7XG5cbiAgciA9IHgwIC0gYXg7XG4gIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB4MSAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICByID0geTAgLSBheTtcbiAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHkxIC0gYXk7XG4gIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIGlmICh0MCA+IDApIGFbMF0gPSBheCArIHQwICogZHgsIGFbMV0gPSBheSArIHQwICogZHk7XG4gIGlmICh0MSA8IDEpIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgY2xpcEJ1ZmZlciBmcm9tIFwiLi9idWZmZXIuanNcIjtcbmltcG9ydCBjbGlwTGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQgY2xpcFJlam9pbiBmcm9tIFwiLi9yZWpvaW4uanNcIjtcbmltcG9ydCB7bWVyZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuXG52YXIgY2xpcE1heCA9IDFlOSwgY2xpcE1pbiA9IC1jbGlwTWF4O1xuXG4vLyBUT0RPIFVzZSBkMy1wb2x5Z29u4oCZcyBwb2x5Z29uQ29udGFpbnMgaGVyZSBmb3IgdGhlIHJpbmcgY2hlY2s/XG4vLyBUT0RPIEVsaW1pbmF0ZSBkdXBsaWNhdGUgYnVmZmVyaW5nIGluIGNsaXBCdWZmZXIgYW5kIHBvbHlnb24ucHVzaD9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xpcFJlY3RhbmdsZSh4MCwgeTAsIHgxLCB5MSkge1xuXG4gIGZ1bmN0aW9uIHZpc2libGUoeCwgeSkge1xuICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgaWYgKGZyb20gPT0gbnVsbFxuICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxuICAgICAgICB8fCBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIGRvIHN0cmVhbS5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzXG4gICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxXG4gICAgICAgIDogYWJzKHBbMV0gLSB5MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXG4gICAgICAgIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyOyAvLyBhYnMocFsxXSAtIHkxKSA8IGVwc2lsb25cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlUG9pbnQoYS54LCBiLngpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVBvaW50KGEsIGIpIHtcbiAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksXG4gICAgICAgIGNiID0gY29ybmVyKGIsIDEpO1xuICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiXG4gICAgICAgIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXVxuICAgICAgICA6IGNhID09PSAxID8gYVswXSAtIGJbMF1cbiAgICAgICAgOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdXG4gICAgICAgIDogYlswXSAtIGFbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSxcbiAgICAgICAgYnVmZmVyU3RyZWFtID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgcmluZyxcbiAgICAgICAgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgeF8sIHlfLCB2XywgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgZmlyc3QsXG4gICAgICAgIGNsZWFuO1xuXG4gICAgdmFyIGNsaXBTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcbiAgICAgIHBvbHlnb25FbmQ6IHBvbHlnb25FbmRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgaWYgKHZpc2libGUoeCwgeSkpIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uSW5zaWRlKCkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xuICAgICAgICAgIGEwID0gYjAsIGExID0gYjEsIHBvaW50ID0gcmluZ1tqXSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTtcbiAgICAgICAgICBpZiAoYTEgPD0geTEpIHsgaWYgKGIxID4geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpID4gKGIxIC0gYTEpICogKHgwIC0gYTApKSArK3dpbmRpbmc7IH1cbiAgICAgICAgICBlbHNlIHsgaWYgKGIxIDw9IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA8IChiMSAtIGExKSAqICh4MCAtIGEwKSkgLS13aW5kaW5nOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpbmRpbmc7XG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIGdlb21ldHJ5IHdpdGhpbiBhIHBvbHlnb24gYW5kIHRoZW4gY2xpcCBpdCBlbiBtYXNzZS5cbiAgICBmdW5jdGlvbiBwb2x5Z29uU3RhcnQoKSB7XG4gICAgICBhY3RpdmVTdHJlYW0gPSBidWZmZXJTdHJlYW0sIHNlZ21lbnRzID0gW10sIHBvbHlnb24gPSBbXSwgY2xlYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25FbmQoKSB7XG4gICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uSW5zaWRlKCksXG4gICAgICAgICAgY2xlYW5JbnNpZGUgPSBjbGVhbiAmJiBzdGFydEluc2lkZSxcbiAgICAgICAgICB2aXNpYmxlID0gKHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICBpZiAoY2xlYW5JbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xuICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHZfID0gZmFsc2U7XG4gICAgICB4XyA9IHlfID0gTmFOO1xuICAgIH1cblxuICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cbiAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgLy8gY2xpcHBpbmcgaXNzdWVzLlxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICB9XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBpZiAodl8pIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goW3gsIHldKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICYmIHZfKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSxcbiAgICAgICAgICAgICAgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICBpZiAoY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpKSB7XG4gICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgaWYgKCF2KSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3RyZWFtO1xuICB9O1xufVxuIiwiaW1wb3J0IHBvaW50RXF1YWwgZnJvbSBcIi4uL3BvaW50RXF1YWwuanNcIjtcbmltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICB0aGlzLnggPSBwb2ludDtcbiAgdGhpcy56ID0gcG9pbnRzO1xuICB0aGlzLm8gPSBvdGhlcjsgLy8gYW5vdGhlciBpbnRlcnNlY3Rpb25cbiAgdGhpcy5lID0gZW50cnk7IC8vIGlzIGFuIGVudHJ5P1xuICB0aGlzLnYgPSBmYWxzZTsgLy8gdmlzaXRlZFxuICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsOyAvLyBuZXh0ICYgcHJldmlvdXNcbn1cblxuLy8gQSBnZW5lcmFsaXplZCBwb2x5Z29uIGNsaXBwaW5nIGFsZ29yaXRobTogZ2l2ZW4gYSBwb2x5Z29uIHRoYXQgaGFzIGJlZW4gY3V0XG4vLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4vLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gIHZhciBzdWJqZWN0ID0gW10sXG4gICAgICBjbGlwID0gW10sXG4gICAgICBpLFxuICAgICAgbjtcblxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl0sIHg7XG5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBpZiAoIXAwWzJdICYmICFwMVsyXSkge1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgZGVnZW5lcmF0ZSBjYXNlcyBieSBtb3ZpbmcgdGhlIHBvaW50XG4gICAgICBwMVswXSArPSAyICogZXBzaWxvbjtcbiAgICB9XG5cbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMCwgbnVsbCwgeCwgZmFsc2UpKTtcbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIG51bGwsIHgsIHRydWUpKTtcbiAgfSk7XG5cbiAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcbiAgbGluayhzdWJqZWN0KTtcbiAgbGluayhjbGlwKTtcblxuICBmb3IgKGkgPSAwLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjbGlwW2ldLmUgPSBzdGFydEluc2lkZSA9ICFzdGFydEluc2lkZTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHN1YmplY3RbMF0sXG4gICAgICBwb2ludHMsXG4gICAgICBwb2ludDtcblxuICB3aGlsZSAoMSkge1xuICAgIC8vIEZpbmQgZmlyc3QgdW52aXNpdGVkIGludGVyc2VjdGlvbi5cbiAgICB2YXIgY3VycmVudCA9IHN0YXJ0LFxuICAgICAgICBpc1N1YmplY3QgPSB0cnVlO1xuICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgZm9yIChpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICBzdHJlYW0ubGluZUVuZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbmsoYXJyYXkpIHtcbiAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgdmFyIG4sXG4gICAgICBpID0gMCxcbiAgICAgIGEgPSBhcnJheVswXSxcbiAgICAgIGI7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgIGIucCA9IGE7XG4gICAgYSA9IGI7XG4gIH1cbiAgYS5uID0gYiA9IGFycmF5WzBdO1xuICBiLnAgPSBhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuXG4gIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgfVxuXG4gIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgfTtcblxuICByZXR1cm4gY29tcG9zZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiB4O1xuIiwiZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtNjtcbmV4cG9ydCB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCB2YXIgdGF1ID0gcGkgKiAyO1xuXG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgdmFyIGFicyA9IE1hdGguYWJzO1xuZXhwb3J0IHZhciBhdGFuID0gTWF0aC5hdGFuO1xuZXhwb3J0IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgdmFyIGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBleHAgPSBNYXRoLmV4cDtcbmV4cG9ydCB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuZXhwb3J0IHZhciBoeXBvdCA9IE1hdGguaHlwb3Q7XG5leHBvcnQgdmFyIGxvZyA9IE1hdGgubG9nO1xuZXhwb3J0IHZhciBwb3cgPSBNYXRoLnBvdztcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG5leHBvcnQgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5leHBvcnQgdmFyIHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICByZXR1cm4gKHggPSBzaW4oeCAvIDIpKSAqIHg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub29wKCkge31cbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciB4MCA9IEluZmluaXR5LFxuICAgIHkwID0geDAsXG4gICAgeDEgPSAteDAsXG4gICAgeTEgPSB4MTtcblxudmFyIGJvdW5kc1N0cmVhbSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50LFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogbm9vcCxcbiAgcG9seWdvbkVuZDogbm9vcCxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm91bmRzID0gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgeDEgPSB5MSA9IC0oeTAgPSB4MCA9IEluZmluaXR5KTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludCh4LCB5KSB7XG4gIGlmICh4IDwgeDApIHgwID0geDtcbiAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gIGlmICh5ID4geTEpIHkxID0geTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYm91bmRzU3RyZWFtO1xuIiwiaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IGVwc2lsb24gJiYgYWJzKGFbMV0gLSBiWzFdKSA8IGVwc2lsb247XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5Dcm9zcywgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZX0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgZXBzaWxvbjIsIGhhbGZQaSwgcGksIHF1YXJ0ZXJQaSwgc2lnbiwgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gbG9uZ2l0dWRlKHBvaW50KSB7XG4gIGlmIChhYnMocG9pbnRbMF0pIDw9IHBpKVxuICAgIHJldHVybiBwb2ludFswXTtcbiAgZWxzZVxuICAgIHJldHVybiBzaWduKHBvaW50WzBdKSAqICgoYWJzKHBvaW50WzBdKSArIHBpKSAlIHRhdSAtIHBpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocG9seWdvbiwgcG9pbnQpIHtcbiAgdmFyIGxhbWJkYSA9IGxvbmdpdHVkZShwb2ludCksXG4gICAgICBwaGkgPSBwb2ludFsxXSxcbiAgICAgIHNpblBoaSA9IHNpbihwaGkpLFxuICAgICAgbm9ybWFsID0gW3NpbihsYW1iZGEpLCAtY29zKGxhbWJkYSksIDBdLFxuICAgICAgYW5nbGUgPSAwLFxuICAgICAgd2luZGluZyA9IDA7XG5cbiAgdmFyIHN1bSA9IG5ldyBBZGRlcigpO1xuXG4gIGlmIChzaW5QaGkgPT09IDEpIHBoaSA9IGhhbGZQaSArIGVwc2lsb247XG4gIGVsc2UgaWYgKHNpblBoaSA9PT0gLTEpIHBoaSA9IC1oYWxmUGkgLSBlcHNpbG9uO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoIShtID0gKHJpbmcgPSBwb2x5Z29uW2ldKS5sZW5ndGgpKSBjb250aW51ZTtcbiAgICB2YXIgcmluZyxcbiAgICAgICAgbSxcbiAgICAgICAgcG9pbnQwID0gcmluZ1ttIC0gMV0sXG4gICAgICAgIGxhbWJkYTAgPSBsb25naXR1ZGUocG9pbnQwKSxcbiAgICAgICAgcGhpMCA9IHBvaW50MFsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgIHNpblBoaTAgPSBzaW4ocGhpMCksXG4gICAgICAgIGNvc1BoaTAgPSBjb3MocGhpMCk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG07ICsraiwgbGFtYmRhMCA9IGxhbWJkYTEsIHNpblBoaTAgPSBzaW5QaGkxLCBjb3NQaGkwID0gY29zUGhpMSwgcG9pbnQwID0gcG9pbnQxKSB7XG4gICAgICB2YXIgcG9pbnQxID0gcmluZ1tqXSxcbiAgICAgICAgICBsYW1iZGExID0gbG9uZ2l0dWRlKHBvaW50MSksXG4gICAgICAgICAgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgICAgc2luUGhpMSA9IHNpbihwaGkxKSxcbiAgICAgICAgICBjb3NQaGkxID0gY29zKHBoaTEpLFxuICAgICAgICAgIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgICAgc2lnbiA9IGRlbHRhID49IDAgPyAxIDogLTEsXG4gICAgICAgICAgYWJzRGVsdGEgPSBzaWduICogZGVsdGEsXG4gICAgICAgICAgYW50aW1lcmlkaWFuID0gYWJzRGVsdGEgPiBwaSxcbiAgICAgICAgICBrID0gc2luUGhpMCAqIHNpblBoaTE7XG5cbiAgICAgIHN1bS5hZGQoYXRhbjIoayAqIHNpZ24gKiBzaW4oYWJzRGVsdGEpLCBjb3NQaGkwICogY29zUGhpMSArIGsgKiBjb3MoYWJzRGVsdGEpKSk7XG4gICAgICBhbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkZWx0YSArIHNpZ24gKiB0YXUgOiBkZWx0YTtcblxuICAgICAgLy8gQXJlIHRoZSBsb25naXR1ZGVzIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludOKAmXMgbWVyaWRpYW4gKGxhbWJkYSksXG4gICAgICAvLyBhbmQgYXJlIHRoZSBsYXRpdHVkZXMgc21hbGxlciB0aGFuIHRoZSBwYXJhbGxlbCAocGhpKT9cbiAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiBsYW1iZGEwID49IGxhbWJkYSBeIGxhbWJkYTEgPj0gbGFtYmRhKSB7XG4gICAgICAgIHZhciBhcmMgPSBjYXJ0ZXNpYW5Dcm9zcyhjYXJ0ZXNpYW4ocG9pbnQwKSwgY2FydGVzaWFuKHBvaW50MSkpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGFyYyk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhub3JtYWwsIGFyYyk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgdmFyIHBoaUFyYyA9IChhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gLTEgOiAxKSAqIGFzaW4oaW50ZXJzZWN0aW9uWzJdKTtcbiAgICAgICAgaWYgKHBoaSA+IHBoaUFyYyB8fCBwaGkgPT09IHBoaUFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICB3aW5kaW5nICs9IGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCwgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIFNvdXRoIHBvbGUgaXMgaW5zaWRlIG9yIG91dHNpZGU6XG4gIC8vXG4gIC8vIEl0IGlzIGluc2lkZSBpZjpcbiAgLy8gKiB0aGUgcG9seWdvbiB3aW5kcyBhcm91bmQgaXQgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLlxuICAvLyAqIHRoZSBwb2x5Z29uIGRvZXMgbm90IChjdW11bGF0aXZlbHkpIHdpbmQgYXJvdW5kIGl0LCBidXQgaGFzIGEgbmVnYXRpdmVcbiAgLy8gICAoY291bnRlci1jbG9ja3dpc2UpIGFyZWEuXG4gIC8vXG4gIC8vIFNlY29uZCwgY291bnQgdGhlIChzaWduZWQpIG51bWJlciBvZiB0aW1lcyBhIHNlZ21lbnQgY3Jvc3NlcyBhIGxhbWJkYVxuICAvLyBmcm9tIHRoZSBwb2ludCB0byB0aGUgU291dGggcG9sZS4gIElmIGl0IGlzIHplcm8sIHRoZW4gdGhlIHBvaW50IGlzIHRoZVxuICAvLyBzYW1lIHNpZGUgYXMgdGhlIFNvdXRoIHBvbGUuXG5cbiAgcmV0dXJuIChhbmdsZSA8IC1lcHNpbG9uIHx8IGFuZ2xlIDwgZXBzaWxvbiAmJiBzdW0gPCAtZXBzaWxvbjIpIF4gKHdpbmRpbmcgJiAxKTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyBnZW9TdHJlYW19IGZyb20gXCIuLi9zdHJlYW0uanNcIjtcbmltcG9ydCBib3VuZHNTdHJlYW0gZnJvbSBcIi4uL3BhdGgvYm91bmRzLmpzXCI7XG5cbmZ1bmN0aW9uIGZpdChwcm9qZWN0aW9uLCBmaXRCb3VuZHMsIG9iamVjdCkge1xuICB2YXIgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgcHJvamVjdGlvbi5zY2FsZSgxNTApLnRyYW5zbGF0ZShbMCwgMF0pO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSkpO1xuICBmaXRCb3VuZHMoYm91bmRzU3RyZWFtLnJlc3VsdCgpKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KGNsaXApO1xuICByZXR1cm4gcHJvamVjdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSxcbiAgICAgICAgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSxcbiAgICAgICAgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksXG4gICAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSArd2lkdGgsXG4gICAgICAgIGsgPSB3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSxcbiAgICAgICAgeCA9ICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9IC1rICogYlswXVsxXTtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciBoID0gK2hlaWdodCxcbiAgICAgICAgayA9IGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pLFxuICAgICAgICB4ID0gLWsgKiBiWzBdWzBdLFxuICAgICAgICB5ID0gKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG4iLCJpbXBvcnQgY2xpcEFudGltZXJpZGlhbiBmcm9tIFwiLi4vY2xpcC9hbnRpbWVyaWRpYW4uanNcIjtcbmltcG9ydCBjbGlwQ2lyY2xlIGZyb20gXCIuLi9jbGlwL2NpcmNsZS5qc1wiO1xuaW1wb3J0IGNsaXBSZWN0YW5nbGUgZnJvbSBcIi4uL2NsaXAvcmVjdGFuZ2xlLmpzXCI7XG5pbXBvcnQgY29tcG9zZSBmcm9tIFwiLi4vY29tcG9zZS5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHtjb3MsIGRlZ3JlZXMsIHJhZGlhbnMsIHNpbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7cm90YXRlUmFkaWFuc30gZnJvbSBcIi4uL3JvdGF0aW9uLmpzXCI7XG5pbXBvcnQge3RyYW5zZm9ybWVyfSBmcm9tIFwiLi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQge2ZpdEV4dGVudCwgZml0U2l6ZSwgZml0V2lkdGgsIGZpdEhlaWdodH0gZnJvbSBcIi4vZml0LmpzXCI7XG5pbXBvcnQgcmVzYW1wbGUgZnJvbSBcIi4vcmVzYW1wbGUuanNcIjtcblxudmFyIHRyYW5zZm9ybVJhZGlhbnMgPSB0cmFuc2Zvcm1lcih7XG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5zdHJlYW0ucG9pbnQoeCAqIHJhZGlhbnMsIHkgKiByYWRpYW5zKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIHIgPSByb3RhdGUoeCwgeSk7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9pbnQoclswXSwgclsxXSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGUoaywgZHgsIGR5LCBzeCwgc3kpIHtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICB4ICo9IHN4OyB5ICo9IHN5O1xuICAgIHJldHVybiBbZHggKyBrICogeCwgZHkgLSBrICogeV07XG4gIH1cbiAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyh4IC0gZHgpIC8gayAqIHN4LCAoZHkgLSB5KSAvIGsgKiBzeV07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIGR4LCBkeSwgc3gsIHN5LCBhbHBoYSkge1xuICBpZiAoIWFscGhhKSByZXR1cm4gc2NhbGVUcmFuc2xhdGUoaywgZHgsIGR5LCBzeCwgc3kpO1xuICB2YXIgY29zQWxwaGEgPSBjb3MoYWxwaGEpLFxuICAgICAgc2luQWxwaGEgPSBzaW4oYWxwaGEpLFxuICAgICAgYSA9IGNvc0FscGhhICogayxcbiAgICAgIGIgPSBzaW5BbHBoYSAqIGssXG4gICAgICBhaSA9IGNvc0FscGhhIC8gayxcbiAgICAgIGJpID0gc2luQWxwaGEgLyBrLFxuICAgICAgY2kgPSAoc2luQWxwaGEgKiBkeSAtIGNvc0FscGhhICogZHgpIC8gayxcbiAgICAgIGZpID0gKHNpbkFscGhhICogZHggKyBjb3NBbHBoYSAqIGR5KSAvIGs7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5KSB7XG4gICAgeCAqPSBzeDsgeSAqPSBzeTtcbiAgICByZXR1cm4gW2EgKiB4IC0gYiAqIHkgKyBkeCwgZHkgLSBiICogeCAtIGEgKiB5XTtcbiAgfVxuICB0cmFuc2Zvcm0uaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbc3ggKiAoYWkgKiB4IC0gYmkgKiB5ICsgY2kpLCBzeSAqIChmaSAtIGJpICogeCAtIGFpICogeSldO1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgcmV0dXJuIHByb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvamVjdDsgfSkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xuICB2YXIgcHJvamVjdCxcbiAgICAgIGsgPSAxNTAsIC8vIHNjYWxlXG4gICAgICB4ID0gNDgwLCB5ID0gMjUwLCAvLyB0cmFuc2xhdGVcbiAgICAgIGxhbWJkYSA9IDAsIHBoaSA9IDAsIC8vIGNlbnRlclxuICAgICAgZGVsdGFMYW1iZGEgPSAwLCBkZWx0YVBoaSA9IDAsIGRlbHRhR2FtbWEgPSAwLCByb3RhdGUsIC8vIHByZS1yb3RhdGVcbiAgICAgIGFscGhhID0gMCwgLy8gcG9zdC1yb3RhdGUgYW5nbGVcbiAgICAgIHN4ID0gMSwgLy8gcmVmbGVjdFhcbiAgICAgIHN5ID0gMSwgLy8gcmVmbGVjdFhcbiAgICAgIHRoZXRhID0gbnVsbCwgcHJlY2xpcCA9IGNsaXBBbnRpbWVyaWRpYW4sIC8vIHByZS1jbGlwIGFuZ2xlXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIHBvc3RjbGlwID0gaWRlbnRpdHksIC8vIHBvc3QtY2xpcCBleHRlbnRcbiAgICAgIGRlbHRhMiA9IDAuNSwgLy8gcHJlY2lzaW9uXG4gICAgICBwcm9qZWN0UmVzYW1wbGUsXG4gICAgICBwcm9qZWN0VHJhbnNmb3JtLFxuICAgICAgcHJvamVjdFJvdGF0ZVRyYW5zZm9ybSxcbiAgICAgIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW07XG5cbiAgZnVuY3Rpb24gcHJvamVjdGlvbihwb2ludCkge1xuICAgIHJldHVybiBwcm9qZWN0Um90YXRlVHJhbnNmb3JtKHBvaW50WzBdICogcmFkaWFucywgcG9pbnRbMV0gKiByYWRpYW5zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZVRyYW5zZm9ybS5pbnZlcnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICByZXR1cm4gcG9pbnQgJiYgW3BvaW50WzBdICogZGVncmVlcywgcG9pbnRbMV0gKiBkZWdyZWVzXTtcbiAgfVxuXG4gIHByb2plY3Rpb24uc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gdHJhbnNmb3JtUmFkaWFucyh0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKShwcmVjbGlwKHByb2plY3RSZXNhbXBsZShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpKSkpO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucHJlY2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gXywgdGhldGEgPSB1bmRlZmluZWQsIHJlc2V0KCkpIDogcHJlY2xpcDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnBvc3RjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2xpcEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSArXyA/IGNsaXBDaXJjbGUodGhldGEgPSBfICogcmFkaWFucykgOiAodGhldGEgPSBudWxsLCBjbGlwQW50aW1lcmlkaWFuKSwgcmVzZXQoKSkgOiB0aGV0YSAqIGRlZ3JlZXM7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcFJlY3RhbmdsZSh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICB9O1xuXG4gIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoayA9ICtfLCByZWNlbnRlcigpKSA6IGs7XG4gIH07XG5cbiAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9ICtfWzBdLCB5ID0gK19bMV0sIHJlY2VudGVyKCkpIDogW3gsIHldO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBwaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBbbGFtYmRhICogZGVncmVlcywgcGhpICogZGVncmVlc107XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVsdGFMYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgZGVsdGFQaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgZGVsdGFHYW1tYSA9IF8ubGVuZ3RoID4gMiA/IF9bMl0gJSAzNjAgKiByYWRpYW5zIDogMCwgcmVjZW50ZXIoKSkgOiBbZGVsdGFMYW1iZGEgKiBkZWdyZWVzLCBkZWx0YVBoaSAqIGRlZ3JlZXMsIGRlbHRhR2FtbWEgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gXyAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogYWxwaGEgKiBkZWdyZWVzO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucmVmbGVjdFggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ggPSBfID8gLTEgOiAxLCByZWNlbnRlcigpKSA6IHN4IDwgMDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJlZmxlY3RZID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN5ID0gXyA/IC0xIDogMSwgcmVjZW50ZXIoKSkgOiBzeSA8IDA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyID0gXyAqIF8pLCByZXNldCgpKSA6IHNxcnQoZGVsdGEyKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjZW50ZXIoKSB7XG4gICAgdmFyIGNlbnRlciA9IHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIDAsIDAsIHN4LCBzeSwgYWxwaGEpLmFwcGx5KG51bGwsIHByb2plY3QobGFtYmRhLCBwaGkpKSxcbiAgICAgICAgdHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgeCAtIGNlbnRlclswXSwgeSAtIGNlbnRlclsxXSwgc3gsIHN5LCBhbHBoYSk7XG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpO1xuICAgIHByb2plY3RUcmFuc2Zvcm0gPSBjb21wb3NlKHByb2plY3QsIHRyYW5zZm9ybSk7XG4gICAgcHJvamVjdFJvdGF0ZVRyYW5zZm9ybSA9IGNvbXBvc2Uocm90YXRlLCBwcm9qZWN0VHJhbnNmb3JtKTtcbiAgICBwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIpO1xuICAgIHJldHVybiByZXNldCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcHJvamVjdCA9IHByb2plY3RBdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHByb2plY3Rpb24uaW52ZXJ0ID0gcHJvamVjdC5pbnZlcnQgJiYgaW52ZXJ0O1xuICAgIHJldHVybiByZWNlbnRlcigpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW59IGZyb20gXCIuLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCByYWRpYW5zLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuXG52YXIgbWF4RGVwdGggPSAxNiwgLy8gbWF4aW11bSBkZXB0aCBvZiBzdWJkaXZpc2lvblxuICAgIGNvc01pbkRpc3RhbmNlID0gY29zKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHByb2plY3QsIGRlbHRhMikge1xuICByZXR1cm4gK2RlbHRhMiA/IHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikgOiByZXNhbXBsZU5vbmUocHJvamVjdCk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlTm9uZShwcm9qZWN0KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzYW1wbGUocHJvamVjdCwgZGVsdGEyKSB7XG5cbiAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICB2YXIgZHggPSB4MSAtIHgwLFxuICAgICAgICBkeSA9IHkxIC0geTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgaWYgKGQyID4gNCAqIGRlbHRhMiAmJiBkZXB0aC0tKSB7XG4gICAgICB2YXIgYSA9IGEwICsgYTEsXG4gICAgICAgICAgYiA9IGIwICsgYjEsXG4gICAgICAgICAgYyA9IGMwICsgYzEsXG4gICAgICAgICAgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSxcbiAgICAgICAgICBwaGkyID0gYXNpbihjIC89IG0pLFxuICAgICAgICAgIGxhbWJkYTIgPSBhYnMoYWJzKGMpIC0gMSkgPCBlcHNpbG9uIHx8IGFicyhsYW1iZGEwIC0gbGFtYmRhMSkgPCBlcHNpbG9uID8gKGxhbWJkYTAgKyBsYW1iZGExKSAvIDIgOiBhdGFuMihiLCBhKSxcbiAgICAgICAgICBwID0gcHJvamVjdChsYW1iZGEyLCBwaGkyKSxcbiAgICAgICAgICB4MiA9IHBbMF0sXG4gICAgICAgICAgeTIgPSBwWzFdLFxuICAgICAgICAgIGR4MiA9IHgyIC0geDAsXG4gICAgICAgICAgZHkyID0geTIgLSB5MCxcbiAgICAgICAgICBkeiA9IGR5ICogZHgyIC0gZHggKiBkeTI7XG4gICAgICBpZiAoZHogKiBkeiAvIGQyID4gZGVsdGEyIC8vIHBlcnBlbmRpY3VsYXIgcHJvamVjdGVkIGRpc3RhbmNlXG4gICAgICAgICAgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gMC41KSA+IDAuMyAvLyBtaWRwb2ludCBjbG9zZSB0byBhbiBlbmRcbiAgICAgICAgICB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkgeyAvLyBhbmd1bGFyIGRpc3RhbmNlXG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDIsIHkyLCBsYW1iZGEyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MiwgeTIsIGxhbWJkYTIsIGEsIGIsIGMsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgbGFtYmRhMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICBsYW1iZGEwLCB4MCwgeTAsIGEwLCBiMCwgYzA7IC8vIHByZXZpb3VzIHBvaW50XG5cbiAgICB2YXIgcmVzYW1wbGVTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvblN0YXJ0KCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IHJpbmdTdGFydDsgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvbkVuZCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7IH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgeDAgPSBOYU47XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIHZhciBjID0gY2FydGVzaWFuKFtsYW1iZGEsIHBoaV0pLCBwID0gcHJvamVjdChsYW1iZGEsIHBoaSk7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCBsYW1iZGEwID0gbGFtYmRhLCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICBsaW5lU3RhcnQoKTtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lUG9pbnQobGFtYmRhMDAgPSBsYW1iZGEsIHBoaSksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCBsYW1iZGEwMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgIGxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzYW1wbGVTdHJlYW07XG4gIH07XG59XG4iLCJpbXBvcnQgY29tcG9zZSBmcm9tIFwiLi9jb21wb3NlLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZGVncmVlcywgcGksIHJhZGlhbnMsIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHJvdGF0aW9uSWRlbnRpdHkobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFthYnMobGFtYmRhKSA+IHBpID8gbGFtYmRhICsgTWF0aC5yb3VuZCgtbGFtYmRhIC8gdGF1KSAqIHRhdSA6IGxhbWJkYSwgcGhpXTtcbn1cblxucm90YXRpb25JZGVudGl0eS5pbnZlcnQgPSByb3RhdGlvbklkZW50aXR5O1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgcmV0dXJuIChkZWx0YUxhbWJkYSAlPSB0YXUpID8gKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyBjb21wb3NlKHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSwgcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkpXG4gICAgOiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkpXG4gICAgOiAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpXG4gICAgOiByb3RhdGlvbklkZW50aXR5KTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHJldHVybiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBsYW1iZGEgKz0gZGVsdGFMYW1iZGEsIFtsYW1iZGEgPiBwaSA/IGxhbWJkYSAtIHRhdSA6IGxhbWJkYSA8IC1waSA/IGxhbWJkYSArIHRhdSA6IGxhbWJkYSwgcGhpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgdmFyIHJvdGF0aW9uID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKTtcbiAgcm90YXRpb24uaW52ZXJ0ID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKC1kZWx0YUxhbWJkYSk7XG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICB2YXIgY29zRGVsdGFQaGkgPSBjb3MoZGVsdGFQaGkpLFxuICAgICAgc2luRGVsdGFQaGkgPSBzaW4oZGVsdGFQaGkpLFxuICAgICAgY29zRGVsdGFHYW1tYSA9IGNvcyhkZWx0YUdhbW1hKSxcbiAgICAgIHNpbkRlbHRhR2FtbWEgPSBzaW4oZGVsdGFHYW1tYSk7XG5cbiAgZnVuY3Rpb24gcm90YXRpb24obGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICAgIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB6ID0gc2luKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFQaGkgKyB4ICogc2luRGVsdGFQaGk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hIC0gayAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSAtIHogKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YUdhbW1hICsgeSAqIHNpbkRlbHRhR2FtbWEpXG4gICAgXTtcbiAgfVxuXG4gIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgICB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgICBrID0geiAqIGNvc0RlbHRhR2FtbWEgLSB5ICogc2luRGVsdGFHYW1tYTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgKyB6ICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpICsgayAqIHNpbkRlbHRhUGhpKSxcbiAgICAgIGFzaW4oayAqIGNvc0RlbHRhUGhpIC0geCAqIHNpbkRlbHRhUGhpKVxuICAgIF07XG4gIH07XG5cbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyb3RhdGUpIHtcbiAgcm90YXRlID0gcm90YXRlUmFkaWFucyhyb3RhdGVbMF0gKiByYWRpYW5zLCByb3RhdGVbMV0gKiByYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIHJhZGlhbnMgOiAwKTtcblxuICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlcztcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlcztcbiAgfTtcblxuICByZXR1cm4gZm9yd2FyZDtcbn1cbiIsImZ1bmN0aW9uIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBzdHJlYW0pIHtcbiAgaWYgKGdlb21ldHJ5ICYmIHN0cmVhbUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkge1xuICAgIHN0cmVhbUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgc3RyZWFtKTtcbiAgfVxufVxuXG52YXIgc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgRmVhdHVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH0sXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShmZWF0dXJlc1tpXS5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfVxufTtcblxudmFyIHN0cmVhbUdlb21ldHJ5VHlwZSA9IHtcbiAgU3BoZXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbS5zcGhlcmUoKTtcbiAgfSxcbiAgUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgfSxcbiAgTXVsdGlQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgb2JqZWN0ID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgfSxcbiAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1MaW5lKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtLCAwKTtcbiAgfSxcbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDApO1xuICB9LFxuICBQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbVBvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0pO1xuICB9LFxuICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSk7XG4gIH0sXG4gIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgc3RyZWFtKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyZWFtTGluZShjb29yZGluYXRlcywgc3RyZWFtLCBjbG9zZWQpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIGNsb3NlZCwgY29vcmRpbmF0ZTtcbiAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSk7XG4gIHN0cmVhbS5saW5lRW5kKCk7XG59XG5cbmZ1bmN0aW9uIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXMsIHN0cmVhbSkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDEpO1xuICBzdHJlYW0ucG9seWdvbkVuZCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICBpZiAob2JqZWN0ICYmIHN0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgc3RyZWFtT2JqZWN0VHlwZVtvYmplY3QudHlwZV0ob2JqZWN0LCBzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdCwgc3RyZWFtKTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWV0aG9kcykge1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogdHJhbnNmb3JtZXIobWV0aG9kcylcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKG1ldGhvZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBzID0gbmV3IFRyYW5zZm9ybVN0cmVhbTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykgc1trZXldID0gbWV0aG9kc1trZXldO1xuICAgIHMuc3RyZWFtID0gc3RyZWFtO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW0oKSB7fVxuXG5UcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNmb3JtU3RyZWFtLFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLnN0cmVhbS5wb2ludCh4LCB5KTsgfSxcbiAgc3BoZXJlOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0uc3BoZXJlKCk7IH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVTdGFydCgpOyB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZUVuZCgpOyB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25FbmQoKTsgfVxufTtcbiIsImV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG5leHBvcnQgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbmV4cG9ydCB2YXIgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgdmFyIGV4cCA9IE1hdGguZXhwO1xuZXhwb3J0IHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5leHBvcnQgdmFyIGxvZyA9IE1hdGgubG9nO1xuZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHBvdyA9IE1hdGgucG93O1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5leHBvcnQgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciB0YW4gPSBNYXRoLnRhbjtcblxuZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtNjtcbmV4cG9ydCB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCB2YXIgc3FydDFfMiA9IE1hdGguU1FSVDFfMjtcbmV4cG9ydCB2YXIgc3FydDIgPSBzcXJ0KDIpO1xuZXhwb3J0IHZhciBzcXJ0UGkgPSBzcXJ0KHBpKTtcbmV4cG9ydCB2YXIgdGF1ID0gcGkgKiAyO1xuZXhwb3J0IHZhciBkZWdyZWVzID0gMTgwIC8gcGk7XG5leHBvcnQgdmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmNpKHgpIHtcbiAgcmV0dXJuIHggPyB4IC8gTWF0aC5zaW4oeCkgOiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCh4KSB7XG4gIHJldHVybiB4ID4gMCA/IE1hdGguc3FydCh4KSA6IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgeCA9IGV4cCgyICogeCk7XG4gIHJldHVybiAoeCAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKGV4cCh4KSAtIGV4cCgteCkpIC8gMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKGV4cCh4KSArIGV4cCgteCkpIC8gMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyc2luaCh4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmNvc2goeCkge1xuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMSkpO1xufVxuIiwiaW1wb3J0IHtnZW9Qcm9qZWN0aW9uIGFzIHByb2plY3Rpb259IGZyb20gXCJkMy1nZW9cIjtcbmltcG9ydCB7YWJzLCBkZWdyZWVzLCBlcHNpbG9uMiwgZmxvb3IsIGhhbGZQaSwgbWF4LCBtaW4sIHBpLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbnZhciBLID0gW1xuICBbMC45OTg2LCAtMC4wNjJdLFxuICBbMS4wMDAwLCAwLjAwMDBdLFxuICBbMC45OTg2LCAwLjA2MjBdLFxuICBbMC45OTU0LCAwLjEyNDBdLFxuICBbMC45OTAwLCAwLjE4NjBdLFxuICBbMC45ODIyLCAwLjI0ODBdLFxuICBbMC45NzMwLCAwLjMxMDBdLFxuICBbMC45NjAwLCAwLjM3MjBdLFxuICBbMC45NDI3LCAwLjQzNDBdLFxuICBbMC45MjE2LCAwLjQ5NThdLFxuICBbMC44OTYyLCAwLjU1NzFdLFxuICBbMC44Njc5LCAwLjYxNzZdLFxuICBbMC44MzUwLCAwLjY3NjldLFxuICBbMC43OTg2LCAwLjczNDZdLFxuICBbMC43NTk3LCAwLjc5MDNdLFxuICBbMC43MTg2LCAwLjg0MzVdLFxuICBbMC42NzMyLCAwLjg5MzZdLFxuICBbMC42MjEzLCAwLjkzOTRdLFxuICBbMC41NzIyLCAwLjk3NjFdLFxuICBbMC41MzIyLCAxLjAwMDBdXG5dO1xuXG5LLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICBkWzFdICo9IDEuMDE0NDtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gcm9iaW5zb25SYXcobGFtYmRhLCBwaGkpIHtcbiAgdmFyIGkgPSBtaW4oMTgsIGFicyhwaGkpICogMzYgLyBwaSksXG4gICAgICBpMCA9IGZsb29yKGkpLFxuICAgICAgZGkgPSBpIC0gaTAsXG4gICAgICBheCA9IChrID0gS1tpMF0pWzBdLFxuICAgICAgYXkgPSBrWzFdLFxuICAgICAgYnggPSAoayA9IEtbKytpMF0pWzBdLFxuICAgICAgYnkgPSBrWzFdLFxuICAgICAgY3ggPSAoayA9IEtbbWluKDE5LCArK2kwKV0pWzBdLFxuICAgICAgY3kgPSBrWzFdLFxuICAgICAgaztcbiAgcmV0dXJuIFtcbiAgICBsYW1iZGEgKiAoYnggKyBkaSAqIChjeCAtIGF4KSAvIDIgKyBkaSAqIGRpICogKGN4IC0gMiAqIGJ4ICsgYXgpIC8gMiksXG4gICAgKHBoaSA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKSAqIChieSArIGRpICogKGN5IC0gYXkpIC8gMiArIGRpICogZGkgKiAoY3kgLSAyICogYnkgKyBheSkgLyAyKVxuICBdO1xufVxuXG5yb2JpbnNvblJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB5eSA9IHkgLyBoYWxmUGksXG4gICAgICBwaGkgPSB5eSAqIDkwLFxuICAgICAgaSA9IG1pbigxOCwgYWJzKHBoaSAvIDUpKSxcbiAgICAgIGkwID0gbWF4KDAsIGZsb29yKGkpKTtcbiAgZG8ge1xuICAgIHZhciBheSA9IEtbaTBdWzFdLFxuICAgICAgICBieSA9IEtbaTAgKyAxXVsxXSxcbiAgICAgICAgY3kgPSBLW21pbigxOSwgaTAgKyAyKV1bMV0sXG4gICAgICAgIHUgPSBjeSAtIGF5LFxuICAgICAgICB2ID0gY3kgLSAyICogYnkgKyBheSxcbiAgICAgICAgdCA9IDIgKiAoYWJzKHl5KSAtIGJ5KSAvIHUsXG4gICAgICAgIGMgPSB2IC8gdSxcbiAgICAgICAgZGkgPSB0ICogKDEgLSBjICogdCAqICgxIC0gMiAqIGMgKiB0KSk7XG4gICAgaWYgKGRpID49IDAgfHwgaTAgPT09IDEpIHtcbiAgICAgIHBoaSA9ICh5ID49IDAgPyA1IDogLTUpICogKGRpICsgaSk7XG4gICAgICB2YXIgaiA9IDUwLCBkZWx0YTtcbiAgICAgIGRvIHtcbiAgICAgICAgaSA9IG1pbigxOCwgYWJzKHBoaSkgLyA1KTtcbiAgICAgICAgaTAgPSBmbG9vcihpKTtcbiAgICAgICAgZGkgPSBpIC0gaTA7XG4gICAgICAgIGF5ID0gS1tpMF1bMV07XG4gICAgICAgIGJ5ID0gS1tpMCArIDFdWzFdO1xuICAgICAgICBjeSA9IEtbbWluKDE5LCBpMCArIDIpXVsxXTtcbiAgICAgICAgcGhpIC09IChkZWx0YSA9ICh5ID49IDAgPyBoYWxmUGkgOiAtaGFsZlBpKSAqIChieSArIGRpICogKGN5IC0gYXkpIC8gMiArIGRpICogZGkgKiAoY3kgLSAyICogYnkgKyBheSkgLyAyKSAtIHkpICogZGVncmVlcztcbiAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uMiAmJiAtLWogPiAwKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSB3aGlsZSAoLS1pMCA+PSAwKTtcbiAgdmFyIGF4ID0gS1tpMF1bMF0sXG4gICAgICBieCA9IEtbaTAgKyAxXVswXSxcbiAgICAgIGN4ID0gS1ttaW4oMTksIGkwICsgMildWzBdO1xuICByZXR1cm4gW1xuICAgIHggLyAoYnggKyBkaSAqIChjeCAtIGF4KSAvIDIgKyBkaSAqIGRpICogKGN4IC0gMiAqIGJ4ICsgYXgpIC8gMiksXG4gICAgcGhpICogcmFkaWFuc1xuICBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKHJvYmluc29uUmF3KVxuICAgICAgLnNjYWxlKDE1Mi42Myk7XG59XG4iLCJpbXBvcnQge2FzaW4sIGF0YW4yLCBjb3MsIHNpbiwgc3FydH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICByZXR1cm4gW2F0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgYXNpbihjYXJ0ZXNpYW5bMl0pXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgdmFyIGxhbWJkYSA9IHNwaGVyaWNhbFswXSwgcGhpID0gc3BoZXJpY2FsWzFdLCBjb3NQaGkgPSBjb3MocGhpKTtcbiAgcmV0dXJuIFtjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG59XG5cbi8vIFRPRE8gcmV0dXJuIGFcbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcbiAgYVswXSArPSBiWzBdLCBhWzFdICs9IGJbMV0sIGFbMl0gKz0gYlsyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICByZXR1cm4gW3ZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGtdO1xufVxuXG4vLyBUT0RPIHJldHVybiBkXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShkKSB7XG4gIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICBkWzBdIC89IGwsIGRbMV0gLz0gbCwgZFsyXSAvPSBsO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2FzaW4sIGF0YW4yLCBjb3MsIGRlZ3JlZXMsIGVwc2lsb24sIGVwc2lsb24yLCBoeXBvdCwgcmFkaWFucywgc2luLCBzcXJ0fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi9ub29wLmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuL3N0cmVhbS5qc1wiO1xuXG52YXIgVzAsIFcxLFxuICAgIFgwLCBZMCwgWjAsXG4gICAgWDEsIFkxLCBaMSxcbiAgICBYMiwgWTIsIFoyLFxuICAgIGxhbWJkYTAwLCBwaGkwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICB4MCwgeTAsIHowOyAvLyBwcmV2aW91cyBwb2ludFxuXG52YXIgY2VudHJvaWRTdHJlYW0gPSB7XG4gIHNwaGVyZTogbm9vcCxcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9XG59O1xuXG4vLyBBcml0aG1ldGljIG1lYW4gb2YgQ2FydGVzaWFuIHZlY3RvcnMuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKGNvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgsIHksIHopIHtcbiAgKytXMDtcbiAgWDAgKz0gKHggLSBYMCkgLyBXMDtcbiAgWTAgKz0gKHkgLSBZMCkgLyBXMDtcbiAgWjAgKz0gKHogLSBaMCkgLyBXMDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludDtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICB3ID0gYXRhbjIoc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuLy8gU2VlIEouIEUuIEJyb2NrLCBUaGUgSW5lcnRpYSBUZW5zb3IgZm9yIGEgU3BoZXJpY2FsIFRyaWFuZ2xlLFxuLy8gSi4gQXBwbGllZCBNZWNoYW5pY3MgNDIsIDIzOSAoMTk3NSkuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEwMCA9IGxhbWJkYSwgcGhpMDAgPSBwaGk7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludDtcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICB6MCA9IHNpbihwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSxcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSxcbiAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgIGN4ID0geTAgKiB6IC0gejAgKiB5LFxuICAgICAgY3kgPSB6MCAqIHggLSB4MCAqIHosXG4gICAgICBjeiA9IHgwICogeSAtIHkwICogeCxcbiAgICAgIG0gPSBoeXBvdChjeCwgY3ksIGN6KSxcbiAgICAgIHcgPSBhc2luKG0pLCAvLyBsaW5lIHdlaWdodCA9IGFuZ2xlXG4gICAgICB2ID0gbSAmJiAtdyAvIG07IC8vIGFyZWEgd2VpZ2h0IG11bHRpcGxpZXJcbiAgWDIuYWRkKHYgKiBjeCk7XG4gIFkyLmFkZCh2ICogY3kpO1xuICBaMi5hZGQodiAqIGN6KTtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0KSB7XG4gIFcwID0gVzEgPVxuICBYMCA9IFkwID0gWjAgPVxuICBYMSA9IFkxID0gWjEgPSAwO1xuICBYMiA9IG5ldyBBZGRlcigpO1xuICBZMiA9IG5ldyBBZGRlcigpO1xuICBaMiA9IG5ldyBBZGRlcigpO1xuICBzdHJlYW0ob2JqZWN0LCBjZW50cm9pZFN0cmVhbSk7XG5cbiAgdmFyIHggPSArWDIsXG4gICAgICB5ID0gK1kyLFxuICAgICAgeiA9ICtaMixcbiAgICAgIG0gPSBoeXBvdCh4LCB5LCB6KTtcblxuICAvLyBJZiB0aGUgYXJlYS13ZWlnaHRlZCBjY2VudHJvaWQgaXMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbGVuZ3RoLXdlaWdodGVkIGNjZW50cm9pZC5cbiAgaWYgKG0gPCBlcHNpbG9uMikge1xuICAgIHggPSBYMSwgeSA9IFkxLCB6ID0gWjE7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXG4gICAgaWYgKFcxIDwgZXBzaWxvbikgeCA9IFgwLCB5ID0gWTAsIHogPSBaMDtcbiAgICBtID0gaHlwb3QoeCwgeSwgeik7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgc3RpbGwgaGFzIGFuIHVuZGVmaW5lZCBjY2VudHJvaWQsIHRoZW4gcmV0dXJuLlxuICAgIGlmIChtIDwgZXBzaWxvbjIpIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG5cbiAgcmV0dXJuIFthdGFuMih5LCB4KSAqIGRlZ3JlZXMsIGFzaW4oeiAvIG0pICogZGVncmVlc107XG59XG4iLCJpbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZSwgc3BoZXJpY2FsfSBmcm9tIFwiLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHthY29zLCBjb3MsIGRlZ3JlZXMsIGVwc2lsb24sIHJhZGlhbnMsIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQge3JvdGF0ZVJhZGlhbnN9IGZyb20gXCIuL3JvdGF0aW9uLmpzXCI7XG5cbi8vIEdlbmVyYXRlcyBhIGNpcmNsZSBjZW50ZXJlZCBhdCBbMMKwLCAwwrBdLCB3aXRoIGEgZ2l2ZW4gcmFkaXVzIGFuZCBwcmVjaXNpb24uXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCB0MCwgdDEpIHtcbiAgaWYgKCFkZWx0YSkgcmV0dXJuO1xuICB2YXIgY29zUmFkaXVzID0gY29zKHJhZGl1cyksXG4gICAgICBzaW5SYWRpdXMgPSBzaW4ocmFkaXVzKSxcbiAgICAgIHN0ZXAgPSBkaXJlY3Rpb24gKiBkZWx0YTtcbiAgaWYgKHQwID09IG51bGwpIHtcbiAgICB0MCA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIHRhdTtcbiAgICB0MSA9IHJhZGl1cyAtIHN0ZXAgLyAyO1xuICB9IGVsc2Uge1xuICAgIHQwID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDApO1xuICAgIHQxID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDEpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwID8gdDAgPCB0MSA6IHQwID4gdDEpIHQwICs9IGRpcmVjdGlvbiAqIHRhdTtcbiAgfVxuICBmb3IgKHZhciBwb2ludCwgdCA9IHQwOyBkaXJlY3Rpb24gPiAwID8gdCA+IHQxIDogdCA8IHQxOyB0IC09IHN0ZXApIHtcbiAgICBwb2ludCA9IHNwaGVyaWNhbChbY29zUmFkaXVzLCAtc2luUmFkaXVzICogY29zKHQpLCAtc2luUmFkaXVzICogc2luKHQpXSk7XG4gICAgc3RyZWFtLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgc2lnbmVkIGFuZ2xlIG9mIGEgY2FydGVzaWFuIHBvaW50IHJlbGF0aXZlIHRvIFtjb3NSYWRpdXMsIDAsIDBdLlxuZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcbiAgcG9pbnQgPSBjYXJ0ZXNpYW4ocG9pbnQpLCBwb2ludFswXSAtPSBjb3NSYWRpdXM7XG4gIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UocG9pbnQpO1xuICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xuICByZXR1cm4gKCgtcG9pbnRbMl0gPCAwID8gLXJhZGl1cyA6IHJhZGl1cykgKyB0YXUgLSBlcHNpbG9uKSAlIHRhdTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjZW50ZXIgPSBjb25zdGFudChbMCwgMF0pLFxuICAgICAgcmFkaXVzID0gY29uc3RhbnQoOTApLFxuICAgICAgcHJlY2lzaW9uID0gY29uc3RhbnQoMiksXG4gICAgICByaW5nLFxuICAgICAgcm90YXRlLFxuICAgICAgc3RyZWFtID0ge3BvaW50OiBwb2ludH07XG5cbiAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICB4WzBdICo9IGRlZ3JlZXMsIHhbMV0gKj0gZGVncmVlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICB2YXIgYyA9IGNlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByID0gcmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zLFxuICAgICAgICBwID0gcHJlY2lzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zO1xuICAgIHJpbmcgPSBbXTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKC1jWzBdICogcmFkaWFucywgLWNbMV0gKiByYWRpYW5zLCAwKS5pbnZlcnQ7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgciwgcCwgMSk7XG4gICAgYyA9IHt0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtyaW5nXX07XG4gICAgcmluZyA9IHJvdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBjaXJjbGUuY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoWytfWzBdLCArX1sxXV0pLCBjaXJjbGUpIDogY2VudGVyO1xuICB9O1xuXG4gIGNpcmNsZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjaXNpb24gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHByZWNpc2lvbjtcbiAgfTtcblxuICByZXR1cm4gY2lyY2xlO1xufVxuIiwiaW1wb3J0IGNsaXAgZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7YWJzLCBhdGFuLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgcGksIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xpcChcbiAgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICBjbGlwQW50aW1lcmlkaWFuTGluZSxcbiAgY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLFxuICBbLXBpLCAtaGFsZlBpXVxuKTtcblxuLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlczogMCAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm8gaW50ZXJzZWN0aW9uczsgMiAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgc2hvdWxkIGJlIHJlam9pbmVkLlxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkxpbmUoc3RyZWFtKSB7XG4gIHZhciBsYW1iZGEwID0gTmFOLFxuICAgICAgcGhpMCA9IE5hTixcbiAgICAgIHNpZ24wID0gTmFOLFxuICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcblxuICByZXR1cm4ge1xuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICBjbGVhbiA9IDE7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhMSwgcGhpMSkge1xuICAgICAgdmFyIHNpZ24xID0gbGFtYmRhMSA+IDAgPyBwaSA6IC1waSxcbiAgICAgICAgICBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XG4gICAgICBpZiAoYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbikgeyAvLyBsaW5lIGNyb3NzZXMgYSBwb2xlXG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwLCBwaGkwID0gKHBoaTAgKyBwaGkxKSAvIDIgPiAwID8gaGFsZlBpIDogLWhhbGZQaSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24wICE9PSBzaWduMSAmJiBkZWx0YSA+PSBwaSkgeyAvLyBsaW5lIGNyb3NzZXMgYW50aW1lcmlkaWFuXG4gICAgICAgIGlmIChhYnMobGFtYmRhMCAtIHNpZ24wKSA8IGVwc2lsb24pIGxhbWJkYTAgLT0gc2lnbjAgKiBlcHNpbG9uOyAvLyBoYW5kbGUgZGVnZW5lcmFjaWVzXG4gICAgICAgIGlmIChhYnMobGFtYmRhMSAtIHNpZ24xKSA8IGVwc2lsb24pIGxhbWJkYTEgLT0gc2lnbjEgKiBlcHNpbG9uO1xuICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9XG4gICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCA9IGxhbWJkYTEsIHBoaTAgPSBwaGkxKTtcbiAgICAgIHNpZ24wID0gc2lnbjE7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICBsYW1iZGEwID0gcGhpMCA9IE5hTjtcbiAgICB9LFxuICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAyIC0gY2xlYW47IC8vIGlmIGludGVyc2VjdGlvbnMsIHJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKSB7XG4gIHZhciBjb3NQaGkwLFxuICAgICAgY29zUGhpMSxcbiAgICAgIHNpbkxhbWJkYTBMYW1iZGExID0gc2luKGxhbWJkYTAgLSBsYW1iZGExKTtcbiAgcmV0dXJuIGFicyhzaW5MYW1iZGEwTGFtYmRhMSkgPiBlcHNpbG9uXG4gICAgICA/IGF0YW4oKHNpbihwaGkwKSAqIChjb3NQaGkxID0gY29zKHBoaTEpKSAqIHNpbihsYW1iZGExKVxuICAgICAgICAgIC0gc2luKHBoaTEpICogKGNvc1BoaTAgPSBjb3MocGhpMCkpICogc2luKGxhbWJkYTApKVxuICAgICAgICAgIC8gKGNvc1BoaTAgKiBjb3NQaGkxICogc2luTGFtYmRhMExhbWJkYTEpKVxuICAgICAgOiAocGhpMCArIHBoaTEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICB2YXIgcGhpO1xuICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgcGhpID0gZGlyZWN0aW9uICogaGFsZlBpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgfSBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IGVwc2lsb24pIHtcbiAgICB2YXIgbGFtYmRhID0gZnJvbVswXSA8IHRvWzBdID8gcGkgOiAtcGk7XG4gICAgcGhpID0gZGlyZWN0aW9uICogbGFtYmRhIC8gMjtcbiAgICBzdHJlYW0ucG9pbnQoLWxhbWJkYSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICB9XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmVzID0gW10sXG4gICAgICBsaW5lO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5LCBtKSB7XG4gICAgICBsaW5lLnB1c2goW3gsIHksIG1dKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBub29wLFxuICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsaW5lcztcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBsaW5lID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbkFkZEluUGxhY2UsIGNhcnRlc2lhbkNyb3NzLCBjYXJ0ZXNpYW5Eb3QsIGNhcnRlc2lhblNjYWxlLCBzcGhlcmljYWx9IGZyb20gXCIuLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7Y2lyY2xlU3RyZWFtfSBmcm9tIFwiLi4vY2lyY2xlLmpzXCI7XG5pbXBvcnQge2FicywgY29zLCBlcHNpbG9uLCBwaSwgcmFkaWFucywgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBwb2ludEVxdWFsIGZyb20gXCIuLi9wb2ludEVxdWFsLmpzXCI7XG5pbXBvcnQgY2xpcCBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIGNyID0gY29zKHJhZGl1cyksXG4gICAgICBkZWx0YSA9IDIgKiByYWRpYW5zLFxuICAgICAgc21hbGxSYWRpdXMgPSBjciA+IDAsXG4gICAgICBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IGVwc2lsb247IC8vIFRPRE8gb3B0aW1pc2UgZm9yIHRoaXMgY29tbW9uIGNhc2VcblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIGZyb20sIHRvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGUobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gY29zKGxhbWJkYSkgKiBjb3MocGhpKSA+IGNyO1xuICB9XG5cbiAgLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlcyB1c2VkIGZvciBwb2x5Z29uXG4gIC8vIGNsaXBwaW5nOiAwIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vXG4gIC8vIGludGVyc2VjdGlvbnMgMiAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAvLyBzaG91bGQgYmUgcmVqb2luZWQuXG4gIGZ1bmN0aW9uIGNsaXBMaW5lKHN0cmVhbSkge1xuICAgIHZhciBwb2ludDAsIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGMwLCAvLyBjb2RlIGZvciBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MCwgLy8gdmlzaWJpbGl0eSBvZiBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MDAsIC8vIHZpc2liaWxpdHkgb2YgZmlyc3QgcG9pbnRcbiAgICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgcG9pbnQxID0gW2xhbWJkYSwgcGhpXSxcbiAgICAgICAgICAgIHBvaW50MixcbiAgICAgICAgICAgIHYgPSB2aXNpYmxlKGxhbWJkYSwgcGhpKSxcbiAgICAgICAgICAgIGMgPSBzbWFsbFJhZGl1c1xuICAgICAgICAgICAgICA/IHYgPyAwIDogY29kZShsYW1iZGEsIHBoaSlcbiAgICAgICAgICAgICAgOiB2ID8gY29kZShsYW1iZGEgKyAobGFtYmRhIDwgMCA/IHBpIDogLXBpKSwgcGhpKSA6IDA7XG4gICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgaWYgKCFwb2ludDIgfHwgcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MikgfHwgcG9pbnRFcXVhbChwb2ludDEsIHBvaW50MikpXG4gICAgICAgICAgICBwb2ludDFbMl0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgLy8gb3V0c2lkZSBnb2luZyBpblxuICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2lkZSBnb2luZyBvdXRcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0sIDIpO1xuICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgIHZhciB0O1xuICAgICAgICAgIC8vIElmIHRoZSBjb2RlcyBmb3IgdHdvIHBvaW50cyBhcmUgZGlmZmVyZW50LCBvciBhcmUgYm90aCB6ZXJvLFxuICAgICAgICAgIC8vIGFuZCB0aGVyZSB0aGlzIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzbWFsbCBjaXJjbGUuXG4gICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2MCkgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIGFuZCBsYXN0IHBvaW50cyB3ZXJlIHZpc2libGUuXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJzZWN0cyB0aGUgZ3JlYXQgY2lyY2xlIGJldHdlZW4gYSBhbmQgYiB3aXRoIHRoZSBjbGlwIGNpcmNsZS5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgIHZhciBwYSA9IGNhcnRlc2lhbihhKSxcbiAgICAgICAgcGIgPSBjYXJ0ZXNpYW4oYik7XG5cbiAgICAvLyBXZSBoYXZlIHR3byBwbGFuZXMsIG4xLnAgPSBkMSBhbmQgbjIucCA9IGQyLlxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIGxpbmUgcCh0KSA9IGMxIG4xICsgYzIgbjIgKyB0IChuMSDiqK8gbjIpLlxuICAgIHZhciBuMSA9IFsxLCAwLCAwXSwgLy8gbm9ybWFsXG4gICAgICAgIG4yID0gY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSxcbiAgICAgICAgbjJuMiA9IGNhcnRlc2lhbkRvdChuMiwgbjIpLFxuICAgICAgICBuMW4yID0gbjJbMF0sIC8vIGNhcnRlc2lhbkRvdChuMSwgbjIpLFxuICAgICAgICBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcblxuICAgIC8vIFR3byBwb2xhciBwb2ludHMuXG4gICAgaWYgKCFkZXRlcm1pbmFudCkgcmV0dXJuICF0d28gJiYgYTtcblxuICAgIHZhciBjMSA9ICBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIG4xeG4yID0gY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSxcbiAgICAgICAgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksXG4gICAgICAgIEIgPSBjYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UoQSwgQik7XG5cbiAgICAvLyBTb2x2ZSB8cCh0KXxeMiA9IDEuXG4gICAgdmFyIHUgPSBuMXhuMixcbiAgICAgICAgdyA9IGNhcnRlc2lhbkRvdChBLCB1KSxcbiAgICAgICAgdXUgPSBjYXJ0ZXNpYW5Eb3QodSwgdSksXG4gICAgICAgIHQyID0gdyAqIHcgLSB1dSAqIChjYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcblxuICAgIGlmICh0MiA8IDApIHJldHVybjtcblxuICAgIHZhciB0ID0gc3FydCh0MiksXG4gICAgICAgIHEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHEsIEEpO1xuICAgIHEgPSBzcGhlcmljYWwocSk7XG5cbiAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG5cbiAgICAvLyBUd28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICB2YXIgbGFtYmRhMCA9IGFbMF0sXG4gICAgICAgIGxhbWJkYTEgPSBiWzBdLFxuICAgICAgICBwaGkwID0gYVsxXSxcbiAgICAgICAgcGhpMSA9IGJbMV0sXG4gICAgICAgIHo7XG5cbiAgICBpZiAobGFtYmRhMSA8IGxhbWJkYTApIHogPSBsYW1iZGEwLCBsYW1iZGEwID0gbGFtYmRhMSwgbGFtYmRhMSA9IHo7XG5cbiAgICB2YXIgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgcG9sYXIgPSBhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uLFxuICAgICAgICBtZXJpZGlhbiA9IHBvbGFyIHx8IGRlbHRhIDwgZXBzaWxvbjtcblxuICAgIGlmICghcG9sYXIgJiYgcGhpMSA8IHBoaTApIHogPSBwaGkwLCBwaGkwID0gcGhpMSwgcGhpMSA9IHo7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBwb2ludCBpcyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgaWYgKG1lcmlkaWFuXG4gICAgICAgID8gcG9sYXJcbiAgICAgICAgICA/IHBoaTAgKyBwaGkxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSBsYW1iZGEwKSA8IGVwc2lsb24gPyBwaGkwIDogcGhpMSlcbiAgICAgICAgICA6IHBoaTAgPD0gcVsxXSAmJiBxWzFdIDw9IHBoaTFcbiAgICAgICAgOiBkZWx0YSA+IHBpIF4gKGxhbWJkYTAgPD0gcVswXSAmJiBxWzBdIDw9IGxhbWJkYTEpKSB7XG4gICAgICB2YXIgcTEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocTEsIEEpO1xuICAgICAgcmV0dXJuIFtxLCBzcGhlcmljYWwocTEpXTtcbiAgICB9XG4gIH1cblxuICAvLyBHZW5lcmF0ZXMgYSA0LWJpdCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IHJlbGF0aXZlIHRvXG4gIC8vIHRoZSBzbWFsbCBjaXJjbGUncyBib3VuZGluZyBib3guXG4gIGZ1bmN0aW9uIGNvZGUobGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogcGkgLSByYWRpdXMsXG4gICAgICAgIGNvZGUgPSAwO1xuICAgIGlmIChsYW1iZGEgPCAtcikgY29kZSB8PSAxOyAvLyBsZWZ0XG4gICAgZWxzZSBpZiAobGFtYmRhID4gcikgY29kZSB8PSAyOyAvLyByaWdodFxuICAgIGlmIChwaGkgPCAtcikgY29kZSB8PSA0OyAvLyBiZWxvd1xuICAgIGVsc2UgaWYgKHBoaSA+IHIpIGNvZGUgfD0gODsgLy8gYWJvdmVcbiAgICByZXR1cm4gY29kZTtcbiAgfVxuXG4gIHJldHVybiBjbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbMCwgLXJhZGl1c10gOiBbLXBpLCByYWRpdXMgLSBwaV0pO1xufVxuIiwiaW1wb3J0IGNsaXBCdWZmZXIgZnJvbSBcIi4vYnVmZmVyLmpzXCI7XG5pbXBvcnQgY2xpcFJlam9pbiBmcm9tIFwiLi9yZWpvaW4uanNcIjtcbmltcG9ydCB7ZXBzaWxvbiwgaGFsZlBpfSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHBvbHlnb25Db250YWlucyBmcm9tIFwiLi4vcG9seWdvbkNvbnRhaW5zLmpzXCI7XG5pbXBvcnQge21lcmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHN0YXJ0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzaW5rKSB7XG4gICAgdmFyIGxpbmUgPSBjbGlwTGluZShzaW5rKSxcbiAgICAgICAgcmluZ0J1ZmZlciA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgcmluZ1NpbmsgPSBjbGlwTGluZShyaW5nQnVmZmVyKSxcbiAgICAgICAgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHJpbmc7XG5cbiAgICB2YXIgY2xpcCA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uQ29udGFpbnMocG9seWdvbiwgc3RhcnQpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc2luayk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgc2luay5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBpZiAocG9pbnRWaXNpYmxlKGxhbWJkYSwgcGhpKSkgc2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgbGluZS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRSaW5nKGxhbWJkYSwgcGhpKSB7XG4gICAgICByaW5nLnB1c2goW2xhbWJkYSwgcGhpXSk7XG4gICAgICByaW5nU2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgcmluZ1NpbmsubGluZVN0YXJ0KCk7XG4gICAgICByaW5nID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgIHJpbmdTaW5rLmxpbmVFbmQoKTtcblxuICAgICAgdmFyIGNsZWFuID0gcmluZ1NpbmsuY2xlYW4oKSxcbiAgICAgICAgICByaW5nU2VnbWVudHMgPSByaW5nQnVmZmVyLnJlc3VsdCgpLFxuICAgICAgICAgIGksIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoLCBtLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgcG9pbnQ7XG5cbiAgICAgIHJpbmcucG9wKCk7XG4gICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICByaW5nID0gbnVsbDtcblxuICAgICAgaWYgKCFuKSByZXR1cm47XG5cbiAgICAgIC8vIE5vIGludGVyc2VjdGlvbnMuXG4gICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgIGlmICgobSA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPiAwKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc2luay5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVqb2luIGNvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgIC8vIFRPRE8gcmV1c2UgcmluZ0J1ZmZlci5yZWpvaW4oKT9cbiAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcblxuICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKHZhbGlkU2VnbWVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudC5sZW5ndGggPiAxO1xufVxuXG4vLyBJbnRlcnNlY3Rpb25zIGFyZSBzb3J0ZWQgYWxvbmcgdGhlIGNsaXAgZWRnZS4gRm9yIGJvdGggYW50aW1lcmlkaWFuIGN1dHRpbmdcbi8vIGFuZCBjaXJjbGUgY2xpcHBpbmcsIHRoZSBzYW1lIGNvbXBhcmlzb24gaXMgdXNlZC5cbmZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGFbMV0pXG4gICAgICAgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYlsxXSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgdDAgPSAwLFxuICAgICAgdDEgPSAxLFxuICAgICAgZHggPSBieCAtIGF4LFxuICAgICAgZHkgPSBieSAtIGF5LFxuICAgICAgcjtcblxuICByID0geDAgLSBheDtcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHgxIC0gYXg7XG4gIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIHIgPSB5MCAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geTEgLSBheTtcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgaWYgKHQwID4gMCkgYVswXSA9IGF4ICsgdDAgKiBkeCwgYVsxXSA9IGF5ICsgdDAgKiBkeTtcbiAgaWYgKHQxIDwgMSkgYlswXSA9IGF4ICsgdDEgKiBkeCwgYlsxXSA9IGF5ICsgdDEgKiBkeTtcbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBjbGlwQnVmZmVyIGZyb20gXCIuL2J1ZmZlci5qc1wiO1xuaW1wb3J0IGNsaXBMaW5lIGZyb20gXCIuL2xpbmUuanNcIjtcbmltcG9ydCBjbGlwUmVqb2luIGZyb20gXCIuL3Jlam9pbi5qc1wiO1xuaW1wb3J0IHttZXJnZX0gZnJvbSBcImQzLWFycmF5XCI7XG5cbnZhciBjbGlwTWF4ID0gMWU5LCBjbGlwTWluID0gLWNsaXBNYXg7XG5cbi8vIFRPRE8gVXNlIGQzLXBvbHlnb27igJlzIHBvbHlnb25Db250YWlucyBoZXJlIGZvciB0aGUgcmluZyBjaGVjaz9cbi8vIFRPRE8gRWxpbWluYXRlIGR1cGxpY2F0ZSBidWZmZXJpbmcgaW4gY2xpcEJ1ZmZlciBhbmQgcG9seWdvbi5wdXNoP1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjbGlwUmVjdGFuZ2xlKHgwLCB5MCwgeDEsIHkxKSB7XG5cbiAgZnVuY3Rpb24gdmlzaWJsZSh4LCB5KSB7XG4gICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICB2YXIgYSA9IDAsIGExID0gMDtcbiAgICBpZiAoZnJvbSA9PSBudWxsXG4gICAgICAgIHx8IChhID0gY29ybmVyKGZyb20sIGRpcmVjdGlvbikpICE9PSAoYTEgPSBjb3JuZXIodG8sIGRpcmVjdGlvbikpXG4gICAgICAgIHx8IGNvbXBhcmVQb2ludChmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgZG8gc3RyZWFtLnBvaW50KGEgPT09IDAgfHwgYSA9PT0gMyA/IHgwIDogeDEsIGEgPiAxID8geTEgOiB5MCk7XG4gICAgICB3aGlsZSAoKGEgPSAoYSArIGRpcmVjdGlvbiArIDQpICUgNCkgIT09IGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBhYnMocFswXSAtIHgwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMCA6IDNcbiAgICAgICAgOiBhYnMocFswXSAtIHgxKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMiA6IDFcbiAgICAgICAgOiBhYnMocFsxXSAtIHkwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMSA6IDBcbiAgICAgICAgOiBkaXJlY3Rpb24gPiAwID8gMyA6IDI7IC8vIGFicyhwWzFdIC0geTEpIDwgZXBzaWxvblxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVQb2ludChhLngsIGIueCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlUG9pbnQoYSwgYikge1xuICAgIHZhciBjYSA9IGNvcm5lcihhLCAxKSxcbiAgICAgICAgY2IgPSBjb3JuZXIoYiwgMSk7XG4gICAgcmV0dXJuIGNhICE9PSBjYiA/IGNhIC0gY2JcbiAgICAgICAgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdXG4gICAgICAgIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXVxuICAgICAgICA6IGNhID09PSAyID8gYVsxXSAtIGJbMV1cbiAgICAgICAgOiBiWzBdIC0gYVswXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgYWN0aXZlU3RyZWFtID0gc3RyZWFtLFxuICAgICAgICBidWZmZXJTdHJlYW0gPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICByaW5nLFxuICAgICAgICB4X18sIHlfXywgdl9fLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICB4XywgeV8sIHZfLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICBmaXJzdCxcbiAgICAgICAgY2xlYW47XG5cbiAgICB2YXIgY2xpcFN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogcG9seWdvblN0YXJ0LFxuICAgICAgcG9seWdvbkVuZDogcG9seWdvbkVuZFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBpZiAodmlzaWJsZSh4LCB5KSkgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25JbnNpZGUoKSB7XG4gICAgICB2YXIgd2luZGluZyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgcmluZyA9IHBvbHlnb25baV0sIGogPSAxLCBtID0gcmluZy5sZW5ndGgsIHBvaW50ID0gcmluZ1swXSwgYTAsIGExLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgYTAgPSBiMCwgYTEgPSBiMSwgcG9pbnQgPSByaW5nW2pdLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdO1xuICAgICAgICAgIGlmIChhMSA8PSB5MSkgeyBpZiAoYjEgPiB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPiAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpICsrd2luZGluZzsgfVxuICAgICAgICAgIGVsc2UgeyBpZiAoYjEgPD0geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpIDwgKGIxIC0gYTEpICogKHgwIC0gYTApKSAtLXdpbmRpbmc7IH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2luZGluZztcbiAgICB9XG5cbiAgICAvLyBCdWZmZXIgZ2VvbWV0cnkgd2l0aGluIGEgcG9seWdvbiBhbmQgdGhlbiBjbGlwIGl0IGVuIG1hc3NlLlxuICAgIGZ1bmN0aW9uIHBvbHlnb25TdGFydCgpIHtcbiAgICAgIGFjdGl2ZVN0cmVhbSA9IGJ1ZmZlclN0cmVhbSwgc2VnbWVudHMgPSBbXSwgcG9seWdvbiA9IFtdLCBjbGVhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkVuZCgpIHtcbiAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25JbnNpZGUoKSxcbiAgICAgICAgICBjbGVhbkluc2lkZSA9IGNsZWFuICYmIHN0YXJ0SW5zaWRlLFxuICAgICAgICAgIHZpc2libGUgPSAoc2VnbWVudHMgPSBtZXJnZShzZWdtZW50cykpLmxlbmd0aDtcbiAgICAgIGlmIChjbGVhbkluc2lkZSB8fCB2aXNpYmxlKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgaWYgKGNsZWFuSW5zaWRlKSB7XG4gICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHN0cmVhbSk7XG4gICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgICAgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgdl8gPSBmYWxzZTtcbiAgICAgIHhfID0geV8gPSBOYU47XG4gICAgfVxuXG4gICAgLy8gVE9ETyByYXRoZXIgdGhhbiBzcGVjaWFsLWNhc2UgcG9seWdvbnMsIHNpbXBseSBoYW5kbGUgdGhlbSBzZXBhcmF0ZWx5LlxuICAgIC8vIElkZWFsbHksIGNvaW5jaWRlbnQgaW50ZXJzZWN0aW9uIHBvaW50cyBzaG91bGQgYmUgaml0dGVyZWQgdG8gYXZvaWRcbiAgICAvLyBjbGlwcGluZyBpc3N1ZXMuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICBpZiAodl9fICYmIHZfKSBidWZmZXJTdHJlYW0ucmVqb2luKCk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyU3RyZWFtLnJlc3VsdCgpKTtcbiAgICAgIH1cbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIGlmICh2XykgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgdmFyIHYgPSB2aXNpYmxlKHgsIHkpO1xuICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbeCwgeV0pO1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgJiYgdl8pIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGEgPSBbeF8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4XykpLCB5XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHlfKSldLFxuICAgICAgICAgICAgICBiID0gW3ggPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4KSksIHkgPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5KSldO1xuICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcbiAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYVswXSwgYVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYlswXSwgYlsxXSk7XG4gICAgICAgICAgICBpZiAoIXYpIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBTdHJlYW07XG4gIH07XG59XG4iLCJpbXBvcnQgcG9pbnRFcXVhbCBmcm9tIFwiLi4vcG9pbnRFcXVhbC5qc1wiO1xuaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gIHRoaXMueCA9IHBvaW50O1xuICB0aGlzLnogPSBwb2ludHM7XG4gIHRoaXMubyA9IG90aGVyOyAvLyBhbm90aGVyIGludGVyc2VjdGlvblxuICB0aGlzLmUgPSBlbnRyeTsgLy8gaXMgYW4gZW50cnk/XG4gIHRoaXMudiA9IGZhbHNlOyAvLyB2aXNpdGVkXG4gIHRoaXMubiA9IHRoaXMucCA9IG51bGw7IC8vIG5leHQgJiBwcmV2aW91c1xufVxuXG4vLyBBIGdlbmVyYWxpemVkIHBvbHlnb24gY2xpcHBpbmcgYWxnb3JpdGhtOiBnaXZlbiBhIHBvbHlnb24gdGhhdCBoYXMgYmVlbiBjdXRcbi8vIGludG8gaXRzIHZpc2libGUgbGluZSBzZWdtZW50cywgYW5kIHJlam9pbnMgdGhlIHNlZ21lbnRzIGJ5IGludGVycG9sYXRpbmdcbi8vIGFsb25nIHRoZSBjbGlwIGVkZ2UuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pIHtcbiAgdmFyIHN1YmplY3QgPSBbXSxcbiAgICAgIGNsaXAgPSBbXSxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMCkgcmV0dXJuO1xuICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXSwgeDtcblxuICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgIGlmICghcDBbMl0gJiYgIXAxWzJdKSB7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBkZWdlbmVyYXRlIGNhc2VzIGJ5IG1vdmluZyB0aGUgcG9pbnRcbiAgICAgIHAxWzBdICs9IDIgKiBlcHNpbG9uO1xuICAgIH1cblxuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBudWxsLCB4LCBmYWxzZSkpO1xuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMSwgc2VnbWVudCwgbnVsbCwgZmFsc2UpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMSwgbnVsbCwgeCwgdHJ1ZSkpO1xuICB9KTtcblxuICBpZiAoIXN1YmplY3QubGVuZ3RoKSByZXR1cm47XG5cbiAgY2xpcC5zb3J0KGNvbXBhcmVJbnRlcnNlY3Rpb24pO1xuICBsaW5rKHN1YmplY3QpO1xuICBsaW5rKGNsaXApO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNsaXBbaV0uZSA9IHN0YXJ0SW5zaWRlID0gIXN0YXJ0SW5zaWRlO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvaW50O1xuXG4gIHdoaWxlICgxKSB7XG4gICAgLy8gRmluZCBmaXJzdCB1bnZpc2l0ZWQgaW50ZXJzZWN0aW9uLlxuICAgIHZhciBjdXJyZW50ID0gc3RhcnQsXG4gICAgICAgIGlzU3ViamVjdCA9IHRydWU7XG4gICAgd2hpbGUgKGN1cnJlbnQudikgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpIHJldHVybjtcbiAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICBmb3IgKGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGluayhhcnJheSkge1xuICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgYSA9IGFycmF5WzBdLFxuICAgICAgYjtcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgYi5wID0gYTtcbiAgICBhID0gYjtcbiAgfVxuICBhLm4gPSBiID0gYXJyYXlbMF07XG4gIGIucCA9IGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG5cbiAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xuICB9XG5cbiAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KSBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICB9O1xuXG4gIHJldHVybiBjb21wb3NlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQge3JhbmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7YWJzLCBjZWlsLCBlcHNpbG9ufSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICB2YXIgeSA9IHJhbmdlKHkwLCB5MSAtIGVwc2lsb24sIGR5KS5jb25jYXQoeTEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geS5tYXAoZnVuY3Rpb24oeSkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gIHZhciB4ID0gcmFuZ2UoeDAsIHgxIC0gZXBzaWxvbiwgZHgpLmNvbmNhdCh4MSk7XG4gIHJldHVybiBmdW5jdGlvbih5KSB7IHJldHVybiB4Lm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gIHZhciB4MSwgeDAsIFgxLCBYMCxcbiAgICAgIHkxLCB5MCwgWTEsIFkwLFxuICAgICAgZHggPSAxMCwgZHkgPSBkeCwgRFggPSA5MCwgRFkgPSAzNjAsXG4gICAgICB4LCB5LCBYLCBZLFxuICAgICAgcHJlY2lzaW9uID0gMi41O1xuXG4gIGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBsaW5lcygpfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgIHJldHVybiByYW5nZShjZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpXG4gICAgICAgIC5jb25jYXQocmFuZ2UoY2VpbChZMCAvIERZKSAqIERZLCBZMSwgRFkpLm1hcChZKSlcbiAgICAgICAgLmNvbmNhdChyYW5nZShjZWlsKHgwIC8gZHgpICogZHgsIHgxLCBkeCkuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGFicyh4ICUgRFgpID4gZXBzaWxvbjsgfSkubWFwKHgpKVxuICAgICAgICAuY29uY2F0KHJhbmdlKGNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uOyB9KS5tYXAoeSkpO1xuICB9XG5cbiAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7IHJldHVybiB7dHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307IH0pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgWChYMCkuY29uY2F0KFxuICAgICAgICBZKFkxKS5zbGljZSgxKSxcbiAgICAgICAgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLFxuICAgICAgICBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpXG4gICAgICBdXG4gICAgfTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWFqb3IoXykuZXh0ZW50TWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbWDAsIFkwXSwgW1gxLCBZMV1dO1xuICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICBpZiAoWDAgPiBYMSkgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICBpZiAoeDAgPiB4MSkgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgaWYgKHkwID4geTEpIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuc3RlcE1ham9yKF8pLnN0ZXBNaW5vcihfKTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtEWCwgRFldO1xuICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICBwcmVjaXNpb24gPSArXztcbiAgICB4ID0gZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICB5ID0gZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgWCA9IGdyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgWSA9IGdyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgcmV0dXJuIGdyYXRpY3VsZVxuICAgICAgLmV4dGVudE1ham9yKFtbLTE4MCwgLTkwICsgZXBzaWxvbl0sIFsxODAsIDkwIC0gZXBzaWxvbl1dKVxuICAgICAgLmV4dGVudE1pbm9yKFtbLTE4MCwgLTgwIC0gZXBzaWxvbl0sIFsxODAsIDgwICsgZXBzaWxvbl1dKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXRpY3VsZTEwKCkge1xuICByZXR1cm4gZ3JhdGljdWxlKCkoKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4geDtcbiIsImV4cG9ydCB2YXIgZXBzaWxvbiA9IDFlLTY7XG5leHBvcnQgdmFyIGVwc2lsb24yID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG5leHBvcnQgdmFyIHRhdSA9IHBpICogMjtcblxuZXhwb3J0IHZhciBkZWdyZWVzID0gMTgwIC8gcGk7XG5leHBvcnQgdmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxuZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbmV4cG9ydCB2YXIgZXhwID0gTWF0aC5leHA7XG5leHBvcnQgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbmV4cG9ydCB2YXIgaHlwb3QgPSBNYXRoLmh5cG90O1xuZXhwb3J0IHZhciBsb2cgPSBNYXRoLmxvZztcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuZXhwb3J0IHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuZXhwb3J0IHZhciB0YW4gPSBNYXRoLnRhbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhdmVyc2luKHgpIHtcbiAgcmV0dXJuICh4ID0gc2luKHggLyAyKSkgKiB4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7YWJzfSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIGFyZWFTdW0gPSBuZXcgQWRkZXIoKSxcbiAgICBhcmVhUmluZ1N1bSA9IG5ldyBBZGRlcigpLFxuICAgIHgwMCxcbiAgICB5MDAsXG4gICAgeDAsXG4gICAgeTA7XG5cbnZhciBhcmVhU3RyZWFtID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcbiAgICBhcmVhU3RyZWFtLmxpbmVFbmQgPSBhcmVhUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhU3RyZWFtLmxpbmVFbmQgPSBhcmVhU3RyZWFtLnBvaW50ID0gbm9vcDtcbiAgICBhcmVhU3VtLmFkZChhYnMoYXJlYVJpbmdTdW0pKTtcbiAgICBhcmVhUmluZ1N1bSA9IG5ldyBBZGRlcigpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmVhID0gYXJlYVN1bSAvIDI7XG4gICAgYXJlYVN1bSA9IG5ldyBBZGRlcigpO1xuICAgIHJldHVybiBhcmVhO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0KCkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KHgsIHkpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludDtcbiAgeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludCh4LCB5KSB7XG4gIGFyZWFSaW5nU3VtLmFkZCh5MCAqIHggLSB4MCAqIHkpO1xuICB4MCA9IHgsIHkwID0geTtcbn1cblxuZnVuY3Rpb24gYXJlYVJpbmdFbmQoKSB7XG4gIGFyZWFQb2ludCh4MDAsIHkwMCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFyZWFTdHJlYW07XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG52YXIgeDAgPSBJbmZpbml0eSxcbiAgICB5MCA9IHgwLFxuICAgIHgxID0gLXgwLFxuICAgIHkxID0geDE7XG5cbnZhciBib3VuZHNTdHJlYW0gPSB7XG4gIHBvaW50OiBib3VuZHNQb2ludCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gIHBvbHlnb25FbmQ6IG5vb3AsXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvdW5kcyA9IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIHgxID0geTEgPSAtKHkwID0geDAgPSBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufTtcblxuZnVuY3Rpb24gYm91bmRzUG9pbnQoeCwgeSkge1xuICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gIGlmICh4ID4geDEpIHgxID0geDtcbiAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICBpZiAoeSA+IHkxKSB5MSA9IHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJvdW5kc1N0cmVhbTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuLy8gVE9ETyBFbmZvcmNlIHBvc2l0aXZlIGFyZWEgZm9yIGV4dGVyaW9yLCBuZWdhdGl2ZSBhcmVhIGZvciBpbnRlcmlvcj9cblxudmFyIFgwID0gMCxcbiAgICBZMCA9IDAsXG4gICAgWjAgPSAwLFxuICAgIFgxID0gMCxcbiAgICBZMSA9IDAsXG4gICAgWjEgPSAwLFxuICAgIFgyID0gMCxcbiAgICBZMiA9IDAsXG4gICAgWjIgPSAwLFxuICAgIHgwMCxcbiAgICB5MDAsXG4gICAgeDAsXG4gICAgeTA7XG5cbnZhciBjZW50cm9pZFN0cmVhbSA9IHtcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZDtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2VudHJvaWQgPSBaMiA/IFtYMiAvIFoyLCBZMiAvIFoyXVxuICAgICAgICA6IFoxID8gW1gxIC8gWjEsIFkxIC8gWjFdXG4gICAgICAgIDogWjAgPyBbWDAgLyBaMCwgWTAgLyBaMF1cbiAgICAgICAgOiBbTmFOLCBOYU5dO1xuICAgIFgwID0gWTAgPSBaMCA9XG4gICAgWDEgPSBZMSA9IFoxID1cbiAgICBYMiA9IFkyID0gWjIgPSAwO1xuICAgIHJldHVybiBjZW50cm9pZDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludCh4LCB5KSB7XG4gIFgwICs9IHg7XG4gIFkwICs9IHk7XG4gICsrWjA7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdExpbmU7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdExpbmUoeCwgeSkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRMaW5lO1xuICBjZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludExpbmUoeCwgeSkge1xuICB2YXIgZHggPSB4IC0geDAsIGR5ID0geSAtIHkwLCB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gIFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gIFoxICs9IHo7XG4gIGNlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0UmluZztcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xuICBjZW50cm9pZFBvaW50UmluZyh4MDAsIHkwMCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdFJpbmcoeCwgeSkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRSaW5nO1xuICBjZW50cm9pZFBvaW50KHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludFJpbmcoeCwgeSkge1xuICB2YXIgZHggPSB4IC0geDAsXG4gICAgICBkeSA9IHkgLSB5MCxcbiAgICAgIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICBYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICBZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICBaMSArPSB6O1xuXG4gIHogPSB5MCAqIHggLSB4MCAqIHk7XG4gIFgyICs9IHogKiAoeDAgKyB4KTtcbiAgWTIgKz0geiAqICh5MCArIHkpO1xuICBaMiArPSB6ICogMztcbiAgY2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNlbnRyb2lkU3RyZWFtO1xuIiwiaW1wb3J0IHt0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYXRoQ29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5QYXRoQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gIF9yYWRpdXM6IDQuNSxcbiAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzID0gXywgdGhpcztcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHggKyB0aGlzLl9yYWRpdXMsIHkpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyh4LCB5LCB0aGlzLl9yYWRpdXMsIDAsIHRhdSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzdWx0OiBub29wXG59O1xuIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHN0cmVhbSBmcm9tIFwiLi4vc3RyZWFtLmpzXCI7XG5pbXBvcnQgcGF0aEFyZWEgZnJvbSBcIi4vYXJlYS5qc1wiO1xuaW1wb3J0IHBhdGhCb3VuZHMgZnJvbSBcIi4vYm91bmRzLmpzXCI7XG5pbXBvcnQgcGF0aENlbnRyb2lkIGZyb20gXCIuL2NlbnRyb2lkLmpzXCI7XG5pbXBvcnQgUGF0aENvbnRleHQgZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHBhdGhNZWFzdXJlIGZyb20gXCIuL21lYXN1cmUuanNcIjtcbmltcG9ydCBQYXRoU3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcm9qZWN0aW9uLCBjb250ZXh0KSB7XG4gIGxldCBkaWdpdHMgPSAzLFxuICAgICAgcG9pbnRSYWRpdXMgPSA0LjUsXG4gICAgICBwcm9qZWN0aW9uU3RyZWFtLFxuICAgICAgY29udGV4dFN0cmVhbTtcblxuICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNvbnRleHRTdHJlYW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gIH1cblxuICBwYXRoLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhBcmVhKSk7XG4gICAgcmV0dXJuIHBhdGhBcmVhLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgubWVhc3VyZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aE1lYXN1cmUpKTtcbiAgICByZXR1cm4gcGF0aE1lYXN1cmUucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhCb3VuZHMpKTtcbiAgICByZXR1cm4gcGF0aEJvdW5kcy5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLmNlbnRyb2lkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQ2VudHJvaWQpKTtcbiAgICByZXR1cm4gcGF0aENlbnRyb2lkLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcm9qZWN0aW9uO1xuICAgIHByb2plY3Rpb25TdHJlYW0gPSBfID09IG51bGwgPyAocHJvamVjdGlvbiA9IG51bGwsIGlkZW50aXR5KSA6IChwcm9qZWN0aW9uID0gXykuc3RyZWFtO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgIGNvbnRleHRTdHJlYW0gPSBfID09IG51bGwgPyAoY29udGV4dCA9IG51bGwsIG5ldyBQYXRoU3RyaW5nKGRpZ2l0cykpIDogbmV3IFBhdGhDb250ZXh0KGNvbnRleHQgPSBfKTtcbiAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHBhdGgucG9pbnRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9pbnRSYWRpdXM7XG4gICAgcG9pbnRSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IChjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtfKSwgK18pO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHBhdGguZGlnaXRzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpZ2l0cztcbiAgICBpZiAoXyA9PSBudWxsKSBkaWdpdHMgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZCA9IE1hdGguZmxvb3IoXyk7XG4gICAgICBpZiAoIShkID49IDApKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7X31gKTtcbiAgICAgIGRpZ2l0cyA9IGQ7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSBjb250ZXh0U3RyZWFtID0gbmV3IFBhdGhTdHJpbmcoZGlnaXRzKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKHByb2plY3Rpb24pLmRpZ2l0cyhkaWdpdHMpLmNvbnRleHQoY29udGV4dCk7XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciBsZW5ndGhTdW0gPSBuZXcgQWRkZXIoKSxcbiAgICBsZW5ndGhSaW5nLFxuICAgIHgwMCxcbiAgICB5MDAsXG4gICAgeDAsXG4gICAgeTA7XG5cbnZhciBsZW5ndGhTdHJlYW0gPSB7XG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3Q7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChsZW5ndGhSaW5nKSBsZW5ndGhQb2ludCh4MDAsIHkwMCk7XG4gICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbm9vcDtcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhSaW5nID0gdHJ1ZTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoUmluZyA9IG51bGw7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9ICtsZW5ndGhTdW07XG4gICAgbGVuZ3RoU3VtID0gbmV3IEFkZGVyKCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxufTtcblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdCh4LCB5KSB7XG4gIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50O1xuICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnQoeCwgeSkge1xuICB4MCAtPSB4LCB5MCAtPSB5O1xuICBsZW5ndGhTdW0uYWRkKHNxcnQoeDAgKiB4MCArIHkwICogeTApKTtcbiAgeDAgPSB4LCB5MCA9IHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxlbmd0aFN0cmVhbTtcbiIsIi8vIFNpbXBsZSBjYWNoaW5nIGZvciBjb25zdGFudC1yYWRpdXMgcG9pbnRzLlxubGV0IGNhY2hlRGlnaXRzLCBjYWNoZUFwcGVuZCwgY2FjaGVSYWRpdXMsIGNhY2hlQ2lyY2xlO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoU3RyaW5nIHtcbiAgY29uc3RydWN0b3IoZGlnaXRzKSB7XG4gICAgdGhpcy5fYXBwZW5kID0gZGlnaXRzID09IG51bGwgPyBhcHBlbmQgOiBhcHBlbmRSb3VuZChkaWdpdHMpO1xuICAgIHRoaXMuX3JhZGl1cyA9IDQuNTtcbiAgICB0aGlzLl8gPSBcIlwiO1xuICB9XG4gIHBvaW50UmFkaXVzKF8pIHtcbiAgICB0aGlzLl9yYWRpdXMgPSArXztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwb2x5Z29uU3RhcnQoKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH1cbiAgcG9seWdvbkVuZCgpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9XG4gIGxpbmVTdGFydCgpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH1cbiAgbGluZUVuZCgpIHtcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fICs9IFwiWlwiO1xuICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICB9XG4gIHBvaW50KHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fYXBwZW5kYE0ke3h9LCR7eX1gO1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2FwcGVuZGBMJHt4fSwke3l9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuX2FwcGVuZGBNJHt4fSwke3l9YDtcbiAgICAgICAgaWYgKHRoaXMuX3JhZGl1cyAhPT0gY2FjaGVSYWRpdXMgfHwgdGhpcy5fYXBwZW5kICE9PSBjYWNoZUFwcGVuZCkge1xuICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9yYWRpdXM7XG4gICAgICAgICAgY29uc3QgcyA9IHRoaXMuXztcbiAgICAgICAgICB0aGlzLl8gPSBcIlwiOyAvLyBzdGFzaCB0aGUgb2xkIHN0cmluZyBzbyB3ZSBjYW4gY2FjaGUgdGhlIGNpcmNsZSBwYXRoIGZyYWdtZW50XG4gICAgICAgICAgdGhpcy5fYXBwZW5kYG0wLCR7cn1hJHtyfSwke3J9IDAgMSwxIDAsJHstMiAqIHJ9YSR7cn0sJHtyfSAwIDEsMSAwLCR7MiAqIHJ9emA7XG4gICAgICAgICAgY2FjaGVSYWRpdXMgPSByO1xuICAgICAgICAgIGNhY2hlQXBwZW5kID0gdGhpcy5fYXBwZW5kO1xuICAgICAgICAgIGNhY2hlQ2lyY2xlID0gdGhpcy5fO1xuICAgICAgICAgIHRoaXMuXyA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fICs9IGNhY2hlQ2lyY2xlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzdWx0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuXztcbiAgICB0aGlzLl8gPSBcIlwiO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBlbmQoc3RyaW5ncykge1xuICBsZXQgaSA9IDE7XG4gIHRoaXMuXyArPSBzdHJpbmdzWzBdO1xuICBmb3IgKGNvbnN0IGogPSBzdHJpbmdzLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgIHRoaXMuXyArPSBhcmd1bWVudHNbaV0gKyBzdHJpbmdzW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFJvdW5kKGRpZ2l0cykge1xuICBjb25zdCBkID0gTWF0aC5mbG9vcihkaWdpdHMpO1xuICBpZiAoIShkID49IDApKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7ZGlnaXRzfWApO1xuICBpZiAoZCA+IDE1KSByZXR1cm4gYXBwZW5kO1xuICBpZiAoZCAhPT0gY2FjaGVEaWdpdHMpIHtcbiAgICBjb25zdCBrID0gMTAgKiogZDtcbiAgICBjYWNoZURpZ2l0cyA9IGQ7XG4gICAgY2FjaGVBcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RyaW5ncykge1xuICAgICAgbGV0IGkgPSAxO1xuICAgICAgdGhpcy5fICs9IHN0cmluZ3NbMF07XG4gICAgICBmb3IgKGNvbnN0IGogPSBzdHJpbmdzLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICB0aGlzLl8gKz0gTWF0aC5yb3VuZChhcmd1bWVudHNbaV0gKiBrKSAvIGsgKyBzdHJpbmdzW2ldO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNhY2hlQXBwZW5kO1xufVxuIiwiaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IGVwc2lsb24gJiYgYWJzKGFbMV0gLSBiWzFdKSA8IGVwc2lsb247XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5Dcm9zcywgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZX0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgZXBzaWxvbjIsIGhhbGZQaSwgcGksIHF1YXJ0ZXJQaSwgc2lnbiwgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gbG9uZ2l0dWRlKHBvaW50KSB7XG4gIHJldHVybiBhYnMocG9pbnRbMF0pIDw9IHBpID8gcG9pbnRbMF0gOiBzaWduKHBvaW50WzBdKSAqICgoYWJzKHBvaW50WzBdKSArIHBpKSAlIHRhdSAtIHBpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocG9seWdvbiwgcG9pbnQpIHtcbiAgdmFyIGxhbWJkYSA9IGxvbmdpdHVkZShwb2ludCksXG4gICAgICBwaGkgPSBwb2ludFsxXSxcbiAgICAgIHNpblBoaSA9IHNpbihwaGkpLFxuICAgICAgbm9ybWFsID0gW3NpbihsYW1iZGEpLCAtY29zKGxhbWJkYSksIDBdLFxuICAgICAgYW5nbGUgPSAwLFxuICAgICAgd2luZGluZyA9IDA7XG5cbiAgdmFyIHN1bSA9IG5ldyBBZGRlcigpO1xuXG4gIGlmIChzaW5QaGkgPT09IDEpIHBoaSA9IGhhbGZQaSArIGVwc2lsb247XG4gIGVsc2UgaWYgKHNpblBoaSA9PT0gLTEpIHBoaSA9IC1oYWxmUGkgLSBlcHNpbG9uO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoIShtID0gKHJpbmcgPSBwb2x5Z29uW2ldKS5sZW5ndGgpKSBjb250aW51ZTtcbiAgICB2YXIgcmluZyxcbiAgICAgICAgbSxcbiAgICAgICAgcG9pbnQwID0gcmluZ1ttIC0gMV0sXG4gICAgICAgIGxhbWJkYTAgPSBsb25naXR1ZGUocG9pbnQwKSxcbiAgICAgICAgcGhpMCA9IHBvaW50MFsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgIHNpblBoaTAgPSBzaW4ocGhpMCksXG4gICAgICAgIGNvc1BoaTAgPSBjb3MocGhpMCk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG07ICsraiwgbGFtYmRhMCA9IGxhbWJkYTEsIHNpblBoaTAgPSBzaW5QaGkxLCBjb3NQaGkwID0gY29zUGhpMSwgcG9pbnQwID0gcG9pbnQxKSB7XG4gICAgICB2YXIgcG9pbnQxID0gcmluZ1tqXSxcbiAgICAgICAgICBsYW1iZGExID0gbG9uZ2l0dWRlKHBvaW50MSksXG4gICAgICAgICAgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgICAgc2luUGhpMSA9IHNpbihwaGkxKSxcbiAgICAgICAgICBjb3NQaGkxID0gY29zKHBoaTEpLFxuICAgICAgICAgIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgICAgc2lnbiA9IGRlbHRhID49IDAgPyAxIDogLTEsXG4gICAgICAgICAgYWJzRGVsdGEgPSBzaWduICogZGVsdGEsXG4gICAgICAgICAgYW50aW1lcmlkaWFuID0gYWJzRGVsdGEgPiBwaSxcbiAgICAgICAgICBrID0gc2luUGhpMCAqIHNpblBoaTE7XG5cbiAgICAgIHN1bS5hZGQoYXRhbjIoayAqIHNpZ24gKiBzaW4oYWJzRGVsdGEpLCBjb3NQaGkwICogY29zUGhpMSArIGsgKiBjb3MoYWJzRGVsdGEpKSk7XG4gICAgICBhbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkZWx0YSArIHNpZ24gKiB0YXUgOiBkZWx0YTtcblxuICAgICAgLy8gQXJlIHRoZSBsb25naXR1ZGVzIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludOKAmXMgbWVyaWRpYW4gKGxhbWJkYSksXG4gICAgICAvLyBhbmQgYXJlIHRoZSBsYXRpdHVkZXMgc21hbGxlciB0aGFuIHRoZSBwYXJhbGxlbCAocGhpKT9cbiAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiBsYW1iZGEwID49IGxhbWJkYSBeIGxhbWJkYTEgPj0gbGFtYmRhKSB7XG4gICAgICAgIHZhciBhcmMgPSBjYXJ0ZXNpYW5Dcm9zcyhjYXJ0ZXNpYW4ocG9pbnQwKSwgY2FydGVzaWFuKHBvaW50MSkpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGFyYyk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhub3JtYWwsIGFyYyk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgdmFyIHBoaUFyYyA9IChhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gLTEgOiAxKSAqIGFzaW4oaW50ZXJzZWN0aW9uWzJdKTtcbiAgICAgICAgaWYgKHBoaSA+IHBoaUFyYyB8fCBwaGkgPT09IHBoaUFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICB3aW5kaW5nICs9IGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCwgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIFNvdXRoIHBvbGUgaXMgaW5zaWRlIG9yIG91dHNpZGU6XG4gIC8vXG4gIC8vIEl0IGlzIGluc2lkZSBpZjpcbiAgLy8gKiB0aGUgcG9seWdvbiB3aW5kcyBhcm91bmQgaXQgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLlxuICAvLyAqIHRoZSBwb2x5Z29uIGRvZXMgbm90IChjdW11bGF0aXZlbHkpIHdpbmQgYXJvdW5kIGl0LCBidXQgaGFzIGEgbmVnYXRpdmVcbiAgLy8gICAoY291bnRlci1jbG9ja3dpc2UpIGFyZWEuXG4gIC8vXG4gIC8vIFNlY29uZCwgY291bnQgdGhlIChzaWduZWQpIG51bWJlciBvZiB0aW1lcyBhIHNlZ21lbnQgY3Jvc3NlcyBhIGxhbWJkYVxuICAvLyBmcm9tIHRoZSBwb2ludCB0byB0aGUgU291dGggcG9sZS4gIElmIGl0IGlzIHplcm8sIHRoZW4gdGhlIHBvaW50IGlzIHRoZVxuICAvLyBzYW1lIHNpZGUgYXMgdGhlIFNvdXRoIHBvbGUuXG5cbiAgcmV0dXJuIChhbmdsZSA8IC1lcHNpbG9uIHx8IGFuZ2xlIDwgZXBzaWxvbiAmJiBzdW0gPCAtZXBzaWxvbjIpIF4gKHdpbmRpbmcgJiAxKTtcbn1cbiIsImltcG9ydCB7YXNpbiwgYXRhbjIsIGNvcywgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gYXppbXV0aGFsUmF3KHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGN4ID0gY29zKHgpLFxuICAgICAgICBjeSA9IGNvcyh5KSxcbiAgICAgICAgayA9IHNjYWxlKGN4ICogY3kpO1xuICAgICAgICBpZiAoayA9PT0gSW5maW5pdHkpIHJldHVybiBbMiwgMF07XG4gICAgcmV0dXJuIFtcbiAgICAgIGsgKiBjeSAqIHNpbih4KSxcbiAgICAgIGsgKiBzaW4oeSlcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhemltdXRoYWxJbnZlcnQoYW5nbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgeiA9IHNxcnQoeCAqIHggKyB5ICogeSksXG4gICAgICAgIGMgPSBhbmdsZSh6KSxcbiAgICAgICAgc2MgPSBzaW4oYyksXG4gICAgICAgIGNjID0gY29zKGMpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih4ICogc2MsIHogKiBjYyksXG4gICAgICBhc2luKHogJiYgeSAqIHNjIC8geilcbiAgICBdO1xuICB9XG59XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgZ2VvU3RyZWFtfSBmcm9tIFwiLi4vc3RyZWFtLmpzXCI7XG5pbXBvcnQgYm91bmRzU3RyZWFtIGZyb20gXCIuLi9wYXRoL2JvdW5kcy5qc1wiO1xuXG5mdW5jdGlvbiBmaXQocHJvamVjdGlvbiwgZml0Qm91bmRzLCBvYmplY3QpIHtcbiAgdmFyIGNsaXAgPSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgJiYgcHJvamVjdGlvbi5jbGlwRXh0ZW50KCk7XG4gIHByb2plY3Rpb24uc2NhbGUoMTUwKS50cmFuc2xhdGUoWzAsIDBdKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KG51bGwpO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uLnN0cmVhbShib3VuZHNTdHJlYW0pKTtcbiAgZml0Qm91bmRzKGJvdW5kc1N0cmVhbS5yZXN1bHQoKSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sXG4gICAgICAgIGggPSBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0sXG4gICAgICAgIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLFxuICAgICAgICB4ID0gK2V4dGVudFswXVswXSArICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgW1swLCAwXSwgc2l6ZV0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gK3dpZHRoLFxuICAgICAgICBrID0gdyAvIChiWzFdWzBdIC0gYlswXVswXSksXG4gICAgICAgIHggPSAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSAtayAqIGJbMF1bMV07XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgaCA9ICtoZWlnaHQsXG4gICAgICAgIGsgPSBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSxcbiAgICAgICAgeCA9IC1rICogYlswXVswXSxcbiAgICAgICAgeSA9IChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuIiwiaW1wb3J0IGNsaXBSZWN0YW5nbGUgZnJvbSBcIi4uL2NsaXAvcmVjdGFuZ2xlLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQge3RyYW5zZm9ybWVyfSBmcm9tIFwiLi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQge2ZpdEV4dGVudCwgZml0U2l6ZSwgZml0V2lkdGgsIGZpdEhlaWdodH0gZnJvbSBcIi4vZml0LmpzXCI7XG5pbXBvcnQge2NvcywgZGVncmVlcywgcmFkaWFucywgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGsgPSAxLCB0eCA9IDAsIHR5ID0gMCwgc3ggPSAxLCBzeSA9IDEsIC8vIHNjYWxlLCB0cmFuc2xhdGUgYW5kIHJlZmxlY3RcbiAgICAgIGFscGhhID0gMCwgY2EsIHNhLCAvLyBhbmdsZVxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCAvLyBjbGlwIGV4dGVudFxuICAgICAga3ggPSAxLCBreSA9IDEsXG4gICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1lcih7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgdmFyIHAgPSBwcm9qZWN0aW9uKFt4LCB5XSlcbiAgICAgICAgICB0aGlzLnN0cmVhbS5wb2ludChwWzBdLCBwWzFdKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBwb3N0Y2xpcCA9IGlkZW50aXR5LFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBreCA9IGsgKiBzeDtcbiAgICBreSA9IGsgKiBzeTtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24gKHApIHtcbiAgICB2YXIgeCA9IHBbMF0gKiBreCwgeSA9IHBbMV0gKiBreTtcbiAgICBpZiAoYWxwaGEpIHtcbiAgICAgIHZhciB0ID0geSAqIGNhIC0geCAqIHNhO1xuICAgICAgeCA9IHggKiBjYSArIHkgKiBzYTtcbiAgICAgIHkgPSB0O1xuICAgIH0gICAgXG4gICAgcmV0dXJuIFt4ICsgdHgsIHkgKyB0eV07XG4gIH1cbiAgcHJvamVjdGlvbi5pbnZlcnQgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHggPSBwWzBdIC0gdHgsIHkgPSBwWzFdIC0gdHk7XG4gICAgaWYgKGFscGhhKSB7XG4gICAgICB2YXIgdCA9IHkgKiBjYSArIHggKiBzYTtcbiAgICAgIHggPSB4ICogY2EgLSB5ICogc2E7XG4gICAgICB5ID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIFt4IC8ga3gsIHkgLyBreV07XG4gIH07XG4gIHByb2plY3Rpb24uc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gdHJhbnNmb3JtKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSk7XG4gIH07XG4gIHByb2plY3Rpb24ucG9zdGNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gIH07XG4gIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcbiAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gK18sIHJlc2V0KCkpIDogaztcbiAgfTtcbiAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHggPSArX1swXSwgdHkgPSArX1sxXSwgcmVzZXQoKSkgOiBbdHgsIHR5XTtcbiAgfVxuICBwcm9qZWN0aW9uLmFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gXyAlIDM2MCAqIHJhZGlhbnMsIHNhID0gc2luKGFscGhhKSwgY2EgPSBjb3MoYWxwaGEpLCByZXNldCgpKSA6IGFscGhhICogZGVncmVlcztcbiAgfTtcbiAgcHJvamVjdGlvbi5yZWZsZWN0WCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeCA9IF8gPyAtMSA6IDEsIHJlc2V0KCkpIDogc3ggPCAwO1xuICB9O1xuICBwcm9qZWN0aW9uLnJlZmxlY3RZID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN5ID0gXyA/IC0xIDogMSwgcmVzZXQoKSkgOiBzeSA8IDA7XG4gIH07XG4gIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG4gIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdGlvbjtcbn1cbiIsImltcG9ydCBjbGlwQW50aW1lcmlkaWFuIGZyb20gXCIuLi9jbGlwL2FudGltZXJpZGlhbi5qc1wiO1xuaW1wb3J0IGNsaXBDaXJjbGUgZnJvbSBcIi4uL2NsaXAvY2lyY2xlLmpzXCI7XG5pbXBvcnQgY2xpcFJlY3RhbmdsZSBmcm9tIFwiLi4vY2xpcC9yZWN0YW5nbGUuanNcIjtcbmltcG9ydCBjb21wb3NlIGZyb20gXCIuLi9jb21wb3NlLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQge2NvcywgZGVncmVlcywgcmFkaWFucywgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtyb3RhdGVSYWRpYW5zfSBmcm9tIFwiLi4vcm90YXRpb24uanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCB7Zml0RXh0ZW50LCBmaXRTaXplLCBmaXRXaWR0aCwgZml0SGVpZ2h0fSBmcm9tIFwiLi9maXQuanNcIjtcbmltcG9ydCByZXNhbXBsZSBmcm9tIFwiLi9yZXNhbXBsZS5qc1wiO1xuXG52YXIgdHJhbnNmb3JtUmFkaWFucyA9IHRyYW5zZm9ybWVyKHtcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgciA9IHJvdGF0ZSh4LCB5KTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb2ludChyWzBdLCByWzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHksIHN4LCBzeSkge1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHggKj0gc3g7IHkgKj0gc3k7XG4gICAgcmV0dXJuIFtkeCArIGsgKiB4LCBkeSAtIGsgKiB5XTtcbiAgfVxuICB0cmFuc2Zvcm0uaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbKHggLSBkeCkgLyBrICogc3gsIChkeSAtIHkpIC8gayAqIHN5XTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgZHgsIGR5LCBzeCwgc3ksIGFscGhhKSB7XG4gIGlmICghYWxwaGEpIHJldHVybiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHksIHN4LCBzeSk7XG4gIHZhciBjb3NBbHBoYSA9IGNvcyhhbHBoYSksXG4gICAgICBzaW5BbHBoYSA9IHNpbihhbHBoYSksXG4gICAgICBhID0gY29zQWxwaGEgKiBrLFxuICAgICAgYiA9IHNpbkFscGhhICogayxcbiAgICAgIGFpID0gY29zQWxwaGEgLyBrLFxuICAgICAgYmkgPSBzaW5BbHBoYSAvIGssXG4gICAgICBjaSA9IChzaW5BbHBoYSAqIGR5IC0gY29zQWxwaGEgKiBkeCkgLyBrLFxuICAgICAgZmkgPSAoc2luQWxwaGEgKiBkeCArIGNvc0FscGhhICogZHkpIC8gaztcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICB4ICo9IHN4OyB5ICo9IHN5O1xuICAgIHJldHVybiBbYSAqIHggLSBiICogeSArIGR4LCBkeSAtIGIgKiB4IC0gYSAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFtzeCAqIChhaSAqIHggLSBiaSAqIHkgKyBjaSksIHN5ICogKGZpIC0gYmkgKiB4IC0gYWkgKiB5KV07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByb2plY3Rpb24ocHJvamVjdCkge1xuICByZXR1cm4gcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24oKSB7IHJldHVybiBwcm9qZWN0OyB9KSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gIHZhciBwcm9qZWN0LFxuICAgICAgayA9IDE1MCwgLy8gc2NhbGVcbiAgICAgIHggPSA0ODAsIHkgPSAyNTAsIC8vIHRyYW5zbGF0ZVxuICAgICAgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXG4gICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgLy8gcHJlLXJvdGF0ZVxuICAgICAgYWxwaGEgPSAwLCAvLyBwb3N0LXJvdGF0ZSBhbmdsZVxuICAgICAgc3ggPSAxLCAvLyByZWZsZWN0WFxuICAgICAgc3kgPSAxLCAvLyByZWZsZWN0WFxuICAgICAgdGhldGEgPSBudWxsLCBwcmVjbGlwID0gY2xpcEFudGltZXJpZGlhbiwgLy8gcHJlLWNsaXAgYW5nbGVcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgcG9zdGNsaXAgPSBpZGVudGl0eSwgLy8gcG9zdC1jbGlwIGV4dGVudFxuICAgICAgZGVsdGEyID0gMC41LCAvLyBwcmVjaXNpb25cbiAgICAgIHByb2plY3RSZXNhbXBsZSxcbiAgICAgIHByb2plY3RUcmFuc2Zvcm0sXG4gICAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbTtcblxuICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0ocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLmludmVydChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgIHJldHVybiBwb2ludCAmJiBbcG9pbnRbMF0gKiBkZWdyZWVzLCBwb2ludFsxXSAqIGRlZ3JlZXNdO1xuICB9XG5cbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm1SYWRpYW5zKHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpKHByZWNsaXAocHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSkpKSk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSBfLCB0aGV0YSA9IHVuZGVmaW5lZCwgcmVzZXQoKSkgOiBwcmVjbGlwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucG9zdGNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9ICtfID8gY2xpcENpcmNsZSh0aGV0YSA9IF8gKiByYWRpYW5zKSA6ICh0aGV0YSA9IG51bGwsIGNsaXBBbnRpbWVyaWRpYW4pLCByZXNldCgpKSA6IHRoZXRhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gK18sIHJlY2VudGVyKCkpIDogaztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIHBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWx0YUxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YVBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YUdhbW1hID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIHJhZGlhbnMgOiAwLCByZWNlbnRlcigpKSA6IFtkZWx0YUxhbWJkYSAqIGRlZ3JlZXMsIGRlbHRhUGhpICogZGVncmVlcywgZGVsdGFHYW1tYSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yZWZsZWN0WCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeCA9IF8gPyAtMSA6IDEsIHJlY2VudGVyKCkpIDogc3ggPCAwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucmVmbGVjdFkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3kgPSBfID8gLTEgOiAxLCByZWNlbnRlcigpKSA6IHN5IDwgMDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIgPSBfICogXyksIHJlc2V0KCkpIDogc3FydChkZWx0YTIpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWNlbnRlcigpIHtcbiAgICB2YXIgY2VudGVyID0gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgMCwgMCwgc3gsIHN5LCBhbHBoYSkuYXBwbHkobnVsbCwgcHJvamVjdChsYW1iZGEsIHBoaSkpLFxuICAgICAgICB0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCB4IC0gY2VudGVyWzBdLCB5IC0gY2VudGVyWzFdLCBzeCwgc3ksIGFscGhhKTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSk7XG4gICAgcHJvamVjdFRyYW5zZm9ybSA9IGNvbXBvc2UocHJvamVjdCwgdHJhbnNmb3JtKTtcbiAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtID0gY29tcG9zZShyb3RhdGUsIHByb2plY3RUcmFuc2Zvcm0pO1xuICAgIHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMik7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgcmV0dXJuIHJlY2VudGVyKCk7XG4gIH07XG59XG4iLCJpbXBvcnQge2FzaW4sIGNvcywgZXBzaWxvbiwgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHthemltdXRoYWxJbnZlcnR9IGZyb20gXCIuL2F6aW11dGhhbC5qc1wiO1xuaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvZ3JhcGhpY1Jhdyh4LCB5KSB7XG4gIHJldHVybiBbY29zKHkpICogc2luKHgpLCBzaW4oeSldO1xufVxuXG5vcnRob2dyYXBoaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGFzaW4pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24ob3J0aG9ncmFwaGljUmF3KVxuICAgICAgLnNjYWxlKDI0OS41KVxuICAgICAgLmNsaXBBbmdsZSg5MCArIGVwc2lsb24pO1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW59IGZyb20gXCIuLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCByYWRpYW5zLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuXG52YXIgbWF4RGVwdGggPSAxNiwgLy8gbWF4aW11bSBkZXB0aCBvZiBzdWJkaXZpc2lvblxuICAgIGNvc01pbkRpc3RhbmNlID0gY29zKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHByb2plY3QsIGRlbHRhMikge1xuICByZXR1cm4gK2RlbHRhMiA/IHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikgOiByZXNhbXBsZU5vbmUocHJvamVjdCk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlTm9uZShwcm9qZWN0KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzYW1wbGUocHJvamVjdCwgZGVsdGEyKSB7XG5cbiAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICB2YXIgZHggPSB4MSAtIHgwLFxuICAgICAgICBkeSA9IHkxIC0geTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgaWYgKGQyID4gNCAqIGRlbHRhMiAmJiBkZXB0aC0tKSB7XG4gICAgICB2YXIgYSA9IGEwICsgYTEsXG4gICAgICAgICAgYiA9IGIwICsgYjEsXG4gICAgICAgICAgYyA9IGMwICsgYzEsXG4gICAgICAgICAgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSxcbiAgICAgICAgICBwaGkyID0gYXNpbihjIC89IG0pLFxuICAgICAgICAgIGxhbWJkYTIgPSBhYnMoYWJzKGMpIC0gMSkgPCBlcHNpbG9uIHx8IGFicyhsYW1iZGEwIC0gbGFtYmRhMSkgPCBlcHNpbG9uID8gKGxhbWJkYTAgKyBsYW1iZGExKSAvIDIgOiBhdGFuMihiLCBhKSxcbiAgICAgICAgICBwID0gcHJvamVjdChsYW1iZGEyLCBwaGkyKSxcbiAgICAgICAgICB4MiA9IHBbMF0sXG4gICAgICAgICAgeTIgPSBwWzFdLFxuICAgICAgICAgIGR4MiA9IHgyIC0geDAsXG4gICAgICAgICAgZHkyID0geTIgLSB5MCxcbiAgICAgICAgICBkeiA9IGR5ICogZHgyIC0gZHggKiBkeTI7XG4gICAgICBpZiAoZHogKiBkeiAvIGQyID4gZGVsdGEyIC8vIHBlcnBlbmRpY3VsYXIgcHJvamVjdGVkIGRpc3RhbmNlXG4gICAgICAgICAgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gMC41KSA+IDAuMyAvLyBtaWRwb2ludCBjbG9zZSB0byBhbiBlbmRcbiAgICAgICAgICB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkgeyAvLyBhbmd1bGFyIGRpc3RhbmNlXG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDIsIHkyLCBsYW1iZGEyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MiwgeTIsIGxhbWJkYTIsIGEsIGIsIGMsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgbGFtYmRhMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICBsYW1iZGEwLCB4MCwgeTAsIGEwLCBiMCwgYzA7IC8vIHByZXZpb3VzIHBvaW50XG5cbiAgICB2YXIgcmVzYW1wbGVTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvblN0YXJ0KCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IHJpbmdTdGFydDsgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvbkVuZCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7IH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgeDAgPSBOYU47XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIHZhciBjID0gY2FydGVzaWFuKFtsYW1iZGEsIHBoaV0pLCBwID0gcHJvamVjdChsYW1iZGEsIHBoaSk7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCBsYW1iZGEwID0gbGFtYmRhLCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICBsaW5lU3RhcnQoKTtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lUG9pbnQobGFtYmRhMDAgPSBsYW1iZGEsIHBoaSksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCBsYW1iZGEwMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgIGxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzYW1wbGVTdHJlYW07XG4gIH07XG59XG4iLCJpbXBvcnQgY29tcG9zZSBmcm9tIFwiLi9jb21wb3NlLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZGVncmVlcywgcGksIHJhZGlhbnMsIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHJvdGF0aW9uSWRlbnRpdHkobGFtYmRhLCBwaGkpIHtcbiAgaWYgKGFicyhsYW1iZGEpID4gcGkpIGxhbWJkYSAtPSBNYXRoLnJvdW5kKGxhbWJkYSAvIHRhdSkgKiB0YXU7XG4gIHJldHVybiBbbGFtYmRhLCBwaGldO1xufVxuXG5yb3RhdGlvbklkZW50aXR5LmludmVydCA9IHJvdGF0aW9uSWRlbnRpdHk7XG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICByZXR1cm4gKGRlbHRhTGFtYmRhICU9IHRhdSkgPyAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IGNvbXBvc2Uocm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpLCByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSlcbiAgICA6IHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSlcbiAgICA6IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSlcbiAgICA6IHJvdGF0aW9uSWRlbnRpdHkpO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgbGFtYmRhICs9IGRlbHRhTGFtYmRhO1xuICAgIGlmIChhYnMobGFtYmRhKSA+IHBpKSBsYW1iZGEgLT0gTWF0aC5yb3VuZChsYW1iZGEgLyB0YXUpICogdGF1O1xuICAgIHJldHVybiBbbGFtYmRhLCBwaGldO1xuICB9O1xufVxuXG5mdW5jdGlvbiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICB2YXIgcm90YXRpb24gPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpO1xuICByb3RhdGlvbi5pbnZlcnQgPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoLWRlbHRhTGFtYmRhKTtcbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5mdW5jdGlvbiByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHZhciBjb3NEZWx0YVBoaSA9IGNvcyhkZWx0YVBoaSksXG4gICAgICBzaW5EZWx0YVBoaSA9IHNpbihkZWx0YVBoaSksXG4gICAgICBjb3NEZWx0YUdhbW1hID0gY29zKGRlbHRhR2FtbWEpLFxuICAgICAgc2luRGVsdGFHYW1tYSA9IHNpbihkZWx0YUdhbW1hKTtcblxuICBmdW5jdGlvbiByb3RhdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YVBoaSArIHggKiBzaW5EZWx0YVBoaTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgLSBrICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpIC0geiAqIHNpbkRlbHRhUGhpKSxcbiAgICAgIGFzaW4oayAqIGNvc0RlbHRhR2FtbWEgKyB5ICogc2luRGVsdGFHYW1tYSlcbiAgICBdO1xuICB9XG5cbiAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICAgIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB6ID0gc2luKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFHYW1tYSAtIHkgKiBzaW5EZWx0YUdhbW1hO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSArIHogKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgKyBrICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXG4gICAgXTtcbiAgfTtcblxuICByZXR1cm4gcm90YXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJvdGF0ZSkge1xuICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKHJvdGF0ZVswXSAqIHJhZGlhbnMsIHJvdGF0ZVsxXSAqIHJhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogcmFkaWFucyA6IDApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuIiwiZnVuY3Rpb24gc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIHN0cmVhbSkge1xuICBpZiAoZ2VvbWV0cnkgJiYgc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59XG5cbnZhciBzdHJlYW1PYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59O1xuXG52YXIgc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtLnNwaGVyZSgpO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xuICB9LFxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gIH0sXG4gIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgc3RyZWFtKTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBzdHJlYW0sIGNsb3NlZCkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgc3RyZWFtLmxpbmVFbmQoKTtcbn1cblxuZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMSk7XG4gIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gIGlmIChvYmplY3QgJiYgc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICBzdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBzdHJlYW0pO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtZXRob2RzKSB7XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtZXIobWV0aG9kcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSBzW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHt9XG5cblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpOyB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCk7IH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG59O1xuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiAoaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5IDogZ2VuZXJpY0FycmF5KShhLCBiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyaWNBcnJheShhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gdmFsdWUoYVtpXSwgYltpXSk7XG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtiYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBkID0gbmV3IERhdGU7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkLnNldFRpbWUoYSAqICgxIC0gdCkgKyBiICogdCksIGQ7XG4gIH07XG59XG4iLCJpbXBvcnQge2xhYiBhcyBjb2xvckxhYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBjb2xvcigoc3RhcnQgPSBjb2xvckxhYihzdGFydCkpLmwsIChlbmQgPSBjb2xvckxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBjb2xvcihzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFiKSBiID0gW107XG4gIHZhciBuID0gYSA/IE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgYyA9IGIuc2xpY2UoKSxcbiAgICAgIGk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY1tpXSA9IGFbaV0gKiAoMSAtIHQpICsgYltpXSAqIHQ7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlckFycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgaSA9IHt9LFxuICAgICAgYyA9IHt9LFxuICAgICAgaztcblxuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IHZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyB2YWx1ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB2YWx1ZXMgPSBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtyZ2IgYXMgY29sb3JSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGJhc2lzIGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5pbXBvcnQgYmFzaXNDbG9zZWQgZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmltcG9ydCBub2dhbW1hLCB7Z2FtbWF9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBjb2xvclJnYihzdGFydCkpLnIsIChlbmQgPSBjb2xvclJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGNvbG9yUmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMpO1xuZXhwb3J0IHZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiAoMSAtIHQpICsgYiAqIHQpO1xuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHJnYiBmcm9tIFwiLi9yZ2IuanNcIjtcbmltcG9ydCB7Z2VuZXJpY0FycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGRhdGUgZnJvbSBcIi4vZGF0ZS5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCBvYmplY3QgZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5pbXBvcnQgc3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG4iLCJ2YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHpvb21SaG8ocmhvLCByaG8yLCByaG80KSB7XG5cbiAgLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuICAvLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG4gIGZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGksXG4gICAgICAgIFM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhbCBjYXNlLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwICogcmhvIC8gTWF0aC5TUVJUMjtcblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgem9vbS5yaG8gPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIF8xID0gTWF0aC5tYXgoMWUtMywgK18pLCBfMiA9IF8xICogXzEsIF80ID0gXzIgKiBfMjtcbiAgICByZXR1cm4gem9vbVJobyhfMSwgXzIsIF80KTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn0pKE1hdGguU1FSVDIsIDIsIDQpO1xuIiwiY29uc3QgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gYXBwZW5kKHN0cmluZ3MpIHtcbiAgdGhpcy5fICs9IHN0cmluZ3NbMF07XG4gIGZvciAobGV0IGkgPSAxLCBuID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLl8gKz0gYXJndW1lbnRzW2ldICsgc3RyaW5nc1tpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBlbmRSb3VuZChkaWdpdHMpIHtcbiAgbGV0IGQgPSBNYXRoLmZsb29yKGRpZ2l0cyk7XG4gIGlmICghKGQgPj0gMCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7ZGlnaXRzfWApO1xuICBpZiAoZCA+IDE1KSByZXR1cm4gYXBwZW5kO1xuICBjb25zdCBrID0gMTAgKiogZDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgICB0aGlzLl8gKz0gc3RyaW5nc1swXTtcbiAgICBmb3IgKGxldCBpID0gMSwgbiA9IHN0cmluZ3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0aGlzLl8gKz0gTWF0aC5yb3VuZChhcmd1bWVudHNbaV0gKiBrKSAvIGsgKyBzdHJpbmdzW2ldO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihkaWdpdHMpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3kwID0gLy8gc3RhcnQgb2YgY3VycmVudCBzdWJwYXRoXG4gICAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl8gPSBcIlwiO1xuICAgIHRoaXMuX2FwcGVuZCA9IGRpZ2l0cyA9PSBudWxsID8gYXBwZW5kIDogYXBwZW5kUm91bmQoZGlnaXRzKTtcbiAgfVxuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MCA9IHRoaXMuX3gxID0gK3h9LCR7dGhpcy5feTAgPSB0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuX2FwcGVuZGBaYDtcbiAgICB9XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgTCR7dGhpcy5feDEgPSAreH0sJHt0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgcXVhZHJhdGljQ3VydmVUbyh4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgUSR7K3gxfSwkeyt5MX0sJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBiZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fYXBwZW5kYEMkeyt4MX0sJHsreTF9LCR7K3gyfSwkeyt5Mn0sJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBhcmNUbyh4MSwgeTEsIHgyLCB5Miwgcikge1xuICAgIHgxID0gK3gxLCB5MSA9ICt5MSwgeDIgPSAreDIsIHkyID0gK3kyLCByID0gK3I7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke3J9YCk7XG5cbiAgICBsZXQgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgxLHkxKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MSA9IHgxfSwke3RoaXMuX3kxID0geTF9YDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgTCR7dGhpcy5feDEgPSB4MX0sJHt0aGlzLl95MSA9IHkxfWA7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIGxldCB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSxcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxuICAgICAgICAgIHQyMSA9IGwgLyBsMjE7XG5cbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgIGlmIChNYXRoLmFicyh0MDEgLSAxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kYEwke3gxICsgdDAxICogeDAxfSwke3kxICsgdDAxICogeTAxfWA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsMCwkeysoeTAxICogeDIwID4geDAxICogeTIwKX0sJHt0aGlzLl94MSA9IHgxICsgdDIxICogeDIxfSwke3RoaXMuX3kxID0geTEgKyB0MjEgKiB5MjF9YDtcbiAgICB9XG4gIH1cbiAgYXJjKHgsIHksIHIsIGEwLCBhMSwgY2N3KSB7XG4gICAgeCA9ICt4LCB5ID0gK3ksIHIgPSArciwgY2N3ID0gISFjY3c7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke3J9YCk7XG5cbiAgICBsZXQgZHggPSByICogTWF0aC5jb3MoYTApLFxuICAgICAgICBkeSA9IHIgKiBNYXRoLnNpbihhMCksXG4gICAgICAgIHgwID0geCArIGR4LFxuICAgICAgICB5MCA9IHkgKyBkeSxcbiAgICAgICAgY3cgPSAxIF4gY2N3LFxuICAgICAgICBkYSA9IGNjdyA/IGEwIC0gYTEgOiBhMSAtIGEwO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MCx5MCkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgTSR7eDB9LCR7eTB9YDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHkwKSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBMJHt4MH0sJHt5MH1gO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgQSR7cn0sJHtyfSwwLDEsJHtjd30sJHt4IC0gZHh9LCR7eSAtIGR5fUEke3J9LCR7cn0sMCwxLCR7Y3d9LCR7dGhpcy5feDEgPSB4MH0sJHt0aGlzLl95MSA9IHkwfWA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgbm9uLWVtcHR5PyBEcmF3IGFuIGFyYyFcbiAgICBlbHNlIGlmIChkYSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsJHsrKGRhID49IHBpKX0sJHtjd30sJHt0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpfSwke3RoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSl9YDtcbiAgICB9XG4gIH1cbiAgcmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9aCR7dyA9ICt3fXYkeytofWgkey13fVpgO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGgoKSB7XG4gIHJldHVybiBuZXcgUGF0aDtcbn1cblxuLy8gQWxsb3cgaW5zdGFuY2VvZiBkMy5wYXRoXG5wYXRoLnByb3RvdHlwZSA9IFBhdGgucHJvdG90eXBlO1xuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFJvdW5kKGRpZ2l0cyA9IDMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKCtkaWdpdHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBjb25zdCB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcbiAgICAgIHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpO1xuICByZXR1cm4gYWRkKHRoaXMuY292ZXIoeCwgeSksIHgsIHksIGQpO1xufVxuXG5mdW5jdGlvbiBhZGQodHJlZSwgeCwgeSwgZCkge1xuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXG4gICAgICBsZWFmID0ge2RhdGE6IGR9LFxuICAgICAgeDAgPSB0cmVlLl94MCxcbiAgICAgIHkwID0gdHJlZS5feTAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeTEgPSB0cmVlLl95MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB4cCxcbiAgICAgIHlwLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cbiAgd2hpbGUgKG5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKHBhcmVudCA9IG5vZGUsICEobm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG4gIH1cblxuICAvLyBJcyB0aGUgbmV3IHBvaW50IGlzIGV4YWN0bHkgY29pbmNpZGVudCB3aXRoIHRoZSBleGlzdGluZyBwb2ludD9cbiAgeHAgPSArdHJlZS5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDQpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg0KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgfSB3aGlsZSAoKGkgPSBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgdmFyIGQsIGksIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeHogPSBuZXcgQXJyYXkobiksXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgY29udGludWU7XG4gICAgeHpbaV0gPSB4O1xuICAgIHl6W2ldID0geTtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICAgIGlmICh5IDwgeTApIHkwID0geTtcbiAgICBpZiAoeSA+IHkxKSB5MSA9IHk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlIG5vICh2YWxpZCkgcG9pbnRzLCBhYm9ydC5cbiAgaWYgKHgwID4geDEgfHwgeTAgPiB5MSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRXhwYW5kIHRoZSB0cmVlIHRvIGNvdmVyIHRoZSBuZXcgcG9pbnRzLlxuICB0aGlzLmNvdmVyKHgwLCB5MCkuY292ZXIoeDEsIHkxKTtcblxuICAvLyBBZGQgdGhlIG5ldyBwb2ludHMuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCBkYXRhW2ldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTE7XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2Uge1xuICAgIHZhciB6ID0geDEgLSB4MCB8fCAxLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKHgwID4geCB8fCB4ID49IHgxIHx8IHkwID4geSB8fCB5ID49IHkxKSB7XG4gICAgICBpID0gKHkgPCB5MCkgPDwgMSB8ICh4IDwgeDApO1xuICAgICAgcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50LCB6ICo9IDI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOiB4MSA9IHgwICsgeiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHgwID0geDEgLSB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogeDEgPSB4MCArIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiB4MCA9IHgxIC0geiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxuICAgICAgOiBpc05hTih0aGlzLl94MCkgPyB1bmRlZmluZWQgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXTtcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gIHZhciBkYXRhLFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgzID0gdGhpcy5feDEsXG4gICAgICB5MyA9IHRoaXMuX3kxLFxuICAgICAgcXVhZHMgPSBbXSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcSxcbiAgICAgIGk7XG5cbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgeDAsIHkwLCB4MywgeTMpKTtcbiAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgZWxzZSB7XG4gICAgeDAgPSB4IC0gcmFkaXVzLCB5MCA9IHkgLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzLCB5MyA9IHkgKyByYWRpdXM7XG4gICAgcmFkaXVzICo9IHJhZGl1cztcbiAgfVxuXG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcblxuICAgIC8vIFN0b3Agc2VhcmNoaW5nIGlmIHRoaXMgcXVhZHJhbnQgY2Fu4oCZdCBjb250YWluIGEgY2xvc2VyIG5vZGUuXG4gICAgaWYgKCEobm9kZSA9IHEubm9kZSlcbiAgICAgICAgfHwgKHgxID0gcS54MCkgPiB4M1xuICAgICAgICB8fCAoeTEgPSBxLnkwKSA+IHkzXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDBcbiAgICAgICAgfHwgKHkyID0gcS55MSkgPCB5MCkgY29udGludWU7XG5cbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgcXVhZHJhbnQuXG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgIHltID0gKHkxICsgeTIpIC8gMjtcblxuICAgICAgcXVhZHMucHVzaChcbiAgICAgICAgbmV3IFF1YWQobm9kZVszXSwgeG0sIHltLCB4MiwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzJdLCB4MSwgeW0sIHhtLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMV0sIHhtLCB5MSwgeDIsIHltKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVswXSwgeDEsIHkxLCB4bSwgeW0pXG4gICAgICApO1xuXG4gICAgICAvLyBWaXNpdCB0aGUgY2xvc2VzdCBxdWFkcmFudCBmaXJzdC5cbiAgICAgIGlmIChpID0gKHkgPj0geW0pIDw8IDEgfCAoeCA+PSB4bSkpIHtcbiAgICAgICAgcSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxXSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldID0gcTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaXNpdCB0aGlzIHBvaW50LiAoVmlzaXRpbmcgY29pbmNpZGVudCBwb2ludHMgaXNu4oCZdCBuZWNlc3NhcnkhKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGR4ID0geCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkeSA9IHkgLSArdGhpcy5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA8IHJhZGl1cykge1xuICAgICAgICB2YXIgZCA9IE1hdGguc3FydChyYWRpdXMgPSBkMik7XG4gICAgICAgIHgwID0geCAtIGQsIHkwID0geSAtIGQ7XG4gICAgICAgIHgzID0geCArIGQsIHkzID0geSArIGQ7XG4gICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLngwID0geDA7XG4gIHRoaXMueTAgPSB5MDtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG59XG4iLCJpbXBvcnQgdHJlZV9hZGQsIHthZGRBbGwgYXMgdHJlZV9hZGRBbGx9IGZyb20gXCIuL2FkZC5qc1wiO1xuaW1wb3J0IHRyZWVfY292ZXIgZnJvbSBcIi4vY292ZXIuanNcIjtcbmltcG9ydCB0cmVlX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHRyZWVfZXh0ZW50IGZyb20gXCIuL2V4dGVudC5qc1wiO1xuaW1wb3J0IHRyZWVfZmluZCBmcm9tIFwiLi9maW5kLmpzXCI7XG5pbXBvcnQgdHJlZV9yZW1vdmUsIHtyZW1vdmVBbGwgYXMgdHJlZV9yZW1vdmVBbGx9IGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyZWVfcm9vdCBmcm9tIFwiLi9yb290LmpzXCI7XG5pbXBvcnQgdHJlZV9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0IGZyb20gXCIuL3Zpc2l0LmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdEFmdGVyIGZyb20gXCIuL3Zpc2l0QWZ0ZXIuanNcIjtcbmltcG9ydCB0cmVlX3gsIHtkZWZhdWx0WH0gZnJvbSBcIi4veC5qc1wiO1xuaW1wb3J0IHRyZWVfeSwge2RlZmF1bHRZfSBmcm9tIFwiLi95LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XG4gIHZhciB0cmVlID0gbmV3IFF1YWR0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIFF1YWR0cmVlKHgsIHksIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgdGhpcy5fcm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbGVhZl9jb3B5KGxlYWYpIHtcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XG4gIHdoaWxlIChsZWFmID0gbGVhZi5uZXh0KSBuZXh0ID0gbmV4dC5uZXh0ID0ge2RhdGE6IGxlYWYuZGF0YX07XG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgdHJlZVByb3RvID0gcXVhZHRyZWUucHJvdG90eXBlID0gUXVhZHRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBRdWFkdHJlZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoNCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IHRyZWVfYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gdHJlZV9yZW1vdmVBbGw7XG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcbnRyZWVQcm90by5zaXplID0gdHJlZV9zaXplO1xudHJlZVByb3RvLnZpc2l0ID0gdHJlZV92aXNpdDtcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xudHJlZVByb3RvLnggPSB0cmVlX3g7XG50cmVlUHJvdG8ueSA9IHRyZWVfeTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICByZXRhaW5lcixcbiAgICAgIHByZXZpb3VzLFxuICAgICAgbmV4dCxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAvLyBGaW5kIHRoZSBsZWFmIG5vZGUgZm9yIHRoZSBwb2ludC5cbiAgLy8gV2hpbGUgZGVzY2VuZGluZywgYWxzbyByZXRhaW4gdGhlIGRlZXBlc3QgcGFyZW50IHdpdGggYSBub24tcmVtb3ZlZCBzaWJsaW5nLlxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudFsoaSArIDEpICYgM10gfHwgcGFyZW50WyhpICsgMikgJiAzXSB8fCBwYXJlbnRbKGkgKyAzKSAmIDNdKSByZXRhaW5lciA9IHBhcmVudCwgaiA9IGk7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBwb2ludCB0byByZW1vdmUuXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xuICBpZiAobmV4dCA9IG5vZGUubmV4dCkgZGVsZXRlIG5vZGUubmV4dDtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cbiAgaWYgKHByZXZpb3VzKSByZXR1cm4gKG5leHQgPyBwcmV2aW91cy5uZXh0ID0gbmV4dCA6IGRlbGV0ZSBwcmV2aW91cy5uZXh0KSwgdGhpcztcblxuICAvLyBJZiB0aGlzIGlzIHRoZSByb290IHBvaW50LCByZW1vdmUgaXQuXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVhZi5cbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgbm93IGNvbnRhaW5zIGV4YWN0bHkgb25lIGxlYWYsIGNvbGxhcHNlIHN1cGVyZmx1b3VzIHBhcmVudHMuXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcbiAgICAgICYmIG5vZGUgPT09IChwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIG5leHQgPSBbXSwgcTtcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIHZhciBub2RlID0gcS5ub2RlO1xuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICB9XG4gICAgbmV4dC5wdXNoKHEpO1xuICB9XG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKHEubm9kZSwgcS54MCwgcS55MCwgcS54MSwgcS55MSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFgoZCkge1xuICByZXR1cm4gZFswXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gXywgdGhpcykgOiB0aGlzLl94O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feSA9IF8sIHRoaXMpIDogdGhpcy5feTtcbn1cbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4uL2NvbG9ycy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjb2xvcnMoXCI4ZGQzYzdmZmZmYjNiZWJhZGFmYjgwNzI4MGIxZDNmZGI0NjJiM2RlNjlmY2NkZTVkOWQ5ZDliYzgwYmRjY2ViYzVmZmVkNmZcIik7XG4iLCJpbXBvcnQgY29sb3JzIGZyb20gXCIuLi9jb2xvcnMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY29sb3JzKFwiMWY3N2I0ZmY3ZjBlMmNhMDJjZDYyNzI4OTQ2N2JkOGM1NjRiZTM3N2MyN2Y3ZjdmYmNiZDIyMTdiZWNmXCIpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gIHZhciBuID0gc3BlY2lmaWVyLmxlbmd0aCAvIDYgfCAwLCBjb2xvcnMgPSBuZXcgQXJyYXkobiksIGkgPSAwO1xuICB3aGlsZSAoaSA8IG4pIGNvbG9yc1tpXSA9IFwiI1wiICsgc3BlY2lmaWVyLnNsaWNlKGkgKiA2LCArK2kgKiA2KTtcbiAgcmV0dXJuIGNvbG9ycztcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVSZ2JCYXNpc30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHNjaGVtZSA9PiBpbnRlcnBvbGF0ZVJnYkJhc2lzKHNjaGVtZVtzY2hlbWUubGVuZ3RoIC0gMV0pO1xuIiwiaW1wb3J0IGNvbG9ycyBmcm9tIFwiLi4vY29sb3JzLmpzXCI7XG5pbXBvcnQgcmFtcCBmcm9tIFwiLi4vcmFtcC5qc1wiO1xuXG5leHBvcnQgdmFyIHNjaGVtZSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmVlOGM4ZmRiYjg0ZTM0YTMzXCIsXG4gIFwiZmVmMGQ5ZmRjYzhhZmM4ZDU5ZDczMDFmXCIsXG4gIFwiZmVmMGQ5ZmRjYzhhZmM4ZDU5ZTM0YTMzYjMwMDAwXCIsXG4gIFwiZmVmMGQ5ZmRkNDllZmRiYjg0ZmM4ZDU5ZTM0YTMzYjMwMDAwXCIsXG4gIFwiZmVmMGQ5ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmOTkwMDAwXCIsXG4gIFwiZmZmN2VjZmVlOGM4ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmOTkwMDAwXCIsXG4gIFwiZmZmN2VjZmVlOGM4ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmYjMwMDAwN2YwMDAwXCJcbikubWFwKGNvbG9ycyk7XG5cbmV4cG9ydCBkZWZhdWx0IHJhbXAoc2NoZW1lKTtcbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4uL2NvbG9ycy5qc1wiO1xuaW1wb3J0IHJhbXAgZnJvbSBcIi4uL3JhbXAuanNcIjtcblxuZXhwb3J0IHZhciBzY2hlbWUgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVkZjhiMTdmY2RiYjJjN2ZiOFwiLFxuICBcImZmZmZjY2ExZGFiNDQxYjZjNDIyNWVhOFwiLFxuICBcImZmZmZjY2ExZGFiNDQxYjZjNDJjN2ZiODI1MzQ5NFwiLFxuICBcImZmZmZjY2M3ZTliNDdmY2RiYjQxYjZjNDJjN2ZiODI1MzQ5NFwiLFxuICBcImZmZmZjY2M3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODBjMmM4NFwiLFxuICBcImZmZmZkOWVkZjhiMWM3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODBjMmM4NFwiLFxuICBcImZmZmZkOWVkZjhiMWM3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODI1MzQ5NDA4MWQ1OFwiXG4pLm1hcChjb2xvcnMpO1xuXG5leHBvcnQgZGVmYXVsdCByYW1wKHNjaGVtZSk7XG4iLCJpbXBvcnQge3JhbmdlIGFzIHNlcXVlbmNlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5pbXBvcnQgb3JkaW5hbCBmcm9tIFwiLi9vcmRpbmFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHIwID0gMCxcbiAgICAgIHIxID0gMSxcbiAgICAgIHN0ZXAsXG4gICAgICBiYW5kd2lkdGgsXG4gICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgcGFkZGluZ0lubmVyID0gMCxcbiAgICAgIHBhZGRpbmdPdXRlciA9IDAsXG4gICAgICBhbGlnbiA9IDAuNTtcblxuICBkZWxldGUgc2NhbGUudW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBuID0gZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICByZXZlcnNlID0gcjEgPCByMCxcbiAgICAgICAgc3RhcnQgPSByZXZlcnNlID8gcjEgOiByMCxcbiAgICAgICAgc3RvcCA9IHJldmVyc2UgPyByMCA6IHIxO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcXVlbmNlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbcjAsIHIxXSA9IF8sIHIwID0gK3IwLCByMSA9ICtyMSwgcmVzY2FsZSgpKSA6IFtyMCwgcjFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIFtyMCwgcjFdID0gXywgcjAgPSArcjAsIHIxID0gK3IxLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgcGFkZGluZ091dGVyID0gK18pLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbigxLCBfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gK18sIHJlc2NhbGUoKSkgOiBwYWRkaW5nT3V0ZXI7XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBhbGlnbjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmQoZG9tYWluKCksIFtyMCwgcjFdKVxuICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcbiAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHJlc2NhbGUoKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhZGRpbmdJbm5lcigxKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25zdGFudHMoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2ludGVycG9sYXRlIGFzIGludGVycG9sYXRlVmFsdWUsIGludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHVuaXQgPSBbMCwgMV07XG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgYikge1xuICByZXR1cm4gKGIgLT0gKGEgPSArYSkpXG4gICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICh4IC0gYSkgLyBiOyB9XG4gICAgICA6IGNvbnN0YW50KGlzTmFOKGIpID8gTmFOIDogMC41KTtcbn1cblxuZnVuY3Rpb24gY2xhbXBlcihhLCBiKSB7XG4gIHZhciB0O1xuICBpZiAoYSA+IGIpIHQgPSBhLCBhID0gYiwgYiA9IHQ7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCB4KSk7IH07XG59XG5cbi8vIG5vcm1hbGl6ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuLy8gaW50ZXJwb2xhdGUoYSwgYikodCkgdGFrZXMgYSBwYXJhbWV0ZXIgdCBpbiBbMCwxXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByYW5nZSB2YWx1ZSB4IGluIFthLGJdLlxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGQwID0gZG9tYWluWzBdLCBkMSA9IGRvbWFpblsxXSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXTtcbiAgaWYgKGQxIDwgZDApIGQwID0gbm9ybWFsaXplKGQxLCBkMCksIHIwID0gaW50ZXJwb2xhdGUocjEsIHIwKTtcbiAgZWxzZSBkMCA9IG5vcm1hbGl6ZShkMCwgZDEpLCByMCA9IGludGVycG9sYXRlKHIwLCByMSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiByMChkMCh4KSk7IH07XG59XG5cbmZ1bmN0aW9uIHBvbHltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcbiAgICAgIGQgPSBuZXcgQXJyYXkoaiksXG4gICAgICByID0gbmV3IEFycmF5KGopLFxuICAgICAgaSA9IC0xO1xuXG4gIC8vIFJldmVyc2UgZGVzY2VuZGluZyBkb21haW5zLlxuICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIH1cblxuICB3aGlsZSAoKytpIDwgaikge1xuICAgIGRbaV0gPSBub3JtYWxpemUoZG9tYWluW2ldLCBkb21haW5baSArIDFdKTtcbiAgICByW2ldID0gaW50ZXJwb2xhdGUocmFuZ2VbaV0sIHJhbmdlW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpID0gYmlzZWN0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xuICAgIHJldHVybiByW2ldKGRbaV0oeCkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5yYW5nZShzb3VyY2UucmFuZ2UoKSlcbiAgICAgIC5pbnRlcnBvbGF0ZShzb3VyY2UuaW50ZXJwb2xhdGUoKSlcbiAgICAgIC5jbGFtcChzb3VyY2UuY2xhbXAoKSlcbiAgICAgIC51bmtub3duKHNvdXJjZS51bmtub3duKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgcmFuZ2UgPSB1bml0LFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVZhbHVlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdW50cmFuc2Zvcm0sXG4gICAgICB1bmtub3duLFxuICAgICAgY2xhbXAgPSBpZGVudGl0eSxcbiAgICAgIHBpZWNld2lzZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIGlucHV0O1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICAgIGlmIChjbGFtcCAhPT0gaWRlbnRpdHkpIGNsYW1wID0gY2xhbXBlcihkb21haW5bMF0sIGRvbWFpbltuIC0gMV0pO1xuICAgIHBpZWNld2lzZSA9IG4gPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgIG91dHB1dCA9IGlucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBBcnJheS5mcm9tKF8sIG51bWJlciksIHJlc2NhbGUoKSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHJhbmdlID0gQXJyYXkuZnJvbShfKSwgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVJvdW5kLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSBfID8gdHJ1ZSA6IGlkZW50aXR5LCByZXNjYWxlKCkpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cygpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKCkoaWRlbnRpdHksIGlkZW50aXR5KTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpbml0UmFuZ2UoZG9tYWluLCByYW5nZSkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5yYW5nZShkb21haW4pOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aGlzLnJhbmdlKHJhbmdlKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0SW50ZXJwb2xhdG9yKGRvbWFpbiwgaW50ZXJwb2xhdG9yKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB7XG4gICAgICBpZiAodHlwZW9mIGRvbWFpbiA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmludGVycG9sYXRvcihkb21haW4pO1xuICAgICAgZWxzZSB0aGlzLnJhbmdlKGRvbWFpbik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhpcy5kb21haW4oZG9tYWluKTtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJwb2xhdG9yID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcik7XG4gICAgICBlbHNlIHRoaXMucmFuZ2UoaW50ZXJwb2xhdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCB7dGlja3MsIHRpY2tJbmNyZW1lbnR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5fSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuaW1wb3J0IHRpY2tGb3JtYXQgZnJvbSBcIi4vdGlja0Zvcm1hdC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LCBzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICB2YXIgaTAgPSAwO1xuICAgIHZhciBpMSA9IGQubGVuZ3RoIC0gMTtcbiAgICB2YXIgc3RhcnQgPSBkW2kwXTtcbiAgICB2YXIgc3RvcCA9IGRbaTFdO1xuICAgIHZhciBwcmVzdGVwO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBtYXhJdGVyID0gMTA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG4gICAgXG4gICAgd2hpbGUgKG1heEl0ZXItLSA+IDApIHtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgICBpZiAoc3RlcCA9PT0gcHJlc3RlcCkge1xuICAgICAgICBkW2kwXSA9IHN0YXJ0XG4gICAgICAgIGRbaTFdID0gc3RvcFxuICAgICAgICByZXR1cm4gZG9tYWluKGQpO1xuICAgICAgfSBlbHNlIGlmIChzdGVwID4gMCkge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHByZXN0ZXAgPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cygpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG51bWJlcih4KSB7XG4gIHJldHVybiAreDtcbn1cbiIsImltcG9ydCB7SW50ZXJuTWFwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBjb25zdCBpbXBsaWNpdCA9IFN5bWJvbChcImltcGxpY2l0XCIpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICB2YXIgaW5kZXggPSBuZXcgSW50ZXJuTWFwKCksXG4gICAgICBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIGxldCBpID0gaW5kZXguZ2V0KGQpO1xuICAgIGlmIChpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh1bmtub3duICE9PSBpbXBsaWNpdCkgcmV0dXJuIHVua25vd247XG4gICAgICBpbmRleC5zZXQoZCwgaSA9IGRvbWFpbi5wdXNoKGQpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZVtpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBuZXcgSW50ZXJuTWFwKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBfKSB7XG4gICAgICBpZiAoaW5kZXguaGFzKHZhbHVlKSkgY29udGludWU7XG4gICAgICBpbmRleC5zZXQodmFsdWUsIGRvbWFpbi5wdXNoKHZhbHVlKSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmRpbmFsKGRvbWFpbiwgcmFuZ2UpLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCB7Y29weSwgaWRlbnRpdHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb3coZXhwb25lbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3FydCh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC1NYXRoLnNxcnQoLXgpIDogTWF0aC5zcXJ0KHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXVhcmUoeCkge1xuICByZXR1cm4geCA8IDAgPyAteCAqIHggOiB4ICogeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvd2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSksXG4gICAgICBleHBvbmVudCA9IDE7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICByZXR1cm4gZXhwb25lbnQgPT09IDEgPyB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KVxuICAgICAgICA6IGV4cG9uZW50ID09PSAwLjUgPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3FydCwgdHJhbnNmb3JtU3F1YXJlKVxuICAgICAgICA6IHRyYW5zZm9ybSh0cmFuc2Zvcm1Qb3coZXhwb25lbnQpLCB0cmFuc2Zvcm1Qb3coMSAvIGV4cG9uZW50KSk7XG4gIH1cblxuICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHBvbmVudCA9ICtfLCByZXNjYWxlKCkpIDogZXhwb25lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgcG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXJ0KCkge1xuICByZXR1cm4gcG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3QsIHF1YW50aWxlU29ydGVkIGFzIHRocmVzaG9sZH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHJhbmdlW2Jpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gIH1cblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICBpID4gMCA/IHRocmVzaG9sZHNbaSAtIDFdIDogZG9tYWluWzBdLFxuICAgICAgaSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1tpXSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV1cbiAgICBdO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXTtcbiAgICBmb3IgKGxldCBkIG9mIF8pIGlmIChkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aXplKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgbiA9IDEsXG4gICAgICBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbeDAsIHgxXSA9IF8sIHgwID0gK3gwLCB4MSA9ICt4MSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBBcnJheS5mcm9tKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocmVzaG9sZCgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duLFxuICAgICAgbiA9IDE7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgeCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBBcnJheS5mcm9tKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHt0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdCwgZm9ybWF0UHJlZml4LCBmb3JtYXRTcGVjaWZpZXIsIHByZWNpc2lvbkZpeGVkLCBwcmVjaXNpb25QcmVmaXgsIHByZWNpc2lvblJvdW5kfSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpY2tGb3JtYXQoc3RhcnQsIHN0b3AsIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0ZXAgPSB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLFxuICAgICAgcHJlY2lzaW9uO1xuICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICBzd2l0Y2ggKHNwZWNpZmllci50eXBlKSB7XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgIHJldHVybiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzcGVjaWZpZXIpO1xufVxuIiwiLy8gR2l2ZW4gc29tZXRoaW5nIGFycmF5IGxpa2UgKG9yIG51bGwpLCByZXR1cm5zIHNvbWV0aGluZyB0aGF0IGlzIHN0cmljdGx5IGFuXG4vLyBhcnJheS4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGFycmF5LWxpa2Ugb2JqZWN0cyBwYXNzZWQgdG8gZDMuc2VsZWN0QWxsXG4vLyBvciBzZWxlY3Rpb24uc2VsZWN0QWxsIGFyZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgYXJyYXlzIHdoZW4gY3JlYXRpbmcgYVxuLy8gc2VsZWN0aW9uOyB3ZSBkb27igJl0IGV2ZXIgd2FudCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gYmFja2VkIGJ5IGEgbGl2ZVxuLy8gSFRNTENvbGxlY3Rpb24gb3IgTm9kZUxpc3QuIEhvd2V2ZXIsIG5vdGUgdGhhdCBzZWxlY3Rpb24uc2VsZWN0QWxsIHdpbGwgdXNlIGFcbi8vIHN0YXRpYyBOb2RlTGlzdCBhcyBhIGdyb3VwLCBzaW5jZSBpdCBzYWZlbHkgZGVyaXZlZCBmcm9tIHF1ZXJ5U2VsZWN0b3JBbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcnJheSh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyBbXSA6IEFycmF5LmlzQXJyYXkoeCkgPyB4IDogQXJyYXkuZnJvbSh4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0KGNyZWF0b3IobmFtZSkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4vbmFtZXNwYWNlLmpzXCI7XG5pbXBvcnQge3hodG1sfSBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZE1hdGNoZXIoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuIiwiaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xufVxuIiwiZXhwb3J0IHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuIiwiaW1wb3J0IHNvdXJjZUV2ZW50IGZyb20gXCIuL3NvdXJjZUV2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG4gIGV2ZW50ID0gc291cmNlRXZlbnQoZXZlbnQpO1xuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSBub2RlID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcbiAgICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gICAgfVxuICAgIGlmIChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiBbZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZXTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW2FycmF5KHNlbGVjdG9yKV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4uL25hbWVzcGFjZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59XG4iLCJmdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZShmYWxzZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgTWFwLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSArIFwiXCI7XG4gICAgICBpZiAobm9kZUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlKSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSkgKyBcIlwiO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlKSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWUuZGVsZXRlKGtleVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWVzW2ldKSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXR1bShub2RlKSB7XG4gIHJldHVybiBub2RlLl9fZGF0YV9fO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIEFycmF5LmZyb20odGhpcywgZGF0dW0pO1xuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IGFycmF5bGlrZSh2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cykpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gR2l2ZW4gc29tZSBkYXRhLCB0aGlzIHJldHVybnMgYW4gYXJyYXktbGlrZSB2aWV3IG9mIGl0OiBhbiBvYmplY3QgdGhhdFxuLy8gZXhwb3NlcyBhIGxlbmd0aCBwcm9wZXJ0eSBhbmQgYWxsb3dzIG51bWVyaWMgaW5kZXhpbmcuIE5vdGUgdGhhdCB1bmxpa2Vcbi8vIHNlbGVjdEFsbCwgdGhpcyBpc27igJl0IHdvcnJpZWQgYWJvdXQg4oCcbGl2ZeKAnSBjb2xsZWN0aW9ucyBiZWNhdXNlIHRoZSByZXN1bHRpbmdcbi8vIGFycmF5IHdpbGwgb25seSBiZSB1c2VkIGJyaWVmbHkgd2hpbGUgZGF0YSBpcyBiZWluZyBib3VuZC4gKEl0IGlzIHBvc3NpYmxlIHRvXG4vLyBjYXVzZSB0aGUgZGF0YSB0byBjaGFuZ2Ugd2hpbGUgaXRlcmF0aW5nIGJ5IHVzaW5nIGEga2V5IGZ1bmN0aW9uLCBidXQgcGxlYXNlXG4vLyBkb27igJl0OyB3ZeKAmWQgcmF0aGVyIGF2b2lkIGEgZ3JhdHVpdG91cyBjb3B5LilcbmZ1bmN0aW9uIGFycmF5bGlrZShkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGRhdGFcbiAgICA/IGRhdGEgLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKGRhdGEpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJmdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cbiIsImltcG9ydCBzZWxlY3Rpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkIGZyb20gXCIuL3NlbGVjdENoaWxkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuIGZyb20gXCIuL3NlbGVjdENoaWxkcmVuLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VudGVyIGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2V4aXQgZnJvbSBcIi4vZXhpdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9qb2luIGZyb20gXCIuL2pvaW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb3JkZXIgZnJvbSBcIi4vb3JkZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc29ydCBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NhbGwgZnJvbSBcIi4vY2FsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlcyBmcm9tIFwiLi9ub2Rlcy5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlIGZyb20gXCIuL25vZGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VtcHR5IGZyb20gXCIuL2VtcHR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VhY2ggZnJvbSBcIi4vZWFjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcHJvcGVydHkgZnJvbSBcIi4vcHJvcGVydHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xhc3NlZCBmcm9tIFwiLi9jbGFzc2VkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9odG1sIGZyb20gXCIuL2h0bWwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmFpc2UgZnJvbSBcIi4vcmFpc2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbG93ZXIgZnJvbSBcIi4vbG93ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXBwZW5kIGZyb20gXCIuL2FwcGVuZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnNlcnQgZnJvbSBcIi4vaW5zZXJ0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xvbmUgZnJvbSBcIi4vY2xvbmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0dW0gZnJvbSBcIi4vZGF0dW0uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGlzcGF0Y2ggZnJvbSBcIi4vZGlzcGF0Y2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3IuanNcIjtcblxuZXhwb3J0IHZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gIHNlbGVjdDogc2VsZWN0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiBzZWxlY3Rpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3NlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gIGRhdGE6IHNlbGVjdGlvbl9kYXRhLFxuICBlbnRlcjogc2VsZWN0aW9uX2VudGVyLFxuICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgam9pbjogc2VsZWN0aW9uX2pvaW4sXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogc2VsZWN0aW9uX3NlbGVjdGlvbixcbiAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gIGNhbGw6IHNlbGVjdGlvbl9jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3NpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICBhdHRyOiBzZWxlY3Rpb25fYXR0cixcbiAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgY2xhc3NlZDogc2VsZWN0aW9uX2NsYXNzZWQsXG4gIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgcmFpc2U6IHNlbGVjdGlvbl9yYWlzZSxcbiAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICBpbnNlcnQ6IHNlbGVjdGlvbl9pbnNlcnQsXG4gIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcbiAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgb246IHNlbGVjdGlvbl9vbixcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9pdGVyYXRvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VsZWN0aW9uO1xuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKigpIHtcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbmVudGVyLCBvbnVwZGF0ZSwgb25leGl0KSB7XG4gIHZhciBlbnRlciA9IHRoaXMuZW50ZXIoKSwgdXBkYXRlID0gdGhpcywgZXhpdCA9IHRoaXMuZXhpdCgpO1xuICBpZiAodHlwZW9mIG9uZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVudGVyID0gb25lbnRlcihlbnRlcik7XG4gICAgaWYgKGVudGVyKSBlbnRlciA9IGVudGVyLnNlbGVjdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGVudGVyID0gZW50ZXIuYXBwZW5kKG9uZW50ZXIgKyBcIlwiKTtcbiAgfVxuICBpZiAob251cGRhdGUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZSA9IG9udXBkYXRlKHVwZGF0ZSk7XG4gICAgaWYgKHVwZGF0ZSkgdXBkYXRlID0gdXBkYXRlLnNlbGVjdGlvbigpO1xuICB9XG4gIGlmIChvbmV4aXQgPT0gbnVsbCkgZXhpdC5yZW1vdmUoKTsgZWxzZSBvbmV4aXQoZXhpdCk7XG4gIHJldHVybiBlbnRlciAmJiB1cGRhdGUgPyBlbnRlci5tZXJnZSh1cGRhdGUpLm9yZGVyKCkgOiB1cGRhdGU7XG59XG4iLCJmdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQ7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG59XG4iLCJmdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCwgdGhpcy5fX2RhdGFfXyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIodmFsdWUpO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8ub3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBvcHRpb25zOiBvcHRpb25zfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBvcHRpb25zKSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgaWYgKG5leHQgJiYgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuZXh0KSBeIDQpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XG59XG4iLCJmdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi4vYXJyYXkuanNcIjtcbmltcG9ydCBzZWxlY3RvckFsbCBmcm9tIFwiLi4vc2VsZWN0b3JBbGwuanNcIjtcblxuZnVuY3Rpb24gYXJyYXlBbGwoc2VsZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJyYXkoc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgPT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gYXJyYXlBbGwoc2VsZWN0KTtcbiAgZWxzZSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQ7XG5cbmZ1bmN0aW9uIGNoaWxkRmluZChtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbmQuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoaWxkRmlyc3QoKSB7XG4gIHJldHVybiB0aGlzLmZpcnN0RWxlbWVudENoaWxkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QobWF0Y2ggPT0gbnVsbCA/IGNoaWxkRmlyc3RcbiAgICAgIDogY2hpbGRGaW5kKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5cbmZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5GaWx0ZXIobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdEFsbChtYXRjaCA9PSBudWxsID8gY2hpbGRyZW5cbiAgICAgIDogY2hpbGRyZW5GaWx0ZXIodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSArK3NpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG59XG4iLCJmdW5jdGlvbiBub25lKCkge31cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJmdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBsZXQgc291cmNlRXZlbnQ7XG4gIHdoaWxlIChzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50KSBldmVudCA9IHNvdXJjZUV2ZW50O1xuICByZXR1cm4gZXZlbnQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQge2FicywgYWNvcywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBtYXgsIG1pbiwgcGksIHNpbiwgc3FydCwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLFxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcbiAgICAgIHQgPSB5MzIgKiB4MTAgLSB4MzIgKiB5MTA7XG4gIGlmICh0ICogdCA8IGVwc2lsb24pIHJldHVybjtcbiAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gdDtcbiAgcmV0dXJuIFt4MCArIHQgKiB4MTAsIHkwICsgdCAqIHkxMF07XG59XG5cbi8vIENvbXB1dGUgcGVycGVuZGljdWxhciBvZmZzZXQgbGluZSBvZiBsZW5ndGggcmMuXG4vLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1MaW5lSW50ZXJzZWN0aW9uLmh0bWxcbmZ1bmN0aW9uIGNvcm5lclRhbmdlbnRzKHgwLCB5MCwgeDEsIHkxLCByMSwgcmMsIGN3KSB7XG4gIHZhciB4MDEgPSB4MCAtIHgxLFxuICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogc3FydChtYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksXG4gICAgICBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLFxuICAgICAgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsXG4gICAgICBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLFxuICAgICAgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsXG4gICAgICBkeDAgPSBjeDAgLSB4MDAsXG4gICAgICBkeTAgPSBjeTAgLSB5MDAsXG4gICAgICBkeDEgPSBjeDEgLSB4MDAsXG4gICAgICBkeTEgPSBjeTEgLSB5MDA7XG5cbiAgLy8gUGljayB0aGUgY2xvc2VyIG9mIHRoZSB0d28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgLy8gVE9ETyBJcyB0aGVyZSBhIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGludGVyc2VjdGlvbiB0byB1c2U/XG4gIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuXG4gIHJldHVybiB7XG4gICAgY3g6IGN4MCxcbiAgICBjeTogY3kwLFxuICAgIHgwMTogLW94LFxuICAgIHkwMTogLW95LFxuICAgIHgxMTogY3gwICogKHIxIC8gciAtIDEpLFxuICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5uZXJSYWRpdXMgPSBhcmNJbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCgwKSxcbiAgICAgIHBhZFJhZGl1cyA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IGFyY1BhZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgoYXJjKTtcblxuICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgcixcbiAgICAgICAgcjAgPSAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgcjEgPSArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgZGEgPSBhYnMoYTEgLSBhMCksXG4gICAgICAgIGN3ID0gYTEgPiBhMDtcblxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdXRlciByYWRpdXMgaXMgYWx3YXlzIGxhcmdlciB0aGFuIHRoZSBpbm5lciByYWRpdXMuXG4gICAgaWYgKHIxIDwgcjApIHIgPSByMSwgcjEgPSByMCwgcjAgPSByO1xuXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICBpZiAoIShyMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUgLSBlcHNpbG9uKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhyMSAqIGNvcyhhMCksIHIxICogc2luKGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAsIGExLCAhY3cpO1xuICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3FydChyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gbWluKGFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBzaW4oYXApKSxcbiAgICAgICAgICAgIHAxID0gYXNpbihycCAvIHIxICogc2luKGFwKSk7XG4gICAgICAgIGlmICgoZGEwIC09IHAwICogMikgPiBlcHNpbG9uKSBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcbiAgICAgICAgZWxzZSBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICBpZiAoKGRhMSAtPSBwMSAqIDIpID4gZXBzaWxvbikgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XG4gICAgICAgIGVsc2UgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIGNvcyhhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogY29zKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbihhMTEpLFxuICAgICAgICAgICAgeDAwID0gcjAgKiBjb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogc2luKGEwMCksXG4gICAgICAgICAgICBvYztcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS4gSWYgdGhpc1xuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gZmFpbHMsIGl04oCZcyBwcm9iYWJseSBiZWNhdXNlIHRoZSBhcmMgaXMgdG9vIHNtYWxsLCBzb1xuICAgICAgICAvLyBkaXNhYmxlIHRoZSBjb3JuZXIgcmFkaXVzIGVudGlyZWx5LlxuICAgICAgICBpZiAoZGEgPCBwaSkge1xuICAgICAgICAgIGlmIChvYyA9IGludGVyc2VjdCh4MDEsIHkwMSwgeDAwLCB5MDAsIHgxMSwgeTExLCB4MTAsIHkxMCkpIHtcbiAgICAgICAgICAgIHZhciBheCA9IHgwMSAtIG9jWzBdLFxuICAgICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcbiAgICAgICAgICAgICAgICBieSA9IHkxMSAtIG9jWzFdLFxuICAgICAgICAgICAgICAgIGtjID0gMSAvIHNpbihhY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBzcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksXG4gICAgICAgICAgICAgICAgbGMgPSBzcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICAgIHJjMCA9IG1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgICAgcmMxID0gbWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJjMCA9IHJjMSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cbiAgICAgIGlmICghKGRhMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgb3V0ZXIgcmluZyBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMSA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MDAsIHkwMCwgeDAxLCB5MDEsIHIxLCByYzEsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MTEsIHkxMSwgeDEwLCB5MTAsIHIxLCByYzEsIGN3KTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMxIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMxLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgb3V0ZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSksIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMDEsIGExMSwgIWN3KTtcblxuICAgICAgLy8gSXMgdGhlcmUgbm8gaW5uZXIgcmluZywgYW5kIGl04oCZcyBhIGNpcmN1bGFyIHNlY3Rvcj9cbiAgICAgIC8vIE9yIHBlcmhhcHMgaXTigJlzIGFuIGFubnVsYXIgc2VjdG9yIGNvbGxhcHNlZCBkdWUgdG8gcGFkZGluZz9cbiAgICAgIGlmICghKHIwID4gZXBzaWxvbikgfHwgIShkYTAgPiBlcHNpbG9uKSkgY29udGV4dC5saW5lVG8oeDEwLCB5MTApO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMCA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MTAsIHkxMCwgeDExLCB5MTEsIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDAxLCB5MDEsIHgwMCwgeTAwLCByMCwgLXJjMCwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzAgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMCwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgIHJldHVybiBbY29zKGEpICogciwgc2luKGEpICogcl07XG4gIH07XG5cbiAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlubmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBpbm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3V0ZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IG91dGVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29ybmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBjb3JuZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRSYWRpdXMgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgYXJjLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGFyYykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmM7XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhci5qc1wiO1xuaW1wb3J0IGxpbmUgZnJvbSBcIi4vbGluZS5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgwLCB5MCwgeTEpIHtcbiAgdmFyIHgxID0gbnVsbCxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgoYXJlYSk7XG5cbiAgeDAgPSB0eXBlb2YgeDAgPT09IFwiZnVuY3Rpb25cIiA/IHgwIDogKHgwID09PSB1bmRlZmluZWQpID8gcG9pbnRYIDogY29uc3RhbnQoK3gwKTtcbiAgeTAgPSB0eXBlb2YgeTAgPT09IFwiZnVuY3Rpb25cIiA/IHkwIDogKHkwID09PSB1bmRlZmluZWQpID8gY29uc3RhbnQoMCkgOiBjb25zdGFudCgreTApO1xuICB5MSA9IHR5cGVvZiB5MSA9PT0gXCJmdW5jdGlvblwiID8geTEgOiAoeTEgPT09IHVuZGVmaW5lZCkgPyBwb2ludFkgOiBjb25zdGFudCgreTEpO1xuXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBuID0gKGRhdGEgPSBhcnJheShkYXRhKSkubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHgweiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeTB6ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDE7XG4gIH07XG5cbiAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMCA9XG4gIGFyZWEubGluZVkwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkxKTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICB9O1xuXG4gIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBhcmVhKSA6IGN1cnZlO1xuICB9O1xuXG4gIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmVhO1xufVxuIiwiZXhwb3J0IHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiB4XG4gICAgPyB4IC8vIEFycmF5LCBUeXBlZEFycmF5LCBOb2RlTGlzdCwgYXJyYXktbGlrZVxuICAgIDogQXJyYXkuZnJvbSh4KTsgLy8gTWFwLCBTZXQsIGl0ZXJhYmxlLCBzdHJpbmcsIG9yIGFueXRoaW5nIGVsc2Vcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHBvaW50UmFkaWFsIGZyb20gXCIuLi9wb2ludFJhZGlhbC5qc1wiO1xuXG5jbGFzcyBCdW1wIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgeCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX3ggPSB4O1xuICB9XG4gIGFyZWFTdGFydCgpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfVxuICBhcmVhRW5kKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH1cbiAgbGluZVN0YXJ0KCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfVxuICBsaW5lRW5kKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH1cbiAgcG9pbnQoeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGlmICh0aGlzLl9saW5lKSB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgZWxzZSB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5feCkgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHRoaXMuX3gwID0gKHRoaXMuX3gwICsgeCkgLyAyLCB0aGlzLl95MCwgdGhpcy5feDAsIHksIHgsIHkpO1xuICAgICAgICBlbHNlIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh0aGlzLl94MCwgdGhpcy5feTAgPSAodGhpcy5feTAgKyB5KSAvIDIsIHgsIHRoaXMuX3kwLCB4LCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3gwID0geCwgdGhpcy5feTAgPSB5O1xuICB9XG59XG5cbmNsYXNzIEJ1bXBSYWRpYWwge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbiAgbGluZVN0YXJ0KCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfVxuICBsaW5lRW5kKCkge31cbiAgcG9pbnQoeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh0aGlzLl9wb2ludCA9PT0gMCkge1xuICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwMCA9IHBvaW50UmFkaWFsKHRoaXMuX3gwLCB0aGlzLl95MCk7XG4gICAgICBjb25zdCBwMSA9IHBvaW50UmFkaWFsKHRoaXMuX3gwLCB0aGlzLl95MCA9ICh0aGlzLl95MCArIHkpIC8gMik7XG4gICAgICBjb25zdCBwMiA9IHBvaW50UmFkaWFsKHgsIHRoaXMuX3kwKTtcbiAgICAgIGNvbnN0IHAzID0gcG9pbnRSYWRpYWwoeCwgeSk7XG4gICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyguLi5wMCk7XG4gICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oLi4ucDEsIC4uLnAyLCAuLi5wMyk7XG4gICAgfVxuICAgIHRoaXMuX3gwID0geCwgdGhpcy5feTAgPSB5O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidW1wWChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQnVtcChjb250ZXh0LCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXBZKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCdW1wKGNvbnRleHQsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXBSYWRpYWwoY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJ1bXBSYWRpYWwoY29udGV4dCk7XG59XG4iLCJmdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBkZWZhdWx0OiB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIHJldHVybiBkO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9jdXJ2ZS9saW5lYXIuanNcIjtcbmltcG9ydCB7d2l0aFBhdGh9IGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsLFxuICAgICAgcGF0aCA9IHdpdGhQYXRoKGxpbmUpO1xuXG4gIHggPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICh4ID09PSB1bmRlZmluZWQpID8gcG9pbnRYIDogY29uc3RhbnQoeCk7XG4gIHkgPSB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geSA6ICh5ID09PSB1bmRlZmluZWQpID8gcG9pbnRZIDogY29uc3RhbnQoeSk7XG5cbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSAoZGF0YSA9IGFycmF5KGRhdGEpKS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSBvdXRwdXQucG9pbnQoK3goZCwgaSwgZGF0YSksICt5KGQsIGksIGRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB4O1xuICB9O1xuXG4gIGxpbmUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeTtcbiAgfTtcblxuICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgbGluZSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGxpbmUuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgbGluZSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBsaW5lLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmUpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluZTtcbn1cbiIsImltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YnVtcFgsIGJ1bXBZLCBidW1wUmFkaWFsfSBmcm9tIFwiLi9jdXJ2ZS9idW1wLmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZnVuY3Rpb24gbGlua1NvdXJjZShkKSB7XG4gIHJldHVybiBkLnNvdXJjZTtcbn1cblxuZnVuY3Rpb24gbGlua1RhcmdldChkKSB7XG4gIHJldHVybiBkLnRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmsoY3VydmUpIHtcbiAgbGV0IHNvdXJjZSA9IGxpbmtTb3VyY2UsXG4gICAgICB0YXJnZXQgPSBsaW5rVGFyZ2V0LFxuICAgICAgeCA9IHBvaW50WCxcbiAgICAgIHkgPSBwb2ludFksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIG91dHB1dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgobGluayk7XG5cbiAgZnVuY3Rpb24gbGluaygpIHtcbiAgICBsZXQgYnVmZmVyO1xuICAgIGNvbnN0IGFyZ3YgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICBjb25zdCB0ID0gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3YpO1xuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG4gICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgIGFyZ3ZbMF0gPSBzLCBvdXRwdXQucG9pbnQoK3guYXBwbHkodGhpcywgYXJndiksICt5LmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICBhcmd2WzBdID0gdCwgb3V0cHV0LnBvaW50KCt4LmFwcGx5KHRoaXMsIGFyZ3YpLCAreS5hcHBseSh0aGlzLCBhcmd2KSk7XG4gICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluay5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc291cmNlID0gXywgbGluaykgOiBzb3VyY2U7XG4gIH07XG5cbiAgbGluay50YXJnZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFyZ2V0ID0gXywgbGluaykgOiB0YXJnZXQ7XG4gIH07XG5cbiAgbGluay54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluaykgOiB4O1xuICB9O1xuXG4gIGxpbmsueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeTtcbiAgfTtcblxuICBsaW5rLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmspIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmtIb3Jpem9udGFsKCkge1xuICByZXR1cm4gbGluayhidW1wWCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rVmVydGljYWwoKSB7XG4gIHJldHVybiBsaW5rKGJ1bXBZKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmtSYWRpYWwoKSB7XG4gIGNvbnN0IGwgPSBsaW5rKGJ1bXBSYWRpYWwpO1xuICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xuICBsLnJhZGl1cyA9IGwueSwgZGVsZXRlIGwueTtcbiAgcmV0dXJuIGw7XG59XG4iLCJleHBvcnQgY29uc3QgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgY29uc3QgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IGNvbnN0IGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IGNvbnN0IG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IGNvbnN0IG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IGNvbnN0IHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5cbmV4cG9ydCBjb25zdCBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgY29uc3QgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCBjb25zdCB0YXUgPSAyICogcGk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID49IDEgPyBoYWxmUGkgOiB4IDw9IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhQYXRoKHNoYXBlKSB7XG4gIGxldCBkaWdpdHMgPSAzO1xuXG4gIHNoYXBlLmRpZ2l0cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkaWdpdHM7XG4gICAgaWYgKF8gPT0gbnVsbCkge1xuICAgICAgZGlnaXRzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZCA9IE1hdGguZmxvb3IoXyk7XG4gICAgICBpZiAoIShkID49IDApKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7X31gKTtcbiAgICAgIGRpZ2l0cyA9IGQ7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuICByZXR1cm4gKCkgPT4gbmV3IFBhdGgoZGlnaXRzKTtcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgZGVzY2VuZGluZyBmcm9tIFwiLi9kZXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7dGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgIHNvcnRWYWx1ZXMgPSBkZXNjZW5kaW5nLFxuICAgICAgc29ydCA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gY29uc3RhbnQoMCksXG4gICAgICBlbmRBbmdsZSA9IGNvbnN0YW50KHRhdSksXG4gICAgICBwYWRBbmdsZSA9IGNvbnN0YW50KDApO1xuXG4gIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSAoZGF0YSA9IGFycmF5KGRhdGEpKS5sZW5ndGgsXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIGluZGV4ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBhcmNzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBhMCA9ICtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGRhID0gTWF0aC5taW4odGF1LCBNYXRoLm1heCgtdGF1LCBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gYTApKSxcbiAgICAgICAgYTEsXG4gICAgICAgIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksXG4gICAgICAgIHY7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHYgPSBhcmNzW2luZGV4W2ldID0gaV0gPSArdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSkpID4gMCkge1xuICAgICAgICBzdW0gKz0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IHNvcnQgdGhlIGFyY3MgYnkgcHJldmlvdXNseS1jb21wdXRlZCB2YWx1ZXMgb3IgYnkgZGF0YS5cbiAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnRWYWx1ZXMoYXJjc1tpXSwgYXJjc1tqXSk7IH0pO1xuICAgIGVsc2UgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0KGRhdGFbaV0sIGRhdGFbal0pOyB9KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGFyY3MhIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGUgb3JpZ2luYWwgZGF0YSdzIG9yZGVyLlxuICAgIGZvciAoaSA9IDAsIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMDsgaSA8IG47ICsraSwgYTAgPSBhMSkge1xuICAgICAgaiA9IGluZGV4W2ldLCB2ID0gYXJjc1tqXSwgYTEgPSBhMCArICh2ID4gMCA/IHYgKiBrIDogMCkgKyBwYSwgYXJjc1tqXSA9IHtcbiAgICAgICAgZGF0YTogZGF0YVtqXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiB2LFxuICAgICAgICBzdGFydEFuZ2xlOiBhMCxcbiAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICBwYWRBbmdsZTogcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJjcztcbiAgfVxuXG4gIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogdmFsdWU7XG4gIH07XG5cbiAgcGllLnNvcnRWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydFZhbHVlcyA9IF8sIHNvcnQgPSBudWxsLCBwaWUpIDogc29ydFZhbHVlcztcbiAgfTtcblxuICBwaWUuc29ydCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0ID0gXywgc29ydFZhbHVlcyA9IG51bGwsIHBpZSkgOiBzb3J0O1xuICB9O1xuXG4gIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgcGllLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBwaWUucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIHJldHVybiBwaWU7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24geChwKSB7XG4gIHJldHVybiBwWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24geShwKSB7XG4gIHJldHVybiBwWzFdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gWyh5ID0gK3kpICogTWF0aC5jb3MoeCAtPSBNYXRoLlBJIC8gMiksIHkgKiBNYXRoLnNpbih4KV07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7d2l0aFBhdGh9IGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCBhc3RlcmlzayBmcm9tIFwiLi9zeW1ib2wvYXN0ZXJpc2suanNcIjtcbmltcG9ydCBjaXJjbGUgZnJvbSBcIi4vc3ltYm9sL2NpcmNsZS5qc1wiO1xuaW1wb3J0IGNyb3NzIGZyb20gXCIuL3N5bWJvbC9jcm9zcy5qc1wiO1xuaW1wb3J0IGRpYW1vbmQgZnJvbSBcIi4vc3ltYm9sL2RpYW1vbmQuanNcIjtcbmltcG9ydCBkaWFtb25kMiBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZDIuanNcIjtcbmltcG9ydCBwbHVzIGZyb20gXCIuL3N5bWJvbC9wbHVzLmpzXCI7XG5pbXBvcnQgc3F1YXJlIGZyb20gXCIuL3N5bWJvbC9zcXVhcmUuanNcIjtcbmltcG9ydCBzcXVhcmUyIGZyb20gXCIuL3N5bWJvbC9zcXVhcmUyLmpzXCI7XG5pbXBvcnQgc3RhciBmcm9tIFwiLi9zeW1ib2wvc3Rhci5qc1wiO1xuaW1wb3J0IHRyaWFuZ2xlIGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZS5qc1wiO1xuaW1wb3J0IHRyaWFuZ2xlMiBmcm9tIFwiLi9zeW1ib2wvdHJpYW5nbGUyLmpzXCI7XG5pbXBvcnQgd3llIGZyb20gXCIuL3N5bWJvbC93eWUuanNcIjtcbmltcG9ydCB0aW1lcyBmcm9tIFwiLi9zeW1ib2wvdGltZXMuanNcIjtcblxuLy8gVGhlc2Ugc3ltYm9scyBhcmUgZGVzaWduZWQgdG8gYmUgZmlsbGVkLlxuZXhwb3J0IGNvbnN0IHN5bWJvbHNGaWxsID0gW1xuICBjaXJjbGUsXG4gIGNyb3NzLFxuICBkaWFtb25kLFxuICBzcXVhcmUsXG4gIHN0YXIsXG4gIHRyaWFuZ2xlLFxuICB3eWVcbl07XG5cbi8vIFRoZXNlIHN5bWJvbHMgYXJlIGRlc2lnbmVkIHRvIGJlIHN0cm9rZWQgKHdpdGggYSB3aWR0aCBvZiAxLjVweCBhbmQgcm91bmQgY2FwcykuXG5leHBvcnQgY29uc3Qgc3ltYm9sc1N0cm9rZSA9IFtcbiAgY2lyY2xlLFxuICBwbHVzLFxuICB0aW1lcyxcbiAgdHJpYW5nbGUyLFxuICBhc3RlcmlzayxcbiAgc3F1YXJlMixcbiAgZGlhbW9uZDJcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN5bWJvbCh0eXBlLCBzaXplKSB7XG4gIGxldCBjb250ZXh0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChzeW1ib2wpO1xuXG4gIHR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiID8gdHlwZSA6IGNvbnN0YW50KHR5cGUgfHwgY2lyY2xlKTtcbiAgc2l6ZSA9IHR5cGVvZiBzaXplID09PSBcImZ1bmN0aW9uXCIgPyBzaXplIDogY29uc3RhbnQoc2l6ZSA9PT0gdW5kZWZpbmVkID8gNjQgOiArc2l6ZSk7XG5cbiAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIGxldCBidWZmZXI7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuICAgIHR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS5kcmF3KGNvbnRleHQsICtzaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHlwZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHN5bWJvbCkgOiB0eXBlO1xuICB9O1xuXG4gIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNpemUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3ltYm9sKSA6IHNpemU7XG4gIH07XG5cbiAgc3ltYm9sLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gc3ltYm9sO1xufVxuIiwiaW1wb3J0IHttaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmNvbnN0IHNxcnQzID0gc3FydCgzKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplICsgbWluKHNpemUgLyAyOCwgMC43NSkpICogMC41OTQzNjtcbiAgICBjb25zdCB0ID0gciAvIDI7XG4gICAgY29uc3QgdSA9IHQgKiBzcXJ0MztcbiAgICBjb250ZXh0Lm1vdmVUbygwLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCAtcik7XG4gICAgY29udGV4dC5tb3ZlVG8oLXUsIC10KTtcbiAgICBjb250ZXh0LmxpbmVUbyh1LCB0KTtcbiAgICBjb250ZXh0Lm1vdmVUbygtdSwgdCk7XG4gICAgY29udGV4dC5saW5lVG8odSwgLXQpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtwaSwgc3FydCwgdGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLyBwaSk7XG4gICAgY29udGV4dC5tb3ZlVG8ociwgMCk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgciwgMCwgdGF1KTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuY29uc3QgdGFuMzAgPSBzcXJ0KDEgLyAzKTtcbmNvbnN0IHRhbjMwXzIgPSB0YW4zMCAqIDI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgeSA9IHNxcnQoc2l6ZSAvIHRhbjMwXzIpO1xuICAgIGNvbnN0IHggPSB5ICogdGFuMzA7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIHkpO1xuICAgIGNvbnRleHQubGluZVRvKC14LCAwKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUpICogMC42MjYyNTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge21pbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplIC0gbWluKHNpemUgLyA3LCAyKSkgKiAwLjg3NTU5O1xuICAgIGNvbnRleHQubW92ZVRvKC1yLCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAwKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCAtcik7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgdyA9IHNxcnQoc2l6ZSk7XG4gICAgY29uc3QgeCA9IC13IC8gMjtcbiAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSkgKiAwLjQ0MzE7XG4gICAgY29udGV4dC5tb3ZlVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NpbiwgY29zLCBzcXJ0LCBwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBrYSA9IDAuODkwODEzMDkxNTI5Mjg1MjI4MTA7XG5jb25zdCBrciA9IHNpbihwaSAvIDEwKSAvIHNpbig3ICogcGkgLyAxMCk7XG5jb25zdCBreCA9IHNpbih0YXUgLyAxMCkgKiBrcjtcbmNvbnN0IGt5ID0gLWNvcyh0YXUgLyAxMCkgKiBrcjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplICoga2EpO1xuICAgIGNvbnN0IHggPSBreCAqIHI7XG4gICAgY29uc3QgeSA9IGt5ICogcjtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA1OyArK2kpIHtcbiAgICAgIGNvbnN0IGEgPSB0YXUgKiBpIC8gNTtcbiAgICAgIGNvbnN0IGMgPSBjb3MoYSk7XG4gICAgICBjb25zdCBzID0gc2luKGEpO1xuICAgICAgY29udGV4dC5saW5lVG8ocyAqIHIsIC1jICogcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7bWluLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLSBtaW4oc2l6ZSAvIDYsIDEuNykpICogMC42MTg5O1xuICAgIGNvbnRleHQubW92ZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5tb3ZlVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuY29uc3Qgc3FydDMgPSBzcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHkgPSAtc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICBjb250ZXh0LmxpbmVUbygtc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuY29uc3Qgc3FydDMgPSBzcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHMgPSBzcXJ0KHNpemUpICogMC42ODI0O1xuICAgIGNvbnN0IHQgPSBzICAvIDI7XG4gICAgY29uc3QgdSA9IChzICogc3FydDMpIC8gMjsgLy8gY29zKE1hdGguUEkgLyA2KVxuICAgIGNvbnRleHQubW92ZVRvKDAsIC1zKTtcbiAgICBjb250ZXh0LmxpbmVUbyh1LCB0KTtcbiAgICBjb250ZXh0LmxpbmVUbygtdSwgdCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuY29uc3QgYyA9IC0wLjU7XG5jb25zdCBzID0gc3FydCgzKSAvIDI7XG5jb25zdCBrID0gMSAvIHNxcnQoMTIpO1xuY29uc3QgYSA9IChrIC8gMiArIDEpICogMztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplIC8gYSk7XG4gICAgY29uc3QgeDAgPSByIC8gMiwgeTAgPSByICogaztcbiAgICBjb25zdCB4MSA9IHgwLCB5MSA9IHIgKiBrICsgcjtcbiAgICBjb25zdCB4MiA9IC14MSwgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgZXZlbnQsIHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyBkcmFnIH0gZnJvbSAnZDMtZHJhZyc7XG5pbXBvcnQgeyBhcmMsIGN1cnZlQ2F0bXVsbFJvbSwgY3VydmVMaW5lYXIsIGxpbmUgfSBmcm9tICdkMy1zaGFwZSc7XG5pbXBvcnQgeyBkaXNwYXRjaCB9IGZyb20gJ2QzLWRpc3BhdGNoJztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxudmFyIEFubm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb24oX3JlZikge1xuICAgIHZhciBfcmVmJHggPSBfcmVmLngsXG4gICAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICAgIF9yZWYkeSA9IF9yZWYueSxcbiAgICAgICAgeSA9IF9yZWYkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeSxcbiAgICAgICAgbnggPSBfcmVmLm54LFxuICAgICAgICBueSA9IF9yZWYubnksXG4gICAgICAgIF9yZWYkZHkgPSBfcmVmLmR5LFxuICAgICAgICBkeSA9IF9yZWYkZHkgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGR5LFxuICAgICAgICBfcmVmJGR4ID0gX3JlZi5keCxcbiAgICAgICAgZHggPSBfcmVmJGR4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRkeCxcbiAgICAgICAgX3JlZiRjb2xvciA9IF9yZWYuY29sb3IsXG4gICAgICAgIGNvbG9yID0gX3JlZiRjb2xvciA9PT0gdW5kZWZpbmVkID8gXCJncmV5XCIgOiBfcmVmJGNvbG9yLFxuICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICBzdWJqZWN0ID0gX3JlZi5zdWJqZWN0LFxuICAgICAgICBjb25uZWN0b3IgPSBfcmVmLmNvbm5lY3RvcixcbiAgICAgICAgbm90ZSA9IF9yZWYubm90ZSxcbiAgICAgICAgZGlzYWJsZSA9IF9yZWYuZGlzYWJsZSxcbiAgICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uKTtcblxuICAgIHRoaXMuX2R4ID0gbnggIT09IHVuZGVmaW5lZCA/IG54IC0geCA6IGR4O1xuICAgIHRoaXMuX2R5ID0gbnkgIT09IHVuZGVmaW5lZCA/IG55IC0geSA6IGR5O1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuX2NsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCBcIlwiO1xuXG4gICAgdGhpcy5fdHlwZSA9IHR5cGUgfHwgXCJcIjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgdGhpcy5ub3RlID0gbm90ZSB8fCB7fTtcbiAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvciB8fCB7fTtcbiAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0IHx8IHt9O1xuXG4gICAgdGhpcy5kaXNhYmxlID0gZGlzYWJsZSB8fCBbXTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEFubm90YXRpb24sIFt7XG4gICAga2V5OiBcInVwZGF0ZVBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudHlwZS5zZXRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnR5cGUuc2V0UG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zdWJqZWN0ICYmIHRoaXMudHlwZS5zdWJqZWN0LnNlbGVjdEFsbChcIjpub3QoLmhhbmRsZSlcIikubm9kZXMoKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aGlzLnR5cGUucmVkcmF3U3ViamVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQ29tcG9uZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLnR5cGUuY2xlYXJDb21wb25lbnRzICYmIHRoaXMudHlwZS5jbGVhckNvbXBvbmVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU9mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUuc2V0T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMudHlwZS5zZXRPZmZzZXQoKTtcblxuICAgICAgICBpZiAodGhpcy50eXBlLmNvbm5lY3Rvci5zZWxlY3RBbGwoXCI6bm90KC5oYW5kbGUpXCIpLm5vZGVzKCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy50eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50eXBlLnJlZHJhd05vdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhc3NOYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xhc3NOYW1lO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLl9jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICBpZiAodGhpcy50eXBlLnNldENsYXNzTmFtZSkgdGhpcy50eXBlLnNldENsYXNzTmFtZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHR5cGUpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5jbGVhckNvbXBvbmVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh4KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh5KSB7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29sb3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKGNvbG9yKSB7XG4gICAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkeFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2R4O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoZHgpIHtcbiAgICAgIHRoaXMuX2R4ID0gZHg7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2R5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoZHkpIHtcbiAgICAgIHRoaXMuX2R5ID0gZHk7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJueFwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG54KSB7XG4gICAgICB0aGlzLl9keCA9IG54IC0gdGhpcy5feDtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm55XCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobnkpIHtcbiAgICAgIHRoaXMuX2R5ID0gbnkgLSB0aGlzLl95O1xuICAgICAgdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLl9keCwgeTogdGhpcy5fZHkgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKF9yZWYyKSB7XG4gICAgICB2YXIgeCA9IF9yZWYyLngsXG4gICAgICAgICAgeSA9IF9yZWYyLnk7XG5cbiAgICAgIHRoaXMuX2R4ID0geDtcbiAgICAgIHRoaXMuX2R5ID0geTtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc2l0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLl94LCB5OiB0aGlzLl95IH07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShfcmVmMykge1xuICAgICAgdmFyIHggPSBfcmVmMy54LFxuICAgICAgICAgIHkgPSBfcmVmMy55O1xuXG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2xhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5feCArIHRoaXMuX2R4LFxuICAgICAgICB5OiB0aGlzLl95ICsgdGhpcy5fZHlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpzb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHZhciBqc29uID0ge1xuICAgICAgICB4OiB0aGlzLl94LFxuICAgICAgICB5OiB0aGlzLl95LFxuICAgICAgICBkeDogdGhpcy5fZHgsXG4gICAgICAgIGR5OiB0aGlzLl9keVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZGF0YSAmJiBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmxlbmd0aCA+IDApIGpzb24uZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGlmICh0aGlzLnR5cGUpIGpzb24udHlwZSA9IHRoaXMudHlwZTtcbiAgICAgIGlmICh0aGlzLl9jbGFzc05hbWUpIGpzb24uY2xhc3NOYW1lID0gdGhpcy5fY2xhc3NOYW1lO1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb25uZWN0b3IpLmxlbmd0aCA+IDApIGpzb24uY29ubmVjdG9yID0gdGhpcy5jb25uZWN0b3I7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zdWJqZWN0KS5sZW5ndGggPiAwKSBqc29uLnN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5ub3RlKS5sZW5ndGggPiAwKSBqc29uLm5vdGUgPSB0aGlzLm5vdGU7XG5cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQW5ub3RhdGlvbjtcbn0oKTtcblxudmFyIEFubm90YXRpb25Db2xsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbm5vdGF0aW9uQ29sbGVjdGlvbihfcmVmKSB7XG4gICAgdmFyIGFubm90YXRpb25zID0gX3JlZi5hbm5vdGF0aW9ucyxcbiAgICAgICAgYWNjZXNzb3JzID0gX3JlZi5hY2Nlc3NvcnMsXG4gICAgICAgIGFjY2Vzc29yc0ludmVyc2UgPSBfcmVmLmFjY2Vzc29yc0ludmVyc2U7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5ub3RhdGlvbkNvbGxlY3Rpb24pO1xuXG4gICAgdGhpcy5hY2Nlc3NvcnMgPSBhY2Nlc3NvcnM7XG4gICAgdGhpcy5hY2Nlc3NvcnNJbnZlcnNlID0gYWNjZXNzb3JzSW52ZXJzZTtcbiAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhBbm5vdGF0aW9uQ29sbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiY2xlYXJUeXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclR5cGVzKG5ld1NldHRpbmdzKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZC50eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBkLnN1YmplY3QgPSBuZXdTZXR0aW5ncyAmJiBuZXdTZXR0aW5ncy5zdWJqZWN0IHx8IGQuc3ViamVjdDtcbiAgICAgICAgZC5jb25uZWN0b3IgPSBuZXdTZXR0aW5ncyAmJiBuZXdTZXR0aW5ncy5jb25uZWN0b3IgfHwgZC5jb25uZWN0b3I7XG4gICAgICAgIGQubm90ZSA9IG5ld1NldHRpbmdzICYmIG5ld1NldHRpbmdzLm5vdGUgfHwgZC5ub3RlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uV2l0aEFjY2Vzc29yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbldpdGhBY2Nlc3NvcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZC50eXBlLnNldFBvc2l0aW9uV2l0aEFjY2Vzc29ycyhfdGhpcy5hY2Nlc3NvcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRNb2RlKF9lZGl0TW9kZSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChhLnR5cGUpIHtcbiAgICAgICAgICBhLnR5cGUuZWRpdE1vZGUgPSBfZWRpdE1vZGU7XG4gICAgICAgICAgYS50eXBlLnVwZGF0ZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVEaXNhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc2FibGUoZGlzYWJsZSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEuZGlzYWJsZSA9IGRpc2FibGU7XG4gICAgICAgIGlmIChhLnR5cGUpIHtcbiAgICAgICAgICBkaXNhYmxlLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChhLnR5cGVbZF0pIHtcbiAgICAgICAgICAgICAgYS50eXBlW2RdLnJlbW92ZSAmJiBhLnR5cGVbZF0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGEudHlwZVtkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVRleHRXcmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRleHRXcmFwKHRleHRXcmFwKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSAmJiBhLnR5cGUudXBkYXRlVGV4dFdyYXApIHtcbiAgICAgICAgICBhLnR5cGUudXBkYXRlVGV4dFdyYXAodGV4dFdyYXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUZXh0KCkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChhLnR5cGUgJiYgYS50eXBlLmRyYXdUZXh0KSB7XG4gICAgICAgICAgYS50eXBlLmRyYXdUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVOb3RlUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVOb3RlUGFkZGluZyhub3RlUGFkZGluZykge1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChhLnR5cGUpIHtcbiAgICAgICAgICBhLnR5cGUubm90ZVBhZGRpbmcgPSBub3RlUGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpzb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGpzb24gPSBhLmpzb247XG4gICAgICAgIGlmIChfdGhpczIuYWNjZXNzb3JzSW52ZXJzZSAmJiBhLmRhdGEpIHtcbiAgICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpczIuYWNjZXNzb3JzSW52ZXJzZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAganNvbi5kYXRhW2tdID0gX3RoaXMyLmFjY2Vzc29yc0ludmVyc2Vba10oeyB4OiBhLngsIHk6IGEueSB9KTtcblxuICAgICAgICAgICAgLy9UT0RPIG1ha2UgdGhpcyBmZWFzaWJsZSB0byBtYXAgYmFjayB0byBkYXRhIGZvciBvdGhlciB0eXBlcyBvZiBzdWJqZWN0c1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vdGVOb2Rlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYS50eXBlLmdldE5vdGVCQm94T2Zmc2V0KCksIHsgcG9zaXRpb25YOiBhLngsIHBvc2l0aW9uWTogYS55IH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy9UT0RPOiBjb21lIGJhY2sgYW5kIHJldGhpbmsgaWYgYS54IGFuZCBhLnkgYXJlIGFwcGxpY2FibGUgaW4gYWxsIHNpdHVhdGlvbnNcbiAgICAvLyBnZXQgY29ubmVjdG9yTm9kZXMoKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoYSA9PiAoeyAuLi5hLnR5cGUuZ2V0Q29ubmVjdG9yQkJveCgpLCBzdGFydFg6IGEueCwgc3RhcnRZOiBhLnl9KSlcbiAgICAvLyB9XG5cbiAgICAvLyBnZXQgc3ViamVjdE5vZGVzKCkge1xuICAgIC8vICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbnMubWFwKGEgPT4gKHsgLi4uYS50eXBlLmdldFN1YmplY3RCQm94KCksIHN0YXJ0WDogYS54LCBzdGFydFk6IGEueX0pKVxuICAgIC8vIH1cblxuICAgIC8vIGdldCBhbm5vdGF0aW9uTm9kZXMoKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoYSA9PiAoeyAuLi5hLnR5cGUuZ2V0QW5ub3RhdGlvbkJCb3goKSwgc3RhcnRYOiBhLngsIHN0YXJ0WTogYS55fSkpXG4gICAgLy8gfVxuXG4gIH1dKTtcbiAgcmV0dXJuIEFubm90YXRpb25Db2xsZWN0aW9uO1xufSgpO1xuXG52YXIgcG9pbnRIYW5kbGUgPSBmdW5jdGlvbiBwb2ludEhhbmRsZShfcmVmKSB7XG4gIHZhciBfcmVmJGN4ID0gX3JlZi5jeCxcbiAgICAgIGN4ID0gX3JlZiRjeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkY3gsXG4gICAgICBfcmVmJGN5ID0gX3JlZi5jeSxcbiAgICAgIGN5ID0gX3JlZiRjeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkY3k7XG5cbiAgcmV0dXJuIHsgbW92ZTogeyB4OiBjeCwgeTogY3kgfSB9O1xufTtcblxudmFyIGNpcmNsZUhhbmRsZXMgPSBmdW5jdGlvbiBjaXJjbGVIYW5kbGVzKF9yZWYyKSB7XG4gIHZhciBfcmVmMiRjeCA9IF9yZWYyLmN4LFxuICAgICAgY3ggPSBfcmVmMiRjeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJGN4LFxuICAgICAgX3JlZjIkY3kgPSBfcmVmMi5jeSxcbiAgICAgIGN5ID0gX3JlZjIkY3kgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMiRjeSxcbiAgICAgIHIxID0gX3JlZjIucjEsXG4gICAgICByMiA9IF9yZWYyLnIyLFxuICAgICAgcGFkZGluZyA9IF9yZWYyLnBhZGRpbmc7XG5cbiAgdmFyIGggPSB7IG1vdmU6IHsgeDogY3gsIHk6IGN5IH0gfTtcblxuICBpZiAocjEgIT09IHVuZGVmaW5lZCkge1xuICAgIGgucjEgPSB7IHg6IGN4ICsgcjEgLyBNYXRoLnNxcnQoMiksIHk6IGN5ICsgcjEgLyBNYXRoLnNxcnQoMikgfTtcbiAgfVxuXG4gIGlmIChyMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaC5yMiA9IHsgeDogY3ggKyByMiAvIE1hdGguc3FydCgyKSwgeTogY3kgKyByMiAvIE1hdGguc3FydCgyKSB9O1xuICB9XG5cbiAgaWYgKHBhZGRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGgucGFkZGluZyA9IHsgeDogY3ggKyByMSArIHBhZGRpbmcsIHk6IGN5IH07XG4gIH1cblxuICByZXR1cm4gaDtcbn07XG5cblxuXG5cblxuLy9hcmMgaGFuZGxlc1xudmFyIGFkZEhhbmRsZXMgPSBmdW5jdGlvbiBhZGRIYW5kbGVzKF9yZWY1KSB7XG4gIHZhciBncm91cCA9IF9yZWY1Lmdyb3VwLFxuICAgICAgaGFuZGxlcyA9IF9yZWY1LmhhbmRsZXMsXG4gICAgICBfcmVmNSRyID0gX3JlZjUucixcbiAgICAgIHIgPSBfcmVmNSRyID09PSB1bmRlZmluZWQgPyAxMCA6IF9yZWY1JHI7XG5cbiAgLy9naXZlIGl0IGEgZ3JvdXAgYW5kIHgseSB0byBkcmF3IGhhbmRsZXNcbiAgLy90aGVuIGdpdmUgaXQgaW5zdHJ1Y3Rpb25zIG9uIHdoYXQgdGhlIGhhbmRsZXMgY2hhbmdlXG4gIHZhciBoID0gZ3JvdXAuc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5kYXRhKGhhbmRsZXMpO1xuXG4gIGguZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpLmF0dHIoXCJmaWxsXCIsIFwiZ3JleVwiKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDAuMSkuYXR0cihcImN1cnNvclwiLCBcIm1vdmVcIikuYXR0cihcInN0cm9rZS1kYXNoYXJyYXlcIiwgNSkuYXR0cihcInN0cm9rZVwiLCBcImdyZXlcIikuY2FsbChkcmFnKCkuY29udGFpbmVyKHNlbGVjdChcImcuYW5ub3RhdGlvbnNcIikubm9kZSgpKS5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc3RhcnQgJiYgZC5zdGFydChkKTtcbiAgfSkub24oXCJkcmFnXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuZHJhZyAmJiBkLmRyYWcoZCk7XG4gIH0pLm9uKFwiZW5kXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuZW5kICYmIGQuZW5kKGQpO1xuICB9KSk7XG5cbiAgZ3JvdXAuc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5hdHRyKFwiY3hcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9KS5hdHRyKFwiY3lcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9KS5hdHRyKFwiclwiLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnIgfHwgcjtcbiAgfSkuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIFwiaGFuZGxlIFwiICsgKGQuY2xhc3NOYW1lIHx8IFwiXCIpO1xuICB9KTtcblxuICBoLmV4aXQoKS5yZW1vdmUoKTtcbn07XG5cbnZhciBsZWZ0UmlnaHREeW5hbWljID0gZnVuY3Rpb24gbGVmdFJpZ2h0RHluYW1pYyhhbGlnbiwgeSkge1xuICBpZiAoYWxpZ24gPT09IFwiZHluYW1pY1wiIHx8IGFsaWduID09PSBcImxlZnRcIiB8fCBhbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgaWYgKHkgPCAwKSB7XG4gICAgICBhbGlnbiA9IFwidG9wXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWduID0gXCJib3R0b21cIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsaWduO1xufTtcblxudmFyIHRvcEJvdHRvbUR5bmFtaWMgPSBmdW5jdGlvbiB0b3BCb3R0b21EeW5hbWljKGFsaWduLCB4KSB7XG4gIGlmIChhbGlnbiA9PT0gXCJkeW5hbWljXCIgfHwgYWxpZ24gPT09IFwidG9wXCIgfHwgYWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGFsaWduID0gXCJyaWdodFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGlnbiA9IFwibGVmdFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxpZ247XG59O1xuXG52YXIgb3JpZW50YXRpb25Ub3BCb3R0b20gPSBbXCJ0b3BCb3R0b21cIiwgXCJ0b3BcIiwgXCJib3R0b21cIl07XG52YXIgb3JpZW50YXRpb25MZWZ0UmlnaHQgPSBbXCJsZWZ0UmlnaHRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5cbnZhciBub3RlQWxpZ25tZW50ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmJHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX3JlZiRwYWRkaW5nID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRwYWRkaW5nLFxuICAgICAgX3JlZiRiYm94ID0gX3JlZi5iYm94LFxuICAgICAgYmJveCA9IF9yZWYkYmJveCA9PT0gdW5kZWZpbmVkID8geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0gOiBfcmVmJGJib3gsXG4gICAgICBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBvcmllbnRhdGlvbiA9IF9yZWYub3JpZW50YXRpb24sXG4gICAgICBfcmVmJG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX3JlZiRvZmZzZXQgPT09IHVuZGVmaW5lZCA/IHsgeDogMCwgeTogMCB9IDogX3JlZiRvZmZzZXQ7XG5cbiAgdmFyIHggPSAtYmJveC54O1xuICB2YXIgeSA9IDA7IC8vLWJib3gueVxuICBpZiAob3JpZW50YXRpb25Ub3BCb3R0b20uaW5kZXhPZihvcmllbnRhdGlvbikgIT09IC0xKSB7XG4gICAgYWxpZ24gPSB0b3BCb3R0b21EeW5hbWljKGFsaWduLCBvZmZzZXQueCk7XG4gICAgaWYgKG9mZnNldC55IDwgMCAmJiBvcmllbnRhdGlvbiA9PT0gXCJ0b3BCb3R0b21cIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJ0b3BcIikge1xuICAgICAgeSAtPSBiYm94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0gcGFkZGluZztcbiAgICB9XG5cbiAgICBpZiAoYWxpZ24gPT09IFwibWlkZGxlXCIpIHtcbiAgICAgIHggLT0gYmJveC53aWR0aCAvIDI7XG4gICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICB4IC09IGJib3gud2lkdGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uTGVmdFJpZ2h0LmluZGV4T2Yob3JpZW50YXRpb24pICE9PSAtMSkge1xuICAgIGFsaWduID0gbGVmdFJpZ2h0RHluYW1pYyhhbGlnbiwgb2Zmc2V0LnkpO1xuICAgIGlmIChvZmZzZXQueCA8IDAgJiYgb3JpZW50YXRpb24gPT09IFwibGVmdFJpZ2h0XCIgfHwgb3JpZW50YXRpb24gPT09IFwibGVmdFwiKSB7XG4gICAgICB4IC09IGJib3gud2lkdGggKyBwYWRkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IHBhZGRpbmc7XG4gICAgfVxuXG4gICAgaWYgKGFsaWduID09PSBcIm1pZGRsZVwiKSB7XG4gICAgICB5IC09IGJib3guaGVpZ2h0IC8gMjtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcInRvcFwiKSB7XG4gICAgICB5IC09IGJib3guaGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn0pO1xuXG52YXIgbGluZUJ1aWxkZXIgPSBmdW5jdGlvbiBsaW5lQnVpbGRlcihfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgX3JlZiRjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBjdXJ2ZSA9IF9yZWYkY3VydmUgPT09IHVuZGVmaW5lZCA/IGN1cnZlTGluZWFyIDogX3JlZiRjdXJ2ZSxcbiAgICAgIGNhbnZhc0NvbnRleHQgPSBfcmVmLmNhbnZhc0NvbnRleHQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzSUQgPSBfcmVmLmNsYXNzSUQ7XG5cbiAgdmFyIGxpbmVHZW4gPSBsaW5lKCkuY3VydmUoY3VydmUpO1xuXG4gIHZhciBidWlsZGVyID0ge1xuICAgIHR5cGU6ICdwYXRoJyxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBjbGFzc0lEOiBjbGFzc0lELFxuICAgIGRhdGE6IGRhdGFcbiAgfTtcblxuICBpZiAoY2FudmFzQ29udGV4dCkge1xuICAgIGxpbmVHZW4uY29udGV4dChjYW52YXNDb250ZXh0KTtcbiAgICBidWlsZGVyLnBhdGhNZXRob2RzID0gbGluZUdlbjtcbiAgfSBlbHNlIHtcbiAgICBidWlsZGVyLmF0dHJzID0ge1xuICAgICAgZDogbGluZUdlbihkYXRhKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gYnVpbGRlcjtcbn07XG5cbnZhciBhcmNCdWlsZGVyID0gZnVuY3Rpb24gYXJjQnVpbGRlcihfcmVmMikge1xuICB2YXIgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBjYW52YXNDb250ZXh0ID0gX3JlZjIuY2FudmFzQ29udGV4dCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzSUQgPSBfcmVmMi5jbGFzc0lEO1xuXG5cbiAgdmFyIGJ1aWxkZXIgPSB7XG4gICAgdHlwZTogJ3BhdGgnLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNsYXNzSUQ6IGNsYXNzSUQsXG4gICAgZGF0YTogZGF0YVxuICB9O1xuXG4gIHZhciBhcmNTaGFwZSA9IGFyYygpLmlubmVyUmFkaXVzKGRhdGEuaW5uZXJSYWRpdXMgfHwgMCkub3V0ZXJSYWRpdXMoZGF0YS5vdXRlclJhZGl1cyB8fCBkYXRhLnJhZGl1cyB8fCAyKS5zdGFydEFuZ2xlKGRhdGEuc3RhcnRBbmdsZSB8fCAwKS5lbmRBbmdsZShkYXRhLmVuZEFuZ2xlIHx8IDIgKiBNYXRoLlBJKTtcblxuICBpZiAoY2FudmFzQ29udGV4dCkge1xuICAgIGFyY1NoYXBlLmNvbnRleHQoY2FudmFzQ29udGV4dCk7XG4gICAgYnVpbGRlci5wYXRoTWV0aG9kcyA9IGxpbmVHZW47XG4gIH0gZWxzZSB7XG5cbiAgICBidWlsZGVyLmF0dHJzID0ge1xuICAgICAgZDogYXJjU2hhcGUoKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gYnVpbGRlcjtcbn07XG5cbnZhciBub3RlVmVydGljYWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgYmJveCA9IF9yZWYuYmJveCxcbiAgICAgIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuXG4gIGFsaWduID0gbGVmdFJpZ2h0RHluYW1pYyhhbGlnbiwgb2Zmc2V0LnkpO1xuXG4gIGlmIChhbGlnbiA9PT0gXCJ0b3BcIikge1xuICAgIHkgLT0gYmJveC5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwibWlkZGxlXCIpIHtcbiAgICB5IC09IGJib3guaGVpZ2h0IC8gMjtcbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4LCB5XSwgW3gsIHkgKyBiYm94LmhlaWdodF1dO1xuICByZXR1cm4geyBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6IFwibm90ZS1saW5lXCIgfSldIH07XG59KTtcblxudmFyIG5vdGVIb3Jpem9udGFsID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBfcmVmJHggPSBfcmVmLngsXG4gICAgICB4ID0gX3JlZiR4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR4LFxuICAgICAgX3JlZiR5ID0gX3JlZi55LFxuICAgICAgeSA9IF9yZWYkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeSxcbiAgICAgIG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgYmJveCA9IF9yZWYuYmJveDtcblxuICBhbGlnbiA9IHRvcEJvdHRvbUR5bmFtaWMoYWxpZ24sIG9mZnNldC54KTtcblxuICBpZiAoYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgIHggLT0gYmJveC53aWR0aDtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHggLT0gYmJveC53aWR0aCAvIDI7XG4gIH1cblxuICB2YXIgZGF0YSA9IFtbeCwgeV0sIFt4ICsgYmJveC53aWR0aCwgeV1dO1xuICByZXR1cm4geyBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6IFwibm90ZS1saW5lXCIgfSldIH07XG59KTtcblxudmFyIGxpbmVTZXR1cCA9IGZ1bmN0aW9uIGxpbmVTZXR1cChfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgc3ViamVjdFR5cGUgPSBfcmVmLnN1YmplY3RUeXBlO1xuXG4gIHZhciBhbm5vdGF0aW9uID0gdHlwZS5hbm5vdGF0aW9uO1xuICB2YXIgb2Zmc2V0ID0gYW5ub3RhdGlvbi5wb3NpdGlvbjtcblxuICB2YXIgeDEgPSBhbm5vdGF0aW9uLnggLSBvZmZzZXQueCxcbiAgICAgIHgyID0geDEgKyBhbm5vdGF0aW9uLmR4LFxuICAgICAgeTEgPSBhbm5vdGF0aW9uLnkgLSBvZmZzZXQueSxcbiAgICAgIHkyID0geTEgKyBhbm5vdGF0aW9uLmR5O1xuXG4gIHZhciBzdWJqZWN0RGF0YSA9IGFubm90YXRpb24uc3ViamVjdDtcblxuICBpZiAoc3ViamVjdFR5cGUgPT09IFwiY2lyY2xlXCIgJiYgKHN1YmplY3REYXRhLm91dGVyUmFkaXVzIHx8IHN1YmplY3REYXRhLnJhZGl1cykpIHtcbiAgICB2YXIgaCA9IE1hdGguc3FydCgoeDEgLSB4MikgKiAoeDEgLSB4MikgKyAoeTEgLSB5MikgKiAoeTEgLSB5MikpO1xuICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbigteTIgLyBoKTtcbiAgICB2YXIgciA9IHN1YmplY3REYXRhLm91dGVyUmFkaXVzIHx8IHN1YmplY3REYXRhLnJhZGl1cyArIChzdWJqZWN0RGF0YS5yYWRpdXNQYWRkaW5nIHx8IDApO1xuXG4gICAgeDEgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkgKiByKSAqICh4MiA8IDAgPyAtMSA6IDEpO1xuICAgIHkxID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpICogcikgKiAoeTIgPCAwID8gLTEgOiAxKTtcbiAgfVxuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICB2YXIgd2lkdGggPSBzdWJqZWN0RGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3ViamVjdERhdGEuaGVpZ2h0O1xuXG5cbiAgICBpZiAod2lkdGggPiAwICYmIGFubm90YXRpb24uZHggPiAwIHx8IHdpZHRoIDwgMCAmJiBhbm5vdGF0aW9uLmR4IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKHdpZHRoKSA+IE1hdGguYWJzKGFubm90YXRpb24uZHgpKSB4MSA9IHdpZHRoIC8gMjtlbHNlIHgxID0gd2lkdGg7XG4gICAgfVxuICAgIGlmIChoZWlnaHQgPiAwICYmIGFubm90YXRpb24uZHkgPiAwIHx8IGhlaWdodCA8IDAgJiYgYW5ub3RhdGlvbi5keSA8IDApIHtcbiAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keSkpIHkxID0gaGVpZ2h0IC8gMjtlbHNlIHkxID0gaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoeDEgPT09IHdpZHRoIC8gMiAmJiB5MSA9PT0gaGVpZ2h0IC8gMikge1xuICAgICAgeDEgPSB4Mjt5MSA9IHkyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbW3gxLCB5MV0sIFt4MiwgeTJdXTtcbn07XG5cbnZhciBjb25uZWN0b3JMaW5lID0gKGZ1bmN0aW9uIChjb25uZWN0b3JEYXRhKSB7XG4gIHZhciBkYXRhID0gbGluZVNldHVwKGNvbm5lY3RvckRhdGEpO1xuICByZXR1cm4geyBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6IFwiY29ubmVjdG9yXCIgfSldIH07XG59KTtcblxudmFyIGNvbm5lY3RvckVsYm93ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgc3ViamVjdFR5cGUgPSBfcmVmLnN1YmplY3RUeXBlO1xuXG5cbiAgdmFyIGFubm90YXRpb24gPSB0eXBlLmFubm90YXRpb247XG4gIHZhciBvZmZzZXQgPSBhbm5vdGF0aW9uLnBvc2l0aW9uO1xuXG4gIHZhciB4MSA9IGFubm90YXRpb24ueCAtIG9mZnNldC54LFxuICAgICAgeDIgPSB4MSArIGFubm90YXRpb24uZHgsXG4gICAgICB5MSA9IGFubm90YXRpb24ueSAtIG9mZnNldC55LFxuICAgICAgeTIgPSB5MSArIGFubm90YXRpb24uZHk7XG5cbiAgdmFyIHN1YmplY3REYXRhID0gYW5ub3RhdGlvbi5zdWJqZWN0O1xuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICB2YXIgd2lkdGggPSBzdWJqZWN0RGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3ViamVjdERhdGEuaGVpZ2h0O1xuXG5cbiAgICBpZiAod2lkdGggPiAwICYmIGFubm90YXRpb24uZHggPiAwIHx8IHdpZHRoIDwgMCAmJiBhbm5vdGF0aW9uLmR4IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKHdpZHRoKSA+IE1hdGguYWJzKGFubm90YXRpb24uZHgpKSB4MSA9IHdpZHRoIC8gMjtlbHNlIHgxID0gd2lkdGg7XG4gICAgfVxuICAgIGlmIChoZWlnaHQgPiAwICYmIGFubm90YXRpb24uZHkgPiAwIHx8IGhlaWdodCA8IDAgJiYgYW5ub3RhdGlvbi5keSA8IDApIHtcbiAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keSkpIHkxID0gaGVpZ2h0IC8gMjtlbHNlIHkxID0gaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoeDEgPT09IHdpZHRoIC8gMiAmJiB5MSA9PT0gaGVpZ2h0IC8gMikge1xuICAgICAgeDEgPSB4Mjt5MSA9IHkyO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4MSwgeTFdLCBbeDIsIHkyXV07XG5cbiAgdmFyIGRpZmZZID0geTIgLSB5MTtcbiAgdmFyIGRpZmZYID0geDIgLSB4MTtcbiAgdmFyIHhlID0geDI7XG4gIHZhciB5ZSA9IHkyO1xuICB2YXIgb3Bwb3NpdGUgPSB5MiA8IHkxICYmIHgyID4geDEgfHwgeDIgPCB4MSAmJiB5MiA+IHkxID8gLTEgOiAxO1xuXG4gIGlmIChNYXRoLmFicyhkaWZmWCkgPCBNYXRoLmFicyhkaWZmWSkpIHtcbiAgICB4ZSA9IHgyO1xuICAgIHllID0geTEgKyBkaWZmWCAqIG9wcG9zaXRlO1xuICB9IGVsc2Uge1xuICAgIHllID0geTI7XG4gICAgeGUgPSB4MSArIGRpZmZZICogb3Bwb3NpdGU7XG4gIH1cblxuICBpZiAoc3ViamVjdFR5cGUgPT09IFwiY2lyY2xlXCIgJiYgKHN1YmplY3REYXRhLm91dGVyUmFkaXVzIHx8IHN1YmplY3REYXRhLnJhZGl1cykpIHtcbiAgICB2YXIgciA9IChzdWJqZWN0RGF0YS5vdXRlclJhZGl1cyB8fCBzdWJqZWN0RGF0YS5yYWRpdXMpICsgKHN1YmplY3REYXRhLnJhZGl1c1BhZGRpbmcgfHwgMCk7XG4gICAgdmFyIGxlbmd0aCA9IHIgLyBNYXRoLnNxcnQoMik7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGlmZlgpID4gbGVuZ3RoICYmIE1hdGguYWJzKGRpZmZZKSA+IGxlbmd0aCkge1xuICAgICAgeDEgPSBsZW5ndGggKiAoeDIgPCAwID8gLTEgOiAxKTtcbiAgICAgIHkxID0gbGVuZ3RoICogKHkyIDwgMCA/IC0xIDogMSk7XG4gICAgICBkYXRhID0gW1t4MSwgeTFdLCBbeGUsIHllXSwgW3gyLCB5Ml1dO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGlmZlgpID4gTWF0aC5hYnMoZGlmZlkpKSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oLXkyIC8gcik7XG4gICAgICB4MSA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSAqIHIpICogKHgyIDwgMCA/IC0xIDogMSk7XG4gICAgICBkYXRhID0gW1t4MSwgeTJdLCBbeDIsIHkyXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfYW5nbGUgPSBNYXRoLmFjb3MoeDIgLyByKTtcbiAgICAgIHkxID0gTWF0aC5hYnMoTWF0aC5zaW4oX2FuZ2xlKSAqIHIpICogKHkyIDwgMCA/IC0xIDogMSk7XG4gICAgICBkYXRhID0gW1t4MiwgeTFdLCBbeDIsIHkyXV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBbW3gxLCB5MV0sIFt4ZSwgeWVdLCBbeDIsIHkyXV07XG4gIH1cblxuICByZXR1cm4geyBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6IFwiY29ubmVjdG9yXCIgfSldIH07XG59KTtcblxudmFyIGNvbm5lY3RvckN1cnZlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgY29ubmVjdG9yRGF0YSA9IF9yZWYuY29ubmVjdG9yRGF0YSxcbiAgICAgIHN1YmplY3RUeXBlID0gX3JlZi5zdWJqZWN0VHlwZTtcblxuXG4gIGlmICghY29ubmVjdG9yRGF0YSkge1xuICAgIGNvbm5lY3RvckRhdGEgPSB7fTtcbiAgfVxuICBpZiAoIWNvbm5lY3RvckRhdGEucG9pbnRzIHx8IHR5cGVvZiBjb25uZWN0b3JEYXRhLnBvaW50cyA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvbm5lY3RvckRhdGEucG9pbnRzID0gY3JlYXRlUG9pbnRzKHR5cGUuYW5ub3RhdGlvbi5vZmZzZXQsIGNvbm5lY3RvckRhdGEucG9pbnRzKTtcbiAgfVxuICBpZiAoIWNvbm5lY3RvckRhdGEuY3VydmUpIHtcbiAgICBjb25uZWN0b3JEYXRhLmN1cnZlID0gY3VydmVDYXRtdWxsUm9tO1xuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcblxuICBpZiAodHlwZS5lZGl0TW9kZSkge1xuICAgIHZhciBjSGFuZGxlcyA9IGNvbm5lY3RvckRhdGEucG9pbnRzLm1hcChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwb2ludEhhbmRsZSh7IGN4OiBjWzBdLCBjeTogY1sxXSB9KSwgeyBpbmRleDogaSB9KTtcbiAgICB9KTtcblxuICAgIHZhciB1cGRhdGVQb2ludCA9IGZ1bmN0aW9uIHVwZGF0ZVBvaW50KGluZGV4KSB7XG4gICAgICBjb25uZWN0b3JEYXRhLnBvaW50c1tpbmRleF1bMF0gKz0gZXZlbnQuZHg7XG4gICAgICBjb25uZWN0b3JEYXRhLnBvaW50c1tpbmRleF1bMV0gKz0gZXZlbnQuZHk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICBoYW5kbGVzID0gdHlwZS5tYXBIYW5kbGVzKGNIYW5kbGVzLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoLm1vdmUsIHsgZHJhZzogdXBkYXRlUG9pbnQuYmluZCh0eXBlLCBoLmluZGV4KSB9KTtcbiAgICB9KSk7XG4gIH1cblxuICB2YXIgZGF0YSA9IGxpbmVTZXR1cCh7IHR5cGU6IHR5cGUsIHN1YmplY3RUeXBlOiBzdWJqZWN0VHlwZSB9KTtcbiAgZGF0YSA9IFtkYXRhWzBdXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY29ubmVjdG9yRGF0YS5wb2ludHMpLCBbZGF0YVsxXV0pO1xuICB2YXIgY29tcG9uZW50cyA9IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGN1cnZlOiBjb25uZWN0b3JEYXRhLmN1cnZlLCBjbGFzc05hbWU6IFwiY29ubmVjdG9yXCIgfSldO1xuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIGhhbmRsZXM6IGhhbmRsZXMgfTtcbn0pO1xuXG52YXIgY3JlYXRlUG9pbnRzID0gZnVuY3Rpb24gY3JlYXRlUG9pbnRzKG9mZnNldCkge1xuICB2YXIgYW5jaG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjtcblxuICB2YXIgZGlmZiA9IHsgeDogb2Zmc2V0LnggLyAoYW5jaG9ycyArIDEpLCB5OiBvZmZzZXQueSAvIChhbmNob3JzICsgMSkgfTtcbiAgdmFyIHAgPSBbXTtcblxuICB2YXIgaSA9IDE7XG4gIGZvciAoOyBpIDw9IGFuY2hvcnM7IGkrKykge1xuICAgIHAucHVzaChbZGlmZi54ICogaSArIGkgJSAyICogMjAsIGRpZmYueSAqIGkgLSBpICUgMiAqIDIwXSk7XG4gIH1cbiAgcmV0dXJuIHA7XG59O1xuXG52YXIgY29ubmVjdG9yQXJyb3cgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFubm90YXRpb24gPSBfcmVmLmFubm90YXRpb24sXG4gICAgICBzdGFydCA9IF9yZWYuc3RhcnQsXG4gICAgICBlbmQgPSBfcmVmLmVuZCxcbiAgICAgIF9yZWYkc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgc2NhbGUgPSBfcmVmJHNjYWxlID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRzY2FsZTtcblxuICB2YXIgb2Zmc2V0ID0gYW5ub3RhdGlvbi5wb3NpdGlvbjtcbiAgaWYgKCFzdGFydCkge1xuICAgIHN0YXJ0ID0gW2Fubm90YXRpb24uZHgsIGFubm90YXRpb24uZHldO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gWy1lbmRbMF0gKyBzdGFydFswXSwgLWVuZFsxXSArIHN0YXJ0WzFdXTtcbiAgfVxuICBpZiAoIWVuZCkge1xuICAgIGVuZCA9IFthbm5vdGF0aW9uLnggLSBvZmZzZXQueCwgYW5ub3RhdGlvbi55IC0gb2Zmc2V0LnldO1xuICB9XG5cbiAgdmFyIHgxID0gZW5kWzBdLFxuICAgICAgeTEgPSBlbmRbMV07XG5cbiAgdmFyIGR4ID0gc3RhcnRbMF07XG4gIHZhciBkeSA9IHN0YXJ0WzFdO1xuXG4gIHZhciBzaXplID0gMTAgKiBzY2FsZTtcbiAgdmFyIGFuZ2xlT2Zmc2V0ID0gMTYgLyAxODAgKiBNYXRoLlBJO1xuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oZHkgLyBkeCk7XG5cbiAgaWYgKGR4IDwgMCkge1xuICAgIGFuZ2xlICs9IE1hdGguUEk7XG4gIH1cblxuICB2YXIgZGF0YSA9IFtbeDEsIHkxXSwgW01hdGguY29zKGFuZ2xlICsgYW5nbGVPZmZzZXQpICogc2l6ZSArIHgxLCBNYXRoLnNpbihhbmdsZSArIGFuZ2xlT2Zmc2V0KSAqIHNpemUgKyB5MV0sIFtNYXRoLmNvcyhhbmdsZSAtIGFuZ2xlT2Zmc2V0KSAqIHNpemUgKyB4MSwgTWF0aC5zaW4oYW5nbGUgLSBhbmdsZU9mZnNldCkgKiBzaXplICsgeTFdLCBbeDEsIHkxXV07XG5cbiAgLy9UT0RPIGFkZCBpbiByZXZlcnNlXG4gIC8vIGlmIChjYW52YXNDb250ZXh0LmFycm93UmV2ZXJzZSl7XG4gIC8vICAgZGF0YSA9IFtbeDEsIHkxXSxcbiAgLy8gICBbTWF0aC5jb3MoYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZSwgTWF0aC5zaW4oYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZV0sXG4gIC8vICAgW01hdGguY29zKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemUsIE1hdGguc2luKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemVdLFxuICAvLyAgIFt4MSwgeTFdXG4gIC8vICAgXVxuICAvLyB9IGVsc2Uge1xuICAvLyAgIGRhdGEgPSBbW3gxLCB5MV0sXG4gIC8vICAgW01hdGguY29zKGFuZ2xlICsgYW5nbGVPZmZzZXQpKnNpemUsIE1hdGguc2luKGFuZ2xlICsgYW5nbGVPZmZzZXQpKnNpemVdLFxuICAvLyAgIFtNYXRoLmNvcyhhbmdsZSAtIGFuZ2xlT2Zmc2V0KSpzaXplLCBNYXRoLnNpbihhbmdsZSAtIGFuZ2xlT2Zmc2V0KSpzaXplXSxcbiAgLy8gICBbeDEsIHkxXVxuICAvLyAgIF1cbiAgLy8gfVxuXG4gIHJldHVybiB7XG4gICAgY29tcG9uZW50czogW2xpbmVCdWlsZGVyKHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBjbGFzc05hbWU6IFwiY29ubmVjdG9yLWVuZCBjb25uZWN0b3ItYXJyb3dcIixcbiAgICAgIGNsYXNzSUQ6IFwiY29ubmVjdG9yLWVuZFwiXG4gICAgfSldXG4gIH07XG59KTtcblxudmFyIGNvbm5lY3RvckRvdCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbGluZSQkMSA9IF9yZWYubGluZSxcbiAgICAgIF9yZWYkc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgc2NhbGUgPSBfcmVmJHNjYWxlID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRzY2FsZTtcblxuICB2YXIgZG90ID0gYXJjQnVpbGRlcih7XG4gICAgY2xhc3NOYW1lOiBcImNvbm5lY3Rvci1lbmQgY29ubmVjdG9yLWRvdFwiLFxuICAgIGNsYXNzSUQ6IFwiY29ubmVjdG9yLWVuZFwiLFxuICAgIGRhdGE6IHsgcmFkaXVzOiAzICogTWF0aC5zcXJ0KHNjYWxlKSB9XG4gIH0pO1xuICBkb3QuYXR0cnMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBsaW5lJCQxLmRhdGFbMF1bMF0gKyBcIiwgXCIgKyBsaW5lJCQxLmRhdGFbMF1bMV0gKyBcIilcIjtcblxuICByZXR1cm4geyBjb21wb25lbnRzOiBbZG90XSB9O1xufSk7XG5cbnZhciBzdWJqZWN0Q2lyY2xlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdWJqZWN0RGF0YSA9IF9yZWYuc3ViamVjdERhdGEsXG4gICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gIGlmICghc3ViamVjdERhdGEucmFkaXVzICYmICFzdWJqZWN0RGF0YS5vdXRlclJhZGl1cykge1xuICAgIHN1YmplY3REYXRhLnJhZGl1cyA9IDIwO1xuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcbiAgdmFyIGMgPSBhcmNCdWlsZGVyKHsgZGF0YTogc3ViamVjdERhdGEsIGNsYXNzTmFtZTogXCJzdWJqZWN0XCIgfSk7XG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIGggPSBjaXJjbGVIYW5kbGVzKHtcbiAgICAgIHIxOiBjLmRhdGEub3V0ZXJSYWRpdXMgfHwgYy5kYXRhLnJhZGl1cyxcbiAgICAgIHIyOiBjLmRhdGEuaW5uZXJSYWRpdXMsXG4gICAgICBwYWRkaW5nOiBzdWJqZWN0RGF0YS5yYWRpdXNQYWRkaW5nXG4gICAgfSk7XG5cbiAgICB2YXIgdXBkYXRlUmFkaXVzID0gZnVuY3Rpb24gdXBkYXRlUmFkaXVzKGF0dHIpIHtcbiAgICAgIHZhciByID0gc3ViamVjdERhdGFbYXR0cl0gKyBldmVudC5keCAqIE1hdGguc3FydCgyKTtcbiAgICAgIHN1YmplY3REYXRhW2F0dHJdID0gcjtcbiAgICAgIHR5cGUucmVkcmF3U3ViamVjdCgpO1xuICAgICAgdHlwZS5yZWRyYXdDb25uZWN0b3IoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNIYW5kbGVzID0gW19leHRlbmRzKHt9LCBoLnIxLCB7XG4gICAgICBkcmFnOiB1cGRhdGVSYWRpdXMuYmluZCh0eXBlLCBzdWJqZWN0RGF0YS5vdXRlclJhZGl1cyAhPT0gdW5kZWZpbmVkID8gXCJvdXRlclJhZGl1c1wiIDogXCJyYWRpdXNcIilcbiAgICB9KV07XG5cbiAgICBpZiAoc3ViamVjdERhdGEuaW5uZXJSYWRpdXMpIHtcbiAgICAgIGNIYW5kbGVzLnB1c2goX2V4dGVuZHMoe30sIGgucjIsIHsgZHJhZzogdXBkYXRlUmFkaXVzLmJpbmQodHlwZSwgXCJpbm5lclJhZGl1c1wiKSB9KSk7XG4gICAgfVxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMoY0hhbmRsZXMpO1xuICB9XG5cbiAgYy5hdHRyc1tcImZpbGwtb3BhY2l0eVwiXSA9IDA7XG5cbiAgcmV0dXJuIHsgY29tcG9uZW50czogW2NdLCBoYW5kbGVzOiBoYW5kbGVzIH07XG59KTtcblxudmFyIHN1YmplY3RSZWN0ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdWJqZWN0RGF0YSA9IF9yZWYuc3ViamVjdERhdGEsXG4gICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gIGlmICghc3ViamVjdERhdGEud2lkdGgpIHtcbiAgICBzdWJqZWN0RGF0YS53aWR0aCA9IDEwMDtcbiAgfVxuICBpZiAoIXN1YmplY3REYXRhLmhlaWdodCkge1xuICAgIHN1YmplY3REYXRhLmhlaWdodCA9IDEwMDtcbiAgfVxuXG4gIHZhciBoYW5kbGVzID0gW107XG4gIHZhciB3aWR0aCA9IHN1YmplY3REYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gc3ViamVjdERhdGEuaGVpZ2h0O1xuXG5cbiAgdmFyIGRhdGEgPSBbWzAsIDBdLCBbd2lkdGgsIDBdLCBbd2lkdGgsIGhlaWdodF0sIFswLCBoZWlnaHRdLCBbMCwgMF1dO1xuICB2YXIgcmVjdCA9IGxpbmVCdWlsZGVyKHsgZGF0YTogZGF0YSwgY2xhc3NOYW1lOiBcInN1YmplY3RcIiB9KTtcblxuICBpZiAodHlwZS5lZGl0TW9kZSkge1xuICAgIHZhciB1cGRhdGVXaWR0aCA9IGZ1bmN0aW9uIHVwZGF0ZVdpZHRoKCkge1xuICAgICAgc3ViamVjdERhdGEud2lkdGggPSBldmVudC54O1xuICAgICAgdHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlSGVpZ2h0ID0gZnVuY3Rpb24gdXBkYXRlSGVpZ2h0KCkge1xuICAgICAgc3ViamVjdERhdGEuaGVpZ2h0ID0gZXZlbnQueTtcbiAgICAgIHR5cGUucmVkcmF3U3ViamVjdCgpO1xuICAgICAgdHlwZS5yZWRyYXdDb25uZWN0b3IoKTtcbiAgICB9O1xuXG4gICAgdmFyIHJIYW5kbGVzID0gW3sgeDogd2lkdGgsIHk6IGhlaWdodCAvIDIsIGRyYWc6IHVwZGF0ZVdpZHRoLmJpbmQodHlwZSkgfSwgeyB4OiB3aWR0aCAvIDIsIHk6IGhlaWdodCwgZHJhZzogdXBkYXRlSGVpZ2h0LmJpbmQodHlwZSkgfV07XG5cbiAgICBoYW5kbGVzID0gdHlwZS5tYXBIYW5kbGVzKHJIYW5kbGVzKTtcbiAgfVxuICByZWN0LmF0dHJzW1wiZmlsbC1vcGFjaXR5XCJdID0gMC4xO1xuICByZXR1cm4geyBjb21wb25lbnRzOiBbcmVjdF0sIGhhbmRsZXM6IGhhbmRsZXMgfTtcbn0pO1xuXG52YXIgc3ViamVjdFRocmVzaG9sZCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc3ViamVjdERhdGEgPSBfcmVmLnN1YmplY3REYXRhLFxuICAgICAgdHlwZSA9IF9yZWYudHlwZTtcblxuICB2YXIgb2Zmc2V0ID0gdHlwZS5hbm5vdGF0aW9uLnBvc2l0aW9uO1xuXG4gIHZhciB4MSA9IChzdWJqZWN0RGF0YS54MSAhPT0gdW5kZWZpbmVkID8gc3ViamVjdERhdGEueDEgOiBvZmZzZXQueCkgLSBvZmZzZXQueCxcbiAgICAgIHgyID0gKHN1YmplY3REYXRhLngyICE9PSB1bmRlZmluZWQgPyBzdWJqZWN0RGF0YS54MiA6IG9mZnNldC54KSAtIG9mZnNldC54LFxuICAgICAgeTEgPSAoc3ViamVjdERhdGEueTEgIT09IHVuZGVmaW5lZCA/IHN1YmplY3REYXRhLnkxIDogb2Zmc2V0LnkpIC0gb2Zmc2V0LnksXG4gICAgICB5MiA9IChzdWJqZWN0RGF0YS55MiAhPT0gdW5kZWZpbmVkID8gc3ViamVjdERhdGEueTIgOiBvZmZzZXQueSkgLSBvZmZzZXQueTtcblxuICB2YXIgZGF0YSA9IFtbeDEsIHkxXSwgW3gyLCB5Ml1dO1xuICByZXR1cm4geyBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6ICdzdWJqZWN0JyB9KV0gfTtcbn0pO1xuXG52YXIgc3ViamVjdEJhZGdlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmJHN1YmplY3REYXRhID0gX3JlZi5zdWJqZWN0RGF0YSxcbiAgICAgIHN1YmplY3REYXRhID0gX3JlZiRzdWJqZWN0RGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJHN1YmplY3REYXRhLFxuICAgICAgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJHR5cGU7XG4gIHZhciBhbm5vdGF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICB2YXIgdHlwZVNldHRpbmdzID0gdHlwZS50eXBlU2V0dGluZ3MgJiYgdHlwZS50eXBlU2V0dGluZ3Muc3ViamVjdDtcblxuICBpZiAoIXN1YmplY3REYXRhLnJhZGl1cykge1xuICAgIGlmICh0eXBlU2V0dGluZ3MgJiYgdHlwZVNldHRpbmdzLnJhZGl1cykge1xuICAgICAgc3ViamVjdERhdGEucmFkaXVzID0gdHlwZVNldHRpbmdzLnJhZGl1cztcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViamVjdERhdGEucmFkaXVzID0gMTQ7XG4gICAgfVxuICB9XG4gIGlmICghc3ViamVjdERhdGEueCkge1xuICAgIGlmICh0eXBlU2V0dGluZ3MgJiYgdHlwZVNldHRpbmdzLngpIHtcbiAgICAgIHN1YmplY3REYXRhLnggPSB0eXBlU2V0dGluZ3MueDtcbiAgICB9XG4gIH1cbiAgaWYgKCFzdWJqZWN0RGF0YS55KSB7XG4gICAgaWYgKHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MueSkge1xuICAgICAgc3ViamVjdERhdGEueSA9IHR5cGVTZXR0aW5ncy55O1xuICAgIH1cbiAgfVxuXG4gIHZhciBoYW5kbGVzID0gW107XG4gIHZhciBjb21wb25lbnRzID0gW107XG4gIHZhciByYWRpdXMgPSBzdWJqZWN0RGF0YS5yYWRpdXM7XG4gIHZhciBpbm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNztcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgdmFyIG5vdENvcm5lck9mZnNldCA9IE1hdGguc3FydCgyKSAqIHJhZGl1cztcbiAgdmFyIHBsYWNlbWVudCA9IHtcbiAgICB4bGVmdGNvcm5lcjogLXJhZGl1cyxcbiAgICB4cmlnaHRjb3JuZXI6IHJhZGl1cyxcbiAgICB5dG9wY29ybmVyOiAtcmFkaXVzLFxuICAgIHlib3R0b21jb3JuZXI6IHJhZGl1cyxcbiAgICB4bGVmdDogLW5vdENvcm5lck9mZnNldCxcbiAgICB4cmlnaHQ6IG5vdENvcm5lck9mZnNldCxcbiAgICB5dG9wOiAtbm90Q29ybmVyT2Zmc2V0LFxuICAgIHlib3R0b206IG5vdENvcm5lck9mZnNldFxuICB9O1xuXG4gIGlmIChzdWJqZWN0RGF0YS54ICYmICFzdWJqZWN0RGF0YS55KSB7XG4gICAgeCA9IHBsYWNlbWVudFtcInhcIiArIHN1YmplY3REYXRhLnhdO1xuICB9IGVsc2UgaWYgKHN1YmplY3REYXRhLnkgJiYgIXN1YmplY3REYXRhLngpIHtcbiAgICB5ID0gcGxhY2VtZW50W1wieVwiICsgc3ViamVjdERhdGEueV07XG4gIH0gZWxzZSBpZiAoc3ViamVjdERhdGEueCAmJiBzdWJqZWN0RGF0YS55KSB7XG4gICAgeCA9IHBsYWNlbWVudFtcInhcIiArIHN1YmplY3REYXRhLnggKyBcImNvcm5lclwiXTtcbiAgICB5ID0gcGxhY2VtZW50W1wieVwiICsgc3ViamVjdERhdGEueSArIFwiY29ybmVyXCJdO1xuICB9XG5cbiAgdmFyIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBcIilcIjtcbiAgdmFyIGNpcmNsZWJnID0gYXJjQnVpbGRlcih7IGNsYXNzTmFtZTogXCJzdWJqZWN0XCIsIGRhdGE6IHsgcmFkaXVzOiByYWRpdXMgfSB9KTtcbiAgY2lyY2xlYmcuYXR0cnMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICBjaXJjbGViZy5hdHRycy5maWxsID0gYW5ub3RhdGlvbi5jb2xvcjtcbiAgY2lyY2xlYmcuYXR0cnNbXCJzdHJva2UtbGluZWNhcFwiXSA9IFwicm91bmRcIjtcbiAgY2lyY2xlYmcuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gPSBcIjNweFwiO1xuXG4gIHZhciBjaXJjbGUgPSBhcmNCdWlsZGVyKHtcbiAgICBjbGFzc05hbWU6IFwic3ViamVjdC1yaW5nXCIsXG4gICAgZGF0YTogeyBvdXRlclJhZGl1czogcmFkaXVzLCBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMgfVxuICB9KTtcblxuICBjaXJjbGUuYXR0cnMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAvLyBjaXJjbGUuYXR0cnMuZmlsbCA9IGFubm90YXRpb24uY29sb3JcbiAgY2lyY2xlLmF0dHJzW1wic3Ryb2tlLXdpZHRoXCJdID0gXCIzcHhcIjtcbiAgY2lyY2xlLmF0dHJzLmZpbGwgPSBcIndoaXRlXCI7XG5cbiAgdmFyIHBvaW50ZXIgPSB2b2lkIDA7XG4gIGlmICh4ICYmIHkgfHwgIXggJiYgIXkpIHtcbiAgICBwb2ludGVyID0gbGluZUJ1aWxkZXIoe1xuICAgICAgY2xhc3NOYW1lOiBcInN1YmplY3QtcG9pbnRlclwiLFxuICAgICAgZGF0YTogW1swLCAwXSwgW3ggfHwgMCwgMF0sIFswLCB5IHx8IDBdLCBbMCwgMF1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoeCB8fCB5KSB7XG4gICAgdmFyIG5vdENvcm5lclBvaW50ZXJYWSA9IGZ1bmN0aW9uIG5vdENvcm5lclBvaW50ZXJYWSh2KSB7XG4gICAgICB2YXIgc2lnbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgIHJldHVybiB2ICYmIHYgLyBNYXRoLnNxcnQoMikgLyBNYXRoLnNxcnQoMikgfHwgc2lnbiAqIHJhZGl1cyAvIE1hdGguc3FydCgyKTtcbiAgICB9O1xuXG4gICAgcG9pbnRlciA9IGxpbmVCdWlsZGVyKHtcbiAgICAgIGNsYXNzTmFtZTogXCJzdWJqZWN0LXBvaW50ZXJcIixcbiAgICAgIGRhdGE6IFtbMCwgMF0sIFtub3RDb3JuZXJQb2ludGVyWFkoeCksIG5vdENvcm5lclBvaW50ZXJYWSh5KV0sIFtub3RDb3JuZXJQb2ludGVyWFkoeCwgLTEpLCBub3RDb3JuZXJQb2ludGVyWFkoeSwgLTEpXSwgWzAsIDBdXVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBvaW50ZXIpIHtcbiAgICBwb2ludGVyLmF0dHJzLmZpbGwgPSBhbm5vdGF0aW9uLmNvbG9yO1xuICAgIHBvaW50ZXIuYXR0cnNbXCJzdHJva2UtbGluZWNhcFwiXSA9IFwicm91bmRcIjtcbiAgICBwb2ludGVyLmF0dHJzW1wic3Ryb2tlLXdpZHRoXCJdID0gXCIzcHhcIjtcbiAgICBjb21wb25lbnRzLnB1c2gocG9pbnRlcik7XG4gIH1cblxuICBpZiAodHlwZS5lZGl0TW9kZSkge1xuICAgIHZhciBkcmFnQmFkZ2UgPSBmdW5jdGlvbiBkcmFnQmFkZ2UoKSB7XG4gICAgICBzdWJqZWN0RGF0YS54ID0gZXZlbnQueCA8IC1yYWRpdXMgKiAyID8gXCJsZWZ0XCIgOiBldmVudC54ID4gcmFkaXVzICogMiA/IFwicmlnaHRcIiA6IHVuZGVmaW5lZDtcbiAgICAgIHN1YmplY3REYXRhLnkgPSBldmVudC55IDwgLXJhZGl1cyAqIDIgPyBcInRvcFwiIDogZXZlbnQueSA+IHJhZGl1cyAqIDIgPyBcImJvdHRvbVwiIDogdW5kZWZpbmVkO1xuXG4gICAgICB0eXBlLnJlZHJhd1N1YmplY3QoKTtcbiAgICB9O1xuXG4gICAgdmFyIGJIYW5kbGVzID0geyB4OiB4ICogMiwgeTogeSAqIDIsIGRyYWc6IGRyYWdCYWRnZS5iaW5kKHR5cGUpIH07XG4gICAgaWYgKCFiSGFuZGxlcy54ICYmICFiSGFuZGxlcy55KSB7XG4gICAgICBiSGFuZGxlcy55ID0gLXJhZGl1cztcbiAgICB9XG5cbiAgICBoYW5kbGVzID0gdHlwZS5tYXBIYW5kbGVzKFtiSGFuZGxlc10pO1xuICB9XG5cbiAgdmFyIHRleHQgPSB2b2lkIDA7XG4gIGlmIChzdWJqZWN0RGF0YS50ZXh0KSB7XG4gICAgdGV4dCA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgY2xhc3NOYW1lOiBcImJhZGdlLXRleHRcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIGZpbGw6IFwid2hpdGVcIixcbiAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgICAgXCJmb250LXNpemVcIjogXCIuN2VtXCIsXG4gICAgICAgIHRleHQ6IHN1YmplY3REYXRhLnRleHQsXG4gICAgICAgIFwidGV4dC1hbmNob3JcIjogXCJtaWRkbGVcIixcbiAgICAgICAgZHk6IFwiLjI1ZW1cIixcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnRzLnB1c2goY2lyY2xlYmcpO1xuICBjb21wb25lbnRzLnB1c2goY2lyY2xlKTtcbiAgY29tcG9uZW50cy5wdXNoKHRleHQpO1xuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIGhhbmRsZXM6IGhhbmRsZXMgfTtcbn0pO1xuXG4vL05vdGUgb3B0aW9uc1xuLy9Db25uZWN0b3Igb3B0aW9uc1xuLy9TdWJqZWN0IG9wdGlvbnNcbnZhciBUeXBlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUeXBlKF9yZWYpIHtcbiAgICB2YXIgYSA9IF9yZWYuYSxcbiAgICAgICAgYW5ub3RhdGlvbiA9IF9yZWYuYW5ub3RhdGlvbixcbiAgICAgICAgZWRpdE1vZGUgPSBfcmVmLmVkaXRNb2RlLFxuICAgICAgICBkaXNwYXRjaGVyID0gX3JlZi5kaXNwYXRjaGVyLFxuICAgICAgICBub3RlUGFkZGluZyA9IF9yZWYubm90ZVBhZGRpbmcsXG4gICAgICAgIGFjY2Vzc29ycyA9IF9yZWYuYWNjZXNzb3JzO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGUpO1xuXG4gICAgdGhpcy5hID0gYTtcblxuICAgIHRoaXMubm90ZSA9IGFubm90YXRpb24uZGlzYWJsZS5pbmRleE9mKFwibm90ZVwiKSA9PT0gLTEgJiYgYS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZVwiKTtcbiAgICB0aGlzLm5vdGVDb250ZW50ID0gdGhpcy5ub3RlICYmIGEuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLW5vdGUtY29udGVudFwiKTtcbiAgICB0aGlzLmNvbm5lY3RvciA9IGFubm90YXRpb24uZGlzYWJsZS5pbmRleE9mKFwiY29ubmVjdG9yXCIpID09PSAtMSAmJiBhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1jb25uZWN0b3JcIik7XG4gICAgdGhpcy5zdWJqZWN0ID0gYW5ub3RhdGlvbi5kaXNhYmxlLmluZGV4T2YoXCJzdWJqZWN0XCIpID09PSAtMSAmJiBhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1zdWJqZWN0XCIpO1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG5cbiAgICBpZiAoZGlzcGF0Y2hlcikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBhZGRIYW5kbGVycy5iaW5kKG51bGwsIGRpc3BhdGNoZXIsIGFubm90YXRpb24pO1xuICAgICAgaGFuZGxlcih7IGNvbXBvbmVudDogdGhpcy5ub3RlLCBuYW1lOiBcIm5vdGVcIiB9KTtcbiAgICAgIGhhbmRsZXIoeyBjb21wb25lbnQ6IHRoaXMuY29ubmVjdG9yLCBuYW1lOiBcImNvbm5lY3RvclwiIH0pO1xuICAgICAgaGFuZGxlcih7IGNvbXBvbmVudDogdGhpcy5zdWJqZWN0LCBuYW1lOiBcInN1YmplY3RcIiB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmFubm90YXRpb24gPSBhbm5vdGF0aW9uO1xuICAgIHRoaXMuZWRpdE1vZGUgPSBhbm5vdGF0aW9uLmVkaXRNb2RlIHx8IGVkaXRNb2RlO1xuICAgIHRoaXMubm90ZVBhZGRpbmcgPSBub3RlUGFkZGluZyAhPT0gdW5kZWZpbmVkID8gbm90ZVBhZGRpbmcgOiAzO1xuICAgIHRoaXMub2Zmc2V0Q29ybmVyWCA9IDA7XG4gICAgdGhpcy5vZmZzZXRDb3JuZXJZID0gMDtcblxuICAgIGlmIChhY2Nlc3NvcnMgJiYgYW5ub3RhdGlvbi5kYXRhKSB7XG4gICAgICB0aGlzLmluaXQoYWNjZXNzb3JzKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUeXBlLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbi54KSB7XG4gICAgICAgIHRoaXMubWFwWChhY2Nlc3NvcnMpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmFubm90YXRpb24ueSkge1xuICAgICAgICB0aGlzLm1hcFkoYWNjZXNzb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBZKGFjY2Vzc29ycykge1xuICAgICAgaWYgKGFjY2Vzc29ycy55KSB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbi55ID0gYWNjZXNzb3JzLnkodGhpcy5hbm5vdGF0aW9uLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFgoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoYWNjZXNzb3JzLngpIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uLnggPSBhY2Nlc3NvcnMueCh0aGlzLmFubm90YXRpb24uZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkaXRNb2RlKCkge1xuICAgICAgdGhpcy5hLnNlbGVjdEFsbChcImNpcmNsZS5oYW5kbGVcIikucmVtb3ZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdPblNWR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3T25TVkcoY29tcG9uZW50LCBidWlsZGVycykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJ1aWxkZXJzKSkge1xuICAgICAgICBidWlsZGVycyA9IFtidWlsZGVyc107XG4gICAgICB9XG5cbiAgICAgIGJ1aWxkZXJzLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjIudHlwZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIGF0dHJzID0gX3JlZjIuYXR0cnMsXG4gICAgICAgICAgICBoYW5kbGVzID0gX3JlZjIuaGFuZGxlcyxcbiAgICAgICAgICAgIGNsYXNzSUQgPSBfcmVmMi5jbGFzc0lEO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImhhbmRsZVwiKSB7XG4gICAgICAgICAgYWRkSGFuZGxlcyh7IGdyb3VwOiBjb21wb25lbnQsIHI6IGF0dHJzICYmIGF0dHJzLnIsIGhhbmRsZXM6IGhhbmRsZXMgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3V2l0aENsYXNzKGNvbXBvbmVudCwgW190aGlzLmFubm90YXRpb25dLCB0eXBlLCBjbGFzc05hbWUsIGNsYXNzSUQpO1xuICAgICAgICAgIHZhciBlbCA9IGNvbXBvbmVudC5zZWxlY3QodHlwZSArIFwiLlwiICsgKGNsYXNzSUQgfHwgY2xhc3NOYW1lKSk7XG4gICAgICAgICAgdmFyIGFkZEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgICAgICAgIHZhciByZW1vdmVBdHRycyA9IFtdO1xuXG4gICAgICAgICAgdmFyIGN1cnJlbnRBdHRycyA9IGVsLm5vZGUoKS5hdHRyaWJ1dGVzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gY3VycmVudEF0dHJzW2ldLm5hbWU7XG4gICAgICAgICAgICBpZiAoYWRkQXR0cnMuaW5kZXhPZihuYW1lKSA9PT0gLTEgJiYgbmFtZSAhPT0gXCJjbGFzc1wiKSByZW1vdmVBdHRycy5wdXNoKG5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZEF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICBlbC50ZXh0KGF0dHJzW2F0dHJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsLmF0dHIoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVtb3ZlQXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmF0dHIoYXR0ciwgbnVsbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vVE9ETzogaG93IHRvIGV4dGVuZCB0aGlzIHRvIGEgZHJhd09uQ2FudmFzIG1vZGU/XG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROb3RlQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb3RlQkJveCgpIHtcbiAgICAgIHJldHVybiBiYm94V2l0aG91dEhhbmRsZXModGhpcy5ub3RlLCBcIi5hbm5vdGF0aW9uLW5vdGUtY29udGVudCB0ZXh0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROb3RlQkJveE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb3RlQkJveE9mZnNldCgpIHtcbiAgICAgIHZhciBiYm94ID0gYmJveFdpdGhvdXRIYW5kbGVzKHRoaXMubm90ZSwgXCIuYW5ub3RhdGlvbi1ub3RlLWNvbnRlbnRcIik7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5ub3RlQ29udGVudC5hdHRyKFwidHJhbnNmb3JtXCIpLnNwbGl0KC9cXCh8XFwsfFxcKS9nKTtcbiAgICAgIGJib3gub2Zmc2V0Q29ybmVyWCA9IHBhcnNlRmxvYXQodHJhbnNmb3JtWzFdKSArIHRoaXMuYW5ub3RhdGlvbi5keDtcbiAgICAgIGJib3gub2Zmc2V0Q29ybmVyWSA9IHBhcnNlRmxvYXQodHJhbnNmb3JtWzJdKSArIHRoaXMuYW5ub3RhdGlvbi5keTtcbiAgICAgIGJib3gub2Zmc2V0WCA9IHRoaXMuYW5ub3RhdGlvbi5keDtcbiAgICAgIGJib3gub2Zmc2V0WSA9IHRoaXMuYW5ub3RhdGlvbi5keTtcbiAgICAgIHJldHVybiBiYm94O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3U3ViamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3U3ViamVjdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHZhciBzdWJqZWN0RGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5zdWJqZWN0O1xuICAgICAgdmFyIHR5cGUgPSBjb250ZXh0LnR5cGU7XG4gICAgICB2YXIgc3ViamVjdFBhcmFtcyA9IHsgdHlwZTogdGhpcywgc3ViamVjdERhdGE6IHN1YmplY3REYXRhIH07XG5cbiAgICAgIHZhciBzdWJqZWN0ID0ge307XG4gICAgICBpZiAodHlwZSA9PT0gXCJjaXJjbGVcIikgc3ViamVjdCA9IHN1YmplY3RDaXJjbGUoc3ViamVjdFBhcmFtcyk7ZWxzZSBpZiAodHlwZSA9PT0gXCJyZWN0XCIpIHN1YmplY3QgPSBzdWJqZWN0UmVjdChzdWJqZWN0UGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcInRocmVzaG9sZFwiKSBzdWJqZWN0ID0gc3ViamVjdFRocmVzaG9sZChzdWJqZWN0UGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcImJhZGdlXCIpIHN1YmplY3QgPSBzdWJqZWN0QmFkZ2Uoc3ViamVjdFBhcmFtcywgdGhpcy5hbm5vdGF0aW9uKTtcblxuICAgICAgdmFyIF9zdWJqZWN0ID0gc3ViamVjdCxcbiAgICAgICAgICBfc3ViamVjdCRjb21wb25lbnRzID0gX3N1YmplY3QuY29tcG9uZW50cyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX3N1YmplY3QkY29tcG9uZW50cyA9PT0gdW5kZWZpbmVkID8gW10gOiBfc3ViamVjdCRjb21wb25lbnRzLFxuICAgICAgICAgIF9zdWJqZWN0JGhhbmRsZXMgPSBfc3ViamVjdC5oYW5kbGVzLFxuICAgICAgICAgIGhhbmRsZXMgPSBfc3ViamVjdCRoYW5kbGVzID09PSB1bmRlZmluZWQgPyBbXSA6IF9zdWJqZWN0JGhhbmRsZXM7XG5cbiAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyAmJiBjLmF0dHJzICYmICFjLmF0dHJzLnN0cm9rZSkge1xuICAgICAgICAgIGMuYXR0cnMuc3Ryb2tlID0gX3RoaXMyLmFubm90YXRpb24uY29sb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSkge1xuICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQodGhpcy5tYXBIYW5kbGVzKFt7IGRyYWc6IHRoaXMuZHJhZ1N1YmplY3QuYmluZCh0aGlzKSB9XSkpO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goeyB0eXBlOiBcImhhbmRsZVwiLCBoYW5kbGVzOiBoYW5kbGVzIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0Nvbm5lY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q29ubmVjdG9yKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdmFyIGNvbm5lY3RvckRhdGEgPSB0aGlzLmFubm90YXRpb24uY29ubmVjdG9yO1xuICAgICAgdmFyIHR5cGUgPSBjb25uZWN0b3JEYXRhLnR5cGUgfHwgY29udGV4dC50eXBlO1xuICAgICAgdmFyIGNvbm5lY3RvclBhcmFtcyA9IHsgdHlwZTogdGhpcywgY29ubmVjdG9yRGF0YTogY29ubmVjdG9yRGF0YSB9O1xuICAgICAgY29ubmVjdG9yUGFyYW1zLnN1YmplY3RUeXBlID0gdGhpcy50eXBlU2V0dGluZ3MgJiYgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCAmJiB0aGlzLnR5cGVTZXR0aW5ncy5zdWJqZWN0LnR5cGU7XG5cbiAgICAgIHZhciBjb25uZWN0b3IgPSB7fTtcbiAgICAgIGlmICh0eXBlID09PSBcImN1cnZlXCIpIGNvbm5lY3RvciA9IGNvbm5lY3RvckN1cnZlKGNvbm5lY3RvclBhcmFtcyk7ZWxzZSBpZiAodHlwZSA9PT0gXCJlbGJvd1wiKSBjb25uZWN0b3IgPSBjb25uZWN0b3JFbGJvdyhjb25uZWN0b3JQYXJhbXMpO2Vsc2UgY29ubmVjdG9yID0gY29ubmVjdG9yTGluZShjb25uZWN0b3JQYXJhbXMpO1xuICAgICAgdmFyIF9jb25uZWN0b3IgPSBjb25uZWN0b3IsXG4gICAgICAgICAgX2Nvbm5lY3RvciRjb21wb25lbnRzID0gX2Nvbm5lY3Rvci5jb21wb25lbnRzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfY29ubmVjdG9yJGNvbXBvbmVudHMgPT09IHVuZGVmaW5lZCA/IFtdIDogX2Nvbm5lY3RvciRjb21wb25lbnRzLFxuICAgICAgICAgIF9jb25uZWN0b3IkaGFuZGxlcyA9IF9jb25uZWN0b3IuaGFuZGxlcyxcbiAgICAgICAgICBoYW5kbGVzID0gX2Nvbm5lY3RvciRoYW5kbGVzID09PSB1bmRlZmluZWQgPyBbXSA6IF9jb25uZWN0b3IkaGFuZGxlcztcblxuICAgICAgdmFyIGxpbmUkJDEgPSBjb21wb25lbnRzWzBdO1xuICAgICAgLy9UT0RPOiBnZW5lcmljaXplIHRoaXMgaW50byBmaWxsIHQvZiBzdHJva2UgdC9mXG4gICAgICBpZiAobGluZSQkMSkge1xuICAgICAgICBsaW5lJCQxLmF0dHJzLnN0cm9rZSA9IHRoaXMuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgICAgbGluZSQkMS5hdHRycy5maWxsID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgICB2YXIgZW5kVHlwZSA9IGNvbm5lY3RvckRhdGEuZW5kIHx8IGNvbnRleHQuZW5kO1xuICAgICAgdmFyIGVuZCA9IHt9O1xuICAgICAgaWYgKGVuZFR5cGUgPT09IFwiYXJyb3dcIikge1xuICAgICAgICB2YXIgcyA9IGxpbmUkJDEuZGF0YVsxXTtcbiAgICAgICAgdmFyIGUgPSBsaW5lJCQxLmRhdGFbMF07XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyhzWzBdIC0gZVswXSwgMikgKyBNYXRoLnBvdyhzWzFdIC0gZVsxXSwgMikpO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCA1ICYmIGxpbmUkJDEuZGF0YVsyXSkge1xuICAgICAgICAgIHMgPSBsaW5lJCQxLmRhdGFbMl07XG4gICAgICAgIH1cbiAgICAgICAgZW5kID0gY29ubmVjdG9yQXJyb3coe1xuICAgICAgICAgIGFubm90YXRpb246IHRoaXMuYW5ub3RhdGlvbixcbiAgICAgICAgICBzdGFydDogcyxcbiAgICAgICAgICBlbmQ6IGUsXG4gICAgICAgICAgc2NhbGU6IGNvbm5lY3RvckRhdGEuZW5kU2NhbGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVuZFR5cGUgPT09IFwiZG90XCIpIHtcbiAgICAgICAgZW5kID0gY29ubmVjdG9yRG90KHsgbGluZTogbGluZSQkMSwgc2NhbGU6IGNvbm5lY3RvckRhdGEuZW5kU2NhbGUgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFlbmRUeXBlIHx8IGVuZFR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yICYmIHRoaXMuY29ubmVjdG9yLnNlbGVjdChcIi5jb25uZWN0b3ItZW5kXCIpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kLmNvbXBvbmVudHMpIHtcbiAgICAgICAgZW5kLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGMuYXR0cnMuZmlsbCA9IF90aGlzMy5hbm5vdGF0aW9uLmNvbG9yO1xuICAgICAgICAgIGMuYXR0cnMuc3Ryb2tlID0gX3RoaXMzLmFubm90YXRpb24uY29sb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb21wb25lbnRzID0gY29tcG9uZW50cy5jb25jYXQoZW5kLmNvbXBvbmVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSkge1xuICAgICAgICBpZiAoaGFuZGxlcy5sZW5ndGggIT09IDApIGNvbXBvbmVudHMucHVzaCh7IHR5cGU6IFwiaGFuZGxlXCIsIGhhbmRsZXM6IGhhbmRsZXMgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd05vdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICB2YXIgbm90ZURhdGEgPSB0aGlzLmFubm90YXRpb24ubm90ZTtcbiAgICAgIHZhciBhbGlnbiA9IG5vdGVEYXRhLmFsaWduIHx8IGNvbnRleHQuYWxpZ24gfHwgXCJkeW5hbWljXCI7XG4gICAgICB2YXIgbm90ZVBhcmFtcyA9IHtcbiAgICAgICAgYmJveDogY29udGV4dC5iYm94LFxuICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgIG9mZnNldDogdGhpcy5hbm5vdGF0aW9uLm9mZnNldFxuICAgICAgfTtcbiAgICAgIHZhciBsaW5lVHlwZSA9IG5vdGVEYXRhLmxpbmVUeXBlIHx8IGNvbnRleHQubGluZVR5cGU7XG4gICAgICB2YXIgbm90ZSA9IHt9O1xuICAgICAgaWYgKGxpbmVUeXBlID09PSBcInZlcnRpY2FsXCIpIG5vdGUgPSBub3RlVmVydGljYWwobm90ZVBhcmFtcyk7ZWxzZSBpZiAobGluZVR5cGUgPT09IFwiaG9yaXpvbnRhbFwiKSBub3RlID0gbm90ZUhvcml6b250YWwobm90ZVBhcmFtcyk7XG5cbiAgICAgIHZhciBfbm90ZSA9IG5vdGUsXG4gICAgICAgICAgX25vdGUkY29tcG9uZW50cyA9IF9ub3RlLmNvbXBvbmVudHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF9ub3RlJGNvbXBvbmVudHMgPT09IHVuZGVmaW5lZCA/IFtdIDogX25vdGUkY29tcG9uZW50cyxcbiAgICAgICAgICBfbm90ZSRoYW5kbGVzID0gX25vdGUuaGFuZGxlcyxcbiAgICAgICAgICBoYW5kbGVzID0gX25vdGUkaGFuZGxlcyA9PT0gdW5kZWZpbmVkID8gW10gOiBfbm90ZSRoYW5kbGVzO1xuXG4gICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgYy5hdHRycy5zdHJva2UgPSBfdGhpczQuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSkge1xuICAgICAgICBoYW5kbGVzID0gdGhpcy5tYXBIYW5kbGVzKFt7IHg6IDAsIHk6IDAsIGRyYWc6IHRoaXMuZHJhZ05vdGUuYmluZCh0aGlzKSB9XSk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7IHR5cGU6IFwiaGFuZGxlXCIsIGhhbmRsZXM6IGhhbmRsZXMgfSk7XG5cbiAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5kcmFnTm90ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmRyYWdzdGFydGVkLmJpbmQodGhpcyksXG4gICAgICAgICAgICBlbmQgPSB0aGlzLmRyYWdlbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGUuY2FsbChkcmFnKCkuY29udGFpbmVyKHNlbGVjdChcImcuYW5ub3RhdGlvbnNcIikubm9kZSgpKS5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0KGQpO1xuICAgICAgICB9KS5vbihcImRyYWdcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZHJhZ2dpbmcoZCk7XG4gICAgICAgIH0pLm9uKFwiZW5kXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZChkKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub3RlLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd05vdGVDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdOb3RlQ29udGVudChjb250ZXh0KSB7XG4gICAgICB2YXIgbm90ZURhdGEgPSB0aGlzLmFubm90YXRpb24ubm90ZTtcbiAgICAgIHZhciBwYWRkaW5nID0gbm90ZURhdGEucGFkZGluZyAhPT0gdW5kZWZpbmVkID8gbm90ZURhdGEucGFkZGluZyA6IHRoaXMubm90ZVBhZGRpbmc7XG4gICAgICB2YXIgb3JpZW50YXRpb24gPSBub3RlRGF0YS5vcmllbnRhdGlvbiB8fCBjb250ZXh0Lm9yaWVudGF0aW9uIHx8IFwidG9wQm90dG9tXCI7XG4gICAgICB2YXIgbGluZVR5cGUgPSBub3RlRGF0YS5saW5lVHlwZSB8fCBjb250ZXh0LmxpbmVUeXBlO1xuICAgICAgdmFyIGFsaWduID0gbm90ZURhdGEuYWxpZ24gfHwgY29udGV4dC5hbGlnbiB8fCBcImR5bmFtaWNcIjtcblxuICAgICAgaWYgKGxpbmVUeXBlID09PSBcInZlcnRpY2FsXCIpIG9yaWVudGF0aW9uID0gXCJsZWZ0UmlnaHRcIjtlbHNlIGlmIChsaW5lVHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIG9yaWVudGF0aW9uID0gXCJ0b3BCb3R0b21cIjtcblxuICAgICAgdmFyIG5vdGVQYXJhbXMgPSB7XG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgIGJib3g6IGNvbnRleHQuYmJveCxcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmFubm90YXRpb24ub2Zmc2V0LFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgIGFsaWduOiBhbGlnblxuICAgICAgfTtcblxuICAgICAgdmFyIF9ub3RlQWxpZ25tZW50ID0gbm90ZUFsaWdubWVudChub3RlUGFyYW1zKSxcbiAgICAgICAgICB4ID0gX25vdGVBbGlnbm1lbnQueCxcbiAgICAgICAgICB5ID0gX25vdGVBbGlnbm1lbnQueTtcblxuICAgICAgdGhpcy5vZmZzZXRDb3JuZXJYID0geCArIHRoaXMuYW5ub3RhdGlvbi5keDtcbiAgICAgIHRoaXMub2Zmc2V0Q29ybmVyWSA9IHkgKyB0aGlzLmFubm90YXRpb24uZHk7XG4gICAgICB0aGlzLm5vdGUgJiYgdGhpcy5ub3RlQ29udGVudC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBcIilcIik7XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd09uU2NyZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdPblNjcmVlbihjb21wb25lbnQsIGRyYXdGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuZHJhd09uU1ZHKGNvbXBvbmVudCwgZHJhd0Z1bmN0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3U3ViamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXdTdWJqZWN0KCkge1xuICAgICAgdGhpcy5zdWJqZWN0ICYmIHRoaXMuZHJhd09uU2NyZWVuKHRoaXMuc3ViamVjdCwgdGhpcy5kcmF3U3ViamVjdCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3Q29ubmVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhd0Nvbm5lY3RvcigpIHtcbiAgICAgIHRoaXMuY29ubmVjdG9yICYmIHRoaXMuZHJhd09uU2NyZWVuKHRoaXMuY29ubmVjdG9yLCB0aGlzLmRyYXdDb25uZWN0b3IoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZHJhd05vdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3Tm90ZSgpIHtcbiAgICAgIHZhciBiYm94ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmdldE5vdGVCQm94KCk7XG5cbiAgICAgIHRoaXMubm90ZUNvbnRlbnQgJiYgdGhpcy5kcmF3T25TY3JlZW4odGhpcy5ub3RlQ29udGVudCwgdGhpcy5kcmF3Tm90ZUNvbnRlbnQoeyBiYm94OiBiYm94IH0pKTtcbiAgICAgIHRoaXMubm90ZSAmJiB0aGlzLmRyYXdPblNjcmVlbih0aGlzLm5vdGUsIHRoaXMuZHJhd05vdGUoeyBiYm94OiBiYm94IH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmFubm90YXRpb24ucG9zaXRpb247XG4gICAgICB0aGlzLmEuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uLnggKyBcIiwgXCIgKyBwb3NpdGlvbi55ICsgXCIpXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckNvbXBvbmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5zdWJqZWN0ICYmIHRoaXMuc3ViamVjdC5zZWxlY3QoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5jb25uZWN0b3Iuc2VsZWN0KFwiKlwiKS5yZW1vdmUoKTtcbiAgICAgIC8vIHRoaXMubm90ZSAmJiB0aGlzLm5vdGUuc2VsZWN0KFwiKlwiKS5yZW1vdmUoKVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMubm90ZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5hbm5vdGF0aW9uLm9mZnNldDtcbiAgICAgICAgdGhpcy5ub3RlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXQueCArIFwiLCBcIiArIG9mZnNldC55ICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvbldpdGhBY2Nlc3NvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb25XaXRoQWNjZXNzb3JzKGFjY2Vzc29ycykge1xuICAgICAgaWYgKGFjY2Vzc29ycyAmJiB0aGlzLmFubm90YXRpb24uZGF0YSkge1xuICAgICAgICB0aGlzLm1hcFgoYWNjZXNzb3JzKTtcbiAgICAgICAgdGhpcy5tYXBZKGFjY2Vzc29ycyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENsYXNzTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDbGFzc05hbWUoKSB7XG4gICAgICB0aGlzLmEuYXR0cihcImNsYXNzXCIsIFwiYW5ub3RhdGlvbiBcIiArICh0aGlzLmNsYXNzTmFtZSAmJiB0aGlzLmNsYXNzTmFtZSgpKSArIFwiIFwiICsgKHRoaXMuZWRpdE1vZGUgPyBcImVkaXRhYmxlXCIgOiBcIlwiKSArIFwiIFwiICsgKHRoaXMuYW5ub3RhdGlvbi5jbGFzc05hbWUgfHwgXCJcIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB0aGlzLnNldENsYXNzTmFtZSgpO1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbigpO1xuICAgICAgdGhpcy5zZXRPZmZzZXQoKTtcbiAgICAgIHRoaXMucmVkcmF3U3ViamVjdCgpO1xuICAgICAgdGhpcy5yZWRyYXdDb25uZWN0b3IoKTtcbiAgICAgIHRoaXMucmVkcmF3Tm90ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnc3RhcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnc3RhcnRlZCgpIHtcbiAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5kaXNwYXRjaGVyICYmIHRoaXMuZGlzcGF0Y2hlci5jYWxsKFwiZHJhZ3N0YXJ0XCIsIHRoaXMuYSwgdGhpcy5hbm5vdGF0aW9uKTtcbiAgICAgIHRoaXMuYS5jbGFzc2VkKFwiZHJhZ2dpbmdcIiwgdHJ1ZSk7XG4gICAgICB0aGlzLmEuc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhZ2VuZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdlbmRlZCgpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hlciAmJiB0aGlzLmRpc3BhdGNoZXIuY2FsbChcImRyYWdlbmRcIiwgdGhpcy5hLCB0aGlzLmFubm90YXRpb24pO1xuICAgICAgdGhpcy5hLmNsYXNzZWQoXCJkcmFnZ2luZ1wiLCBmYWxzZSk7XG4gICAgICB0aGlzLmEuc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnU3ViamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnU3ViamVjdCgpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYW5ub3RhdGlvbi5wb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uLnggKz0gZXZlbnQuZHg7XG4gICAgICBwb3NpdGlvbi55ICs9IGV2ZW50LmR5O1xuICAgICAgdGhpcy5hbm5vdGF0aW9uLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdOb3RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdOb3RlKCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuYW5ub3RhdGlvbi5vZmZzZXQ7XG4gICAgICBvZmZzZXQueCArPSBldmVudC5keDtcbiAgICAgIG9mZnNldC55ICs9IGV2ZW50LmR5O1xuICAgICAgdGhpcy5hbm5vdGF0aW9uLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwSGFuZGxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBIYW5kbGVzKGhhbmRsZXMpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gaGFuZGxlcy5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoLCB7XG4gICAgICAgICAgc3RhcnQ6IF90aGlzNS5kcmFnc3RhcnRlZC5iaW5kKF90aGlzNSksXG4gICAgICAgICAgZW5kOiBfdGhpczUuZHJhZ2VuZGVkLmJpbmQoX3RoaXM1KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHlwZTtcbn0oKTtcblxudmFyIGN1c3RvbVR5cGUgPSBmdW5jdGlvbiBjdXN0b21UeXBlKGluaXRpYWxUeXBlLCB0eXBlU2V0dGluZ3MsIF9pbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX2luaXRpYWxUeXBlKSB7XG4gICAgaW5oZXJpdHMoY3VzdG9tVHlwZSwgX2luaXRpYWxUeXBlKTtcblxuICAgIGZ1bmN0aW9uIGN1c3RvbVR5cGUoc2V0dGluZ3MpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIGN1c3RvbVR5cGUpO1xuXG4gICAgICB2YXIgX3RoaXM2ID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoY3VzdG9tVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUpKS5jYWxsKHRoaXMsIHNldHRpbmdzKSk7XG5cbiAgICAgIF90aGlzNi50eXBlU2V0dGluZ3MgPSB0eXBlU2V0dGluZ3M7XG5cbiAgICAgIGlmICh0eXBlU2V0dGluZ3MuZGlzYWJsZSkge1xuICAgICAgICB0eXBlU2V0dGluZ3MuZGlzYWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgX3RoaXM2W2RdICYmIF90aGlzNltkXS5yZW1vdmUoKTtcblxuICAgICAgICAgIF90aGlzNltkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoZCA9PT0gXCJub3RlXCIpIHtcbiAgICAgICAgICAgIF90aGlzNi5ub3RlQ29udGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF90aGlzNjtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhjdXN0b21UeXBlLCBbe1xuICAgICAga2V5OiBcImNsYXNzTmFtZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyAodHlwZVNldHRpbmdzLmNsYXNzTmFtZSB8fCBnZXQoY3VzdG9tVHlwZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXN0b21UeXBlLnByb3RvdHlwZSksIFwiY2xhc3NOYW1lXCIsIHRoaXMpICYmIGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJjbGFzc05hbWVcIiwgdGhpcykuY2FsbCh0aGlzKSB8fCBcIlwiKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1N1YmplY3RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3U3ViamVjdChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHlwZVNldHRpbmdzLnN1YmplY3QgPSBfZXh0ZW5kcyh7fSwgdHlwZVNldHRpbmdzLnN1YmplY3QsIHRoaXMudHlwZVNldHRpbmdzLnN1YmplY3QpO1xuICAgICAgICByZXR1cm4gZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImRyYXdTdWJqZWN0XCIsIHRoaXMpLmNhbGwodGhpcywgX2V4dGVuZHMoe30sIGNvbnRleHQsIHRoaXMudHlwZVNldHRpbmdzLnN1YmplY3QpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0Nvbm5lY3RvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDb25uZWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLnR5cGVTZXR0aW5ncy5jb25uZWN0b3IgPSBfZXh0ZW5kcyh7fSwgdHlwZVNldHRpbmdzLmNvbm5lY3RvciwgdGhpcy50eXBlU2V0dGluZ3MuY29ubmVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJkcmF3Q29ubmVjdG9yXCIsIHRoaXMpLmNhbGwodGhpcywgX2V4dGVuZHMoe30sIGNvbnRleHQsIHR5cGVTZXR0aW5ncy5jb25uZWN0b3IsIHRoaXMudHlwZVNldHRpbmdzLmNvbm5lY3RvcikpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Tm90ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdOb3RlKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSA9IF9leHRlbmRzKHt9LCB0eXBlU2V0dGluZ3Mubm90ZSwgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSk7XG4gICAgICAgIHJldHVybiBnZXQoY3VzdG9tVHlwZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXN0b21UeXBlLnByb3RvdHlwZSksIFwiZHJhd05vdGVcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdHlwZVNldHRpbmdzLm5vdGUsIHRoaXMudHlwZVNldHRpbmdzLm5vdGUpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd05vdGVDb250ZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGVDb250ZW50KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJkcmF3Tm90ZUNvbnRlbnRcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdHlwZVNldHRpbmdzLm5vdGUsIHRoaXMudHlwZVNldHRpbmdzLm5vdGUpKTtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChhbm5vdGF0aW9uLCBhY2Nlc3NvcnMpIHtcbiAgICAgICAgZ2V0KGN1c3RvbVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXN0b21UeXBlKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgYW5ub3RhdGlvbiwgYWNjZXNzb3JzKTtcbiAgICAgICAgaWYgKF9pbml0KSB7XG4gICAgICAgICAgYW5ub3RhdGlvbiA9IF9pbml0KGFubm90YXRpb24sIGFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBjdXN0b21UeXBlO1xuICB9KGluaXRpYWxUeXBlKTtcbn07XG5cbnZhciBkM05vdGVUZXh0ID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKGQzTm90ZVRleHQsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBkM05vdGVUZXh0KHBhcmFtcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIGQzTm90ZVRleHQpO1xuXG4gICAgdmFyIF90aGlzNyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKGQzTm90ZVRleHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihkM05vdGVUZXh0KSkuY2FsbCh0aGlzLCBwYXJhbXMpKTtcblxuICAgIF90aGlzNy50ZXh0V3JhcCA9IHBhcmFtcy50ZXh0V3JhcCB8fCAxMjA7XG4gICAgX3RoaXM3LmRyYXdUZXh0KCk7XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKGQzTm90ZVRleHQsIFt7XG4gICAga2V5OiBcInVwZGF0ZVRleHRXcmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRleHRXcmFwKHRleHRXcmFwKSB7XG4gICAgICB0aGlzLnRleHRXcmFwID0gdGV4dFdyYXA7XG4gICAgICB0aGlzLmRyYXdUZXh0KCk7XG4gICAgfVxuXG4gICAgLy9UT0RPOiBhZGQgdXBkYXRlIHRleHQgZnVuY3Rpb25hbGl0eVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgICBpZiAodGhpcy5ub3RlKSB7XG4gICAgICAgIG5ld1dpdGhDbGFzcyh0aGlzLm5vdGUsIFt0aGlzLmFubm90YXRpb25dLCBcImdcIiwgXCJhbm5vdGF0aW9uLW5vdGUtY29udGVudFwiKTtcblxuICAgICAgICB2YXIgbm90ZUNvbnRlbnQgPSB0aGlzLm5vdGUuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLW5vdGUtY29udGVudFwiKTtcbiAgICAgICAgbmV3V2l0aENsYXNzKG5vdGVDb250ZW50LCBbdGhpcy5hbm5vdGF0aW9uXSwgXCJyZWN0XCIsIFwiYW5ub3RhdGlvbi1ub3RlLWJnXCIpO1xuICAgICAgICBuZXdXaXRoQ2xhc3Mobm90ZUNvbnRlbnQsIFt0aGlzLmFubm90YXRpb25dLCBcInRleHRcIiwgXCJhbm5vdGF0aW9uLW5vdGUtbGFiZWxcIik7XG4gICAgICAgIG5ld1dpdGhDbGFzcyhub3RlQ29udGVudCwgW3RoaXMuYW5ub3RhdGlvbl0sIFwidGV4dFwiLCBcImFubm90YXRpb24tbm90ZS10aXRsZVwiKTtcblxuICAgICAgICB2YXIgdGl0bGVCQm94ID0geyBoZWlnaHQ6IDAgfTtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5hLnNlbGVjdChcInRleHQuYW5ub3RhdGlvbi1ub3RlLWxhYmVsXCIpO1xuICAgICAgICB2YXIgd3JhcExlbmd0aCA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlICYmIHRoaXMuYW5ub3RhdGlvbi5ub3RlLndyYXAgfHwgdGhpcy50eXBlU2V0dGluZ3MgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlLndyYXAgfHwgdGhpcy50ZXh0V3JhcDtcblxuICAgICAgICB2YXIgd3JhcFNwbGl0dGVyID0gdGhpcy5hbm5vdGF0aW9uLm5vdGUgJiYgdGhpcy5hbm5vdGF0aW9uLm5vdGUud3JhcFNwbGl0dGVyIHx8IHRoaXMudHlwZVNldHRpbmdzICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZS53cmFwU3BsaXR0ZXI7XG5cbiAgICAgICAgdmFyIGJnUGFkZGluZyA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlICYmIHRoaXMuYW5ub3RhdGlvbi5ub3RlLmJnUGFkZGluZyB8fCB0aGlzLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUuYmdQYWRkaW5nO1xuXG4gICAgICAgIHZhciBiZ1BhZGRpbmdGaW5hbCA9IHsgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwIH07XG4gICAgICAgIGlmICh0eXBlb2YgYmdQYWRkaW5nID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgYmdQYWRkaW5nRmluYWwgPSB7XG4gICAgICAgICAgICB0b3A6IGJnUGFkZGluZyxcbiAgICAgICAgICAgIGJvdHRvbTogYmdQYWRkaW5nLFxuICAgICAgICAgICAgbGVmdDogYmdQYWRkaW5nLFxuICAgICAgICAgICAgcmlnaHQ6IGJnUGFkZGluZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYmdQYWRkaW5nICYmICh0eXBlb2YgYmdQYWRkaW5nID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoYmdQYWRkaW5nKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBiZ1BhZGRpbmdGaW5hbCA9IF9leHRlbmRzKGJnUGFkZGluZ0ZpbmFsLCBiZ1BhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbi5ub3RlLnRpdGxlKSB7XG4gICAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5hLnNlbGVjdChcInRleHQuYW5ub3RhdGlvbi1ub3RlLXRpdGxlXCIpO1xuICAgICAgICAgIHRpdGxlLnRleHQodGhpcy5hbm5vdGF0aW9uLm5vdGUudGl0bGUpO1xuICAgICAgICAgIHRpdGxlLmF0dHIoXCJmaWxsXCIsIHRoaXMuYW5ub3RhdGlvbi5jb2xvcik7XG4gICAgICAgICAgdGl0bGUuYXR0cihcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKTtcbiAgICAgICAgICB0aXRsZS5jYWxsKHdyYXAsIHdyYXBMZW5ndGgsIHdyYXBTcGxpdHRlcik7XG4gICAgICAgICAgdGl0bGVCQm94ID0gdGl0bGUubm9kZSgpLmdldEJCb3goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsLnRleHQodGhpcy5hbm5vdGF0aW9uLm5vdGUubGFiZWwpLmF0dHIoXCJkeFwiLCBcIjBcIik7XG4gICAgICAgIGxhYmVsLmNhbGwod3JhcCwgd3JhcExlbmd0aCwgd3JhcFNwbGl0dGVyKTtcblxuICAgICAgICBsYWJlbC5hdHRyKFwieVwiLCB0aXRsZUJCb3guaGVpZ2h0ICogMS4xIHx8IDApO1xuICAgICAgICBsYWJlbC5hdHRyKFwiZmlsbFwiLCB0aGlzLmFubm90YXRpb24uY29sb3IpO1xuXG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXROb3RlQkJveCgpO1xuXG4gICAgICAgIHRoaXMuYS5zZWxlY3QoXCJyZWN0LmFubm90YXRpb24tbm90ZS1iZ1wiKS5hdHRyKFwid2lkdGhcIiwgYmJveC53aWR0aCArIGJnUGFkZGluZ0ZpbmFsLmxlZnQgKyBiZ1BhZGRpbmdGaW5hbC5yaWdodCkuYXR0cihcImhlaWdodFwiLCBiYm94LmhlaWdodCArIGJnUGFkZGluZ0ZpbmFsLnRvcCArIGJnUGFkZGluZ0ZpbmFsLmJvdHRvbSkuYXR0cihcInhcIiwgYmJveC54IC0gYmdQYWRkaW5nRmluYWwubGVmdCkuYXR0cihcInlcIiwgLWJnUGFkZGluZ0ZpbmFsLnRvcCkuYXR0cihcImZpbGxcIiwgXCJ3aGl0ZVwiKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gZDNOb3RlVGV4dDtcbn0oVHlwZSk7XG5cbnZhciBkM0xhYmVsID0gY3VzdG9tVHlwZShkM05vdGVUZXh0LCB7XG4gIGNsYXNzTmFtZTogXCJsYWJlbFwiLFxuICBub3RlOiB7IGFsaWduOiBcIm1pZGRsZVwiIH1cbn0pO1xuXG52YXIgZDNDYWxsb3V0ID0gY3VzdG9tVHlwZShkM05vdGVUZXh0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0XCIsXG4gIG5vdGU6IHsgbGluZVR5cGU6IFwiaG9yaXpvbnRhbFwiIH1cbn0pO1xuXG52YXIgZDNDYWxsb3V0RWxib3cgPSBjdXN0b21UeXBlKGQzQ2FsbG91dCwge1xuICBjbGFzc05hbWU6IFwiY2FsbG91dCBlbGJvd1wiLFxuICBjb25uZWN0b3I6IHsgdHlwZTogXCJlbGJvd1wiIH1cbn0pO1xuXG52YXIgZDNDYWxsb3V0Q3VydmUgPSBjdXN0b21UeXBlKGQzQ2FsbG91dCwge1xuICBjbGFzc05hbWU6IFwiY2FsbG91dCBjdXJ2ZVwiLFxuICBjb25uZWN0b3I6IHsgdHlwZTogXCJjdXJ2ZVwiIH1cbn0pO1xuXG52YXIgZDNCYWRnZSA9IGN1c3RvbVR5cGUoVHlwZSwge1xuICBjbGFzc05hbWU6IFwiYmFkZ2VcIixcbiAgc3ViamVjdDogeyB0eXBlOiBcImJhZGdlXCIgfSxcbiAgZGlzYWJsZTogW1wiY29ubmVjdG9yXCIsIFwibm90ZVwiXVxufSk7XG5cbnZhciBkM0NhbGxvdXRDaXJjbGUgPSBjdXN0b21UeXBlKGQzTm90ZVRleHQsIHtcbiAgY2xhc3NOYW1lOiBcImNhbGxvdXQgY2lyY2xlXCIsXG4gIHN1YmplY3Q6IHsgdHlwZTogXCJjaXJjbGVcIiB9LFxuICBub3RlOiB7IGxpbmVUeXBlOiBcImhvcml6b250YWxcIiB9LFxuICBjb25uZWN0b3I6IHsgdHlwZTogXCJlbGJvd1wiIH1cbn0pO1xuXG52YXIgZDNDYWxsb3V0UmVjdCA9IGN1c3RvbVR5cGUoZDNOb3RlVGV4dCwge1xuICBjbGFzc05hbWU6IFwiY2FsbG91dCByZWN0XCIsXG4gIHN1YmplY3Q6IHsgdHlwZTogXCJyZWN0XCIgfSxcbiAgbm90ZTogeyBsaW5lVHlwZTogXCJob3Jpem9udGFsXCIgfSxcbiAgY29ubmVjdG9yOiB7IHR5cGU6IFwiZWxib3dcIiB9XG59KTtcblxudmFyIFRocmVzaG9sZE1hcCA9IGZ1bmN0aW9uIChfZDNDYWxsb3V0KSB7XG4gIGluaGVyaXRzKFRocmVzaG9sZE1hcCwgX2QzQ2FsbG91dCk7XG5cbiAgZnVuY3Rpb24gVGhyZXNob2xkTWFwKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRocmVzaG9sZE1hcCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRocmVzaG9sZE1hcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRocmVzaG9sZE1hcCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVGhyZXNob2xkTWFwLCBbe1xuICAgIGtleTogXCJtYXBZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFkoYWNjZXNzb3JzKSB7XG4gICAgICBnZXQoVGhyZXNob2xkTWFwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRocmVzaG9sZE1hcC5wcm90b3R5cGUpLCBcIm1hcFlcIiwgdGhpcykuY2FsbCh0aGlzLCBhY2Nlc3NvcnMpO1xuICAgICAgdmFyIGEgPSB0aGlzLmFubm90YXRpb247XG4gICAgICBpZiAoKGEuc3ViamVjdC54MSB8fCBhLnN1YmplY3QueDIpICYmIGEuZGF0YSAmJiBhY2Nlc3NvcnMueSkge1xuICAgICAgICBhLnkgPSBhY2Nlc3NvcnMueShhLmRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKChhLnN1YmplY3QueDEgfHwgYS5zdWJqZWN0LngyKSAmJiAhYS54KSB7XG4gICAgICAgIGEueCA9IGEuc3ViamVjdC54MSB8fCBhLnN1YmplY3QueDI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWChhY2Nlc3NvcnMpIHtcbiAgICAgIGdldChUaHJlc2hvbGRNYXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhyZXNob2xkTWFwLnByb3RvdHlwZSksIFwibWFwWFwiLCB0aGlzKS5jYWxsKHRoaXMsIGFjY2Vzc29ycyk7XG4gICAgICB2YXIgYSA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgIGlmICgoYS5zdWJqZWN0LnkxIHx8IGEuc3ViamVjdC55MikgJiYgYS5kYXRhICYmIGFjY2Vzc29ycy54KSB7XG4gICAgICAgIGEueCA9IGFjY2Vzc29ycy54KGEuZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKGEuc3ViamVjdC55MSB8fCBhLnN1YmplY3QueTIpICYmICFhLnkpIHtcbiAgICAgICAgYS55ID0gYS5zdWJqZWN0LnkxIHx8IGEuc3ViamVjdC55MjtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRocmVzaG9sZE1hcDtcbn0oZDNDYWxsb3V0KTtcblxudmFyIGQzWFlUaHJlc2hvbGQgPSBjdXN0b21UeXBlKFRocmVzaG9sZE1hcCwge1xuICBjbGFzc05hbWU6IFwiY2FsbG91dCB4eXRocmVzaG9sZFwiLFxuICBzdWJqZWN0OiB7IHR5cGU6IFwidGhyZXNob2xkXCIgfVxufSk7XG5cbnZhciBuZXdXaXRoQ2xhc3MgPSBmdW5jdGlvbiBuZXdXaXRoQ2xhc3MoYSwgZCwgdHlwZSwgY2xhc3NOYW1lLCBjbGFzc0lEKSB7XG4gIHZhciBncm91cCA9IGEuc2VsZWN0QWxsKHR5cGUgKyBcIi5cIiArIChjbGFzc0lEIHx8IGNsYXNzTmFtZSkpLmRhdGEoZCk7XG4gIGdyb3VwLmVudGVyKCkuYXBwZW5kKHR5cGUpLm1lcmdlKGdyb3VwKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NOYW1lKTtcblxuICBncm91cC5leGl0KCkucmVtb3ZlKCk7XG4gIHJldHVybiBhO1xufTtcblxudmFyIGFkZEhhbmRsZXJzID0gZnVuY3Rpb24gYWRkSGFuZGxlcnMoZGlzcGF0Y2hlciwgYW5ub3RhdGlvbiwgX3JlZjMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IF9yZWYzLmNvbXBvbmVudCxcbiAgICAgIG5hbWUgPSBfcmVmMy5uYW1lO1xuXG4gIGlmIChjb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQub24oXCJtb3VzZW92ZXIuYW5ub3RhdGlvbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgZGlzcGF0Y2hlci5jYWxsKG5hbWUgKyBcIm92ZXJcIiwgY29tcG9uZW50LCBhbm5vdGF0aW9uKTtcbiAgICB9KS5vbihcIm1vdXNlb3V0LmFubm90YXRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLmNhbGwobmFtZSArIFwib3V0XCIsIGNvbXBvbmVudCwgYW5ub3RhdGlvbik7XG4gICAgfSkub24oXCJjbGljay5hbm5vdGF0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci5jYWxsKG5hbWUgKyBcImNsaWNrXCIsIGNvbXBvbmVudCwgYW5ub3RhdGlvbik7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vVGV4dCB3cmFwcGluZyBjb2RlIGFkYXB0ZWQgZnJvbSBNaWtlIEJvc3RvY2tcbnZhciB3cmFwID0gZnVuY3Rpb24gd3JhcCh0ZXh0LCB3aWR0aCwgd3JhcFNwbGl0dGVyKSB7XG4gIHZhciBsaW5lSGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxLjI7XG5cbiAgdGV4dC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGV4dCA9IHNlbGVjdCh0aGlzKSxcbiAgICAgICAgd29yZHMgPSB0ZXh0LnRleHQoKS5zcGxpdCh3cmFwU3BsaXR0ZXIgfHwgL1sgXFx0XFxyXFxuXSsvKS5yZXZlcnNlKCkuZmlsdGVyKGZ1bmN0aW9uICh3KSB7XG4gICAgICByZXR1cm4gdyAhPT0gXCJcIjtcbiAgICB9KTtcbiAgICB2YXIgd29yZCA9IHZvaWQgMCxcbiAgICAgICAgbGluZSQkMSA9IFtdLFxuICAgICAgICB0c3BhbiA9IHRleHQudGV4dChudWxsKS5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwiZHlcIiwgMC44ICsgXCJlbVwiKTtcblxuICAgIHdoaWxlICh3b3JkID0gd29yZHMucG9wKCkpIHtcbiAgICAgIGxpbmUkJDEucHVzaCh3b3JkKTtcbiAgICAgIHRzcGFuLnRleHQobGluZSQkMS5qb2luKFwiIFwiKSk7XG4gICAgICBpZiAodHNwYW4ubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpID4gd2lkdGggJiYgbGluZSQkMS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxpbmUkJDEucG9wKCk7XG4gICAgICAgIHRzcGFuLnRleHQobGluZSQkMS5qb2luKFwiIFwiKSk7XG4gICAgICAgIGxpbmUkJDEgPSBbd29yZF07XG4gICAgICAgIHRzcGFuID0gdGV4dC5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwiZHlcIiwgbGluZUhlaWdodCArIFwiZW1cIikudGV4dCh3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGJib3hXaXRob3V0SGFuZGxlcyA9IGZ1bmN0aW9uIGJib3hXaXRob3V0SGFuZGxlcyhzZWxlY3Rpb24pIHtcbiAgdmFyIHNlbGVjdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIjpub3QoLmhhbmRsZSlcIjtcblxuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24uc2VsZWN0QWxsKHNlbGVjdG9yKS5ub2RlcygpLnJlZHVjZShmdW5jdGlvbiAocCwgYykge1xuICAgIHZhciBiYm94ID0gYy5nZXRCQm94KCk7XG4gICAgcC54ID0gTWF0aC5taW4ocC54LCBiYm94LngpO1xuICAgIHAueSA9IE1hdGgubWluKHAueSwgYmJveC55KTtcbiAgICBwLndpZHRoID0gTWF0aC5tYXgocC53aWR0aCwgYmJveC53aWR0aCk7XG5cbiAgICB2YXIgeU9mZnNldCA9IGMgJiYgYy5hdHRyaWJ1dGVzICYmIGMuYXR0cmlidXRlcy55O1xuICAgIHAuaGVpZ2h0ID0gTWF0aC5tYXgocC5oZWlnaHQsICh5T2Zmc2V0ICYmIHBhcnNlRmxvYXQoeU9mZnNldC52YWx1ZSkgfHwgMCkgKyBiYm94LmhlaWdodCk7XG4gICAgcmV0dXJuIHA7XG4gIH0sIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbn07XG5cbmZ1bmN0aW9uIGFubm90YXRpb24oKSB7XG4gIHZhciBhbm5vdGF0aW9ucyA9IFtdLFxuICAgICAgY29sbGVjdGlvbiA9IHZvaWQgMCxcbiAgICAgIGNvbnRleHQgPSB2b2lkIDAsXG4gICAgICAvL1RPRE86IGFkZCBjYW52YXMgZnVuY3Rpb25hbGl0eVxuICBkaXNhYmxlID0gW10sXG4gICAgICBhY2Nlc3NvcnMgPSB7fSxcbiAgICAgIGFjY2Vzc29yc0ludmVyc2UgPSB7fSxcbiAgICAgIGVkaXRNb2RlID0gZmFsc2UsXG4gICAgICBpZHMgPSB2b2lkIDAsXG4gICAgICB0eXBlID0gZDNDYWxsb3V0LFxuICAgICAgdGV4dFdyYXAgPSB2b2lkIDAsXG4gICAgICBub3RlUGFkZGluZyA9IHZvaWQgMCxcbiAgICAgIGFubm90YXRpb25EaXNwYXRjaGVyID0gZGlzcGF0Y2goXCJzdWJqZWN0b3ZlclwiLCBcInN1YmplY3RvdXRcIiwgXCJzdWJqZWN0Y2xpY2tcIiwgXCJjb25uZWN0b3JvdmVyXCIsIFwiY29ubmVjdG9yb3V0XCIsIFwiY29ubmVjdG9yY2xpY2tcIiwgXCJub3Rlb3ZlclwiLCBcIm5vdGVvdXRcIiwgXCJub3RlY2xpY2tcIiwgXCJkcmFnZW5kXCIsIFwiZHJhZ3N0YXJ0XCIpLFxuICAgICAgc2VsID0gdm9pZCAwO1xuXG4gIHZhciBhbm5vdGF0aW9uID0gZnVuY3Rpb24gYW5ub3RhdGlvbihzZWxlY3Rpb24pIHtcbiAgICBzZWwgPSBzZWxlY3Rpb247XG4gICAgLy9UT0RPOiBjaGVjayB0byBzZWUgaWYgdGhpcyBpcyBzdGlsbCBuZWVkZWRcbiAgICBpZiAoIWVkaXRNb2RlKSB7XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNsYXRlZEFubm90YXRpb25zID0gYW5ub3RhdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICBpZiAoIWEudHlwZSkge1xuICAgICAgICBhLnR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKCFhLmRpc2FibGUpIHtcbiAgICAgICAgYS5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbihhKTtcbiAgICB9KTtcblxuICAgIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uIHx8IG5ldyBBbm5vdGF0aW9uQ29sbGVjdGlvbih7XG4gICAgICBhbm5vdGF0aW9uczogdHJhbnNsYXRlZEFubm90YXRpb25zLFxuICAgICAgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsXG4gICAgICBhY2Nlc3NvcnNJbnZlcnNlOiBhY2Nlc3NvcnNJbnZlcnNlLFxuICAgICAgaWRzOiBpZHNcbiAgICB9KTtcblxuICAgIHZhciBhbm5vdGF0aW9uRyA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJnXCIpLmRhdGEoW2NvbGxlY3Rpb25dKTtcbiAgICBhbm5vdGF0aW9uRy5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiYW5ub3RhdGlvbnNcIik7XG5cbiAgICB2YXIgZ3JvdXAgPSBzZWxlY3Rpb24uc2VsZWN0KFwiZy5hbm5vdGF0aW9uc1wiKTtcbiAgICBuZXdXaXRoQ2xhc3MoZ3JvdXAsIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMsIFwiZ1wiLCBcImFubm90YXRpb25cIik7XG5cbiAgICB2YXIgYW5ub3RhdGlvbiA9IGdyb3VwLnNlbGVjdEFsbChcImcuYW5ub3RhdGlvblwiKTtcblxuICAgIGFubm90YXRpb24uZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGEgPSBzZWxlY3QodGhpcyk7XG5cbiAgICAgIGEuYXR0cihcImNsYXNzXCIsIFwiYW5ub3RhdGlvblwiKTtcblxuICAgICAgbmV3V2l0aENsYXNzKGEsIFtkXSwgXCJnXCIsIFwiYW5ub3RhdGlvbi1jb25uZWN0b3JcIik7XG4gICAgICBuZXdXaXRoQ2xhc3MoYSwgW2RdLCBcImdcIiwgXCJhbm5vdGF0aW9uLXN1YmplY3RcIik7XG4gICAgICBuZXdXaXRoQ2xhc3MoYSwgW2RdLCBcImdcIiwgXCJhbm5vdGF0aW9uLW5vdGVcIik7XG4gICAgICBuZXdXaXRoQ2xhc3MoYS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZVwiKSwgW2RdLCBcImdcIiwgXCJhbm5vdGF0aW9uLW5vdGUtY29udGVudFwiKTtcbiAgICAgIGQudHlwZSA9IGQudHlwZS50b1N0cmluZygpID09PSBcIltvYmplY3QgT2JqZWN0XVwiID8gZC50eXBlIDogbmV3IGQudHlwZSh7XG4gICAgICAgIGE6IGEsXG4gICAgICAgIGFubm90YXRpb246IGQsXG4gICAgICAgIHRleHRXcmFwOiB0ZXh0V3JhcCxcbiAgICAgICAgbm90ZVBhZGRpbmc6IG5vdGVQYWRkaW5nLFxuICAgICAgICBlZGl0TW9kZTogZWRpdE1vZGUsXG4gICAgICAgIGRpc3BhdGNoZXI6IGFubm90YXRpb25EaXNwYXRjaGVyLFxuICAgICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29yc1xuICAgICAgfSk7XG4gICAgICBkLnR5cGUuZHJhdygpO1xuICAgICAgZC50eXBlLmRyYXdUZXh0ICYmIGQudHlwZS5kcmF3VGV4dCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGFubm90YXRpb24uanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgY29uc29sZS5sb2coXCJBbm5vdGF0aW9ucyBKU09OIHdhcyBjb3BpZWQgdG8geW91ciBjbGlwYm9hcmQuIFBsZWFzZSBub3RlIHRoZSBhbm5vdGF0aW9uIHR5cGUgaXMgbm90IEpTT04gY29tcGF0aWJsZS4gSXQgYXBwZWFycyBpbiB0aGUgb2JqZWN0cyBhcnJheSBpbiB0aGUgY29uc29sZSwgYnV0IG5vdCBpbiB0aGUgY29waWVkIEpTT04uXCIsIGNvbGxlY3Rpb24uanNvbik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgd2luZG93LmNvcHkoSlNPTi5zdHJpbmdpZnkoY29sbGVjdGlvbi5qc29uLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgZGVsZXRlIGEudHlwZTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0pKSk7XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFubm90YXRpb25zICYmIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS50eXBlLmRyYXcoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi51cGRhdGVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZVRleHQodGV4dFdyYXApO1xuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLnVwZGF0ZWRBY2Nlc3NvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29sbGVjdGlvbi5zZXRQb3NpdGlvbldpdGhBY2Nlc3NvcnMoKTtcbiAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5kaXNhYmxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkaXNhYmxlO1xuICAgIGRpc2FibGUgPSBfO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZURpc2FibGUoZGlzYWJsZSk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24udGV4dFdyYXAgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRleHRXcmFwO1xuICAgIHRleHRXcmFwID0gXztcbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi51cGRhdGVUZXh0V3JhcCh0ZXh0V3JhcCk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24ubm90ZVBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vdGVQYWRkaW5nO1xuICAgIG5vdGVQYWRkaW5nID0gXztcbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi51cGRhdGVOb3RlUGFkZGluZyhub3RlUGFkZGluZyk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuICAvL3RvZG8gdGhpbmsgb2YgaG93IHRvIGhhbmRsZSB3aGVuIHVuZGVmaW5lZCBpcyBzZW50XG4gIGFubm90YXRpb24udHlwZSA9IGZ1bmN0aW9uIChfLCBzZXR0aW5ncykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHR5cGU7XG4gICAgdHlwZSA9IF87XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEudHlwZS5ub3RlICYmIGEudHlwZS5ub3RlLnNlbGVjdEFsbChcIio6bm90KC5hbm5vdGF0aW9uLW5vdGUtY29udGVudClcIikucmVtb3ZlKCk7XG4gICAgICAgIGEudHlwZS5ub3RlQ29udGVudCAmJiBhLnR5cGUubm90ZUNvbnRlbnQuc2VsZWN0QWxsKFwiKlwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLnN1YmplY3QgJiYgYS50eXBlLnN1YmplY3Quc2VsZWN0QWxsKFwiKlwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLmNvbm5lY3RvciAmJiBhLnR5cGUuY29ubmVjdG9yLnNlbGVjdEFsbChcIipcIikucmVtb3ZlKCk7XG4gICAgICAgIGEudHlwZS50eXBlU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgYS50eXBlID0gdHlwZTtcblxuICAgICAgICBhLnN1YmplY3QgPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5zdWJqZWN0IHx8IGEuc3ViamVjdDtcbiAgICAgICAgYS5jb25uZWN0b3IgPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5jb25uZWN0b3IgfHwgYS5jb25uZWN0b3I7XG4gICAgICAgIGEubm90ZSA9IHNldHRpbmdzICYmIHNldHRpbmdzLm5vdGUgfHwgYS5ub3RlO1xuICAgICAgfSk7XG5cbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmFubm90YXRpb25zIHx8IGFubm90YXRpb25zO1xuICAgIGFubm90YXRpb25zID0gXztcblxuICAgIGlmIChjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMpIHtcbiAgICAgIHZhciByZXJ1biA9IGFubm90YXRpb25zLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICFkLnR5cGUgfHwgZC50eXBlLnRvU3RyaW5nKCkgIT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlcnVuKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICBhbm5vdGF0aW9uKHNlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xsZWN0aW9uLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uY29udGV4dCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcbiAgICBjb250ZXh0ID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmFjY2Vzc29ycyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYWNjZXNzb3JzO1xuICAgIGFjY2Vzc29ycyA9IF87XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5hY2Nlc3NvcnNJbnZlcnNlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhY2Nlc3NvcnNJbnZlcnNlO1xuICAgIGFjY2Vzc29yc0ludmVyc2UgPSBfO1xuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uaWRzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpZHM7XG4gICAgaWRzID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmVkaXRNb2RlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlZGl0TW9kZTtcbiAgICBlZGl0TW9kZSA9IF87XG5cbiAgICBpZiAoc2VsKSB7XG4gICAgICBzZWwuc2VsZWN0QWxsKFwiZy5hbm5vdGF0aW9uXCIpLmNsYXNzZWQoXCJlZGl0YWJsZVwiLCBlZGl0TW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24uZWRpdE1vZGUoZWRpdE1vZGUpO1xuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgY29sbGVjdGlvbiA9IF87XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBhbm5vdGF0aW9uRGlzcGF0Y2hlci5vbi5hcHBseShhbm5vdGF0aW9uRGlzcGF0Y2hlciwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGFubm90YXRpb25EaXNwYXRjaGVyID8gYW5ub3RhdGlvbiA6IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBhbm5vdGF0aW9uO1xufVxuXG52YXIgaW5kZXggPSB7XG4gIGFubm90YXRpb246IGFubm90YXRpb24sXG4gIGFubm90YXRpb25UeXBlQmFzZTogVHlwZSxcbiAgYW5ub3RhdGlvbkxhYmVsOiBkM0xhYmVsLFxuICBhbm5vdGF0aW9uQ2FsbG91dDogZDNDYWxsb3V0LFxuICBhbm5vdGF0aW9uQ2FsbG91dEN1cnZlOiBkM0NhbGxvdXRDdXJ2ZSxcbiAgYW5ub3RhdGlvbkNhbGxvdXRFbGJvdzogZDNDYWxsb3V0RWxib3csXG4gIGFubm90YXRpb25DYWxsb3V0Q2lyY2xlOiBkM0NhbGxvdXRDaXJjbGUsXG4gIGFubm90YXRpb25DYWxsb3V0UmVjdDogZDNDYWxsb3V0UmVjdCxcbiAgYW5ub3RhdGlvblhZVGhyZXNob2xkOiBkM1hZVGhyZXNob2xkLFxuICBhbm5vdGF0aW9uQmFkZ2U6IGQzQmFkZ2UsXG4gIGFubm90YXRpb25DdXN0b21UeXBlOiBjdXN0b21UeXBlXG59O1xuXG5leHBvcnQgeyBhbm5vdGF0aW9uLCBUeXBlIGFzIGFubm90YXRpb25UeXBlQmFzZSwgZDNMYWJlbCBhcyBhbm5vdGF0aW9uTGFiZWwsIGQzQ2FsbG91dCBhcyBhbm5vdGF0aW9uQ2FsbG91dCwgZDNDYWxsb3V0Q3VydmUgYXMgYW5ub3RhdGlvbkNhbGxvdXRDdXJ2ZSwgZDNDYWxsb3V0RWxib3cgYXMgYW5ub3RhdGlvbkNhbGxvdXRFbGJvdywgZDNDYWxsb3V0Q2lyY2xlIGFzIGFubm90YXRpb25DYWxsb3V0Q2lyY2xlLCBkM0NhbGxvdXRSZWN0IGFzIGFubm90YXRpb25DYWxsb3V0UmVjdCwgZDNYWVRocmVzaG9sZCBhcyBhbm5vdGF0aW9uWFlUaHJlc2hvbGQsIGQzQmFkZ2UgYXMgYW5ub3RhdGlvbkJhZGdlLCBjdXN0b21UeXBlIGFzIGFubm90YXRpb25DdXN0b21UeXBlIH07ZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleFJvbGx1cE5leHQuanMubWFwXG4iLCJleHBvcnQge2RlZmF1bHQgYXMgZGlzcGF0Y2h9IGZyb20gXCIuL3NyYy9kaXNwYXRjaFwiO1xuIiwidmFyIG5vb3AgPSB7dmFsdWU6IGZ1bmN0aW9uKCkge319O1xuXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlzcGF0Y2g7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtldmVudCwgY3VzdG9tRXZlbnQsIHNlbGVjdCwgbW91c2UsIHRvdWNofSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9kcmFnLCB7eWVzZHJhZ30gZnJvbSBcIi4vbm9kcmFnXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnRcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IERyYWdFdmVudCBmcm9tIFwiLi9ldmVudFwiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoKSB7XG4gIHJldHVybiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udGFpbmVyKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3ViamVjdChkKSB7XG4gIHJldHVybiBkID09IG51bGwgPyB7eDogZXZlbnQueCwgeTogZXZlbnQueX0gOiBkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBjb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IGRlZmF1bHRTdWJqZWN0LFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIGdlc3R1cmVzID0ge30sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImVuZFwiKSxcbiAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICBtb3VzZWRvd254LFxuICAgICAgbW91c2Vkb3dueSxcbiAgICAgIG1vdXNlbW92aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KFwibW91c2VcIiwgY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIG1vdXNlLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghZ2VzdHVyZSkgcmV0dXJuO1xuICAgIHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIHRydWUpO1xuICAgIG5vZHJhZyhldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgbW91c2Vtb3ZpbmcgPSBmYWxzZTtcbiAgICBtb3VzZWRvd254ID0gZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZXZlbnQuY2xpZW50WTtcbiAgICBnZXN0dXJlKFwic3RhcnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XG4gICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0gbW91c2Vkb3dueCwgZHkgPSBldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICBzZWxlY3QoZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIiwgbnVsbCk7XG4gICAgeWVzZHJhZyhldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XG4gICAgbm9ldmVudCgpO1xuICAgIGdlc3R1cmVzLm1vdXNlKFwiZW5kXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodG91Y2hlc1tpXS5pZGVudGlmaWVyLCBjLCB0b3VjaCwgdGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub2V2ZW50KCk7XG4gICAgICAgIGdlc3R1cmUoXCJkcmFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcImVuZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVzdGFydChpZCwgY29udGFpbmVyLCBwb2ludCwgdGhhdCwgYXJncykge1xuICAgIHZhciBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIHMsIGR4LCBkeSxcbiAgICAgICAgc3VibGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvcHkoKTtcblxuICAgIGlmICghY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCBcImJlZm9yZXN0YXJ0XCIsIHMsIGlkLCBhY3RpdmUsIHBbMF0sIHBbMV0sIDAsIDAsIHN1Ymxpc3RlbmVycyksIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChldmVudC5zdWJqZWN0ID0gcyA9IHN1YmplY3QuYXBwbHkodGhhdCwgYXJncykpID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgICAgZHkgPSBzLnkgLSBwWzFdIHx8IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRdID0gZ2VzdHVyZSwgbiA9IGFjdGl2ZSsrOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRdLCAtLWFjdGl2ZTsgLy8gbm9icmVha1xuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCB0eXBlLCBzLCBpZCwgbiwgcFswXSArIGR4LCBwWzFdICsgZHksIHBbMF0gLSBwMFswXSwgcFsxXSAtIHAwWzFdLCBzdWJsaXN0ZW5lcnMpLCBzdWJsaXN0ZW5lcnMuYXBwbHksIHN1Ymxpc3RlbmVycywgW3R5cGUsIHRoYXQsIGFyZ3NdKTtcbiAgICB9O1xuICB9XG5cbiAgZHJhZy5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IGZpbHRlcjtcbiAgfTtcblxuICBkcmFnLmNvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250YWluZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IGNvbnRhaW5lcjtcbiAgfTtcblxuICBkcmFnLnN1YmplY3QgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ViamVjdCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogc3ViamVjdDtcbiAgfTtcblxuICBkcmFnLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGRyYWcub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gZHJhZyA6IHZhbHVlO1xuICB9O1xuXG4gIGRyYWcuY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgZHJhZykgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiBkcmFnO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHJhZ0V2ZW50KHRhcmdldCwgdHlwZSwgc3ViamVjdCwgaWQsIGFjdGl2ZSwgeCwgeSwgZHgsIGR5LCBkaXNwYXRjaCkge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgdGhpcy5pZGVudGlmaWVyID0gaWQ7XG4gIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLmR4ID0gZHg7XG4gIHRoaXMuZHkgPSBkeTtcbiAgdGhpcy5fID0gZGlzcGF0Y2g7XG59XG5cbkRyYWdFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5fLm9uLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHZhbHVlID09PSB0aGlzLl8gPyB0aGlzIDogdmFsdWU7XG59O1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWd9IGZyb20gXCIuL2RyYWdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkcmFnRGlzYWJsZSwgeWVzZHJhZyBhcyBkcmFnRW5hYmxlfSBmcm9tIFwiLi9ub2RyYWdcIjtcbiIsImltcG9ydCB7c2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9ldmVudCBmcm9tIFwiLi9ub2V2ZW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fX25vc2VsZWN0ID0gcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0O1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG4iLCJpbXBvcnQge2V2ZW50fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwidmFyIHBpID0gTWF0aC5QSSxcbiAgICB0YXUgPSAyICogcGksXG4gICAgZXBzaWxvbiA9IDFlLTYsXG4gICAgdGF1RXBzaWxvbiA9IHRhdSAtIGVwc2lsb247XG5cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5fID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHBhdGgucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICB9XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJRXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkNcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKCt4MikgKyBcIixcIiArICgreTIpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgYXJjVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcbiAgICB2YXIgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24pKTtcblxuICAgIC8vIE9yLCBhcmUgKHgwLHkwKSwgKHgxLHkxKSBhbmQgKHgyLHkyKSBjb2xsaW5lYXI/XG4gICAgLy8gRXF1aXZhbGVudGx5LCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDIseTIpP1xuICAgIC8vIE9yLCBpcyB0aGUgcmFkaXVzIHplcm8/IExpbmUgdG8gKHgxLHkxKS5cbiAgICBlbHNlIGlmICghKE1hdGguYWJzKHkwMSAqIHgyMSAtIHkyMSAqIHgwMSkgPiBlcHNpbG9uKSB8fCAhcikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIHZhciB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSxcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxuICAgICAgICAgIHQyMSA9IGwgLyBsMjE7XG5cbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgIGlmIChNYXRoLmFicyh0MDEgLSAxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHgxICsgdDAxICogeDAxKSArIFwiLFwiICsgKHkxICsgdDAxICogeTAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMCxcIiArICgrKHkwMSAqIHgyMCA+IHgwMSAqIHkyMCkpICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MSArIHQyMSAqIHgyMSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxICsgdDIxICogeTIxKTtcbiAgICB9XG4gIH0sXG4gIGFyYzogZnVuY3Rpb24oeCwgeSwgciwgYTAsIGExLCBjY3cpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyLCBjY3cgPSAhIWNjdztcbiAgICB2YXIgZHggPSByICogTWF0aC5jb3MoYTApLFxuICAgICAgICBkeSA9IHIgKiBNYXRoLnNpbihhMCksXG4gICAgICAgIHgwID0geCArIGR4LFxuICAgICAgICB5MCA9IHkgKyBkeSxcbiAgICAgICAgY3cgPSAxIF4gY2N3LFxuICAgICAgICBkYSA9IGNjdyA/IGEwIC0gYTEgOiBhMSAtIGEwO1xuXG4gICAgLy8gSXMgdGhlIHJhZGl1cyBuZWdhdGl2ZT8gRXJyb3IuXG4gICAgaWYgKHIgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgwLHkwKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuXyArPSBcIk1cIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHkwKSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuXyArPSBcIkxcIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBlbXB0eT8gV2XigJlyZSBkb25lLlxuICAgIGlmICghcikgcmV0dXJuO1xuXG4gICAgLy8gRG9lcyB0aGUgYW5nbGUgZ28gdGhlIHdyb25nIHdheT8gRmxpcCB0aGUgZGlyZWN0aW9uLlxuICAgIGlmIChkYSA8IDApIGRhID0gZGEgJSB0YXUgKyB0YXU7XG5cbiAgICAvLyBJcyB0aGlzIGEgY29tcGxldGUgY2lyY2xlPyBEcmF3IHR3byBhcmNzIHRvIGNvbXBsZXRlIHRoZSBjaXJjbGUuXG4gICAgaWYgKGRhID4gdGF1RXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAoeCAtIGR4KSArIFwiLFwiICsgKHkgLSBkeSkgKyBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geDApICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MCk7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgbm9uLWVtcHR5PyBEcmF3IGFuIGFyYyFcbiAgICBlbHNlIGlmIChkYSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLFwiICsgKCsoZGEgPj0gcGkpKSArIFwiLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpKSArIFwiLFwiICsgKHRoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSkpO1xuICAgIH1cbiAgfSxcbiAgcmVjdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICt5KSArIFwiaFwiICsgKCt3KSArIFwidlwiICsgKCtoKSArIFwiaFwiICsgKC13KSArIFwiWlwiO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGF0aDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4vY3JlYXRvclwiO1xuaW1wb3J0IHNlbGVjdCBmcm9tIFwiLi9zZWxlY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0KGNyZWF0b3IobmFtZSkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4vbmFtZXNwYWNlXCI7XG5pbXBvcnQge3hodG1sfSBmcm9tIFwiLi9uYW1lc3BhY2VzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgY3JlYXRlfSBmcm9tIFwiLi9jcmVhdGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdG9yfSBmcm9tIFwiLi9jcmVhdG9yXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbG9jYWx9IGZyb20gXCIuL2xvY2FsXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWF0Y2hlcn0gZnJvbSBcIi4vbWF0Y2hlclwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1vdXNlfSBmcm9tIFwiLi9tb3VzZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5hbWVzcGFjZX0gZnJvbSBcIi4vbmFtZXNwYWNlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmFtZXNwYWNlc30gZnJvbSBcIi4vbmFtZXNwYWNlc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNsaWVudFBvaW50fSBmcm9tIFwiLi9wb2ludFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdH0gZnJvbSBcIi4vc2VsZWN0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0QWxsfSBmcm9tIFwiLi9zZWxlY3RBbGxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3Rpb259IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdG9yfSBmcm9tIFwiLi9zZWxlY3RvclwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdG9yQWxsfSBmcm9tIFwiLi9zZWxlY3RvckFsbFwiO1xuZXhwb3J0IHtzdHlsZVZhbHVlIGFzIHN0eWxlfSBmcm9tIFwiLi9zZWxlY3Rpb24vc3R5bGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0b3VjaH0gZnJvbSBcIi4vdG91Y2hcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0b3VjaGVzfSBmcm9tIFwiLi90b3VjaGVzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgd2luZG93fSBmcm9tIFwiLi93aW5kb3dcIjtcbmV4cG9ydCB7ZXZlbnQsIGN1c3RvbUV2ZW50fSBmcm9tIFwiLi9zZWxlY3Rpb24vb25cIjtcbiIsInZhciBuZXh0SWQgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb2NhbCgpIHtcbiAgcmV0dXJuIG5ldyBMb2NhbDtcbn1cblxuZnVuY3Rpb24gTG9jYWwoKSB7XG4gIHRoaXMuXyA9IFwiQFwiICsgKCsrbmV4dElkKS50b1N0cmluZygzNik7XG59XG5cbkxvY2FsLnByb3RvdHlwZSA9IGxvY2FsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExvY2FsLFxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG4gICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIG5vZGVbaWRdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnRcIjtcbmltcG9ydCBwb2ludCBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBldmVudCA9IHNvdXJjZUV2ZW50KCk7XG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykgZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgcmV0dXJuIHBvaW50KG5vZGUsIGV2ZW50KTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2VzIGZyb20gXCIuL25hbWVzcGFjZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xuICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTtcbn1cbiIsImV4cG9ydCB2YXIgeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KSB7XG4gIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuXG4gIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gIH1cblxuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW3NlbGVjdG9yID09IG51bGwgPyBbXSA6IHNlbGVjdG9yXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi4vbmFtZXNwYWNlXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cbiIsImZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgdGhpcy5uZXh0U2libGluZyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY2xvbmVOb2RlKHRydWUpLCB0aGlzLm5leHRTaWJsaW5nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVlcCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZGVlcCA/IHNlbGVjdGlvbl9jbG9uZURlZXAgOiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHtFbnRlck5vZGV9IGZyb20gXCIuL2VudGVyXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4uL2NvbnN0YW50XCI7XG5cbnZhciBrZXlQcmVmaXggPSBcIiRcIjsgLy8gUHJvdGVjdCBhZ2FpbnN0IGtleXMgbGlrZSDigJxfX3Byb3RvX1/igJ0uXG5cbmZ1bmN0aW9uIGJpbmRJbmRleChwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG5vZGUsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAvLyBQdXQgYW55IG51bGwgbm9kZXMgaW50byBlbnRlci5cbiAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cbiAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gIHZhciBpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVCeUtleVZhbHVlID0ge30sXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgICAgaWYgKGtleVZhbHVlIGluIG5vZGVCeUtleVZhbHVlKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICBpZiAobm9kZSA9IG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZXNbaV1dID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIGRhdGEgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBqID0gLTE7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGQpIHsgZGF0YVsrK2pdID0gZDsgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYmluZCA9IGtleSA/IGJpbmRLZXkgOiBiaW5kSW5kZXgsXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gY29uc3RhbnQodmFsdWUpO1xuXG4gIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICBncm91cCA9IGdyb3Vwc1tqXSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGEgPSB2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cyksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93XCI7XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZVwiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSBcIi4uL21hdGNoZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJmdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cbiIsImltcG9ydCBzZWxlY3Rpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0YSBmcm9tIFwiLi9kYXRhXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VudGVyIGZyb20gXCIuL2VudGVyXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2V4aXQgZnJvbSBcIi4vZXhpdFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9qb2luIGZyb20gXCIuL2pvaW5cIjtcbmltcG9ydCBzZWxlY3Rpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2VcIjtcbmltcG9ydCBzZWxlY3Rpb25fb3JkZXIgZnJvbSBcIi4vb3JkZXJcIjtcbmltcG9ydCBzZWxlY3Rpb25fc29ydCBmcm9tIFwiLi9zb3J0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NhbGwgZnJvbSBcIi4vY2FsbFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlcyBmcm9tIFwiLi9ub2Rlc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlIGZyb20gXCIuL25vZGVcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2l6ZSBmcm9tIFwiLi9zaXplXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VtcHR5IGZyb20gXCIuL2VtcHR5XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VhY2ggZnJvbSBcIi4vZWFjaFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9hdHRyIGZyb20gXCIuL2F0dHJcIjtcbmltcG9ydCBzZWxlY3Rpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGVcIjtcbmltcG9ydCBzZWxlY3Rpb25fcHJvcGVydHkgZnJvbSBcIi4vcHJvcGVydHlcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xhc3NlZCBmcm9tIFwiLi9jbGFzc2VkXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RleHQgZnJvbSBcIi4vdGV4dFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9odG1sIGZyb20gXCIuL2h0bWxcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmFpc2UgZnJvbSBcIi4vcmFpc2VcIjtcbmltcG9ydCBzZWxlY3Rpb25fbG93ZXIgZnJvbSBcIi4vbG93ZXJcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXBwZW5kIGZyb20gXCIuL2FwcGVuZFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnNlcnQgZnJvbSBcIi4vaW5zZXJ0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmVcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xvbmUgZnJvbSBcIi4vY2xvbmVcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0dW0gZnJvbSBcIi4vZGF0dW1cIjtcbmltcG9ydCBzZWxlY3Rpb25fb24gZnJvbSBcIi4vb25cIjtcbmltcG9ydCBzZWxlY3Rpb25fZGlzcGF0Y2ggZnJvbSBcIi4vZGlzcGF0Y2hcIjtcblxuZXhwb3J0IHZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBqb2luOiBzZWxlY3Rpb25fam9pbixcbiAgbWVyZ2U6IHNlbGVjdGlvbl9tZXJnZSxcbiAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gIGNhbGw6IHNlbGVjdGlvbl9jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3NpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICBhdHRyOiBzZWxlY3Rpb25fYXR0cixcbiAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgY2xhc3NlZDogc2VsZWN0aW9uX2NsYXNzZWQsXG4gIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgcmFpc2U6IHNlbGVjdGlvbl9yYWlzZSxcbiAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICBpbnNlcnQ6IHNlbGVjdGlvbl9pbnNlcnQsXG4gIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcbiAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgb246IHNlbGVjdGlvbl9vbixcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaFxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VsZWN0aW9uO1xuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3JcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3JcIjtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9uZW50ZXIsIG9udXBkYXRlLCBvbmV4aXQpIHtcbiAgdmFyIGVudGVyID0gdGhpcy5lbnRlcigpLCB1cGRhdGUgPSB0aGlzLCBleGl0ID0gdGhpcy5leGl0KCk7XG4gIGVudGVyID0gdHlwZW9mIG9uZW50ZXIgPT09IFwiZnVuY3Rpb25cIiA/IG9uZW50ZXIoZW50ZXIpIDogZW50ZXIuYXBwZW5kKG9uZW50ZXIgKyBcIlwiKTtcbiAgaWYgKG9udXBkYXRlICE9IG51bGwpIHVwZGF0ZSA9IG9udXBkYXRlKHVwZGF0ZSk7XG4gIGlmIChvbmV4aXQgPT0gbnVsbCkgZXhpdC5yZW1vdmUoKTsgZWxzZSBvbmV4aXQoZXhpdCk7XG4gIHJldHVybiBlbnRlciAmJiB1cGRhdGUgPyBlbnRlci5tZXJnZSh1cGRhdGUpLm9yZGVyKCkgOiB1cGRhdGU7XG59XG4iLCJmdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGkgPSAtMTtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBub2Rlc1srK2ldID0gdGhpczsgfSk7XG4gIHJldHVybiBub2Rlcztcbn1cbiIsInZhciBmaWx0ZXJFdmVudHMgPSB7fTtcblxuZXhwb3J0IHZhciBldmVudCA9IG51bGw7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICghKFwib25tb3VzZWVudGVyXCIgaW4gZWxlbWVudCkpIHtcbiAgICBmaWx0ZXJFdmVudHMgPSB7bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIiwgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwifTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJDb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGhpcyAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcykgJiA4KSkpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50MSkge1xuICAgIHZhciBldmVudDAgPSBldmVudDsgLy8gRXZlbnRzIGNhbiBiZSByZWVudHJhbnQgKGUuZy4sIGZvY3VzKS5cbiAgICBldmVudCA9IGV2ZW50MTtcbiAgICB0cnkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCB0aGlzLl9fZGF0YV9fLCBpbmRleCwgZ3JvdXApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBldmVudCA9IGV2ZW50MDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIGNhcHR1cmUpIHtcbiAgdmFyIHdyYXAgPSBmaWx0ZXJFdmVudHMuaGFzT3duUHJvcGVydHkodHlwZW5hbWUudHlwZSkgPyBmaWx0ZXJDb250ZXh0TGlzdGVuZXIgOiBjb250ZXh0TGlzdGVuZXI7XG4gIHJldHVybiBmdW5jdGlvbihkLCBpLCBncm91cCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSB3cmFwKHZhbHVlLCBpLCBncm91cCk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5jYXB0dXJlID0gY2FwdHVyZSk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIGNhcHR1cmU6IGNhcHR1cmV9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgaWYgKGNhcHR1cmUgPT0gbnVsbCkgY2FwdHVyZSA9IGZhbHNlO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgY2FwdHVyZSkpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbUV2ZW50KGV2ZW50MSwgbGlzdGVuZXIsIHRoYXQsIGFyZ3MpIHtcbiAgdmFyIGV2ZW50MCA9IGV2ZW50O1xuICBldmVudDEuc291cmNlRXZlbnQgPSBldmVudDtcbiAgZXZlbnQgPSBldmVudDE7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9IGZpbmFsbHkge1xuICAgIGV2ZW50ID0gZXZlbnQwO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5leHQpIF4gNCkgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn1cbiIsImZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3RvclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHNlbGVjdG9yQWxsIGZyb20gXCIuLi9zZWxlY3RvckFsbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzdWJncm91cHMucHVzaChzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCBwYXJlbnRzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgKytzaXplOyB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3dcIjtcblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG59XG4iLCJmdW5jdGlvbiBub25lKCkge31cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJmdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJpbXBvcnQge2V2ZW50fSBmcm9tIFwiLi9zZWxlY3Rpb24vb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJyZW50ID0gZXZlbnQsIHNvdXJjZTtcbiAgd2hpbGUgKHNvdXJjZSA9IGN1cnJlbnQuc291cmNlRXZlbnQpIGN1cnJlbnQgPSBzb3VyY2U7XG4gIHJldHVybiBjdXJyZW50O1xufVxuIiwiaW1wb3J0IHNvdXJjZUV2ZW50IGZyb20gXCIuL3NvdXJjZUV2ZW50XCI7XG5pbXBvcnQgcG9pbnQgZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgdG91Y2hlcywgaWRlbnRpZmllcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGlkZW50aWZpZXIgPSB0b3VjaGVzLCB0b3VjaGVzID0gc291cmNlRXZlbnQoKS5jaGFuZ2VkVG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCh0b3VjaCA9IHRvdWNoZXNbaV0pLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiBwb2ludChub2RlLCB0b3VjaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnRcIjtcbmltcG9ydCBwb2ludCBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB0b3VjaGVzKSB7XG4gIGlmICh0b3VjaGVzID09IG51bGwpIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLnRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCBwb2ludHMgPSBuZXcgQXJyYXkobik7IGkgPCBuOyArK2kpIHtcbiAgICBwb2ludHNbaV0gPSBwb2ludChub2RlLCB0b3VjaGVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGFyY30gZnJvbSBcIi4vc3JjL2FyY1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGFyZWF9IGZyb20gXCIuL3NyYy9hcmVhXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbGluZX0gZnJvbSBcIi4vc3JjL2xpbmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwaWV9IGZyb20gXCIuL3NyYy9waWVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyByYWRpYWxBcmVhfSBmcm9tIFwiLi9zcmMvcmFkaWFsQXJlYVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhZGlhbExpbmV9IGZyb20gXCIuL3NyYy9yYWRpYWxMaW5lXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2wsIHN5bWJvbHN9IGZyb20gXCIuL3NyYy9zeW1ib2xcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xDaXJjbGV9IGZyb20gXCIuL3NyYy9zeW1ib2wvY2lyY2xlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sQ3Jvc3N9IGZyb20gXCIuL3NyYy9zeW1ib2wvY3Jvc3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xEaWFtb25kfSBmcm9tIFwiLi9zcmMvc3ltYm9sL2RpYW1vbmRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xTcXVhcmV9IGZyb20gXCIuL3NyYy9zeW1ib2wvc3F1YXJlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sU3Rhcn0gZnJvbSBcIi4vc3JjL3N5bWJvbC9zdGFyXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sVHJpYW5nbGV9IGZyb20gXCIuL3NyYy9zeW1ib2wvdHJpYW5nbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xXeWV9IGZyb20gXCIuL3NyYy9zeW1ib2wvd3llXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUJhc2lzQ2xvc2VkfSBmcm9tIFwiLi9zcmMvY3VydmUvYmFzaXNDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUJhc2lzT3Blbn0gZnJvbSBcIi4vc3JjL2N1cnZlL2Jhc2lzT3BlblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXN9IGZyb20gXCIuL3NyYy9jdXJ2ZS9iYXNpc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQnVuZGxlfSBmcm9tIFwiLi9zcmMvY3VydmUvYnVuZGxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVDYXJkaW5hbENsb3NlZH0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhcmRpbmFsQ2xvc2VkXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVDYXJkaW5hbE9wZW59IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXJkaW5hbE9wZW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsfSBmcm9tIFwiLi9zcmMvY3VydmUvY2FyZGluYWxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb21DbG9zZWR9IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tQ2xvc2VkXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVDYXRtdWxsUm9tT3Blbn0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhdG11bGxSb21PcGVuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVDYXRtdWxsUm9tfSBmcm9tIFwiLi9zcmMvY3VydmUvY2F0bXVsbFJvbVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlTGluZWFyQ2xvc2VkfSBmcm9tIFwiLi9zcmMvY3VydmUvbGluZWFyQ2xvc2VkXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVMaW5lYXJ9IGZyb20gXCIuL3NyYy9jdXJ2ZS9saW5lYXJcIjtcbmV4cG9ydCB7bW9ub3RvbmVYIGFzIGN1cnZlTW9ub3RvbmVYLCBtb25vdG9uZVkgYXMgY3VydmVNb25vdG9uZVl9IGZyb20gXCIuL3NyYy9jdXJ2ZS9tb25vdG9uZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlTmF0dXJhbH0gZnJvbSBcIi4vc3JjL2N1cnZlL25hdHVyYWxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZVN0ZXAsIHN0ZXBBZnRlciBhcyBjdXJ2ZVN0ZXBBZnRlciwgc3RlcEJlZm9yZSBhcyBjdXJ2ZVN0ZXBCZWZvcmV9IGZyb20gXCIuL3NyYy9jdXJ2ZS9zdGVwXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja30gZnJvbSBcIi4vc3JjL3N0YWNrXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXRFeHBhbmR9IGZyb20gXCIuL3NyYy9vZmZzZXQvZXhwYW5kXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXROb25lfSBmcm9tIFwiLi9zcmMvb2Zmc2V0L25vbmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldFNpbGhvdWV0dGV9IGZyb20gXCIuL3NyYy9vZmZzZXQvc2lsaG91ZXR0ZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT2Zmc2V0V2lnZ2xlfSBmcm9tIFwiLi9zcmMvb2Zmc2V0L3dpZ2dsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJBc2NlbmRpbmd9IGZyb20gXCIuL3NyYy9vcmRlci9hc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyRGVzY2VuZGluZ30gZnJvbSBcIi4vc3JjL29yZGVyL2Rlc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVySW5zaWRlT3V0fSBmcm9tIFwiLi9zcmMvb3JkZXIvaW5zaWRlT3V0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlck5vbmV9IGZyb20gXCIuL3NyYy9vcmRlci9ub25lXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlclJldmVyc2V9IGZyb20gXCIuL3NyYy9vcmRlci9yZXZlcnNlXCI7XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCB7ZXBzaWxvbiwgcGksIGhhbGZQaSwgdGF1fSBmcm9tIFwiLi9tYXRoXCI7XG5cbmZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxufVxuXG5mdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPj0gMSA/IGhhbGZQaSA6IHggPD0gLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLFxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcbiAgICAgIHQgPSAoeDMyICogKHkwIC0geTIpIC0geTMyICogKHgwIC0geDIpKSAvICh5MzIgKiB4MTAgLSB4MzIgKiB5MTApO1xuICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbn1cblxuLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY29ybmVyVGFuZ2VudHMoeDAsIHkwLCB4MSwgeTEsIHIxLCByYywgY3cpIHtcbiAgdmFyIHgwMSA9IHgwIC0geDEsXG4gICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBNYXRoLnNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSxcbiAgICAgIG94ID0gbG8gKiB5MDEsXG4gICAgICBveSA9IC1sbyAqIHgwMSxcbiAgICAgIHgxMSA9IHgwICsgb3gsXG4gICAgICB5MTEgPSB5MCArIG95LFxuICAgICAgeDEwID0geDEgKyBveCxcbiAgICAgIHkxMCA9IHkxICsgb3ksXG4gICAgICB4MDAgPSAoeDExICsgeDEwKSAvIDIsXG4gICAgICB5MDAgPSAoeTExICsgeTEwKSAvIDIsXG4gICAgICBkeCA9IHgxMCAtIHgxMSxcbiAgICAgIGR5ID0geTEwIC0geTExLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIHIgPSByMSAtIHJjLFxuICAgICAgRCA9IHgxMSAqIHkxMCAtIHgxMCAqIHkxMSxcbiAgICAgIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIE1hdGguc3FydChNYXRoLm1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSxcbiAgICAgIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMixcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMixcbiAgICAgIGR4MCA9IGN4MCAtIHgwMCxcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcbiAgICAgIGR4MSA9IGN4MSAtIHgwMCxcbiAgICAgIGR5MSA9IGN5MSAtIHkwMDtcblxuICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBhcmNPdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvbnN0YW50KDApLFxuICAgICAgcGFkUmFkaXVzID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBhcmNTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBhcmNFbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgcixcbiAgICAgICAgcjAgPSAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgcjEgPSArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgZGEgPSBNYXRoLmFicyhhMSAtIGEwKSxcbiAgICAgICAgY3cgPSBhMSA+IGEwO1xuXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIG91dGVyIHJhZGl1cyBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIHJhZGl1cy5cbiAgICBpZiAocjEgPCByMCkgciA9IHIxLCByMSA9IHIwLCByMCA9IHI7XG5cbiAgICAvLyBJcyBpdCBhIHBvaW50P1xuICAgIGlmICghKHIxID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKDAsIDApO1xuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjbGUgb3IgYW5udWx1cz9cbiAgICBlbHNlIGlmIChkYSA+IHRhdSAtIGVwc2lsb24pIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHIxICogTWF0aC5jb3MoYTApLCByMSAqIE1hdGguc2luKGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAsIGExLCAhY3cpO1xuICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIE1hdGguY29zKGExKSwgcjAgKiBNYXRoLnNpbihhMSkpO1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEsIGEwLCBjdyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjdWxhciBvciBhbm51bGFyIHNlY3Rvcj9cbiAgICBlbHNlIHtcbiAgICAgIHZhciBhMDEgPSBhMCxcbiAgICAgICAgICBhMTEgPSBhMSxcbiAgICAgICAgICBhMDAgPSBhMCxcbiAgICAgICAgICBhMTAgPSBhMSxcbiAgICAgICAgICBkYTAgPSBkYSxcbiAgICAgICAgICBkYTEgPSBkYSxcbiAgICAgICAgICBhcCA9IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLyAyLFxuICAgICAgICAgIHJwID0gKGFwID4gZXBzaWxvbikgJiYgKHBhZFJhZGl1cyA/ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IE1hdGguc3FydChyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gTWF0aC5taW4oTWF0aC5hYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICAgIHJjMCA9IHJjLFxuICAgICAgICAgIHJjMSA9IHJjLFxuICAgICAgICAgIHQwLFxuICAgICAgICAgIHQxO1xuXG4gICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cbiAgICAgIGlmIChycCA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHAwID0gYXNpbihycCAvIHIwICogTWF0aC5zaW4oYXApKSxcbiAgICAgICAgICAgIHAxID0gYXNpbihycCAvIHIxICogTWF0aC5zaW4oYXApKTtcbiAgICAgICAgaWYgKChkYTAgLT0gcDAgKiAyKSA+IGVwc2lsb24pIHAwICo9IChjdyA/IDEgOiAtMSksIGEwMCArPSBwMCwgYTEwIC09IHAwO1xuICAgICAgICBlbHNlIGRhMCA9IDAsIGEwMCA9IGExMCA9IChhMCArIGExKSAvIDI7XG4gICAgICAgIGlmICgoZGExIC09IHAxICogMikgPiBlcHNpbG9uKSBwMSAqPSAoY3cgPyAxIDogLTEpLCBhMDEgKz0gcDEsIGExMSAtPSBwMTtcbiAgICAgICAgZWxzZSBkYTEgPSAwLCBhMDEgPSBhMTEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDAxID0gcjEgKiBNYXRoLmNvcyhhMDEpLFxuICAgICAgICAgIHkwMSA9IHIxICogTWF0aC5zaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIE1hdGguY29zKGExMCksXG4gICAgICAgICAgeTEwID0gcjAgKiBNYXRoLnNpbihhMTApO1xuXG4gICAgICAvLyBBcHBseSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBpZiAocmMgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciB4MTEgPSByMSAqIE1hdGguY29zKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIE1hdGguc2luKGExMSksXG4gICAgICAgICAgICB4MDAgPSByMCAqIE1hdGguY29zKGEwMCksXG4gICAgICAgICAgICB5MDAgPSByMCAqIE1hdGguc2luKGEwMCk7XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIGNvcm5lciByYWRpdXMgYWNjb3JkaW5nIHRvIHRoZSBzZWN0b3IgYW5nbGUuXG4gICAgICAgIGlmIChkYSA8IHBpKSB7XG4gICAgICAgICAgdmFyIG9jID0gZGEwID4gZXBzaWxvbiA/IGludGVyc2VjdCh4MDEsIHkwMSwgeDAwLCB5MDAsIHgxMSwgeTExLCB4MTAsIHkxMCkgOiBbeDEwLCB5MTBdLFxuICAgICAgICAgICAgICBheCA9IHgwMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBheSA9IHkwMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBieCA9IHgxMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBieSA9IHkxMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBrYyA9IDEgLyBNYXRoLnNpbihNYXRoLmFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkpICogTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksXG4gICAgICAgICAgICAgIGxjID0gTWF0aC5zcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICByYzAgPSBNYXRoLm1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgIHJjMSA9IE1hdGgubWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSXMgdGhlIHNlY3RvciBjb2xsYXBzZWQgdG8gYSBsaW5lP1xuICAgICAgaWYgKCEoZGExID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzEgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIE1hdGguYXRhbjIodDAueTAxLCB0MC54MDEpLCBNYXRoLmF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIE1hdGguYXRhbjIodDAueTAxLCB0MC54MDEpLCBNYXRoLmF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgTWF0aC5hdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBNYXRoLmF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIE1hdGguYXRhbjIodDEueTExLCB0MS54MTEpLCBNYXRoLmF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgb3V0ZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSksIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMDEsIGExMSwgIWN3KTtcblxuICAgICAgLy8gSXMgdGhlcmUgbm8gaW5uZXIgcmluZywgYW5kIGl04oCZcyBhIGNpcmN1bGFyIHNlY3Rvcj9cbiAgICAgIC8vIE9yIHBlcmhhcHMgaXTigJlzIGFuIGFubnVsYXIgc2VjdG9yIGNvbGxhcHNlZCBkdWUgdG8gcGFkZGluZz9cbiAgICAgIGlmICghKHIwID4gZXBzaWxvbikgfHwgIShkYTAgPiBlcHNpbG9uKSkgY29udGV4dC5saW5lVG8oeDEwLCB5MTApO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMCA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MTAsIHkxMCwgeDExLCB5MTEsIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDAxLCB5MDEsIHgwMCwgeTAwLCByMCwgLXJjMCwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzAgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIE1hdGguYXRhbjIodDAueTAxLCB0MC54MDEpLCBNYXRoLmF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIE1hdGguYXRhbjIodDAueTAxLCB0MC54MDEpLCBNYXRoLmF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgTWF0aC5hdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBNYXRoLmF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMCwgTWF0aC5hdGFuMih0MS55MTEsIHQxLngxMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBpbm5lciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMixcbiAgICAgICAgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIHBpIC8gMjtcbiAgICByZXR1cm4gW01hdGguY29zKGEpICogciwgTWF0aC5zaW4oYSkgKiByXTtcbiAgfTtcblxuICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW5uZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGlubmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvdXRlclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogb3V0ZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZFJhZGl1cyA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZFJhZGl1cztcbiAgfTtcblxuICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRBbmdsZTtcbiAgfTtcblxuICBhcmMuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgYXJjKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyYztcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhclwiO1xuaW1wb3J0IGxpbmUgZnJvbSBcIi4vbGluZVwiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgeDAgPSBwb2ludFgsXG4gICAgICB4MSA9IG51bGwsXG4gICAgICB5MCA9IGNvbnN0YW50KDApLFxuICAgICAgeTEgPSBwb2ludFksXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgeDB6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7XG4gICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFTdGFydCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGsgPSBpIC0gMTsgayA+PSBqOyAtLWspIHtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MHpba10sIHkweltrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSB7XG4gICAgICAgIHgweltpXSA9ICt4MChkLCBpLCBkYXRhKSwgeTB6W2ldID0gK3kwKGQsIGksIGRhdGEpO1xuICAgICAgICBvdXRwdXQucG9pbnQoeDEgPyAreDEoZCwgaSwgZGF0YSkgOiB4MHpbaV0sIHkxID8gK3kxKGQsIGksIGRhdGEpIDogeTB6W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlYWxpbmUoKSB7XG4gICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHgxID0gbnVsbCwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MTtcbiAgfTtcblxuICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeTEgPSBudWxsLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkxO1xuICB9O1xuXG4gIGFyZWEubGluZVgwID1cbiAgYXJlYS5saW5lWTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmxpbmVZMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xuICB9O1xuXG4gIGFyZWEubGluZVgxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MSkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGFyZWEpIDogZGVmaW5lZDtcbiAgfTtcblxuICBhcmVhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XG4gIH07XG5cbiAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBhcmVhKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyZWE7XG59XG4iLCJleHBvcnQgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgKDIgKiB0aGF0Ll94MCArIHRoYXQuX3gxKSAvIDMsXG4gICAgKDIgKiB0aGF0Ll95MCArIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgMiAqIHRoYXQuX3gxKSAvIDMsXG4gICAgKHRoYXQuX3kwICsgMiAqIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgNCAqIHRoYXQuX3gxICsgeCkgLyA2LFxuICAgICh0aGF0Ll95MCArIDQgKiB0aGF0Ll95MSArIHkpIC8gNlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQmFzaXMoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXMucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IC8vIHByb2NlZWRcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9jb250ZXh0LmxpbmVUbygoNSAqIHRoaXMuX3gwICsgdGhpcy5feDEpIC8gNiwgKDUgKiB0aGlzLl95MCArIHRoaXMuX3kxKSAvIDYpOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpcyhjb250ZXh0KTtcbn1cbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCYXNpc0Nsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc0Nsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MiArIDIgKiB0aGlzLl94MykgLyAzLCAodGhpcy5feTIgKyAyICogdGhpcy5feTMpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKCh0aGlzLl94MyArIDIgKiB0aGlzLl94MikgLyAzLCAodGhpcy5feTMgKyAyICogdGhpcy5feTIpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDIgPSB4LCB0aGlzLl95MiA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geTsgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDYpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzQ2xvc2VkKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vYmFzaXNcIjtcblxuZnVuY3Rpb24gQmFzaXNPcGVuKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHZhciB4MCA9ICh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgeTAgPSAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDY7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MCwgeTApIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeDAsIHkwKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNPcGVuKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtCYXNpc30gZnJvbSBcIi4vYmFzaXNcIjtcblxuZnVuY3Rpb24gQnVuZGxlKGNvbnRleHQsIGJldGEpIHtcbiAgdGhpcy5fYmFzaXMgPSBuZXcgQmFzaXMoY29udGV4dCk7XG4gIHRoaXMuX2JldGEgPSBiZXRhO1xufVxuXG5CdW5kbGUucHJvdG90eXBlID0ge1xuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gICAgdGhpcy5fYmFzaXMubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIGogPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoaiA+IDApIHtcbiAgICAgIHZhciB4MCA9IHhbMF0sXG4gICAgICAgICAgeTAgPSB5WzBdLFxuICAgICAgICAgIGR4ID0geFtqXSAtIHgwLFxuICAgICAgICAgIGR5ID0geVtqXSAtIHkwLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICB0O1xuXG4gICAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgICAgdCA9IGkgLyBqO1xuICAgICAgICB0aGlzLl9iYXNpcy5wb2ludChcbiAgICAgICAgICB0aGlzLl9iZXRhICogeFtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeDAgKyB0ICogZHgpLFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB5W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh5MCArIHQgKiBkeSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gICAgdGhpcy5fYmFzaXMubGluZUVuZCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShiZXRhKSB7XG5cbiAgZnVuY3Rpb24gYnVuZGxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYmV0YSA9PT0gMSA/IG5ldyBCYXNpcyhjb250ZXh0KSA6IG5ldyBCdW5kbGUoY29udGV4dCwgYmV0YSk7XG4gIH1cblxuICBidW5kbGUuYmV0YSA9IGZ1bmN0aW9uKGJldGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCtiZXRhKTtcbiAgfTtcblxuICByZXR1cm4gYnVuZGxlO1xufSkoMC44NSk7XG4iLCJleHBvcnQgZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgdGhhdC5feDEgKyB0aGF0Ll9rICogKHRoYXQuX3gyIC0gdGhhdC5feDApLFxuICAgIHRoYXQuX3kxICsgdGhhdC5fayAqICh0aGF0Ll95MiAtIHRoYXQuX3kwKSxcbiAgICB0aGF0Ll94MiArIHRoYXQuX2sgKiAodGhhdC5feDEgLSB4KSxcbiAgICB0aGF0Ll95MiArIHRoYXQuX2sgKiAodGhhdC5feTEgLSB5KSxcbiAgICB0aGF0Ll94MixcbiAgICB0aGF0Ll95MlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gxID0geCwgdGhpcy5feTEgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbENsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2FyZGluYWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcbiIsImltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGhcIjtcbmltcG9ydCB7Q2FyZGluYWx9IGZyb20gXCIuL2NhcmRpbmFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHZhciB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIHgyID0gdGhhdC5feDIsXG4gICAgICB5MiA9IHRoYXQuX3kyO1xuXG4gIGlmICh0aGF0Ll9sMDFfYSA+IGVwc2lsb24pIHtcbiAgICB2YXIgYSA9IDIgKiB0aGF0Ll9sMDFfMmEgKyAzICogdGhhdC5fbDAxX2EgKiB0aGF0Ll9sMTJfYSArIHRoYXQuX2wxMl8yYSxcbiAgICAgICAgbiA9IDMgKiB0aGF0Ll9sMDFfYSAqICh0aGF0Ll9sMDFfYSArIHRoYXQuX2wxMl9hKTtcbiAgICB4MSA9ICh4MSAqIGEgLSB0aGF0Ll94MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3gyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gICAgeTEgPSAoeTEgKiBhIC0gdGhhdC5feTAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll95MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICB9XG5cbiAgaWYgKHRoYXQuX2wyM19hID4gZXBzaWxvbikge1xuICAgIHZhciBiID0gMiAqIHRoYXQuX2wyM18yYSArIDMgKiB0aGF0Ll9sMjNfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBtID0gMyAqIHRoYXQuX2wyM19hICogKHRoYXQuX2wyM19hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgyID0gKHgyICogYiArIHRoYXQuX3gxICogdGhhdC5fbDIzXzJhIC0geCAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICAgIHkyID0gKHkyICogYiArIHRoYXQuX3kxICogdGhhdC5fbDIzXzJhIC0geSAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICB9XG5cbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB0aGF0Ll94MiwgdGhhdC5feTIpO1xufVxuXG5mdW5jdGlvbiBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWwoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuIiwiaW1wb3J0IHtDYXJkaW5hbENsb3NlZH0gZnJvbSBcIi4vY2FyZGluYWxDbG9zZWRcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb21DbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuIiwiaW1wb3J0IHtDYXJkaW5hbE9wZW59IGZyb20gXCIuL2NhcmRpbmFsT3BlblwiO1xuaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2F0bXVsbFJvbVwiO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbU9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJmdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcblxuZnVuY3Rpb24gTGluZWFyQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhckNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGVsc2UgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhckNsb3NlZChjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgc2xvcGVzIG9mIHRoZSB0YW5nZW50cyAoSGVybWl0ZS10eXBlIGludGVycG9sYXRpb24pIGJhc2VkIG9uXG4vLyB0aGUgZm9sbG93aW5nIHBhcGVyOiBTdGVmZmVuLCBNLiAxOTkwLiBBIFNpbXBsZSBNZXRob2QgZm9yIE1vbm90b25pY1xuLy8gSW50ZXJwb2xhdGlvbiBpbiBPbmUgRGltZW5zaW9uLiBBc3Ryb25vbXkgYW5kIEFzdHJvcGh5c2ljcywgVm9sLiAyMzksIE5PLlxuLy8gTk9WKElJKSwgUC4gNDQzLCAxOTkwLlxuZnVuY3Rpb24gc2xvcGUzKHRoYXQsIHgyLCB5Mikge1xuICB2YXIgaDAgPSB0aGF0Ll94MSAtIHRoYXQuX3gwLFxuICAgICAgaDEgPSB4MiAtIHRoYXQuX3gxLFxuICAgICAgczAgPSAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyAoaDAgfHwgaDEgPCAwICYmIC0wKSxcbiAgICAgIHMxID0gKHkyIC0gdGhhdC5feTEpIC8gKGgxIHx8IGgwIDwgMCAmJiAtMCksXG4gICAgICBwID0gKHMwICogaDEgKyBzMSAqIGgwKSAvIChoMCArIGgxKTtcbiAgcmV0dXJuIChzaWduKHMwKSArIHNpZ24oczEpKSAqIE1hdGgubWluKE1hdGguYWJzKHMwKSwgTWF0aC5hYnMoczEpLCAwLjUgKiBNYXRoLmFicyhwKSkgfHwgMDtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgb25lLXNpZGVkIHNsb3BlLlxuZnVuY3Rpb24gc2xvcGUyKHRoYXQsIHQpIHtcbiAgdmFyIGggPSB0aGF0Ll94MSAtIHRoYXQuX3gwO1xuICByZXR1cm4gaCA/ICgzICogKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gaCAtIHQpIC8gMiA6IHQ7XG59XG5cbi8vIEFjY29yZGluZyB0byBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSNSZXByZXNlbnRhdGlvbnNcbi8vIFwieW91IGNhbiBleHByZXNzIGN1YmljIEhlcm1pdGUgaW50ZXJwb2xhdGlvbiBpbiB0ZXJtcyBvZiBjdWJpYyBCw6l6aWVyIGN1cnZlc1xuLy8gd2l0aCByZXNwZWN0IHRvIHRoZSBmb3VyIHZhbHVlcyBwMCwgcDAgKyBtMCAvIDMsIHAxIC0gbTEgLyAzLCBwMVwiLlxuZnVuY3Rpb24gcG9pbnQodGhhdCwgdDAsIHQxKSB7XG4gIHZhciB4MCA9IHRoYXQuX3gwLFxuICAgICAgeTAgPSB0aGF0Ll95MCxcbiAgICAgIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgZHggPSAoeDEgLSB4MCkgLyAzO1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDAgKyBkeCwgeTAgKyBkeCAqIHQwLCB4MSAtIGR4LCB5MSAtIGR4ICogdDEsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5Nb25vdG9uZVgucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPVxuICAgIHRoaXMuX3QwID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5fdDAsIHNsb3BlMih0aGlzLCB0aGlzLl90MCkpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdDEgPSBOYU47XG5cbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAoeCA9PT0gdGhpcy5feDEgJiYgeSA9PT0gdGhpcy5feTEpIHJldHVybjsgLy8gSWdub3JlIGNvaW5jaWRlbnQgcG9pbnRzLlxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgcG9pbnQodGhpcywgc2xvcGUyKHRoaXMsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKSwgdDEpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHRoaXMuX3QwLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gICAgdGhpcy5fdDAgPSB0MTtcbiAgfVxufVxuXG5mdW5jdGlvbiBNb25vdG9uZVkoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gbmV3IFJlZmxlY3RDb250ZXh0KGNvbnRleHQpO1xufVxuXG4oTW9ub3RvbmVZLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9ub3RvbmVYLnByb3RvdHlwZSkpLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICBNb25vdG9uZVgucHJvdG90eXBlLnBvaW50LmNhbGwodGhpcywgeSwgeCk7XG59O1xuXG5mdW5jdGlvbiBSZWZsZWN0Q29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZsZWN0Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh5LCB4KTsgfSxcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubGluZVRvKHksIHgpOyB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkgeyB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oeTEsIHgxLCB5MiwgeDIsIHksIHgpOyB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVgoY29udGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVkoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWShjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIE5hdHVyYWwoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTmF0dXJhbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKG4pIHtcbiAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzBdLCB5WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHhbMF0sIHlbMF0pO1xuICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeFsxXSwgeVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHggPSBjb250cm9sUG9pbnRzKHgpLFxuICAgICAgICAgICAgcHkgPSBjb250cm9sUG9pbnRzKHkpO1xuICAgICAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMTsgaTEgPCBuOyArK2kwLCArK2kxKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHB4WzBdW2kwXSwgcHlbMF1baTBdLCBweFsxXVtpMF0sIHB5WzFdW2kwXSwgeFtpMV0sIHlbaTFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIG4gPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG4vLyBTZWUgaHR0cHM6Ly93d3cucGFydGljbGVpbmNlbGwuY29tLzIwMTIvYmV6aWVyLXNwbGluZXMvIGZvciBkZXJpdmF0aW9uLlxuZnVuY3Rpb24gY29udHJvbFBvaW50cyh4KSB7XG4gIHZhciBpLFxuICAgICAgbiA9IHgubGVuZ3RoIC0gMSxcbiAgICAgIG0sXG4gICAgICBhID0gbmV3IEFycmF5KG4pLFxuICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkobik7XG4gIGFbMF0gPSAwLCBiWzBdID0gMiwgclswXSA9IHhbMF0gKyAyICogeFsxXTtcbiAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpIGFbaV0gPSAxLCBiW2ldID0gNCwgcltpXSA9IDQgKiB4W2ldICsgMiAqIHhbaSArIDFdO1xuICBhW24gLSAxXSA9IDIsIGJbbiAtIDFdID0gNywgcltuIC0gMV0gPSA4ICogeFtuIC0gMV0gKyB4W25dO1xuICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSBtID0gYVtpXSAvIGJbaSAtIDFdLCBiW2ldIC09IG0sIHJbaV0gLT0gbSAqIHJbaSAtIDFdO1xuICBhW24gLSAxXSA9IHJbbiAtIDFdIC8gYltuIC0gMV07XG4gIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkgYVtpXSA9IChyW2ldIC0gYVtpICsgMV0pIC8gYltpXTtcbiAgYltuIC0gMV0gPSAoeFtuXSArIGFbbiAtIDFdKSAvIDI7XG4gIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgKytpKSBiW2ldID0gMiAqIHhbaSArIDFdIC0gYVtpICsgMV07XG4gIHJldHVybiBbYSwgYl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBOYXR1cmFsKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2xpbmVhclwiO1xuXG5leHBvcnQgdmFyIGN1cnZlUmFkaWFsTGluZWFyID0gY3VydmVSYWRpYWwoY3VydmVMaW5lYXIpO1xuXG5mdW5jdGlvbiBSYWRpYWwoY3VydmUpIHtcbiAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcbn1cblxuUmFkaWFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhU3RhcnQoKTtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUuYXJlYUVuZCgpO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVTdGFydCgpO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihhLCByKSB7XG4gICAgdGhpcy5fY3VydmUucG9pbnQociAqIE1hdGguc2luKGEpLCByICogLU1hdGguY29zKGEpKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3VydmVSYWRpYWwoY3VydmUpIHtcblxuICBmdW5jdGlvbiByYWRpYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUmFkaWFsKGN1cnZlKGNvbnRleHQpKTtcbiAgfVxuXG4gIHJhZGlhbC5fY3VydmUgPSBjdXJ2ZTtcblxuICByZXR1cm4gcmFkaWFsO1xufVxuIiwiZnVuY3Rpb24gU3RlcChjb250ZXh0LCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl90ID0gdDtcbn1cblxuU3RlcC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoMCA8IHRoaXMuX3QgJiYgdGhpcy5fdCA8IDEgJiYgdGhpcy5fcG9pbnQgPT09IDIpIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBpZiAodGhpcy5fbGluZSA+PSAwKSB0aGlzLl90ID0gMSAtIHRoaXMuX3QsIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX3QgPD0gMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4MSA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgeCAqIHRoaXMuX3Q7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHRoaXMuX3kpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwLjUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEJlZm9yZShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBBZnRlcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAxKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICByZXR1cm4gZDtcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhclwiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHBvaW50WCxcbiAgICAgIHkgPSBwb2ludFksXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSBvdXRwdXQucG9pbnQoK3goZCwgaSwgZGF0YSksICt5KGQsIGksIGRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB4O1xuICB9O1xuXG4gIGxpbmUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeTtcbiAgfTtcblxuICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgbGluZSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGxpbmUuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgbGluZSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBsaW5lLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmUpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluZTtcbn1cbiIsImV4cG9ydCB2YXIgZXBzaWxvbiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgdGF1ID0gMiAqIHBpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpLCBuLCBqID0gMCwgbSA9IHNlcmllc1swXS5sZW5ndGgsIHk7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHkgPSBpID0gMDsgaSA8IG47ICsraSkgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcbiAgICBpZiAoeSkgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc2VyaWVzW2ldW2pdWzFdIC89IHk7XG4gIH1cbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDEpKSByZXR1cm47XG4gIGZvciAodmFyIGkgPSAxLCBzMCwgczEgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgczAgPSBzMSwgczEgPSBzZXJpZXNbb3JkZXJbaV1dO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGogPSAwLCBzMCA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMC5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgeSA9IDA7IGkgPCBuOyArK2kpIHkgKz0gc2VyaWVzW2ldW2pdWzFdIHx8IDA7XG4gICAgczBbal1bMV0gKz0gczBbal1bMF0gPSAteSAvIDI7XG4gIH1cbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkgfHwgISgobSA9IChzMCA9IHNlcmllc1tvcmRlclswXV0pLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciB5ID0gMCwgaiA9IDEsIHMwLCBtLCBuOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHMxID0gMCwgczIgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgc2kgPSBzZXJpZXNbb3JkZXJbaV1dLFxuICAgICAgICAgIHNpajAgPSBzaVtqXVsxXSB8fCAwLFxuICAgICAgICAgIHNpajEgPSBzaVtqIC0gMV1bMV0gfHwgMCxcbiAgICAgICAgICBzMyA9IChzaWowIC0gc2lqMSkgLyAyO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpOyArK2spIHtcbiAgICAgICAgdmFyIHNrID0gc2VyaWVzW29yZGVyW2tdXSxcbiAgICAgICAgICAgIHNrajAgPSBza1tqXVsxXSB8fCAwLFxuICAgICAgICAgICAgc2tqMSA9IHNrW2ogLSAxXVsxXSB8fCAwO1xuICAgICAgICBzMyArPSBza2owIC0gc2tqMTtcbiAgICAgIH1cbiAgICAgIHMxICs9IHNpajAsIHMyICs9IHMzICogc2lqMDtcbiAgICB9XG4gICAgczBbaiAtIDFdWzFdICs9IHMwW2ogLSAxXVswXSA9IHk7XG4gICAgaWYgKHMxKSB5IC09IHMyIC8gczE7XG4gIH1cbiAgczBbaiAtIDFdWzFdICs9IHMwW2ogLSAxXVswXSA9IHk7XG4gIG5vbmUoc2VyaWVzLCBvcmRlcik7XG59XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgc3VtcyA9IHNlcmllcy5tYXAoc3VtKTtcbiAgcmV0dXJuIG5vbmUoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYV0gLSBzdW1zW2JdOyB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1bShzZXJpZXMpIHtcbiAgdmFyIHMgPSAwLCBpID0gLTEsIG4gPSBzZXJpZXMubGVuZ3RoLCB2O1xuICB3aGlsZSAoKytpIDwgbikgaWYgKHYgPSArc2VyaWVzW2ldWzFdKSBzICs9IHY7XG4gIHJldHVybiBzO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHJldHVybiBhc2NlbmRpbmcoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lXCI7XG5pbXBvcnQge3N1bX0gZnJvbSBcIi4vYXNjZW5kaW5nXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHN1bXMgPSBzZXJpZXMubWFwKHN1bSksXG4gICAgICBvcmRlciA9IG5vbmUoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYl0gLSBzdW1zW2FdOyB9KSxcbiAgICAgIHRvcCA9IDAsXG4gICAgICBib3R0b20gPSAwLFxuICAgICAgdG9wcyA9IFtdLFxuICAgICAgYm90dG9tcyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBqID0gb3JkZXJbaV07XG4gICAgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgdG9wICs9IHN1bXNbal07XG4gICAgICB0b3BzLnB1c2goaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdHRvbSArPSBzdW1zW2pdO1xuICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pO1xuICB3aGlsZSAoLS1uID49IDApIG9bbl0gPSBuO1xuICByZXR1cm4gbztcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHJldHVybiBub25lKHNlcmllcykucmV2ZXJzZSgpO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgZGVzY2VuZGluZyBmcm9tIFwiLi9kZXNjZW5kaW5nXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHlcIjtcbmltcG9ydCB7dGF1fSBmcm9tIFwiLi9tYXRoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgIHNvcnRWYWx1ZXMgPSBkZXNjZW5kaW5nLFxuICAgICAgc29ydCA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gY29uc3RhbnQoMCksXG4gICAgICBlbmRBbmdsZSA9IGNvbnN0YW50KHRhdSksXG4gICAgICBwYWRBbmdsZSA9IGNvbnN0YW50KDApO1xuXG4gIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGFyY3MgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUsIE1hdGgubWF4KC10YXUsIGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBhMCkpLFxuICAgICAgICBhMSxcbiAgICAgICAgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sIHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgdjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodiA9IGFyY3NbaW5kZXhbaV0gPSBpXSA9ICt2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKSkgPiAwKSB7XG4gICAgICAgIHN1bSArPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGlvbmFsbHkgc29ydCB0aGUgYXJjcyBieSBwcmV2aW91c2x5LWNvbXB1dGVkIHZhbHVlcyBvciBieSBkYXRhLlxuICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7XG4gICAgZWxzZSBpZiAoc29ydCAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7IH0pO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXG4gICAgZm9yIChpID0gMCwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwOyBpIDwgbjsgKytpLCBhMCA9IGExKSB7XG4gICAgICBqID0gaW5kZXhbaV0sIHYgPSBhcmNzW2pdLCBhMSA9IGEwICsgKHYgPiAwID8gdiAqIGsgOiAwKSArIHBhLCBhcmNzW2pdID0ge1xuICAgICAgICBkYXRhOiBkYXRhW2pdLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBhcmNzO1xuICB9XG5cbiAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiB2YWx1ZTtcbiAgfTtcblxuICBwaWUuc29ydFZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0VmFsdWVzID0gXywgc29ydCA9IG51bGwsIHBpZSkgOiBzb3J0VmFsdWVzO1xuICB9O1xuXG4gIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XG4gIH07XG5cbiAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgcmV0dXJuIHBpZTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG4iLCJpbXBvcnQgY3VydmVSYWRpYWwsIHtjdXJ2ZVJhZGlhbExpbmVhcn0gZnJvbSBcIi4vY3VydmUvcmFkaWFsXCI7XG5pbXBvcnQgYXJlYSBmcm9tIFwiLi9hcmVhXCI7XG5pbXBvcnQge3JhZGlhbExpbmV9IGZyb20gXCIuL3JhZGlhbExpbmVcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBhcmVhKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpLFxuICAgICAgYyA9IGEuY3VydmUsXG4gICAgICB4MCA9IGEubGluZVgwLFxuICAgICAgeDEgPSBhLmxpbmVYMSxcbiAgICAgIHkwID0gYS5saW5lWTAsXG4gICAgICB5MSA9IGEubGluZVkxO1xuXG4gIGEuYW5nbGUgPSBhLngsIGRlbGV0ZSBhLng7XG4gIGEuc3RhcnRBbmdsZSA9IGEueDAsIGRlbGV0ZSBhLngwO1xuICBhLmVuZEFuZ2xlID0gYS54MSwgZGVsZXRlIGEueDE7XG4gIGEucmFkaXVzID0gYS55LCBkZWxldGUgYS55O1xuICBhLmlubmVyUmFkaXVzID0gYS55MCwgZGVsZXRlIGEueTA7XG4gIGEub3V0ZXJSYWRpdXMgPSBhLnkxLCBkZWxldGUgYS55MTtcbiAgYS5saW5lU3RhcnRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh4MCgpKTsgfSwgZGVsZXRlIGEubGluZVgwO1xuICBhLmxpbmVFbmRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh4MSgpKTsgfSwgZGVsZXRlIGEubGluZVgxO1xuICBhLmxpbmVJbm5lclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh5MCgpKTsgfSwgZGVsZXRlIGEubGluZVkwO1xuICBhLmxpbmVPdXRlclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh5MSgpKTsgfSwgZGVsZXRlIGEubGluZVkxO1xuXG4gIGEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gIH07XG5cbiAgcmV0dXJuIGE7XG59XG4iLCJpbXBvcnQgY3VydmVSYWRpYWwsIHtjdXJ2ZVJhZGlhbExpbmVhcn0gZnJvbSBcIi4vY3VydmUvcmFkaWFsXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByYWRpYWxMaW5lKGwpIHtcbiAgdmFyIGMgPSBsLmN1cnZlO1xuXG4gIGwuYW5nbGUgPSBsLngsIGRlbGV0ZSBsLng7XG4gIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xuXG4gIGwuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gIH07XG5cbiAgcmV0dXJuIGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmFkaWFsTGluZShsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcbn1cbiIsImltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBvZmZzZXROb25lIGZyb20gXCIuL29mZnNldC9ub25lXCI7XG5pbXBvcnQgb3JkZXJOb25lIGZyb20gXCIuL29yZGVyL25vbmVcIjtcblxuZnVuY3Rpb24gc3RhY2tWYWx1ZShkLCBrZXkpIHtcbiAgcmV0dXJuIGRba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBrZXlzID0gY29uc3RhbnQoW10pLFxuICAgICAgb3JkZXIgPSBvcmRlck5vbmUsXG4gICAgICBvZmZzZXQgPSBvZmZzZXROb25lLFxuICAgICAgdmFsdWUgPSBzdGFja1ZhbHVlO1xuXG4gIGZ1bmN0aW9uIHN0YWNrKGRhdGEpIHtcbiAgICB2YXIga3ogPSBrZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGksXG4gICAgICAgIG0gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgbiA9IGt6Lmxlbmd0aCxcbiAgICAgICAgc3ogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIG96O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZm9yICh2YXIga2kgPSBreltpXSwgc2kgPSBzeltpXSA9IG5ldyBBcnJheShtKSwgaiA9IDAsIHNpajsgaiA8IG07ICsraikge1xuICAgICAgICBzaVtqXSA9IHNpaiA9IFswLCArdmFsdWUoZGF0YVtqXSwga2ksIGosIGRhdGEpXTtcbiAgICAgICAgc2lqLmRhdGEgPSBkYXRhW2pdO1xuICAgICAgfVxuICAgICAgc2kua2V5ID0ga2k7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgb3ogPSBvcmRlcihzeik7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN6W296W2ldXS5pbmRleCA9IGk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KHN6LCBveik7XG4gICAgcmV0dXJuIHN6O1xuICB9XG5cbiAgc3RhY2sua2V5cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrZXlzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDoga2V5cztcbiAgfTtcblxuICBzdGFjay52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzdGFjaykgOiB2YWx1ZTtcbiAgfTtcblxuICBzdGFjay5vcmRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvcmRlciA9IF8gPT0gbnVsbCA/IG9yZGVyTm9uZSA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoc2xpY2UuY2FsbChfKSksIHN0YWNrKSA6IG9yZGVyO1xuICB9O1xuXG4gIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvZmZzZXQgPSBfID09IG51bGwgPyBvZmZzZXROb25lIDogXywgc3RhY2spIDogb2Zmc2V0O1xuICB9O1xuXG4gIHJldHVybiBzdGFjaztcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjaXJjbGUgZnJvbSBcIi4vc3ltYm9sL2NpcmNsZVwiO1xuaW1wb3J0IGNyb3NzIGZyb20gXCIuL3N5bWJvbC9jcm9zc1wiO1xuaW1wb3J0IGRpYW1vbmQgZnJvbSBcIi4vc3ltYm9sL2RpYW1vbmRcIjtcbmltcG9ydCBzdGFyIGZyb20gXCIuL3N5bWJvbC9zdGFyXCI7XG5pbXBvcnQgc3F1YXJlIGZyb20gXCIuL3N5bWJvbC9zcXVhcmVcIjtcbmltcG9ydCB0cmlhbmdsZSBmcm9tIFwiLi9zeW1ib2wvdHJpYW5nbGVcIjtcbmltcG9ydCB3eWUgZnJvbSBcIi4vc3ltYm9sL3d5ZVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5cbmV4cG9ydCB2YXIgc3ltYm9scyA9IFtcbiAgY2lyY2xlLFxuICBjcm9zcyxcbiAgZGlhbW9uZCxcbiAgc3F1YXJlLFxuICBzdGFyLFxuICB0cmlhbmdsZSxcbiAgd3llXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSBjb25zdGFudChjaXJjbGUpLFxuICAgICAgc2l6ZSA9IGNvbnN0YW50KDY0KSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgfTtcblxuICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN5bWJvbCkgOiBzaXplO1xuICB9O1xuXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHN5bWJvbDtcbn1cbiIsImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGhcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIHBpKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICBjb250ZXh0Lm1vdmVUbygtMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgdGFuMzAgPSBNYXRoLnNxcnQoMSAvIDMpLFxuICAgIHRhbjMwXzIgPSB0YW4zMCAqIDI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gTWF0aC5zcXJ0KHNpemUgLyB0YW4zMF8yKSxcbiAgICAgICAgeCA9IHkgKiB0YW4zMDtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXgsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcbiAgICAgICAgeCA9IC13IC8gMjtcbiAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3BpLCB0YXV9IGZyb20gXCIuLi9tYXRoXCI7XG5cbnZhciBrYSA9IDAuODkwODEzMDkxNTI5Mjg1MjI4MTAsXG4gICAga3IgPSBNYXRoLnNpbihwaSAvIDEwKSAvIE1hdGguc2luKDcgKiBwaSAvIDEwKSxcbiAgICBreCA9IE1hdGguc2luKHRhdSAvIDEwKSAqIGtyLFxuICAgIGt5ID0gLU1hdGguY29zKHRhdSAvIDEwKSAqIGtyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplICoga2EpLFxuICAgICAgICB4ID0ga3ggKiByLFxuICAgICAgICB5ID0ga3kgKiByO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDU7ICsraSkge1xuICAgICAgdmFyIGEgPSB0YXUgKiBpIC8gNSxcbiAgICAgICAgICBjID0gTWF0aC5jb3MoYSksXG4gICAgICAgICAgcyA9IE1hdGguc2luKGEpO1xuICAgICAgY29udGV4dC5saW5lVG8ocyAqIHIsIC1jICogcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciBzcXJ0MyA9IE1hdGguc3FydCgzKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSAtTWF0aC5zcXJ0KHNpemUgLyAoc3FydDMgKiAzKSk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIGMgPSAtMC41LFxuICAgIHMgPSBNYXRoLnNxcnQoMykgLyAyLFxuICAgIGsgPSAxIC8gTWF0aC5zcXJ0KDEyKSxcbiAgICBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksXG4gICAgICAgIHgwID0gciAvIDIsXG4gICAgICAgIHkwID0gciAqIGssXG4gICAgICAgIHgxID0geDAsXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxuICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtUaW1lcn0gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZWxhcHNlZCA9PiB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsInZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwodW5kZWZpbmVkLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7U0NIRURVTEVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbnZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgaTtcblxuICBpZiAoc2NoZWR1bGVzKSB7XG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5zdGF0ZSA+IFNDSEVEVUxFRCAmJiBzY2hlZHVsZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYWN0aXZlfSBmcm9tIFwiLi9hY3RpdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnJ1cHR9IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuIiwiaW1wb3J0IHtTVEFSVElORywgRU5ESU5HLCBFTkRFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcblxuICBpZiAoIXNjaGVkdWxlcykgcmV0dXJuO1xuXG4gIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG5cbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLm5hbWUgIT09IG5hbWUpIHsgZW1wdHkgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBhY3RpdmUgPSBzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HICYmIHNjaGVkdWxlLnN0YXRlIDwgRU5ESU5HO1xuICAgIHNjaGVkdWxlLnN0YXRlID0gRU5ERUQ7XG4gICAgc2NoZWR1bGUudGltZXIuc3RvcCgpO1xuICAgIHNjaGVkdWxlLm9uLmNhbGwoYWN0aXZlID8gXCJpbnRlcnJ1cHRcIiA6IFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlLmluZGV4LCBzY2hlZHVsZS5ncm91cCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgfVxuXG4gIGlmIChlbXB0eSkgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBzZWxlY3Rpb25faW50ZXJydXB0IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcblxuc2VsZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBzZWxlY3Rpb25faW50ZXJydXB0O1xuc2VsZWN0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uID0gc2VsZWN0aW9uX3RyYW5zaXRpb247XG4iLCJpbXBvcnQgaW50ZXJydXB0IGZyb20gXCIuLi9pbnRlcnJ1cHQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlIGZyb20gXCIuLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge2Vhc2VDdWJpY0luT3V0fSBmcm9tIFwiZDMtZWFzZVwiO1xuaW1wb3J0IHtub3d9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGVhc2VDdWJpY0luT3V0XG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG4gIHdoaWxlICghKHRpbWluZyA9IG5vZGUuX190cmFuc2l0aW9uKSB8fCAhKHRpbWluZyA9IHRpbWluZ1tpZF0pKSB7XG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNpdGlvbiAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IG5vdygpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGksIGdyb3VwLCB0aW1pbmcgfHwgaW5oZXJpdChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pKGZ1bGxuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdmFsdWUgPT0gbnVsbCA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIGksIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlKG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJhdHRyLlwiICsgbmFtZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtnZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGRlbGF5RnVuY3Rpb25cbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGR1cmF0aW9uRnVuY3Rpb25cbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZVZhcnlpbmcoaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMuZWFjaChlYXNlVmFyeWluZyh0aGlzLl9pZCwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG9uMCwgb24xLCB0aGF0ID0gdGhpcywgaWQgPSB0aGF0Ll9pZCwgc2l6ZSA9IHRoYXQuc2l6ZSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGNhbmNlbCA9IHt2YWx1ZTogcmVqZWN0fSxcbiAgICAgICAgZW5kID0ge3ZhbHVlOiBmdW5jdGlvbigpIHsgaWYgKC0tc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpOyB9fTtcblxuICAgIHRoYXQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICAgIGlmIChvbiAhPT0gb24wKSB7XG4gICAgICAgIG9uMSA9IChvbjAgPSBvbikuY29weSgpO1xuICAgICAgICBvbjEuXy5jYW5jZWwucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5pbnRlcnJ1cHQucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5lbmQucHVzaChlbmQpO1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBzZWxlY3Rpb24gd2FzIGVtcHR5LCByZXNvbHZlIGVuZCBpbW1lZGlhdGVseVxuICAgIGlmIChzaXplID09PSAwKSByZXNvbHZlKCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHttYXRjaGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyVHdlZW4gZnJvbSBcIi4vYXR0clR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kZWxheSBmcm9tIFwiLi9kZWxheS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2UgZnJvbSBcIi4vZWFzZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcgZnJvbSBcIi4vZWFzZVZhcnlpbmcuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0aW9uIGZyb20gXCIuL3NlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gZnJvbSBcIi4vc3R5bGVUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0VHdlZW4gZnJvbSBcIi4vdGV4dFR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3R3ZWVuIGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lbmQgZnJvbSBcIi4vZW5kLmpzXCI7XG5cbnZhciBpZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0aW9uKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHRyYW5zaXRpb25fZmlsdGVyLFxuICBtZXJnZTogdHJhbnNpdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiB0cmFuc2l0aW9uX3NlbGVjdGlvbixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbl90cmFuc2l0aW9uLFxuICBjYWxsOiBzZWxlY3Rpb25fcHJvdG90eXBlLmNhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9wcm90b3R5cGUuZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9wcm90b3R5cGUuZWFjaCxcbiAgb246IHRyYW5zaXRpb25fb24sXG4gIGF0dHI6IHRyYW5zaXRpb25fYXR0cixcbiAgYXR0clR3ZWVuOiB0cmFuc2l0aW9uX2F0dHJUd2VlbixcbiAgc3R5bGU6IHRyYW5zaXRpb25fc3R5bGUsXG4gIHN0eWxlVHdlZW46IHRyYW5zaXRpb25fc3R5bGVUd2VlbixcbiAgdGV4dDogdHJhbnNpdGlvbl90ZXh0LFxuICB0ZXh0VHdlZW46IHRyYW5zaXRpb25fdGV4dFR3ZWVuLFxuICByZW1vdmU6IHRyYW5zaXRpb25fcmVtb3ZlLFxuICB0d2VlbjogdHJhbnNpdGlvbl90d2VlbixcbiAgZGVsYXk6IHRyYW5zaXRpb25fZGVsYXksXG4gIGR1cmF0aW9uOiB0cmFuc2l0aW9uX2R1cmF0aW9uLFxuICBlYXNlOiB0cmFuc2l0aW9uX2Vhc2UsXG4gIGVhc2VWYXJ5aW5nOiB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nLFxuICBlbmQ6IHRyYW5zaXRpb25fZW5kLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX3Byb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdXG59O1xuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQge2ludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVTdHJpbmd9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIGludGVycG9sYXRlUmdiKVxuICAgICAgOiBpbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgaWYgKHRyYW5zaXRpb24uX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSB0cmFuc2l0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcbiAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKS5ldmVyeShmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lciwgdGltZW91dH0gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbmV4cG9ydCB2YXIgQ1JFQVRFRCA9IDA7XG5leHBvcnQgdmFyIFNDSEVEVUxFRCA9IDE7XG5leHBvcnQgdmFyIFNUQVJUSU5HID0gMjtcbmV4cG9ydCB2YXIgU1RBUlRFRCA9IDM7XG5leHBvcnQgdmFyIFJVTk5JTkcgPSA0O1xuZXhwb3J0IHZhciBFTkRJTkcgPSA1O1xuZXhwb3J0IHZhciBFTkRFRCA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGVzKSBub2RlLl9fdHJhbnNpdGlvbiA9IHt9O1xuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBncm91cDogZ3JvdXAsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBvbjogZW1wdHlPbixcbiAgICB0d2VlbjogZW1wdHlUd2VlbixcbiAgICB0aW1lOiB0aW1pbmcudGltZSxcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxuICAgIGR1cmF0aW9uOiB0aW1pbmcuZHVyYXRpb24sXG4gICAgZWFzZTogdGltaW5nLmVhc2UsXG4gICAgdGltZXI6IG51bGwsXG4gICAgc3RhdGU6IENSRUFURURcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSB0aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobm9kZSwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHtzZWxlY3Rvcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3RvckFsbH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG52YXIgU2VsZWN0aW9uID0gc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c3R5bGV9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlTnVsbChuYW1lLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHN0cmluZzEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCBzdHJpbmcxMCA9IHN0cmluZzEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpLFxuICAgICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHN0cmluZzEgPSB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVNYXliZVJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgb24wLCBvbjEsIGxpc3RlbmVyMCwga2V5ID0gXCJzdHlsZS5cIiArIG5hbWUsIGV2ZW50ID0gXCJlbmQuXCIgKyBrZXksIHJlbW92ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub24sXG4gICAgICAgIGxpc3RlbmVyID0gc2NoZWR1bGUudmFsdWVba2V5XSA9PSBudWxsID8gcmVtb3ZlIHx8IChyZW1vdmUgPSBzdHlsZVJlbW92ZShuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjAgfHwgbGlzdGVuZXIwICE9PSBsaXN0ZW5lcikgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihldmVudCwgbGlzdGVuZXIwID0gbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZU51bGwobmFtZSwgaSkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZShuYW1lKSlcbiAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpKVxuICAgICAgLmVhY2goc3R5bGVNYXliZVJlbW92ZSh0aGlzLl9pZCwgbmFtZSkpXG4gICAgOiB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlKSwgcHJpb3JpdHkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBudWxsKTtcbn1cbiIsImZ1bmN0aW9uIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkuY2FsbCh0aGlzLCB0KSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgdCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQgPSAoaTAgPSBpKSAmJiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cbiIsImltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24odHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxuICAgICAgOiB0ZXh0Q29uc3RhbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCIpKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRJbnRlcnBvbGF0ZShpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGkuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgdGV4dEludGVycG9sYXRlKGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJ0ZXh0XCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCB0ZXh0VHdlZW4odmFsdWUpKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gdHdlZW5SZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9IHR3ZWVuMCA9IHR3ZWVuO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFpvb21FdmVudCh0eXBlLCB7XG4gIHNvdXJjZUV2ZW50LFxuICB0YXJnZXQsXG4gIHRyYW5zZm9ybSxcbiAgZGlzcGF0Y2hcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHt2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzb3VyY2VFdmVudDoge3ZhbHVlOiBzb3VyY2VFdmVudCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0YXJnZXQ6IHt2YWx1ZTogdGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRyYW5zZm9ybToge3ZhbHVlOiB0cmFuc2Zvcm0sIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgXzoge3ZhbHVlOiBkaXNwYXRjaH1cbiAgfSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgem9vbX0gZnJvbSBcIi4vem9vbS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHpvb21UcmFuc2Zvcm0sIGlkZW50aXR5IGFzIHpvb21JZGVudGl0eSwgVHJhbnNmb3JtIGFzIFpvb21UcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCk7XG5cbnRyYW5zZm9ybS5wcm90b3R5cGUgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX196b29tKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuIGlkZW50aXR5O1xuICByZXR1cm4gbm9kZS5fX3pvb207XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7ZHJhZ0Rpc2FibGUsIGRyYWdFbmFibGV9IGZyb20gXCJkMy1kcmFnXCI7XG5pbXBvcnQge2ludGVycG9sYXRlWm9vbX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3NlbGVjdCwgcG9pbnRlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtpbnRlcnJ1cHR9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBab29tRXZlbnQgZnJvbSBcIi4vZXZlbnQuanNcIjtcbmltcG9ydCB7VHJhbnNmb3JtLCBpZGVudGl0eX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG4vLyBleGNlcHQgZm9yIHBpbmNoLXRvLXpvb20sIHdoaWNoIGlzIHNlbnQgYXMgYSB3aGVlbCtjdHJsS2V5IGV2ZW50XG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICBpZiAoZS5oYXNBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpKSB7XG4gICAgICBlID0gZS52aWV3Qm94LmJhc2VWYWw7XG4gICAgICByZXR1cm4gW1tlLngsIGUueV0sIFtlLnggKyBlLndpZHRoLCBlLnkgKyBlLmhlaWdodF1dO1xuICAgIH1cbiAgICByZXR1cm4gW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbZS5jbGllbnRXaWR0aCwgZS5jbGllbnRIZWlnaHRdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YShldmVudCkge1xuICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIChldmVudC5jdHJsS2V5ID8gMTAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzBdLFxuICAgICAgZHgxID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzFdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVswXSxcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXG4gICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzFdO1xuICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZShcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgZHkxID4gZHkwID8gKGR5MCArIGR5MSkgLyAyIDogTWF0aC5taW4oMCwgZHkwKSB8fCBNYXRoLm1heCgwLCBkeTEpXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBjb25zdHJhaW4gPSBkZWZhdWx0Q29uc3RyYWluLFxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IFtbLUluZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIEluZmluaXR5XV0sXG4gICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVab29tLFxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hmaXJzdCxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgdG91Y2hEZWxheSA9IDUwMCxcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDAsXG4gICAgICB0YXBEaXN0YW5jZSA9IDEwO1xuXG4gIGZ1bmN0aW9uIHpvb20oc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKVxuICAgICAgICAub24oXCJ3aGVlbC56b29tXCIsIHdoZWVsZWQsIHtwYXNzaXZlOiBmYWxzZX0pXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlZG93bmVkKVxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuem9vbSB0b3VjaGNhbmNlbC56b29tXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICB6b29tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmludGVycnVwdCgpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGdlc3R1cmUodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIC5ldmVudChldmVudClcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC56b29tKG51bGwsIHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdHJhbnNmb3JtKVxuICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS5zY2FsZVRvKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gazAgKiBrMTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS5zY2FsZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwLFxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0aGlzLl9fem9vbS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB4LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeVxuICAgICAgKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgbnVsbCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcDtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHAwWzBdLCBwMFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyAteC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyAteS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXlcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgaykge1xuICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIGspKTtcbiAgICByZXR1cm4gayA9PT0gdHJhbnNmb3JtLmsgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKGssIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBwMCwgcDEpIHtcbiAgICB2YXIgeCA9IHAwWzBdIC0gcDFbMF0gKiB0cmFuc2Zvcm0uaywgeSA9IHAwWzFdIC0gcDFbMV0gKiB0cmFuc2Zvcm0uaztcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtLnggJiYgeSA9PT0gdHJhbnNmb3JtLnkgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybS5rLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGV4dGVudCkge1xuICAgIHJldHVybiBbKCtleHRlbnRbMF1bMF0gKyArZXh0ZW50WzFdWzBdKSAvIDIsICgrZXh0ZW50WzBdWzFdICsgK2V4dGVudFsxXVsxXSkgLyAyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLnN0YXJ0KCk7IH0pXG4gICAgICAgIC5vbihcImludGVycnVwdC56b29tIGVuZC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLmVuZCgpOyB9KVxuICAgICAgICAudHdlZW4oXCJ6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZyA9IGdlc3R1cmUodGhhdCwgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gcG9pbnQgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHBvaW50ID09PSBcImZ1bmN0aW9uXCIgPyBwb2ludC5hcHBseSh0aGF0LCBhcmdzKSA6IHBvaW50LFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX3pvb21pbmcpIHx8IG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB0aGlzLnNvdXJjZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB0aGlzLnRhcHMgPSAwO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgZXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHRoaXMuc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy50aGF0Ll9fem9vbWluZyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aGF0Ll9fem9vbWluZztcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgZCA9IHNlbGVjdCh0aGlzLnRoYXQpLmRhdHVtKCk7XG4gICAgICBsaXN0ZW5lcnMuY2FsbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy50aGF0LFxuICAgICAgICBuZXcgWm9vbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogdGhpcy5zb3VyY2VFdmVudCxcbiAgICAgICAgICB0YXJnZXQ6IHpvb20sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMudGhhdC5fX3pvb20sXG4gICAgICAgICAgZGlzcGF0Y2g6IGxpc3RlbmVyc1xuICAgICAgICB9KSxcbiAgICAgICAgZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gd2hlZWxlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQpO1xuXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSByZWNlbnQgd2hlZWwgZXZlbnRzLCByZXNldCB0aGUgd2hlZWwgaWRsZSB0aW1lb3V0LlxuICAgIGlmIChnLndoZWVsKSB7XG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XG4gICAgICAgIGcubW91c2VbMV0gPSB0LmludmVydChnLm1vdXNlWzBdID0gcCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXG4gICAgZWxzZSBpZiAodC5rID09PSBrKSByZXR1cm47XG5cbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXG4gICAgZWxzZSB7XG4gICAgICBnLm1vdXNlID0gW3AsIHQuaW52ZXJ0KHApXTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBnLndoZWVsID0gc2V0VGltZW91dCh3aGVlbGlkbGVkLCB3aGVlbERlbGF5KTtcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIHRydWUpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdiA9IHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksXG4gICAgICAgIHgwID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBldmVudC5jbGllbnRZO1xuXG4gICAgZHJhZ0Rpc2FibGUoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKGV2ZW50KSB7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuZXZlbnQoZXZlbnQpXG4gICAgICAgLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKGcudGhhdC5fX3pvb20sIGcubW91c2VbMF0gPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwcGVkKGV2ZW50KSB7XG4gICAgICB2Lm9uKFwibW91c2Vtb3ZlLnpvb20gbW91c2V1cC56b29tXCIsIG51bGwpO1xuICAgICAgZHJhZ0VuYWJsZShldmVudC52aWV3LCBnLm1vdmVkKTtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgZy5ldmVudChldmVudCkuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBwb2ludGVyKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCwgdGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGV2ZW50LnNoaWZ0S2V5ID8gMC41IDogMiksXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJncyksIHRyYW5zbGF0ZUV4dGVudCk7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHNjaGVkdWxlLCB0MSwgcDAsIGV2ZW50KTtcbiAgICBlbHNlIHNlbGVjdCh0aGlzKS5jYWxsKHpvb20udHJhbnNmb3JtLCB0MSwgcDAsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSBuKS5ldmVudChldmVudCksXG4gICAgICAgIHN0YXJ0ZWQsIGksIHQsIHA7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBwID0gW3AsIHRoaXMuX196b29tLmludmVydChwKSwgdC5pZGVudGlmaWVyXTtcbiAgICAgIGlmICghZy50b3VjaDApIGcudG91Y2gwID0gcCwgc3RhcnRlZCA9IHRydWUsIGcudGFwcyA9IDEgKyAhIXRvdWNoc3RhcnRpbmc7XG4gICAgICBlbHNlIGlmICghZy50b3VjaDEgJiYgZy50b3VjaDBbMl0gIT09IHBbMl0pIGcudG91Y2gxID0gcCwgZy50YXBzID0gMDtcbiAgICB9XG5cbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICBpZiAoZy50YXBzIDwgMikgdG91Y2hmaXJzdCA9IHBbMF0sIHRvdWNoc3RhcnRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaHN0YXJ0aW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdCwgcCwgbDtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMFswXSA9IHA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMVswXSA9IHA7XG4gICAgfVxuICAgIHQgPSBnLnRoYXQuX196b29tO1xuICAgIGlmIChnLnRvdWNoMSkge1xuICAgICAgdmFyIHAwID0gZy50b3VjaDBbMF0sIGwwID0gZy50b3VjaDBbMV0sXG4gICAgICAgICAgcDEgPSBnLnRvdWNoMVswXSwgbDEgPSBnLnRvdWNoMVsxXSxcbiAgICAgICAgICBkcCA9IChkcCA9IHAxWzBdIC0gcDBbMF0pICogZHAgKyAoZHAgPSBwMVsxXSAtIHAwWzFdKSAqIGRwLFxuICAgICAgICAgIGRsID0gKGRsID0gbDFbMF0gLSBsMFswXSkgKiBkbCArIChkbCA9IGwxWzFdIC0gbDBbMV0pICogZGw7XG4gICAgICB0ID0gc2NhbGUodCwgTWF0aC5zcXJ0KGRwIC8gZGwpKTtcbiAgICAgIHAgPSBbKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMl07XG4gICAgICBsID0gWyhsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChnLnRvdWNoMCkgcCA9IGcudG91Y2gwWzBdLCBsID0gZy50b3VjaDBbMV07XG4gICAgZWxzZSByZXR1cm47XG5cbiAgICBnLnpvb20oXCJ0b3VjaFwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHQsIHAsIGwpLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDE7XG4gICAgfVxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICBpZiAoZy50b3VjaDApIGcudG91Y2gwWzFdID0gdGhpcy5fX3pvb20uaW52ZXJ0KGcudG91Y2gwWzBdKTtcbiAgICBlbHNlIHtcbiAgICAgIGcuZW5kKCk7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhIGRibHRhcCwgcmVyb3V0ZSB0byB0aGUgKG9wdGlvbmFsKSBkYmxjbGljay56b29tIGhhbmRsZXIuXG4gICAgICBpZiAoZy50YXBzID09PSAyKSB7XG4gICAgICAgIHQgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgICBpZiAoTWF0aC5oeXBvdCh0b3VjaGZpcnN0WzBdIC0gdFswXSwgdG91Y2hmaXJzdFsxXSAtIHRbMV0pIDwgdGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICB2YXIgcCA9IHNlbGVjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIik7XG4gICAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHpvb20ud2hlZWxEZWx0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3aGVlbERlbHRhID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHpvb20pIDogd2hlZWxEZWx0YTtcbiAgfTtcblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgem9vbS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSksIHpvb20pIDogZXh0ZW50O1xuICB9O1xuXG4gIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGVFeHRlbnRbMF1bMF0gPSArX1swXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzBdID0gK19bMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXSA9ICtfWzBdWzFdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV0gPSArX1sxXVsxXSwgem9vbSkgOiBbW3RyYW5zbGF0ZUV4dGVudFswXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdXSwgW3RyYW5zbGF0ZUV4dGVudFsxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdXV07XG4gIH07XG5cbiAgem9vbS5jb25zdHJhaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uc3RyYWluID0gXywgem9vbSkgOiBjb25zdHJhaW47XG4gIH07XG5cbiAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xuICB9O1xuXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCB6b29tKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHpvb20ub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xuICB9O1xuXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgem9vbSkgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHpvb20udGFwRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFwRGlzdGFuY2UgPSArXywgem9vbSkgOiB0YXBEaXN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn1cbiIsImZ1bmN0aW9uIHByb21pc2lmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBmaWxlIHNpemUgaGFja3NcbiAgICAgICAgcmVxdWVzdC5vbmNvbXBsZXRlID0gcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGZpbGUgc2l6ZSBoYWNrc1xuICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZShkYk5hbWUsIHN0b3JlTmFtZSkge1xuICAgIGxldCBkYnA7XG4gICAgY29uc3QgZ2V0REIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkYnApXG4gICAgICAgICAgICByZXR1cm4gZGJwO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oZGJOYW1lKTtcbiAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiByZXF1ZXN0LnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICBkYnAgPSBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICBkYnAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICAgIC8vIEl0IHNlZW1zIGxpa2UgU2FmYXJpIHNvbWV0aW1lcyBsaWtlcyB0byBqdXN0IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gSXQncyBzdXBwb3NlZCB0byBmaXJlIHRoaXMgZXZlbnQgd2hlbiB0aGF0IGhhcHBlbnMuIExldCdzIGhvcGUgaXQgZG9lcyFcbiAgICAgICAgICAgIGRiLm9uY2xvc2UgPSAoKSA9PiAoZGJwID0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSwgKCkgPT4geyB9KTtcbiAgICAgICAgcmV0dXJuIGRicDtcbiAgICB9O1xuICAgIHJldHVybiAodHhNb2RlLCBjYWxsYmFjaykgPT4gZ2V0REIoKS50aGVuKChkYikgPT4gY2FsbGJhY2soZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCB0eE1vZGUpLm9iamVjdFN0b3JlKHN0b3JlTmFtZSkpKTtcbn1cbmxldCBkZWZhdWx0R2V0U3RvcmVGdW5jO1xuZnVuY3Rpb24gZGVmYXVsdEdldFN0b3JlKCkge1xuICAgIGlmICghZGVmYXVsdEdldFN0b3JlRnVuYykge1xuICAgICAgICBkZWZhdWx0R2V0U3RvcmVGdW5jID0gY3JlYXRlU3RvcmUoJ2tleXZhbC1zdG9yZScsICdrZXl2YWwnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRHZXRTdG9yZUZ1bmM7XG59XG4vKipcbiAqIEdldCBhIHZhbHVlIGJ5IGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIGN1c3RvbVN0b3JlIE1ldGhvZCB0byBnZXQgYSBjdXN0b20gc3RvcmUuIFVzZSB3aXRoIGNhdXRpb24gKHNlZSB0aGUgZG9jcykuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXksIGN1c3RvbVN0b3JlID0gZGVmYXVsdEdldFN0b3JlKCkpIHtcbiAgICByZXR1cm4gY3VzdG9tU3RvcmUoJ3JlYWRvbmx5JywgKHN0b3JlKSA9PiBwcm9taXNpZnlSZXF1ZXN0KHN0b3JlLmdldChrZXkpKSk7XG59XG4vKipcbiAqIFNldCBhIHZhbHVlIHdpdGggYSBrZXkuXG4gKlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gY3VzdG9tU3RvcmUgTWV0aG9kIHRvIGdldCBhIGN1c3RvbSBzdG9yZS4gVXNlIHdpdGggY2F1dGlvbiAoc2VlIHRoZSBkb2NzKS5cbiAqL1xuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUsIGN1c3RvbVN0b3JlID0gZGVmYXVsdEdldFN0b3JlKCkpIHtcbiAgICByZXR1cm4gY3VzdG9tU3RvcmUoJ3JlYWR3cml0ZScsIChzdG9yZSkgPT4ge1xuICAgICAgICBzdG9yZS5wdXQodmFsdWUsIGtleSk7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHN0b3JlLnRyYW5zYWN0aW9uKTtcbiAgICB9KTtcbn1cbi8qKlxuICogU2V0IG11bHRpcGxlIHZhbHVlcyBhdCBvbmNlLiBUaGlzIGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgc2V0KCkgbXVsdGlwbGUgdGltZXMuXG4gKiBJdCdzIGFsc28gYXRvbWljIOKAkyBpZiBvbmUgb2YgdGhlIHBhaXJzIGNhbid0IGJlIGFkZGVkLCBub25lIHdpbGwgYmUgYWRkZWQuXG4gKlxuICogQHBhcmFtIGVudHJpZXMgQXJyYXkgb2YgZW50cmllcywgd2hlcmUgZWFjaCBlbnRyeSBpcyBhbiBhcnJheSBvZiBgW2tleSwgdmFsdWVdYC5cbiAqIEBwYXJhbSBjdXN0b21TdG9yZSBNZXRob2QgdG8gZ2V0IGEgY3VzdG9tIHN0b3JlLiBVc2Ugd2l0aCBjYXV0aW9uIChzZWUgdGhlIGRvY3MpLlxuICovXG5mdW5jdGlvbiBzZXRNYW55KGVudHJpZXMsIGN1c3RvbVN0b3JlID0gZGVmYXVsdEdldFN0b3JlKCkpIHtcbiAgICByZXR1cm4gY3VzdG9tU3RvcmUoJ3JlYWR3cml0ZScsIChzdG9yZSkgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiBzdG9yZS5wdXQoZW50cnlbMV0sIGVudHJ5WzBdKSk7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHN0b3JlLnRyYW5zYWN0aW9uKTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2V0IG11bHRpcGxlIHZhbHVlcyBieSB0aGVpciBrZXlzXG4gKlxuICogQHBhcmFtIGtleXNcbiAqIEBwYXJhbSBjdXN0b21TdG9yZSBNZXRob2QgdG8gZ2V0IGEgY3VzdG9tIHN0b3JlLiBVc2Ugd2l0aCBjYXV0aW9uIChzZWUgdGhlIGRvY3MpLlxuICovXG5mdW5jdGlvbiBnZXRNYW55KGtleXMsIGN1c3RvbVN0b3JlID0gZGVmYXVsdEdldFN0b3JlKCkpIHtcbiAgICByZXR1cm4gY3VzdG9tU3RvcmUoJ3JlYWRvbmx5JywgKHN0b3JlKSA9PiBQcm9taXNlLmFsbChrZXlzLm1hcCgoa2V5KSA9PiBwcm9taXNpZnlSZXF1ZXN0KHN0b3JlLmdldChrZXkpKSkpKTtcbn1cbi8qKlxuICogVXBkYXRlIGEgdmFsdWUuIFRoaXMgbGV0cyB5b3Ugc2VlIHRoZSBvbGQgdmFsdWUgYW5kIHVwZGF0ZSBpdCBhcyBhbiBhdG9taWMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSB1cGRhdGVyIEEgY2FsbGJhY2sgdGhhdCB0YWtlcyB0aGUgb2xkIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICogQHBhcmFtIGN1c3RvbVN0b3JlIE1ldGhvZCB0byBnZXQgYSBjdXN0b20gc3RvcmUuIFVzZSB3aXRoIGNhdXRpb24gKHNlZSB0aGUgZG9jcykuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShrZXksIHVwZGF0ZXIsIGN1c3RvbVN0b3JlID0gZGVmYXVsdEdldFN0b3JlKCkpIHtcbiAgICByZXR1cm4gY3VzdG9tU3RvcmUoJ3JlYWR3cml0ZScsIChzdG9yZSkgPT4gXG4gICAgLy8gTmVlZCB0byBjcmVhdGUgdGhlIHByb21pc2UgbWFudWFsbHkuXG4gICAgLy8gSWYgSSB0cnkgdG8gY2hhaW4gcHJvbWlzZXMsIHRoZSB0cmFuc2FjdGlvbiBjbG9zZXMgaW4gYnJvd3NlcnNcbiAgICAvLyB0aGF0IHVzZSBhIHByb21pc2UgcG9seWZpbGwgKElFMTAvMTEpLlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc3RvcmUuZ2V0KGtleSkub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXQodXBkYXRlcih0aGlzLnJlc3VsdCksIGtleSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNpZnlSZXF1ZXN0KHN0b3JlLnRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkpO1xufVxuLyoqXG4gKiBEZWxldGUgYSBwYXJ0aWN1bGFyIGtleSBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gY3VzdG9tU3RvcmUgTWV0aG9kIHRvIGdldCBhIGN1c3RvbSBzdG9yZS4gVXNlIHdpdGggY2F1dGlvbiAoc2VlIHRoZSBkb2NzKS5cbiAqL1xuZnVuY3Rpb24gZGVsKGtleSwgY3VzdG9tU3RvcmUgPSBkZWZhdWx0R2V0U3RvcmUoKSkge1xuICAgIHJldHVybiBjdXN0b21TdG9yZSgncmVhZHdyaXRlJywgKHN0b3JlKSA9PiB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5UmVxdWVzdChzdG9yZS50cmFuc2FjdGlvbik7XG4gICAgfSk7XG59XG4vKipcbiAqIERlbGV0ZSBtdWx0aXBsZSBrZXlzIGF0IG9uY2UuXG4gKlxuICogQHBhcmFtIGtleXMgTGlzdCBvZiBrZXlzIHRvIGRlbGV0ZS5cbiAqIEBwYXJhbSBjdXN0b21TdG9yZSBNZXRob2QgdG8gZ2V0IGEgY3VzdG9tIHN0b3JlLiBVc2Ugd2l0aCBjYXV0aW9uIChzZWUgdGhlIGRvY3MpLlxuICovXG5mdW5jdGlvbiBkZWxNYW55KGtleXMsIGN1c3RvbVN0b3JlID0gZGVmYXVsdEdldFN0b3JlKCkpIHtcbiAgICByZXR1cm4gY3VzdG9tU3RvcmUoJ3JlYWR3cml0ZScsIChzdG9yZSkgPT4ge1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4gc3RvcmUuZGVsZXRlKGtleSkpO1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5UmVxdWVzdChzdG9yZS50cmFuc2FjdGlvbik7XG4gICAgfSk7XG59XG4vKipcbiAqIENsZWFyIGFsbCB2YWx1ZXMgaW4gdGhlIHN0b3JlLlxuICpcbiAqIEBwYXJhbSBjdXN0b21TdG9yZSBNZXRob2QgdG8gZ2V0IGEgY3VzdG9tIHN0b3JlLiBVc2Ugd2l0aCBjYXV0aW9uIChzZWUgdGhlIGRvY3MpLlxuICovXG5mdW5jdGlvbiBjbGVhcihjdXN0b21TdG9yZSA9IGRlZmF1bHRHZXRTdG9yZSgpKSB7XG4gICAgcmV0dXJuIGN1c3RvbVN0b3JlKCdyZWFkd3JpdGUnLCAoc3RvcmUpID0+IHtcbiAgICAgICAgc3RvcmUuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3Qoc3RvcmUudHJhbnNhY3Rpb24pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZWFjaEN1cnNvcihzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBzdG9yZS5vcGVuQ3Vyc29yKCkub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsYmFjayh0aGlzLnJlc3VsdCk7XG4gICAgICAgIHRoaXMucmVzdWx0LmNvbnRpbnVlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gcHJvbWlzaWZ5UmVxdWVzdChzdG9yZS50cmFuc2FjdGlvbik7XG59XG4vKipcbiAqIEdldCBhbGwga2V5cyBpbiB0aGUgc3RvcmUuXG4gKlxuICogQHBhcmFtIGN1c3RvbVN0b3JlIE1ldGhvZCB0byBnZXQgYSBjdXN0b20gc3RvcmUuIFVzZSB3aXRoIGNhdXRpb24gKHNlZSB0aGUgZG9jcykuXG4gKi9cbmZ1bmN0aW9uIGtleXMoY3VzdG9tU3RvcmUgPSBkZWZhdWx0R2V0U3RvcmUoKSkge1xuICAgIHJldHVybiBjdXN0b21TdG9yZSgncmVhZG9ubHknLCAoc3RvcmUpID0+IHtcbiAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaWYgKHN0b3JlLmdldEFsbEtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHN0b3JlLmdldEFsbEtleXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGVhY2hDdXJzb3Ioc3RvcmUsIChjdXJzb3IpID0+IGl0ZW1zLnB1c2goY3Vyc29yLmtleSkpLnRoZW4oKCkgPT4gaXRlbXMpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBHZXQgYWxsIHZhbHVlcyBpbiB0aGUgc3RvcmUuXG4gKlxuICogQHBhcmFtIGN1c3RvbVN0b3JlIE1ldGhvZCB0byBnZXQgYSBjdXN0b20gc3RvcmUuIFVzZSB3aXRoIGNhdXRpb24gKHNlZSB0aGUgZG9jcykuXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhjdXN0b21TdG9yZSA9IGRlZmF1bHRHZXRTdG9yZSgpKSB7XG4gICAgcmV0dXJuIGN1c3RvbVN0b3JlKCdyZWFkb25seScsIChzdG9yZSkgPT4ge1xuICAgICAgICAvLyBGYXN0IHBhdGggZm9yIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpZiAoc3RvcmUuZ2V0QWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5UmVxdWVzdChzdG9yZS5nZXRBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGVhY2hDdXJzb3Ioc3RvcmUsIChjdXJzb3IpID0+IGl0ZW1zLnB1c2goY3Vyc29yLnZhbHVlKSkudGhlbigoKSA9PiBpdGVtcyk7XG4gICAgfSk7XG59XG4vKipcbiAqIEdldCBhbGwgZW50cmllcyBpbiB0aGUgc3RvcmUuIEVhY2ggZW50cnkgaXMgYW4gYXJyYXkgb2YgYFtrZXksIHZhbHVlXWAuXG4gKlxuICogQHBhcmFtIGN1c3RvbVN0b3JlIE1ldGhvZCB0byBnZXQgYSBjdXN0b20gc3RvcmUuIFVzZSB3aXRoIGNhdXRpb24gKHNlZSB0aGUgZG9jcykuXG4gKi9cbmZ1bmN0aW9uIGVudHJpZXMoY3VzdG9tU3RvcmUgPSBkZWZhdWx0R2V0U3RvcmUoKSkge1xuICAgIHJldHVybiBjdXN0b21TdG9yZSgncmVhZG9ubHknLCAoc3RvcmUpID0+IHtcbiAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gKGFsdGhvdWdoLCBob3BlZnVsbHkgd2UnbGwgZ2V0IGEgc2ltcGxlciBwYXRoIHNvbWUgZGF5KVxuICAgICAgICBpZiAoc3RvcmUuZ2V0QWxsICYmIHN0b3JlLmdldEFsbEtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgcHJvbWlzaWZ5UmVxdWVzdChzdG9yZS5nZXRBbGxLZXlzKCkpLFxuICAgICAgICAgICAgICAgIHByb21pc2lmeVJlcXVlc3Qoc3RvcmUuZ2V0QWxsKCkpLFxuICAgICAgICAgICAgXSkudGhlbigoW2tleXMsIHZhbHVlc10pID0+IGtleXMubWFwKChrZXksIGkpID0+IFtrZXksIHZhbHVlc1tpXV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICByZXR1cm4gY3VzdG9tU3RvcmUoJ3JlYWRvbmx5JywgKHN0b3JlKSA9PiBlYWNoQ3Vyc29yKHN0b3JlLCAoY3Vyc29yKSA9PiBpdGVtcy5wdXNoKFtjdXJzb3Iua2V5LCBjdXJzb3IudmFsdWVdKSkudGhlbigoKSA9PiBpdGVtcykpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBjbGVhciwgY3JlYXRlU3RvcmUsIGRlbCwgZGVsTWFueSwgZW50cmllcywgZ2V0LCBnZXRNYW55LCBrZXlzLCBwcm9taXNpZnlSZXF1ZXN0LCBzZXQsIHNldE1hbnksIHVwZGF0ZSwgdmFsdWVzIH07XG4iLCJleHBvcnQgY2xhc3MgSW50ZXJuTWFwIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IoZW50cmllcywga2V5ID0ga2V5b2YpIHtcbiAgICBzdXBlcigpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtfaW50ZXJuOiB7dmFsdWU6IG5ldyBNYXAoKX0sIF9rZXk6IHt2YWx1ZToga2V5fX0pO1xuICAgIGlmIChlbnRyaWVzICE9IG51bGwpIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMpIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0KGludGVybl9nZXQodGhpcywga2V5KSk7XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiBzdXBlci5oYXMoaW50ZXJuX2dldCh0aGlzLCBrZXkpKTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5zZXQoaW50ZXJuX3NldCh0aGlzLCBrZXkpLCB2YWx1ZSk7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIHJldHVybiBzdXBlci5kZWxldGUoaW50ZXJuX2RlbGV0ZSh0aGlzLCBrZXkpKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW50ZXJuU2V0IGV4dGVuZHMgU2V0IHtcbiAgY29uc3RydWN0b3IodmFsdWVzLCBrZXkgPSBrZXlvZikge1xuICAgIHN1cGVyKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge19pbnRlcm46IHt2YWx1ZTogbmV3IE1hcCgpfSwgX2tleToge3ZhbHVlOiBrZXl9fSk7XG4gICAgaWYgKHZhbHVlcyAhPSBudWxsKSBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykgdGhpcy5hZGQodmFsdWUpO1xuICB9XG4gIGhhcyh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5oYXMoaW50ZXJuX2dldCh0aGlzLCB2YWx1ZSkpO1xuICB9XG4gIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5hZGQoaW50ZXJuX3NldCh0aGlzLCB2YWx1ZSkpO1xuICB9XG4gIGRlbGV0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5kZWxldGUoaW50ZXJuX2RlbGV0ZSh0aGlzLCB2YWx1ZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybl9nZXQoe19pbnRlcm4sIF9rZXl9LCB2YWx1ZSkge1xuICBjb25zdCBrZXkgPSBfa2V5KHZhbHVlKTtcbiAgcmV0dXJuIF9pbnRlcm4uaGFzKGtleSkgPyBfaW50ZXJuLmdldChrZXkpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGludGVybl9zZXQoe19pbnRlcm4sIF9rZXl9LCB2YWx1ZSkge1xuICBjb25zdCBrZXkgPSBfa2V5KHZhbHVlKTtcbiAgaWYgKF9pbnRlcm4uaGFzKGtleSkpIHJldHVybiBfaW50ZXJuLmdldChrZXkpO1xuICBfaW50ZXJuLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5fZGVsZXRlKHtfaW50ZXJuLCBfa2V5fSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5ID0gX2tleSh2YWx1ZSk7XG4gIGlmIChfaW50ZXJuLmhhcyhrZXkpKSB7XG4gICAgdmFsdWUgPSBfaW50ZXJuLmdldChrZXkpO1xuICAgIF9pbnRlcm4uZGVsZXRlKGtleSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBrZXlvZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG59XG4iLCIvLyBqc29uc3RhdC10b29sa2l0IHYxLjUuMyBDb3B5cmlnaHQgMjAyNCBYYXZpZXIgQmFkb3NhIGh0dHBzOi8vanNvbnN0YXQuY29tXG5mdW5jdGlvbiB0KGkscil7dmFyIGwscyxhLG8sdT1mdW5jdGlvbih0LGkscil7aWYoMD09PU9iamVjdC5lbnRyaWVzKHQpLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgbCxzPVtdO2lmKHImJiFuKHIubmFtZSkmJihyPW51bGwpLFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1bdF0pLEFycmF5LmlzQXJyYXkodCl8fGUodCkpe2lmKHQubGVuZ3RoPT09aSlyZXR1cm4gciYmLTE9PT10LmZpbmRJbmRleCgoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXR9KSk/ci5mcm9tKHQpOnQ7aWYoMT09PXQubGVuZ3RoKXtmb3IobD0wO2w8aTtsKyspcy5wdXNoKHRbMF0pO3JldHVybiBzfX1mb3IobD0wO2w8aTtsKyspe3ZhciBhPXZvaWQgMD09PXRbbF0/bnVsbDp0W2xdO3MucHVzaChhKX1yZXR1cm4gc307aWYodGhpcy5sZW5ndGg9MCx0aGlzLmlkPVtdLG51bGwhPWkpc3dpdGNoKHRoaXMuY2xhc3M9aS5jbGFzc3x8XCJidW5kbGVcIix0aGlzLmNsYXNzKXtjYXNlXCJidW5kbGVcIjp2YXIgaD1bXSxmPTA7aWYodGhpcy5lcnJvcj1udWxsLHRoaXMubGVuZ3RoPTAsbnVsbD09PWl8fFwib2JqZWN0XCIhPXR5cGVvZiBpKXJldHVybiB2b2lkKHRoaXMuY2xhc3M9bnVsbCk7aWYoaS5oYXNPd25Qcm9wZXJ0eShcImVycm9yXCIpKXJldHVybiB2b2lkKHRoaXMuZXJyb3I9aS5lcnJvcik7aWYoXCJkYXRhc2V0XCI9PT1pLmNsYXNzfHxcImNvbGxlY3Rpb25cIj09PWkuY2xhc3N8fFwiZGltZW5zaW9uXCI9PT1pLmNsYXNzKXJldHVybiBuZXcgdChpKTtmb3IocyBpbiBpKWYrKyxoLnB1c2gocyk7dGhpcy5fX3RyZWVfXz1pLHRoaXMubGVuZ3RoPWYsdGhpcy5pZD1oO2JyZWFrO2Nhc2VcImRhdGFzZXRcIjppLmhhc093blByb3BlcnR5KFwiX190cmVlX19cIik/dGhpcy5fX3RyZWVfXz1sPWkuX190cmVlX186dGhpcy5fX3RyZWVfXz1sPWksdGhpcy5sYWJlbD1sLmxhYmVsfHxudWxsLHRoaXMubm90ZT1sLm5vdGV8fG51bGwsdGhpcy5saW5rPWwubGlua3x8bnVsbCx0aGlzLmhyZWY9bC5ocmVmfHxudWxsLHRoaXMudXBkYXRlZD1sLnVwZGF0ZWR8fG51bGwsdGhpcy5zb3VyY2U9bC5zb3VyY2V8fG51bGwsdGhpcy5leHRlbnNpb249bC5leHRlbnNpb258fG51bGw7dmFyIGMsZD0wLHY9bC5zaXplfHxsLmRpbWVuc2lvbiYmbC5kaW1lbnNpb24uc2l6ZTtpZih0aGlzLnNpemU9dix0aGlzLnZhbHVlPWwuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmbnVsbCE9PWwudmFsdWUmJjAhPT1sLnZhbHVlLmxlbmd0aD9sLnZhbHVlOnt9LEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSl8fGUodGhpcy52YWx1ZSkpZD10aGlzLnZhbHVlLmxlbmd0aDtlbHNle3ZhciB5PTE7Zm9yKGM9di5sZW5ndGg7Yy0tOyl5Kj12W2NdO2Q9eX1pZih0aGlzLnZhbHVlPXUodGhpcy52YWx1ZSxkLHIpLHRoaXMuc3RhdHVzPWwuaGFzT3duUHJvcGVydHkoXCJzdGF0dXNcIikmJm51bGwhPT1sLnN0YXR1cz91KGwuc3RhdHVzLGQpOm51bGwsbC5oYXNPd25Qcm9wZXJ0eShcImRpbWVuc2lvblwiKSl7dmFyIHA9bC5kaW1lbnNpb24sZz1sLnJvbGV8fCFsLnZlcnNpb24mJnAucm9sZXx8bnVsbCxiPWwuaWR8fHAuaWQsbT12Lmxlbmd0aCxfPWZ1bmN0aW9uKHQpe2cuaGFzT3duUHJvcGVydHkodCl8fChnW3RdPW51bGwpfTtpZighQXJyYXkuaXNBcnJheShiKXx8IUFycmF5LmlzQXJyYXkodil8fGIubGVuZ3RoIT1tKXJldHVybjtpZih0aGlzLmxlbmd0aD1tLHRoaXMuaWQ9YixnJiYoXyhcInRpbWVcIiksXyhcImdlb1wiKSxfKFwibWV0cmljXCIpLF8oXCJjbGFzc2lmaWNhdGlvblwiKSksZyYmbnVsbD09PWcuY2xhc3NpZmljYXRpb24pe3ZhciB4PVtdLE89W1widGltZVwiLFwiZ2VvXCIsXCJtZXRyaWNcIl0sQT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLmxlbmd0aDtuLS07KWlmKHQ9PT1lW25dKXJldHVybiEwO3JldHVybiExfTtmb3IoYz0wO2M8MztjKyspe3ZhciB3PWdbT1tjXV07bnVsbCE9PXcmJih4PXguY29uY2F0KHcpKX1mb3IoZy5jbGFzc2lmaWNhdGlvbj1bXSxjPTA7YzxtO2MrKylBKGJbY10seCl8fGcuY2xhc3NpZmljYXRpb24ucHVzaChiW2NdKTswPT09Zy5jbGFzc2lmaWNhdGlvbi5sZW5ndGgmJihnLmNsYXNzaWZpY2F0aW9uPW51bGwpfXRoaXMucm9sZT1nLHRoaXMubj1kO2Zvcih2YXIgaj0wLGs9dGhpcy5sZW5ndGg7ajxrO2orKylpZihwW2Jbal1dLmNhdGVnb3J5Lmhhc093blByb3BlcnR5KFwiaW5kZXhcIikpe2lmKEFycmF5LmlzQXJyYXkocFtiW2pdXS5jYXRlZ29yeS5pbmRleCkpe3ZhciBEPXt9LFA9cFtiW2pdXS5jYXRlZ29yeS5pbmRleDtmb3IoYT1QLmxlbmd0aCxvPTA7bzxhO28rKylEW1Bbb11dPW87cFtiW2pdXS5jYXRlZ29yeS5pbmRleD1EfX1lbHNle3ZhciBFPTA7Zm9yKHMgaW4gcFtiW2pdXS5jYXRlZ29yeS5pbmRleD17fSxwW2Jbal1dLmNhdGVnb3J5LmxhYmVsKXBbYltqXV0uY2F0ZWdvcnkuaW5kZXhbc109RSsrfX1lbHNlIHRoaXMubGVuZ3RoPTA7YnJlYWs7Y2FzZVwiZGltZW5zaW9uXCI6aWYoIWkuaGFzT3duUHJvcGVydHkoXCJfX3RyZWVfX1wiKSlyZXR1cm4gbmV3IHQoe3ZlcnNpb246XCIyLjBcIixjbGFzczpcImRhdGFzZXRcIixkaW1lbnNpb246e2Q6aX0saWQ6W1wiZFwiXSxzaXplOltmdW5jdGlvbih0KXt2YXIgZT12b2lkIDA9PT10LmluZGV4P3QubGFiZWw6dC5pbmRleDtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9lLmxlbmd0aDpPYmplY3Qua2V5cyhlKS5sZW5ndGh9KGkuY2F0ZWdvcnkpXSx2YWx1ZTpbbnVsbF19KS5EaW1lbnNpb24oMCk7dmFyIHo9W10sUz0obD1pLl9fdHJlZV9fKS5jYXRlZ29yeTtpZighbC5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5XCIpKXJldHVybjtpZighUy5oYXNPd25Qcm9wZXJ0eShcImxhYmVsXCIpKWZvcihzIGluIFMubGFiZWw9e30sUy5pbmRleClTLmxhYmVsW3NdPXM7Zm9yKHMgaW4gUy5pbmRleCl6W1MuaW5kZXhbc11dPXM7dGhpcy5fX3RyZWVfXz1sLHRoaXMubGFiZWw9bC5sYWJlbHx8bnVsbCx0aGlzLm5vdGU9bC5ub3RlfHxudWxsLHRoaXMubGluaz1sLmxpbmt8fG51bGwsdGhpcy5ocmVmPWwuaHJlZnx8bnVsbCx0aGlzLmlkPXosdGhpcy5sZW5ndGg9ei5sZW5ndGgsdGhpcy5yb2xlPWkucm9sZSx0aGlzLmhpZXJhcmNoeT1TLmhhc093blByb3BlcnR5KFwiY2hpbGRcIiksdGhpcy5leHRlbnNpb249bC5leHRlbnNpb258fG51bGw7YnJlYWs7Y2FzZVwiY2F0ZWdvcnlcIjp2YXIgST1pLmNoaWxkO3RoaXMuaWQ9SSx0aGlzLmxlbmd0aD1udWxsPT09ST8wOkkubGVuZ3RoLHRoaXMuaW5kZXg9aS5pbmRleCx0aGlzLmxhYmVsPWkubGFiZWwsdGhpcy5ub3RlPWkubm90ZXx8bnVsbCx0aGlzLnVuaXQ9aS51bml0LHRoaXMuY29vcmRpbmF0ZXM9aS5jb29yZDticmVhaztjYXNlXCJjb2xsZWN0aW9uXCI6aWYodGhpcy5sZW5ndGg9MCx0aGlzLmxhYmVsPWkubGFiZWx8fG51bGwsdGhpcy5ub3RlPWkubm90ZXx8bnVsbCx0aGlzLmxpbms9aS5saW5rfHxudWxsLHRoaXMuaHJlZj1pLmhyZWZ8fG51bGwsdGhpcy51cGRhdGVkPWkudXBkYXRlZHx8bnVsbCx0aGlzLnNvdXJjZT1pLnNvdXJjZXx8bnVsbCx0aGlzLmV4dGVuc2lvbj1pLmV4dGVuc2lvbnx8bnVsbCxudWxsIT09dGhpcy5saW5rJiZpLmxpbmsuaXRlbSl7dmFyIEM9aS5saW5rLml0ZW07aWYodGhpcy5sZW5ndGg9QXJyYXkuaXNBcnJheShDKT9DLmxlbmd0aDowLHRoaXMubGVuZ3RoKWZvcihvPTA7bzx0aGlzLmxlbmd0aDtvKyspdGhpcy5pZFtvXT1DW29dLmhyZWZ9fX1mdW5jdGlvbiBlKHQpe3JldHVyblwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmJ1ZmZlcil9ZnVuY3Rpb24gbih0KXtyZXR1cm4tMSE9PVtcIkludDhBcnJheVwiLFwiVWludDhBcnJheVwiLFwiVWludDhDbGFtcGVkQXJyYXlcIixcIkludDE2QXJyYXlcIixcIlVpbnQxNkFycmF5XCIsXCJJbnQzMkFycmF5XCIsXCJVaW50MzJBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkJpZ0ludDY0QXJyYXlcIixcIkJpZ1VpbnQ2NEFycmF5XCJdLmluZGV4T2YodCl9ZnVuY3Rpb24gaSh0KXtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IodC5zdGF0dXMrXCIgXCIrdC5zdGF0dXNUZXh0KTtyZXR1cm4gdC5qc29uKCl9ZnVuY3Rpb24gcihlLG4scil7dmFyIGw9XCJvYmplY3RcIj09dHlwZW9mIG4/bjpudWxsO3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHImJihyPW51bGwpLHJ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG58fChyPW4pLFwib2JqZWN0XCI9PXR5cGVvZiBlP25ldyB0KGUscik6XCJ2ZXJzaW9uXCI9PT1lP1wiMS41LjNcIjpmZXRjaD9mZXRjaChlLGwpLnRoZW4oaSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUscil9KSk6dm9pZCAwfXQucHJvdG90eXBlLkl0ZW09ZnVuY3Rpb24odCl7aWYobnVsbD09PXRoaXN8fFwiY29sbGVjdGlvblwiIT09dGhpcy5jbGFzc3x8IXRoaXMubGVuZ3RoKXJldHVybiBudWxsO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiB0PnRoaXMubGVuZ3RofHx0PDA/bnVsbDp0aGlzLmxpbmsuaXRlbVt0XTt2YXIgZSxuPVtdO2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXtpZighdC5jbGFzcyYmIXQuZm9sbG93KXJldHVybiBudWxsO3QuY2xhc3MmJihlPVwiZGF0YXNldFwiPT09dC5jbGFzcyYmXCJib29sZWFuXCI9PXR5cGVvZiB0LmVtYmVkZGVkPyEwPT09dC5lbWJlZGRlZD9mdW5jdGlvbih0LGUsaSl7dmFyIHI9dC5saW5rLml0ZW1bZV07aS5jbGFzcz09PXIuY2xhc3MmJnIuaWQmJnIuc2l6ZSYmci5kaW1lbnNpb24mJm4ucHVzaChyKX06ZnVuY3Rpb24odCxlLGkpe3ZhciByPXQubGluay5pdGVtW2VdO2kuY2xhc3MhPT1yLmNsYXNzfHxyLmlkJiZyLnNpemUmJnIuZGltZW5zaW9ufHxuLnB1c2gocil9OmZ1bmN0aW9uKHQsZSxpKXtpLmNsYXNzPT09dC5saW5rLml0ZW1bZV0uY2xhc3MmJm4ucHVzaCh0LmxpbmsuaXRlbVtlXSl9KX1lbHNlIGU9ZnVuY3Rpb24odCxlKXtuLnB1c2godC5saW5rLml0ZW1bZV0pfTtmb3IodmFyIGk9MDtpPHRoaXMubGVuZ3RoO2krKyllKHRoaXMsaSx0KTtyZXR1cm4gbn0sdC5wcm90b3R5cGUuRGF0YXNldD1mdW5jdGlvbihlKXtpZihudWxsPT09dGhpcylyZXR1cm4gbnVsbDtpZihcImRhdGFzZXRcIj09PXRoaXMuY2xhc3MpcmV0dXJuIHZvaWQgMCE9PWU/dGhpczpbdGhpc107dmFyIG4saT1bXSxyPTA7aWYoXCJjb2xsZWN0aW9uXCI9PT10aGlzLmNsYXNzKXt2YXIgbD10aGlzLkl0ZW0oe2NsYXNzOlwiZGF0YXNldFwiLGVtYmVkZGVkOiEwfSk7aWYodm9pZCAwPT09ZSl7Zm9yKG49bC5sZW5ndGg7cjxuO3IrKylpLnB1c2gobmV3IHQobFtyXSkpO3JldHVybiBpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBlJiZlPj0wJiZlPGwubGVuZ3RoKXJldHVybiBuZXcgdChsW2VdKTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlmb3Iobj1sLmxlbmd0aDtyPG47cisrKWlmKGxbcl0uaHJlZj09PWUpcmV0dXJuIG5ldyB0KGxbcl0pO3JldHVybiBudWxsfWlmKFwiYnVuZGxlXCIhPT10aGlzLmNsYXNzKXJldHVybiBudWxsO2lmKHZvaWQgMD09PWUpe2ZvcihuPXRoaXMuaWQubGVuZ3RoO3I8bjtyKyspaS5wdXNoKHRoaXMuRGF0YXNldCh0aGlzLmlkW3JdKSk7cmV0dXJuIGl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3ZhciBzPXRoaXMuaWRbZV07cmV0dXJuIHZvaWQgMCE9PXM/dGhpcy5EYXRhc2V0KHMpOm51bGx9dmFyIGE9dGhpcy5fX3RyZWVfX1tlXTtyZXR1cm4gdm9pZCAwPT09YT9udWxsOm5ldyB0KHtjbGFzczpcImRhdGFzZXRcIixfX3RyZWVfXzphfSl9LHQucHJvdG90eXBlLkRpbWVuc2lvbj1mdW5jdGlvbihlLG4pe249XCJib29sZWFuXCIhPXR5cGVvZiBufHxuO3ZhciBpLHI9W10sbD10aGlzLmlkLmxlbmd0aCxzPWZ1bmN0aW9uKHQsZSl7aWYobnVsbCE9PXQpZm9yKHZhciBuIGluIHQpZm9yKHZhciBpPW51bGwhPT10W25dP3Rbbl0ubGVuZ3RoOjA7aS0tOylpZih0W25dW2ldPT09ZSlyZXR1cm4gbjtyZXR1cm4gbnVsbH07aWYobnVsbD09PXRoaXN8fFwiZGF0YXNldFwiIT09dGhpcy5jbGFzcylyZXR1cm4gbnVsbDtpZih2b2lkIDA9PT1lKXtmb3IoaT0wO2k8bDtpKyspci5wdXNoKHRoaXMuRGltZW5zaW9uKHRoaXMuaWRbaV0pKTtyZXR1cm4gcn1pZihcIm51bWJlclwiPT10eXBlb2YgZSl7dmFyIGE9dGhpcy5pZFtlXTtyZXR1cm4gdm9pZCAwIT09YT90aGlzLkRpbWVuc2lvbihhLG4pOm51bGx9dmFyIG89dGhpcy5yb2xlO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlKXtpZihlLmhhc093blByb3BlcnR5KFwicm9sZVwiKSl7Zm9yKGk9MDtpPGw7aSsrKXt2YXIgdT10aGlzLmlkW2ldO3Mobyx1KT09PWUucm9sZSYmci5wdXNoKHRoaXMuRGltZW5zaW9uKHUsbikpfXJldHVybiB2b2lkIDA9PT1yWzBdP251bGw6cn1yZXR1cm4gbnVsbH12YXIgaD10aGlzLl9fdHJlZV9fLmRpbWVuc2lvbjtpZih2b2lkIDA9PT1oKXJldHVybiBudWxsO3ZhciBmPWhbZV07cmV0dXJuIHZvaWQgMD09PWY/bnVsbDpuP25ldyB0KHtjbGFzczpcImRpbWVuc2lvblwiLF9fdHJlZV9fOmYscm9sZTpzKG8sZSl9KTpmdW5jdGlvbih0LGUpe3ZhciBuPVtdO2Zvcih2YXIgaSBpbiB0KW5bdFtpXV09ZVtpXTtyZXR1cm4gbn0oZi5jYXRlZ29yeS5pbmRleCxmLmNhdGVnb3J5LmxhYmVsKX0sdC5wcm90b3R5cGUuQ2F0ZWdvcnk9ZnVuY3Rpb24oZSl7aWYobnVsbD09PXRoaXN8fFwiZGltZW5zaW9uXCIhPT10aGlzLmNsYXNzKXJldHVybiBudWxsO2lmKHZvaWQgMD09PWUpe2Zvcih2YXIgbj1bXSxpPTAscj10aGlzLmlkLmxlbmd0aDtpPHI7aSsrKW4ucHVzaCh0aGlzLkNhdGVnb3J5KHRoaXMuaWRbaV0pKTtyZXR1cm4gbn1pZihcIm51bWJlclwiPT10eXBlb2YgZSl7dmFyIGw9dGhpcy5pZFtlXTtyZXR1cm4gdm9pZCAwIT09bD90aGlzLkNhdGVnb3J5KGwpOm51bGx9dmFyIHM9dGhpcy5fX3RyZWVfXy5jYXRlZ29yeTtpZih2b2lkIDA9PT1zKXJldHVybiBudWxsO3ZhciBhPXMuaW5kZXhbZV07aWYodm9pZCAwPT09YSlyZXR1cm4gbnVsbDt2YXIgbz1zLnVuaXQmJnMudW5pdFtlXXx8bnVsbCx1PXMuY29vcmRpbmF0ZXMmJnMuY29vcmRpbmF0ZXNbZV18fG51bGwsaD1zLmNoaWxkJiZzLmNoaWxkW2VdfHxudWxsLGY9cy5ub3RlJiZzLm5vdGVbZV18fG51bGw7cmV0dXJuIG5ldyB0KHtjbGFzczpcImNhdGVnb3J5XCIsaW5kZXg6YSxsYWJlbDpzLmxhYmVsW2VdLG5vdGU6ZixjaGlsZDpoLHVuaXQ6byxjb29yZDp1fSl9LHQucHJvdG90eXBlLkRpY2U9ZnVuY3Rpb24obixpLHIpe3ZhciBsLHMsYSxvLHU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5oYXNPd25Qcm9wZXJ0eShlKSYmISF0W2VdfTtpZihudWxsPT09dGhpc3x8XCJkYXRhc2V0XCIhPT10aGlzLmNsYXNzfHxudWxsPT09dGhpcy52YWx1ZSlyZXR1cm4gbnVsbDtpZihcIm9iamVjdFwiIT10eXBlb2YgbilyZXR1cm4gdGhpcztcIm9iamVjdFwiIT10eXBlb2YgaT8oXCJib29sZWFuXCI9PXR5cGVvZiBpJiYhMD09PWkmJihsPSEwKSxcImJvb2xlYW5cIj09dHlwZW9mIHImJiEwPT09cnx8KHI9ITEpKToobD11KGksXCJjbG9uZVwiKSxyPXUoaSxcImRyb3BcIikscz11KGksXCJzdHJpbmdpZnlcIiksYT11KGksXCJvdmFsdWVcIiksbz11KGksXCJvc3RhdHVzXCIpKTt2YXIgaCxmPXRoaXMudmFsdWUsYz1sP25ldyB0KEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcykpKTp0aGlzLGQ9Yy5zdGF0dXMsdj1bXSx5PVtdLHA9ZnVuY3Rpb24odCxlKXt2YXIgbixpLHIsbD0obj10LGk9ZSxyPXt9LEFycmF5LmlzQXJyYXkobltpXSk/KG5baV0uZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtudWxsIT09dCYmKHJbU3RyaW5nKGUpXT10KX0pKSxyKTpuW2ldKTtkZWxldGUgdFtlXSx0W2VdPWx9O0FycmF5LmlzQXJyYXkobikmJihuPWZ1bmN0aW9uKHQpe3ZhciBlPXt9O3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2VbdFswXV09dFsxXX0pKSxlfShuKSksbnVsbD09PW4mJihuPXt9KTt2YXIgZz1PYmplY3Qua2V5cyhuKTtyZXR1cm4gZy5sZW5ndGg+MCYmKGcuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9blt0XTtBcnJheS5pc0FycmF5KGUpfHwoblt0XT1bZV0pLDA9PT1uW3RdLmxlbmd0aCYmZGVsZXRlIG5bdF19KSksciYmKG49ZnVuY3Rpb24odCl7dmFyIGU9e307cmV0dXJuIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKG4pe2Vbbl09Yy5EaW1lbnNpb24obikuaWQuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4tMT09PXRbbl0uaW5kZXhPZihlKX0pKX0pKSxlfShuKSksYy50b1RhYmxlKHt0eXBlOlwiYXJyb2JqXCIsY29udGVudDpcImlkXCIsc3RhdHVzOiEwfSkuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXt2YXIgaT1bXTtnLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPW5bZV0sbD1bXTtyLmZvckVhY2goKGZ1bmN0aW9uKG4pe2wucHVzaCh0W2VdPT09bil9KSksaS5wdXNoKC0xIT09bC5pbmRleE9mKCEwKSl9KSksLTE9PT1pLmluZGV4T2YoITEpJiYodi5wdXNoKHQudmFsdWUpLHkucHVzaCh0LnN0YXR1cykpfSkpLGcuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9Yy5EaW1lbnNpb24odCkuaWQsaT0wLHI9e307Yy5zaXplW2MuaWQuaW5kZXhPZih0KV09blt0XS5sZW5ndGgsZS5mb3JFYWNoKChmdW5jdGlvbihlKXstMSE9PW5bdF0uaW5kZXhPZihlKSYmKHJbZV09aSxpKyspfSkpLGMuX190cmVlX18uZGltZW5zaW9uW3RdLmNhdGVnb3J5LmluZGV4PXJ9KSksYy5uPXYubGVuZ3RoLGMudmFsdWU9Yy5fX3RyZWVfXy52YWx1ZT1lKGYpP2Z1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZnJvbSh0KX0odixmLmNvbnN0cnVjdG9yKTp2LGMuc3RhdHVzPWMuX190cmVlX18uc3RhdHVzPW51bGwhPT1kP3k6bnVsbCkscz8oKGg9Yy5fX3RyZWVfXykuaGFzT3duUHJvcGVydHkoXCJpZFwiKXx8KGgudmVyc2lvbj1cIjIuMFwiLGguaGFzT3duUHJvcGVydHkoXCJjbGFzc1wiKXx8KGguY2xhc3M9XCJkYXRhc2V0XCIpLGguaWQ9aC5kaW1lbnNpb24uaWQsaC5zaXplPWguZGltZW5zaW9uLnNpemUsZGVsZXRlIGguZGltZW5zaW9uLmlkLGRlbGV0ZSBoLmRpbWVuc2lvbi5zaXplLGguZGltZW5zaW9uLmhhc093blByb3BlcnR5KFwicm9sZVwiKSYmKGgucm9sZT1oLmRpbWVuc2lvbi5yb2xlLGRlbGV0ZSBoLmRpbWVuc2lvbi5yb2xlKSksaC5oYXNPd25Qcm9wZXJ0eShcInN0YXR1c1wiKSYmLTEhPT1bXCJudWxsXCIsXCJ7fVwiLFwiW11cIl0uaW5kZXhPZihKU09OLnN0cmluZ2lmeShoLnN0YXR1cykpJiZkZWxldGUgaC5zdGF0dXMsaC5oYXNPd25Qcm9wZXJ0eShcInJvbGVcIikmJihkZWxldGUgaC5yb2xlLmNsYXNzaWZpY2F0aW9uLFtcImdlb1wiLFwidGltZVwiLFwibWV0cmljXCJdLmZvckVhY2goKGZ1bmN0aW9uKHQpe251bGw9PT1oLnJvbGVbdF0mJmRlbGV0ZSBoLnJvbGVbdF19KSkpLGEmJnAoaCxcInZhbHVlXCIpLG8mJmguaGFzT3duUHJvcGVydHkoXCJzdGF0dXNcIikmJnAoaCxcInN0YXR1c1wiKSxKU09OLnN0cmluZ2lmeShoKSk6Y30sdC5wcm90b3R5cGUuU2xpY2U9ZnVuY3Rpb24odCl7aWYobnVsbD09PXRoaXN8fFwiZGF0YXNldFwiIT09dGhpcy5jbGFzc3x8MD09PU9iamVjdC5lbnRyaWVzKHRoaXMudmFsdWUpLmxlbmd0aClyZXR1cm4gbnVsbDtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzO2lmKCFBcnJheS5pc0FycmF5KHQpKXt2YXIgZSxuPVtdO2ZvcihlIGluIHQpbi5wdXNoKFtlLHRbZV1dKTt0PW59cmV0dXJuIHRoaXMuRGljZSh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuW3RbMF0sW3RbMV1dXX0pKSl9LHQucHJvdG90eXBlLkRhdGE9ZnVuY3Rpb24odCxlKXt2YXIgbixpLHI9W10sbD1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdClpZih0Lmhhc093blByb3BlcnR5KGUpKXJldHVybiBlfTtpZihudWxsPT09dGhpc3x8XCJkYXRhc2V0XCIhPT10aGlzLmNsYXNzfHxudWxsPT09dGhpcy52YWx1ZSlyZXR1cm4gbnVsbDtpZih2b2lkIDA9PT10KXtmb3IoaT10aGlzLnZhbHVlLmxlbmd0aCxuPTA7bjxpO24rKylyLnB1c2godGhpcy5EYXRhKG4pKTtyZXR1cm4gcn1pZihcImJvb2xlYW5cIiE9dHlwZW9mIGUmJihlPSEwKSxcIm51bWJlclwiPT10eXBlb2YgdCl7dmFyIHM9dGhpcy52YWx1ZVt0XTtyZXR1cm4gdm9pZCAwPT09cz9udWxsOmU/e3ZhbHVlOnMsc3RhdHVzOnRoaXMuc3RhdHVzP3RoaXMuc3RhdHVzW3RdOm51bGx9OnN9dmFyIGE9XCJvYmplY3RcIixvPXRoaXMuX190cmVlX18sdT1vLnNpemV8fG8uZGltZW5zaW9uJiZvLmRpbWVuc2lvbi5zaXplLGg9dS5sZW5ndGg7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYoIUFycmF5LmlzQXJyYXkodFswXSkpe2lmKHRoaXMubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGY9MSxjPTAsZD1bXSx2PVtdO2ZvcihuPTA7bjxoO24rKylpZih2b2lkIDAhPT10W25dKXtpZihcIm51bWJlclwiIT10eXBlb2YgdFtuXXx8dFtuXT49dVtuXSlyZXR1cm4gbnVsbDtjKz0oZio9bj4wP3VbaC1uXToxKSp0W2gtbi0xXX1lbHNlIGQucHVzaChuKSx2LnB1c2godVtuXSk7aWYoZC5sZW5ndGg+MSlyZXR1cm4gbnVsbDtpZigxPT09ZC5sZW5ndGgpe2Zvcih2YXIgeT0wLHA9dlswXTt5PHA7eSsrKXt2YXIgZz1bXTtmb3Iobj0wO248aDtuKyspbiE9PWRbMF0/Zy5wdXNoKHRbbl0pOmcucHVzaCh5KTtyLnB1c2godGhpcy5EYXRhKGcsZSkpfXJldHVybiByfXJldHVybiBlP3t2YWx1ZTp0aGlzLnZhbHVlW2NdLHN0YXR1czp0aGlzLnN0YXR1cz90aGlzLnN0YXR1c1tjXTpudWxsfTp0aGlzLnZhbHVlW2NdfWE9XCJhcnJheVwifXZhciBiPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaSxyPVtdLHM9e30sYT10LmRpbWVuc2lvbixvPXQuaWR8fGEuaWQsdT10LnNpemV8fGEmJmEuc2l6ZTtpZihcImFycmF5XCI9PT1uKXtmb3IoaT1lLmxlbmd0aDtpLS07KXNbZVtpXVswXV09ZVtpXVsxXTtlPXN9Zm9yKHZhciBoPTAsZj1vLmxlbmd0aDtoPGY7aCsrKXt2YXIgYz1vW2hdLGQ9ZVtjXTtyLnB1c2goXCJzdHJpbmdcIj09dHlwZW9mIGQ/ZDoxPT09dVtoXT9sKGFbY10uY2F0ZWdvcnkuaW5kZXgpOm51bGwpfXJldHVybiByfShvLHQsYSksbT1bXSxfPW8uZGltZW5zaW9uLHg9by5pZHx8Xy5pZDtmb3Iobj0wLGk9Yi5sZW5ndGg7bjxpO24rKyltLnB1c2goX1t4W25dXS5jYXRlZ29yeS5pbmRleFtiW25dXSk7cmV0dXJuIHRoaXMuRGF0YShtLGUpfSx0LnByb3RvdHlwZS50b1RhYmxlPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXRoaXN8fFwiZGF0YXNldFwiIT09dGhpcy5jbGFzc3x8bnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIG51bGw7MT09YXJndW1lbnRzLmxlbmd0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKGU9dCx0PW51bGwpLFwiYXJyb2JqXCIhPT0odD10fHx7ZmllbGQ6XCJsYWJlbFwiLGNvbnRlbnQ6XCJsYWJlbFwiLHZsYWJlbDpcIlZhbHVlXCIsc2xhYmVsOlwiU3RhdHVzXCIsdHlwZTpcImFycmF5XCIsc3RhdHVzOiExLHVuaXQ6ITEsYnk6bnVsbCxwcmVmaXg6XCJcIixkcm9wOltdLG1ldGE6ITEsY29tbWE6ITEsYnlsYWJlbDohMX0pLnR5cGUmJlwib2JqYXJyXCIhPT10LnR5cGV8fHZvaWQgMCE9PXQuZmllbGR8fCh0LmZpZWxkPVwiaWRcIik7dmFyIGkscixsLHMsYSxvLHUsaCxmLGM9XCJpZFwiPT09dC5maWVsZCxkPWZ1bmN0aW9uKHQpe3JldHVybihjP1widmFsdWVcIjp0KXx8XCJWYWx1ZVwifSx2PWZ1bmN0aW9uKHQpe3JldHVybihjP1wic3RhdHVzXCI6dCl8fFwiU3RhdHVzXCJ9LHk9dGhpcy5fX3RyZWVfXyxwPSEwPT09dC5zdGF0dXM7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSl7aT10aGlzLnRvVGFibGUodCk7dmFyIGc9W10sYj1cImFycmF5XCIhPT10LnR5cGU/MDoxO2ZvcihhPShWPVwib2JqZWN0XCIhPT10LnR5cGU/aS5zbGljZShiKTppLnJvd3Muc2xpY2UoMCkpLmxlbmd0aCxyPTA7cjxhO3IrKyl7dmFyIG09ZS5jYWxsKHRoaXMsVltyXSxyKTt2b2lkIDAhPT1tJiZnLnB1c2gobSl9cmV0dXJuXCJvYmplY3RcIj09PXQudHlwZT97Y29sczppLmNvbHMscm93czpnfTooXCJhcnJheVwiPT09dC50eXBlJiZnLnVuc2hpZnQoaVswXSksZyl9aWYoXCJhcnJvYmpcIj09PXQudHlwZXx8XCJvYmphcnJcIj09PXQudHlwZSl7dmFyIF89W10seD15LnJvbGUmJnkucm9sZS5tZXRyaWMsTz1mdW5jdGlvbigpe30sQT17fSx3PXRoaXMsaj13LmlkLGs9dC5ieSYmLTEhPT1qLmluZGV4T2YodC5ieSk/dC5ieTpudWxsLEQ9ITA9PT10Lm1ldGEsUD12b2lkIDAhPT10LmRyb3AmJkFycmF5LmlzQXJyYXkodC5kcm9wKT90LmRyb3A6W10sRT0hMD09PXQuY29tbWEsej0hMD09PXQuYnlsYWJlbCxTPXcudmFsdWUuY29uc3RydWN0b3IsST1mdW5jdGlvbihlKXt2YXIgaSxyPXt9LGw9ZCh0LnZsYWJlbCk7aWYoXCJvYmphcnJcIj09PXQudHlwZSYmKGk9bnVsbD09PWsmJm4oUy5uYW1lKT9mdW5jdGlvbih0KXtyW3RdPXQ9PT1sP1MuZnJvbShlLChmdW5jdGlvbihlKXtyZXR1cm4gZVt0XX0pKTplLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGVbdF19KSl9OmZ1bmN0aW9uKHQpe3JbdF09ZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlW3RdfSkpfSxPYmplY3Qua2V5cyhlWzBdKS5mb3JFYWNoKGkpLGU9ciksRCl7cj17fTtyZXR1cm4gai5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT13LkRpbWVuc2lvbih0KTtyW3RdPXtsYWJlbDplLmxhYmVsLHJvbGU6ZS5yb2xlLGNhdGVnb3JpZXM6e2lkOmUuaWQsbGFiZWw6dy5EaW1lbnNpb24odCwhMSl9fX0pKSx7bWV0YTp7bGFiZWw6dy5sYWJlbCxzb3VyY2U6dy5zb3VyY2UsdXBkYXRlZDp3LnVwZGF0ZWQsaWQ6aixzdGF0dXM6cCx1bml0OnQudW5pdCxieTprLGJ5bGFiZWw6eixkcm9wOm51bGwhPT1rJiZQLmxlbmd0aD4wP1A6bnVsbCxwcmVmaXg6bnVsbCE9PWs/R3x8XCJcIjpudWxsLGNvbW1hOkUsZGltZW5zaW9uczpyfSxkYXRhOmV9fXJldHVybiBlfTtrJiYodC5maWVsZD1cImlkXCIpO3ZhciBDPShpPXRoaXMudG9UYWJsZSh7ZmllbGQ6dC5maWVsZCx2bGFiZWw6dC52bGFiZWwsc2xhYmVsOnQuc2xhYmVsLGNvbnRlbnQ6dC5jb250ZW50LHN0YXR1czpwfSkpLnNoaWZ0KCk7aWYobnVsbD09PWsmJnQudW5pdCYmeCl7aWYoXCJpZFwiIT09dC5jb250ZW50KWZvcih2YXIgVD14Lmxlbmd0aDtULS07KXt2YXIgVT10aGlzLkRpbWVuc2lvbih4W1RdKTtBW3hbVF1dPXt9O2Zvcih2YXIgSj1VLmxlbmd0aDtKLS07KUFbeFtUXV1bVS5DYXRlZ29yeShKKS5sYWJlbF09VS5pZFtKXX1PPWZ1bmN0aW9uKGUsbil7aWYoLTEhPT14LmluZGV4T2YoZSkpe3ZhciBpPXkuZGltZW5zaW9uW2VdLmNhdGVnb3J5O2kudW5pdD9OLnVuaXQ9aS51bml0W1wiaWRcIiE9PXQuY29udGVudD9BW2VdW25dOm5dOk4udW5pdD1udWxsfX0sdC51bml0PSEwfWVsc2UgdC51bml0PSExO2ZvcihhPWkubGVuZ3RoLHI9MDtyPGE7cisrKXt2YXIgTj17fTtmb3IobD1pW3JdLmxlbmd0aDtsLS07KU5bQ1tsXV09aVtyXVtsXSxPKENbbF0saVtyXVtsXSk7Xy5wdXNoKE4pfWlmKEUmJl8uZm9yRWFjaCgoZnVuY3Rpb24odCl7bnVsbCE9PXQudmFsdWUmJih0LnZhbHVlPShcIlwiK3QudmFsdWUpLnJlcGxhY2UoXCIuXCIsXCIsXCIpKX0pKSxudWxsIT09ayl7dmFyIEIsRj17fSxWPVtdLHE9e30sRz12b2lkIDAhPT10LnByZWZpeD90LnByZWZpeDpcIlwiO1AuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXsoIXcuRGltZW5zaW9uKHQpfHx3LkRpbWVuc2lvbih0KS5sZW5ndGg+MSkmJihQW2VdPVwiXCIpfSkpO3ZhciBIPWouZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdCE9PWsmJi0xPT09UC5pbmRleE9mKHQpfSkpLEs9dy5EaW1lbnNpb24oayk7Zm9yKHZhciBMIGluXCJpZFwiIT09dC5jb250ZW50P3o/Qj1mdW5jdGlvbih0LGUsbil7dFtlXVtHK25ba11dPW4udmFsdWV9OihLLkNhdGVnb3J5KCkuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtxW3QubGFiZWxdPUsuaWRbZV19KSksQj1mdW5jdGlvbih0LGUsbil7dFtlXVtHK3FbbltrXV1dPW4udmFsdWV9KTpCPWZ1bmN0aW9uKHQsZSxuKXt0W2VdW0crbltrXV09bi52YWx1ZX0sXy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbih0LGUpe3ZhciBuPVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe24ucHVzaCh0W2VdKX0pKSxuLmpvaW4oXCJcXHRcIil9KHQsSCk7dm9pZCAwPT09RltlXSYmKEZbZV09ZnVuY3Rpb24odCxlKXt2YXIgbj17fTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlKXtuW2VdPXRbZV19KSksbn0odCxIKSksQihGLGUsdCxrKX0pKSxGKVYucHVzaChGW0xdKTtyZXR1cm4gcD0hMSxJKFYpfXJldHVybiBJKF8pfWlmKFwib2JqZWN0XCI9PT10LnR5cGUpe3ZhciBNPVwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLnZhbHVlWzBdfHxudWxsPT09dGhpcy52YWx1ZVswXT9cIm51bWJlclwiOlwic3RyaW5nXCI7bz1mdW5jdGlvbih0LGUpe3ZhciBuPWMmJnR8fGV8fHQ7aXQucHVzaCh7aWQ6dCxsYWJlbDpuLHR5cGU6XCJzdHJpbmdcIn0pfSx1PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1kKHQpLHI9dihlKTtuJiZpdC5wdXNoKHtpZDpcInN0YXR1c1wiLGxhYmVsOnIsdHlwZTpcInN0cmluZ1wifSksaXQucHVzaCh7aWQ6XCJ2YWx1ZVwiLGxhYmVsOmksdHlwZTpNfSl9LGg9ZnVuY3Rpb24odCl7eXQucHVzaCh7djp0fSl9LGY9ZnVuY3Rpb24odCl7eXQucHVzaCh7djp0fSkscnQucHVzaCh7Yzp5dH0pfX1lbHNlIG89ZnVuY3Rpb24odCxlKXt2YXIgbj1jJiZ0fHxlfHx0O2l0LnB1c2gobil9LHU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWQodCkscj12KGUpO24mJml0LnB1c2gociksaXQucHVzaChpKSxudC5wdXNoKGl0KX0saD1mdW5jdGlvbih0KXt5dC5wdXNoKHQpfSxmPWZ1bmN0aW9uKHQpe3l0LnB1c2godCksbnQucHVzaCh5dCl9O3ZhciBRPXkuZGltZW5zaW9uLFI9eS5pZHx8US5pZCxXPXkuc2l6ZXx8US5zaXplLFg9Ui5sZW5ndGg7aWYoWCE9Vy5sZW5ndGgpcmV0dXJuITE7dmFyIFk9W10sWj0xLCQ9KFQ9MSxbXSksdHQ9W10sZXQ9W10sbnQ9W10saXQ9W10scnQ9W107Zm9yKHI9MDtyPFg7cisrKXt2YXIgbHQ9UltyXTtvKGx0LFFbbHRdLmxhYmVsKSxaKj1XW3JdLFQqPVdbcl07dmFyIHN0PVtdO2ZvcihsPTA7bDxXW3JdO2wrKylmb3IodmFyIGF0IGluIFFbUltyXV0uY2F0ZWdvcnkuaW5kZXgpaWYoUVtSW3JdXS5jYXRlZ29yeS5pbmRleFthdF09PT1sKXt2YXIgb3Q9XCJpZFwiIT09dC5jb250ZW50JiZRW1Jbcl1dLmNhdGVnb3J5LmxhYmVsP1FbUltyXV0uY2F0ZWdvcnkubGFiZWxbYXRdOmF0O3N0LnB1c2gob3QpfVkucHVzaChzdCksJC5wdXNoKFQpfWZvcih1KHQudmxhYmVsLHQuc2xhYmVsLHApLGE9WS5sZW5ndGgscj0wO3I8YTtyKyspe2Zvcih2YXIgdXQ9W10saHQ9MCxmdD1ZW3JdLmxlbmd0aDtodDxmdDtodCsrKWZvcih2YXIgY3Q9MDtjdDxaLyRbcl07Y3QrKyl1dC5wdXNoKFlbcl1baHRdKTt0dC5wdXNoKHV0KX1mb3IoYT10dC5sZW5ndGgscj0wO3I8YTtyKyspe3ZhciBkdD1bXSx2dD0wO2ZvcihzPTA7czxaO3MrKylkdC5wdXNoKHR0W3JdW3Z0XSksKyt2dD09PXR0W3JdLmxlbmd0aCYmKHZ0PTApO2V0LnB1c2goZHQpfWZvcihzPTA7czxaO3MrKyl7dmFyIHl0PVtdO2E9dHQubGVuZ3RoO2Zvcih2YXIgcHQ9MDtwdDxhO3B0KyspaChldFtwdF1bc10pO3AmJmgodGhpcy5zdGF0dXM/dGhpcy5zdGF0dXNbc106bnVsbCksZih0aGlzLnZhbHVlW3NdKX1yZXR1cm5cIm9iamVjdFwiPT09dC50eXBlP3tjb2xzOml0LHJvd3M6cnR9Om50fSx0LnByb3RvdHlwZS5ub2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX190cmVlX199LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xhc3N9O2V4cG9ydHtyIGFzIGRlZmF1bHR9O1xuIiwiLyoqXG4gKiBbU2ltcGxlIGxpbmVhciByZWdyZXNzaW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpbXBsZV9saW5lYXJfcmVncmVzc2lvbilcbiAqIGlzIGEgc2ltcGxlIHdheSB0byBmaW5kIGEgZml0dGVkIGxpbmVcbiAqIGJldHdlZW4gYSBzZXQgb2YgY29vcmRpbmF0ZXMuIFRoaXMgYWxnb3JpdGhtIGZpbmRzIHRoZSBzbG9wZSBhbmQgeS1pbnRlcmNlcHQgb2YgYSByZWdyZXNzaW9uIGxpbmVcbiAqIHVzaW5nIHRoZSBsZWFzdCBzdW0gb2Ygc3F1YXJlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBkYXRhIGFuIGFycmF5IG9mIHR3by1lbGVtZW50IG9mIGFycmF5cyxcbiAqIGxpa2UgYFtbMCwgMV0sIFsyLCAzXV1gXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBzbG9wZSBhbmQgaW50ZXJzZWN0IG9mIHJlZ3Jlc3Npb24gbGluZVxuICogQGV4YW1wbGVcbiAqIGxpbmVhclJlZ3Jlc3Npb24oW1swLCAwXSwgWzEsIDFdXSk7IC8vID0+IHsgbTogMSwgYjogMCB9XG4gKi9cbmZ1bmN0aW9uIGxpbmVhclJlZ3Jlc3Npb24oZGF0YSkge1xuICAgIHZhciBtO1xuICAgIHZhciBiO1xuXG4gICAgLy8gU3RvcmUgZGF0YSBsZW5ndGggaW4gYSBsb2NhbCB2YXJpYWJsZSB0byByZWR1Y2VcbiAgICAvLyByZXBlYXRlZCBvYmplY3QgcHJvcGVydHkgbG9va3Vwc1xuICAgIHZhciBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAvL2lmIHRoZXJlJ3Mgb25seSBvbmUgcG9pbnQsIGFyYml0cmFyaWx5IGNob29zZSBhIHNsb3BlIG9mIDBcbiAgICAvL2FuZCBhIHktaW50ZXJjZXB0IG9mIHdoYXRldmVyIHRoZSB5IG9mIHRoZSBpbml0aWFsIHBvaW50IGlzXG4gICAgaWYgKGRhdGFMZW5ndGggPT09IDEpIHtcbiAgICAgICAgbSA9IDA7XG4gICAgICAgIGIgPSBkYXRhWzBdWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgb3VyIHN1bXMgYW5kIHNjb3BlIHRoZSBgbWAgYW5kIGBiYFxuICAgICAgICAvLyB2YXJpYWJsZXMgdGhhdCBkZWZpbmUgdGhlIGxpbmUuXG4gICAgICAgIHZhciBzdW1YID0gMDtcbiAgICAgICAgdmFyIHN1bVkgPSAwO1xuICAgICAgICB2YXIgc3VtWFggPSAwO1xuICAgICAgICB2YXIgc3VtWFkgPSAwO1xuXG4gICAgICAgIC8vIFVzZSBsb2NhbCB2YXJpYWJsZXMgdG8gZ3JhYiBwb2ludCB2YWx1ZXNcbiAgICAgICAgLy8gd2l0aCBtaW5pbWFsIG9iamVjdCBwcm9wZXJ0eSBsb29rdXBzXG4gICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIHZhciB5O1xuXG4gICAgICAgIC8vIEdhdGhlciB0aGUgc3VtIG9mIGFsbCB4IHZhbHVlcywgdGhlIHN1bSBvZiBhbGxcbiAgICAgICAgLy8geSB2YWx1ZXMsIGFuZCB0aGUgc3VtIG9mIHheMiBhbmQgKHgqeSkgZm9yIGVhY2hcbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIG1hdGggbm90YXRpb24sIHRoZXNlIHdvdWxkIGJlIFNTX3gsIFNTX3ksIFNTX3h4LCBhbmQgU1NfeHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHggPSBwb2ludFswXTtcbiAgICAgICAgICAgIHkgPSBwb2ludFsxXTtcblxuICAgICAgICAgICAgc3VtWCArPSB4O1xuICAgICAgICAgICAgc3VtWSArPSB5O1xuXG4gICAgICAgICAgICBzdW1YWCArPSB4ICogeDtcbiAgICAgICAgICAgIHN1bVhZICs9IHggKiB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYG1gIGlzIHRoZSBzbG9wZSBvZiB0aGUgcmVncmVzc2lvbiBsaW5lXG4gICAgICAgIG0gPVxuICAgICAgICAgICAgKGRhdGFMZW5ndGggKiBzdW1YWSAtIHN1bVggKiBzdW1ZKSAvXG4gICAgICAgICAgICAoZGF0YUxlbmd0aCAqIHN1bVhYIC0gc3VtWCAqIHN1bVgpO1xuXG4gICAgICAgIC8vIGBiYCBpcyB0aGUgeS1pbnRlcmNlcHQgb2YgdGhlIGxpbmUuXG4gICAgICAgIGIgPSBzdW1ZIC8gZGF0YUxlbmd0aCAtIChtICogc3VtWCkgLyBkYXRhTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBib3RoIHZhbHVlcyBhcyBhbiBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbTogbSxcbiAgICAgICAgYjogYlxuICAgIH07XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIG91dHB1dCBvZiBgbGluZWFyUmVncmVzc2lvbmA6IGFuIG9iamVjdFxuICogd2l0aCBgbWAgYW5kIGBiYCB2YWx1ZXMgaW5kaWNhdGluZyBzbG9wZSBhbmQgaW50ZXJjZXB0LFxuICogcmVzcGVjdGl2ZWx5LCBnZW5lcmF0ZSBhIGxpbmUgZnVuY3Rpb24gdGhhdCB0cmFuc2xhdGVzXG4gKiB4IHZhbHVlcyBpbnRvIHkgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYiBvYmplY3Qgd2l0aCBgbWAgYW5kIGBiYCBtZW1iZXJzLCByZXByZXNlbnRpbmdcbiAqIHNsb3BlIGFuZCBpbnRlcnNlY3Qgb2YgZGVzaXJlZCBsaW5lXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IG1ldGhvZCB0aGF0IGNvbXB1dGVzIHktdmFsdWUgYXQgYW55IGdpdmVuXG4gKiB4LXZhbHVlIG9uIHRoZSBsaW5lLlxuICogQGV4YW1wbGVcbiAqIHZhciBsID0gbGluZWFyUmVncmVzc2lvbkxpbmUobGluZWFyUmVncmVzc2lvbihbWzAsIDBdLCBbMSwgMV1dKSk7XG4gKiBsKDApIC8vID0gMFxuICogbCgyKSAvLyA9IDJcbiAqIGxpbmVhclJlZ3Jlc3Npb25MaW5lKHsgYjogMCwgbTogMSB9KSgxKTsgLy8gPT4gMVxuICogbGluZWFyUmVncmVzc2lvbkxpbmUoeyBiOiAxLCBtOiAxIH0pKDEpOyAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGxpbmVhclJlZ3Jlc3Npb25MaW5lKG1iIC8qOiB7IGI6IG51bWJlciwgbTogbnVtYmVyIH0qLykge1xuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgYSBgeWAgdmFsdWUgZm9yIGVhY2hcbiAgICAvLyB4IHZhbHVlIGl0IGlzIGdpdmVuLCBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIGBiYCBhbmQgYGFgXG4gICAgLy8gdGhhdCB3ZSBqdXN0IGNvbXB1dGVkLlxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbWIuYiArIG1iLm0gKiB4O1xuICAgIH07XG59XG5cbi8qKlxuICogT3VyIGRlZmF1bHQgc3VtIGlzIHRoZSBbS2FoYW4tQmFidXNrYSBhbGdvcml0aG1dKGh0dHBzOi8vcGRmcy5zZW1hbnRpY3NjaG9sYXIub3JnLzE3NjAvN2Q0NjdjZGExZDAyNzdhZDI3MmRlYjIxMTM1MzMxMzFkYzA5LnBkZikuXG4gKiBUaGlzIG1ldGhvZCBpcyBhbiBpbXByb3ZlbWVudCBvdmVyIHRoZSBjbGFzc2ljYWxcbiAqIFtLYWhhbiBzdW1tYXRpb24gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYWhhbl9zdW1tYXRpb25fYWxnb3JpdGhtKS5cbiAqIEl0IGFpbXMgYXQgY29tcHV0aW5nIHRoZSBzdW0gb2YgYSBsaXN0IG9mIG51bWJlcnMgd2hpbGUgY29ycmVjdGluZyBmb3JcbiAqIGZsb2F0aW5nLXBvaW50IGVycm9ycy4gVHJhZGl0aW9uYWxseSwgc3VtcyBhcmUgY2FsY3VsYXRlZCBhcyBtYW55XG4gKiBzdWNjZXNzaXZlIGFkZGl0aW9ucywgZWFjaCBvbmUgd2l0aCBpdHMgb3duIGZsb2F0aW5nLXBvaW50IHJvdW5kb2ZmLiBUaGVzZVxuICogbG9zc2VzIGluIHByZWNpc2lvbiBhZGQgdXAgYXMgdGhlIG51bWJlciBvZiBudW1iZXJzIGluY3JlYXNlcy4gVGhpcyBhbHRlcm5hdGl2ZVxuICogYWxnb3JpdGhtIGlzIG1vcmUgYWNjdXJhdGUgdGhhbiB0aGUgc2ltcGxlIHdheSBvZiBjYWxjdWxhdGluZyBzdW1zIGJ5IHNpbXBsZVxuICogYWRkaXRpb24uXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gc3VtIG9mIGFsbCBpbnB1dCBudW1iZXJzXG4gKiBAZXhhbXBsZVxuICogc3VtKFsxLCAyLCAzXSk7IC8vID0+IDZcbiAqL1xuZnVuY3Rpb24gc3VtKHgpIHtcbiAgICAvLyBJZiB0aGUgYXJyYXkgaXMgZW1wdHksIHdlIG5lZWRuJ3QgYm90aGVyIGNvbXB1dGluZyBpdHMgc3VtXG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemluZyB0aGUgc3VtIGFzIHRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIGFycmF5XG4gICAgdmFyIHN1bSA9IHhbMF07XG5cbiAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIHRoZSBmbG9hdGluZy1wb2ludCBlcnJvciBjb3JyZWN0aW9uXG4gICAgdmFyIGNvcnJlY3Rpb24gPSAwO1xuXG4gICAgdmFyIHRyYW5zaXRpb247XG5cbiAgICBpZiAodHlwZW9mIHN1bSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4W2ldICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2l0aW9uID0gc3VtICsgeFtpXTtcblxuICAgICAgICAvLyBIZXJlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjb3JyZWN0aW9uIGluIGEgZGlmZmVyZW50IGZhc2hpb25cbiAgICAgICAgLy8gaWYgdGhlIG5ldyBhYnNvbHV0ZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGFic29sdXRlIHN1bVxuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA+PSBNYXRoLmFicyh4W2ldKSkge1xuICAgICAgICAgICAgY29ycmVjdGlvbiArPSBzdW0gLSB0cmFuc2l0aW9uICsgeFtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gKz0geFtpXSAtIHRyYW5zaXRpb24gKyBzdW07XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gPSB0cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIFJldHVybmluZyB0aGUgY29ycmVjdGVkIHN1bVxuICAgIHJldHVybiBzdW0gKyBjb3JyZWN0aW9uO1xufVxuXG4vKipcbiAqIFRoZSBtZWFuLCBfYWxzbyBrbm93biBhcyBhdmVyYWdlXyxcbiAqIGlzIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBvdmVyIHRoZSBudW1iZXIgb2YgdmFsdWVzLlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gb25lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWFuXG4gKiBAZXhhbXBsZVxuICogbWVhbihbMCwgMTBdKTsgLy8gPT4gNVxuICovXG5mdW5jdGlvbiBtZWFuKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVhbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtKHgpIC8geC5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIHN1bSBvZiBkZXZpYXRpb25zIHRvIHRoZSBOdGggcG93ZXIuXG4gKiBXaGVuIG49MiBpdCdzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zLlxuICogV2hlbiBuPTMgaXQncyB0aGUgc3VtIG9mIGN1YmVkIGRldmlhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4XG4gKiBAcGFyYW0ge251bWJlcn0gbiBwb3dlclxuICogQHJldHVybnMge251bWJlcn0gc3VtIG9mIG50aCBwb3dlciBkZXZpYXRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBpbnB1dCA9IFsxLCAyLCAzXTtcbiAqIC8vIHNpbmNlIHRoZSB2YXJpYW5jZSBvZiBhIHNldCBpcyB0aGUgbWVhbiBzcXVhcmVkXG4gKiAvLyBkZXZpYXRpb25zLCB3ZSBjYW4gY2FsY3VsYXRlIHRoYXQgd2l0aCBzdW1OdGhQb3dlckRldmlhdGlvbnM6XG4gKiBzdW1OdGhQb3dlckRldmlhdGlvbnMoaW5wdXQsIDIpIC8gaW5wdXQubGVuZ3RoO1xuICovXG5mdW5jdGlvbiBzdW1OdGhQb3dlckRldmlhdGlvbnMoeCwgbikge1xuICAgIHZhciBtZWFuVmFsdWUgPSBtZWFuKHgpO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciB0ZW1wVmFsdWU7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbjogd2hlbiBuIGlzIDIgKHdlJ3JlIGNvbXB1dGluZyBhIG51bWJlciBzcXVhcmVkKSxcbiAgICAvLyBtdWx0aXBseWluZyB0aGUgbnVtYmVyIGJ5IGl0c2VsZiBpcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHVzaW5nXG4gICAgLy8gdGhlIE1hdGgucG93IG1ldGhvZC5cbiAgICBpZiAobiA9PT0gMikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFZhbHVlID0geFtpXSAtIG1lYW5WYWx1ZTtcbiAgICAgICAgICAgIHN1bSArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IE1hdGgucG93KHhbaV0gLSBtZWFuVmFsdWUsIG4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLyoqXG4gKiBUaGUgW3ZhcmlhbmNlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhcmlhbmNlKVxuICogaXMgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbi5cbiAqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHZhcmlhbmNlLCBub3Qgc2FtcGxlIHZhcmlhbmNlOlxuICogc2VlIHRoZSBgc2FtcGxlVmFyaWFuY2VgIG1ldGhvZCBpZiB5b3Ugd2FudCBhIHNhbXBsZSBtZWFzdXJlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHBvcHVsYXRpb24gb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhcmlhbmNlOiBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLlxuICogemVybyBpbmRpY2F0ZXMgdGhhdCBhbGwgdmFsdWVzIGFyZSBpZGVudGljYWwuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCdzIGxlbmd0aCBpcyAwXG4gKiBAZXhhbXBsZVxuICogdmFyaWFuY2UoWzEsIDIsIDMsIDQsIDUsIDZdKTsgLy8gPT4gMi45MTY2NjY2NjY2NjY2NjY1XG4gKi9cbmZ1bmN0aW9uIHZhcmlhbmNlKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgbWVhbiBvZiBzcXVhcmVkIGRldmlhdGlvbnMgYmV0d2VlbiB0aGVcbiAgICAvLyBtZWFuIHZhbHVlIGFuZCBlYWNoIHZhbHVlLlxuICAgIHJldHVybiBzdW1OdGhQb3dlckRldmlhdGlvbnMoeCwgMikgLyB4Lmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgW3N0YW5kYXJkIGRldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9kZXZpYXRpb24pXG4gKiBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhcmlhbmNlLiBUaGlzIGlzIGFsc28ga25vd24gYXMgdGhlIHBvcHVsYXRpb25cbiAqIHN0YW5kYXJkIGRldmlhdGlvbi4gSXQncyB1c2VmdWwgZm9yIG1lYXN1cmluZyB0aGUgYW1vdW50XG4gKiBvZiB2YXJpYXRpb24gb3IgZGlzcGVyc2lvbiBpbiBhIHNldCBvZiB2YWx1ZXMuXG4gKlxuICogU3RhbmRhcmQgZGV2aWF0aW9uIGlzIG9ubHkgYXBwcm9wcmlhdGUgZm9yIGZ1bGwtcG9wdWxhdGlvbiBrbm93bGVkZ2U6IGZvclxuICogc2FtcGxlcyBvZiBhIHBvcHVsYXRpb24sIHtAbGluayBzYW1wbGVTdGFuZGFyZERldmlhdGlvbn0gaXNcbiAqIG1vcmUgYXBwcm9wcmlhdGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBleGFtcGxlXG4gKiB2YXJpYW5jZShbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pOyAvLyA9PiA0XG4gKiBzdGFuZGFyZERldmlhdGlvbihbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pOyAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkRGV2aWF0aW9uKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciB2ID0gdmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2KTtcbn1cblxuLyoqXG4gKiBUaGUgW1IgU3F1YXJlZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2VmZmljaWVudF9vZl9kZXRlcm1pbmF0aW9uKVxuICogdmFsdWUgb2YgZGF0YSBjb21wYXJlZCB3aXRoIGEgZnVuY3Rpb24gYGZgXG4gKiBpcyB0aGUgc3VtIG9mIHRoZSBzcXVhcmVkIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHByZWRpY3Rpb25cbiAqIGFuZCB0aGUgYWN0dWFsIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHggaW5wdXQgZGF0YTogdGhpcyBzaG91bGQgYmUgZG91Ymx5LW5lc3RlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiBjYWxsZWQgb24gYFtpXVswXWAgdmFsdWVzIHdpdGhpbiB0aGUgZGF0YXNldFxuICogQHJldHVybnMge251bWJlcn0gci1zcXVhcmVkIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogdmFyIHNhbXBsZXMgPSBbWzAsIDBdLCBbMSwgMV1dO1xuICogdmFyIHJlZ3Jlc3Npb25MaW5lID0gbGluZWFyUmVncmVzc2lvbkxpbmUobGluZWFyUmVncmVzc2lvbihzYW1wbGVzKSk7XG4gKiByU3F1YXJlZChzYW1wbGVzLCByZWdyZXNzaW9uTGluZSk7IC8vID0gMSB0aGlzIGxpbmUgaXMgYSBwZXJmZWN0IGZpdFxuICovXG5mdW5jdGlvbiByU3F1YXJlZCh4LCBmdW5jKSB7XG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhdmVyYWdlIHkgdmFsdWUgZm9yIHRoZSBhY3R1YWxcbiAgICAvLyBkYXRhIHNldCBpbiBvcmRlciB0byBjb21wdXRlIHRoZVxuICAgIC8vIF90b3RhbCBzdW0gb2Ygc3F1YXJlc19cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHhbaV1bMV07XG4gICAgfVxuICAgIHZhciBhdmVyYWdlID0gc3VtIC8geC5sZW5ndGg7XG5cbiAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBzdW0gb2Ygc3F1YXJlcyAtIHRoZVxuICAgIC8vIHNxdWFyZWQgZGlmZmVyZW5jZSBiZXR3ZWVuIGVhY2ggcG9pbnRcbiAgICAvLyBhbmQgdGhlIGF2ZXJhZ2Ugb2YgYWxsIHBvaW50cy5cbiAgICB2YXIgc3VtT2ZTcXVhcmVzID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtT2ZTcXVhcmVzICs9IE1hdGgucG93KGF2ZXJhZ2UgLSB4W2pdWzFdLCAyKTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5IGVzdGltYXRlIHRoZSBlcnJvcjogdGhlIHNxdWFyZWRcbiAgICAvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGVzdGltYXRlIGFuZCB0aGUgYWN0dWFsIGRhdGFcbiAgICAvLyB2YWx1ZSBhdCBlYWNoIHBvaW50LlxuICAgIHZhciBlcnIgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgeC5sZW5ndGg7IGsrKykge1xuICAgICAgICBlcnIgKz0gTWF0aC5wb3coeFtrXVsxXSAtIGZ1bmMoeFtrXVswXSksIDIpO1xuICAgIH1cblxuICAgIC8vIEFzIHRoZSBlcnJvciBncm93cyBsYXJnZXIsIGl0cyByYXRpbyB0byB0aGVcbiAgICAvLyBzdW0gb2Ygc3F1YXJlcyBpbmNyZWFzZXMgYW5kIHRoZSByIHNxdWFyZWRcbiAgICAvLyB2YWx1ZSBncm93cyBsb3dlci5cbiAgICByZXR1cm4gMSAtIGVyciAvIHN1bU9mU3F1YXJlcztcbn1cblxuLyoqXG4gKiBUaGUgW21vZGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZGVfJTI4c3RhdGlzdGljcyUyOSkgaXMgdGhlIG51bWJlclxuICogdGhhdCBhcHBlYXJzIGluIGEgbGlzdCB0aGUgaGlnaGVzdCBudW1iZXIgb2YgdGltZXMuXG4gKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgbW9kZXMgaW4gYSBsaXN0OiBpbiB0aGUgZXZlbnQgb2YgYSB0aWUsIHRoaXNcbiAqIGFsZ29yaXRobSB3aWxsIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBzZWVuIG1vZGUuXG4gKlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAgYmVjYXVzZSB0aGUgaW5wdXQgaXMgc29ydGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc29ydGVkIGEgc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtb2RlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgc29ydGVkIGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogbW9kZVNvcnRlZChbMCwgMCwgMV0pOyAvLyA9PiAwXG4gKi9cbmZ1bmN0aW9uIG1vZGVTb3J0ZWQoc29ydGVkKSB7XG4gICAgLy8gSGFuZGxlIGVkZ2UgY2FzZXM6XG4gICAgLy8gVGhlIG1vZGUgb2YgYW4gZW1wdHkgbGlzdCBpcyB1bmRlZmluZWRcbiAgICBpZiAoc29ydGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2RlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cbiAgICBpZiAoc29ydGVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc29ydGVkWzBdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgYXNzdW1lcyBpdCBpcyBkZWFsaW5nIHdpdGggYW4gYXJyYXkgb2Ygc2l6ZSA+IDEsIHNpbmNlIHNpemVcbiAgICAvLyAwIGFuZCAxIGFyZSBoYW5kbGVkIGltbWVkaWF0ZWx5LiBIZW5jZSBpdCBzdGFydHMgYXQgaW5kZXggMSBpbiB0aGVcbiAgICAvLyBhcnJheS5cbiAgICB2YXIgbGFzdCA9IHNvcnRlZFswXTtcbiAgICAvLyBzdG9yZSB0aGUgbW9kZSBhcyB3ZSBmaW5kIG5ldyBtb2Rlc1xuICAgIHZhciB2YWx1ZSA9IE51bWJlci5OYU47XG4gICAgLy8gc3RvcmUgaG93IG1hbnkgdGltZXMgd2UndmUgc2VlbiB0aGUgbW9kZVxuICAgIHZhciBtYXhTZWVuID0gMDtcbiAgICAvLyBob3cgbWFueSB0aW1lcyB0aGUgY3VycmVudCBjYW5kaWRhdGUgZm9yIHRoZSBtb2RlXG4gICAgLy8gaGFzIGJlZW4gc2VlblxuICAgIHZhciBzZWVuVGhpcyA9IDE7XG5cbiAgICAvLyBlbmQgYXQgc29ydGVkLmxlbmd0aCArIDEgdG8gZml4IHRoZSBjYXNlIGluIHdoaWNoIHRoZSBtb2RlIGlzXG4gICAgLy8gdGhlIGhpZ2hlc3QgbnVtYmVyIHRoYXQgb2NjdXJzIGluIHRoZSBzZXF1ZW5jZS4gdGhlIGxhc3QgaXRlcmF0aW9uXG4gICAgLy8gY29tcGFyZXMgc29ydGVkW2ldLCB3aGljaCBpcyB1bmRlZmluZWQsIHRvIHRoZSBoaWdoZXN0IG51bWJlclxuICAgIC8vIGluIHRoZSBzZXJpZXNcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNvcnRlZC5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgICAgLy8gd2UncmUgc2VlaW5nIGEgbmV3IG51bWJlciBwYXNzIGJ5XG4gICAgICAgIGlmIChzb3J0ZWRbaV0gIT09IGxhc3QpIHtcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IG51bWJlciBpcyB0aGUgbmV3IG1vZGUgc2luY2Ugd2Ugc2F3IGl0IG1vcmVcbiAgICAgICAgICAgIC8vIG9mdGVuIHRoYW4gdGhlIG9sZCBvbmVcbiAgICAgICAgICAgIGlmIChzZWVuVGhpcyA+IG1heFNlZW4pIHtcbiAgICAgICAgICAgICAgICBtYXhTZWVuID0gc2VlblRoaXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlblRoaXMgPSAxO1xuICAgICAgICAgICAgbGFzdCA9IHNvcnRlZFtpXTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXNuJ3QgYSBuZXcgbnVtYmVyLCBpdCdzIG9uZSBtb3JlIG9jY3VycmVuY2Ugb2ZcbiAgICAgICAgICAgIC8vIHRoZSBwb3RlbnRpYWwgbW9kZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VlblRoaXMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogU29ydCBhbiBhcnJheSBvZiBudW1iZXJzIGJ5IHRoZWlyIG51bWVyaWMgdmFsdWUsIGVuc3VyaW5nIHRoYXQgdGhlXG4gKiBhcnJheSBpcyBub3QgY2hhbmdlZCBpbiBwbGFjZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIC5zb3J0XG4gKiBpbiBKYXZhU2NyaXB0IGlzIHRvIHNvcnQgYXJyYXlzIGFzIHN0cmluZyB2YWx1ZXNcbiAqXG4gKiAgICAgWzEsIDEwLCAxMiwgMTAyLCAyMF0uc29ydCgpXG4gKiAgICAgLy8gb3V0cHV0XG4gKiAgICAgWzEsIDEwLCAxMDIsIDEyLCAyMF1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXQgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IHNvcnRlZCBhcnJheVxuICogQHByaXZhdGVcbiAqIEBleGFtcGxlXG4gKiBudW1lcmljU29ydChbMywgMiwgMV0pIC8vID0+IFsxLCAyLCAzXVxuICovXG5mdW5jdGlvbiBudW1lcmljU29ydCh4KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgeFxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBhcnJheSBpcyBub3QgY2hhbmdlZCBpbi1wbGFjZVxuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC8vIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhdCB0cmVhdHMgaW5wdXQgYXMgbnVtZXJpY1xuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICB9KVxuICAgICk7XG59XG5cbi8qKlxuICogVGhlIFttb2RlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2RlXyUyOHN0YXRpc3RpY3MlMjkpIGlzIHRoZSBudW1iZXJcbiAqIHRoYXQgYXBwZWFycyBpbiBhIGxpc3QgdGhlIGhpZ2hlc3QgbnVtYmVyIG9mIHRpbWVzLlxuICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIG1vZGVzIGluIGEgbGlzdDogaW4gdGhlIGV2ZW50IG9mIGEgdGllLCB0aGlzXG4gKiBhbGdvcml0aG0gd2lsbCByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgc2VlbiBtb2RlLlxuICpcbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obiBsb2cobikpYCBiZWNhdXNlIGl0IG5lZWRzIHRvIHNvcnQgdGhlIGFycmF5IGludGVybmFsbHlcbiAqIGJlZm9yZSBydW5uaW5nIGFuIGBPKG4pYCBzZWFyY2ggdG8gZmluZCB0aGUgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1vZGVcbiAqIEBleGFtcGxlXG4gKiBtb2RlKFswLCAwLCAxXSk7IC8vID0+IDBcbiAqL1xuZnVuY3Rpb24gbW9kZSh4KSB7XG4gICAgLy8gU29ydGluZyB0aGUgYXJyYXkgbGV0cyB1cyBpdGVyYXRlIHRocm91Z2ggaXQgYmVsb3cgYW5kIGJlIHN1cmVcbiAgICAvLyB0aGF0IGV2ZXJ5IHRpbWUgd2Ugc2VlIGEgbmV3IG51bWJlciBpdCdzIG5ldyBhbmQgd2UnbGwgbmV2ZXJcbiAgICAvLyBzZWUgdGhlIHNhbWUgbnVtYmVyIHR3aWNlXG4gICAgcmV0dXJuIG1vZGVTb3J0ZWQobnVtZXJpY1NvcnQoeCkpO1xufVxuXG4vKiBnbG9iYWxzIE1hcDogZmFsc2UgKi9cblxuLyoqXG4gKiBUaGUgW21vZGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZGVfJTI4c3RhdGlzdGljcyUyOSkgaXMgdGhlIG51bWJlclxuICogdGhhdCBhcHBlYXJzIGluIGEgbGlzdCB0aGUgaGlnaGVzdCBudW1iZXIgb2YgdGltZXMuXG4gKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgbW9kZXMgaW4gYSBsaXN0OiBpbiB0aGUgZXZlbnQgb2YgYSB0aWUsIHRoaXNcbiAqIGFsZ29yaXRobSB3aWxsIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBzZWVuIG1vZGUuXG4gKlxuICogbW9kZUZhc3QgdXNlcyBhIE1hcCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiB0aGUgbW9kZSwgaW5zdGVhZCBvZiB0aGUgYXBwcm9hY2hcbiAqIHVzZWQgd2l0aCBgbW9kZWAsIGEgc29ydGVkIGFycmF5LiBBcyBhIHJlc3VsdCwgaXQgaXMgZmFzdGVyXG4gKiB0aGFuIGBtb2RlYCBhbmQgc3VwcG9ydHMgYW55IGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBjb21wYXJlZCB3aXRoIGA9PWAuXG4gKiBJdCBhbHNvIHJlcXVpcmVzIGFcbiAqIFtKYXZhU2NyaXB0IGVudmlyb25tZW50IHdpdGggc3VwcG9ydCBmb3IgTWFwXShodHRwczovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNi8jdGVzdC1NYXApLFxuICogYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgTWFwIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHggYSBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHs/Kn0gbW9kZVxuICogQHRocm93cyB7UmVmZXJlbmNlRXJyb3J9IGlmIHRoZSBKYXZhU2NyaXB0IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCBNYXBcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogbW9kZUZhc3QoWydyYWJiaXRzJywgJ3JhYmJpdHMnLCAnc3F1aXJyZWxzJ10pOyAvLyA9PiAncmFiYml0cydcbiAqL1xuZnVuY3Rpb24gbW9kZUZhc3QoeCkge1xuICAgIC8vIFRoaXMgaW5kZXggd2lsbCByZWZsZWN0IHRoZSBpbmNpZGVuY2Ugb2YgZGlmZmVyZW50IHZhbHVlcywgaW5kZXhpbmdcbiAgICAvLyB0aGVtIGxpa2VcbiAgICAvLyB7IHZhbHVlOiBjb3VudCB9XG4gICAgdmFyIGluZGV4ID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gQSBydW5uaW5nIGBtb2RlYCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBpdCBoYXMgYmVlbiBlbmNvdW50ZXJlZC5cbiAgICB2YXIgbW9kZTtcbiAgICB2YXIgbW9kZUNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q291bnQgPSBpbmRleC5nZXQoeFtpXSk7XG4gICAgICAgIGlmIChuZXdDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdDb3VudCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb3VudCA+IG1vZGVDb3VudCkge1xuICAgICAgICAgICAgbW9kZSA9IHhbaV07XG4gICAgICAgICAgICBtb2RlQ291bnQgPSBuZXdDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpbmRleC5zZXQoeFtpXSwgbmV3Q291bnQpO1xuICAgIH1cblxuICAgIGlmIChtb2RlQ291bnQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZSByZXF1aXJlcyBhdCBsYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlO1xufVxuXG4vKipcbiAqIFRoZSBtaW4gaXMgdGhlIGxvd2VzdCBudW1iZXIgaW4gdGhlIGFycmF5LlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1pbmltdW0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtaW4oWzEsIDUsIC0xMCwgMTAwLCAyXSk7IC8vID0+IC0xMFxuICovXG5mdW5jdGlvbiBtaW4oeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0geFswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhbaV0gPCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB4W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXB1dGVzIHRoZSBtYXhpbXVtIG51bWJlciBpbiBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1heGltdW0gdmFsdWVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQGV4YW1wbGVcbiAqIG1heChbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gNFxuICovXG5mdW5jdGlvbiBtYXgoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0geFswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhbaV0gPiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB4W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXB1dGVzIHRoZSBtaW5pbXVtICYgbWF4aW11bSBudW1iZXIgaW4gYW4gYXJyYXkuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gbWluaW11bSAmIG1heGltdW0gdmFsdWVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQGV4YW1wbGVcbiAqIGV4dGVudChbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzEsIDRdXG4gKi9cbmZ1bmN0aW9uIGV4dGVudCh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVudCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbWluID0geFswXTtcbiAgICB2YXIgbWF4ID0geFswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHhbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhbaV0gPCBtaW4pIHtcbiAgICAgICAgICAgIG1pbiA9IHhbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbi8qKlxuICogVGhlIG1pbmltdW0gaXMgdGhlIGxvd2VzdCBudW1iZXIgaW4gdGhlIGFycmF5LiBXaXRoIGEgc29ydGVkIGFycmF5LFxuICogdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIGFsd2F5cyB0aGUgc21hbGxlc3QsIHNvIHRoaXMgY2FsY3VsYXRpb25cbiAqIGNhbiBiZSBkb25lIGluIG9uZSBzdGVwLCBvciBjb25zdGFudCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gbWluaW11bSB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIG1pblNvcnRlZChbLTEwMCwgLTEwLCAxLCAyLCA1XSk7IC8vID0+IC0xMDBcbiAqL1xuZnVuY3Rpb24gbWluU29ydGVkKHgpIHtcbiAgICByZXR1cm4geFswXTtcbn1cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBpcyB0aGUgaGlnaGVzdCBudW1iZXIgaW4gdGhlIGFycmF5LiBXaXRoIGEgc29ydGVkIGFycmF5LFxuICogdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgYWx3YXlzIHRoZSBsYXJnZXN0LCBzbyB0aGlzIGNhbGN1bGF0aW9uXG4gKiBjYW4gYmUgZG9uZSBpbiBvbmUgc3RlcCwgb3IgY29uc3RhbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1heGltdW0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtYXhTb3J0ZWQoWy0xMDAsIC0xMCwgMSwgMiwgNV0pOyAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIG1heFNvcnRlZCh4KSB7XG4gICAgcmV0dXJuIHhbeC5sZW5ndGggLSAxXTtcbn1cblxuLyoqXG4gKiBUaGUgZXh0ZW50IGlzIHRoZSBsb3dlc3QgJiBoaWdoZXN0IG51bWJlciBpbiB0aGUgYXJyYXkuIFdpdGggYSBzb3J0ZWQgYXJyYXksXG4gKiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgYWx3YXlzIHRoZSBsb3dlc3Qgd2hpbGUgdGhlIGxhc3QgZWxlbWVudCBpcyBhbHdheXMgdGhlIGxhcmdlc3QsIHNvIHRoaXMgY2FsY3VsYXRpb25cbiAqIGNhbiBiZSBkb25lIGluIG9uZSBzdGVwLCBvciBjb25zdGFudCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IG1pbmltdW0gJiBtYXhpbXVtIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogZXh0ZW50U29ydGVkKFstMTAwLCAtMTAsIDEsIDIsIDVdKTsgLy8gPT4gWy0xMDAsIDVdXG4gKi9cbmZ1bmN0aW9uIGV4dGVudFNvcnRlZCh4KSB7XG4gICAgcmV0dXJuIFt4WzBdLCB4W3gubGVuZ3RoIC0gMV1dO1xufVxuXG4vKipcbiAqIFRoZSBzaW1wbGUgW3N1bV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3VtbWF0aW9uKSBvZiBhbiBhcnJheVxuICogaXMgdGhlIHJlc3VsdCBvZiBhZGRpbmcgYWxsIG51bWJlcnMgdG9nZXRoZXIsIHN0YXJ0aW5nIGZyb20gemVyby5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfSBzdW0gb2YgYWxsIGlucHV0IG51bWJlcnNcbiAqIEBleGFtcGxlXG4gKiBzdW1TaW1wbGUoWzEsIDIsIDNdKTsgLy8gPT4gNlxuICovXG5mdW5jdGlvbiBzdW1TaW1wbGUoeCkge1xuICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeFtpXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0geFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBbcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvZHVjdF8obWF0aGVtYXRpY3MpKSBvZiBhbiBhcnJheVxuICogaXMgdGhlIHJlc3VsdCBvZiBtdWx0aXBseWluZyBhbGwgbnVtYmVycyB0b2dldGhlciwgc3RhcnRpbmcgdXNpbmcgb25lIGFzIHRoZSBtdWx0aXBsaWNhdGl2ZSBpZGVudGl0eS5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfSBwcm9kdWN0IG9mIGFsbCBpbnB1dCBudW1iZXJzXG4gKiBAZXhhbXBsZVxuICogcHJvZHVjdChbMSwgMiwgMywgNF0pOyAvLyA9PiAyNFxuICovXG5mdW5jdGlvbiBwcm9kdWN0KHgpIHtcbiAgICB2YXIgdmFsdWUgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSAqPSB4W2ldO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgcXVhbnRpbGVzOiB3aGVuIHlvdSBrbm93XG4gKiB0aGF0IHRoZSBvcmRlciBpcyBzb3J0ZWQsIHlvdSBkb24ndCBuZWVkIHRvIHJlLXNvcnQgaXQsIGFuZCB0aGUgY29tcHV0YXRpb25zXG4gKiBhcmUgZmFzdGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwIGRlc2lyZWQgcXVhbnRpbGU6IGEgbnVtYmVyIGJldHdlZW4gMCB0byAxLCBpbmNsdXNpdmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHF1YW50aWxlIHZhbHVlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcCBpeCBvdXRzaWRlIG9mIHRoZSByYW5nZSBmcm9tIDAgdG8gMVxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZVNvcnRlZChbMywgNiwgNywgOCwgOCwgOSwgMTAsIDEzLCAxNSwgMTYsIDIwXSwgMC41KTsgLy8gPT4gOVxuICovXG5mdW5jdGlvbiBxdWFudGlsZVNvcnRlZCh4LCBwKSB7XG4gICAgdmFyIGlkeCA9IHgubGVuZ3RoICogcDtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpbGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQuXCIpO1xuICAgIH0gZWxzZSBpZiAocCA8IDAgfHwgcCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpbGVzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMSkge1xuICAgICAgICAvLyBJZiBwIGlzIDEsIGRpcmVjdGx5IHJldHVybiB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgIHJldHVybiB4W3gubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMCwgZGlyZWN0bHkgcmV0dXJuIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgIHJldHVybiB4WzBdO1xuICAgIH0gZWxzZSBpZiAoaWR4ICUgMSAhPT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIG5vdCBpbnRlZ2VyLCByZXR1cm4gdGhlIG5leHQgZWxlbWVudCBpbiBhcnJheVxuICAgICAgICByZXR1cm4geFtNYXRoLmNlaWwoaWR4KSAtIDFdO1xuICAgIH0gZWxzZSBpZiAoeC5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgIC8vIElmIHRoZSBsaXN0IGhhcyBldmVuLWxlbmd0aCwgd2UnbGwgdGFrZSB0aGUgYXZlcmFnZSBvZiB0aGlzIG51bWJlclxuICAgICAgICAvLyBhbmQgdGhlIG5leHQgdmFsdWUsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICByZXR1cm4gKHhbaWR4IC0gMV0gKyB4W2lkeF0pIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaW5hbGx5LCBpbiB0aGUgc2ltcGxlIGNhc2Ugb2YgYW4gaW50ZWdlciB2YWx1ZVxuICAgICAgICAvLyB3aXRoIGFuIG9kZC1sZW5ndGggbGlzdCwgcmV0dXJuIHRoZSB4IHZhbHVlIGF0IHRoZSBpbmRleC5cbiAgICAgICAgcmV0dXJuIHhbaWR4XTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVhcnJhbmdlIGl0ZW1zIGluIGBhcnJgIHNvIHRoYXQgYWxsIGl0ZW1zIGluIGBbbGVmdCwga11gIHJhbmdlIGFyZSB0aGUgc21hbGxlc3QuXG4gKiBUaGUgYGtgLXRoIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSBgKGsgLSBsZWZ0ICsgMSlgLXRoIHNtYWxsZXN0IHZhbHVlIGluIGBbbGVmdCwgcmlnaHRdYC5cbiAqXG4gKiBJbXBsZW1lbnRzIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zsb3lkLVJpdmVzdF9hbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFyciBpbnB1dCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGsgcGl2b3QgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVmdF0gbGVmdCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtyaWdodF0gcmlnaHQgaW5kZXhcbiAqIEByZXR1cm5zIHt2b2lkfSBtdXRhdGVzIGlucHV0IGFycmF5XG4gKiBAZXhhbXBsZVxuICogdmFyIGFyciA9IFs2NSwgMjgsIDU5LCAzMywgMjEsIDU2LCAyMiwgOTUsIDUwLCAxMiwgOTAsIDUzLCAyOCwgNzcsIDM5XTtcbiAqIHF1aWNrc2VsZWN0KGFyciwgOCk7XG4gKiAvLyA9IFszOSwgMjgsIDI4LCAzMywgMjEsIDEyLCAyMiwgNTAsIDUzLCA1NiwgNTksIDY1LCA5MCwgNzcsIDk1XVxuICovXG5mdW5jdGlvbiBxdWlja3NlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgICByaWdodCA9IHJpZ2h0IHx8IGFyci5sZW5ndGggLSAxO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICAvLyA2MDAgYW5kIDAuNSBhcmUgYXJiaXRyYXJ5IGNvbnN0YW50cyBjaG9zZW4gaW4gdGhlIG9yaWdpbmFsIHBhcGVyIHRvIG1pbmltaXplIGV4ZWN1dGlvbiB0aW1lXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoKDIgKiB6KSAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KCh6ICogcyAqIChuIC0gcykpIC8gbik7XG4gICAgICAgICAgICBpZiAobSAtIG4gLyAyIDwgMCkgeyBzZCAqPSAtMTsgfVxuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSAobSAqIHMpIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGsgKyAoKG4gLSBtKSAqIHMpIC8gbiArIHNkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChhcnJbcmlnaHRdID4gdCkgeyBzd2FwKGFyciwgbGVmdCwgcmlnaHQpOyB9XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2ldIDwgdCkgeyBpKys7IH1cbiAgICAgICAgICAgIHdoaWxlIChhcnJbal0gPiB0KSB7IGotLTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycltsZWZ0XSA9PT0gdCkgeyBzd2FwKGFyciwgbGVmdCwgaik7IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgeyBsZWZ0ID0gaiArIDE7IH1cbiAgICAgICAgaWYgKGsgPD0gaikgeyByaWdodCA9IGogLSAxOyB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuLyoqXG4gKiBUaGUgW3F1YW50aWxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWFudGlsZSk6XG4gKiB0aGlzIGlzIGEgcG9wdWxhdGlvbiBxdWFudGlsZSwgc2luY2Ugd2UgYXNzdW1lIHRvIGtub3cgdGhlIGVudGlyZVxuICogZGF0YXNldCBpbiB0aGlzIGxpYnJhcnkuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gKiBbUXVhbnRpbGVzIG9mIGEgUG9wdWxhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWFudGlsZSNRdWFudGlsZXNfb2ZfYV9wb3B1bGF0aW9uKVxuICogYWxnb3JpdGhtIGZyb20gd2lraXBlZGlhLlxuICpcbiAqIFNhbXBsZSBpcyBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBudW1iZXJzLFxuICogYW5kIHAgaXMgZWl0aGVyIGEgZGVjaW1hbCBudW1iZXIgZnJvbSAwIHRvIDEgb3IgYW4gYXJyYXkgb2YgZGVjaW1hbFxuICogbnVtYmVycyBmcm9tIDAgdG8gMS5cbiAqIEluIHRlcm1zIG9mIGEgay9xIHF1YW50aWxlLCBwID0gay9xIC0gaXQncyBqdXN0IGRlYWxpbmcgd2l0aCBmcmFjdGlvbnMgb3IgZGVhbGluZ1xuICogd2l0aCBkZWNpbWFsIHZhbHVlcy5cbiAqIFdoZW4gcCBpcyBhbiBhcnJheSwgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaXMgYWxzbyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBhcHByb3ByaWF0ZVxuICogcXVhbnRpbGVzIGluIGlucHV0IG9yZGVyXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj4gfCBudW1iZXJ9IHAgdGhlIGRlc2lyZWQgcXVhbnRpbGUsIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge251bWJlcn0gcXVhbnRpbGVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZShbMywgNiwgNywgOCwgOCwgOSwgMTAsIDEzLCAxNSwgMTYsIDIwXSwgMC41KTsgLy8gPT4gOVxuICovXG5mdW5jdGlvbiBxdWFudGlsZSh4LCBwKSB7XG4gICAgdmFyIGNvcHkgPSB4LnNsaWNlKCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgICAvLyByZWFycmFuZ2UgZWxlbWVudHMgc28gdGhhdCBlYWNoIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIHJlcXVlc3RlZFxuICAgICAgICAvLyBxdWFudGlsZSBpcyBvbiBhIHBsYWNlIGl0IHdvdWxkIGJlIGlmIHRoZSBhcnJheSB3YXMgZnVsbHkgc29ydGVkXG4gICAgICAgIG11bHRpUXVhbnRpbGVTZWxlY3QoY29weSwgcCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0ZWQgcXVhbnRpbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcXVhbnRpbGVTb3J0ZWQoY29weSwgcFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IHF1YW50aWxlSW5kZXgoY29weS5sZW5ndGgsIHApO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChjb3B5LCBpZHgsIDAsIGNvcHkubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBxdWFudGlsZVNvcnRlZChjb3B5LCBwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlU2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoayAlIDEgPT09IDApIHtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgayA9IE1hdGguZmxvb3Ioayk7XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIGsgKyAxLCBrICsgMSwgcmlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbXVsdGlRdWFudGlsZVNlbGVjdChhcnIsIHApIHtcbiAgICB2YXIgaW5kaWNlcyA9IFswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHF1YW50aWxlSW5kZXgoYXJyLmxlbmd0aCwgcFtpXSkpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2goYXJyLmxlbmd0aCAtIDEpO1xuICAgIGluZGljZXMuc29ydChjb21wYXJlKTtcblxuICAgIHZhciBzdGFjayA9IFswLCBpbmRpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgciA9IE1hdGguY2VpbChzdGFjay5wb3AoKSk7XG4gICAgICAgIHZhciBsID0gTWF0aC5mbG9vcihzdGFjay5wb3AoKSk7XG4gICAgICAgIGlmIChyIC0gbCA8PSAxKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKChsICsgcikgLyAyKTtcbiAgICAgICAgcXVhbnRpbGVTZWxlY3QoXG4gICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICBpbmRpY2VzW21dLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihpbmRpY2VzW2xdKSxcbiAgICAgICAgICAgIE1hdGguY2VpbChpbmRpY2VzW3JdKVxuICAgICAgICApO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobCwgbSwgbSwgcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlSW5kZXgobGVuLCBwKSB7XG4gICAgdmFyIGlkeCA9IGxlbiAqIHA7XG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgaW5kZXhcbiAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG4gICAgfSBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMCwgZGlyZWN0bHkgcmV0dXJuIHRoZSBmaXJzdCBpbmRleFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgaW5kZXggaXMgbm90IGludGVnZXIsIHJldHVybiB0aGUgbmV4dCBpbmRleCBpbiBhcnJheVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGlkeCkgLSAxO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHJldHVybiB0aGUgbWlkZGxlIG9mIHR3byBpbmRpY2VzXG4gICAgICAgIC8vIGFyb3VuZCBxdWFudGlsZSB0byBpbmRpY2F0ZSB0aGF0IHdlIG5lZWQgYW4gYXZlcmFnZSB2YWx1ZSBvZiB0aGUgdHdvXG4gICAgICAgIHJldHVybiBpZHggLSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgaW5kZXhcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgaW5kZXhcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG59XG5cbi8qIGVzbGludCBuby1iaXR3aXNlOiAwICovXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBxdWFudGlsZSBpbiB3aGljaCBvbmUgd291bGQgZmluZCB0aGUgZ2l2ZW4gdmFsdWUgaW5cbiAqIHRoZSBnaXZlbiBhcnJheS4gV2l0aCBhIHNvcnRlZCBhcnJheSwgbGV2ZXJhZ2luZyBiaW5hcnkgc2VhcmNoLCB3ZSBjYW4gZmluZFxuICogdGhpcyBpbmZvcm1hdGlvbiBpbiBsb2dhcml0aG1pYyB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gdmFsdWUgdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZVJhbmtTb3J0ZWQoWzEsIDIsIDMsIDRdLCAzKTsgLy8gPT4gMC43NVxuICogcXVhbnRpbGVSYW5rU29ydGVkKFsxLCAyLCAzLCAzLCA0XSwgMyk7IC8vID0+IDAuN1xuICogcXVhbnRpbGVSYW5rU29ydGVkKFsxLCAyLCAzLCA0XSwgNik7IC8vID0+IDFcbiAqIHF1YW50aWxlUmFua1NvcnRlZChbMSwgMiwgMywgMywgNV0sIDQpOyAvLyA9PiAwLjhcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVSYW5rU29ydGVkKHgsIHZhbHVlKSB7XG4gICAgLy8gVmFsdWUgaXMgbGVzc2VyIHRoYW4gYW55IHZhbHVlIGluIHRoZSBhcnJheVxuICAgIGlmICh2YWx1ZSA8IHhbMF0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gVmFsdWUgaXMgZ3JlYXRlciB0aGFuIGFueSB2YWx1ZSBpbiB0aGUgYXJyYXlcbiAgICBpZiAodmFsdWUgPiB4W3gubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBsb3dlckJvdW5kKHgsIHZhbHVlKTtcblxuICAgIC8vIFZhbHVlIGlzIG5vdCBpbiB0aGUgYXJyYXlcbiAgICBpZiAoeFtsXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGwgLyB4Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBsKys7XG5cbiAgICB2YXIgdSA9IHVwcGVyQm91bmQoeCwgdmFsdWUpO1xuXG4gICAgLy8gVGhlIHZhbHVlIGV4aXN0cyBvbmx5IG9uY2UgaW4gdGhlIGFycmF5XG4gICAgaWYgKHUgPT09IGwpIHtcbiAgICAgICAgcmV0dXJuIGwgLyB4Lmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBIZXJlLCB3ZSBhcmUgYmFzaWNhbGx5IGNvbXB1dGluZyB0aGUgbWVhbiBvZiB0aGUgcmFuZ2Ugb2YgaW5kaWNlc1xuICAgIC8vIGNvbnRhaW5pbmcgb3VyIHNlYXJjaGVkIHZhbHVlLiBCdXQsIGluc3RlYWQsIG9mIGluaXRpYWxpemluZyBhblxuICAgIC8vIGFycmF5IGFuZCBsb29waW5nIG92ZXIgaXQsIHRoZXJlIGlzIGEgZGVkaWNhdGVkIG1hdGggZm9ybXVsYSB0aGF0XG4gICAgLy8gd2UgYXBwbHkgYmVsb3cgdG8gZ2V0IHRoZSByZXN1bHQuXG4gICAgdmFyIHIgPSB1IC0gbCArIDE7XG4gICAgdmFyIHN1bSA9IChyICogKHUgKyBsKSkgLyAyO1xuICAgIHZhciBtZWFuID0gc3VtIC8gcjtcblxuICAgIHJldHVybiBtZWFuIC8geC5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGxvd2VyQm91bmQoeCwgdmFsdWUpIHtcbiAgICB2YXIgbWlkID0gMDtcbiAgICB2YXIgbG8gPSAwO1xuICAgIHZhciBoaSA9IHgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuXG4gICAgICAgIGlmICh2YWx1ZSA8PSB4W21pZF0pIHtcbiAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG8gPSAtfm1pZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsbztcbn1cblxuZnVuY3Rpb24gdXBwZXJCb3VuZCh4LCB2YWx1ZSkge1xuICAgIHZhciBtaWQgPSAwO1xuICAgIHZhciBsbyA9IDA7XG4gICAgdmFyIGhpID0geC5sZW5ndGg7XG5cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG5cbiAgICAgICAgaWYgKHZhbHVlID49IHhbbWlkXSkge1xuICAgICAgICAgICAgbG8gPSAtfm1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcXVhbnRpbGUgaW4gd2hpY2ggb25lIHdvdWxkIGZpbmQgdGhlIGdpdmVuIHZhbHVlIGluXG4gKiB0aGUgZ2l2ZW4gYXJyYXkuIEl0IHdpbGwgY29weSBhbmQgc29ydCB5b3VyIGFycmF5IGJlZm9yZSBlYWNoIHJ1biwgc29cbiAqIGlmIHlvdSBrbm93IHlvdXIgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWQsIHlvdSBzaG91bGQgdXNlIGBxdWFudGlsZVJhbmtTb3J0ZWRgXG4gKiBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gdmFsdWUgdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZVJhbmsoWzQsIDMsIDEsIDJdLCAzKTsgLy8gPT4gMC43NVxuICogcXVhbnRpbGVSYW5rKFs0LCAzLCAyLCAzLCAxXSwgMyk7IC8vID0+IDAuN1xuICogcXVhbnRpbGVSYW5rKFsyLCA0LCAxLCAzXSwgNik7IC8vID0+IDFcbiAqIHF1YW50aWxlUmFuayhbNSwgMywgMSwgMiwgM10sIDQpOyAvLyA9PiAwLjhcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVSYW5rKHgsIHZhbHVlKSB7XG4gICAgLy8gQ2xvbmluZyBhbmQgc29ydGluZyB0aGUgYXJyYXlcbiAgICB2YXIgc29ydGVkQ29weSA9IG51bWVyaWNTb3J0KHgpO1xuXG4gICAgcmV0dXJuIHF1YW50aWxlUmFua1NvcnRlZChzb3J0ZWRDb3B5LCB2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIFtJbnRlcnF1YXJ0aWxlIHJhbmdlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVycXVhcnRpbGVfcmFuZ2UpIGlzXG4gKiBhIG1lYXN1cmUgb2Ygc3RhdGlzdGljYWwgZGlzcGVyc2lvbiwgb3IgaG93IHNjYXR0ZXJlZCwgc3ByZWFkLCBvclxuICogY29uY2VudHJhdGVkIGEgZGlzdHJpYnV0aW9uIGlzLiBJdCdzIGNvbXB1dGVkIGFzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAqIHRoZSB0aGlyZCBxdWFydGlsZSBhbmQgZmlyc3QgcXVhcnRpbGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnRlcnF1YXJ0aWxlIHJhbmdlOiB0aGUgc3BhbiBiZXR3ZWVuIGxvd2VyIGFuZCB1cHBlciBxdWFydGlsZSxcbiAqIDAuMjUgYW5kIDAuNzVcbiAqIEBleGFtcGxlXG4gKiBpbnRlcnF1YXJ0aWxlUmFuZ2UoWzAsIDEsIDIsIDNdKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBpbnRlcnF1YXJ0aWxlUmFuZ2UoeCkge1xuICAgIC8vIEludGVycXVhcnRpbGUgcmFuZ2UgaXMgdGhlIHNwYW4gYmV0d2VlbiB0aGUgdXBwZXIgcXVhcnRpbGUsXG4gICAgLy8gYXQgYDAuNzVgLCBhbmQgbG93ZXIgcXVhcnRpbGUsIGAwLjI1YFxuICAgIHZhciBxMSA9IHF1YW50aWxlKHgsIDAuNzUpO1xuICAgIHZhciBxMiA9IHF1YW50aWxlKHgsIDAuMjUpO1xuXG4gICAgaWYgKHR5cGVvZiBxMSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcTIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHExIC0gcTI7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBbbWVkaWFuXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lZGlhbikgaXNcbiAqIHRoZSBtaWRkbGUgbnVtYmVyIG9mIGEgbGlzdC4gVGhpcyBpcyBvZnRlbiBhIGdvb2QgaW5kaWNhdG9yIG9mICd0aGUgbWlkZGxlJ1xuICogd2hlbiB0aGVyZSBhcmUgb3V0bGllcnMgdGhhdCBza2V3IHRoZSBgbWVhbigpYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGUgbWVkaWFuIGlzbid0IG5lY2Vzc2FyaWx5IG9uZSBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIGxpc3Q6IHRoZSB2YWx1ZVxuICogY2FuIGJlIHRoZSBhdmVyYWdlIG9mIHR3byBlbGVtZW50cyBpZiB0aGUgbGlzdCBoYXMgYW4gZXZlbiBsZW5ndGhcbiAqIGFuZCB0aGUgdHdvIGNlbnRyYWwgdmFsdWVzIGFyZSBkaWZmZXJlbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWRpYW4gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtZWRpYW4oWzEwLCAyLCA1LCAxMDAsIDIsIDFdKTsgLy8gPT4gMy41XG4gKi9cbmZ1bmN0aW9uIG1lZGlhbih4KSB7XG4gICAgcmV0dXJuICtxdWFudGlsZSh4LCAwLjUpO1xufVxuXG4vKipcbiAqIFRoZSBbTWVkaWFuIEFic29sdXRlIERldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZWRpYW5fYWJzb2x1dGVfZGV2aWF0aW9uKSBpc1xuICogYSByb2J1c3QgbWVhc3VyZSBvZiBzdGF0aXN0aWNhbFxuICogZGlzcGVyc2lvbi4gSXQgaXMgbW9yZSByZXNpbGllbnQgdG8gb3V0bGllcnMgdGhhbiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dCBhcnJheVxuICogQHJldHVybnMge251bWJlcn0gbWVkaWFuIGFic29sdXRlIGRldmlhdGlvblxuICogQGV4YW1wbGVcbiAqIG1lZGlhbkFic29sdXRlRGV2aWF0aW9uKFsxLCAxLCAyLCAyLCA0LCA2LCA5XSk7IC8vID0+IDFcbiAqL1xuZnVuY3Rpb24gbWVkaWFuQWJzb2x1dGVEZXZpYXRpb24oeCkge1xuICAgIHZhciBtZWRpYW5WYWx1ZSA9IG1lZGlhbih4KTtcbiAgICB2YXIgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb25zID0gW107XG5cbiAgICAvLyBNYWtlIGEgbGlzdCBvZiBhYnNvbHV0ZSBkZXZpYXRpb25zIGZyb20gdGhlIG1lZGlhblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbnMucHVzaChNYXRoLmFicyh4W2ldIC0gbWVkaWFuVmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBtZWRpYW4gdmFsdWUgb2YgdGhhdCBsaXN0XG4gICAgcmV0dXJuIG1lZGlhbihtZWRpYW5BYnNvbHV0ZURldmlhdGlvbnMpO1xufVxuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5IGludG8gY2h1bmtzIG9mIGEgc3BlY2lmaWVkIHNpemUuIFRoaXMgZnVuY3Rpb25cbiAqIGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBbUEhQJ3MgYXJyYXlfY2h1bmtdKGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9mdW5jdGlvbi5hcnJheS1jaHVuay5waHApXG4gKiBmdW5jdGlvbiwgYW5kIHRodXMgd2lsbCBpbnNlcnQgc21hbGxlci1zaXplZCBjaHVua3MgYXQgdGhlIGVuZCBpZlxuICogdGhlIGlucHV0IHNpemUgaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgY2h1bmsgc2l6ZS5cbiAqXG4gKiBgeGAgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXksIGFuZCBgY2h1bmtTaXplYCBhIG51bWJlci5cbiAqIFRoZSBgeGAgYXJyYXkgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IGEgc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gY2h1bmtTaXplIHNpemUgb2YgZWFjaCBvdXRwdXQgYXJyYXkuIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSBhIGNodW5rZWQgYXJyYXlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBjaHVuayBzaXplIGlzIGxlc3MgdGhhbiAxIG9yIG5vdCBhbiBpbnRlZ2VyXG4gKiBAZXhhbXBsZVxuICogY2h1bmsoWzEsIDIsIDMsIDQsIDUsIDZdLCAyKTtcbiAqIC8vID0+IFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdXVxuICovXG5mdW5jdGlvbiBjaHVuayh4LCBjaHVua1NpemUpIHtcbiAgICAvLyBhIGxpc3Qgb2YgcmVzdWx0IGNodW5rcywgYXMgYXJyYXlzIGluIGFuIGFycmF5XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgLy8gYGNodW5rU2l6ZWAgbXVzdCBiZSB6ZXJvIG9yIGhpZ2hlciAtIG90aGVyd2lzZSB0aGUgbG9vcCBiZWxvdyxcbiAgICAvLyBpbiB3aGljaCB3ZSBjYWxsIGBzdGFydCArPSBjaHVua1NpemVgLCB3aWxsIGxvb3AgaW5maW5pdGVseS5cbiAgICAvLyBTbywgd2UnbGwgZGV0ZWN0IGFuZCB0aHJvdyBpbiB0aGF0IGNhc2UgdG8gaW5kaWNhdGVcbiAgICAvLyBpbnZhbGlkIGlucHV0LlxuICAgIGlmIChjaHVua1NpemUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rIHNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5mbG9vcihjaHVua1NpemUpICE9PSBjaHVua1NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2h1bmsgc2l6ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgfVxuXG4gICAgLy8gYHN0YXJ0YCBpcyB0aGUgaW5kZXggYXQgd2hpY2ggYC5zbGljZWAgd2lsbCBzdGFydCBzZWxlY3RpbmdcbiAgICAvLyBuZXcgYXJyYXkgZWxlbWVudHNcbiAgICBmb3IgKHZhciBzdGFydCA9IDA7IHN0YXJ0IDwgeC5sZW5ndGg7IHN0YXJ0ICs9IGNodW5rU2l6ZSkge1xuICAgICAgICAvLyBmb3IgZWFjaCBjaHVuaywgc2xpY2UgdGhhdCBwYXJ0IG9mIHRoZSBhcnJheSBhbmQgYWRkIGl0XG4gICAgICAgIC8vIHRvIHRoZSBvdXRwdXQuIFRoZSBgLnNsaWNlYCBmdW5jdGlvbiBkb2VzIG5vdCBjaGFuZ2VcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgICAgICBvdXRwdXQucHVzaCh4LnNsaWNlKHN0YXJ0LCBzdGFydCArIGNodW5rU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIFNhbXBsaW5nIHdpdGggcmVwbGFjZW1lbnQgaXMgYSB0eXBlIG9mIHNhbXBsaW5nIHRoYXQgYWxsb3dzIHRoZSBzYW1lXG4gKiBpdGVtIHRvIGJlIHBpY2tlZCBvdXQgb2YgYSBwb3B1bGF0aW9uIG1vcmUgdGhhbiBvbmNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHggYW4gYXJyYXkgb2YgYW55IGtpbmQgb2YgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIGNvdW50IG9mIGhvdyBtYW55IGVsZW1lbnRzIHRvIHRha2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlIHRoYXRcbiAqIHJldHVybnMgbnVtYmVycyBiZXR3ZWVuIDAgaW5jbHVzaXZlIGFuZCAxIGV4Y2x1c2l2ZTogdGhlIHJhbmdlIFswLCAxKVxuICogQHJldHVybiB7QXJyYXl9IG4gc2FtcGxlZCBpdGVtcyBmcm9tIHRoZSBwb3B1bGF0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyIHZhbHVlcyA9IFsxLCAyLCAzLCA0XTtcbiAqIHNhbXBsZVdpdGhSZXBsYWNlbWVudCh2YWx1ZXMsIDIpOyAvLyByZXR1cm5zIDIgcmFuZG9tIHZhbHVlcywgbGlrZSBbMiwgNF07XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVdpdGhSZXBsYWNlbWVudCh4LCBuLCByYW5kb21Tb3VyY2UpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIGEgY3VzdG9tIHJhbmRvbSBudW1iZXIgc291cmNlIGNhbiBiZSBwcm92aWRlZCBpZiB5b3Ugd2FudCB0byB1c2VcbiAgICAvLyBhIGZpeGVkIHNlZWQgb3IgYW5vdGhlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvciwgbGlrZVxuICAgIC8vIFtyYW5kb20tanNdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL3JhbmRvbS1qcylcbiAgICByYW5kb21Tb3VyY2UgPSByYW5kb21Tb3VyY2UgfHwgTWF0aC5yYW5kb207XG5cbiAgICB2YXIgbGVuZ3RoID0geC5sZW5ndGg7XG4gICAgdmFyIHNhbXBsZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcihyYW5kb21Tb3VyY2UoKSAqIGxlbmd0aCk7XG5cbiAgICAgICAgc2FtcGxlLnB1c2goeFtpbmRleF0pO1xuICAgIH1cblxuICAgIHJldHVybiBzYW1wbGU7XG59XG5cbi8qKlxuICogQSBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZSlcbiAqIGluLXBsYWNlIC0gd2hpY2ggbWVhbnMgdGhhdCBpdCAqKndpbGwgY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgb3JpZ2luYWxcbiAqIGFycmF5IGJ5IHJlZmVyZW5jZSoqLlxuICpcbiAqIFRoaXMgaXMgYW4gYWxnb3JpdGhtIHRoYXQgZ2VuZXJhdGVzIGEgcmFuZG9tIFtwZXJtdXRhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVybXV0YXRpb24pXG4gKiBvZiBhIHNldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmFuZG9tU291cmNlPU1hdGgucmFuZG9tXSBhbiBvcHRpb25hbCBlbnRyb3B5IHNvdXJjZSB0aGF0XG4gKiByZXR1cm5zIG51bWJlcnMgYmV0d2VlbiAwIGluY2x1c2l2ZSBhbmQgMSBleGNsdXNpdmU6IHRoZSByYW5nZSBbMCwgMSlcbiAqIEByZXR1cm5zIHtBcnJheX0geFxuICogQGV4YW1wbGVcbiAqIHZhciB4ID0gWzEsIDIsIDMsIDRdO1xuICogc2h1ZmZsZUluUGxhY2UoeCk7XG4gKiAvLyB4IGlzIHNodWZmbGVkIHRvIGEgdmFsdWUgbGlrZSBbMiwgMSwgNCwgM11cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZUluUGxhY2UoeCwgcmFuZG9tU291cmNlKSB7XG4gICAgLy8gYSBjdXN0b20gcmFuZG9tIG51bWJlciBzb3VyY2UgY2FuIGJlIHByb3ZpZGVkIGlmIHlvdSB3YW50IHRvIHVzZVxuICAgIC8vIGEgZml4ZWQgc2VlZCBvciBhbm90aGVyIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLCBsaWtlXG4gICAgLy8gW3JhbmRvbS1qc10oaHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvcmFuZG9tLWpzKVxuICAgIHJhbmRvbVNvdXJjZSA9IHJhbmRvbVNvdXJjZSB8fCBNYXRoLnJhbmRvbTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgeCB0byBkZXRlcm1pbmVcbiAgICAvLyB3aGVuIG5vIGVsZW1lbnRzIHJlbWFpbiB0byBzaHVmZmxlLlxuICAgIHZhciBsZW5ndGggPSB4Lmxlbmd0aDtcblxuICAgIC8vIHRlbXBvcmFyeSBpcyB1c2VkIHRvIGhvbGQgYW4gaXRlbSB3aGVuIGl0IGlzIGJlaW5nXG4gICAgLy8gc3dhcHBlZCBiZXR3ZWVuIGluZGljZXMuXG4gICAgdmFyIHRlbXBvcmFyeTtcblxuICAgIC8vIFRoZSBpbmRleCB0byBzd2FwIGF0IGVhY2ggc3RhZ2UuXG4gICAgdmFyIGluZGV4O1xuXG4gICAgLy8gV2hpbGUgdGhlcmUgYXJlIHN0aWxsIGl0ZW1zIHRvIHNodWZmbGVcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjaG9vc2UgYSByYW5kb20gaW5kZXggd2l0aGluIHRoZSBzdWJzZXQgb2YgdGhlIGFycmF5XG4gICAgICAgIC8vIHRoYXQgaXMgbm90IHlldCBzaHVmZmxlZFxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IocmFuZG9tU291cmNlKCkgKiBsZW5ndGgtLSk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHZhbHVlIHRoYXQgd2UnbGwgbW92ZSB0ZW1wb3JhcmlseVxuICAgICAgICB0ZW1wb3JhcnkgPSB4W2xlbmd0aF07XG5cbiAgICAgICAgLy8gc3dhcCB0aGUgdmFsdWUgYXQgYHhbbGVuZ3RoXWAgd2l0aCBgeFtpbmRleF1gXG4gICAgICAgIHhbbGVuZ3RoXSA9IHhbaW5kZXhdO1xuICAgICAgICB4W2luZGV4XSA9IHRlbXBvcmFyeTtcbiAgICB9XG5cbiAgICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBBIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXIlRTIlODAlOTNZYXRlc19zaHVmZmxlKVxuICogaXMgYSBmYXN0IHdheSB0byBjcmVhdGUgYSByYW5kb20gcGVybXV0YXRpb24gb2YgYSBmaW5pdGUgc2V0LiBUaGlzIGlzXG4gKiBhIGZ1bmN0aW9uIGFyb3VuZCBgc2h1ZmZsZV9pbl9wbGFjZWAgdGhhdCBhZGRzIHRoZSBndWFyYW50ZWUgdGhhdFxuICogaXQgd2lsbCBub3QgbW9kaWZ5IGl0cyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IHNhbXBsZSBvZiAwIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdFxuICogcmV0dXJucyBudW1iZXJzIGJldHdlZW4gMCBpbmNsdXNpdmUgYW5kIDEgZXhjbHVzaXZlOiB0aGUgcmFuZ2UgWzAsIDEpXG4gKiBAcmV0dXJuIHtBcnJheX0gc2h1ZmZsZWQgdmVyc2lvbiBvZiBpbnB1dFxuICogQGV4YW1wbGVcbiAqIHZhciBzaHVmZmxlZCA9IHNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIHNodWZmbGVkOyAvLyA9IFsyLCAzLCAxLCA0XSBvciBhbnkgb3RoZXIgcmFuZG9tIHBlcm11dGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoeCwgcmFuZG9tU291cmNlKSB7XG4gICAgLy8gc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5IHNvIHRoYXQgaXQgaXMgbm90IG1vZGlmaWVkXG4gICAgdmFyIHNhbXBsZSA9IHguc2xpY2UoKTtcblxuICAgIC8vIGFuZCB0aGVuIHNodWZmbGUgdGhhdCBzaGFsbG93LWNvcGllZCBhcnJheSwgaW4gcGxhY2VcbiAgICByZXR1cm4gc2h1ZmZsZUluUGxhY2Uoc2FtcGxlLCByYW5kb21Tb3VyY2UpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFtzaW1wbGUgcmFuZG9tIHNhbXBsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfcmFuZG9tX3NhbXBsZSlcbiAqIGZyb20gYSBnaXZlbiBhcnJheSBvZiBgbmAgZWxlbWVudHMuXG4gKlxuICogVGhlIHNhbXBsZWQgdmFsdWVzIHdpbGwgYmUgaW4gYW55IG9yZGVyLCBub3QgbmVjZXNzYXJpbHkgdGhlIG9yZGVyXG4gKiB0aGV5IGFwcGVhciBpbiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSB4IGlucHV0IGFycmF5LiBjYW4gY29udGFpbiBhbnkgdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gY291bnQgb2YgaG93IG1hbnkgZWxlbWVudHMgdG8gdGFrZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdFxuICogcmV0dXJucyBudW1iZXJzIGJldHdlZW4gMCBpbmNsdXNpdmUgYW5kIDEgZXhjbHVzaXZlOiB0aGUgcmFuZ2UgWzAsIDEpXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic2V0IG9mIG4gZWxlbWVudHMgaW4gb3JpZ2luYWwgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHZhbHVlcyA9IFsxLCAyLCA0LCA1LCA2LCA3LCA4LCA5XTtcbiAqIHNhbXBsZSh2YWx1ZXMsIDMpOyAvLyByZXR1cm5zIDMgcmFuZG9tIHZhbHVlcywgbGlrZSBbMiwgNSwgOF07XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZSh4LCBuLCByYW5kb21Tb3VyY2UpIHtcbiAgICAvLyBzaHVmZmxlIHRoZSBvcmlnaW5hbCBhcnJheSB1c2luZyBhIGZpc2hlci15YXRlcyBzaHVmZmxlXG4gICAgdmFyIHNodWZmbGVkID0gc2h1ZmZsZSh4LCByYW5kb21Tb3VyY2UpO1xuXG4gICAgLy8gYW5kIHRoZW4gcmV0dXJuIGEgc3Vic2V0IG9mIGl0IC0gdGhlIGZpcnN0IGBuYCBlbGVtZW50cy5cbiAgICByZXR1cm4gc2h1ZmZsZWQuc2xpY2UoMCwgbik7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbHVtbiB4IHJvdyBtYXRyaXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXG4gKiBAcGFyYW0ge251bWJlcn0gcm93c1xuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdHJpeFxuICogQGV4YW1wbGVcbiAqIG1ha2VNYXRyaXgoMTAsIDEwKTtcbiAqL1xuZnVuY3Rpb24gbWFrZU1hdHJpeChjb2x1bW5zLCByb3dzKSB7XG4gICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uczsgaSsrKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3dzOyBqKyspIHtcbiAgICAgICAgICAgIGNvbHVtbi5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5wdXNoKGNvbHVtbik7XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG59XG5cbi8qKlxuICogRm9yIGEgc29ydGVkIGlucHV0LCBjb3VudGluZyB0aGUgbnVtYmVyIG9mIHVuaXF1ZSB2YWx1ZXNcbiAqIGlzIHBvc3NpYmxlIGluIGNvbnN0YW50IHRpbWUgYW5kIGNvbnN0YW50IG1lbW9yeS4gVGhpcyBpc1xuICogYSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBWYWx1ZXMgYXJlIGNvbXBhcmVkIHdpdGggYD09PWAsIHNvIG9iamVjdHMgYW5kIG5vbi1wcmltaXRpdmUgb2JqZWN0c1xuICogYXJlIG5vdCBoYW5kbGVkIGluIGFueSBzcGVjaWFsIHdheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB4IGFuIGFycmF5IG9mIGFueSBraW5kIG9mIHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb3VudCBvZiB1bmlxdWUgdmFsdWVzXG4gKiBAZXhhbXBsZVxuICogdW5pcXVlQ291bnRTb3J0ZWQoWzEsIDIsIDNdKTsgLy8gPT4gM1xuICogdW5pcXVlQ291bnRTb3J0ZWQoWzEsIDEsIDFdKTsgLy8gPT4gMVxuICovXG5mdW5jdGlvbiB1bmlxdWVDb3VudFNvcnRlZCh4KSB7XG4gICAgdmFyIHVuaXF1ZVZhbHVlQ291bnQgPSAwO1xuICAgIHZhciBsYXN0U2VlblZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCB4W2ldICE9PSBsYXN0U2VlblZhbHVlKSB7XG4gICAgICAgICAgICBsYXN0U2VlblZhbHVlID0geFtpXTtcbiAgICAgICAgICAgIHVuaXF1ZVZhbHVlQ291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlVmFsdWVDb3VudDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgaW5jcmVtZW50YWxseSBjb21wdXRlZCB2YWx1ZXMgYmFzZWQgb24gdGhlIHN1bXMgYW5kIHN1bXMgb2ZcbiAqIHNxdWFyZXMgZm9yIHRoZSBkYXRhIGFycmF5XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBqXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHN1bXNPZlNxdWFyZXNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBleGFtcGxlXG4gKiBzc3EoMCwgMSwgWy0xLCAwLCAyXSwgWzEsIDEsIDVdKTtcbiAqL1xuZnVuY3Rpb24gc3NxKGosIGksIHN1bXMsIHN1bXNPZlNxdWFyZXMpIHtcbiAgICB2YXIgc2ppOyAvLyBzKGosIGkpXG4gICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHZhciBtdWppID0gKHN1bXNbaV0gLSBzdW1zW2ogLSAxXSkgLyAoaSAtIGogKyAxKTsgLy8gbXUoaiwgaSlcbiAgICAgICAgc2ppID1cbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXNbaV0gLSBzdW1zT2ZTcXVhcmVzW2ogLSAxXSAtIChpIC0gaiArIDEpICogbXVqaSAqIG11amk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2ppID0gc3Vtc09mU3F1YXJlc1tpXSAtIChzdW1zW2ldICogc3Vtc1tpXSkgLyAoaSArIDEpO1xuICAgIH1cbiAgICBpZiAoc2ppIDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHNqaTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJlY3Vyc2l2ZWx5IGRpdmlkZXMgYW5kIGNvbnF1ZXJzIGNvbXB1dGF0aW9uc1xuICogZm9yIGNsdXN0ZXIgalxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaU1pbiBNaW5pbXVtIGluZGV4IGluIGNsdXN0ZXIgdG8gYmUgY29tcHV0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpTWF4IE1heGltdW0gaW5kZXggaW4gY2x1c3RlciB0byBiZSBjb21wdXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IGNsdXN0ZXIgSW5kZXggb2YgdGhlIGNsdXN0ZXIgY3VycmVudGx5IGJlaW5nIGNvbXB1dGVkXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGJhY2t0cmFja01hdHJpeFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHN1bXNPZlNxdWFyZXNcbiAqL1xuZnVuY3Rpb24gZmlsbE1hdHJpeENvbHVtbihcbiAgICBpTWluLFxuICAgIGlNYXgsXG4gICAgY2x1c3RlcixcbiAgICBtYXRyaXgsXG4gICAgYmFja3RyYWNrTWF0cml4LFxuICAgIHN1bXMsXG4gICAgc3Vtc09mU3F1YXJlc1xuKSB7XG4gICAgaWYgKGlNaW4gPiBpTWF4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdGFydCBhdCBtaWRwb2ludCBiZXR3ZWVuIGlNaW4gYW5kIGlNYXhcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKGlNaW4gKyBpTWF4KSAvIDIpO1xuXG4gICAgbWF0cml4W2NsdXN0ZXJdW2ldID0gbWF0cml4W2NsdXN0ZXIgLSAxXVtpIC0gMV07XG4gICAgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2ldID0gaTtcblxuICAgIHZhciBqbG93ID0gY2x1c3RlcjsgLy8gdGhlIGxvd2VyIGVuZCBmb3IgalxuXG4gICAgaWYgKGlNaW4gPiBjbHVzdGVyKSB7XG4gICAgICAgIGpsb3cgPSBNYXRoLm1heChqbG93LCBiYWNrdHJhY2tNYXRyaXhbY2x1c3Rlcl1baU1pbiAtIDFdIHx8IDApO1xuICAgIH1cbiAgICBqbG93ID0gTWF0aC5tYXgoamxvdywgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXIgLSAxXVtpXSB8fCAwKTtcblxuICAgIHZhciBqaGlnaCA9IGkgLSAxOyAvLyB0aGUgdXBwZXIgZW5kIGZvciBqXG4gICAgaWYgKGlNYXggPCBtYXRyaXhbMF0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgamhpZ2ggPSBNYXRoLm1pbihqaGlnaCwgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2lNYXggKyAxXSB8fCAwKTtcbiAgICAgICAgLyogYzggaWdub3JlIGVuZCAqL1xuICAgIH1cblxuICAgIHZhciBzamk7XG4gICAgdmFyIHNqbG93aTtcbiAgICB2YXIgc3NxamxvdztcbiAgICB2YXIgc3NxajtcbiAgICBmb3IgKHZhciBqID0gamhpZ2g7IGogPj0gamxvdzsgLS1qKSB7XG4gICAgICAgIHNqaSA9IHNzcShqLCBpLCBzdW1zLCBzdW1zT2ZTcXVhcmVzKTtcblxuICAgICAgICBpZiAoc2ppICsgbWF0cml4W2NsdXN0ZXIgLSAxXVtqbG93IC0gMV0gPj0gbWF0cml4W2NsdXN0ZXJdW2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4YW1pbmUgdGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBjbHVzdGVyIGJvcmRlclxuICAgICAgICBzamxvd2kgPSBzc3EoamxvdywgaSwgc3Vtcywgc3Vtc09mU3F1YXJlcyk7XG5cbiAgICAgICAgc3NxamxvdyA9IHNqbG93aSArIG1hdHJpeFtjbHVzdGVyIC0gMV1bamxvdyAtIDFdO1xuXG4gICAgICAgIGlmIChzc3FqbG93IDwgbWF0cml4W2NsdXN0ZXJdW2ldKSB7XG4gICAgICAgICAgICAvLyBTaHJpbmsgdGhlIGxvd2VyIGJvdW5kXG4gICAgICAgICAgICBtYXRyaXhbY2x1c3Rlcl1baV0gPSBzc3FqbG93O1xuICAgICAgICAgICAgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2ldID0gamxvdztcbiAgICAgICAgfVxuICAgICAgICBqbG93Kys7XG5cbiAgICAgICAgc3NxaiA9IHNqaSArIG1hdHJpeFtjbHVzdGVyIC0gMV1baiAtIDFdO1xuICAgICAgICBpZiAoc3NxaiA8IG1hdHJpeFtjbHVzdGVyXVtpXSkge1xuICAgICAgICAgICAgbWF0cml4W2NsdXN0ZXJdW2ldID0gc3NxajtcbiAgICAgICAgICAgIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpXSA9IGo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaWxsTWF0cml4Q29sdW1uKFxuICAgICAgICBpTWluLFxuICAgICAgICBpIC0gMSxcbiAgICAgICAgY2x1c3RlcixcbiAgICAgICAgbWF0cml4LFxuICAgICAgICBiYWNrdHJhY2tNYXRyaXgsXG4gICAgICAgIHN1bXMsXG4gICAgICAgIHN1bXNPZlNxdWFyZXNcbiAgICApO1xuICAgIGZpbGxNYXRyaXhDb2x1bW4oXG4gICAgICAgIGkgKyAxLFxuICAgICAgICBpTWF4LFxuICAgICAgICBjbHVzdGVyLFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIGJhY2t0cmFja01hdHJpeCxcbiAgICAgICAgc3VtcyxcbiAgICAgICAgc3Vtc09mU3F1YXJlc1xuICAgICk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIG1haW4gbWF0cmljZXMgdXNlZCBpbiBDa21lYW5zIGFuZCBraWNrc1xuICogb2ZmIHRoZSBkaXZpZGUgYW5kIGNvbnF1ZXIgY2x1c3RlciBjb21wdXRhdGlvbiBzdHJhdGVneVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhdGEgc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0cml4XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBiYWNrdHJhY2tNYXRyaXhcbiAqL1xuZnVuY3Rpb24gZmlsbE1hdHJpY2VzKGRhdGEsIG1hdHJpeCwgYmFja3RyYWNrTWF0cml4KSB7XG4gICAgdmFyIG5WYWx1ZXMgPSBtYXRyaXhbMF0ubGVuZ3RoO1xuXG4gICAgLy8gU2hpZnQgdmFsdWVzIGJ5IHRoZSBtZWRpYW4gdG8gaW1wcm92ZSBudW1lcmljIHN0YWJpbGl0eVxuICAgIHZhciBzaGlmdCA9IGRhdGFbTWF0aC5mbG9vcihuVmFsdWVzIC8gMildO1xuXG4gICAgLy8gQ3VtdWxhdGl2ZSBzdW0gYW5kIGN1bXVsYXRpdmUgc3VtIG9mIHNxdWFyZXMgZm9yIGFsbCB2YWx1ZXMgaW4gZGF0YSBhcnJheVxuICAgIHZhciBzdW1zID0gW107XG4gICAgdmFyIHN1bXNPZlNxdWFyZXMgPSBbXTtcblxuICAgIC8vIEluaXRpYWxpemUgZmlyc3QgY29sdW1uIGluIG1hdHJpeCAmIGJhY2t0cmFja01hdHJpeFxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdGVkVmFsdWUgPSAodm9pZCAwKTsgaSA8IG5WYWx1ZXM7ICsraSkge1xuICAgICAgICBzaGlmdGVkVmFsdWUgPSBkYXRhW2ldIC0gc2hpZnQ7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBzdW1zLnB1c2goc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXMucHVzaChzaGlmdGVkVmFsdWUgKiBzaGlmdGVkVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vtcy5wdXNoKHN1bXNbaSAtIDFdICsgc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXMucHVzaChcbiAgICAgICAgICAgICAgICBzdW1zT2ZTcXVhcmVzW2kgLSAxXSArIHNoaWZ0ZWRWYWx1ZSAqIHNoaWZ0ZWRWYWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZm9yIGNsdXN0ZXIgPSAwXG4gICAgICAgIG1hdHJpeFswXVtpXSA9IHNzcSgwLCBpLCBzdW1zLCBzdW1zT2ZTcXVhcmVzKTtcbiAgICAgICAgYmFja3RyYWNrTWF0cml4WzBdW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSByZXN0IG9mIHRoZSBjb2x1bW5zXG4gICAgdmFyIGlNaW47XG4gICAgZm9yICh2YXIgY2x1c3RlciA9IDE7IGNsdXN0ZXIgPCBtYXRyaXgubGVuZ3RoOyArK2NsdXN0ZXIpIHtcbiAgICAgICAgaWYgKGNsdXN0ZXIgPCBtYXRyaXgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaU1pbiA9IGNsdXN0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNvbXB1dGUgbWF0cml4W0stMV1bMF0gLi4uIG1hdHJpeFtLLTFdW04tMl1cbiAgICAgICAgICAgIGlNaW4gPSBuVmFsdWVzIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGxNYXRyaXhDb2x1bW4oXG4gICAgICAgICAgICBpTWluLFxuICAgICAgICAgICAgblZhbHVlcyAtIDEsXG4gICAgICAgICAgICBjbHVzdGVyLFxuICAgICAgICAgICAgbWF0cml4LFxuICAgICAgICAgICAgYmFja3RyYWNrTWF0cml4LFxuICAgICAgICAgICAgc3VtcyxcbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXNcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2ttZWFucyBjbHVzdGVyaW5nIGlzIGFuIGltcHJvdmVtZW50IG9uIGhldXJpc3RpYy1iYXNlZCBjbHVzdGVyaW5nXG4gKiBhcHByb2FjaGVzIGxpa2UgSmVua3MuIFRoZSBhbGdvcml0aG0gd2FzIGRldmVsb3BlZCBpblxuICogW0hhaXpob3UgV2FuZyBhbmQgTWluZ3pob3UgU29uZ10oaHR0cDovL2pvdXJuYWwuci1wcm9qZWN0Lm9yZy9hcmNoaXZlLzIwMTEtMi9SSm91cm5hbF8yMDExLTJfV2FuZytTb25nLnBkZilcbiAqIGFzIGEgW2R5bmFtaWMgcHJvZ3JhbW1pbmddKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0R5bmFtaWNfcHJvZ3JhbW1pbmcpIGFwcHJvYWNoXG4gKiB0byB0aGUgcHJvYmxlbSBvZiBjbHVzdGVyaW5nIG51bWVyaWMgZGF0YSBpbnRvIGdyb3VwcyB3aXRoIHRoZSBsZWFzdFxuICogd2l0aGluLWdyb3VwIHN1bS1vZi1zcXVhcmVkLWRldmlhdGlvbnMuXG4gKlxuICogTWluaW1pemluZyB0aGUgZGlmZmVyZW5jZSB3aXRoaW4gZ3JvdXBzIC0gd2hhdCBXYW5nICYgU29uZyByZWZlciB0byBhc1xuICogYHdpdGhpbnNzYCwgb3Igd2l0aGluIHN1bS1vZi1zcXVhcmVzLCBtZWFucyB0aGF0IGdyb3VwcyBhcmUgb3B0aW1hbGx5XG4gKiBob21vZ2Vub3VzIHdpdGhpbiBhbmQgdGhlIGRhdGEgaXMgc3BsaXQgaW50byByZXByZXNlbnRhdGl2ZSBncm91cHMuXG4gKiBUaGlzIGlzIHZlcnkgdXNlZnVsIGZvciB2aXN1YWxpemF0aW9uLCB3aGVyZSB5b3UgbWF5IHdhbnQgdG8gcmVwcmVzZW50XG4gKiBhIGNvbnRpbnVvdXMgdmFyaWFibGUgaW4gZGlzY3JldGUgY29sb3Igb3Igc3R5bGUgZ3JvdXBzLiBUaGlzIGZ1bmN0aW9uXG4gKiBjYW4gcHJvdmlkZSBncm91cHMgdGhhdCBlbXBoYXNpemUgZGlmZmVyZW5jZXMgYmV0d2VlbiBkYXRhLlxuICpcbiAqIEJlaW5nIGEgZHluYW1pYyBhcHByb2FjaCwgdGhpcyBhbGdvcml0aG0gaXMgYmFzZWQgb24gdHdvIG1hdHJpY2VzIHRoYXRcbiAqIHN0b3JlIGluY3JlbWVudGFsbHktY29tcHV0ZWQgdmFsdWVzIGZvciBzcXVhcmVkIGRldmlhdGlvbnMgYW5kIGJhY2t0cmFja2luZ1xuICogaW5kZXhlcy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIENrbWVhbnMgMy40LjYsIHdoaWNoIGludHJvZHVjZWQgYSBuZXcgZGl2aWRlXG4gKiBhbmQgY29ucXVlciBhcHByb2FjaCB0aGF0IGltcHJvdmVkIHJ1bnRpbWUgZnJvbSBPKGtuXjIpIHRvIE8oa24gbG9nKG4pKS5cbiAqXG4gKiBVbmxpa2UgdGhlIFtvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9jcmFuLnItcHJvamVjdC5vcmcvd2ViL3BhY2thZ2VzL0NrbWVhbnMuMWQuZHAvaW5kZXguaHRtbCksXG4gKiB0aGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGluY2x1ZGUgYW55IGNvZGUgdG8gYXV0b21hdGljYWxseSBkZXRlcm1pbmVcbiAqIHRoZSBvcHRpbWFsIG51bWJlciBvZiBjbHVzdGVyczogdGhpcyBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBleHBsaWNpdGx5XG4gKiBwcm92aWRlZC5cbiAqXG4gKiAjIyMgUmVmZXJlbmNlc1xuICogX0NrbWVhbnMuMWQuZHA6IE9wdGltYWwgay1tZWFucyBDbHVzdGVyaW5nIGluIE9uZSBEaW1lbnNpb24gYnkgRHluYW1pY1xuICogUHJvZ3JhbW1pbmdfIEhhaXpob3UgV2FuZyBhbmQgTWluZ3pob3UgU29uZyBJU1NOIDIwNzMtNDg1OVxuICpcbiAqIGZyb20gVGhlIFIgSm91cm5hbCBWb2wuIDMvMiwgRGVjZW1iZXIgMjAxMVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0IGRhdGEsIGFzIGFuIGFycmF5IG9mIG51bWJlciB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuQ2x1c3RlcnMgbnVtYmVyIG9mIGRlc2lyZWQgY2xhc3Nlcy4gVGhpcyBjYW5ub3QgYmVcbiAqIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbiB0aGUgZGF0YSBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY2x1c3RlcmVkIGlucHV0XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG51bWJlciBvZiByZXF1ZXN0ZWQgY2x1c3RlcnMgaXMgaGlnaGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIGRhdGFcbiAqIEBleGFtcGxlXG4gKiBja21lYW5zKFstMSwgMiwgLTEsIDIsIDQsIDUsIDYsIC0xLCAyLCAtMV0sIDMpO1xuICogLy8gVGhlIGlucHV0LCBjbHVzdGVyZWQgaW50byBncm91cHMgb2Ygc2ltaWxhciBudW1iZXJzLlxuICogLy89IFtbLTEsIC0xLCAtMSwgLTFdLCBbMiwgMiwgMl0sIFs0LCA1LCA2XV0pO1xuICovXG5mdW5jdGlvbiBja21lYW5zKHgsIG5DbHVzdGVycykge1xuICAgIGlmIChuQ2x1c3RlcnMgPiB4Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcImNhbm5vdCBnZW5lcmF0ZSBtb3JlIGNsYXNzZXMgdGhhbiB0aGVyZSBhcmUgZGF0YSB2YWx1ZXNcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBzb3J0ZWQgPSBudW1lcmljU29ydCh4KTtcbiAgICAvLyB3ZSdsbCB1c2UgdGhpcyBhcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2x1c3RlcnNcbiAgICB2YXIgdW5pcXVlQ291bnQgPSB1bmlxdWVDb3VudFNvcnRlZChzb3J0ZWQpO1xuXG4gICAgLy8gaWYgYWxsIG9mIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIGlkZW50aWNhbCwgdGhlcmUncyBvbmUgY2x1c3RlclxuICAgIC8vIHdpdGggYWxsIG9mIHRoZSBpbnB1dCBpbiBpdC5cbiAgICBpZiAodW5pcXVlQ291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtzb3J0ZWRdO1xuICAgIH1cblxuICAgIC8vIG5hbWVkICdTJyBvcmlnaW5hbGx5XG4gICAgdmFyIG1hdHJpeCA9IG1ha2VNYXRyaXgobkNsdXN0ZXJzLCBzb3J0ZWQubGVuZ3RoKTtcbiAgICAvLyBuYW1lZCAnSicgb3JpZ2luYWxseVxuICAgIHZhciBiYWNrdHJhY2tNYXRyaXggPSBtYWtlTWF0cml4KG5DbHVzdGVycywgc29ydGVkLmxlbmd0aCk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwcm9ncmFtbWluZyB3YXkgdG8gc29sdmUgdGhlIHByb2JsZW0gb2YgbWluaW1pemluZ1xuICAgIC8vIHdpdGhpbi1jbHVzdGVyIHN1bSBvZiBzcXVhcmVzLiBJdCdzIHNpbWlsYXIgdG8gbGluZWFyIHJlZ3Jlc3Npb25cbiAgICAvLyBpbiB0aGlzIHdheSwgYW5kIHRoaXMgY2FsY3VsYXRpb24gaW5jcmVtZW50YWxseSBjb21wdXRlcyB0aGVcbiAgICAvLyBzdW0gb2Ygc3F1YXJlcyB0aGF0IGFyZSBsYXRlciByZWFkLlxuICAgIGZpbGxNYXRyaWNlcyhzb3J0ZWQsIG1hdHJpeCwgYmFja3RyYWNrTWF0cml4KTtcblxuICAgIC8vIFRoZSByZWFsIHdvcmsgb2YgQ2ttZWFucyBjbHVzdGVyaW5nIGhhcHBlbnMgaW4gdGhlIG1hdHJpeCBnZW5lcmF0aW9uOlxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgbWF0cmljZXMgZW5jb2RlIGFsbCBwb3NzaWJsZSBjbHVzdGVyaW5nIGNvbWJpbmF0aW9ucywgYW5kXG4gICAgLy8gb25jZSB0aGV5J3JlIGdlbmVyYXRlZCB3ZSBjYW4gc29sdmUgZm9yIHRoZSBiZXN0IGNsdXN0ZXJpbmcgZ3JvdXBzXG4gICAgLy8gdmVyeSBxdWlja2x5LlxuICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgIHZhciBjbHVzdGVyUmlnaHQgPSBiYWNrdHJhY2tNYXRyaXhbMF0ubGVuZ3RoIC0gMTtcblxuICAgIC8vIEJhY2t0cmFjayB0aGUgY2x1c3RlcnMgZnJvbSB0aGUgZHluYW1pYyBwcm9ncmFtbWluZyBtYXRyaXguIFRoaXNcbiAgICAvLyBzdGFydHMgYXQgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXIgb2YgdGhlIG1hdHJpeCAoaWYgdGhlIHRvcC1sZWZ0IGlzIDAsIDApLFxuICAgIC8vIGFuZCBtb3ZlcyB0aGUgY2x1c3RlciB0YXJnZXQgd2l0aCB0aGUgbG9vcC5cbiAgICBmb3IgKHZhciBjbHVzdGVyID0gYmFja3RyYWNrTWF0cml4Lmxlbmd0aCAtIDE7IGNsdXN0ZXIgPj0gMDsgY2x1c3Rlci0tKSB7XG4gICAgICAgIHZhciBjbHVzdGVyTGVmdCA9IGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtjbHVzdGVyUmlnaHRdO1xuXG4gICAgICAgIC8vIGZpbGwgdGhlIGNsdXN0ZXIgZnJvbSB0aGUgc29ydGVkIGlucHV0IGJ5IHRha2luZyBhIHNsaWNlIG9mIHRoZVxuICAgICAgICAvLyBhcnJheS4gdGhlIGJhY2t0cmFjayBtYXRyaXggbWFrZXMgdGhpcyBlYXN5IC0gaXQgc3RvcmVzIHRoZVxuICAgICAgICAvLyBpbmRleGVzIHdoZXJlIHRoZSBjbHVzdGVyIHNob3VsZCBzdGFydCBhbmQgZW5kLlxuICAgICAgICBjbHVzdGVyc1tjbHVzdGVyXSA9IHNvcnRlZC5zbGljZShjbHVzdGVyTGVmdCwgY2x1c3RlclJpZ2h0ICsgMSk7XG5cbiAgICAgICAgaWYgKGNsdXN0ZXIgPiAwKSB7XG4gICAgICAgICAgICBjbHVzdGVyUmlnaHQgPSBjbHVzdGVyTGVmdCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbi8qXG4gKiBQdWxsIEJyZWFrcyBWYWx1ZXMgZm9yIEplbmtzXG4gKlxuICogdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBqZW5rcyByZWNpcGU6IHRha2UgdGhlIGNhbGN1bGF0ZWQgbWF0cmljZXNcbiAqIGFuZCBkZXJpdmUgYW4gYXJyYXkgb2YgbiBicmVha3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gamVua3NCcmVha3MoZGF0YSwgbG93ZXJDbGFzc0xpbWl0cywgbkNsYXNzZXMpIHtcbiAgICB2YXIgayA9IGRhdGEubGVuZ3RoO1xuICAgIHZhciBrY2xhc3MgPSBbXTtcbiAgICB2YXIgY291bnROdW0gPSBuQ2xhc3NlcztcblxuICAgIC8vIHRoZSBjYWxjdWxhdGlvbiBvZiBjbGFzc2VzIHdpbGwgbmV2ZXIgaW5jbHVkZSB0aGUgdXBwZXJcbiAgICAvLyBib3VuZCwgc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IHNldCBpdFxuICAgIGtjbGFzc1tuQ2xhc3Nlc10gPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG5cbiAgICAvLyB0aGUgbG93ZXJDbGFzc0xpbWl0cyBtYXRyaXggaXMgdXNlZCBhcyBpbmRpY2VzIGludG8gaXRzZWxmXG4gICAgLy8gaGVyZTogdGhlIGBrYCB2YXJpYWJsZSBpcyByZXVzZWQgaW4gZWFjaCBpdGVyYXRpb24uXG4gICAgd2hpbGUgKGNvdW50TnVtID4gMCkge1xuICAgICAgICBrY2xhc3NbY291bnROdW0gLSAxXSA9IGRhdGFbbG93ZXJDbGFzc0xpbWl0c1trXVtjb3VudE51bV0gLSAxXTtcbiAgICAgICAgayA9IGxvd2VyQ2xhc3NMaW1pdHNba11bY291bnROdW1dIC0gMTtcbiAgICAgICAgY291bnROdW0tLTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2NsYXNzO1xufVxuXG4vKlxuICogQ29tcHV0ZSBNYXRyaWNlcyBmb3IgSmVua3NcbiAqXG4gKiBDb21wdXRlIHRoZSBtYXRyaWNlcyByZXF1aXJlZCBmb3IgSmVua3MgYnJlYWtzLiBUaGVzZSBtYXRyaWNlc1xuICogY2FuIGJlIHVzZWQgZm9yIGFueSBjbGFzc2luZyBvZiBkYXRhIHdpdGggYGNsYXNzZXMgPD0gbkNsYXNzZXNgXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gamVua3NNYXRyaWNlcyhkYXRhLCBuQ2xhc3Nlcykge1xuICAgIC8vIGluIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiwgdGhlc2UgbWF0cmljZXMgYXJlIHJlZmVycmVkIHRvXG4gICAgLy8gYXMgYExDYCBhbmQgYE9QYFxuICAgIC8vXG4gICAgLy8gKiBsb3dlckNsYXNzTGltaXRzIChMQyk6IG9wdGltYWwgbG93ZXIgY2xhc3MgbGltaXRzXG4gICAgLy8gKiB2YXJpYW5jZUNvbWJpbmF0aW9ucyAoT1ApOiBvcHRpbWFsIHZhcmlhbmNlIGNvbWJpbmF0aW9ucyBmb3IgYWxsIGNsYXNzZXNcbiAgICB2YXIgbG93ZXJDbGFzc0xpbWl0cyA9IFtdO1xuICAgIHZhciB2YXJpYW5jZUNvbWJpbmF0aW9ucyA9IFtdO1xuICAgIC8vIGxvb3AgY291bnRlcnNcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICAvLyB0aGUgdmFyaWFuY2UsIGFzIGNvbXB1dGVkIGF0IGVhY2ggc3RlcCBpbiB0aGUgY2FsY3VsYXRpb25cbiAgICB2YXIgdmFyaWFuY2UgPSAwO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBhbmQgZmlsbCBlYWNoIG1hdHJpeCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCArIDE7IGkrKykge1xuICAgICAgICB2YXIgdG1wMSA9IFtdO1xuICAgICAgICB2YXIgdG1wMiA9IFtdO1xuICAgICAgICAvLyBkZXNwaXRlIHRoZXNlIGFycmF5cyBoYXZpbmcgdGhlIHNhbWUgdmFsdWVzLCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGtlZXAgdGhlbSBzZXBhcmF0ZSBzbyB0aGF0IGNoYW5naW5nIG9uZSBkb2VzIG5vdCBjaGFuZ2VcbiAgICAgICAgLy8gdGhlIG90aGVyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBuQ2xhc3NlcyArIDE7IGorKykge1xuICAgICAgICAgICAgdG1wMS5wdXNoKDApO1xuICAgICAgICAgICAgdG1wMi5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHMucHVzaCh0bXAxKTtcbiAgICAgICAgdmFyaWFuY2VDb21iaW5hdGlvbnMucHVzaCh0bXAyKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbkNsYXNzZXMgKyAxOyBpKyspIHtcbiAgICAgICAgbG93ZXJDbGFzc0xpbWl0c1sxXVtpXSA9IDE7XG4gICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zWzFdW2ldID0gMDtcbiAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLCA5OTk5OTk5IGlzIHVzZWQgYnV0XG4gICAgICAgIC8vIHNpbmNlIEphdmFzY3JpcHQgaGFzIGBJbmZpbml0eWAsIHdlIHVzZSB0aGF0LlxuICAgICAgICBmb3IgKGogPSAyOyBqIDwgZGF0YS5sZW5ndGggKyAxOyBqKyspIHtcbiAgICAgICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zW2pdW2ldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbCA9IDI7IGwgPCBkYXRhLmxlbmd0aCArIDE7IGwrKykge1xuICAgICAgICAvLyBgU1pgIG9yaWdpbmFsbHkuIHRoaXMgaXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIHNlZW4gdGh1c1xuICAgICAgICAvLyBmYXIgd2hlbiBjYWxjdWxhdGluZyB2YXJpYW5jZS5cbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIC8vIGBaU1FgIG9yaWdpbmFsbHkuIHRoZSBzdW0gb2Ygc3F1YXJlcyBvZiB2YWx1ZXMgc2VlblxuICAgICAgICAvLyB0aHVzIGZhclxuICAgICAgICB2YXIgc3VtU3F1YXJlcyA9IDA7XG4gICAgICAgIC8vIGBXVGAgb3JpZ2luYWxseS4gVGhpcyBpcyB0aGUgbnVtYmVyIG9mXG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgLy8gYElWYCBvcmlnaW5hbGx5XG4gICAgICAgIHZhciBpNCA9IDA7XG5cbiAgICAgICAgLy8gaW4gc2V2ZXJhbCBpbnN0YW5jZXMsIHlvdSBjb3VsZCBzYXkgYE1hdGgucG93KHgsIDIpYFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGB4ICogeGAsIGJ1dCB0aGlzIGlzIHNsb3dlciBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIC8vIGludHJvZHVjZXMgYW4gdW5uZWNlc3NhcnkgY29uY2VwdC5cbiAgICAgICAgZm9yICh2YXIgbSA9IDE7IG0gPCBsICsgMTsgbSsrKSB7XG4gICAgICAgICAgICAvLyBgSUlJYCBvcmlnaW5hbGx5XG4gICAgICAgICAgICB2YXIgbG93ZXJDbGFzc0xpbWl0ID0gbCAtIG0gKyAxO1xuICAgICAgICAgICAgdmFyIHZhbCA9IGRhdGFbbG93ZXJDbGFzc0xpbWl0IC0gMV07XG5cbiAgICAgICAgICAgIC8vIGhlcmUgd2UncmUgZXN0aW1hdGluZyB2YXJpYW5jZSBmb3IgZWFjaCBwb3RlbnRpYWwgY2xhc3NpbmdcbiAgICAgICAgICAgIC8vIG9mIHRoZSBkYXRhLCBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mIGNsYXNzZXMuIGB3YFxuICAgICAgICAgICAgLy8gaXMgdGhlIG51bWJlciBvZiBkYXRhIHBvaW50cyBjb25zaWRlcmVkIHNvIGZhci5cbiAgICAgICAgICAgIHcrKztcblxuICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGN1cnJlbnQgc3VtIGFuZCBzdW0tb2Ytc3F1YXJlc1xuICAgICAgICAgICAgc3VtICs9IHZhbDtcbiAgICAgICAgICAgIHN1bVNxdWFyZXMgKz0gdmFsICogdmFsO1xuXG4gICAgICAgICAgICAvLyB0aGUgdmFyaWFuY2UgYXQgdGhpcyBwb2ludCBpbiB0aGUgc2VxdWVuY2UgaXMgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHN1bSBvZiBzcXVhcmVzIGFuZCB0aGUgdG90YWwgeCAyLCBvdmVyIHRoZSBudW1iZXJcbiAgICAgICAgICAgIC8vIG9mIHNhbXBsZXMuXG4gICAgICAgICAgICB2YXJpYW5jZSA9IHN1bVNxdWFyZXMgLSAoc3VtICogc3VtKSAvIHc7XG5cbiAgICAgICAgICAgIGk0ID0gbG93ZXJDbGFzc0xpbWl0IC0gMTtcblxuICAgICAgICAgICAgaWYgKGk0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMjsgaiA8IG5DbGFzc2VzICsgMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFkZGluZyB0aGlzIGVsZW1lbnQgdG8gYW4gZXhpc3RpbmcgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBpbmNyZWFzZSBpdHMgdmFyaWFuY2UgYmV5b25kIHRoZSBsaW1pdCwgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNsYXNzIGF0IHRoaXMgcG9pbnQsIHNldHRpbmcgdGhlIGBsb3dlckNsYXNzTGltaXRgXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zW2xdW2pdID49XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW5jZSArIHZhcmlhbmNlQ29tYmluYXRpb25zW2k0XVtqIC0gMV1cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlckNsYXNzTGltaXRzW2xdW2pdID0gbG93ZXJDbGFzc0xpbWl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFuY2VDb21iaW5hdGlvbnNbbF1bal0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlICsgdmFyaWFuY2VDb21iaW5hdGlvbnNbaTRdW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHNbbF1bMV0gPSAxO1xuICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1tsXVsxXSA9IHZhcmlhbmNlO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgdHdvIG1hdHJpY2VzLiBmb3IganVzdCBwcm92aWRpbmcgYnJlYWtzLCBvbmx5XG4gICAgLy8gYGxvd2VyQ2xhc3NMaW1pdHNgIGlzIG5lZWRlZCwgYnV0IHZhcmlhbmNlcyBjYW4gYmUgdXNlZnVsIHRvXG4gICAgLy8gZXZhbHVhdGUgZ29vZG5lc3Mgb2YgZml0LlxuICAgIHJldHVybiB7XG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHM6IGxvd2VyQ2xhc3NMaW1pdHMsXG4gICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zOiB2YXJpYW5jZUNvbWJpbmF0aW9uc1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlICoqW2plbmtzIG5hdHVyYWwgYnJlYWtzIG9wdGltaXphdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KZW5rc19uYXR1cmFsX2JyZWFrc19vcHRpbWl6YXRpb24pKipcbiAqIGlzIGFuIGFsZ29yaXRobSBjb21tb25seSB1c2VkIGluIGNhcnRvZ3JhcGh5IGFuZCB2aXN1YWxpemF0aW9uIHRvIGRlY2lkZVxuICogdXBvbiBncm91cGluZ3Mgb2YgZGF0YSB2YWx1ZXMgdGhhdCBtaW5pbWl6ZSB2YXJpYW5jZSB3aXRoaW4gdGhlbXNlbHZlc1xuICogYW5kIG1heGltaXplIHZhcmlhdGlvbiBiZXR3ZWVuIHRoZW1zZWx2ZXMuXG4gKlxuICogRm9yIGluc3RhbmNlLCBjYXJ0b2dyYXBoZXJzIG9mdGVuIHVzZSBqZW5rcyBpbiBvcmRlciB0byBjaG9vc2Ugd2hpY2hcbiAqIHZhbHVlcyBhcmUgYXNzaWduZWQgdG8gd2hpY2ggY29sb3JzIGluIGEgW2Nob3JvcGxldGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nob3JvcGxldGhfbWFwKVxuICogbWFwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YSBpbnB1dCBkYXRhLCBhcyBhbiBhcnJheSBvZiBudW1iZXIgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbkNsYXNzZXMgbnVtYmVyIG9mIGRlc2lyZWQgY2xhc3Nlc1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGFycmF5IG9mIGNsYXNzIGJyZWFrIHBvc2l0aW9uc1xuICogLy8gc3BsaXQgZGF0YSBpbnRvIDMgYnJlYWsgcG9pbnRzXG4gKiBqZW5rcyhbMSwgMiwgNCwgNSwgNywgOSwgMTAsIDIwXSwgMykgLy8gPSBbMSwgNywgMjAsIDIwXVxuICovXG5mdW5jdGlvbiBqZW5rcyhkYXRhLCBuQ2xhc3Nlcykge1xuICAgIGlmIChuQ2xhc3NlcyA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHNvcnQgZGF0YSBpbiBudW1lcmljYWwgb3JkZXIsIHNpbmNlIHRoaXMgaXMgZXhwZWN0ZWRcbiAgICAvLyBieSB0aGUgbWF0cmljZXMgZnVuY3Rpb25cbiAgICBkYXRhID0gZGF0YS5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgLy8gZ2V0IG91ciBiYXNpYyBtYXRyaWNlc1xuICAgIHZhciBtYXRyaWNlcyA9IGplbmtzTWF0cmljZXMoZGF0YSwgbkNsYXNzZXMpO1xuICAgIC8vIHdlIG9ubHkgbmVlZCBsb3dlciBjbGFzcyBsaW1pdHMgaGVyZVxuICAgIHZhciBsb3dlckNsYXNzTGltaXRzID0gbWF0cmljZXMubG93ZXJDbGFzc0xpbWl0cztcblxuICAgIC8vIGV4dHJhY3QgbkNsYXNzZXMgb3V0IG9mIHRoZSBjb21wdXRlZCBtYXRyaWNlc1xuICAgIHJldHVybiBqZW5rc0JyZWFrcyhkYXRhLCBsb3dlckNsYXNzTGltaXRzLCBuQ2xhc3Nlcyk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgeCwgdGhpcyB3aWxsIGZpbmQgdGhlIGV4dGVudCBvZiB0aGVcbiAqIHggYW5kIHJldHVybiBhbiBhcnJheSBvZiBicmVha3MgdGhhdCBjYW4gYmUgdXNlZFxuICogdG8gY2F0ZWdvcml6ZSB0aGUgeCBpbnRvIGEgbnVtYmVyIG9mIGNsYXNzZXMuIFRoZVxuICogcmV0dXJuZWQgYXJyYXkgd2lsbCBhbHdheXMgYmUgMSBsb25nZXIgdGhhbiB0aGUgbnVtYmVyIG9mXG4gKiBjbGFzc2VzIGJlY2F1c2UgaXQgaW5jbHVkZXMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGFuIGFycmF5IG9mIG51bWJlciB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuQ2xhc3NlcyBudW1iZXIgb2YgZGVzaXJlZCBjbGFzc2VzXG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gYXJyYXkgb2YgY2xhc3MgYnJlYWsgcG9zaXRpb25zXG4gKiBAZXhhbXBsZVxuICogZXF1YWxJbnRlcnZhbEJyZWFrcyhbMSwgMiwgMywgNCwgNSwgNl0sIDQpOyAvLyA9PiBbMSwgMi4yNSwgMy41LCA0Ljc1LCA2XVxuICovXG5mdW5jdGlvbiBlcXVhbEludGVydmFsQnJlYWtzKHgsIG5DbGFzc2VzKSB7XG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICB2YXIgdGhlTWluID0gbWluKHgpO1xuICAgIHZhciB0aGVNYXggPSBtYXgoeCk7XG5cbiAgICAvLyB0aGUgZmlyc3QgYnJlYWsgd2lsbCBhbHdheXMgYmUgdGhlIG1pbmltdW0gdmFsdWVcbiAgICAvLyBpbiB0aGUgeHNldFxuICAgIHZhciBicmVha3MgPSBbdGhlTWluXTtcblxuICAgIC8vIFRoZSBzaXplIG9mIGVhY2ggYnJlYWsgaXMgdGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIHhcbiAgICAvLyBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgY2xhc3NlcyByZXF1ZXN0ZWRcbiAgICB2YXIgYnJlYWtTaXplID0gKHRoZU1heCAtIHRoZU1pbikgLyBuQ2xhc3NlcztcblxuICAgIC8vIEluIHRoZSBjYXNlIG9mIG5DbGFzc2VzID0gMSwgdGhpcyBsb29wIHdvbid0IHJ1blxuICAgIC8vIGFuZCB0aGUgcmV0dXJuZWQgYnJlYWtzIHdpbGwgYmUgW21pbiwgbWF4XVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbkNsYXNzZXM7IGkrKykge1xuICAgICAgICBicmVha3MucHVzaChicmVha3NbMF0gKyBicmVha1NpemUgKiBpKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgbGFzdCBicmVhayB3aWxsIGFsd2F5cyBiZSB0aGVcbiAgICAvLyBtYXhpbXVtLlxuICAgIGJyZWFrcy5wdXNoKHRoZU1heCk7XG5cbiAgICByZXR1cm4gYnJlYWtzO1xufVxuXG4vKipcbiAqIFtTYW1wbGUgY292YXJpYW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2FtcGxlX21lYW5fYW5kX2NvdmFyaWFuY2UpIG9mIHR3byBkYXRhc2V0czpcbiAqIGhvdyBtdWNoIGRvIHRoZSB0d28gZGF0YXNldHMgbW92ZSB0b2dldGhlcj9cbiAqIHggYW5kIHkgYXJlIHR3byBkYXRhc2V0cywgcmVwcmVzZW50ZWQgYXMgYXJyYXlzIG9mIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIHR3byBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHkgYSBzYW1wbGUgb2YgdHdvIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGFuZCB5IGRvIG5vdCBoYXZlIGVxdWFsIGxlbmd0aHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IG9yIHkgaGF2ZSBsZW5ndGggb2Ygb25lIG9yIGxlc3NcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBjb3ZhcmlhbmNlXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlQ292YXJpYW5jZShbMSwgMiwgMywgNCwgNSwgNl0sIFs2LCA1LCA0LCAzLCAyLCAxXSk7IC8vID0+IC0zLjVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlQ292YXJpYW5jZSh4LCB5KSB7XG4gICAgLy8gVGhlIHR3byBkYXRhc2V0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoIHdoaWNoIG11c3QgYmUgbW9yZSB0aGFuIDFcbiAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgc2FtcGxlcyB3aXRoIGVxdWFsIGxlbmd0aHNcIik7XG4gICAgfVxuXG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcInNhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzIGluIGVhY2ggc2FtcGxlXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIG1lYW4gb2YgZWFjaCBkYXRhc2V0IHNvIHRoYXQgd2UgY2FuIGp1ZGdlIGVhY2hcbiAgICAvLyB2YWx1ZSBvZiB0aGUgZGF0YXNldCBmYWlybHkgYXMgdGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgbWVhbi4gdGhpc1xuICAgIC8vIHdheSwgaWYgb25lIGRhdGFzZXQgaXMgWzEsIDIsIDNdIGFuZCBbMiwgMywgNF0sIHRoZWlyIGNvdmFyaWFuY2VcbiAgICAvLyBkb2VzIG5vdCBzdWZmZXIgYmVjYXVzZSBvZiB0aGUgZGlmZmVyZW5jZSBpbiBhYnNvbHV0ZSB2YWx1ZXNcbiAgICB2YXIgeG1lYW4gPSBtZWFuKHgpO1xuICAgIHZhciB5bWVhbiA9IG1lYW4oeSk7XG4gICAgdmFyIHN1bSA9IDA7XG5cbiAgICAvLyBmb3IgZWFjaCBwYWlyIG9mIHZhbHVlcywgdGhlIGNvdmFyaWFuY2UgaW5jcmVhc2VzIHdoZW4gdGhlaXJcbiAgICAvLyBkaWZmZXJlbmNlIGZyb20gdGhlIG1lYW4gaXMgYXNzb2NpYXRlZCAtIGlmIGJvdGggYXJlIHdlbGwgYWJvdmVcbiAgICAvLyBvciBpZiBib3RoIGFyZSB3ZWxsIGJlbG93XG4gICAgLy8gdGhlIG1lYW4sIHRoZSBjb3ZhcmlhbmNlIGluY3JlYXNlcyBzaWduaWZpY2FudGx5LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gKHhbaV0gLSB4bWVhbikgKiAoeVtpXSAtIHltZWFuKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIEJlc3NlbHMnIENvcnJlY3Rpb246IGFuIGFkanVzdG1lbnQgbWFkZSB0byBzYW1wbGUgc3RhdGlzdGljc1xuICAgIC8vIHRoYXQgYWxsb3dzIGZvciB0aGUgcmVkdWNlZCBkZWdyZWUgb2YgZnJlZWRvbSBlbnRhaWxlZCBpbiBjYWxjdWxhdGluZ1xuICAgIC8vIHZhbHVlcyBmcm9tIHNhbXBsZXMgcmF0aGVyIHRoYW4gY29tcGxldGUgcG9wdWxhdGlvbnMuXG4gICAgdmFyIGJlc3NlbHNDb3JyZWN0aW9uID0geC5sZW5ndGggLSAxO1xuXG4gICAgLy8gdGhlIGNvdmFyaWFuY2UgaXMgd2VpZ2h0ZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgZGF0YXNldHMuXG4gICAgcmV0dXJuIHN1bSAvIGJlc3NlbHNDb3JyZWN0aW9uO1xufVxuXG4vKipcbiAqIFRoZSBbc2FtcGxlIHZhcmlhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYW5jZSNTYW1wbGVfdmFyaWFuY2UpXG4gKiBpcyB0aGUgc3VtIG9mIHNxdWFyZWQgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWFuLiBUaGUgc2FtcGxlIHZhcmlhbmNlXG4gKiBpcyBkaXN0aW5ndWlzaGVkIGZyb20gdGhlIHZhcmlhbmNlIGJ5IHRoZSB1c2FnZSBvZiBbQmVzc2VsJ3MgQ29ycmVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVzc2VsJ3NfY29ycmVjdGlvbik6XG4gKiBpbnN0ZWFkIG9mIGRpdmlkaW5nIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGlucHV0LFxuICogaXQgaXMgZGl2aWRlZCBieSB0aGUgbGVuZ3RoIG1pbnVzIG9uZS4gVGhpcyBjb3JyZWN0cyB0aGUgYmlhcyBpbiBlc3RpbWF0aW5nXG4gKiBhIHZhbHVlIGZyb20gYSBzZXQgdGhhdCB5b3UgZG9uJ3Qga25vdyBpZiBmdWxsLlxuICpcbiAqIFJlZmVyZW5jZXM6XG4gKiAqIFtXb2xmcmFtIE1hdGhXb3JsZCBvbiBTYW1wbGUgVmFyaWFuY2VdKGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU2FtcGxlVmFyaWFuY2UuaHRtbClcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBzYW1wbGUgb2YgdHdvIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIDJcbiAqIEByZXR1cm4ge251bWJlcn0gc2FtcGxlIHZhcmlhbmNlXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlVmFyaWFuY2UoWzEsIDIsIDMsIDQsIDVdKTsgLy8gPT4gMi41XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVZhcmlhbmNlKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZVZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBkYXRhIHBvaW50c1wiKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtU3F1YXJlZERldmlhdGlvbnNWYWx1ZSA9IHN1bU50aFBvd2VyRGV2aWF0aW9ucyh4LCAyKTtcblxuICAgIC8vIHRoaXMgaXMgQmVzc2VscycgQ29ycmVjdGlvbjogYW4gYWRqdXN0bWVudCBtYWRlIHRvIHNhbXBsZSBzdGF0aXN0aWNzXG4gICAgLy8gdGhhdCBhbGxvd3MgZm9yIHRoZSByZWR1Y2VkIGRlZ3JlZSBvZiBmcmVlZG9tIGVudGFpbGVkIGluIGNhbGN1bGF0aW5nXG4gICAgLy8gdmFsdWVzIGZyb20gc2FtcGxlcyByYXRoZXIgdGhhbiBjb21wbGV0ZSBwb3B1bGF0aW9ucy5cbiAgICB2YXIgYmVzc2Vsc0NvcnJlY3Rpb24gPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICAvLyBGaW5kIHRoZSBtZWFuIHZhbHVlIG9mIHRoYXQgbGlzdFxuICAgIHJldHVybiBzdW1TcXVhcmVkRGV2aWF0aW9uc1ZhbHVlIC8gYmVzc2Vsc0NvcnJlY3Rpb247XG59XG5cbi8qKlxuICogVGhlIFtzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0YW5kYXJkX2RldmlhdGlvbiNTYW1wbGVfc3RhbmRhcmRfZGV2aWF0aW9uKVxuICogaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBzYW1wbGUgdmFyaWFuY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0IGFycmF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKS50b0ZpeGVkKDIpO1xuICogLy8gPT4gJzIuMTQnXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpIHtcbiAgICB2YXIgc2FtcGxlVmFyaWFuY2VYID0gc2FtcGxlVmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydChzYW1wbGVWYXJpYW5jZVgpO1xufVxuXG4vKipcbiAqIFRoZSBbY29ycmVsYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29ycmVsYXRpb25fYW5kX2RlcGVuZGVuY2UpIGlzXG4gKiBhIG1lYXN1cmUgb2YgaG93IGNvcnJlbGF0ZWQgdHdvIGRhdGFzZXRzIGFyZSwgYmV0d2VlbiAtMSBhbmQgMVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBmaXJzdCBpbnB1dFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5IHNlY29uZCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIGNvcnJlbGF0aW9uXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlQ29ycmVsYXRpb24oWzEsIDIsIDMsIDQsIDUsIDZdLCBbMiwgMiwgMywgNCwgNSwgNjBdKS50b0ZpeGVkKDIpO1xuICogLy8gPT4gJzAuNjknXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZUNvcnJlbGF0aW9uKHgsIHkpIHtcbiAgICB2YXIgY292ID0gc2FtcGxlQ292YXJpYW5jZSh4LCB5KTtcbiAgICB2YXIgeHN0ZCA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpO1xuICAgIHZhciB5c3RkID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeSk7XG5cbiAgICByZXR1cm4gY292IC8geHN0ZCAvIHlzdGQ7XG59XG5cbi8qKlxuICogVGhlIFtyYW5rIGNvcnJlbGF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW5rX2NvcnJlbGF0aW9uKSBpc1xuICogYSBtZWFzdXJlIG9mIHRoZSBzdHJlbmd0aCBvZiBtb25vdG9uaWMgcmVsYXRpb25zaGlwIGJldHdlZW4gdHdvIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBmaXJzdCBpbnB1dFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5IHNlY29uZCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIHJhbmsgY29ycmVsYXRpb25cbiAqL1xuZnVuY3Rpb24gc2FtcGxlUmFua0NvcnJlbGF0aW9uKHgsIHkpIHtcbiAgICB2YXIgeEluZGV4ZXMgPSB4XG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gW3ZhbHVlLCBpbmRleF07IH0pXG4gICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocGFpcikgeyByZXR1cm4gcGFpclsxXTsgfSk7XG4gICAgdmFyIHlJbmRleGVzID0geVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuIFt2YWx1ZSwgaW5kZXhdOyB9KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhaXIpIHsgcmV0dXJuIHBhaXJbMV07IH0pO1xuXG4gICAgLy8gQXQgdGhpcyBzdGVwLCB3ZSBoYXZlIGFuIGFycmF5IG9mIGluZGV4ZXNcbiAgICAvLyB0aGF0IG1hcCBmcm9tIHNvcnRlZCBudW1iZXJzIHRvIHRoZWlyIG9yaWdpbmFsIGluZGV4ZXMuIFdlIHJldmVyc2VcbiAgICAvLyB0aGF0IHNvIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgdGhlIHNvcnRlZCBkZXN0aW5hdGlvbiBpbmRleC5cbiAgICB2YXIgeFJhbmtzID0gQXJyYXkoeEluZGV4ZXMubGVuZ3RoKTtcbiAgICB2YXIgeVJhbmtzID0gQXJyYXkoeEluZGV4ZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhSYW5rc1t4SW5kZXhlc1tpXV0gPSBpO1xuICAgICAgICB5UmFua3NbeUluZGV4ZXNbaV1dID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2FtcGxlQ29ycmVsYXRpb24oeFJhbmtzLCB5UmFua3MpO1xufVxuXG4vKipcbiAqIFtTa2V3bmVzc10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ta2V3bmVzcykgaXNcbiAqIGEgbWVhc3VyZSBvZiB0aGUgZXh0ZW50IHRvIHdoaWNoIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIG9mIGFcbiAqIHJlYWwtdmFsdWVkIHJhbmRvbSB2YXJpYWJsZSBcImxlYW5zXCIgdG8gb25lIHNpZGUgb2YgdGhlIG1lYW4uXG4gKiBUaGUgc2tld25lc3MgdmFsdWUgY2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBvciBldmVuIHVuZGVmaW5lZC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgYWRqdXN0ZWQgRmlzaGVyLVBlYXJzb24gc3RhbmRhcmRpemVkXG4gKiBtb21lbnQgY29lZmZpY2llbnQsIHdoaWNoIGlzIHRoZSB2ZXJzaW9uIGZvdW5kIGluIEV4Y2VsIGFuZCBzZXZlcmFsXG4gKiBzdGF0aXN0aWNhbCBwYWNrYWdlcyBpbmNsdWRpbmcgTWluaXRhYiwgU0FTIGFuZCBTUFNTLlxuICpcbiAqIEBzaW5jZSA0LjEuMFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIDMgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIHNrZXduZXNzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBoYXMgbGVuZ3RoIGxlc3MgdGhhbiAzXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlU2tld25lc3MoWzIsIDQsIDYsIDMsIDFdKTsgLy8gPT4gMC41OTAxMjg2NTYzODQzNjVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlU2tld25lc3MoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlU2tld25lc3MgcmVxdWlyZXMgYXQgbGVhc3QgdGhyZWUgZGF0YSBwb2ludHNcIik7XG4gICAgfVxuXG4gICAgdmFyIG1lYW5WYWx1ZSA9IG1lYW4oeCk7XG4gICAgdmFyIHRlbXBWYWx1ZTtcbiAgICB2YXIgc3VtU3F1YXJlZERldmlhdGlvbnMgPSAwO1xuICAgIHZhciBzdW1DdWJlZERldmlhdGlvbnMgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgIHN1bVNxdWFyZWREZXZpYXRpb25zICs9IHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZTtcbiAgICAgICAgc3VtQ3ViZWREZXZpYXRpb25zICs9IHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIEJlc3NlbHMnIENvcnJlY3Rpb246IGFuIGFkanVzdG1lbnQgbWFkZSB0byBzYW1wbGUgc3RhdGlzdGljc1xuICAgIC8vIHRoYXQgYWxsb3dzIGZvciB0aGUgcmVkdWNlZCBkZWdyZWUgb2YgZnJlZWRvbSBlbnRhaWxlZCBpbiBjYWxjdWxhdGluZ1xuICAgIC8vIHZhbHVlcyBmcm9tIHNhbXBsZXMgcmF0aGVyIHRoYW4gY29tcGxldGUgcG9wdWxhdGlvbnMuXG4gICAgdmFyIGJlc3NlbHNDb3JyZWN0aW9uID0geC5sZW5ndGggLSAxO1xuXG4gICAgLy8gRmluZCB0aGUgbWVhbiB2YWx1ZSBvZiB0aGF0IGxpc3RcbiAgICB2YXIgdGhlU2FtcGxlU3RhbmRhcmREZXZpYXRpb24gPSBNYXRoLnNxcnQoXG4gICAgICAgIHN1bVNxdWFyZWREZXZpYXRpb25zIC8gYmVzc2Vsc0NvcnJlY3Rpb25cbiAgICApO1xuXG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICB2YXIgY3ViZWRTID0gTWF0aC5wb3codGhlU2FtcGxlU3RhbmRhcmREZXZpYXRpb24sIDMpO1xuXG4gICAgcmV0dXJuIChuICogc3VtQ3ViZWREZXZpYXRpb25zKSAvICgobiAtIDEpICogKG4gLSAyKSAqIGN1YmVkUyk7XG59XG5cbi8qKlxuICogW0t1cnRvc2lzXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0t1cnRvc2lzKSBpc1xuICogYSBtZWFzdXJlIG9mIHRoZSBoZWF2aW5lc3Mgb2YgYSBkaXN0cmlidXRpb24ncyB0YWlscyByZWxhdGl2ZSB0byBpdHNcbiAqIHZhcmlhbmNlLiBUaGUga3VydG9zaXMgdmFsdWUgY2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBvciBldmVuIHVuZGVmaW5lZC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiBGaXNoZXIncyBleGNlc3Mga3VydG9zaXMgZGVmaW5pdGlvbiBhbmQgdXNlc1xuICogdW5iaWFzZWQgbW9tZW50IGVzdGltYXRvcnMuIFRoaXMgaXMgdGhlIHZlcnNpb24gZm91bmQgaW4gRXhjZWwgYW5kIGF2YWlsYWJsZVxuICogaW4gc2V2ZXJhbCBzdGF0aXN0aWNhbCBwYWNrYWdlcywgaW5jbHVkaW5nIFNBUyBhbmQgU2NpUHkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIDQgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIGt1cnRvc2lzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBoYXMgbGVuZ3RoIGxlc3MgdGhhbiA0XG4gKiBAZXhhbXBsZVxuICogc2FtcGxlS3VydG9zaXMoWzEsIDIsIDIsIDMsIDVdKTsgLy8gPT4gMS40NTU1NzY1NTk1NDYzMTIyXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZUt1cnRvc2lzKHgpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKG4gPCA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZUt1cnRvc2lzIHJlcXVpcmVzIGF0IGxlYXN0IGZvdXIgZGF0YSBwb2ludHNcIik7XG4gICAgfVxuXG4gICAgdmFyIG1lYW5WYWx1ZSA9IG1lYW4oeCk7XG4gICAgdmFyIHRlbXBWYWx1ZTtcbiAgICB2YXIgc2Vjb25kQ2VudHJhbE1vbWVudCA9IDA7XG4gICAgdmFyIGZvdXJ0aENlbnRyYWxNb21lbnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdGVtcFZhbHVlID0geFtpXSAtIG1lYW5WYWx1ZTtcbiAgICAgICAgc2Vjb25kQ2VudHJhbE1vbWVudCArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgICAgIGZvdXJ0aENlbnRyYWxNb21lbnQgKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlICogdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgICgobiAtIDEpIC8gKChuIC0gMikgKiAobiAtIDMpKSkgKlxuICAgICAgICAoKG4gKiAobiArIDEpICogZm91cnRoQ2VudHJhbE1vbWVudCkgL1xuICAgICAgICAgICAgKHNlY29uZENlbnRyYWxNb21lbnQgKiBzZWNvbmRDZW50cmFsTW9tZW50KSAtXG4gICAgICAgICAgICAzICogKG4gLSAxKSlcbiAgICApO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIFtIZWFwJ3MgQWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwJTI3c19hbGdvcml0aG0pXG4gKiBmb3IgZ2VuZXJhdGluZyBwZXJtdXRhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgYW55IHR5cGUgb2YgZGF0YVxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYXJyYXkgb2YgcGVybXV0YXRpb25zXG4gKi9cbmZ1bmN0aW9uIHBlcm11dGF0aW9uc0hlYXAoZWxlbWVudHMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IG5ldyBBcnJheShlbGVtZW50cy5sZW5ndGgpO1xuICAgIHZhciBwZXJtdXRhdGlvbnMgPSBbZWxlbWVudHMuc2xpY2UoKV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluZGV4ZXNbaV0gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGVsZW1lbnRzLmxlbmd0aDsgKSB7XG4gICAgICAgIGlmIChpbmRleGVzW2kkMV0gPCBpJDEpIHtcbiAgICAgICAgICAgIC8vIEF0IG9kZCBpbmRleGVzLCBzd2FwIGZyb20gaW5kZXhlc1tpXSBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBvZiBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gICAgICAgICAgICB2YXIgc3dhcEZyb20gPSAwO1xuICAgICAgICAgICAgaWYgKGkkMSAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICBzd2FwRnJvbSA9IGluZGV4ZXNbaSQxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3dhcCBiZXR3ZWVuIHN3YXBGcm9tIGFuZCBpLCB1c2luZ1xuICAgICAgICAgICAgLy8gYSB0ZW1wb3JhcnkgdmFyaWFibGUgYXMgc3RvcmFnZS5cbiAgICAgICAgICAgIHZhciB0ZW1wID0gZWxlbWVudHNbc3dhcEZyb21dO1xuICAgICAgICAgICAgZWxlbWVudHNbc3dhcEZyb21dID0gZWxlbWVudHNbaSQxXTtcbiAgICAgICAgICAgIGVsZW1lbnRzW2kkMV0gPSB0ZW1wO1xuXG4gICAgICAgICAgICBwZXJtdXRhdGlvbnMucHVzaChlbGVtZW50cy5zbGljZSgpKTtcbiAgICAgICAgICAgIGluZGV4ZXNbaSQxXSsrO1xuICAgICAgICAgICAgaSQxID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ZXNbaSQxXSA9IDA7XG4gICAgICAgICAgICBpJDErKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgQ29tYmluYXRpb25zXG4gKiBDb21iaW5hdGlvbnMgYXJlIHVuaXF1ZSBzdWJzZXRzIG9mIGEgY29sbGVjdGlvbiAtIGluIHRoaXMgY2FzZSwgayB4IGZyb20gYSBjb2xsZWN0aW9uIGF0IGEgdGltZS5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmF0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSB4IGFueSB0eXBlIG9mIGRhdGFcbiAqIEBwYXJhbSB7aW50fSBrIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiBlYWNoIGdyb3VwICh3aXRob3V0IHJlcGxhY2VtZW50KVxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYXJyYXkgb2YgcGVybXV0YXRpb25zXG4gKiBAZXhhbXBsZVxuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7IC8vID0+IFtbMSwyXSwgWzEsM10sIFsyLDNdXVxuICovXG5cbmZ1bmN0aW9uIGNvbWJpbmF0aW9ucyh4LCBrKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHN1Ykk7XG4gICAgdmFyIGNvbWJpbmF0aW9uTGlzdCA9IFtdO1xuICAgIHZhciBzdWJzZXRDb21iaW5hdGlvbnM7XG4gICAgdmFyIG5leHQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgY29tYmluYXRpb25MaXN0LnB1c2goW3hbaV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNldENvbWJpbmF0aW9ucyA9IGNvbWJpbmF0aW9ucyh4LnNsaWNlKGkgKyAxLCB4Lmxlbmd0aCksIGsgLSAxKTtcbiAgICAgICAgICAgIGZvciAoc3ViSSA9IDA7IHN1YkkgPCBzdWJzZXRDb21iaW5hdGlvbnMubGVuZ3RoOyBzdWJJKyspIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gc3Vic2V0Q29tYmluYXRpb25zW3N1YkldO1xuICAgICAgICAgICAgICAgIG5leHQudW5zaGlmdCh4W2ldKTtcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbkxpc3QucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tYmluYXRpb25MaXN0O1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIFtDb21iaW5hdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmF0aW9uKSB3aXRoIHJlcGxhY2VtZW50XG4gKiBDb21iaW5hdGlvbnMgYXJlIHVuaXF1ZSBzdWJzZXRzIG9mIGEgY29sbGVjdGlvbiAtIGluIHRoaXMgY2FzZSwgayB4IGZyb20gYSBjb2xsZWN0aW9uIGF0IGEgdGltZS5cbiAqICdXaXRoIHJlcGxhY2VtZW50JyBtZWFucyB0aGF0IGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgY2hvc2VuIG11bHRpcGxlIHRpbWVzLlxuICogVW5saWtlIHBlcm11dGF0aW9uLCBvcmRlciBkb2Vzbid0IG1hdHRlciBmb3IgY29tYmluYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHggYW55IHR5cGUgb2YgZGF0YVxuICogQHBhcmFtIHtpbnR9IGsgdGhlIG51bWJlciBvZiBvYmplY3RzIGluIGVhY2ggZ3JvdXAgKHdpdGhvdXQgcmVwbGFjZW1lbnQpXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSBhcnJheSBvZiBwZXJtdXRhdGlvbnNcbiAqIEBleGFtcGxlXG4gKiBjb21iaW5hdGlvbnNSZXBsYWNlbWVudChbMSwgMl0sIDIpOyAvLyA9PiBbWzEsIDFdLCBbMSwgMl0sIFsyLCAyXV1cbiAqL1xuZnVuY3Rpb24gY29tYmluYXRpb25zUmVwbGFjZW1lbnQoeCwgaykge1xuICAgIHZhciBjb21iaW5hdGlvbkxpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgcmVxdWVzdGVkIHRvIGZpbmQgb25seSBvbmUgZWxlbWVudCwgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAgICAgLy8gdG8gcmVjdXJzZToganVzdCBwdXNoIGB4W2ldYCBvbnRvIHRoZSBsaXN0IG9mIGNvbWJpbmF0aW9ucy5cbiAgICAgICAgICAgIGNvbWJpbmF0aW9uTGlzdC5wdXNoKFt4W2ldXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHJlY3Vyc2l2ZWx5IGZpbmQgY29tYmluYXRpb25zLCBnaXZlbiBgayAtIDFgLiBOb3RlIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIHJlcXVlc3QgYGsgLSAxYCwgc28gaWYgeW91IHdlcmUgbG9va2luZyBmb3Igaz0zIGNvbWJpbmF0aW9ucywgd2UncmVcbiAgICAgICAgICAgIC8vIHJlcXVlc3Rpbmcgaz0yLiBUaGlzIC0xIGdldHMgcmV2ZXJzZWQgaW4gdGhlIGZvciBsb29wIHJpZ2h0IGFmdGVyIHRoaXNcbiAgICAgICAgICAgIC8vIGNvZGUsIHNpbmNlIHdlIGNvbmNhdGVuYXRlIGB4W2ldYCBvbnRvIHRoZSBzZWxlY3RlZCBjb21iaW5hdGlvbnMsXG4gICAgICAgICAgICAvLyBicmluZ2luZyBga2AgYmFjayB1cCB0byB5b3VyIHJlcXVlc3RlZCBsZXZlbC5cbiAgICAgICAgICAgIC8vIFRoaXMgcmVjdXJzaW9uIG1heSBnbyBtYW55IGxldmVscyBkZWVwLCBzaW5jZSBpdCBvbmx5IHN0b3BzIG9uY2VcbiAgICAgICAgICAgIC8vIGs9MS5cbiAgICAgICAgICAgIHZhciBzdWJzZXRDb21iaW5hdGlvbnMgPSBjb21iaW5hdGlvbnNSZXBsYWNlbWVudChcbiAgICAgICAgICAgICAgICB4LnNsaWNlKGksIHgubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBrIC0gMVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJzZXRDb21iaW5hdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbkxpc3QucHVzaChbeFtpXV0uY29uY2F0KHN1YnNldENvbWJpbmF0aW9uc1tqXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmF0aW9uTGlzdDtcbn1cblxuLyoqXG4gKiBXaGVuIGFkZGluZyBhIG5ldyB2YWx1ZSB0byBhIGxpc3QsIG9uZSBkb2VzIG5vdCBoYXZlIHRvIG5lY2Vzc2FyeVxuICogcmVjb21wdXRlIHRoZSBtZWFuIG9mIHRoZSBsaXN0IGluIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZVxuICogdGhpcyBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBuZXcgbWVhbiBieSBwcm92aWRpbmcgdGhlIGN1cnJlbnQgbWVhbixcbiAqIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3QgdGhhdCBwcm9kdWNlZCBpdCBhbmQgdGhlIG5ld1xuICogdmFsdWUgdG8gYWRkLlxuICpcbiAqIEBzaW5jZSAyLjUuMFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4gY3VycmVudCBtZWFuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSB0aGUgYWRkZWQgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBuZXcgbWVhblxuICpcbiAqIEBleGFtcGxlXG4gKiBhZGRUb01lYW4oMTQsIDUsIDUzKTsgLy8gPT4gMjAuNVxuICovXG5mdW5jdGlvbiBhZGRUb01lYW4obWVhbiwgbiwgbmV3VmFsdWUpIHtcbiAgICByZXR1cm4gbWVhbiArIChuZXdWYWx1ZSAtIG1lYW4pIC8gKG4gKyAxKTtcbn1cblxuLyoqXG4gKiBXaGVuIGNvbWJpbmluZyB0d28gbGlzdHMgb2YgdmFsdWVzIGZvciB3aGljaCBvbmUgYWxyZWFkeSBrbm93cyB0aGUgbWVhbnMsXG4gKiBvbmUgZG9lcyBub3QgaGF2ZSB0byBuZWNlc3NhcnkgcmVjb21wdXRlIHRoZSBtZWFuIG9mIHRoZSBjb21iaW5lZCBsaXN0cyBpblxuICogbGluZWFyIHRpbWUuIFRoZXkgY2FuIGluc3RlYWQgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgY29tYmluZWRcbiAqIG1lYW4gYnkgcHJvdmlkaW5nIHRoZSBtZWFuICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgZmlyc3QgbGlzdCBhbmQgdGhlIG1lYW5cbiAqICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgc2Vjb25kIGxpc3QuXG4gKlxuICogQHNpbmNlIDMuMC4wXG4gKiBAcGFyYW0ge251bWJlcn0gbWVhbjEgbWVhbiBvZiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4xIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4yIG1lYW4gb2YgdGhlIHNlY29uZCBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbjIgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzZWNvbmQgbGlzdFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNvbWJpbmVkIG1lYW5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29tYmluZU1lYW5zKDUsIDMsIDQsIDMpOyAvLyA9PiA0LjVcbiAqL1xuZnVuY3Rpb24gY29tYmluZU1lYW5zKG1lYW4xLCBuMSwgbWVhbjIsIG4yKSB7XG4gICAgcmV0dXJuIChtZWFuMSAqIG4xICsgbWVhbjIgKiBuMikgLyAobjEgKyBuMik7XG59XG5cbi8qKlxuICogV2hlbiBjb21iaW5pbmcgdHdvIGxpc3RzIG9mIHZhbHVlcyBmb3Igd2hpY2ggb25lIGFscmVhZHkga25vd3MgdGhlIHZhcmlhbmNlcyxcbiAqIG9uZSBkb2VzIG5vdCBoYXZlIHRvIG5lY2Vzc2FyeSByZWNvbXB1dGUgdGhlIHZhcmlhbmNlIG9mIHRoZSBjb21iaW5lZCBsaXN0c1xuICogaW4gbGluZWFyIHRpbWUuIFRoZXkgY2FuIGluc3RlYWQgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgY29tYmluZWRcbiAqIHZhcmlhbmNlIGJ5IHByb3ZpZGluZyB0aGUgdmFyaWFuY2UsIG1lYW4gJiBudW1iZXIgb2YgdmFsdWVzIG9mIHRoZSBmaXJzdCBsaXN0XG4gKiBhbmQgdGhlIHZhcmlhbmNlLCBtZWFuICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgc2Vjb25kIGxpc3QuXG4gKlxuICogQHNpbmNlIDMuMC4wXG4gKiBAcGFyYW0ge251bWJlcn0gdmFyaWFuY2UxIHZhcmlhbmNlIG9mIHRoZSBmaXJzdCBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbWVhbjEgbWVhbiBvZiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4xIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IHZhcmlhbmNlMiB2YXJpYW5jZSBvZiB0aGUgc2Vjb25kIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuMiBtZWFuIG9mIHRoZSBzZWNvbmQgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4yIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc2Vjb25kIGxpc3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb21iaW5lZCBtZWFuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbWJpbmVWYXJpYW5jZXMoMTQgLyAzLCA1LCAzLCA4IC8gMywgNCwgMyk7IC8vID0+IDQ3IC8gMTJcbiAqL1xuZnVuY3Rpb24gY29tYmluZVZhcmlhbmNlcyh2YXJpYW5jZTEsIG1lYW4xLCBuMSwgdmFyaWFuY2UyLCBtZWFuMiwgbjIpIHtcbiAgICB2YXIgbmV3TWVhbiA9IGNvbWJpbmVNZWFucyhtZWFuMSwgbjEsIG1lYW4yLCBuMik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICAobjEgKiAodmFyaWFuY2UxICsgTWF0aC5wb3cobWVhbjEgLSBuZXdNZWFuLCAyKSkgK1xuICAgICAgICAgICAgbjIgKiAodmFyaWFuY2UyICsgTWF0aC5wb3cobWVhbjIgLSBuZXdNZWFuLCAyKSkpIC9cbiAgICAgICAgKG4xICsgbjIpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBUaGUgW0dlb21ldHJpYyBNZWFuXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9tZXRyaWNfbWVhbikgaXNcbiAqIGEgbWVhbiBmdW5jdGlvbiB0aGF0IGlzIG1vcmUgdXNlZnVsIGZvciBudW1iZXJzIGluIGRpZmZlcmVudFxuICogcmFuZ2VzLlxuICpcbiAqIFRoaXMgaXMgdGhlIG50aCByb290IG9mIHRoZSBpbnB1dCBudW1iZXJzIG11bHRpcGxpZWQgYnkgZWFjaCBvdGhlci5cbiAqXG4gKiBUaGUgZ2VvbWV0cmljIG1lYW4gaXMgb2Z0ZW4gdXNlZnVsIGZvclxuICogKipbcHJvcG9ydGlvbmFsIGdyb3d0aF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvbWV0cmljX21lYW4jUHJvcG9ydGlvbmFsX2dyb3d0aCkqKjogZ2l2ZW5cbiAqIGdyb3d0aCByYXRlcyBmb3IgbXVsdGlwbGUgeWVhcnMsIGxpa2UgXzgwJSwgMTYuNjYlIGFuZCA0Mi44NSVfLCBhIHNpbXBsZVxuICogbWVhbiB3aWxsIGluY29ycmVjdGx5IGVzdGltYXRlIGFuIGF2ZXJhZ2UgZ3Jvd3RoIHJhdGUsIHdoZXJlYXMgYSBnZW9tZXRyaWNcbiAqIG1lYW4gd2lsbCBjb3JyZWN0bHkgZXN0aW1hdGUgYSBncm93dGggcmF0ZSB0aGF0LCBvdmVyIHRob3NlIHllYXJzLFxuICogd2lsbCB5aWVsZCB0aGUgc2FtZSBlbmQgdmFsdWUuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBnZW9tZXRyaWMgbWVhblxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGNvbnRhaW5zIGEgbmVnYXRpdmUgbnVtYmVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGdyb3d0aFJhdGVzID0gWzEuODAsIDEuMTY2NjY2LCAxLjQyODU3MV07XG4gKiB2YXIgYXZlcmFnZUdyb3d0aCA9IHNzLmdlb21ldHJpY01lYW4oZ3Jvd3RoUmF0ZXMpO1xuICogdmFyIGF2ZXJhZ2VHcm93dGhSYXRlcyA9IFthdmVyYWdlR3Jvd3RoLCBhdmVyYWdlR3Jvd3RoLCBhdmVyYWdlR3Jvd3RoXTtcbiAqIHZhciBzdGFydGluZ1ZhbHVlID0gMTA7XG4gKiB2YXIgc3RhcnRpbmdWYWx1ZU1lYW4gPSAxMDtcbiAqIGdyb3d0aFJhdGVzLmZvckVhY2goZnVuY3Rpb24ocmF0ZSkge1xuICogICBzdGFydGluZ1ZhbHVlICo9IHJhdGU7XG4gKiB9KTtcbiAqIGF2ZXJhZ2VHcm93dGhSYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhdGUpIHtcbiAqICAgc3RhcnRpbmdWYWx1ZU1lYW4gKj0gcmF0ZTtcbiAqIH0pO1xuICogc3RhcnRpbmdWYWx1ZU1lYW4gPT09IHN0YXJ0aW5nVmFsdWU7XG4gKi9cbmZ1bmN0aW9uIGdlb21ldHJpY01lYW4oeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyaWNNZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIC8vIHRoZSBzdGFydGluZyB2YWx1ZS5cbiAgICB2YXIgdmFsdWUgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBnZW9tZXRyaWMgbWVhbiBpcyBvbmx5IHZhbGlkIGZvciBwb3NpdGl2ZSBudW1iZXJzXG4gICAgICAgIGlmICh4W2ldIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiZ2VvbWV0cmljTWVhbiByZXF1aXJlcyBvbmx5IG5vbi1uZWdhdGl2ZSBudW1iZXJzIGFzIGlucHV0XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBlYXRlZGx5IG11bHRpcGx5IHRoZSB2YWx1ZSBieSBlYWNoIG51bWJlclxuICAgICAgICB2YWx1ZSAqPSB4W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnBvdyh2YWx1ZSwgMSAvIHgubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBUaGUgW2xvZyBhdmVyYWdlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9tZXRyaWNfbWVhbiNSZWxhdGlvbnNoaXBfd2l0aF9sb2dhcml0aG1zKVxuICogaXMgYW4gZXF1aXZhbGVudCB3YXkgb2YgY29tcHV0aW5nIHRoZSBnZW9tZXRyaWMgbWVhbiBvZiBhbiBhcnJheSBzdWl0YWJsZSBmb3IgbGFyZ2Ugb3Igc21hbGwgcHJvZHVjdHMuXG4gKlxuICogSXQncyBmb3VuZCBieSBjYWxjdWxhdGluZyB0aGUgYXZlcmFnZSBsb2dhcml0aG0gb2YgdGhlIGVsZW1lbnRzIGFuZCBleHBvbmVudGlhdGluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBnZW9tZXRyaWMgbWVhblxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGNvbnRhaW5zIGEgbmVnYXRpdmUgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGxvZ0F2ZXJhZ2UoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2dBdmVyYWdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibG9nQXZlcmFnZSByZXF1aXJlcyBvbmx5IG5vbi1uZWdhdGl2ZSBudW1iZXJzIGFzIGlucHV0XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gTWF0aC5sb2coeFtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZXhwKHZhbHVlIC8geC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRoZSBbSGFybW9uaWMgTWVhbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFybW9uaWNfbWVhbikgaXNcbiAqIGEgbWVhbiBmdW5jdGlvbiB0eXBpY2FsbHkgdXNlZCB0byBmaW5kIHRoZSBhdmVyYWdlIG9mIHJhdGVzLlxuICogVGhpcyBtZWFuIGlzIGNhbGN1bGF0ZWQgYnkgdGFraW5nIHRoZSByZWNpcHJvY2FsIG9mIHRoZSBhcml0aG1ldGljIG1lYW5cbiAqIG9mIHRoZSByZWNpcHJvY2FscyBvZiB0aGUgaW5wdXQgbnVtYmVycy5cbiAqXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBoYXJtb25pYyBtZWFuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBpcyBlbXB0eVxuICogQHRocm93cyB7RXJyb3J9IGlmIHggY29udGFpbnMgYSBuZWdhdGl2ZSBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiBoYXJtb25pY01lYW4oWzIsIDNdKS50b0ZpeGVkKDIpIC8vID0+ICcyLjQwJ1xuICovXG5mdW5jdGlvbiBoYXJtb25pY01lYW4oeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYXJtb25pY01lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIHJlY2lwcm9jYWxTdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBoYXJtb25pYyBtZWFuIGlzIG9ubHkgdmFsaWQgZm9yIHBvc2l0aXZlIG51bWJlcnNcbiAgICAgICAgaWYgKHhbaV0gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiaGFybW9uaWNNZWFuIHJlcXVpcmVzIG9ubHkgcG9zaXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjaXByb2NhbFN1bSArPSAxIC8geFtpXTtcbiAgICB9XG5cbiAgICAvLyBkaXZpZGUgbiBieSB0aGUgcmVjaXByb2NhbCBzdW1cbiAgICByZXR1cm4geC5sZW5ndGggLyByZWNpcHJvY2FsU3VtO1xufVxuXG4vKipcbiAqIFRoZSBtZWFuLCBfYWxzbyBrbm93biBhcyBhdmVyYWdlXyxcbiAqIGlzIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBvdmVyIHRoZSBudW1iZXIgb2YgdmFsdWVzLlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoZSBzaW1wbGUgbWVhbiB1c2VzIHRoZSBzdWNjZXNzaXZlIGFkZGl0aW9uIG1ldGhvZCBpbnRlcm5hbGx5XG4gKiB0byBjYWxjdWxhdGUgaXQncyByZXN1bHQuIEVycm9ycyBpbiBmbG9hdGluZy1wb2ludCBhZGRpdGlvbiBhcmVcbiAqIG5vdCBhY2NvdW50ZWQgZm9yLCBzbyBpZiBwcmVjaXNpb24gaXMgcmVxdWlyZWQsIHRoZSBzdGFuZGFyZCB7QGxpbmsgbWVhbn1cbiAqIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQHJldHVybnMge251bWJlcn0gbWVhblxuICogQGV4YW1wbGVcbiAqIG1lYW4oWzAsIDEwXSk7IC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gbWVhblNpbXBsZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYW5TaW1wbGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bVNpbXBsZSh4KSAvIHgubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBbbWVkaWFuXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lZGlhbikgaXNcbiAqIHRoZSBtaWRkbGUgbnVtYmVyIG9mIGEgbGlzdC4gVGhpcyBpcyBvZnRlbiBhIGdvb2QgaW5kaWNhdG9yIG9mICd0aGUgbWlkZGxlJ1xuICogd2hlbiB0aGVyZSBhcmUgb3V0bGllcnMgdGhhdCBza2V3IHRoZSBgbWVhbigpYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGUgbWVkaWFuIGlzbid0IG5lY2Vzc2FyaWx5IG9uZSBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIGxpc3Q6IHRoZSB2YWx1ZVxuICogY2FuIGJlIHRoZSBhdmVyYWdlIG9mIHR3byBlbGVtZW50cyBpZiB0aGUgbGlzdCBoYXMgYW4gZXZlbiBsZW5ndGhcbiAqIGFuZCB0aGUgdHdvIGNlbnRyYWwgdmFsdWVzIGFyZSBkaWZmZXJlbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzb3J0ZWQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1lZGlhbiB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIG1lZGlhblNvcnRlZChbMTAsIDIsIDUsIDEwMCwgMiwgMV0pOyAvLyA9PiA1Mi41XG4gKi9cbmZ1bmN0aW9uIG1lZGlhblNvcnRlZChzb3J0ZWQpIHtcbiAgICByZXR1cm4gcXVhbnRpbGVTb3J0ZWQoc29ydGVkLCAwLjUpO1xufVxuXG4vKipcbiAqIFdoZW4gcmVtb3ZpbmcgYSB2YWx1ZSBmcm9tIGEgbGlzdCwgb25lIGRvZXMgbm90IGhhdmUgdG8gbmVjZXNzYXJ5XG4gKiByZWNvbXB1dGUgdGhlIG1lYW4gb2YgdGhlIGxpc3QgaW4gbGluZWFyIHRpbWUuIFRoZXkgY2FuIGluc3RlYWQgdXNlXG4gKiB0aGlzIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIG5ldyBtZWFuIGJ5IHByb3ZpZGluZyB0aGUgY3VycmVudCBtZWFuLFxuICogdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbGlzdCB0aGF0IHByb2R1Y2VkIGl0IGFuZCB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICpcbiAqIEBzaW5jZSAzLjAuMFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4gY3VycmVudCBtZWFuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbmV3IG1lYW5cbiAqXG4gKiBAZXhhbXBsZVxuICogc3VidHJhY3RGcm9tTWVhbigyMC41LCA2LCA1Myk7IC8vID0+IDE0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0RnJvbU1lYW4obWVhbiwgbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gKG1lYW4gKiBuIC0gdmFsdWUpIC8gKG4gLSAxKTtcbn1cblxuLyoqXG4gKiBUaGUgUm9vdCBNZWFuIFNxdWFyZSAoUk1TKSBpc1xuICogYSBtZWFuIGZ1bmN0aW9uIHVzZWQgYXMgYSBtZWFzdXJlIG9mIHRoZSBtYWduaXR1ZGUgb2YgYSBzZXRcbiAqIG9mIG51bWJlcnMsIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgc2lnbi5cbiAqIFRoaXMgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBtZWFuIG9mIHRoZSBzcXVhcmVzIG9mIHRoZVxuICogaW5wdXQgbnVtYmVycy5cbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByb290IG1lYW4gc3F1YXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBpcyBlbXB0eVxuICogQGV4YW1wbGVcbiAqIHJvb3RNZWFuU3F1YXJlKFstMSwgMSwgLTEsIDFdKTsgLy8gPT4gMVxuICovXG5mdW5jdGlvbiByb290TWVhblNxdWFyZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJvb3RNZWFuU3F1YXJlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciBzdW1PZlNxdWFyZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW1PZlNxdWFyZXMgKz0gTWF0aC5wb3coeFtpXSwgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChzdW1PZlNxdWFyZXMgLyB4Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogVGhlYGNvZWZmaWNpZW50IG9mIHZhcmlhdGlvbmBfIGlzIHRoZSByYXRpbyBvZiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIHRvIHRoZSBtZWFuLlxuICogLi5fYGNvZWZmaWNpZW50IG9mIHZhcmlhdGlvbmA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvZWZmaWNpZW50X29mX3ZhcmlhdGlvblxuICpcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb2VmZmljaWVudCBvZiB2YXJpYXRpb25cbiAqIEBleGFtcGxlXG4gKiBjb2VmZmljaWVudE9mVmFyaWF0aW9uKFsxLCAyLCAzLCA0XSkudG9GaXhlZCgzKTsgLy8gPT4gMC41MTZcbiAqIGNvZWZmaWNpZW50T2ZWYXJpYXRpb24oWzEsIDIsIDMsIDQsIDVdKS50b0ZpeGVkKDMpOyAvLyA9PiAwLjUyN1xuICogY29lZmZpY2llbnRPZlZhcmlhdGlvbihbLTEsIDAsIDEsIDIsIDMsIDRdKS50b0ZpeGVkKDMpOyAvLyA9PiAxLjI0N1xuICovXG5mdW5jdGlvbiBjb2VmZmljaWVudE9mVmFyaWF0aW9uKHgpIHtcbiAgICByZXR1cm4gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeCkgLyBtZWFuKHgpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdG8gY29tcHV0ZSBbYSBvbmUtc2FtcGxlIHQtdGVzdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3R1ZGVudCUyN3NfdC10ZXN0I09uZS1zYW1wbGVfdC10ZXN0KSwgY29tcGFyaW5nIHRoZSBtZWFuXG4gKiBvZiBhIHNhbXBsZSB0byBhIGtub3duIHZhbHVlLCB4LlxuICpcbiAqIGluIHRoaXMgY2FzZSwgd2UncmUgdHJ5aW5nIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogcG9wdWxhdGlvbiBtZWFuIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSB0aGF0IHdlIGtub3csIHdoaWNoIGlzIGB4YFxuICogaGVyZS4gVXN1YWxseSB0aGUgcmVzdWx0cyBoZXJlIGFyZSB1c2VkIHRvIGxvb2sgdXAgYVxuICogW3AtdmFsdWVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUC12YWx1ZSksIHdoaWNoLCBmb3JcbiAqIGEgY2VydGFpbiBsZXZlbCBvZiBzaWduaWZpY2FuY2UsIHdpbGwgbGV0IHlvdSBkZXRlcm1pbmUgdGhhdCB0aGVcbiAqIG51bGwgaHlwb3RoZXNpcyBjYW4gb3IgY2Fubm90IGJlIHJlamVjdGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkVmFsdWUgZXhwZWN0ZWQgdmFsdWUgb2YgdGhlIHBvcHVsYXRpb24gbWVhblxuICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiB0VGVzdChbMSwgMiwgMywgNCwgNSwgNl0sIDMuMzg1KS50b0ZpeGVkKDIpOyAvLyA9PiAnMC4xNidcbiAqL1xuZnVuY3Rpb24gdFRlc3QoeCwgZXhwZWN0ZWRWYWx1ZSkge1xuICAgIC8vIFRoZSBtZWFuIG9mIHRoZSBzYW1wbGVcbiAgICB2YXIgc2FtcGxlTWVhbiA9IG1lYW4oeCk7XG5cbiAgICAvLyBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBzYW1wbGVcbiAgICB2YXIgc2QgPSBzdGFuZGFyZERldmlhdGlvbih4KTtcblxuICAgIC8vIFNxdWFyZSByb290IHRoZSBsZW5ndGggb2YgdGhlIHNhbXBsZVxuICAgIHZhciByb290TiA9IE1hdGguc3FydCh4Lmxlbmd0aCk7XG5cbiAgICAvLyByZXR1cm5pbmcgdGhlIHQgdmFsdWVcbiAgICByZXR1cm4gKHNhbXBsZU1lYW4gLSBleHBlY3RlZFZhbHVlKSAvIChzZCAvIHJvb3ROKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRvIGNvbXB1dGUgW3R3byBzYW1wbGUgdC10ZXN0XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0dWRlbnQnc190LXRlc3QpLlxuICogVGVzdHMgd2hldGhlciBcIm1lYW4oWCktbWVhbihZKSA9IGRpZmZlcmVuY2VcIiwgKFxuICogaW4gdGhlIG1vc3QgY29tbW9uIGNhc2UsIHdlIG9mdGVuIGhhdmUgYGRpZmZlcmVuY2UgPT0gMGAgdG8gdGVzdCBpZiB0d28gc2FtcGxlc1xuICogYXJlIGxpa2VseSB0byBiZSB0YWtlbiBmcm9tIHBvcHVsYXRpb25zIHdpdGggdGhlIHNhbWUgbWVhbiB2YWx1ZSkgd2l0aFxuICogbm8gcHJpb3Iga25vd2xlZGdlIG9uIHN0YW5kYXJkIGRldmlhdGlvbnMgb2YgYm90aCBzYW1wbGVzXG4gKiBvdGhlciB0aGFuIHRoZSBmYWN0IHRoYXQgdGhleSBoYXZlIHRoZSBzYW1lIHN0YW5kYXJkIGRldmlhdGlvbi5cbiAqXG4gKiBVc3VhbGx5IHRoZSByZXN1bHRzIGhlcmUgYXJlIHVzZWQgdG8gbG9vayB1cCBhXG4gKiBbcC12YWx1ZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QLXZhbHVlKSwgd2hpY2gsIGZvclxuICogYSBjZXJ0YWluIGxldmVsIG9mIHNpZ25pZmljYW5jZSwgd2lsbCBsZXQgeW91IGRldGVybWluZSB0aGF0IHRoZVxuICogbnVsbCBoeXBvdGhlc2lzIGNhbiBvciBjYW5ub3QgYmUgcmVqZWN0ZWQuXG4gKlxuICogYGRpZmZgIGNhbiBiZSBvbWl0dGVkIGlmIGl0IGVxdWFscyAwLlxuICpcbiAqIFtUaGlzIGlzIHVzZWQgdG8gcmVqZWN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeGNsdXNpb25fb2ZfdGhlX251bGxfaHlwb3RoZXNpcylcbiAqIGEgbnVsbCBoeXBvdGhlc2lzIHRoYXQgdGhlIHR3byBwb3B1bGF0aW9ucyB0aGF0IGhhdmUgYmVlbiBzYW1wbGVkIGludG9cbiAqIGBzYW1wbGVYYCBhbmQgYHNhbXBsZVlgIGFyZSBlcXVhbCB0byBlYWNoIG90aGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWCBhIHNhbXBsZSBhcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVkgYSBzYW1wbGUgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtkaWZmZXJlbmNlPTBdXG4gKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9IHRlc3QgcmVzdWx0XG4gKlxuICogQGV4YW1wbGVcbiAqIHRUZXN0VHdvU2FtcGxlKFsxLCAyLCAzLCA0XSwgWzMsIDQsIDUsIDZdLCAwKTsgLy8gPT4gLTIuMTkwODkwMjMwMDIwNjY0M1xuICovXG5mdW5jdGlvbiB0VGVzdFR3b1NhbXBsZShzYW1wbGVYLCBzYW1wbGVZLCBkaWZmZXJlbmNlKSB7XG4gICAgdmFyIG4gPSBzYW1wbGVYLmxlbmd0aDtcbiAgICB2YXIgbSA9IHNhbXBsZVkubGVuZ3RoO1xuXG4gICAgLy8gSWYgZWl0aGVyIHNhbXBsZSBkb2Vzbid0IGFjdHVhbGx5IGhhdmUgYW55IHZhbHVlcywgd2UgY2FuJ3RcbiAgICAvLyBjb21wdXRlIHRoaXMgYXQgYWxsLCBzbyB3ZSByZXR1cm4gYG51bGxgLlxuICAgIGlmICghbiB8fCAhbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IGRpZmZlcmVuY2UgKG11KSBpcyB6ZXJvXG4gICAgaWYgKCFkaWZmZXJlbmNlKSB7XG4gICAgICAgIGRpZmZlcmVuY2UgPSAwO1xuICAgIH1cblxuICAgIHZhciBtZWFuWCA9IG1lYW4oc2FtcGxlWCk7XG4gICAgdmFyIG1lYW5ZID0gbWVhbihzYW1wbGVZKTtcbiAgICB2YXIgc2FtcGxlVmFyaWFuY2VYID0gc2FtcGxlVmFyaWFuY2Uoc2FtcGxlWCk7XG4gICAgdmFyIHNhbXBsZVZhcmlhbmNlWSA9IHNhbXBsZVZhcmlhbmNlKHNhbXBsZVkpO1xuXG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgbWVhblggPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIG1lYW5ZID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBzYW1wbGVWYXJpYW5jZVggPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIHNhbXBsZVZhcmlhbmNlWSA9PT0gXCJudW1iZXJcIlxuICAgICkge1xuICAgICAgICB2YXIgd2VpZ2h0ZWRWYXJpYW5jZSA9XG4gICAgICAgICAgICAoKG4gLSAxKSAqIHNhbXBsZVZhcmlhbmNlWCArIChtIC0gMSkgKiBzYW1wbGVWYXJpYW5jZVkpIC9cbiAgICAgICAgICAgIChuICsgbSAtIDIpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobWVhblggLSBtZWFuWSAtIGRpZmZlcmVuY2UpIC9cbiAgICAgICAgICAgIE1hdGguc3FydCh3ZWlnaHRlZFZhcmlhbmNlICogKDEgLyBuICsgMSAvIG0pKVxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIFdpbGNveG9uIHJhbmsgc3VtIHN0YXRpc3RpYyBmb3IgdGhlIGZpcnN0IHNhbXBsZVxuICogd2l0aCByZXNwZWN0IHRvIHRoZSBzZWNvbmQuIFRoZSBXaWxjb3hvbiByYW5rIHN1bSB0ZXN0IGlzIGEgbm9uLXBhcmFtZXRyaWNcbiAqIGFsdGVybmF0aXZlIHRvIHRoZSB0LXRlc3Qgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGVcbiAqIFtNYW5uLVdoaXRuZXkgVSB0ZXN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYW5uJUUyJTgwJTkzV2hpdG5leV9VX3Rlc3QpLlxuICogVGhlIHN0YXRpc3RpYyBpcyBjYWxjdWxhdGVkIGJ5IHBvb2xpbmcgYWxsIHRoZSBvYnNlcnZhdGlvbnMgdG9nZXRoZXIsIHJhbmtpbmcgdGhlbSxcbiAqIGFuZCB0aGVuIHN1bW1pbmcgdGhlIHJhbmtzIGFzc29jaWF0ZWQgd2l0aCBvbmUgb2YgdGhlIHNhbXBsZXMuIElmIHRoaXMgcmFuayBzdW0gaXNcbiAqIHN1ZmZpY2llbnRseSBsYXJnZSBvciBzbWFsbCB3ZSByZWplY3QgdGhlIGh5cG90aGVzaXMgdGhhdCB0aGUgdHdvIHNhbXBsZXMgY29tZVxuICogZnJvbSB0aGUgc2FtZSBkaXN0cmlidXRpb24gaW4gZmF2b3Igb2YgdGhlIGFsdGVybmF0aXZlIHRoYXQgb25lIGlzIHNoaWZ0ZWQgd2l0aFxuICogcmVzcGVjdCB0byB0aGUgb3RoZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzYW1wbGVYIGEgc2FtcGxlIGFzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWSBhIHNhbXBsZSBhcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByYW5rIHN1bSBmb3Igc2FtcGxlWFxuICpcbiAqIEBleGFtcGxlXG4gKiB3aWxjb3hvblJhbmtTdW0oWzEsIDQsIDhdLCBbOSwgMTIsIDE1XSk7IC8vID0+IDZcbiAqL1xuZnVuY3Rpb24gd2lsY294b25SYW5rU3VtKHNhbXBsZVgsIHNhbXBsZVkpIHtcbiAgICBpZiAoIXNhbXBsZVgubGVuZ3RoIHx8ICFzYW1wbGVZLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWl0aGVyIHNhbXBsZSBjYW4gYmUgZW1wdHlcIik7XG4gICAgfVxuXG4gICAgdmFyIHBvb2xlZFNhbXBsZXMgPSBzYW1wbGVYXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICh7IGxhYmVsOiBcInhcIiwgdmFsdWU6IHggfSk7IH0pXG4gICAgICAgIC5jb25jYXQoc2FtcGxlWS5tYXAoZnVuY3Rpb24gKHkpIHsgcmV0dXJuICh7IGxhYmVsOiBcInlcIiwgdmFsdWU6IHkgfSk7IH0pKVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7IH0pO1xuXG4gICAgZm9yICh2YXIgcmFuayA9IDA7IHJhbmsgPCBwb29sZWRTYW1wbGVzLmxlbmd0aDsgcmFuaysrKSB7XG4gICAgICAgIHBvb2xlZFNhbXBsZXNbcmFua10ucmFuayA9IHJhbms7XG4gICAgfVxuXG4gICAgdmFyIHRpZWRSYW5rcyA9IFtwb29sZWRTYW1wbGVzWzBdLnJhbmtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9vbGVkU2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9vbGVkU2FtcGxlc1tpXS52YWx1ZSA9PT0gcG9vbGVkU2FtcGxlc1tpIC0gMV0udmFsdWUpIHtcbiAgICAgICAgICAgIHRpZWRSYW5rcy5wdXNoKHBvb2xlZFNhbXBsZXNbaV0ucmFuayk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gcG9vbGVkU2FtcGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVJhbmtzSW5QbGFjZShwb29sZWRTYW1wbGVzLCB0aWVkUmFua3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRpZWRSYW5rcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXBsYWNlUmFua3NJblBsYWNlKHBvb2xlZFNhbXBsZXMsIHRpZWRSYW5rcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWVkUmFua3MgPSBbcG9vbGVkU2FtcGxlc1tpXS5yYW5rXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VSYW5rc0luUGxhY2UocG9vbGVkU2FtcGxlcywgdGllZFJhbmtzKSB7XG4gICAgICAgIHZhciBhdmVyYWdlID0gKHRpZWRSYW5rc1swXSArIHRpZWRSYW5rc1t0aWVkUmFua3MubGVuZ3RoIC0gMV0pIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWVkUmFua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvb2xlZFNhbXBsZXNbdGllZFJhbmtzW2ldXS5yYW5rID0gYXZlcmFnZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByYW5rU3VtID0gMDtcblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvb2xlZFNhbXBsZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgc2FtcGxlID0gcG9vbGVkU2FtcGxlc1tpJDFdO1xuICAgICAgICBpZiAoc2FtcGxlLmxhYmVsID09PSBcInhcIikge1xuICAgICAgICAgICAgcmFua1N1bSArPSBzYW1wbGUucmFuayArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmFua1N1bTtcbn1cblxuLyoqXG4gKiBbQmF5ZXNpYW4gQ2xhc3NpZmllcl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OYWl2ZV9CYXllc19jbGFzc2lmaWVyKVxuICpcbiAqIFRoaXMgaXMgYSBuYcOvdmUgYmF5ZXNpYW4gY2xhc3NpZmllciB0aGF0IHRha2VzXG4gKiBzaW5nbHktbmVzdGVkIG9iamVjdHMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXhhbXBsZVxuICogdmFyIGJheWVzID0gbmV3IEJheWVzaWFuQ2xhc3NpZmllcigpO1xuICogYmF5ZXMudHJhaW4oe1xuICogICBzcGVjaWVzOiAnQ2F0J1xuICogfSwgJ2FuaW1hbCcpO1xuICogdmFyIHJlc3VsdCA9IGJheWVzLnNjb3JlKHtcbiAqICAgc3BlY2llczogJ0NhdCdcbiAqIH0pXG4gKiAvLyByZXN1bHRcbiAqIC8vIHtcbiAqIC8vICAgYW5pbWFsOiAxXG4gKiAvLyB9XG4gKi9cbnZhciBCYXllc2lhbkNsYXNzaWZpZXIgPSBmdW5jdGlvbiBCYXllc2lhbkNsYXNzaWZpZXIoKSB7XG4gICAgLy8gVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGFyZSBjdXJyZW50bHlcbiAgICAvLyBjbGFzc2lmaWVkIGluIHRoZSBtb2RlbFxuICAgIHRoaXMudG90YWxDb3VudCA9IDA7XG4gICAgLy8gRXZlcnkgaXRlbSBjbGFzc2lmaWVkIGluIHRoZSBtb2RlbFxuICAgIHRoaXMuZGF0YSA9IHt9O1xufTtcblxuLyoqXG4gKiBUcmFpbiB0aGUgY2xhc3NpZmllciB3aXRoIGEgbmV3IGl0ZW0sIHdoaWNoIGhhcyBhIHNpbmdsZVxuICogZGltZW5zaW9uIG9mIEphdmFzY3JpcHQgbGl0ZXJhbCBrZXlzIGFuZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gYW4gb2JqZWN0IHdpdGggc2luZ2x5LWRlZXAgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IHRoZSBjYXRlZ29yeSB0aGlzIGl0ZW0gYmVsb25ncyB0b1xuICogQHJldHVybiB7dW5kZWZpbmVkfSBhZGRzIHRoZSBpdGVtIHRvIHRoZSBjbGFzc2lmaWVyXG4gKi9cbkJheWVzaWFuQ2xhc3NpZmllci5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiB0cmFpbiAoaXRlbSwgY2F0ZWdvcnkpIHtcbiAgICAvLyBJZiB0aGUgZGF0YSBvYmplY3QgZG9lc24ndCBoYXZlIGFueSB2YWx1ZXNcbiAgICAvLyBmb3IgdGhpcyBjYXRlZ29yeSwgY3JlYXRlIGEgbmV3IG9iamVjdCBmb3IgaXQuXG4gICAgaWYgKCF0aGlzLmRhdGFbY2F0ZWdvcnldKSB7XG4gICAgICAgIHRoaXMuZGF0YVtjYXRlZ29yeV0gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBrZXkgaW4gdGhlIGl0ZW0uXG4gICAgZm9yICh2YXIgayBpbiBpdGVtKSB7XG4gICAgICAgIHZhciB2ID0gaXRlbVtrXTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbmVzdGVkIG9iamVjdCBgZGF0YVtjYXRlZ29yeV1ba11baXRlbVtrXV1gXG4gICAgICAgIC8vIHdpdGggYW4gb2JqZWN0IG9mIGtleXMgdGhhdCBlcXVhbCAwLlxuICAgICAgICBpZiAodGhpcy5kYXRhW2NhdGVnb3J5XVtrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbY2F0ZWdvcnldW2tdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YVtjYXRlZ29yeV1ba11bdl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2NhdGVnb3J5XVtrXVt2XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmQgaW5jcmVtZW50IHRoZSBrZXkgZm9yIHRoaXMga2V5L3ZhbHVlIGNvbWJpbmF0aW9uLlxuICAgICAgICB0aGlzLmRhdGFbY2F0ZWdvcnldW2tdW3ZdKys7XG4gICAgfVxuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgaXRlbXMgY2xhc3NpZmllZFxuICAgIHRoaXMudG90YWxDb3VudCsrO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNjb3JlIG9mIGhvdyB3ZWxsIHRoaXMgaXRlbSBtYXRjaGVzIGFsbFxuICogcG9zc2libGUgY2F0ZWdvcmllcyBiYXNlZCBvbiBpdHMgYXR0cmlidXRlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIGFuIGl0ZW0gaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHdpdGggdHJhaW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9mIHByb2JhYmlsaXRpZXMgdGhhdCB0aGlzIGl0ZW0gYmVsb25ncyB0byBhXG4gKiBnaXZlbiBjYXRlZ29yeS5cbiAqL1xuQmF5ZXNpYW5DbGFzc2lmaWVyLnByb3RvdHlwZS5zY29yZSA9IGZ1bmN0aW9uIHNjb3JlIChpdGVtKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhbiBlbXB0eSBhcnJheSBvZiBvZGRzIHBlciBjYXRlZ29yeS5cbiAgICB2YXIgb2RkcyA9IHt9O1xuICAgIHZhciBjYXRlZ29yeTtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBrZXkgaW4gdGhlIGl0ZW0sXG4gICAgLy8gdGhlbiBpdGVyYXRlIHRocm91Z2ggZWFjaCBjYXRlZ29yeSB0aGF0IGhhcyBiZWVuIHVzZWRcbiAgICAvLyBpbiBwcmV2aW91cyBjYWxscyB0byBgLnRyYWluKClgXG4gICAgZm9yICh2YXIgayBpbiBpdGVtKSB7XG4gICAgICAgIHZhciB2ID0gaXRlbVtrXTtcbiAgICAgICAgZm9yIChjYXRlZ29yeSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBvYmplY3QgZm9yIHN0b3Jpbmcga2V5IC0gdmFsdWUgY29tYmluYXRpb25zXG4gICAgICAgICAgICAvLyBmb3IgdGhpcyBjYXRlZ29yeS5cbiAgICAgICAgICAgIG9kZHNbY2F0ZWdvcnldID0ge307XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXRlbSBkb2Vzbid0IGV2ZW4gaGF2ZSBhIHByb3BlcnR5LCBpdCBjb3VudHMgZm9yIG5vdGhpbmcsXG4gICAgICAgICAgICAvLyBidXQgaWYgaXQgZG9lcyBoYXZlIHRoZSBwcm9wZXJ0eSB0aGF0IHdlJ3JlIGxvb2tpbmcgZm9yIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSBpdGVtIHRvIGNhdGVnb3JpemUsIGl0IGNvdW50cyBiYXNlZCBvbiBob3cgcG9wdWxhciBpdCBpc1xuICAgICAgICAgICAgLy8gdmVyc3VzIHRoZSB3aG9sZSBwb3B1bGF0aW9uLlxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtjYXRlZ29yeV1ba10pIHtcbiAgICAgICAgICAgICAgICBvZGRzW2NhdGVnb3J5XVtrICsgXCJfXCIgKyB2XSA9XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmRhdGFbY2F0ZWdvcnldW2tdW3ZdIHx8IDApIC8gdGhpcy50b3RhbENvdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZGRzW2NhdGVnb3J5XVtrICsgXCJfXCIgKyB2XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgYSBuZXcgb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIHN1bXMgb2YgdGhlc2Ugb2RkcyBieSBjYXRlZ29yeVxuICAgIHZhciBvZGRzU3VtcyA9IHt9O1xuXG4gICAgZm9yIChjYXRlZ29yeSBpbiBvZGRzKSB7XG4gICAgICAgIC8vIFRhbGx5IGFsbCBvZiB0aGUgb2RkcyBmb3IgZWFjaCBjYXRlZ29yeS1jb21iaW5hdGlvbiBwYWlyIC1cbiAgICAgICAgLy8gdGhlIG5vbi1leGlzdGVuY2Ugb2YgYSBjYXRlZ29yeSBkb2VzIG5vdCBhZGQgYW55dGhpbmcgdG8gdGhlXG4gICAgICAgIC8vIHNjb3JlLlxuICAgICAgICBvZGRzU3Vtc1tjYXRlZ29yeV0gPSAwO1xuICAgICAgICBmb3IgKHZhciBjb21iaW5hdGlvbiBpbiBvZGRzW2NhdGVnb3J5XSkge1xuICAgICAgICAgICAgb2Rkc1N1bXNbY2F0ZWdvcnldICs9IG9kZHNbY2F0ZWdvcnldW2NvbWJpbmF0aW9uXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZGRzU3Vtcztcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIHNpbmdsZS1sYXllciBbUGVyY2VwdHJvbiBDbGFzc2lmaWVyXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcmNlcHRyb24pIHRoYXQgdGFrZXNcbiAqIGFycmF5cyBvZiBudW1iZXJzIGFuZCBwcmVkaWN0cyB3aGV0aGVyIHRoZXkgc2hvdWxkIGJlIGNsYXNzaWZpZWRcbiAqIGFzIGVpdGhlciAwIG9yIDEgKG5lZ2F0aXZlIG9yIHBvc2l0aXZlIGV4YW1wbGVzKS5cbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSB0aGUgbW9kZWxcbiAqIHZhciBwID0gbmV3IFBlcmNlcHRyb25Nb2RlbCgpO1xuICogLy8gVHJhaW4gdGhlIG1vZGVsIHdpdGggaW5wdXQgd2l0aCBhIGRpYWdvbmFsIGJvdW5kYXJ5LlxuICogZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAqICAgICBwLnRyYWluKFsxLCAxXSwgMSk7XG4gKiAgICAgcC50cmFpbihbMCwgMV0sIDApO1xuICogICAgIHAudHJhaW4oWzEsIDBdLCAwKTtcbiAqICAgICBwLnRyYWluKFswLCAwXSwgMCk7XG4gKiB9XG4gKiBwLnByZWRpY3QoWzAsIDBdKTsgLy8gMFxuICogcC5wcmVkaWN0KFswLCAxXSk7IC8vIDBcbiAqIHAucHJlZGljdChbMSwgMF0pOyAvLyAwXG4gKiBwLnByZWRpY3QoWzEsIDFdKTsgLy8gMVxuICovXG52YXIgUGVyY2VwdHJvbk1vZGVsID0gZnVuY3Rpb24gUGVyY2VwdHJvbk1vZGVsKCkge1xuICAgIC8vIFRoZSB3ZWlnaHRzLCBvciBjb2VmZmljaWVudHMgb2YgdGhlIG1vZGVsO1xuICAgIC8vIHdlaWdodHMgYXJlIG9ubHkgcG9wdWxhdGVkIHdoZW4gdHJhaW5pbmcgd2l0aCBkYXRhLlxuICAgIHRoaXMud2VpZ2h0cyA9IFtdO1xuICAgIC8vIFRoZSBiaWFzIHRlcm0sIG9yIGludGVyY2VwdDsgaXQgaXMgYWxzbyBhIHdlaWdodCBidXRcbiAgICAvLyBpdCdzIHN0b3JlZCBzZXBhcmF0ZWx5IGZvciBjb252ZW5pZW5jZSBhcyBpdCBpcyBhbHdheXNcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IG9uZS5cbiAgICB0aGlzLmJpYXMgPSAwO1xufTtcbi8qKlxuICogKipQcmVkaWN0Kio6IFVzZSBhbiBhcnJheSBvZiBmZWF0dXJlcyB3aXRoIHRoZSB3ZWlnaHQgYXJyYXkgYW5kIGJpYXNcbiAqIHRvIHByZWRpY3Qgd2hldGhlciBhbiBleGFtcGxlIGlzIGxhYmVsZWQgMCBvciAxLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmVhdHVyZXMgYW4gYXJyYXkgb2YgZmVhdHVyZXMgYXMgbnVtYmVyc1xuICogQHJldHVybnMge251bWJlcn0gMSBpZiB0aGUgc2NvcmUgaXMgb3ZlciAwLCBvdGhlcndpc2UgMFxuICovXG5QZXJjZXB0cm9uTW9kZWwucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiBwcmVkaWN0IChmZWF0dXJlcykge1xuICAgIC8vIE9ubHkgcHJlZGljdCBpZiBwcmV2aW91c2x5IHRyYWluZWRcbiAgICAvLyBvbiB0aGUgc2FtZSBzaXplIGZlYXR1cmUgYXJyYXkocykuXG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCAhPT0gdGhpcy53ZWlnaHRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHN1bSBvZiBmZWF0dXJlcyB0aW1lcyB3ZWlnaHRzLFxuICAgIC8vIHdpdGggdGhlIGJpYXMgYWRkZWQgKGltcGxpY2l0bHkgdGltZXMgb25lKS5cbiAgICB2YXIgc2NvcmUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNjb3JlICs9IHRoaXMud2VpZ2h0c1tpXSAqIGZlYXR1cmVzW2ldO1xuICAgIH1cbiAgICBzY29yZSArPSB0aGlzLmJpYXM7XG5cbiAgICAvLyBDbGFzc2lmeSBhcyAxIGlmIHRoZSBzY29yZSBpcyBvdmVyIDAsIG90aGVyd2lzZSAwLlxuICAgIGlmIChzY29yZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiAqKlRyYWluKiogdGhlIGNsYXNzaWZpZXIgd2l0aCBhIG5ldyBleGFtcGxlLCB3aGljaCBpc1xuICogYSBudW1lcmljIGFycmF5IG9mIGZlYXR1cmVzIGFuZCBhIDAgb3IgMSBsYWJlbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVzIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFzIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbCBlaXRoZXIgMCBvciAxXG4gKiBAcmV0dXJucyB7UGVyY2VwdHJvbk1vZGVsfSB0aGlzXG4gKi9cblBlcmNlcHRyb25Nb2RlbC5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiB0cmFpbiAoZmVhdHVyZXMsIGxhYmVsKSB7XG4gICAgLy8gUmVxdWlyZSB0aGF0IG9ubHkgbGFiZWxzIG9mIDAgb3IgMSBhcmUgY29uc2lkZXJlZC5cbiAgICBpZiAobGFiZWwgIT09IDAgJiYgbGFiZWwgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZSBsZW5ndGggb2YgdGhlIGZlYXR1cmUgYXJyYXkgZGV0ZXJtaW5lc1xuICAgIC8vIHRoZSBsZW5ndGggb2YgdGhlIHdlaWdodCBhcnJheS5cbiAgICAvLyBUaGUgcGVyY2VwdHJvbiB3aWxsIGNvbnRpbnVlIGxlYXJuaW5nIGFzIGxvbmcgYXNcbiAgICAvLyBpdCBrZWVwcyBzZWVpbmcgZmVhdHVyZSBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoLlxuICAgIC8vIFdoZW4gaXQgc2VlcyBhIG5ldyBkYXRhIHNoYXBlLCBpdCBpbml0aWFsaXplcy5cbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoICE9PSB0aGlzLndlaWdodHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IGZlYXR1cmVzO1xuICAgICAgICB0aGlzLmJpYXMgPSAxO1xuICAgIH1cbiAgICAvLyBNYWtlIGEgcHJlZGljdGlvbiBiYXNlZCBvbiBjdXJyZW50IHdlaWdodHMuXG4gICAgdmFyIHByZWRpY3Rpb24gPSB0aGlzLnByZWRpY3QoZmVhdHVyZXMpO1xuICAgIC8vIFVwZGF0ZSB0aGUgd2VpZ2h0cyBpZiB0aGUgcHJlZGljdGlvbiBpcyB3cm9uZy5cbiAgICBpZiAodHlwZW9mIHByZWRpY3Rpb24gPT09IFwibnVtYmVyXCIgJiYgcHJlZGljdGlvbiAhPT0gbGFiZWwpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gbGFiZWwgLSBwcmVkaWN0aW9uO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRzW2ldICs9IGdyYWRpZW50ICogZmVhdHVyZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaWFzICs9IGdyYWRpZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2UgdXNlIGDOtWAsIGVwc2lsb24sIGFzIGEgc3RvcHBpbmcgY3JpdGVyaW9uIHdoZW4gd2Ugd2FudCB0byBpdGVyYXRlXG4gKiB1bnRpbCB3ZSdyZSBcImNsb3NlIGVub3VnaFwiLiBFcHNpbG9uIGlzIGEgdmVyeSBzbWFsbCBudW1iZXI6IGZvclxuICogc2ltcGxlIHN0YXRpc3RpY3MsIHRoYXQgbnVtYmVyIGlzICoqMC4wMDAxKipcbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW4gY2FsY3VsYXRpb25zIGxpa2UgdGhlIGJpbm9taWFsRGlzdHJpYnV0aW9uLCBpbiB3aGljaFxuICogdGhlIHByb2Nlc3Mgb2YgZmluZGluZyBhIHZhbHVlIGlzIFtpdGVyYXRpdmVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0l0ZXJhdGl2ZV9tZXRob2QpOlxuICogaXQgcHJvZ3Jlc3NlcyB1bnRpbCBpdCBpcyBjbG9zZSBlbm91Z2guXG4gKlxuICogQmVsb3cgaXMgYW4gZXhhbXBsZSBvZiB1c2luZyBlcHNpbG9uIGluIFtncmFkaWVudCBkZXNjZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmFkaWVudF9kZXNjZW50KSxcbiAqIHdoZXJlIHdlJ3JlIHRyeWluZyB0byBmaW5kIGEgbG9jYWwgbWluaW11bSBvZiBhIGZ1bmN0aW9uJ3MgZGVyaXZhdGl2ZSxcbiAqIGdpdmVuIGJ5IHRoZSBgZkRlcml2YXRpdmVgIG1ldGhvZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRnJvbSBjYWxjdWxhdGlvbiwgd2UgZXhwZWN0IHRoYXQgdGhlIGxvY2FsIG1pbmltdW0gb2NjdXJzIGF0IHg9OS80XG4gKiB2YXIgeF9vbGQgPSAwO1xuICogLy8gVGhlIGFsZ29yaXRobSBzdGFydHMgYXQgeD02XG4gKiB2YXIgeF9uZXcgPSA2O1xuICogdmFyIHN0ZXBTaXplID0gMC4wMTtcbiAqXG4gKiBmdW5jdGlvbiBmRGVyaXZhdGl2ZSh4KSB7XG4gKiAgIHJldHVybiA0ICogTWF0aC5wb3coeCwgMykgLSA5ICogTWF0aC5wb3coeCwgMik7XG4gKiB9XG4gKlxuICogLy8gVGhlIGxvb3AgcnVucyB1bnRpbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwcmV2aW91c1xuICogLy8gdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIHNtYWxsZXIgdGhhbiBlcHNpbG9uIC0gYSByb3VnaFxuICogLy8gbWVhdXJlIG9mICdjbG9zZSBlbm91Z2gnXG4gKiB3aGlsZSAoTWF0aC5hYnMoeF9uZXcgLSB4X29sZCkgPiBzcy5lcHNpbG9uKSB7XG4gKiAgIHhfb2xkID0geF9uZXc7XG4gKiAgIHhfbmV3ID0geF9vbGQgLSBzdGVwU2l6ZSAqIGZEZXJpdmF0aXZlKHhfb2xkKTtcbiAqIH1cbiAqXG4gKiBjb25zb2xlLmxvZygnTG9jYWwgbWluaW11bSBvY2N1cnMgYXQnLCB4X25ldyk7XG4gKi9cbnZhciBlcHNpbG9uID0gMC4wMDAxO1xuXG4vKipcbiAqIEEgW0ZhY3RvcmlhbF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmFjdG9yaWFsKSwgdXN1YWxseSB3cml0dGVuIG4hLCBpcyB0aGUgcHJvZHVjdCBvZiBhbGwgcG9zaXRpdmVcbiAqIGludGVnZXJzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBuLiBPZnRlbiBmYWN0b3JpYWwgaXMgaW1wbGVtZW50ZWRcbiAqIHJlY3Vyc2l2ZWx5LCBidXQgdGhpcyBpdGVyYXRpdmUgYXBwcm9hY2ggaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXJcbiAqIGFuZCBzaW1wbGVyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIGlucHV0LCBtdXN0IGJlIGFuIGludGVnZXIgbnVtYmVyIDEgb3IgZ3JlYXRlclxuICogQHJldHVybnMge251bWJlcn0gZmFjdG9yaWFsOiBuIVxuICogQHRocm93cyB7RXJyb3J9IGlmIG4gaXMgbGVzcyB0aGFuIDAgb3Igbm90IGFuIGludGVnZXJcbiAqIEBleGFtcGxlXG4gKiBmYWN0b3JpYWwoNSk7IC8vID0+IDEyMFxuICovXG5mdW5jdGlvbiBmYWN0b3JpYWwobikge1xuICAgIC8vIGZhY3RvcmlhbCBpcyBtYXRoZW1hdGljYWxseSB1bmRlZmluZWQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcbiAgICBpZiAobiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFjdG9yaWFsIHJlcXVpcmVzIGEgbm9uLW5lZ2F0aXZlIHZhbHVlXCIpO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmZsb29yKG4pICE9PSBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhY3RvcmlhbCByZXF1aXJlcyBhbiBpbnRlZ2VyIGlucHV0XCIpO1xuICAgIH1cblxuICAgIC8vIHR5cGljYWxseSB5b3UnbGwgZXhwYW5kIHRoZSBmYWN0b3JpYWwgZnVuY3Rpb24gZ29pbmcgZG93biwgbGlrZVxuICAgIC8vIDUhID0gNSAqIDQgKiAzICogMiAqIDEuIFRoaXMgaXMgZ29pbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbixcbiAgICAvLyBjb3VudGluZyBmcm9tIDIgdXAgdG8gdGhlIG51bWJlciBpbiBxdWVzdGlvbiwgYW5kIHNpbmNlIGFueXRoaW5nXG4gICAgLy8gbXVsdGlwbGllZCBieSAxIGlzIGl0c2VsZiwgdGhlIGxvb3Agb25seSBuZWVkcyB0byBzdGFydCBhdCAyLlxuICAgIHZhciBhY2N1bXVsYXRvciA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIC8vIGZvciBlYWNoIG51bWJlciB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBudW1iZXIgYG5gLCBtdWx0aXBseVxuICAgICAgICAvLyB0aGUgYWNjdW11bGF0b3IgbXkgdGhhdCBudW1iZXIuXG4gICAgICAgIGFjY3VtdWxhdG9yICo9IGk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBbZ2FtbWEgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhbW1hX2Z1bmN0aW9uKSBvZiBhIHZhbHVlIHVzaW5nIE5lbWVzJyBhcHByb3hpbWF0aW9uLlxuICogVGhlIGdhbW1hIG9mIG4gaXMgZXF1aXZhbGVudCB0byAobi0xKSEsIGJ1dCB1bmxpa2UgdGhlIGZhY3RvcmlhbCBmdW5jdGlvbiwgZ2FtbWEgaXMgZGVmaW5lZCBmb3IgYWxsIHJlYWwgbiBleGNlcHQgemVyb1xuICogYW5kIG5lZ2F0aXZlIGludGVnZXJzICh3aGVyZSBOYU4gaXMgcmV0dXJuZWQpLiBOb3RlLCB0aGUgZ2FtbWEgZnVuY3Rpb24gaXMgYWxzbyB3ZWxsLWRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVycyxcbiAqIHRob3VnaCB0aGlzIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBkb2VzIG5vdCBoYW5kbGUgY29tcGxleCBudW1iZXJzIGFzIGlucHV0IHZhbHVlcy5cbiAqIE5lbWVzJyBhcHByb3hpbWF0aW9uIGlzIGRlZmluZWQgW2hlcmVdKGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xMDAzLjYwMjApIGFzIFRoZW9yZW0gMi4yLlxuICogTmVnYXRpdmUgdmFsdWVzIHVzZSBbRXVsZXIncyByZWZsZWN0aW9uIGZvcm11bGFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhbW1hX2Z1bmN0aW9uI1Byb3BlcnRpZXMpIGZvciBjb21wdXRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBBbnkgcmVhbCBudW1iZXIgZXhjZXB0IGZvciB6ZXJvIGFuZCBuZWdhdGl2ZSBpbnRlZ2Vycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBnYW1tYSBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGdhbW1hKDExLjUpOyAvLyAxMTg5OTQyMy4wODQwMzcwMzhcbiAqIGdhbW1hKC0xMS41KTsgLy8gMi4yOTU3NTgxMDQ4MTYwOWUtOFxuICogZ2FtbWEoNSk7IC8vIDI0XG4gKi9cbmZ1bmN0aW9uIGdhbW1hKG4pIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgICAvLyBnYW1tYSBub3QgZGVmaW5lZCBmb3IgemVybyBvciBuZWdhdGl2ZSBpbnRlZ2Vyc1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2UgZmFjdG9yaWFsIGZvciBpbnRlZ2VyIGlucHV0c1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcmlhbChuIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWNyZW1lbnQgbiwgYmVjYXVzZSBhcHByb3hpbWF0aW9uIGlzIGRlZmluZWQgZm9yIG4gLSAxXG4gICAgbi0tO1xuXG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIC8vIFVzZSBFdWxlcidzIHJlZmxlY3Rpb24gZm9ybXVsYSBmb3IgbmVnYXRpdmUgaW5wdXRzXG4gICAgICAgIC8vIHNlZTogIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhbW1hX2Z1bmN0aW9uI1Byb3BlcnRpZXNcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIC1uKSAqIGdhbW1hKC1uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTmVtZXMnIGV4cGFuc2lvbiBhcHByb3hpbWF0aW9uXG4gICAgICAgIHZhciBzZXJpZXNDb2VmZmljaWVudCA9XG4gICAgICAgICAgICBNYXRoLnBvdyhuIC8gTWF0aC5FLCBuKSAqIE1hdGguc3FydCgyICogTWF0aC5QSSAqIChuICsgMSAvIDYpKTtcblxuICAgICAgICB2YXIgc2VyaWVzRGVub20gPSBuICsgMSAvIDQ7XG5cbiAgICAgICAgdmFyIHNlcmllc0V4cGFuc2lvbiA9XG4gICAgICAgICAgICAxICtcbiAgICAgICAgICAgIDEgLyAxNDQgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgMikgLVxuICAgICAgICAgICAgMSAvIDEyOTYwIC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDMpIC1cbiAgICAgICAgICAgIDI1NyAvIDIwNzM2MCAvIE1hdGgucG93KHNlcmllc0Rlbm9tLCA0KSAtXG4gICAgICAgICAgICA1MiAvIDI2MTI3MzYgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNSkgK1xuICAgICAgICAgICAgNTc0MTE3MyAvIDk0MDU4NDk2MDAgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNikgK1xuICAgICAgICAgICAgMzc1MjkgLyAxODgxMTY5OTIwMCAvIE1hdGgucG93KHNlcmllc0Rlbm9tLCA3KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzQ29lZmZpY2llbnQgKiBzZXJpZXNFeHBhbnNpb247XG4gICAgfVxufVxuXG4vLyBEZWZpbmUgc2VyaWVzIGNvZWZmaWNpZW50c1xudmFyIENPRUZGSUNJRU5UUyA9IFtcbiAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLCA1Ny4xNTYyMzU2NjU4NjI5MjM1MTcsIC01OS41OTc5NjAzNTU0NzU0OTEyNDgsXG4gICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LCAtMC40OTE5MTM4MTYwOTc2MjAxOTk3OCwgMC4zMzk5NDY0OTk4NDgxMTg4ODY5OWUtNCxcbiAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LCAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLCAtMC4yMTAyNjQ0NDE3MjQxMDQ4ODMxOWUtMyxcbiAgICAwLjIxNzQzOTYxODExNTIxMjY0MzJlLTMsIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAgIDAuODQ0MTgyMjM5ODM4NTI3NDMyOTNlLTQsIC0wLjI2MTkwODM4NDAxNTgxNDA4NjdlLTQsXG4gICAgMC4zNjg5OTE4MjY1OTUzMTYyMjcwNGUtNVxuXTtcblxudmFyIGcgPSA2MDcgLyAxMjg7XG52YXIgTE9HU1FSVDJQSSA9IE1hdGgubG9nKE1hdGguc3FydCgyICogTWF0aC5QSSkpO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxvZ2FyaXRobSBvZiB0aGUgW2dhbW1hIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbikgb2YgYSB2YWx1ZSB1c2luZyBMYW5jem9zJyBhcHByb3hpbWF0aW9uLlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhcyBpbnB1dCBhbnkgcmVhbC12YWx1ZSBuIGdyZWF0ZXIgdGhhbiAwLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgZm9yIHZhbHVlcyBvZiBuIHRvbyBsYXJnZSBmb3IgdGhlIG5vcm1hbCBnYW1tYSBmdW5jdGlvbiAobiA+IDE2NSkuXG4gKiBUaGUgY29kZSBpcyBiYXNlZCBvbiBMYW5jem8ncyBHYW1tYSBhcHByb3hpbWF0aW9uLCBkZWZpbmVkIFtoZXJlXShodHRwOi8vbXkuZml0LmVkdS9+Z2FiZG8vZ2FtbWEudHh0KS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBBbnkgcmVhbCBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbG9nYXJpdGhtIG9mIGdhbW1hIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogZ2FtbWFsbig1MDApOyAvLyAyNjA1LjExNTg1MDM2MTczMzVcbiAqIGdhbW1hbG4oMi40KTsgLy8gMC4yMTY4NTkzMjI0NDg4NDA0M1xuICovXG5mdW5jdGlvbiBnYW1tYWxuKG4pIHtcbiAgICAvLyBSZXR1cm4gaW5maW5pdHkgaWYgdmFsdWUgbm90IGluIGRvbWFpblxuICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG5cbiAgICAvLyBEZWNyZW1lbnQgbiwgYmVjYXVzZSBhcHByb3hpbWF0aW9uIGlzIGRlZmluZWQgZm9yIG4gLSAxXG4gICAgbi0tO1xuXG4gICAgLy8gQ3JlYXRlIHNlcmllcyBhcHByb3hpbWF0aW9uXG4gICAgdmFyIGEgPSBDT0VGRklDSUVOVFNbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgICAgYSArPSBDT0VGRklDSUVOVFNbaV0gLyAobiArIGkpO1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBnICsgMC41ICsgbjtcblxuICAgIC8vIFJldHVybiBuYXR1cmFsIGxvZ2FyaXRobSBvZiBnYW1tYShuKVxuICAgIHJldHVybiBMT0dTUVJUMlBJICsgTWF0aC5sb2coYSkgLSB0bXAgKyAobiArIDAuNSkgKiBNYXRoLmxvZyh0bXApO1xufVxuXG4vKipcbiAqIFRoZSBbQmVybm91bGxpIGRpc3RyaWJ1dGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZXJub3VsbGlfZGlzdHJpYnV0aW9uKVxuICogaXMgdGhlIHByb2JhYmlsaXR5IGRpc2NyZXRlXG4gKiBkaXN0cmlidXRpb24gb2YgYSByYW5kb20gdmFyaWFibGUgd2hpY2ggdGFrZXMgdmFsdWUgMSB3aXRoIHN1Y2Nlc3NcbiAqIHByb2JhYmlsaXR5IGBwYCBhbmQgdmFsdWUgMCB3aXRoIGZhaWx1cmVcbiAqIHByb2JhYmlsaXR5IGBxYCA9IDEgLSBgcGAuIEl0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gcmVwcmVzZW50IHRoZVxuICogdG9zcyBvZiBhIGNvaW4sIHdoZXJlIFwiMVwiIGlzIGRlZmluZWQgdG8gbWVhbiBcImhlYWRzXCIgYW5kIFwiMFwiIGlzIGRlZmluZWRcbiAqIHRvIG1lYW4gXCJ0YWlsc1wiIChvciB2aWNlIHZlcnNhKS4gSXQgaXNcbiAqIGEgc3BlY2lhbCBjYXNlIG9mIGEgQmlub21pYWwgRGlzdHJpYnV0aW9uXG4gKiB3aGVyZSBgbmAgPSAxLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwIGlucHV0IHZhbHVlLCBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZhbHVlcyBvZiBiZXJub3VsbGkgZGlzdHJpYnV0aW9uIGF0IHRoaXMgcG9pbnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBwIGlzIG91dHNpZGUgMCBhbmQgMVxuICogQGV4YW1wbGVcbiAqIGJlcm5vdWxsaURpc3RyaWJ1dGlvbigwLjMpOyAvLyA9PiBbMC43LCAwLjNdXG4gKi9cbmZ1bmN0aW9uIGJlcm5vdWxsaURpc3RyaWJ1dGlvbihwKSAvKjogbnVtYmVyW10gKi8ge1xuICAgIC8vIENoZWNrIHRoYXQgYHBgIGlzIGEgdmFsaWQgcHJvYmFiaWxpdHkgKDAg4omkIHAg4omkIDEpXG4gICAgaWYgKHAgPCAwIHx8IHAgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiYmVybm91bGxpRGlzdHJpYnV0aW9uIHJlcXVpcmVzIHByb2JhYmlsaXR5IHRvIGJlIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmVcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBbMSAtIHAsIHBdO1xufVxuXG4vKipcbiAqIFRoZSBbQmlub21pYWwgRGlzdHJpYnV0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jpbm9taWFsX2Rpc3RyaWJ1dGlvbikgaXMgdGhlIGRpc2NyZXRlIHByb2JhYmlsaXR5XG4gKiBkaXN0cmlidXRpb24gb2YgdGhlIG51bWJlciBvZiBzdWNjZXNzZXMgaW4gYSBzZXF1ZW5jZSBvZiBuIGluZGVwZW5kZW50IHllcy9ubyBleHBlcmltZW50cywgZWFjaCBvZiB3aGljaCB5aWVsZHNcbiAqIHN1Y2Nlc3Mgd2l0aCBwcm9iYWJpbGl0eSBgcHJvYmFiaWxpdHlgLiBTdWNoIGEgc3VjY2Vzcy9mYWlsdXJlIGV4cGVyaW1lbnQgaXMgYWxzbyBjYWxsZWQgYSBCZXJub3VsbGkgZXhwZXJpbWVudCBvclxuICogQmVybm91bGxpIHRyaWFsOyB3aGVuIHRyaWFscyA9IDEsIHRoZSBCaW5vbWlhbCBEaXN0cmlidXRpb24gaXMgYSBCZXJub3VsbGkgRGlzdHJpYnV0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0cmlhbHMgbnVtYmVyIG9mIHRyaWFscyB0byBzaW11bGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHByb2JhYmlsaXR5XG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG91dHB1dFxuICovXG5mdW5jdGlvbiBiaW5vbWlhbERpc3RyaWJ1dGlvbih0cmlhbHMsIHByb2JhYmlsaXR5KSAvKjogP251bWJlcltdICovIHtcbiAgICAvLyBDaGVjayB0aGF0IGBwYCBpcyBhIHZhbGlkIHByb2JhYmlsaXR5ICgwIOKJpCBwIOKJpCAxKSxcbiAgICAvLyB0aGF0IGBuYCBpcyBhbiBpbnRlZ2VyLCBzdHJpY3RseSBwb3NpdGl2ZS5cbiAgICBpZiAocHJvYmFiaWxpdHkgPCAwIHx8IHByb2JhYmlsaXR5ID4gMSB8fCB0cmlhbHMgPD0gMCB8fCB0cmlhbHMgJSAxICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgaW5pdGlhbGl6ZSBgeGAsIHRoZSByYW5kb20gdmFyaWFibGUsIGFuZCBgYWNjdW11bGF0b3JgLCBhbiBhY2N1bXVsYXRvclxuICAgIC8vIGZvciB0aGUgY3VtdWxhdGl2ZSBkaXN0cmlidXRpb24gZnVuY3Rpb24gdG8gMC4gYGRpc3RyaWJ1dGlvbl9mdW5jdGlvbnNgXG4gICAgLy8gaXMgdGhlIG9iamVjdCB3ZSdsbCByZXR1cm4gd2l0aCB0aGUgYHByb2JhYmlsaXR5X29mX3hgIGFuZCB0aGVcbiAgICAvLyBgY3VtdWxhdGl2ZVByb2JhYmlsaXR5X29mX3hgLCBhcyB3ZWxsIGFzIHRoZSBjYWxjdWxhdGVkIG1lYW4gJlxuICAgIC8vIHZhcmlhbmNlLiBXZSBpdGVyYXRlIHVudGlsIHRoZSBgY3VtdWxhdGl2ZVByb2JhYmlsaXR5X29mX3hgIGlzXG4gICAgLy8gd2l0aGluIGBlcHNpbG9uYCBvZiAxLjAuXG4gICAgdmFyIHggPSAwO1xuICAgIHZhciBjdW11bGF0aXZlUHJvYmFiaWxpdHkgPSAwO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIHZhciBiaW5vbWlhbENvZWZmaWNpZW50ID0gMTtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGl0ZXJhdGVzIHRocm91Z2ggZWFjaCBwb3RlbnRpYWwgb3V0Y29tZSxcbiAgICAvLyB1bnRpbCB0aGUgYGN1bXVsYXRpdmVQcm9iYWJpbGl0eWAgaXMgdmVyeSBjbG9zZSB0byAxLCBhdFxuICAgIC8vIHdoaWNoIHBvaW50IHdlJ3ZlIGRlZmluZWQgdGhlIHZhc3QgbWFqb3JpdHkgb2Ygb3V0Y29tZXNcbiAgICBkbyB7XG4gICAgICAgIC8vIGEgW3Byb2JhYmlsaXR5IG1hc3MgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JhYmlsaXR5X21hc3NfZnVuY3Rpb24pXG4gICAgICAgIGNlbGxzW3hdID1cbiAgICAgICAgICAgIGJpbm9taWFsQ29lZmZpY2llbnQgKlxuICAgICAgICAgICAgTWF0aC5wb3cocHJvYmFiaWxpdHksIHgpICpcbiAgICAgICAgICAgIE1hdGgucG93KDEgLSBwcm9iYWJpbGl0eSwgdHJpYWxzIC0geCk7XG4gICAgICAgIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSArPSBjZWxsc1t4XTtcbiAgICAgICAgeCsrO1xuICAgICAgICBiaW5vbWlhbENvZWZmaWNpZW50ID0gKGJpbm9taWFsQ29lZmZpY2llbnQgKiAodHJpYWxzIC0geCArIDEpKSAvIHg7XG4gICAgICAgIC8vIHdoZW4gdGhlIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSBpcyBuZWFybHkgMSwgd2UndmUgY2FsY3VsYXRlZFxuICAgICAgICAvLyB0aGUgdXNlZnVsIHJhbmdlIG9mIHRoaXMgZGlzdHJpYnV0aW9uXG4gICAgfSB3aGlsZSAoY3VtdWxhdGl2ZVByb2JhYmlsaXR5IDwgMSAtIGVwc2lsb24pO1xuXG4gICAgcmV0dXJuIGNlbGxzO1xufVxuXG4vKipcbiAqIFRoZSBbUG9pc3NvbiBEaXN0cmlidXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9pc3Nvbl9kaXN0cmlidXRpb24pXG4gKiBpcyBhIGRpc2NyZXRlIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiB0aGF0IGV4cHJlc3NlcyB0aGUgcHJvYmFiaWxpdHlcbiAqIG9mIGEgZ2l2ZW4gbnVtYmVyIG9mIGV2ZW50cyBvY2N1cnJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbCBvZiB0aW1lXG4gKiBhbmQvb3Igc3BhY2UgaWYgdGhlc2UgZXZlbnRzIG9jY3VyIHdpdGggYSBrbm93biBhdmVyYWdlIHJhdGUgYW5kXG4gKiBpbmRlcGVuZGVudGx5IG9mIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGV2ZW50LlxuICpcbiAqIFRoZSBQb2lzc29uIERpc3RyaWJ1dGlvbiBpcyBjaGFyYWN0ZXJpemVkIGJ5IHRoZSBzdHJpY3RseSBwb3NpdGl2ZVxuICogbWVhbiBhcnJpdmFsIG9yIG9jY3VycmVuY2UgcmF0ZSwgYM67YC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGFtYmRhIGxvY2F0aW9uIHBvaXNzb24gZGlzdHJpYnV0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZhbHVlcyBvZiBwb2lzc29uIGRpc3RyaWJ1dGlvbiBhdCB0aGF0IHBvaW50XG4gKi9cbmZ1bmN0aW9uIHBvaXNzb25EaXN0cmlidXRpb24obGFtYmRhKSAvKjogP251bWJlcltdICovIHtcbiAgICAvLyBDaGVjayB0aGF0IGxhbWJkYSBpcyBzdHJpY3RseSBwb3NpdGl2ZVxuICAgIGlmIChsYW1iZGEgPD0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIG91ciBjdXJyZW50IHBsYWNlIGluIHRoZSBkaXN0cmlidXRpb25cbiAgICB2YXIgeCA9IDA7XG4gICAgLy8gYW5kIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgY3VtdWxhdGl2ZSBwcm9iYWJpbGl0eSwgaW5cbiAgICAvLyBvcmRlciB0byBrbm93IHdoZW4gdG8gc3RvcCBjYWxjdWxhdGluZyBjaGFuY2VzLlxuICAgIHZhciBjdW11bGF0aXZlUHJvYmFiaWxpdHkgPSAwO1xuICAgIC8vIHRoZSBjYWxjdWxhdGVkIGNlbGxzIHRvIGJlIHJldHVybmVkXG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgdmFyIGZhY3RvcmlhbFggPSAxO1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gaXRlcmF0ZXMgdGhyb3VnaCBlYWNoIHBvdGVudGlhbCBvdXRjb21lLFxuICAgIC8vIHVudGlsIHRoZSBgY3VtdWxhdGl2ZVByb2JhYmlsaXR5YCBpcyB2ZXJ5IGNsb3NlIHRvIDEsIGF0XG4gICAgLy8gd2hpY2ggcG9pbnQgd2UndmUgZGVmaW5lZCB0aGUgdmFzdCBtYWpvcml0eSBvZiBvdXRjb21lc1xuICAgIGRvIHtcbiAgICAgICAgLy8gYSBbcHJvYmFiaWxpdHkgbWFzcyBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvYmFiaWxpdHlfbWFzc19mdW5jdGlvbilcbiAgICAgICAgY2VsbHNbeF0gPSAoTWF0aC5leHAoLWxhbWJkYSkgKiBNYXRoLnBvdyhsYW1iZGEsIHgpKSAvIGZhY3RvcmlhbFg7XG4gICAgICAgIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSArPSBjZWxsc1t4XTtcbiAgICAgICAgeCsrO1xuICAgICAgICBmYWN0b3JpYWxYICo9IHg7XG4gICAgICAgIC8vIHdoZW4gdGhlIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSBpcyBuZWFybHkgMSwgd2UndmUgY2FsY3VsYXRlZFxuICAgICAgICAvLyB0aGUgdXNlZnVsIHJhbmdlIG9mIHRoaXMgZGlzdHJpYnV0aW9uXG4gICAgfSB3aGlsZSAoY3VtdWxhdGl2ZVByb2JhYmlsaXR5IDwgMSAtIGVwc2lsb24pO1xuXG4gICAgcmV0dXJuIGNlbGxzO1xufVxuXG4vKipcbiAqICoqUGVyY2VudGFnZSBQb2ludHMgb2YgdGhlIM+HMiAoQ2hpLVNxdWFyZWQpIERpc3RyaWJ1dGlvbioqXG4gKlxuICogVGhlIFvPhzIgKENoaS1TcXVhcmVkKSBEaXN0cmlidXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hpLXNxdWFyZWRfZGlzdHJpYnV0aW9uKSBpcyB1c2VkIGluIHRoZSBjb21tb25cbiAqIGNoaS1zcXVhcmVkIHRlc3RzIGZvciBnb29kbmVzcyBvZiBmaXQgb2YgYW4gb2JzZXJ2ZWQgZGlzdHJpYnV0aW9uIHRvIGEgdGhlb3JldGljYWwgb25lLCB0aGUgaW5kZXBlbmRlbmNlIG9mIHR3b1xuICogY3JpdGVyaWEgb2YgY2xhc3NpZmljYXRpb24gb2YgcXVhbGl0YXRpdmUgZGF0YSwgYW5kIGluIGNvbmZpZGVuY2UgaW50ZXJ2YWwgZXN0aW1hdGlvbiBmb3IgYSBwb3B1bGF0aW9uIHN0YW5kYXJkXG4gKiBkZXZpYXRpb24gb2YgYSBub3JtYWwgZGlzdHJpYnV0aW9uIGZyb20gYSBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uLlxuICpcbiAqIFZhbHVlcyBmcm9tIEFwcGVuZGl4IDEsIFRhYmxlIElJSSBvZiBXaWxsaWFtIFcuIEhpbmVzICYgRG91Z2xhcyBDLiBNb250Z29tZXJ5LCBcIlByb2JhYmlsaXR5IGFuZCBTdGF0aXN0aWNzIGluXG4gKiBFbmdpbmVlcmluZyBhbmQgTWFuYWdlbWVudCBTY2llbmNlXCIsIFdpbGV5ICgxOTgwKS5cbiAqL1xudmFyIGNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZSA9IHtcbiAgICAxOiB7XG4gICAgICAgIDAuOTk1OiAwLFxuICAgICAgICAwLjk5OiAwLFxuICAgICAgICAwLjk3NTogMCxcbiAgICAgICAgMC45NTogMCxcbiAgICAgICAgMC45OiAwLjAyLFxuICAgICAgICAwLjU6IDAuNDUsXG4gICAgICAgIDAuMTogMi43MSxcbiAgICAgICAgMC4wNTogMy44NCxcbiAgICAgICAgMC4wMjU6IDUuMDIsXG4gICAgICAgIDAuMDE6IDYuNjMsXG4gICAgICAgIDAuMDA1OiA3Ljg4XG4gICAgfSxcbiAgICAyOiB7XG4gICAgICAgIDAuOTk1OiAwLjAxLFxuICAgICAgICAwLjk5OiAwLjAyLFxuICAgICAgICAwLjk3NTogMC4wNSxcbiAgICAgICAgMC45NTogMC4xLFxuICAgICAgICAwLjk6IDAuMjEsXG4gICAgICAgIDAuNTogMS4zOSxcbiAgICAgICAgMC4xOiA0LjYxLFxuICAgICAgICAwLjA1OiA1Ljk5LFxuICAgICAgICAwLjAyNTogNy4zOCxcbiAgICAgICAgMC4wMTogOS4yMSxcbiAgICAgICAgMC4wMDU6IDEwLjZcbiAgICB9LFxuICAgIDM6IHtcbiAgICAgICAgMC45OTU6IDAuMDcsXG4gICAgICAgIDAuOTk6IDAuMTEsXG4gICAgICAgIDAuOTc1OiAwLjIyLFxuICAgICAgICAwLjk1OiAwLjM1LFxuICAgICAgICAwLjk6IDAuNTgsXG4gICAgICAgIDAuNTogMi4zNyxcbiAgICAgICAgMC4xOiA2LjI1LFxuICAgICAgICAwLjA1OiA3LjgxLFxuICAgICAgICAwLjAyNTogOS4zNSxcbiAgICAgICAgMC4wMTogMTEuMzQsXG4gICAgICAgIDAuMDA1OiAxMi44NFxuICAgIH0sXG4gICAgNDoge1xuICAgICAgICAwLjk5NTogMC4yMSxcbiAgICAgICAgMC45OTogMC4zLFxuICAgICAgICAwLjk3NTogMC40OCxcbiAgICAgICAgMC45NTogMC43MSxcbiAgICAgICAgMC45OiAxLjA2LFxuICAgICAgICAwLjU6IDMuMzYsXG4gICAgICAgIDAuMTogNy43OCxcbiAgICAgICAgMC4wNTogOS40OSxcbiAgICAgICAgMC4wMjU6IDExLjE0LFxuICAgICAgICAwLjAxOiAxMy4yOCxcbiAgICAgICAgMC4wMDU6IDE0Ljg2XG4gICAgfSxcbiAgICA1OiB7XG4gICAgICAgIDAuOTk1OiAwLjQxLFxuICAgICAgICAwLjk5OiAwLjU1LFxuICAgICAgICAwLjk3NTogMC44MyxcbiAgICAgICAgMC45NTogMS4xNSxcbiAgICAgICAgMC45OiAxLjYxLFxuICAgICAgICAwLjU6IDQuMzUsXG4gICAgICAgIDAuMTogOS4yNCxcbiAgICAgICAgMC4wNTogMTEuMDcsXG4gICAgICAgIDAuMDI1OiAxMi44MyxcbiAgICAgICAgMC4wMTogMTUuMDksXG4gICAgICAgIDAuMDA1OiAxNi43NVxuICAgIH0sXG4gICAgNjoge1xuICAgICAgICAwLjk5NTogMC42OCxcbiAgICAgICAgMC45OTogMC44NyxcbiAgICAgICAgMC45NzU6IDEuMjQsXG4gICAgICAgIDAuOTU6IDEuNjQsXG4gICAgICAgIDAuOTogMi4yLFxuICAgICAgICAwLjU6IDUuMzUsXG4gICAgICAgIDAuMTogMTAuNjUsXG4gICAgICAgIDAuMDU6IDEyLjU5LFxuICAgICAgICAwLjAyNTogMTQuNDUsXG4gICAgICAgIDAuMDE6IDE2LjgxLFxuICAgICAgICAwLjAwNTogMTguNTVcbiAgICB9LFxuICAgIDc6IHtcbiAgICAgICAgMC45OTU6IDAuOTksXG4gICAgICAgIDAuOTk6IDEuMjUsXG4gICAgICAgIDAuOTc1OiAxLjY5LFxuICAgICAgICAwLjk1OiAyLjE3LFxuICAgICAgICAwLjk6IDIuODMsXG4gICAgICAgIDAuNTogNi4zNSxcbiAgICAgICAgMC4xOiAxMi4wMixcbiAgICAgICAgMC4wNTogMTQuMDcsXG4gICAgICAgIDAuMDI1OiAxNi4wMSxcbiAgICAgICAgMC4wMTogMTguNDgsXG4gICAgICAgIDAuMDA1OiAyMC4yOFxuICAgIH0sXG4gICAgODoge1xuICAgICAgICAwLjk5NTogMS4zNCxcbiAgICAgICAgMC45OTogMS42NSxcbiAgICAgICAgMC45NzU6IDIuMTgsXG4gICAgICAgIDAuOTU6IDIuNzMsXG4gICAgICAgIDAuOTogMy40OSxcbiAgICAgICAgMC41OiA3LjM0LFxuICAgICAgICAwLjE6IDEzLjM2LFxuICAgICAgICAwLjA1OiAxNS41MSxcbiAgICAgICAgMC4wMjU6IDE3LjUzLFxuICAgICAgICAwLjAxOiAyMC4wOSxcbiAgICAgICAgMC4wMDU6IDIxLjk2XG4gICAgfSxcbiAgICA5OiB7XG4gICAgICAgIDAuOTk1OiAxLjczLFxuICAgICAgICAwLjk5OiAyLjA5LFxuICAgICAgICAwLjk3NTogMi43LFxuICAgICAgICAwLjk1OiAzLjMzLFxuICAgICAgICAwLjk6IDQuMTcsXG4gICAgICAgIDAuNTogOC4zNCxcbiAgICAgICAgMC4xOiAxNC42OCxcbiAgICAgICAgMC4wNTogMTYuOTIsXG4gICAgICAgIDAuMDI1OiAxOS4wMixcbiAgICAgICAgMC4wMTogMjEuNjcsXG4gICAgICAgIDAuMDA1OiAyMy41OVxuICAgIH0sXG4gICAgMTA6IHtcbiAgICAgICAgMC45OTU6IDIuMTYsXG4gICAgICAgIDAuOTk6IDIuNTYsXG4gICAgICAgIDAuOTc1OiAzLjI1LFxuICAgICAgICAwLjk1OiAzLjk0LFxuICAgICAgICAwLjk6IDQuODcsXG4gICAgICAgIDAuNTogOS4zNCxcbiAgICAgICAgMC4xOiAxNS45OSxcbiAgICAgICAgMC4wNTogMTguMzEsXG4gICAgICAgIDAuMDI1OiAyMC40OCxcbiAgICAgICAgMC4wMTogMjMuMjEsXG4gICAgICAgIDAuMDA1OiAyNS4xOVxuICAgIH0sXG4gICAgMTE6IHtcbiAgICAgICAgMC45OTU6IDIuNixcbiAgICAgICAgMC45OTogMy4wNSxcbiAgICAgICAgMC45NzU6IDMuODIsXG4gICAgICAgIDAuOTU6IDQuNTcsXG4gICAgICAgIDAuOTogNS41OCxcbiAgICAgICAgMC41OiAxMC4zNCxcbiAgICAgICAgMC4xOiAxNy4yOCxcbiAgICAgICAgMC4wNTogMTkuNjgsXG4gICAgICAgIDAuMDI1OiAyMS45MixcbiAgICAgICAgMC4wMTogMjQuNzIsXG4gICAgICAgIDAuMDA1OiAyNi43NlxuICAgIH0sXG4gICAgMTI6IHtcbiAgICAgICAgMC45OTU6IDMuMDcsXG4gICAgICAgIDAuOTk6IDMuNTcsXG4gICAgICAgIDAuOTc1OiA0LjQsXG4gICAgICAgIDAuOTU6IDUuMjMsXG4gICAgICAgIDAuOTogNi4zLFxuICAgICAgICAwLjU6IDExLjM0LFxuICAgICAgICAwLjE6IDE4LjU1LFxuICAgICAgICAwLjA1OiAyMS4wMyxcbiAgICAgICAgMC4wMjU6IDIzLjM0LFxuICAgICAgICAwLjAxOiAyNi4yMixcbiAgICAgICAgMC4wMDU6IDI4LjNcbiAgICB9LFxuICAgIDEzOiB7XG4gICAgICAgIDAuOTk1OiAzLjU3LFxuICAgICAgICAwLjk5OiA0LjExLFxuICAgICAgICAwLjk3NTogNS4wMSxcbiAgICAgICAgMC45NTogNS44OSxcbiAgICAgICAgMC45OiA3LjA0LFxuICAgICAgICAwLjU6IDEyLjM0LFxuICAgICAgICAwLjE6IDE5LjgxLFxuICAgICAgICAwLjA1OiAyMi4zNixcbiAgICAgICAgMC4wMjU6IDI0Ljc0LFxuICAgICAgICAwLjAxOiAyNy42OSxcbiAgICAgICAgMC4wMDU6IDI5LjgyXG4gICAgfSxcbiAgICAxNDoge1xuICAgICAgICAwLjk5NTogNC4wNyxcbiAgICAgICAgMC45OTogNC42NixcbiAgICAgICAgMC45NzU6IDUuNjMsXG4gICAgICAgIDAuOTU6IDYuNTcsXG4gICAgICAgIDAuOTogNy43OSxcbiAgICAgICAgMC41OiAxMy4zNCxcbiAgICAgICAgMC4xOiAyMS4wNixcbiAgICAgICAgMC4wNTogMjMuNjgsXG4gICAgICAgIDAuMDI1OiAyNi4xMixcbiAgICAgICAgMC4wMTogMjkuMTQsXG4gICAgICAgIDAuMDA1OiAzMS4zMlxuICAgIH0sXG4gICAgMTU6IHtcbiAgICAgICAgMC45OTU6IDQuNixcbiAgICAgICAgMC45OTogNS4yMyxcbiAgICAgICAgMC45NzU6IDYuMjcsXG4gICAgICAgIDAuOTU6IDcuMjYsXG4gICAgICAgIDAuOTogOC41NSxcbiAgICAgICAgMC41OiAxNC4zNCxcbiAgICAgICAgMC4xOiAyMi4zMSxcbiAgICAgICAgMC4wNTogMjUsXG4gICAgICAgIDAuMDI1OiAyNy40OSxcbiAgICAgICAgMC4wMTogMzAuNTgsXG4gICAgICAgIDAuMDA1OiAzMi44XG4gICAgfSxcbiAgICAxNjoge1xuICAgICAgICAwLjk5NTogNS4xNCxcbiAgICAgICAgMC45OTogNS44MSxcbiAgICAgICAgMC45NzU6IDYuOTEsXG4gICAgICAgIDAuOTU6IDcuOTYsXG4gICAgICAgIDAuOTogOS4zMSxcbiAgICAgICAgMC41OiAxNS4zNCxcbiAgICAgICAgMC4xOiAyMy41NCxcbiAgICAgICAgMC4wNTogMjYuMyxcbiAgICAgICAgMC4wMjU6IDI4Ljg1LFxuICAgICAgICAwLjAxOiAzMixcbiAgICAgICAgMC4wMDU6IDM0LjI3XG4gICAgfSxcbiAgICAxNzoge1xuICAgICAgICAwLjk5NTogNS43LFxuICAgICAgICAwLjk5OiA2LjQxLFxuICAgICAgICAwLjk3NTogNy41NixcbiAgICAgICAgMC45NTogOC42NyxcbiAgICAgICAgMC45OiAxMC4wOSxcbiAgICAgICAgMC41OiAxNi4zNCxcbiAgICAgICAgMC4xOiAyNC43NyxcbiAgICAgICAgMC4wNTogMjcuNTksXG4gICAgICAgIDAuMDI1OiAzMC4xOSxcbiAgICAgICAgMC4wMTogMzMuNDEsXG4gICAgICAgIDAuMDA1OiAzNS43MlxuICAgIH0sXG4gICAgMTg6IHtcbiAgICAgICAgMC45OTU6IDYuMjYsXG4gICAgICAgIDAuOTk6IDcuMDEsXG4gICAgICAgIDAuOTc1OiA4LjIzLFxuICAgICAgICAwLjk1OiA5LjM5LFxuICAgICAgICAwLjk6IDEwLjg3LFxuICAgICAgICAwLjU6IDE3LjM0LFxuICAgICAgICAwLjE6IDI1Ljk5LFxuICAgICAgICAwLjA1OiAyOC44NyxcbiAgICAgICAgMC4wMjU6IDMxLjUzLFxuICAgICAgICAwLjAxOiAzNC44MSxcbiAgICAgICAgMC4wMDU6IDM3LjE2XG4gICAgfSxcbiAgICAxOToge1xuICAgICAgICAwLjk5NTogNi44NCxcbiAgICAgICAgMC45OTogNy42MyxcbiAgICAgICAgMC45NzU6IDguOTEsXG4gICAgICAgIDAuOTU6IDEwLjEyLFxuICAgICAgICAwLjk6IDExLjY1LFxuICAgICAgICAwLjU6IDE4LjM0LFxuICAgICAgICAwLjE6IDI3LjIsXG4gICAgICAgIDAuMDU6IDMwLjE0LFxuICAgICAgICAwLjAyNTogMzIuODUsXG4gICAgICAgIDAuMDE6IDM2LjE5LFxuICAgICAgICAwLjAwNTogMzguNThcbiAgICB9LFxuICAgIDIwOiB7XG4gICAgICAgIDAuOTk1OiA3LjQzLFxuICAgICAgICAwLjk5OiA4LjI2LFxuICAgICAgICAwLjk3NTogOS41OSxcbiAgICAgICAgMC45NTogMTAuODUsXG4gICAgICAgIDAuOTogMTIuNDQsXG4gICAgICAgIDAuNTogMTkuMzQsXG4gICAgICAgIDAuMTogMjguNDEsXG4gICAgICAgIDAuMDU6IDMxLjQxLFxuICAgICAgICAwLjAyNTogMzQuMTcsXG4gICAgICAgIDAuMDE6IDM3LjU3LFxuICAgICAgICAwLjAwNTogNDBcbiAgICB9LFxuICAgIDIxOiB7XG4gICAgICAgIDAuOTk1OiA4LjAzLFxuICAgICAgICAwLjk5OiA4LjksXG4gICAgICAgIDAuOTc1OiAxMC4yOCxcbiAgICAgICAgMC45NTogMTEuNTksXG4gICAgICAgIDAuOTogMTMuMjQsXG4gICAgICAgIDAuNTogMjAuMzQsXG4gICAgICAgIDAuMTogMjkuNjIsXG4gICAgICAgIDAuMDU6IDMyLjY3LFxuICAgICAgICAwLjAyNTogMzUuNDgsXG4gICAgICAgIDAuMDE6IDM4LjkzLFxuICAgICAgICAwLjAwNTogNDEuNFxuICAgIH0sXG4gICAgMjI6IHtcbiAgICAgICAgMC45OTU6IDguNjQsXG4gICAgICAgIDAuOTk6IDkuNTQsXG4gICAgICAgIDAuOTc1OiAxMC45OCxcbiAgICAgICAgMC45NTogMTIuMzQsXG4gICAgICAgIDAuOTogMTQuMDQsXG4gICAgICAgIDAuNTogMjEuMzQsXG4gICAgICAgIDAuMTogMzAuODEsXG4gICAgICAgIDAuMDU6IDMzLjkyLFxuICAgICAgICAwLjAyNTogMzYuNzgsXG4gICAgICAgIDAuMDE6IDQwLjI5LFxuICAgICAgICAwLjAwNTogNDIuOFxuICAgIH0sXG4gICAgMjM6IHtcbiAgICAgICAgMC45OTU6IDkuMjYsXG4gICAgICAgIDAuOTk6IDEwLjIsXG4gICAgICAgIDAuOTc1OiAxMS42OSxcbiAgICAgICAgMC45NTogMTMuMDksXG4gICAgICAgIDAuOTogMTQuODUsXG4gICAgICAgIDAuNTogMjIuMzQsXG4gICAgICAgIDAuMTogMzIuMDEsXG4gICAgICAgIDAuMDU6IDM1LjE3LFxuICAgICAgICAwLjAyNTogMzguMDgsXG4gICAgICAgIDAuMDE6IDQxLjY0LFxuICAgICAgICAwLjAwNTogNDQuMThcbiAgICB9LFxuICAgIDI0OiB7XG4gICAgICAgIDAuOTk1OiA5Ljg5LFxuICAgICAgICAwLjk5OiAxMC44NixcbiAgICAgICAgMC45NzU6IDEyLjQsXG4gICAgICAgIDAuOTU6IDEzLjg1LFxuICAgICAgICAwLjk6IDE1LjY2LFxuICAgICAgICAwLjU6IDIzLjM0LFxuICAgICAgICAwLjE6IDMzLjIsXG4gICAgICAgIDAuMDU6IDM2LjQyLFxuICAgICAgICAwLjAyNTogMzkuMzYsXG4gICAgICAgIDAuMDE6IDQyLjk4LFxuICAgICAgICAwLjAwNTogNDUuNTZcbiAgICB9LFxuICAgIDI1OiB7XG4gICAgICAgIDAuOTk1OiAxMC41MixcbiAgICAgICAgMC45OTogMTEuNTIsXG4gICAgICAgIDAuOTc1OiAxMy4xMixcbiAgICAgICAgMC45NTogMTQuNjEsXG4gICAgICAgIDAuOTogMTYuNDcsXG4gICAgICAgIDAuNTogMjQuMzQsXG4gICAgICAgIDAuMTogMzQuMjgsXG4gICAgICAgIDAuMDU6IDM3LjY1LFxuICAgICAgICAwLjAyNTogNDAuNjUsXG4gICAgICAgIDAuMDE6IDQ0LjMxLFxuICAgICAgICAwLjAwNTogNDYuOTNcbiAgICB9LFxuICAgIDI2OiB7XG4gICAgICAgIDAuOTk1OiAxMS4xNixcbiAgICAgICAgMC45OTogMTIuMixcbiAgICAgICAgMC45NzU6IDEzLjg0LFxuICAgICAgICAwLjk1OiAxNS4zOCxcbiAgICAgICAgMC45OiAxNy4yOSxcbiAgICAgICAgMC41OiAyNS4zNCxcbiAgICAgICAgMC4xOiAzNS41NixcbiAgICAgICAgMC4wNTogMzguODksXG4gICAgICAgIDAuMDI1OiA0MS45MixcbiAgICAgICAgMC4wMTogNDUuNjQsXG4gICAgICAgIDAuMDA1OiA0OC4yOVxuICAgIH0sXG4gICAgMjc6IHtcbiAgICAgICAgMC45OTU6IDExLjgxLFxuICAgICAgICAwLjk5OiAxMi44OCxcbiAgICAgICAgMC45NzU6IDE0LjU3LFxuICAgICAgICAwLjk1OiAxNi4xNSxcbiAgICAgICAgMC45OiAxOC4xMSxcbiAgICAgICAgMC41OiAyNi4zNCxcbiAgICAgICAgMC4xOiAzNi43NCxcbiAgICAgICAgMC4wNTogNDAuMTEsXG4gICAgICAgIDAuMDI1OiA0My4xOSxcbiAgICAgICAgMC4wMTogNDYuOTYsXG4gICAgICAgIDAuMDA1OiA0OS42NVxuICAgIH0sXG4gICAgMjg6IHtcbiAgICAgICAgMC45OTU6IDEyLjQ2LFxuICAgICAgICAwLjk5OiAxMy41NyxcbiAgICAgICAgMC45NzU6IDE1LjMxLFxuICAgICAgICAwLjk1OiAxNi45MyxcbiAgICAgICAgMC45OiAxOC45NCxcbiAgICAgICAgMC41OiAyNy4zNCxcbiAgICAgICAgMC4xOiAzNy45MixcbiAgICAgICAgMC4wNTogNDEuMzQsXG4gICAgICAgIDAuMDI1OiA0NC40NixcbiAgICAgICAgMC4wMTogNDguMjgsXG4gICAgICAgIDAuMDA1OiA1MC45OVxuICAgIH0sXG4gICAgMjk6IHtcbiAgICAgICAgMC45OTU6IDEzLjEyLFxuICAgICAgICAwLjk5OiAxNC4yNixcbiAgICAgICAgMC45NzU6IDE2LjA1LFxuICAgICAgICAwLjk1OiAxNy43MSxcbiAgICAgICAgMC45OiAxOS43NyxcbiAgICAgICAgMC41OiAyOC4zNCxcbiAgICAgICAgMC4xOiAzOS4wOSxcbiAgICAgICAgMC4wNTogNDIuNTYsXG4gICAgICAgIDAuMDI1OiA0NS43MixcbiAgICAgICAgMC4wMTogNDkuNTksXG4gICAgICAgIDAuMDA1OiA1Mi4zNFxuICAgIH0sXG4gICAgMzA6IHtcbiAgICAgICAgMC45OTU6IDEzLjc5LFxuICAgICAgICAwLjk5OiAxNC45NSxcbiAgICAgICAgMC45NzU6IDE2Ljc5LFxuICAgICAgICAwLjk1OiAxOC40OSxcbiAgICAgICAgMC45OiAyMC42LFxuICAgICAgICAwLjU6IDI5LjM0LFxuICAgICAgICAwLjE6IDQwLjI2LFxuICAgICAgICAwLjA1OiA0My43NyxcbiAgICAgICAgMC4wMjU6IDQ2Ljk4LFxuICAgICAgICAwLjAxOiA1MC44OSxcbiAgICAgICAgMC4wMDU6IDUzLjY3XG4gICAgfSxcbiAgICA0MDoge1xuICAgICAgICAwLjk5NTogMjAuNzEsXG4gICAgICAgIDAuOTk6IDIyLjE2LFxuICAgICAgICAwLjk3NTogMjQuNDMsXG4gICAgICAgIDAuOTU6IDI2LjUxLFxuICAgICAgICAwLjk6IDI5LjA1LFxuICAgICAgICAwLjU6IDM5LjM0LFxuICAgICAgICAwLjE6IDUxLjgxLFxuICAgICAgICAwLjA1OiA1NS43NixcbiAgICAgICAgMC4wMjU6IDU5LjM0LFxuICAgICAgICAwLjAxOiA2My42OSxcbiAgICAgICAgMC4wMDU6IDY2Ljc3XG4gICAgfSxcbiAgICA1MDoge1xuICAgICAgICAwLjk5NTogMjcuOTksXG4gICAgICAgIDAuOTk6IDI5LjcxLFxuICAgICAgICAwLjk3NTogMzIuMzYsXG4gICAgICAgIDAuOTU6IDM0Ljc2LFxuICAgICAgICAwLjk6IDM3LjY5LFxuICAgICAgICAwLjU6IDQ5LjMzLFxuICAgICAgICAwLjE6IDYzLjE3LFxuICAgICAgICAwLjA1OiA2Ny41LFxuICAgICAgICAwLjAyNTogNzEuNDIsXG4gICAgICAgIDAuMDE6IDc2LjE1LFxuICAgICAgICAwLjAwNTogNzkuNDlcbiAgICB9LFxuICAgIDYwOiB7XG4gICAgICAgIDAuOTk1OiAzNS41MyxcbiAgICAgICAgMC45OTogMzcuNDgsXG4gICAgICAgIDAuOTc1OiA0MC40OCxcbiAgICAgICAgMC45NTogNDMuMTksXG4gICAgICAgIDAuOTogNDYuNDYsXG4gICAgICAgIDAuNTogNTkuMzMsXG4gICAgICAgIDAuMTogNzQuNCxcbiAgICAgICAgMC4wNTogNzkuMDgsXG4gICAgICAgIDAuMDI1OiA4My4zLFxuICAgICAgICAwLjAxOiA4OC4zOCxcbiAgICAgICAgMC4wMDU6IDkxLjk1XG4gICAgfSxcbiAgICA3MDoge1xuICAgICAgICAwLjk5NTogNDMuMjgsXG4gICAgICAgIDAuOTk6IDQ1LjQ0LFxuICAgICAgICAwLjk3NTogNDguNzYsXG4gICAgICAgIDAuOTU6IDUxLjc0LFxuICAgICAgICAwLjk6IDU1LjMzLFxuICAgICAgICAwLjU6IDY5LjMzLFxuICAgICAgICAwLjE6IDg1LjUzLFxuICAgICAgICAwLjA1OiA5MC41MyxcbiAgICAgICAgMC4wMjU6IDk1LjAyLFxuICAgICAgICAwLjAxOiAxMDAuNDIsXG4gICAgICAgIDAuMDA1OiAxMDQuMjJcbiAgICB9LFxuICAgIDgwOiB7XG4gICAgICAgIDAuOTk1OiA1MS4xNyxcbiAgICAgICAgMC45OTogNTMuNTQsXG4gICAgICAgIDAuOTc1OiA1Ny4xNSxcbiAgICAgICAgMC45NTogNjAuMzksXG4gICAgICAgIDAuOTogNjQuMjgsXG4gICAgICAgIDAuNTogNzkuMzMsXG4gICAgICAgIDAuMTogOTYuNTgsXG4gICAgICAgIDAuMDU6IDEwMS44OCxcbiAgICAgICAgMC4wMjU6IDEwNi42MyxcbiAgICAgICAgMC4wMTogMTEyLjMzLFxuICAgICAgICAwLjAwNTogMTE2LjMyXG4gICAgfSxcbiAgICA5MDoge1xuICAgICAgICAwLjk5NTogNTkuMixcbiAgICAgICAgMC45OTogNjEuNzUsXG4gICAgICAgIDAuOTc1OiA2NS42NSxcbiAgICAgICAgMC45NTogNjkuMTMsXG4gICAgICAgIDAuOTogNzMuMjksXG4gICAgICAgIDAuNTogODkuMzMsXG4gICAgICAgIDAuMTogMTA3LjU3LFxuICAgICAgICAwLjA1OiAxMTMuMTQsXG4gICAgICAgIDAuMDI1OiAxMTguMTQsXG4gICAgICAgIDAuMDE6IDEyNC4xMixcbiAgICAgICAgMC4wMDU6IDEyOC4zXG4gICAgfSxcbiAgICAxMDA6IHtcbiAgICAgICAgMC45OTU6IDY3LjMzLFxuICAgICAgICAwLjk5OiA3MC4wNixcbiAgICAgICAgMC45NzU6IDc0LjIyLFxuICAgICAgICAwLjk1OiA3Ny45MyxcbiAgICAgICAgMC45OiA4Mi4zNixcbiAgICAgICAgMC41OiA5OS4zMyxcbiAgICAgICAgMC4xOiAxMTguNSxcbiAgICAgICAgMC4wNTogMTI0LjM0LFxuICAgICAgICAwLjAyNTogMTI5LjU2LFxuICAgICAgICAwLjAxOiAxMzUuODEsXG4gICAgICAgIDAuMDA1OiAxNDAuMTdcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSBbz4cyIChDaGktU3F1YXJlZCkgR29vZG5lc3Mtb2YtRml0IFRlc3RdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR29vZG5lc3Nfb2ZfZml0I1BlYXJzb24uMjdzX2NoaS1zcXVhcmVkX3Rlc3QpXG4gKiB1c2VzIGEgbWVhc3VyZSBvZiBnb29kbmVzcyBvZiBmaXQgd2hpY2ggaXMgdGhlIHN1bSBvZiBkaWZmZXJlbmNlcyBiZXR3ZWVuIG9ic2VydmVkIGFuZCBleHBlY3RlZCBvdXRjb21lIGZyZXF1ZW5jaWVzXG4gKiAodGhhdCBpcywgY291bnRzIG9mIG9ic2VydmF0aW9ucyksIGVhY2ggc3F1YXJlZCBhbmQgZGl2aWRlZCBieSB0aGUgbnVtYmVyIG9mIG9ic2VydmF0aW9ucyBleHBlY3RlZCBnaXZlbiB0aGVcbiAqIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uIFRoZSByZXN1bHRpbmcgz4cyIHN0YXRpc3RpYywgYGNoaVNxdWFyZWRgLCBjYW4gYmUgY29tcGFyZWQgdG8gdGhlIGNoaS1zcXVhcmVkIGRpc3RyaWJ1dGlvblxuICogdG8gZGV0ZXJtaW5lIHRoZSBnb29kbmVzcyBvZiBmaXQuIEluIG9yZGVyIHRvIGRldGVybWluZSB0aGUgZGVncmVlcyBvZiBmcmVlZG9tIG9mIHRoZSBjaGktc3F1YXJlZCBkaXN0cmlidXRpb24sIG9uZVxuICogdGFrZXMgdGhlIHRvdGFsIG51bWJlciBvZiBvYnNlcnZlZCBmcmVxdWVuY2llcyBhbmQgc3VidHJhY3RzIHRoZSBudW1iZXIgb2YgZXN0aW1hdGVkIHBhcmFtZXRlcnMuIFRoZSB0ZXN0IHN0YXRpc3RpY1xuICogZm9sbG93cywgYXBwcm94aW1hdGVseSwgYSBjaGktc3F1YXJlIGRpc3RyaWJ1dGlvbiB3aXRoIChrIOKIkiBjKSBkZWdyZWVzIG9mIGZyZWVkb20gd2hlcmUgYGtgIGlzIHRoZSBudW1iZXIgb2Ygbm9uLWVtcHR5XG4gKiBjZWxscyBhbmQgYGNgIGlzIHRoZSBudW1iZXIgb2YgZXN0aW1hdGVkIHBhcmFtZXRlcnMgZm9yIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXN0cmlidXRpb25UeXBlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcG9pbnQgaW4gYSBkaXN0cmlidXRpb246XG4gKiBmb3IgaW5zdGFuY2UsIGJpbm9taWFsLCBiZXJub3VsbGksIG9yIHBvaXNzb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWduaWZpY2FuY2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNoaSBzcXVhcmVkIGdvb2RuZXNzIG9mIGZpdFxuICogQGV4YW1wbGVcbiAqIC8vIERhdGEgZnJvbSBQb2lzc29uIGdvb2RuZXNzLW9mLWZpdCBleGFtcGxlIDEwLTE5IGluIFdpbGxpYW0gVy4gSGluZXMgJiBEb3VnbGFzIEMuIE1vbnRnb21lcnksXG4gKiAvLyBcIlByb2JhYmlsaXR5IGFuZCBTdGF0aXN0aWNzIGluIEVuZ2luZWVyaW5nIGFuZCBNYW5hZ2VtZW50IFNjaWVuY2VcIiwgV2lsZXkgKDE5ODApLlxuICogdmFyIGRhdGExMDE5ID0gW1xuICogICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gKiAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAqICAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICogICAgIDIsIDIsIDIsIDIsIDIsIDIsIDIsIDIsIDIsXG4gKiAgICAgMywgMywgMywgM1xuICogXTtcbiAqIHNzLmNoaVNxdWFyZWRHb29kbmVzc09mRml0KGRhdGExMDE5LCBzcy5wb2lzc29uRGlzdHJpYnV0aW9uLCAwLjA1KTsgLy89IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNoaVNxdWFyZWRHb29kbmVzc09mRml0KGRhdGEsIGRpc3RyaWJ1dGlvblR5cGUsIHNpZ25pZmljYW5jZSkge1xuICAgIC8vIEVzdGltYXRlIGZyb20gdGhlIHNhbXBsZSBkYXRhLCBhIHdlaWdodGVkIG1lYW4uXG4gICAgdmFyIGlucHV0TWVhbiA9IG1lYW4oZGF0YSk7XG4gICAgLy8gQ2FsY3VsYXRlZCB2YWx1ZSBvZiB0aGUgz4cyIHN0YXRpc3RpYy5cbiAgICB2YXIgY2hpU3F1YXJlZCA9IDA7XG4gICAgLy8gTnVtYmVyIG9mIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24gcGFyYW1ldGVycyBlc3RpbWF0ZWQsIGV4cGVjdGVkIHRvIGJlIHN1cHBsaWVkIGluIHRoZSBkaXN0cmlidXRpb24gdGVzdC5cbiAgICAvLyBMb3NlIG9uZSBkZWdyZWUgb2YgZnJlZWRvbSBmb3IgZXN0aW1hdGluZyBgbGFtYmRhYCBmcm9tIHRoZSBzYW1wbGUgZGF0YS5cbiAgICB2YXIgYyA9IDE7XG4gICAgLy8gVGhlIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgLy8gR2VuZXJhdGUgdGhlIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgdmFyIGh5cG90aGVzaXplZERpc3RyaWJ1dGlvbiA9IGRpc3RyaWJ1dGlvblR5cGUoaW5wdXRNZWFuKTtcbiAgICB2YXIgb2JzZXJ2ZWRGcmVxdWVuY2llcyA9IFtdO1xuICAgIHZhciBleHBlY3RlZEZyZXF1ZW5jaWVzID0gW107XG5cbiAgICAvLyBDcmVhdGUgYW4gYXJyYXkgaG9sZGluZyBhIGhpc3RvZ3JhbSBmcm9tIHRoZSBzYW1wbGUgZGF0YSwgb2ZcbiAgICAvLyB0aGUgZm9ybSBgeyB2YWx1ZTogbnVtYmVyT2ZPY3VycmVuY2VzIH1gXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChvYnNlcnZlZEZyZXF1ZW5jaWVzW2RhdGFbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbZGF0YVtpXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbZGF0YVtpXV0rKztcbiAgICB9XG5cbiAgICAvLyBUaGUgaGlzdG9ncmFtIHdlIGNyZWF0ZWQgbWlnaHQgYmUgc3BhcnNlIC0gdGhlcmUgbWlnaHQgYmUgZ2Fwc1xuICAgIC8vIGJldHdlZW4gdmFsdWVzLiBTbyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGhpc3RvZ3JhbSwgbWFraW5nXG4gICAgLy8gc3VyZSB0aGF0IGluc3RlYWQgb2YgdW5kZWZpbmVkLCBnYXBzIGhhdmUgMCB2YWx1ZXMuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb2JzZXJ2ZWRGcmVxdWVuY2llcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIGlmIChvYnNlcnZlZEZyZXF1ZW5jaWVzW2kkMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZWRGcmVxdWVuY2llc1tpJDFdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbiBhcnJheSBob2xkaW5nIGEgaGlzdG9ncmFtIG9mIGV4cGVjdGVkIGRhdGEgZ2l2ZW4gdGhlXG4gICAgLy8gc2FtcGxlIHNpemUgYW5kIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgZm9yICh2YXIgayBpbiBoeXBvdGhlc2l6ZWREaXN0cmlidXRpb24pIHtcbiAgICAgICAgaWYgKGsgaW4gb2JzZXJ2ZWRGcmVxdWVuY2llcykge1xuICAgICAgICAgICAgZXhwZWN0ZWRGcmVxdWVuY2llc1sra10gPSBoeXBvdGhlc2l6ZWREaXN0cmlidXRpb25ba10gKiBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdvcmtpbmcgYmFja3dhcmQgdGhyb3VnaCB0aGUgZXhwZWN0ZWQgZnJlcXVlbmNpZXMsIGNvbGxhcHNlIGNsYXNzZXNcbiAgICAvLyBpZiBsZXNzIHRoYW4gdGhyZWUgb2JzZXJ2YXRpb25zIGFyZSBleHBlY3RlZCBmb3IgYSBjbGFzcy5cbiAgICAvLyBUaGlzIHRyYW5zZm9ybWF0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIG9ic2VydmVkIGZyZXF1ZW5jaWVzIGFzIHdlbGwuXG4gICAgZm9yICh2YXIgayQxID0gZXhwZWN0ZWRGcmVxdWVuY2llcy5sZW5ndGggLSAxOyBrJDEgPj0gMDsgayQxLS0pIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkRnJlcXVlbmNpZXNbayQxXSA8IDMpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXNbayQxIC0gMV0gKz0gZXhwZWN0ZWRGcmVxdWVuY2llc1trJDFdO1xuICAgICAgICAgICAgZXhwZWN0ZWRGcmVxdWVuY2llcy5wb3AoKTtcblxuICAgICAgICAgICAgb2JzZXJ2ZWRGcmVxdWVuY2llc1trJDEgLSAxXSArPSBvYnNlcnZlZEZyZXF1ZW5jaWVzW2skMV07XG4gICAgICAgICAgICBvYnNlcnZlZEZyZXF1ZW5jaWVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzcXVhcmVkIGRpZmZlcmVuY2VzIGJldHdlZW4gb2JzZXJ2ZWQgJiBleHBlY3RlZFxuICAgIC8vIGZyZXF1ZW5jaWVzLCBhY2N1bXVsYXRpbmcgdGhlIGBjaGlTcXVhcmVkYCBzdGF0aXN0aWMuXG4gICAgZm9yICh2YXIgayQyID0gMDsgayQyIDwgb2JzZXJ2ZWRGcmVxdWVuY2llcy5sZW5ndGg7IGskMisrKSB7XG4gICAgICAgIGNoaVNxdWFyZWQgKz1cbiAgICAgICAgICAgIE1hdGgucG93KG9ic2VydmVkRnJlcXVlbmNpZXNbayQyXSAtIGV4cGVjdGVkRnJlcXVlbmNpZXNbayQyXSwgMikgL1xuICAgICAgICAgICAgZXhwZWN0ZWRGcmVxdWVuY2llc1trJDJdO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBkZWdyZWVzIG9mIGZyZWVkb20gZm9yIHRoaXMgdGVzdCBhbmQgbG9vayBpdCB1cCBpbiB0aGVcbiAgICAvLyBgY2hpU3F1YXJlZERpc3RyaWJ1dGlvblRhYmxlYCBpbiBvcmRlciB0b1xuICAgIC8vIGFjY2VwdCBvciByZWplY3QgdGhlIGdvb2RuZXNzLW9mLWZpdCBvZiB0aGUgaHlwb3RoZXNpemVkIGRpc3RyaWJ1dGlvbi5cbiAgICAvLyBEZWdyZWVzIG9mIGZyZWVkb20sIGNhbGN1bGF0ZWQgYXMgKG51bWJlciBvZiBjbGFzcyBpbnRlcnZhbHMgLVxuICAgIC8vIG51bWJlciBvZiBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uIHBhcmFtZXRlcnMgZXN0aW1hdGVkIC0gMSlcbiAgICB2YXIgZGVncmVlc09mRnJlZWRvbSA9IG9ic2VydmVkRnJlcXVlbmNpZXMubGVuZ3RoIC0gYyAtIDE7XG4gICAgcmV0dXJuIChcbiAgICAgICAgY2hpU3F1YXJlZERpc3RyaWJ1dGlvblRhYmxlW2RlZ3JlZXNPZkZyZWVkb21dW3NpZ25pZmljYW5jZV0gPCBjaGlTcXVhcmVkXG4gICAgKTtcbn1cblxudmFyIFNRUlRfMlBJJDEgPSBNYXRoLnNxcnQoMiAqIE1hdGguUEkpO1xuXG4vKipcbiAqIFtXZWxsLWtub3duIGtlcm5lbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlcm5lbF8oc3RhdGlzdGljcykjS2VybmVsX2Z1bmN0aW9uc19pbl9jb21tb25fdXNlKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGtlcm5lbHMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIGdhdXNzaWFuIGtlcm5lbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdhdXNzaWFuOiBmdW5jdGlvbiAodSkge1xuICAgICAgICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIHUgKiB1KSAvIFNRUlRfMlBJJDE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXZWxsIGtub3duIGJhbmR3aWR0aCBzZWxlY3Rpb24gbWV0aG9kc1xuICogQHByaXZhdGVcbiAqL1xudmFyIGJhbmR3aWR0aE1ldGhvZHMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIFtcIm5vcm1hbCByZWZlcmVuY2UgZGlzdHJpYnV0aW9uXCJcbiAgICAgKiBydWxlLW9mLXRodW1iXShodHRwczovL3N0YXQuZXRoei5jaC9SLW1hbnVhbC9SLWRldmVsL2xpYnJhcnkvTUFTUy9odG1sL2JhbmR3aWR0aC5ucmQuaHRtbCksXG4gICAgICogYSBjb21tb25seSB1c2VkIHZlcnNpb24gb2YgW1NpbHZlcm1hbidzXG4gICAgICogcnVsZS1vZi10aHVtYl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2VybmVsX2RlbnNpdHlfZXN0aW1hdGlvbiNBX3J1bGUtb2YtdGh1bWJfYmFuZHdpZHRoX2VzdGltYXRvcikuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBucmQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBzID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeCk7XG4gICAgICAgIHZhciBpcXIgPSBpbnRlcnF1YXJ0aWxlUmFuZ2UoeCk7XG4gICAgICAgIGlmICh0eXBlb2YgaXFyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzID0gTWF0aC5taW4ocywgaXFyIC8gMS4zNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDEuMDYgKiBzICogTWF0aC5wb3coeC5sZW5ndGgsIC0wLjIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogW0tlcm5lbCBkZW5zaXR5IGVzdGltYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlcm5lbF9kZW5zaXR5X2VzdGltYXRpb24pXG4gKiBpcyBhIHVzZWZ1bCB0b29sIGZvciwgYW1vbmcgb3RoZXIgdGhpbmdzLCBlc3RpbWF0aW5nIHRoZSBzaGFwZSBvZiB0aGVcbiAqIHVuZGVybHlpbmcgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIGZyb20gYSBzYW1wbGUuXG4gKlxuICogQG5hbWUga2VybmVsRGVuc2l0eUVzdGltYXRpb25cbiAqIEBwYXJhbSBYIHNhbXBsZSB2YWx1ZXNcbiAqIEBwYXJhbSBrZXJuZWwgVGhlIGtlcm5lbCBmdW5jdGlvbiB0byB1c2UuIElmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IHNob3VsZCByZXR1cm4gbm9uLW5lZ2F0aXZlIHZhbHVlcyBhbmQgaW50ZWdyYXRlIHRvIDEuIERlZmF1bHRzIHRvICdnYXVzc2lhbicuXG4gKiBAcGFyYW0gYmFuZHdpZHRoTWV0aG9kIFRoZSBcImJhbmR3aWR0aCBzZWxlY3Rpb25cIiBtZXRob2QgdG8gdXNlLCBvciBhIGZpeGVkIGJhbmR3aWR0aCB2YWx1ZS4gRGVmYXVsdHMgdG8gXCJucmRcIiwgdGhlIGNvbW1vbmx5LXVzZWQgW1wibm9ybWFsIHJlZmVyZW5jZSBkaXN0cmlidXRpb25cIiBydWxlLW9mLXRodW1iXShodHRwczovL3N0YXQuZXRoei5jaC9SLW1hbnVhbC9SLWRldmVsL2xpYnJhcnkvTUFTUy9odG1sL2JhbmR3aWR0aC5ucmQuaHRtbCkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEFuIGVzdGltYXRlZCBbcHJvYmFiaWxpdHkgZGVuc2l0eSBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvYmFiaWxpdHlfZGVuc2l0eV9mdW5jdGlvbikgZm9yIHRoZSBnaXZlbiBzYW1wbGUuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBydW5zIGluIGBPKFgubGVuZ3RoKWAuXG4gKi9cbmZ1bmN0aW9uIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uKFgsIGtlcm5lbCwgYmFuZHdpZHRoTWV0aG9kKSB7XG4gICAgdmFyIGtlcm5lbEZuO1xuICAgIGlmIChrZXJuZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWxGbiA9IGtlcm5lbHMuZ2F1c3NpYW47XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2VybmVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICgha2VybmVsc1trZXJuZWxdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24ga2VybmVsIFwiJyArIGtlcm5lbCArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGtlcm5lbEZuID0ga2VybmVsc1trZXJuZWxdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtlcm5lbEZuID0ga2VybmVsO1xuICAgIH1cblxuICAgIHZhciBiYW5kd2lkdGg7XG4gICAgaWYgKHR5cGVvZiBiYW5kd2lkdGhNZXRob2QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYmFuZHdpZHRoID0gYmFuZHdpZHRoTWV0aG9kcy5ucmQoWCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYmFuZHdpZHRoTWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghYmFuZHdpZHRoTWV0aG9kc1tiYW5kd2lkdGhNZXRob2RdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1Vua25vd24gYmFuZHdpZHRoIG1ldGhvZCBcIicgKyBiYW5kd2lkdGhNZXRob2QgKyAnXCInXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJhbmR3aWR0aCA9IGJhbmR3aWR0aE1ldGhvZHNbYmFuZHdpZHRoTWV0aG9kXShYKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBiYW5kd2lkdGggPSBiYW5kd2lkdGhNZXRob2Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBYLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0ga2VybmVsRm4oKHggLSBYW2ldKSAvIGJhbmR3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSAvIGJhbmR3aWR0aCAvIFgubGVuZ3RoO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIFtaLVNjb3JlLCBvciBTdGFuZGFyZCBTY29yZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9zY29yZSkuXG4gKlxuICogVGhlIHN0YW5kYXJkIHNjb3JlIGlzIHRoZSBudW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBhbiBvYnNlcnZhdGlvblxuICogb3IgZGF0dW0gaXMgYWJvdmUgb3IgYmVsb3cgdGhlIG1lYW4uIFRodXMsIGEgcG9zaXRpdmUgc3RhbmRhcmQgc2NvcmVcbiAqIHJlcHJlc2VudHMgYSBkYXR1bSBhYm92ZSB0aGUgbWVhbiwgd2hpbGUgYSBuZWdhdGl2ZSBzdGFuZGFyZCBzY29yZVxuICogcmVwcmVzZW50cyBhIGRhdHVtIGJlbG93IHRoZSBtZWFuLiBJdCBpcyBhIGRpbWVuc2lvbmxlc3MgcXVhbnRpdHlcbiAqIG9idGFpbmVkIGJ5IHN1YnRyYWN0aW5nIHRoZSBwb3B1bGF0aW9uIG1lYW4gZnJvbSBhbiBpbmRpdmlkdWFsIHJhd1xuICogc2NvcmUgYW5kIHRoZW4gZGl2aWRpbmcgdGhlIGRpZmZlcmVuY2UgYnkgdGhlIHBvcHVsYXRpb24gc3RhbmRhcmRcbiAqIGRldmlhdGlvbi5cbiAqXG4gKiBUaGUgei1zY29yZSBpcyBvbmx5IGRlZmluZWQgaWYgb25lIGtub3dzIHRoZSBwb3B1bGF0aW9uIHBhcmFtZXRlcnM7XG4gKiBpZiBvbmUgb25seSBoYXMgYSBzYW1wbGUgc2V0LCB0aGVuIHRoZSBhbmFsb2dvdXMgY29tcHV0YXRpb24gd2l0aFxuICogc2FtcGxlIG1lYW4gYW5kIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24geWllbGRzIHRoZVxuICogU3R1ZGVudCdzIHQtc3RhdGlzdGljLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0gbWVhblxuICogQHBhcmFtIHtudW1iZXJ9IHN0YW5kYXJkRGV2aWF0aW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHogc2NvcmVcbiAqIEBleGFtcGxlXG4gKiB6U2NvcmUoNzgsIDgwLCA1KTsgLy8gPT4gLTAuNFxuICovXG5mdW5jdGlvbiB6U2NvcmUoeCwgbWVhbiwgc3RhbmRhcmREZXZpYXRpb24pIHtcbiAgICByZXR1cm4gKHggLSBtZWFuKSAvIHN0YW5kYXJkRGV2aWF0aW9uO1xufVxuXG52YXIgU1FSVF8yUEkgPSBNYXRoLnNxcnQoMiAqIE1hdGguUEkpO1xuXG5mdW5jdGlvbiBjdW11bGF0aXZlRGlzdHJpYnV0aW9uKHopIHtcbiAgICB2YXIgc3VtID0gejtcbiAgICB2YXIgdG1wID0gejtcblxuICAgIC8vIDE1IGl0ZXJhdGlvbnMgYXJlIGVub3VnaCBmb3IgNC1kaWdpdCBwcmVjaXNpb25cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgICAgdG1wICo9ICh6ICogeikgLyAoMiAqIGkgKyAxKTtcbiAgICAgICAgc3VtICs9IHRtcDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICAgTWF0aC5yb3VuZCgoMC41ICsgKHN1bSAvIFNRUlRfMlBJKSAqIE1hdGguZXhwKCgteiAqIHopIC8gMikpICogMWU0KSAvXG4gICAgICAgIDFlNFxuICAgICk7XG59XG5cbi8qKlxuICogQSBzdGFuZGFyZCBub3JtYWwgdGFibGUsIGFsc28gY2FsbGVkIHRoZSB1bml0IG5vcm1hbCB0YWJsZSBvciBaIHRhYmxlLFxuICogaXMgYSBtYXRoZW1hdGljYWwgdGFibGUgZm9yIHRoZSB2YWx1ZXMgb2YgzqYgKHBoaSksIHdoaWNoIGFyZSB0aGUgdmFsdWVzIG9mXG4gKiB0aGUgW2N1bXVsYXRpdmUgZGlzdHJpYnV0aW9uIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ob3JtYWxfZGlzdHJpYnV0aW9uI0N1bXVsYXRpdmVfZGlzdHJpYnV0aW9uX2Z1bmN0aW9uKVxuICogb2YgdGhlIG5vcm1hbCBkaXN0cmlidXRpb24uIEl0IGlzIHVzZWQgdG8gZmluZCB0aGUgcHJvYmFiaWxpdHkgdGhhdCBhXG4gKiBzdGF0aXN0aWMgaXMgb2JzZXJ2ZWQgYmVsb3csIGFib3ZlLCBvciBiZXR3ZWVuIHZhbHVlcyBvbiB0aGUgc3RhbmRhcmRcbiAqIG5vcm1hbCBkaXN0cmlidXRpb24sIGFuZCBieSBleHRlbnNpb24sIGFueSBub3JtYWwgZGlzdHJpYnV0aW9uLlxuICovXG52YXIgc3RhbmRhcmROb3JtYWxUYWJsZSA9IFtdO1xuXG5mb3IgKHZhciB6ID0gMDsgeiA8PSAzLjA5OyB6ICs9IDAuMDEpIHtcbiAgICBzdGFuZGFyZE5vcm1hbFRhYmxlLnB1c2goY3VtdWxhdGl2ZURpc3RyaWJ1dGlvbih6KSk7XG59XG5cbi8qKlxuICogKipbQ3VtdWxhdGl2ZSBTdGFuZGFyZCBOb3JtYWwgUHJvYmFiaWxpdHldKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfbm9ybWFsX3RhYmxlKSoqXG4gKlxuICogU2luY2UgcHJvYmFiaWxpdHkgdGFibGVzIGNhbm5vdCBiZVxuICogcHJpbnRlZCBmb3IgZXZlcnkgbm9ybWFsIGRpc3RyaWJ1dGlvbiwgYXMgdGhlcmUgYXJlIGFuIGluZmluaXRlIHZhcmlldHlcbiAqIG9mIG5vcm1hbCBkaXN0cmlidXRpb25zLCBpdCBpcyBjb21tb24gcHJhY3RpY2UgdG8gY29udmVydCBhIG5vcm1hbCB0byBhXG4gKiBzdGFuZGFyZCBub3JtYWwgYW5kIHRoZW4gdXNlIHRoZSBzdGFuZGFyZCBub3JtYWwgdGFibGUgdG8gZmluZCBwcm9iYWJpbGl0aWVzLlxuICpcbiAqIFlvdSBjYW4gdXNlIGAuNSArIC41ICogZXJyb3JGdW5jdGlvbih4IC8gTWF0aC5zcXJ0KDIpKWAgdG8gY2FsY3VsYXRlIHRoZSBwcm9iYWJpbGl0eVxuICogaW5zdGVhZCBvZiBsb29raW5nIGl0IHVwIGluIGEgdGFibGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGN1bXVsYXRpdmUgc3RhbmRhcmQgbm9ybWFsIHByb2JhYmlsaXR5XG4gKi9cbmZ1bmN0aW9uIGN1bXVsYXRpdmVTdGROb3JtYWxQcm9iYWJpbGl0eSh6KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHZhbHVlLlxuICAgIHZhciBhYnNaID0gTWF0aC5hYnMoeik7XG4gICAgLy8gRWFjaCByb3cgYmVnaW5zIHdpdGggYSBkaWZmZXJlbnRcbiAgICAvLyBzaWduaWZpY2FudCBkaWdpdDogMC41LCAwLjYsIDAuNywgYW5kIHNvIG9uLiBFYWNoIHZhbHVlIGluIHRoZSB0YWJsZVxuICAgIC8vIGNvcnJlc3BvbmRzIHRvIGEgcmFuZ2Ugb2YgMC4wMSBpbiB0aGUgaW5wdXQgdmFsdWVzLCBzbyB0aGUgdmFsdWUgaXNcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IDEwMC5cbiAgICB2YXIgaW5kZXggPSBNYXRoLm1pbihcbiAgICAgICAgTWF0aC5yb3VuZChhYnNaICogMTAwKSxcbiAgICAgICAgc3RhbmRhcmROb3JtYWxUYWJsZS5sZW5ndGggLSAxXG4gICAgKTtcblxuICAgIC8vIFRoZSBpbmRleCB3ZSBjYWxjdWxhdGUgbXVzdCBiZSBpbiB0aGUgdGFibGUgYXMgYSBwb3NpdGl2ZSB2YWx1ZSxcbiAgICAvLyBidXQgd2Ugc3RpbGwgcGF5IGF0dGVudGlvbiB0byB3aGV0aGVyIHRoZSBpbnB1dCBpcyBwb3NpdGl2ZVxuICAgIC8vIG9yIG5lZ2F0aXZlLCBhbmQgZmxpcCB0aGUgb3V0cHV0IHZhbHVlIGFzIGEgbGFzdCBzdGVwLlxuICAgIGlmICh6ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YW5kYXJkTm9ybWFsVGFibGVbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGR1ZSB0byBmbG9hdGluZy1wb2ludCBhcml0aG1ldGljLCB2YWx1ZXMgaW4gdGhlIHRhYmxlIHdpdGhcbiAgICAgICAgLy8gNCBzaWduaWZpY2FudCBmaWd1cmVzIGNhbiBuZXZlcnRoZWxlc3MgZW5kIHVwIGFzIHJlcGVhdGluZ1xuICAgICAgICAvLyBmcmFjdGlvbnMgd2hlbiB0aGV5J3JlIGNvbXB1dGVkIGhlcmUuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCgxIC0gc3RhbmRhcmROb3JtYWxUYWJsZVtpbmRleF0pICogMWU0KSAvIDFlNDtcbiAgICB9XG59XG5cbi8qKlxuICogKipbTG9naXN0aWMgQ3VtdWxhdGl2ZSBEaXN0cmlidXRpb24gRnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvZ2lzdGljX2Rpc3RyaWJ1dGlvbikqKlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjdW11bGF0aXZlIHN0YW5kYXJkIGxvZ2lzdGljIHByb2JhYmlsaXR5XG4gKi9cbmZ1bmN0aW9uIGN1bXVsYXRpdmVTdGRMb2dpc3RpY1Byb2JhYmlsaXR5KHgpIHtcbiAgICByZXR1cm4gMSAvIChNYXRoLmV4cCgteCkgKyAxKTtcbn1cblxuLyoqXG4gKiAqKltHYXVzc2lhbiBlcnJvciBmdW5jdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcnJvcl9mdW5jdGlvbikqKlxuICpcbiAqIFRoZSBgZXJyb3JGdW5jdGlvbih4LyhzZCAqIE1hdGguc3FydCgyKSkpYCBpcyB0aGUgcHJvYmFiaWxpdHkgdGhhdCBhIHZhbHVlIGluIGFcbiAqIG5vcm1hbCBkaXN0cmlidXRpb24gd2l0aCBzdGFuZGFyZCBkZXZpYXRpb24gc2QgaXMgd2l0aGluIHggb2YgdGhlIG1lYW4uXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbnVtZXJpY2FsIGFwcHJveGltYXRpb24gdG8gdGhlIGV4YWN0IHZhbHVlLlxuICogSXQgdXNlcyBIb3JuZXIncyBtZXRob2QgdG8gZXZhbHVhdGUgdGhlIHBvbHlub21pYWwgb2Ygz4QgKHRhdSkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gZXJyb3IgZXN0aW1hdGlvblxuICogQGV4YW1wbGVcbiAqIGVycm9yRnVuY3Rpb24oMSkudG9GaXhlZCgyKTsgLy8gPT4gJzAuODQnXG4gKi9cbmZ1bmN0aW9uIGVycm9yRnVuY3Rpb24oeCkge1xuICAgIHZhciB0ID0gMSAvICgxICsgMC41ICogTWF0aC5hYnMoeCkpO1xuICAgIHZhciB0YXUgPVxuICAgICAgICB0ICpcbiAgICAgICAgTWF0aC5leHAoXG4gICAgICAgICAgICAteCAqIHggK1xuICAgICAgICAgICAgICAgICgoKCgoKCgoMC4xNzA4NzI3NyAqIHQgLSAwLjgyMjE1MjIzKSAqIHQgKyAxLjQ4ODUxNTg3KSAqIHQgLVxuICAgICAgICAgICAgICAgICAgICAxLjEzNTIwMzk4KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAwLjI3ODg2ODA3KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgLVxuICAgICAgICAgICAgICAgICAgICAwLjE4NjI4ODA2KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAwLjA5Njc4NDE4KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAwLjM3NDA5MTk2KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAxLjAwMDAyMzY4KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgLVxuICAgICAgICAgICAgICAgIDEuMjY1NTEyMjNcbiAgICAgICAgKTtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiAxIC0gdGF1O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0YXUgLSAxO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgSW52ZXJzZSBbR2F1c3NpYW4gZXJyb3IgZnVuY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24pXG4gKiByZXR1cm5zIGEgbnVtZXJpY2FsIGFwcHJveGltYXRpb24gdG8gdGhlIHZhbHVlIHRoYXQgd291bGQgaGF2ZSBjYXVzZWRcbiAqIGBlcnJvckZ1bmN0aW9uKClgIHRvIHJldHVybiB4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHZhbHVlIG9mIGVycm9yIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBlc3RpbWF0ZWQgaW52ZXJ0ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZUVycm9yRnVuY3Rpb24oeCkge1xuICAgIHZhciBhID0gKDggKiAoTWF0aC5QSSAtIDMpKSAvICgzICogTWF0aC5QSSAqICg0IC0gTWF0aC5QSSkpO1xuXG4gICAgdmFyIGludiA9IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3coMiAvIChNYXRoLlBJICogYSkgKyBNYXRoLmxvZygxIC0geCAqIHgpIC8gMiwgMikgLVxuICAgICAgICAgICAgICAgIE1hdGgubG9nKDEgLSB4ICogeCkgLyBhXG4gICAgICAgICkgLVxuICAgICAgICAgICAgKDIgLyAoTWF0aC5QSSAqIGEpICsgTWF0aC5sb2coMSAtIHggKiB4KSAvIDIpXG4gICAgKTtcblxuICAgIGlmICh4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGludjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLWludjtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIFtQcm9iaXRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvYml0KVxuICogaXMgdGhlIGludmVyc2Ugb2YgY3VtdWxhdGl2ZVN0ZE5vcm1hbFByb2JhYmlsaXR5KCksXG4gKiBhbmQgaXMgYWxzbyBrbm93biBhcyB0aGUgbm9ybWFsIHF1YW50aWxlIGZ1bmN0aW9uLlxuICpcbiAqIEl0IHJldHVybnMgdGhlIG51bWJlciBvZiBzdGFuZGFyZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW5cbiAqIHdoZXJlIHRoZSBwJ3RoIHF1YW50aWxlIG9mIHZhbHVlcyBjYW4gYmUgZm91bmQgaW4gYSBub3JtYWwgZGlzdHJpYnV0aW9uLlxuICogU28sIGZvciBleGFtcGxlLCBwcm9iaXQoMC41ICsgMC42ODI3LzIpIOKJiCAxIGJlY2F1c2UgNjguMjclIG9mIHZhbHVlcyBhcmVcbiAqIG5vcm1hbGx5IGZvdW5kIHdpdGhpbiAxIHN0YW5kYXJkIGRldmlhdGlvbiBhYm92ZSBvciBiZWxvdyB0aGUgbWVhbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcFxuICogQHJldHVybnMge251bWJlcn0gcHJvYml0XG4gKi9cbmZ1bmN0aW9uIHByb2JpdChwKSB7XG4gICAgaWYgKHAgPT09IDApIHtcbiAgICAgICAgcCA9IGVwc2lsb247XG4gICAgfSBlbHNlIGlmIChwID49IDEpIHtcbiAgICAgICAgcCA9IDEgLSBlcHNpbG9uO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KDIpICogaW52ZXJzZUVycm9yRnVuY3Rpb24oMiAqIHAgLSAxKTtcbn1cblxuLyoqXG4gKiBUaGUgW0xvZ2l0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dpdClcbiAqIGlzIHRoZSBpbnZlcnNlIG9mIGN1bXVsYXRpdmVTdGRMb2dpc3RpY1Byb2JhYmlsaXR5LFxuICogYW5kIGlzIGFsc28ga25vd24gYXMgdGhlIGxvZ2lzdGljIHF1YW50aWxlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBsb2dpdFxuICovXG5mdW5jdGlvbiBsb2dpdChwKSB7XG4gICAgaWYgKHAgPD0gMCB8fCBwID49IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicCBtdXN0IGJlIHN0cmljdGx5IGJldHdlZW4gemVybyBhbmQgb25lXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5sb2cocCAvICgxIC0gcCkpO1xufVxuXG4vKipcbiAqIENvbmR1Y3RzIGEgW3Blcm11dGF0aW9uIHRlc3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jlc2FtcGxpbmdfKHN0YXRpc3RpY3MpI1Blcm11dGF0aW9uX3Rlc3RzKVxuICogdG8gZGV0ZXJtaW5lIGlmIHR3byBkYXRhIHNldHMgYXJlICpzaWduaWZpY2FudGx5KiBkaWZmZXJlbnQgZnJvbSBlYWNoIG90aGVyLCB1c2luZ1xuICogdGhlIGRpZmZlcmVuY2Ugb2YgbWVhbnMgYmV0d2VlbiB0aGUgZ3JvdXBzIGFzIHRoZSB0ZXN0IHN0YXRpc3RpYy5cbiAqIFRoZSBmdW5jdGlvbiBhbGxvd3MgZm9yIHRoZSBmb2xsb3dpbmcgaHlwb3RoZXNlczpcbiAqIC0gdHdvX3RhaWwgPSBOdWxsIGh5cG90aGVzaXM6IHRoZSB0d28gZGlzdHJpYnV0aW9ucyBhcmUgZXF1YWwuXG4gKiAtIGdyZWF0ZXIgPSBOdWxsIGh5cG90aGVzaXM6IG9ic2VydmF0aW9ucyBmcm9tIHNhbXBsZVggdGVuZCB0byBiZSBzbWFsbGVyIHRoYW4gdGhvc2UgZnJvbSBzYW1wbGVZLlxuICogLSBsZXNzID0gTnVsbCBoeXBvdGhlc2lzOiBvYnNlcnZhdGlvbnMgZnJvbSBzYW1wbGVYIHRlbmQgdG8gYmUgZ3JlYXRlciB0aGFuIHRob3NlIGZyb20gc2FtcGxlWS5cbiAqIFtMZWFybiBtb3JlIGFib3V0IG9uZS10YWlsIHZzIHR3by10YWlsIHRlc3RzLl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT25lLV9hbmRfdHdvLXRhaWxlZF90ZXN0cylcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVggZmlyc3QgZGF0YXNldCAoZS5nLiB0cmVhdG1lbnQgZGF0YSlcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWSBzZWNvbmQgZGF0YXNldCAoZS5nLiBjb250cm9sIGRhdGEpXG4gKiBAcGFyYW0ge3N0cmluZ30gYWx0ZXJuYXRpdmUgYWx0ZXJuYXRpdmUgaHlwb3RoZXNpcywgZWl0aGVyICd0d29fc2lkZWQnIChkZWZhdWx0KSwgJ2dyZWF0ZXInLCBvciAnbGVzcydcbiAqIEBwYXJhbSB7bnVtYmVyfSBrIG51bWJlciBvZiB2YWx1ZXMgaW4gcGVybXV0YXRpb24gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHAtdmFsdWUgVGhlIHByb2JhYmlsaXR5IG9mIG9ic2VydmluZyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGdyb3VwcyAoYXMgb3IgbW9yZSBleHRyZW1lIHRoYW4gd2hhdCB3ZSBkaWQpLCBhc3N1bWluZyB0aGUgbnVsbCBoeXBvdGhlc2lzLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udHJvbCA9IFsyLCA1LCAzLCA2LCA3LCAyLCA1XTtcbiAqIHZhciB0cmVhdG1lbnQgPSBbMjAsIDUsIDEzLCAxMiwgNywgMiwgMl07XG4gKiBwZXJtdXRhdGlvblRlc3QoY29udHJvbCwgdHJlYXRtZW50KTsgLy8gfjAuMTMyNFxuICovXG5mdW5jdGlvbiBwZXJtdXRhdGlvblRlc3Qoc2FtcGxlWCwgc2FtcGxlWSwgYWx0ZXJuYXRpdmUsIGssIHJhbmRvbVNvdXJjZSkge1xuICAgIC8vIFNldCBkZWZhdWx0IGFyZ3VtZW50c1xuICAgIGlmIChrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgayA9IDEwMDAwO1xuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbHRlcm5hdGl2ZSA9IFwidHdvX3NpZGVcIjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICBhbHRlcm5hdGl2ZSAhPT0gXCJ0d29fc2lkZVwiICYmXG4gICAgICAgIGFsdGVybmF0aXZlICE9PSBcImdyZWF0ZXJcIiAmJlxuICAgICAgICBhbHRlcm5hdGl2ZSAhPT0gXCJsZXNzXCJcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJgYWx0ZXJuYXRpdmVgIG11c3QgYmUgZWl0aGVyICd0d29fc2lkZScsICdncmVhdGVyJywgb3IgJ2xlc3MnLlwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG1lYW5zIGZvciBlYWNoIHNhbXBsZVxuICAgIHZhciBtZWFuWCA9IG1lYW4oc2FtcGxlWCk7XG4gICAgdmFyIG1lYW5ZID0gbWVhbihzYW1wbGVZKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBpbml0aWFsIHRlc3Qgc3RhdGlzdGljLiBUaGlzIHdpbGwgYmUgb3VyIHBvaW50IG9mIGNvbXBhcmlzb24gd2l0aFxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgdGVzdCBzdGF0aXN0aWNzLlxuICAgIHZhciB0ZXN0U3RhdGlzdGljID0gbWVhblggLSBtZWFuWTtcblxuICAgIC8vIGNyZWF0ZSB0ZXN0LXN0YXRpc3RpYyBkaXN0cmlidXRpb25cbiAgICB2YXIgdGVzdFN0YXREc24gPSBuZXcgQXJyYXkoayk7XG5cbiAgICAvLyBjb21iaW5lIGRhdHNldHMgc28gd2UgY2FuIGVhc2lseSBzaHVmZmxlIGxhdGVyXG4gICAgdmFyIGFsbERhdGEgPSBzYW1wbGVYLmNvbmNhdChzYW1wbGVZKTtcbiAgICB2YXIgbWlkSW5kZXggPSBNYXRoLmZsb29yKGFsbERhdGEubGVuZ3RoIC8gMik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAvLyAxLiBzaHVmZmxlIGRhdGEgYXNzaWdubWVudHNcbiAgICAgICAgc2h1ZmZsZUluUGxhY2UoYWxsRGF0YSwgcmFuZG9tU291cmNlKTtcbiAgICAgICAgdmFyIHBlcm1MZWZ0ID0gYWxsRGF0YS5zbGljZSgwLCBtaWRJbmRleCk7XG4gICAgICAgIHZhciBwZXJtUmlnaHQgPSBhbGxEYXRhLnNsaWNlKG1pZEluZGV4LCBhbGxEYXRhLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMi5yZS1jYWxjdWxhdGUgdGVzdCBzdGF0aXN0aWNcbiAgICAgICAgdmFyIHBlcm1UZXN0U3RhdGlzdGljID0gbWVhbihwZXJtTGVmdCkgLSBtZWFuKHBlcm1SaWdodCk7XG5cbiAgICAgICAgLy8gMy4gc3RvcmUgdGVzdCBzdGF0aXN0aWMgdG8gYnVpbGQgdGVzdCBzdGF0aXN0aWMgZGlzdHJpYnV0aW9uXG4gICAgICAgIHRlc3RTdGF0RHNuW2ldID0gcGVybVRlc3RTdGF0aXN0aWM7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHAtdmFsdWUgZGVwZW5kaW5nIG9uIGFsdGVybmF0aXZlXG4gICAgLy8gRm9yIHRoaXMgdGVzdCwgd2UgY2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIG9mICdleHRyZW1lJyB0ZXN0IHN0YXRpc3RpY3MgKHN1YmplY3QgdG8gb3VyIGh5cG90aGVzaXMpXG4gICAgLy8gbW9yZSBpbmZvIG9uIHBlcm11dGF0aW9uIHRlc3QgcC12YWx1ZSBjYWxjdWxhdGlvbnM6IGh0dHBzOi8vb25saW5lY291cnNlcy5zY2llbmNlLnBzdS5lZHUvc3RhdDQ2NC9ub2RlLzM1XG4gICAgdmFyIG51bUV4dHJlbWVUU3RhdHMgPSAwO1xuICAgIGlmIChhbHRlcm5hdGl2ZSA9PT0gXCJ0d29fc2lkZVwiKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8PSBrOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRlc3RTdGF0RHNuW2kkMV0pID49IE1hdGguYWJzKHRlc3RTdGF0aXN0aWMpKSB7XG4gICAgICAgICAgICAgICAgbnVtRXh0cmVtZVRTdGF0cyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRlcm5hdGl2ZSA9PT0gXCJncmVhdGVyXCIpIHtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDw9IGs7IGkkMisrKSB7XG4gICAgICAgICAgICBpZiAodGVzdFN0YXREc25baSQyXSA+PSB0ZXN0U3RhdGlzdGljKSB7XG4gICAgICAgICAgICAgICAgbnVtRXh0cmVtZVRTdGF0cyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWx0ZXJuYXRpdmUgPT09ICdsZXNzJ1xuICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPD0gazsgaSQzKyspIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRlc3RTdGF0RHNuW2kkM10gPD0gdGVzdFN0YXRpc3RpYykge1xuICAgICAgICAgICAgICAgIG51bUV4dHJlbWVUU3RhdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBlbmQgKi9cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1FeHRyZW1lVFN0YXRzIC8gaztcbn1cblxuLyoqXG4gKiBbU2lnbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvbikgaXMgYSBmdW5jdGlvblxuICogdGhhdCBleHRyYWN0cyB0aGUgc2lnbiBvZiBhIHJlYWwgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggaW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNpZ24gdmFsdWUgZWl0aGVyIDEsIDAgb3IgLTFcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgdGhlIGlucHV0IGFyZ3VtZW50IHggaXMgbm90IGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBzaWduKDIpOyAvLyA9PiAxXG4gKi9cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmICh4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIG51bWJlclwiKTtcbiAgICB9XG59XG5cbi8qKlxuICogW0Jpc2VjdGlvbiBtZXRob2RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jpc2VjdGlvbl9tZXRob2QpIGlzIGEgcm9vdC1maW5kaW5nXG4gKiBtZXRob2QgdGhhdCByZXBlYXRlZGx5IGJpc2VjdHMgYW4gaW50ZXJ2YWwgdG8gZmluZCB0aGUgcm9vdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBudW1lcmljYWwgYXBwcm94aW1hdGlvbiB0byB0aGUgZXhhY3QgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBpbnB1dCBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgb2YgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBlbmQgb2YgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJdGVyYXRpb25zIC0gdGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvclRvbGVyYW5jZSAtIHRoZSBlcnJvciB0b2xlcmFuY2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGVzdGltYXRlZCByb290IHZhbHVlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEFyZ3VtZW50IGZ1bmMgbXVzdCBiZSBhIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGJpc2VjdChNYXRoLmNvcywwLDQsMTAwLDAuMDAzKTsgLy8gPT4gMS41NzIyNjU2MjVcbiAqL1xuZnVuY3Rpb24gYmlzZWN0KGZ1bmMsIHN0YXJ0LCBlbmQsIG1heEl0ZXJhdGlvbnMsIGVycm9yVG9sZXJhbmNlKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZ1bmMgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZnVuYyhvdXRwdXQpID09PSAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicygoZW5kIC0gc3RhcnQpIC8gMikgPCBlcnJvclRvbGVyYW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lnbihmdW5jKG91dHB1dCkpID09PSBzaWduKGZ1bmMoc3RhcnQpKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBvdXRwdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIGV4Y2VlZGVkXCIpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsZWZ0IEZpcnN0IE4tZGltZW5zaW9uYWwgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHJpZ2h0IFNlY29uZCBOLWRpbWVuc2lvbmFsIHBvaW50LlxuICogQHJldHVybnMge251bWJlcn0gRGlzdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGV1Y2xpZGVhbkRpc3RhbmNlKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaWZmID0gbGVmdFtpXSAtIHJpZ2h0W2ldO1xuICAgICAgICBzdW0gKz0gZGlmZiAqIGRpZmY7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBrTWVhbnNSZXR1cm5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIFRoZSBsYWJlbHMuXG4gKiBAcHJvcGVydHkge0FycmF5PEFycmF5PG51bWJlcj4+fSBjZW50cm9pZHMgVGhlIGNsdXN0ZXIgY2VudHJvaWRzLlxuICovXG5cbi8qKlxuICogUGVyZm9ybSBrLW1lYW5zIGNsdXN0ZXJpbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzIHRvIGJlIGNsdXN0ZXJlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1DbHVzdGVyIEhvdyBtYW55IGNsdXN0ZXJzIHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJhbmRvbVNvdXJjZSBBbiBvcHRpb25hbCBlbnRyb3B5IHNvdXJjZSB0aGF0IGdlbmVyYXRlcyB1bmlmb3JtIHZhbHVlcyBpbiBbMCwgMSkuXG4gKiBAcmV0dXJuIHtrTWVhbnNSZXR1cm59IExhYmVscyAoc2FtZSBsZW5ndGggYXMgZGF0YSkgYW5kIGNlbnRyb2lkcyAoc2FtZSBsZW5ndGggYXMgbnVtQ2x1c3RlcikuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IGNlbnRyb2lkcyB3aW5kIHVwIGZyaWVuZGxlc3MgKGkuZS4sIHdpdGhvdXQgYXNzb2NpYXRlZCBwb2ludHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBrTWVhbnNDbHVzdGVyKFtbMC4wLCAwLjVdLCBbMS4wLCAwLjVdXSwgMik7IC8vID0+IHtsYWJlbHM6IFswLCAxXSwgY2VudHJvaWRzOiBbWzAuMCwgMC41XSwgWzEuMCAwLjVdXX1cbiAqL1xuZnVuY3Rpb24ga01lYW5zQ2x1c3Rlcihwb2ludHMsIG51bUNsdXN0ZXIsIHJhbmRvbVNvdXJjZSkge1xuICAgIGlmICggcmFuZG9tU291cmNlID09PSB2b2lkIDAgKSByYW5kb21Tb3VyY2UgPSBNYXRoLnJhbmRvbTtcblxuICAgIHZhciBvbGRDZW50cm9pZHMgPSBudWxsO1xuICAgIHZhciBuZXdDZW50cm9pZHMgPSBzYW1wbGUocG9pbnRzLCBudW1DbHVzdGVyLCByYW5kb21Tb3VyY2UpO1xuICAgIHZhciBsYWJlbHMgPSBudWxsO1xuICAgIHZhciBjaGFuZ2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHdoaWxlIChjaGFuZ2UgIT09IDApIHtcbiAgICAgICAgbGFiZWxzID0gbGFiZWxQb2ludHMocG9pbnRzLCBuZXdDZW50cm9pZHMpO1xuICAgICAgICBvbGRDZW50cm9pZHMgPSBuZXdDZW50cm9pZHM7XG4gICAgICAgIG5ld0NlbnRyb2lkcyA9IGNhbGN1bGF0ZUNlbnRyb2lkcyhwb2ludHMsIGxhYmVscywgbnVtQ2x1c3Rlcik7XG4gICAgICAgIGNoYW5nZSA9IGNhbGN1bGF0ZUNoYW5nZShuZXdDZW50cm9pZHMsIG9sZENlbnRyb2lkcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICBjZW50cm9pZHM6IG5ld0NlbnRyb2lkc1xuICAgIH07XG59XG5cbi8qKlxuICogTGFiZWwgZWFjaCBwb2ludCBhY2NvcmRpbmcgdG8gd2hpY2ggY2VudHJvaWQgaXQgaXMgY2xvc2VzdCB0by5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIEFycmF5IG9mIFhZIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY2VudHJvaWRzIEN1cnJlbnQgY2VudHJvaWRzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gR3JvdXAgbGFiZWxzLlxuICovXG5mdW5jdGlvbiBsYWJlbFBvaW50cyhwb2ludHMsIGNlbnRyb2lkcykge1xuICAgIHJldHVybiBwb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGxhYmVsID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2VudHJvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IGV1Y2xpZGVhbkRpc3RhbmNlKHAsIGNlbnRyb2lkc1tpXSk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBjZW50cm9pZHMgZm9yIHBvaW50cyBnaXZlbiBsYWJlbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBBcnJheSBvZiBYWSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIFdoaWNoIGdyb3VwcyBwb2ludHMgYmVsb25nIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bUNsdXN0ZXIgTnVtYmVyIG9mIGNsdXN0ZXJzIGJlaW5nIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQ2VudHJvaWQgZm9yIGVhY2ggZ3JvdXAuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IGNlbnRyb2lkcyB3aW5kIHVwIGZyaWVuZGxlc3MgKGkuZS4sIHdpdGhvdXQgYXNzb2NpYXRlZCBwb2ludHMpLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDZW50cm9pZHMocG9pbnRzLCBsYWJlbHMsIG51bUNsdXN0ZXIpIHtcbiAgICAvLyBJbml0aWFsaXplIGFjY3VtdWxhdG9ycy5cbiAgICB2YXIgZGltZW5zaW9uID0gcG9pbnRzWzBdLmxlbmd0aDtcbiAgICB2YXIgY2VudHJvaWRzID0gbWFrZU1hdHJpeChudW1DbHVzdGVyLCBkaW1lbnNpb24pO1xuICAgIHZhciBjb3VudHMgPSBBcnJheShudW1DbHVzdGVyKS5maWxsKDApO1xuXG4gICAgLy8gQWRkIHBvaW50cyB0byBjZW50cm9pZHMnIGFjY3VtdWxhdG9ycyBhbmQgY291bnQgcG9pbnRzIHBlciBjZW50cm9pZC5cbiAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICB2YXIgY3VycmVudCA9IGNlbnRyb2lkc1tsYWJlbF07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRbal0gKz0gcG9pbnRbal07XG4gICAgICAgIH1cbiAgICAgICAgY291bnRzW2xhYmVsXSArPSAxO1xuICAgIH1cblxuICAgIC8vIFJlc2NhbGUgY2VudHJvaWRzLCBjaGVja2luZyBmb3IgYW55IHRoYXQgaGF2ZSBubyBwb2ludHMuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbnVtQ2x1c3RlcjsgaSQxKyspIHtcbiAgICAgICAgaWYgKGNvdW50c1tpJDFdID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiQ2VudHJvaWQgXCIgKyBpJDEgKyBcIiBoYXMgbm8gZnJpZW5kc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRzW2kkMV07XG4gICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGRpbWVuc2lvbjsgaiQxKyspIHtcbiAgICAgICAgICAgIGNlbnRyb2lkW2okMV0gLz0gY291bnRzW2kkMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VudHJvaWRzO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9sZCBjZW50cm9pZHMgYW5kIG5ldyBjZW50cm9pZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGxlZnQgT25lIGxpc3Qgb2YgY2VudHJvaWRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcmlnaHQgQW5vdGhlciBsaXN0IG9mIGNlbnRyb2lkcy5cbiAqIEByZXR1cm4ge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiBjZW50cm9pZHMuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNoYW5nZShsZWZ0LCByaWdodCkge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsICs9IGV1Y2xpZGVhbkRpc3RhbmNlKGxlZnRbaV0sIHJpZ2h0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgW3NpbGhvdWV0dGUgdmFsdWVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWxob3VldHRlXyhjbHVzdGVyaW5nKSlcbiAqIGZvciBjbHVzdGVyZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwb2ludHMgTi1kaW1lbnNpb25hbCBjb29yZGluYXRlcyBvZiBwb2ludHMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGxhYmVscyBMYWJlbHMgb2YgcG9pbnRzLiBUaGlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIGBwb2ludHNgLFxuICogYW5kIHZhbHVlcyBtdXN0IGxpZSBpbiBbMC4uRy0xXSwgd2hlcmUgRyBpcyB0aGUgbnVtYmVyIG9mIGdyb3Vwcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzaWxob3VldHRlIHZhbHVlIGZvciBlYWNoIHBvaW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBzaWxob3VldHRlKFtbMC4yNV0sIFswLjc1XV0sIFswLCAwXSk7IC8vID0+IFsxLjAsIDEuMF1cbiAqL1xuZnVuY3Rpb24gc2lsaG91ZXR0ZShwb2ludHMsIGxhYmVscykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoICE9PSBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgaGF2ZSBleGFjdGx5IGFzIG1hbnkgbGFiZWxzIGFzIHBvaW50c1wiKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwaW5ncyA9IGNyZWF0ZUdyb3VwcyhsYWJlbHMpO1xuICAgIHZhciBkaXN0YW5jZXMgPSBjYWxjdWxhdGVBbGxEaXN0YW5jZXMocG9pbnRzKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICBpZiAoZ3JvdXBpbmdzW2xhYmVsc1tpXV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGEgPSBtZWFuRGlzdGFuY2VGcm9tUG9pbnRUb0dyb3VwKFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdzW2xhYmVsc1tpXV0sXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGIgPSBtZWFuRGlzdGFuY2VUb05lYXJlc3RHcm91cChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGxhYmVscyxcbiAgICAgICAgICAgICAgICBncm91cGluZ3MsXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcyA9IChiIC0gYSkgLyBNYXRoLm1heChhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsb29rdXAgdGFibGUgbWFwcGluZyBncm91cCBJRHMgdG8gcG9pbnQgSURzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGxhYmVscyBMYWJlbHMgb2YgcG9pbnRzLiBUaGlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIGBwb2ludHNgLFxuICogYW5kIHZhbHVlcyBtdXN0IGxpZSBpbiBbMC4uRy0xXSwgd2hlcmUgRyBpcyB0aGUgbnVtYmVyIG9mIGdyb3Vwcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBBbiBhcnJheSBvZiBsZW5ndGggRywgZWFjaCBvZiB3aG9zZSBlbnRyaWVzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSBwb2ludHMgaW4gdGhhdCBncm91cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlR3JvdXBzKGxhYmVscykge1xuICAgIHZhciBudW1Hcm91cHMgPSAxICsgbWF4KGxhYmVscyk7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KG51bUdyb3Vwcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICBpZiAocmVzdWx0W2xhYmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRbbGFiZWxdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2xhYmVsXS5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxvb2t1cCB0YWJsZSBvZiBhbGwgaW50ZXItcG9pbnQgZGlzdGFuY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwb2ludHMgTi1kaW1lbnNpb25hbCBjb29yZGluYXRlcyBvZiBwb2ludHMuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQSBzeW1tZXRyaWMgc3F1YXJlIGFycmF5IG9mIGludGVyLXBvaW50IGRpc3RhbmNlc1xuICogKHplcm8gb24gdGhlIGRpYWdvbmFsKS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQWxsRGlzdGFuY2VzKHBvaW50cykge1xuICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBtYWtlTWF0cml4KG51bVBvaW50cywgbnVtUG9pbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV1bal0gPSBldWNsaWRlYW5EaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tqXSk7XG4gICAgICAgICAgICByZXN1bHRbal1baV0gPSByZXN1bHRbaV1bal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1lYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbGwgdGhlIHBvaW50cyBpbiB0aGVcbiAqIG5lYXJlc3QgZ3JvdXAgKGFzIGRldGVybWluZWQgYnkgd2hpY2ggcG9pbnQgaW4gYW5vdGhlciBncm91cCBpcyBjbG9zZXN0KS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHdoaWNoIFRoZSBpbmRleCBvZiB0aGlzIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGdyb3VwaW5ncyBBbiBhcnJheSB3aG9zZSBlbnRyaWVzIGFyZSBhcnJheXNcbiAqIGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHBvaW50cyBpbiB0aGF0IGdyb3VwLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGlzdGFuY2VzIEEgc3ltbWV0cmljIHNxdWFyZSBhcnJheSBvZiBpbnRlci1wb2ludFxuICogZGlzdGFuY2VzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWVhbiBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgdG8gb3RoZXJzIGluIHRoZSBuZWFyZXN0XG4gKiBncm91cC5cbiAqL1xuZnVuY3Rpb24gbWVhbkRpc3RhbmNlVG9OZWFyZXN0R3JvdXAod2hpY2gsIGxhYmVscywgZ3JvdXBpbmdzLCBkaXN0YW5jZXMpIHtcbiAgICB2YXIgbGFiZWwgPSBsYWJlbHNbd2hpY2hdO1xuICAgIHZhciByZXN1bHQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGQgPSBtZWFuRGlzdGFuY2VGcm9tUG9pbnRUb0dyb3VwKFxuICAgICAgICAgICAgICAgIHdoaWNoLFxuICAgICAgICAgICAgICAgIGdyb3VwaW5nc1tpXSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZCA8IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1lYW4gZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50IGFuZCBhbGwgdGhlIHBvaW50cyBpbiBhIGdyb3VwXG4gKiAocG9zc2libHkgaXRzIG93bikuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aGljaCBUaGUgaW5kZXggb2YgdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZ3JvdXAgVGhlIGluZGljZXMgb2YgYWxsIHRoZSBwb2ludHMgaW4gdGhlIGdyb3VwIGluXG4gKiBxdWVzdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRpc3RhbmNlcyBBIHN5bW1ldHJpYyBzcXVhcmUgYXJyYXkgb2YgaW50ZXItcG9pbnRcbiAqIGRpc3RhbmNlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1lYW4gZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIG90aGVycyBpbiB0aGVcbiAqIHNwZWNpZmllZCBncm91cC5cbiAqL1xuZnVuY3Rpb24gbWVhbkRpc3RhbmNlRnJvbVBvaW50VG9Hcm91cCh3aGljaCwgZ3JvdXAsIGRpc3RhbmNlcykge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBkaXN0YW5jZXNbd2hpY2hdW2dyb3VwW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsIC8gZ3JvdXAubGVuZ3RoO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgW3NpbGhvdWV0dGUgbWV0cmljXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWxob3VldHRlXyhjbHVzdGVyaW5nKSlcbiAqIGZvciBhIHNldCBvZiBOLWRpbWVuc2lvbmFsIHBvaW50cyBhcnJhbmdlZCBpbiBncm91cHMuIFRoZSBtZXRyaWMgaXMgdGhlIGxhcmdlc3RcbiAqIGluZGl2aWR1YWwgc2lsaG91ZXR0ZSB2YWx1ZSBmb3IgdGhlIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy4gVGhpcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBhcyBgcG9pbnRzYCxcbiAqIGFuZCB2YWx1ZXMgbXVzdCBsaWUgaW4gWzAuLkctMV0sIHdoZXJlIEcgaXMgdGhlIG51bWJlciBvZiBncm91cHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaWxob3VldHRlIG1ldHJpYyBmb3IgdGhlIGdyb3VwaW5ncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogc2lsaG91ZXR0ZU1ldHJpYyhbWzAuMjVdLCBbMC43NV1dLCBbMCwgMF0pOyAvLyA9PiAxLjBcbiAqL1xuZnVuY3Rpb24gc2lsaG91ZXR0ZU1ldHJpYyhwb2ludHMsIGxhYmVscykge1xuICAgIHZhciB2YWx1ZXMgPSBzaWxob3VldHRlKHBvaW50cywgbGFiZWxzKTtcbiAgICByZXR1cm4gbWF4KHZhbHVlcyk7XG59XG5cbi8qKlxuICogUmVsYXRpdmUgZXJyb3IuXG4gKlxuICogVGhpcyBpcyBtb3JlIGRpZmZpY3VsdCB0byBjYWxjdWxhdGUgdGhhbiBpdCBmaXJzdCBhcHBlYXJzIFsxLDJdLiAgVGhlIHVzdWFsXG4gKiBmb3JtdWxhIGZvciB0aGUgcmVsYXRpdmUgZXJyb3IgYmV0d2VlbiBhbiBhY3R1YWwgdmFsdWUgQSBhbmQgYW4gZXhwZWN0ZWRcbiAqIHZhbHVlIEUgaXMgYHwoQS1FKS9FfGAsIGJ1dDpcbiAqXG4gKiAxLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgMCwgYW55IG90aGVyIHZhbHVlIGhhcyBpbmZpbml0ZSByZWxhdGl2ZSBlcnJvcixcbiAqICAgIHdoaWNoIGlzIGNvdW50ZXItaW50dWl0aXZlOiBpZiB0aGUgZXhwZWN0ZWQgdm9sdGFnZSBpcyAwLCBnZXR0aW5nIDEvMTB0aFxuICogICAgb2YgYSB2b2x0IGRvZXNuJ3QgZmVlbCBsaWtlIGFuIGluZmluaXRlbHkgbGFyZ2UgZXJyb3IuXG4gKlxuICogMi4gVGhpcyBmb3JtdWxhIGRvZXMgbm90IHNhdGlzZnkgdGhlIG1hdGhlbWF0aWNhbCBkZWZpbml0aW9uIG9mIGEgbWV0cmljIFszXS5cbiAqICAgIFs0XSBzb2x2ZWQgdGhpcyBwcm9ibGVtIGJ5IGRlZmluaW5nIHRoZSByZWxhdGl2ZSBlcnJvciBhcyBgfGxuKHxBL0V8KXxgLFxuICogICAgYnV0IHRoYXQgZm9ybXVsYSBvbmx5IHdvcmtzIGlmIGFsbCB2YWx1ZXMgYXJlIHBvc2l0aXZlOiBmb3IgZXhhbXBsZSwgaXRcbiAqICAgIHJlcG9ydHMgdGhlIHJlbGF0aXZlIGVycm9yIG9mIC0xMCBhbmQgMTAgYXMgMC5cbiAqXG4gKiBPdXIgaW1wbGVtZW50YXRpb24gc3RpY2tzIHdpdGggY29udmVudGlvbiBhbmQgcmV0dXJuczpcbiAqXG4gKiAtIDAgaWYgdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIGFyZSBib3RoIHplcm9cbiAqIC0gSW5maW5pdHkgaWYgdGhlIGFjdHVhbCB2YWx1ZSBpcyBub24temVybyBhbmQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIHplcm9cbiAqIC0gYHwoQS1FKS9FfGAgaW4gYWxsIG90aGVyIGNhc2VzXG4gKlxuICogWzFdIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNjc3ODUyL2hvdy10by1jYWxjdWxhdGUtcmVsYXRpdmUtZXJyb3Itd2hlbi10cnVlLXZhbHVlLWlzLXplcm9cbiAqIFsyXSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZWxhdGl2ZV9jaGFuZ2VfYW5kX2RpZmZlcmVuY2VcbiAqIFszXSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXRyaWNfKG1hdGhlbWF0aWNzKSNEZWZpbml0aW9uXG4gKiBbNF0gRi5XLkouIE9sdmVyOiBcIkEgTmV3IEFwcHJvYWNoIHRvIEVycm9yIEFyaXRobWV0aWMuXCIgU0lBTSBKb3VybmFsIG9uXG4gKiAgICAgTnVtZXJpY2FsIEFuYWx5c2lzLCAxNSgyKSwgMTk3OCwgMTAuMTEzNy8wNzE1MDI0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWwgVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCBUaGUgZXhwZWN0ZWQgdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWxhdGl2ZSBlcnJvci5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmVFcnJvcihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgLy8gVGhlc2UgbGluZXMgYXJlIGFjdHVhbGx5IGNvdmVyZWQgYnkgdGVzdHMsIGJ1dCBpdCBzZWVtc1xuICAgIC8vIGxpa2UgYzggaGFzIGEgYnVnIHRoYXQgbWFya3MgdGhlbSBhcyBub3QgY292ZXJlZC5cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAoYWN0dWFsID09PSAwICYmIGV4cGVjdGVkID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgZW5kICovXG4gICAgcmV0dXJuIE1hdGguYWJzKChhY3R1YWwgLSBleHBlY3RlZCkgLyBleHBlY3RlZCk7XG59XG5cbi8qKlxuICogQXBwcm94aW1hdGUgZXF1YWxpdHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFjdHVhbCBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkIFRoZSByZWZlcmVuY2UgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRoZSBhY2NlcHRhYmxlIHJlbGF0aXZlIGRpZmZlcmVuY2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG51bWJlcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gKi9cbmZ1bmN0aW9uIGFwcHJveEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRvbGVyYW5jZSkge1xuICAgIGlmICggdG9sZXJhbmNlID09PSB2b2lkIDAgKSB0b2xlcmFuY2UgPSBlcHNpbG9uO1xuXG4gICAgcmV0dXJuIHJlbGF0aXZlRXJyb3IoYWN0dWFsLCBleHBlY3RlZCkgPD0gdG9sZXJhbmNlO1xufVxuXG5leHBvcnQgeyBCYXllc2lhbkNsYXNzaWZpZXIsIFBlcmNlcHRyb25Nb2RlbCwgYWRkVG9NZWFuLCBhcHByb3hFcXVhbCwgbWVhbiBhcyBhdmVyYWdlLCBtZWFuU2ltcGxlIGFzIGF2ZXJhZ2VTaW1wbGUsIEJheWVzaWFuQ2xhc3NpZmllciBhcyBiYXllc2lhbiwgYmVybm91bGxpRGlzdHJpYnV0aW9uLCBiaW5vbWlhbERpc3RyaWJ1dGlvbiwgYmlzZWN0LCBjaGlTcXVhcmVkRGlzdHJpYnV0aW9uVGFibGUsIGNoaVNxdWFyZWRHb29kbmVzc09mRml0LCBjaHVuaywgY2ttZWFucywgY29lZmZpY2llbnRPZlZhcmlhdGlvbiwgY29tYmluYXRpb25zLCBjb21iaW5hdGlvbnNSZXBsYWNlbWVudCwgY29tYmluZU1lYW5zLCBjb21iaW5lVmFyaWFuY2VzLCBjdW11bGF0aXZlU3RkTG9naXN0aWNQcm9iYWJpbGl0eSwgY3VtdWxhdGl2ZVN0ZE5vcm1hbFByb2JhYmlsaXR5LCBlcHNpbG9uLCBlcXVhbEludGVydmFsQnJlYWtzLCBlcnJvckZ1bmN0aW9uIGFzIGVyZiwgZXJyb3JGdW5jdGlvbiwgZXh0ZW50LCBleHRlbnRTb3J0ZWQsIGZhY3RvcmlhbCwgZ2FtbWEsIGdhbW1hbG4sIGdlb21ldHJpY01lYW4sIGhhcm1vbmljTWVhbiwgaW50ZXJxdWFydGlsZVJhbmdlLCBpbnZlcnNlRXJyb3JGdW5jdGlvbiwgaW50ZXJxdWFydGlsZVJhbmdlIGFzIGlxciwgamVua3MsIGtNZWFuc0NsdXN0ZXIsIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uIGFzIGtkZSwga2VybmVsRGVuc2l0eUVzdGltYXRpb24sIGxpbmVhclJlZ3Jlc3Npb24sIGxpbmVhclJlZ3Jlc3Npb25MaW5lLCBsb2dBdmVyYWdlLCBsb2dpdCwgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb24gYXMgbWFkLCBtYXgsIG1heFNvcnRlZCwgbWVhbiwgbWVhblNpbXBsZSwgbWVkaWFuLCBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbiwgbWVkaWFuU29ydGVkLCBtaW4sIG1pblNvcnRlZCwgbW9kZSwgbW9kZUZhc3QsIG1vZGVTb3J0ZWQsIG51bWVyaWNTb3J0LCBQZXJjZXB0cm9uTW9kZWwgYXMgcGVyY2VwdHJvbiwgcGVybXV0YXRpb25UZXN0LCBwZXJtdXRhdGlvbnNIZWFwLCBwb2lzc29uRGlzdHJpYnV0aW9uLCBwcm9iaXQsIHByb2R1Y3QsIHF1YW50aWxlLCBxdWFudGlsZVJhbmssIHF1YW50aWxlUmFua1NvcnRlZCwgcXVhbnRpbGVTb3J0ZWQsIHF1aWNrc2VsZWN0LCByU3F1YXJlZCwgcmVsYXRpdmVFcnJvciwgcm9vdE1lYW5TcXVhcmUgYXMgcm1zLCByb290TWVhblNxdWFyZSwgc2FtcGxlLCBzYW1wbGVDb3JyZWxhdGlvbiwgc2FtcGxlQ292YXJpYW5jZSwgc2FtcGxlS3VydG9zaXMsIHNhbXBsZVJhbmtDb3JyZWxhdGlvbiwgc2FtcGxlU2tld25lc3MsIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uLCBzYW1wbGVWYXJpYW5jZSwgc2FtcGxlV2l0aFJlcGxhY2VtZW50LCBzaHVmZmxlLCBzaHVmZmxlSW5QbGFjZSwgc2lnbiwgc2lsaG91ZXR0ZSwgc2lsaG91ZXR0ZU1ldHJpYywgc3RhbmRhcmREZXZpYXRpb24sIHN0YW5kYXJkTm9ybWFsVGFibGUsIHN1YnRyYWN0RnJvbU1lYW4sIHN1bSwgc3VtTnRoUG93ZXJEZXZpYXRpb25zLCBzdW1TaW1wbGUsIHRUZXN0LCB0VGVzdFR3b1NhbXBsZSwgdW5pcXVlQ291bnRTb3J0ZWQsIHZhcmlhbmNlLCB3aWxjb3hvblJhbmtTdW0sIHpTY29yZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxlLXN0YXRpc3RpY3MubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cbiAgY3NzICs9IG9iai5jc3M7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH1cblxuICAvLyBGb3Igb2xkIElFXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCJpbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIgdCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLCBrZXksXG4gICAgICB4MCA9IEluZmluaXR5LCB5MCA9IHgwLCB4MSA9IC14MCwgeTEgPSAteDA7XG5cbiAgZnVuY3Rpb24gYmJveFBvaW50KHApIHtcbiAgICBwID0gdChwKTtcbiAgICBpZiAocFswXSA8IHgwKSB4MCA9IHBbMF07XG4gICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICBpZiAocFsxXSA+IHkxKSB5MSA9IHBbMV07XG4gIH1cblxuICBmdW5jdGlvbiBiYm94R2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG8uZ2VvbWV0cmllcy5mb3JFYWNoKGJib3hHZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGJib3hQb2ludChvLmNvb3JkaW5hdGVzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvLmNvb3JkaW5hdGVzLmZvckVhY2goYmJveFBvaW50KTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcmMubGVuZ3RoLCBwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwID0gdChhcmNbaV0sIGkpO1xuICAgICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgICAgaWYgKHBbMV0gPCB5MCkgeTAgPSBwWzFdO1xuICAgICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChrZXkgaW4gdG9wb2xvZ3kub2JqZWN0cykge1xuICAgIGJib3hHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIFt4MCwgeTAsIHgxLCB5MV07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCB4KSB7XG4gIHZhciBsbyA9IDAsIGhpID0gYS5sZW5ndGg7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKGFbbWlkXSA8IHgpIGxvID0gbWlkICsgMTtcbiAgICBlbHNlIGhpID0gbWlkO1xuICB9XG4gIHJldHVybiBsbztcbn1cbiIsImltcG9ydCByZXZlcnNlIGZyb20gXCIuL3JldmVyc2UuanNcIjtcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCBvKSB7XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgbyA9IHRvcG9sb2d5Lm9iamVjdHNbb107XG4gIHJldHVybiBvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCJcbiAgICAgID8ge3R5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIiwgZmVhdHVyZXM6IG8uZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24obykgeyByZXR1cm4gZmVhdHVyZSh0b3BvbG9neSwgbyk7IH0pfVxuICAgICAgOiBmZWF0dXJlKHRvcG9sb2d5LCBvKTtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZSh0b3BvbG9neSwgbykge1xuICB2YXIgaWQgPSBvLmlkLFxuICAgICAgYmJveCA9IG8uYmJveCxcbiAgICAgIHByb3BlcnRpZXMgPSBvLnByb3BlcnRpZXMgPT0gbnVsbCA/IHt9IDogby5wcm9wZXJ0aWVzLFxuICAgICAgZ2VvbWV0cnkgPSBvYmplY3QodG9wb2xvZ3ksIG8pO1xuICByZXR1cm4gaWQgPT0gbnVsbCAmJiBiYm94ID09IG51bGwgPyB7dHlwZTogXCJGZWF0dXJlXCIsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDogYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDoge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIGJib3g6IGJib3gsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIHRyYW5zZm9ybVBvaW50ID0gdHJhbnNmb3JtKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICBmdW5jdGlvbiBhcmMoaSwgcG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGgpIHBvaW50cy5wb3AoKTtcbiAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGg7IGsgPCBuOyArK2spIHtcbiAgICAgIHBvaW50cy5wdXNoKHRyYW5zZm9ybVBvaW50KGFba10sIGspKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludChwKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBvaW50KHApO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIGFyYyhhcmNzW2ldLCBwb2ludHMpO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0pOyAvLyBUaGlzIG1heSBoYXBwZW4gaWYgYW4gYXJjIGhhcyBvbmx5IHR3byBwb2ludHMuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICB2YXIgdHlwZSA9IG8udHlwZSwgY29vcmRpbmF0ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IHJldHVybiB7dHlwZTogdHlwZSwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9O1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGNvb3JkaW5hdGVzID0gcG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogY29vcmRpbmF0ZXMgPSBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBsaW5lKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAobGluZSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBwb2x5Z29uKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAocG9seWdvbik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogdHlwZSwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeShvKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYmJveH0gZnJvbSBcIi4vYmJveC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZlYXR1cmV9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXNoLCBtZXNoQXJjc30gZnJvbSBcIi4vbWVzaC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lcmdlLCBtZXJnZUFyY3N9IGZyb20gXCIuL21lcmdlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmVpZ2hib3JzfSBmcm9tIFwiLi9uZWlnaGJvcnMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBxdWFudGl6ZX0gZnJvbSBcIi4vcXVhbnRpemUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHVudHJhbnNmb3JtfSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmZ1bmN0aW9uIHBsYW5hclJpbmdBcmVhKHJpbmcpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IHJpbmcubGVuZ3RoLCBhLCBiID0gcmluZ1tuIC0gMV0sIGFyZWEgPSAwO1xuICB3aGlsZSAoKytpIDwgbikgYSA9IGIsIGIgPSByaW5nW2ldLCBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIHJldHVybiBNYXRoLmFicyhhcmVhKTsgLy8gTm90ZTogZG91YmxlZCBhcmVhIVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXJnZUFyY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICBncm91cHMgPSBbXTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogZXh0cmFjdChvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogby5hcmNzLmZvckVhY2goZXh0cmFjdCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QocG9seWdvbikge1xuICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgIChwb2x5Z29uc0J5QXJjW2FyYyA9IGFyYyA8IDAgPyB+YXJjIDogYXJjXSB8fCAocG9seWdvbnNCeUFyY1thcmNdID0gW10pKS5wdXNoKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWEocmluZykge1xuICAgIHJldHVybiBwbGFuYXJSaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pO1xuICB9XG5cbiAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICBncm91cC5wdXNoKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBhcmNzOiBncm91cHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICB2YXIgYXJjcyA9IFtdLCBuO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBleHRlcmlvciAodW5pcXVlKSBhcmNzLlxuICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgYXJjcyA9IHN0aXRjaCh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgcmluZyBpcyByZXR1cm5lZCxcbiAgICAgIC8vIGF0IG1vc3Qgb25lIG9mIHRoZXNlIHJpbmdzIGNhbiBiZSB0aGUgZXh0ZXJpb3I7XG4gICAgICAvLyBjaG9vc2UgdGhlIG9uZSB3aXRoIHRoZSBncmVhdGVzdCBhYnNvbHV0ZSBhcmVhLlxuICAgICAgaWYgKChuID0gYXJjcy5sZW5ndGgpID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgayA9IGFyZWEoYXJjc1swXSksIGtpLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKChraSA9IGFyZWEoYXJjc1tpXSkpID4gaykge1xuICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdCwgayA9IGtpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubGVuZ3RoID4gMDtcbiAgICB9KVxuICB9O1xufVxuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5KSB7XG4gIHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lc2hBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVzaEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKSB7XG4gIHZhciBhcmNzLCBpLCBuO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGFyY3MgPSBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpO1xuICBlbHNlIGZvciAoaSA9IDAsIGFyY3MgPSBuZXcgQXJyYXkobiA9IHRvcG9sb2d5LmFyY3MubGVuZ3RoKTsgaSA8IG47ICsraSkgYXJjc1tpXSA9IGk7XG4gIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoKHRvcG9sb2d5LCBhcmNzKX07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcyA9IFtdLFxuICAgICAgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgZ2VvbTtcblxuICBmdW5jdGlvbiBleHRyYWN0MChpKSB7XG4gICAgdmFyIGogPSBpIDwgMCA/IH5pIDogaTtcbiAgICAoZ2VvbXNCeUFyY1tqXSB8fCAoZ2VvbXNCeUFyY1tqXSA9IFtdKSkucHVzaCh7aTogaSwgZzogZ2VvbX0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDEoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MihhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QzKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoZ2VvbSA9IG8sIG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogZXh0cmFjdDEoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6IGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3QyKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBleHRyYWN0MyhvLmFyY3MpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBnZW9tZXRyeShvYmplY3QpO1xuXG4gIGdlb21zQnlBcmMuZm9yRWFjaChmaWx0ZXIgPT0gbnVsbFxuICAgICAgPyBmdW5jdGlvbihnZW9tcykgeyBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH1cbiAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcblxuICByZXR1cm4gYXJjcztcbn1cbiIsImltcG9ydCBiaXNlY3QgZnJvbSBcIi4vYmlzZWN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgdmFyIGluZGV4ZXNCeUFyYyA9IHt9LCAvLyBhcmMgaW5kZXggLT4gYXJyYXkgb2Ygb2JqZWN0IGluZGV4ZXNcbiAgICAgIG5laWdoYm9ycyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoYSA8IDApIGEgPSB+YTtcbiAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgaWYgKG8pIG8ucHVzaChpKTtcbiAgICAgIGVsc2UgaW5kZXhlc0J5QXJjW2FdID0gW2ldO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9seWdvbihhcmNzLCBpKSB7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobywgaSkge1xuICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcywgaSk7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBwb2x5Z29uLFxuICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzLCBpKSB7IGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgcG9seWdvbihhcmMsIGkpOyB9KTsgfVxuICB9O1xuXG4gIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgZm9yICh2YXIgaSBpbiBpbmRleGVzQnlBcmMpIHtcbiAgICBmb3IgKHZhciBpbmRleGVzID0gaW5kZXhlc0J5QXJjW2ldLCBtID0gaW5kZXhlcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgdmFyIGlqID0gaW5kZXhlc1tqXSwgaWsgPSBpbmRleGVzW2tdLCBuO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWpdKVtpID0gYmlzZWN0KG4sIGlrKV0gIT09IGlrKSBuLnNwbGljZShpLCAwLCBpayk7XG4gICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVpZ2hib3JzO1xufVxuIiwiaW1wb3J0IGJib3ggZnJvbSBcIi4vYmJveC5qc1wiO1xuaW1wb3J0IHVudHJhbnNmb3JtIGZyb20gXCIuL3VudHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBxdWFudGl6ZWRcIik7XG5cbiAgaWYgKCF0cmFuc2Zvcm0gfHwgIXRyYW5zZm9ybS5zY2FsZSkge1xuICAgIGlmICghKChuID0gTWF0aC5mbG9vcih0cmFuc2Zvcm0pKSA+PSAyKSkgdGhyb3cgbmV3IEVycm9yKFwibiBtdXN0IGJlIOKJpTJcIik7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveCB8fCBiYm94KHRvcG9sb2d5KTtcbiAgICB2YXIgeDAgPSBib3hbMF0sIHkwID0gYm94WzFdLCB4MSA9IGJveFsyXSwgeTEgPSBib3hbM10sIG47XG4gICAgdHJhbnNmb3JtID0ge3NjYWxlOiBbeDEgLSB4MCA/ICh4MSAtIHgwKSAvIChuIC0gMSkgOiAxLCB5MSAtIHkwID8gKHkxIC0geTApIC8gKG4gLSAxKSA6IDFdLCB0cmFuc2xhdGU6IFt4MCwgeTBdfTtcbiAgfSBlbHNlIHtcbiAgICBib3ggPSB0b3BvbG9neS5iYm94O1xuICB9XG5cbiAgdmFyIHQgPSB1bnRyYW5zZm9ybSh0cmFuc2Zvcm0pLCBib3gsIGtleSwgaW5wdXRzID0gdG9wb2xvZ3kub2JqZWN0cywgb3V0cHV0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHF1YW50aXplUG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4gdChwb2ludCk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUdlb21ldHJ5KGlucHV0KSB7XG4gICAgdmFyIG91dHB1dDtcbiAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogb3V0cHV0ID0ge3R5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsIGdlb21ldHJpZXM6IGlucHV0Lmdlb21ldHJpZXMubWFwKHF1YW50aXplR2VvbWV0cnkpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiUG9pbnRcIiwgY29vcmRpbmF0ZXM6IHF1YW50aXplUG9pbnQoaW5wdXQuY29vcmRpbmF0ZXMpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvdXRwdXQgPSB7dHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBpbnB1dC5jb29yZGluYXRlcy5tYXAocXVhbnRpemVQb2ludCl9OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKGlucHV0LmlkICE9IG51bGwpIG91dHB1dC5pZCA9IGlucHV0LmlkO1xuICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpIG91dHB1dC5iYm94ID0gaW5wdXQuYmJveDtcbiAgICBpZiAoaW5wdXQucHJvcGVydGllcyAhPSBudWxsKSBvdXRwdXQucHJvcGVydGllcyA9IGlucHV0LnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50aXplQXJjKGlucHV0KSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMSwgbiA9IGlucHV0Lmxlbmd0aCwgcCwgb3V0cHV0ID0gbmV3IEFycmF5KG4pOyAvLyBwZXNzaW1pc3RpY1xuICAgIG91dHB1dFswXSA9IHQoaW5wdXRbMF0sIDApO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHAgPSB0KGlucHV0W2ldLCBpKSlbMF0gfHwgcFsxXSkgb3V0cHV0W2orK10gPSBwOyAvLyBub24tY29pbmNpZGVudCBwb2ludHNcbiAgICBpZiAoaiA9PT0gMSkgb3V0cHV0W2orK10gPSBbMCwgMF07IC8vIGFuIGFyYyBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgIG91dHB1dC5sZW5ndGggPSBqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmb3IgKGtleSBpbiBpbnB1dHMpIG91dHB1dHNba2V5XSA9IHF1YW50aXplR2VvbWV0cnkoaW5wdXRzW2tleV0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUb3BvbG9neVwiLFxuICAgIGJib3g6IGJveCxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBvYmplY3RzOiBvdXRwdXRzLFxuICAgIGFyY3M6IHRvcG9sb2d5LmFyY3MubWFwKHF1YW50aXplQXJjKVxuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIG4pIHtcbiAgdmFyIHQsIGogPSBhcnJheS5sZW5ndGgsIGkgPSBqIC0gbjtcbiAgd2hpbGUgKGkgPCAtLWopIHQgPSBhcnJheVtpXSwgYXJyYXlbaSsrXSA9IGFycmF5W2pdLCBhcnJheVtqXSA9IHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgYXJjcykge1xuICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICBmcmFnbWVudEJ5U3RhcnQgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlFbmQgPSB7fSxcbiAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgZW1wdHlJbmRleCA9IC0xO1xuXG4gIC8vIFN0aXRjaCBlbXB0eSBhcmNzIGZpcnN0LCBzaW5jZSB0aGV5IG1heSBiZSBzdWJzdW1lZCBieSBvdGhlciBhcmNzLlxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgdDtcbiAgICBpZiAoYXJjLmxlbmd0aCA8IDMgJiYgIWFyY1sxXVswXSAmJiAhYXJjWzFdWzFdKSB7XG4gICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgfVxuICB9KTtcblxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHZhciBlID0gZW5kcyhpKSxcbiAgICAgICAgc3RhcnQgPSBlWzBdLFxuICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICBmLCBnO1xuXG4gICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgZi5wdXNoKGkpO1xuICAgICAgZi5lbmQgPSBlbmQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XG4gICAgICAgIHZhciBmZyA9IGcgPT09IGYgPyBmIDogZi5jb25jYXQoZyk7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgIGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICB2YXIgZ2YgPSBnID09PSBmID8gZiA6IGcuY29uY2F0KGYpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZ2Yuc3RhcnQgPSBnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZ2YuZW5kID0gZi5lbmRdID0gZ2Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSBbaV07XG4gICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRdID0gZjtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuZHMoaSkge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHAxID0gWzAsIDBdLCBhcmMuZm9yRWFjaChmdW5jdGlvbihkcCkgeyBwMVswXSArPSBkcFswXSwgcDFbMV0gKz0gZHBbMV07IH0pO1xuICAgIGVsc2UgcDEgPSBhcmNbYXJjLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpIHtcbiAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgIHZhciBmID0gZnJhZ21lbnRCeUVuZFtrXTtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgIGRlbGV0ZSBmLmVuZDtcbiAgICAgIGYuZm9yRWFjaChmdW5jdGlvbihpKSB7IHN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0gPSAxOyB9KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gIGZsdXNoKGZyYWdtZW50QnlTdGFydCwgZnJhZ21lbnRCeUVuZCk7XG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7IGlmICghc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSkgZnJhZ21lbnRzLnB1c2goW2ldKTsgfSk7XG5cbiAgcmV0dXJuIGZyYWdtZW50cztcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsIG4gPSBpbnB1dC5sZW5ndGgsIG91dHB1dCA9IG5ldyBBcnJheShuKTtcbiAgICBvdXRwdXRbMF0gPSAoeDAgKz0gaW5wdXRbMF0pICoga3ggKyBkeDtcbiAgICBvdXRwdXRbMV0gPSAoeTAgKz0gaW5wdXRbMV0pICoga3kgKyBkeTtcbiAgICB3aGlsZSAoaiA8IG4pIG91dHB1dFtqXSA9IGlucHV0W2pdLCArK2o7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsXG4gICAgICAgIG4gPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeDEgPSBNYXRoLnJvdW5kKChpbnB1dFswXSAtIGR4KSAvIGt4KSxcbiAgICAgICAgeTEgPSBNYXRoLnJvdW5kKChpbnB1dFsxXSAtIGR5KSAvIGt5KTtcbiAgICBvdXRwdXRbMF0gPSB4MSAtIHgwLCB4MCA9IHgxO1xuICAgIG91dHB1dFsxXSA9IHkxIC0geTAsIHkwID0geTE7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJpbXBvcnQge1xyXG4gICAgYW5ub3RhdGlvbixcclxuICAgIGFubm90YXRpb25MYWJlbCxcclxuICAgIGFubm90YXRpb25DYWxsb3V0LFxyXG4gICAgYW5ub3RhdGlvbkNhbGxvdXRSZWN0LFxyXG4gICAgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGUsXHJcbiAgICBhbm5vdGF0aW9uWFlUaHJlc2hvbGQsXHJcbn0gZnJvbSAnZDMtc3ZnLWFubm90YXRpb24nXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQW5ub3RhdGlvbnMobWFwKSB7XHJcbiAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBtYXAuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBtYXAuc3ZnSWRfKVxyXG4gICAgICAgIC8vY2xlYXIgcHJldmlvdXNcclxuICAgICAgICB6b29tR3JvdXAuc2VsZWN0QWxsKCcuZW0tYW5ub3RhdGlvbi1ncm91cCcpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIGNvbnN0IGFubm90YXRpb25zQ29uZmlnID0gbWFwLmFubm90YXRpb25zX1xyXG5cclxuICAgICAgICBpZiAoYW5ub3RhdGlvbnNDb25maWcpIHtcclxuICAgICAgICAgICAgLy8gRGVmaW5lIGEgbWFwIHRoYXQgbWFwcyB0aGUgdHlwZSBzdHJpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYW5ub3RhdGlvbiBmdW5jdGlvblxyXG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uVHlwZU1hcCA9IHtcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25MYWJlbDogYW5ub3RhdGlvbkxhYmVsLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNhbGxvdXQ6IGFubm90YXRpb25DYWxsb3V0LFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNhbGxvdXRSZWN0OiBhbm5vdGF0aW9uQ2FsbG91dFJlY3QsXHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uQ2FsbG91dENpcmNsZTogYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGUsXHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uWFlUaHJlc2hvbGQ6IGFubm90YXRpb25YWVRocmVzaG9sZCwgLy8gQWRkIGFueSBvdGhlciB0eXBlcyB5b3UgbmVlZFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYXAgYW5ub3RhdGlvbnMgZGF0YSB0byBlbnN1cmUgZWFjaCBhbm5vdGF0aW9uIGhhcyB0aGUgcHJvcGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zV2l0aFR5cGVzID0gYW5ub3RhdGlvbnNDb25maWcuYW5ub3RhdGlvbnMubWFwKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSAndHlwZScgc3RyaW5nIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYW5ub3RhdGlvbiBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uVHlwZU1hcFtkLnR5cGVdIHx8IGFubm90YXRpb25MYWJlbCAvLyBEZWZhdWx0IHRvIGFubm90YXRpb25MYWJlbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uZCwgdHlwZTogYW5ub3RhdGlvblR5cGUgfSAvLyBVcGRhdGUgJ3R5cGUnIHdpdGggdGhlIGZ1bmN0aW9uIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBjb25zdCBtYWtlQW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uKCkudHlwZShhbm5vdGF0aW9uTGFiZWwpLmFubm90YXRpb25zKGFubm90YXRpb25zV2l0aFR5cGVzKS5lZGl0TW9kZShhbm5vdGF0aW9uc0NvbmZpZy5lZGl0TW9kZSlcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGVuZCBuZXdcclxuICAgICAgICAgICAgem9vbUdyb3VwLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWFubm90YXRpb24tZ3JvdXAnKS5jYWxsKG1ha2VBbm5vdGF0aW9ucylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGNzdlBhcnNlUm93cyB9IGZyb20gJ2QzLWRzdidcclxuXHJcbi8vIGRyYXcgZ3JpZCBjYXJ0b2dyYW0gZ2VvbWV0cmllc1xyXG5leHBvcnQgY29uc3QgYnVpbGRHcmlkQ2FydG9ncmFtQmFzZSA9IGZ1bmN0aW9uIChvdXQpIHtcclxuICAgIGNvbnN0IHpvb21Hcm91cCA9IHNlbGVjdChgI2VtLXpvb20tZ3JvdXAtJHtvdXQuc3ZnSWRffWApXHJcbiAgICBjb25zdCBncmlkR3JvdXAgPSB6b29tR3JvdXAuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnZW0tZ3JpZC1jb250YWluZXInKVxyXG5cclxuICAgIC8vIEVuc3VyZSBtYXJnaW5zIGV4aXN0IHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuICAgIG91dC5ncmlkQ2FydG9ncmFtTWFyZ2luc18gPSBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfIHx8IHsgdG9wOiA4MCwgcmlnaHQ6IDgwLCBib3R0b206IDgwLCBsZWZ0OiA4MCB9XHJcblxyXG4gICAgLy8gR2V0IGdyaWQgbGF5b3V0XHJcbiAgICBjb25zdCBncmlkTGF5b3V0ID0gZ2V0R3JpZExheW91dChvdXQpXHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBhcnNlR3JpZExheW91dChncmlkTGF5b3V0KVxyXG4gICAgY29uc3QgZ3JpZERhdGEgPSBnZXRHcmlkRGF0YShwb3NpdGlvbiwgb3V0KVxyXG5cclxuICAgIC8vIERyYXcgdGhlIGFwcHJvcHJpYXRlIGdyaWRcclxuICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbVNoYXBlXyA9PT0gJ2hleGFnb24nKSB7XHJcbiAgICAgICAgZHJhd0hleGFnb25HcmlkKGdyaWRHcm91cCwgZ3JpZERhdGEsIG91dClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHJhd1NxdWFyZUdyaWQoZ3JpZEdyb3VwLCBncmlkRGF0YSwgb3V0KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENlbnRlciB0aGUgZ3JpZFxyXG4gICAgY2VudGVyR3JpZChncmlkR3JvdXAsIG91dC53aWR0aF8sIG91dC5oZWlnaHRfLCBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfKVxyXG59XHJcblxyXG4vKiogRGV0ZXJtaW5lcyB0aGUgZ3JpZCBsYXlvdXQgYmFzZWQgb24gc2V0dGluZ3MgKi9cclxuY29uc3QgZ2V0R3JpZExheW91dCA9IChvdXQpID0+IHtcclxuICAgIGNvbnN0IHNxdWFyZUdyaWQgPSBgXHJcbiAgICAgICAgLElTLCAgLCAgLE5PLFNFLEZJLCAgLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICwgICwgICwgICxFRSwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsTFYsICAsICAsICAsICAsXHJcbiAgICAgICAgLElFLFVLLCAgLCAgLERLLCAgLExULCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICxOTCxERSxQTCwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsQkUsTFUsQ1osU0ssVUEsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLEZSLENILExJLEFULEhVLFJPLE1ELCAgLCAgLCAgLFxyXG4gICAgICAgICxQVCxFUywgICxJVCxTSSxIUixSUyxCRywgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsQkEsTUUsTUssICAsICAsICAsICBcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsQUwsRUwsVFIsR0UsICAsICBcclxuICAgICAgICAsICAsICAsICAsTVQsICAsICAsICAsICAsQ1ksICAsICAsICBgXHJcblxyXG4gICAgY29uc3QgaGV4YWdvbkdyaWQgPSBgXHJcbiAgICAgICAgLElTLCAgLCAgLCAgLCAgLCAgLCAgLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICxOTyxTRSxGSSxFRSwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsTFYsICAsICAsICAsICAsXHJcbiAgICAgICAgLElFLFVLLCAgLCAgLERLLCAgLExULCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICxOTCxERSxQTCwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsQkUsTFUsQ1osU0ssVUEsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLEZSLENILExJLEFULEhVLFJPLE1ELCAgLCAgLCAgLFxyXG4gICAgICAgICxQVCxFUywgICxJVCxTSSxIUixSUyxCRywgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsQkEsTUUsTUssICAsICAsICAsICBcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsQUwsRUwsVFIsR0UsICAsICBcclxuICAgICAgICAsICAsICAsICAsTVQsICAsICAsICAsICAsQ1ksICAsICAsICBgXHJcblxyXG4gICAgcmV0dXJuIG91dC5ncmlkQ2FydG9ncmFtUG9zaXRpb25zXyB8fCAob3V0LmdyaWRDYXJ0b2dyYW1TaGFwZV8gPT09ICdoZXhhZ29uJyA/IGhleGFnb25HcmlkIDogc3F1YXJlR3JpZClcclxufVxyXG5cclxuLyoqIFBhcnNlcyB0aGUgZ3JpZCBsYXlvdXQgYW5kIG1hcHMgZWFjaCBJRCB0byBpdHMgcG9zaXRpb24gKi9cclxuY29uc3QgcGFyc2VHcmlkTGF5b3V0ID0gKGdyaWRMYXlvdXQpID0+IHtcclxuICAgIGNvbnN0IHBvc2l0aW9uQnlJZCA9IG5ldyBNYXAoKVxyXG4gICAgY3N2UGFyc2VSb3dzKGdyaWRMYXlvdXQudHJpbSgpLCAocm93LCBqKSA9PiB7XHJcbiAgICAgICAgcm93LmZvckVhY2goKGlkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICgoaWQgPSBpZC50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkJ5SWQuc2V0KGlkLCBbaSwgal0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuICAgIHJldHVybiBwb3NpdGlvbkJ5SWRcclxufVxyXG5cclxuLyoqIENvbnZlcnRzIHBhcnNlZCBwb3NpdGlvbnMgaW50byBzdHJ1Y3R1cmVkIGdyaWQgZGF0YSAqL1xyXG5jb25zdCBnZXRHcmlkRGF0YSA9IChwb3NpdGlvbiwgb3V0KSA9PiB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwb3NpdGlvbiwgKFtpZCwgW2NvbCwgcm93XV0pID0+IHtcclxuICAgICAgICBjb25zdCBmZWF0dXJlID0gb3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c3JnLmZpbmQoKHJnKSA9PiByZy5wcm9wZXJ0aWVzLmlkID09IGlkKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBjb2wsXHJcbiAgICAgICAgICAgIHJvdyxcclxuICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogZmVhdHVyZSA/IGZlYXR1cmUucHJvcGVydGllcy5uYSA6ICcnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcbi8qKiBEcmF3cyBhIHNxdWFyZSBncmlkICovXHJcbmNvbnN0IGRyYXdTcXVhcmVHcmlkID0gKGdyaWRHcm91cCwgZ3JpZERhdGEsIG91dCkgPT4ge1xyXG4gICAgY29uc3QgbnVtQ29scyA9IE1hdGgubWF4KC4uLmdyaWREYXRhLm1hcCgoZCkgPT4gZC5jb2wpKSArIDFcclxuICAgIGNvbnN0IG51bVJvd3MgPSBNYXRoLm1heCguLi5ncmlkRGF0YS5tYXAoKGQpID0+IGQucm93KSkgKyAxXHJcblxyXG4gICAgY29uc3QgbWFyZ2lucyA9IG91dC5ncmlkQ2FydG9ncmFtTWFyZ2luc19cclxuICAgIGNvbnN0IGNlbGxQYWRkaW5nID0gb3V0LmdyaWRDYXJ0b2dyYW1DZWxsUGFkZGluZ18gfHwgMCAvLyBLZWVwIGNlbGwgcGFkZGluZ1xyXG5cclxuICAgIGNvbnN0IGNlbGxXaWR0aCA9IChvdXQud2lkdGhfIC0gbWFyZ2lucy5sZWZ0IC0gbWFyZ2lucy5yaWdodCkgLyBudW1Db2xzIC0gY2VsbFBhZGRpbmdcclxuICAgIGNvbnN0IGNlbGxIZWlnaHQgPSAob3V0LmhlaWdodF8gLSBtYXJnaW5zLnRvcCAtIG1hcmdpbnMuYm90dG9tKSAvIG51bVJvd3MgLSBjZWxsUGFkZGluZ1xyXG4gICAgY29uc3QgY2VsbFNpemUgPSBNYXRoLm1pbihjZWxsV2lkdGgsIGNlbGxIZWlnaHQpXHJcblxyXG4gICAgZ3JpZEdyb3VwXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnLmVtLWdyaWQtY2VsbCcpXHJcbiAgICAgICAgLmRhdGEoZ3JpZERhdGEpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZ3JpZC1jZWxsJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IGB0cmFuc2xhdGUoJHtkLmNvbCAqIChjZWxsU2l6ZSArIGNlbGxQYWRkaW5nKSArIG1hcmdpbnMubGVmdH0sICR7ZC5yb3cgKiAoY2VsbFNpemUgKyBjZWxsUGFkZGluZykgKyBtYXJnaW5zLnRvcH0pYClcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuYXBwZW5kKCdyZWN0JykuYXR0cignd2lkdGgnLCBjZWxsU2l6ZSkuYXR0cignaGVpZ2h0JywgY2VsbFNpemUpLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtcmVjdCcpXHJcblxyXG4gICAgICAgICAgICBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAudGV4dChkLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBjZWxsU2l6ZSAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGNlbGxTaXplIC8gMiArIDUpXHJcbiAgICAgICAgfSlcclxufVxyXG5cclxuLyoqIERyYXdzIGEgaGV4YWdvbiBncmlkICovXHJcbmNvbnN0IGRyYXdIZXhhZ29uR3JpZCA9IChncmlkR3JvdXAsIGdyaWREYXRhLCBvdXQpID0+IHtcclxuICAgIGNvbnN0IG51bUNvbHMgPSBNYXRoLm1heCguLi5ncmlkRGF0YS5tYXAoKGQpID0+IGQuY29sKSkgKyAxXHJcbiAgICBjb25zdCBudW1Sb3dzID0gTWF0aC5tYXgoLi4uZ3JpZERhdGEubWFwKChkKSA9PiBkLnJvdykpICsgMVxyXG5cclxuICAgIGNvbnN0IG1hcmdpbnMgPSBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfXHJcbiAgICBjb25zdCBjZWxsUGFkZGluZyA9IG91dC5ncmlkQ2FydG9ncmFtQ2VsbFBhZGRpbmdfIHx8IDAgLy8gS2VlcCBjZWxsIHBhZGRpbmdcclxuXHJcbiAgICBjb25zdCBiYXNlSGV4UmFkaXVzID0gTWF0aC5taW4oXHJcbiAgICAgICAgKG91dC53aWR0aF8gLSBtYXJnaW5zLmxlZnQgLSBtYXJnaW5zLnJpZ2h0KSAvIChudW1Db2xzICogMS41KSxcclxuICAgICAgICAob3V0LmhlaWdodF8gLSBtYXJnaW5zLnRvcCAtIG1hcmdpbnMuYm90dG9tKSAvIChudW1Sb3dzICogTWF0aC5zcXJ0KDMpKVxyXG4gICAgKVxyXG5cclxuICAgIGNvbnN0IGhleFJhZGl1cyA9IGJhc2VIZXhSYWRpdXNcclxuICAgIGNvbnN0IGhleEhlaWdodCA9IE1hdGguc3FydCgzKSAqIGhleFJhZGl1c1xyXG5cclxuICAgIGdyaWRHcm91cFxyXG4gICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLWNlbGwnKVxyXG4gICAgICAgIC5kYXRhKGdyaWREYXRhKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtY2VsbCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBkLmNvbCAqICgxLjUgKiBoZXhSYWRpdXMgKyBjZWxsUGFkZGluZykgKyBtYXJnaW5zLmxlZnRcclxuICAgICAgICAgICAgY29uc3QgeSA9IGQucm93ICogKGhleEhlaWdodCArIGNlbGxQYWRkaW5nKSArIChkLmNvbCAlIDIgPT09IDEgPyAoaGV4SGVpZ2h0ICsgY2VsbFBhZGRpbmcpIC8gMiA6IDApICsgbWFyZ2lucy50b3BcclxuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIGRyYXdIZXhhZ29uKGhleFJhZGl1cykpLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtaGV4YWdvbicpXHJcblxyXG4gICAgICAgICAgICBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAudGV4dChkLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCA1KVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbi8qKiBHZW5lcmF0ZXMgdGhlIGhleGFnb24gcGF0aCAqL1xyXG5jb25zdCBkcmF3SGV4YWdvbiA9IChyKSA9PiB7XHJcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguUEkgLyAzXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IDYgfSwgKF8sIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IHIgKiBNYXRoLmNvcyhhbmdsZSAqIGkpXHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSByICogTWF0aC5zaW4oYW5nbGUgKiBpKVxyXG4gICAgICAgICAgICByZXR1cm4gYCR7aSA9PT0gMCA/ICdNJyA6ICdMJ30ke3h9LCR7eX1gXHJcbiAgICAgICAgfSkuam9pbignICcpICsgJyBaJ1xyXG4gICAgKVxyXG59XHJcblxyXG4vKiogQ2VudGVycyB0aGUgZ3JpZCB3aXRoaW4gdGhlIFNWRyAqL1xyXG5jb25zdCBjZW50ZXJHcmlkID0gKGdyaWRHcm91cCwgc3ZnV2lkdGgsIHN2Z0hlaWdodCwgbWFyZ2lucykgPT4ge1xyXG4gICAgZ3JpZEdyb3VwLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKVxyXG4gICAgICAgIGNvbnN0IGR4ID0gKHN2Z1dpZHRoIC0gbWFyZ2lucy5sZWZ0IC0gbWFyZ2lucy5yaWdodCAtIGJib3gud2lkdGgpIC8gMiAtIGJib3gueCArIG1hcmdpbnMubGVmdFxyXG4gICAgICAgIGNvbnN0IGR5ID0gKHN2Z0hlaWdodCAtIG1hcmdpbnMudG9wIC0gbWFyZ2lucy5ib3R0b20gLSBiYm94LmhlaWdodCkgLyAyIC0gYmJveC55ICsgbWFyZ2lucy50b3BcclxuICAgICAgICBncmlkR3JvdXAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2R4fSwgJHtkeX0pYClcclxuICAgIH0pXHJcbn1cclxuIiwiaW1wb3J0IHsgdXBkYXRlQ1NTUnVsZSB9IGZyb20gJy4vdXRpbHMuanMnXHJcblxyXG4vKiBwcmV0dGllci1pZ25vcmUgKi9cclxuLy8gdG8ga2VlcCB0cmFjayBvZiBkZXByZWNhdGVkIGZ1bmN0aW9ucyB3aGlsc3Qga2VlcGluZyB0aGUgY3VycmVudCB2ZXJzaW9uIGNsZWFuLlxyXG4vLyBhbHNvIHBhc3NlcyBhbnkgaW1wb3J0YW50IHBhcmFtZXRlcnMgdG8gdGhlIG5ldyBmdW5jdGlvbnMgKGlmIHRoZXkgZXhpc3QpIGFuZCBvdmVyd3JpdGVzIGFueSBDU1Mgc3R5bGUgcnVsZXMuXHJcbi8vIFRvIGJlIHJlbW92ZWQgd2hlbiBjb21wbGV0ZWx5IHBoYXNlZCBvdXQuXHJcblxyXG5leHBvcnQgY29uc3QgZGVmaW5lRGVwcmVjYXRlZEZ1bmN0aW9ucyA9IChvdXQpID0+IHtcclxuICAgIC8vIHN0eWxlc1xyXG4gICAgb3V0LnNlYUZpbGxTdHlsZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdzZWFGaWxsU3R5bGUoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLXNlYSBDU1MgY2xhc3MnKSwgdXBkYXRlQ1NTUnVsZSgnLmVtLXNlYScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmNudHJnRmlsbFN0eWxlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2NudHJnRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1jbnRyZyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tY250cmcnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5udXRzcmdGaWxsU3R5bGUgPSAodikgPT4gKGNvbnNvbGUud2FybignbnV0c3JnRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1udXRzcmcgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLW51dHNyZycsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0Lm51dHNiblN0cm9rZSA9ICh2KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdudXRzYm5TdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmJuXzAsIC5ibl8xLCAuYm5fMiwgLmJuXzMgQ1NTIGNsYXNzZXMnKVxyXG4gICAgICAgIGlmICh2WycwJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzAnLCdzdHJva2UnLHZbJzAnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzEnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMScsJ3N0cm9rZScsdlsnMSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMiddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8yJywnc3Ryb2tlJyx2WycyJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WyczJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzMnLCdzdHJva2UnLHZbJzMnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC5udXRzYm5TdHJva2VXaWR0aCA9ICh2KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdudXRzYm5TdHJva2VXaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuYm5fMCwgLmJuXzEsIC5ibl8yLCAuYm5fMyBDU1MgY2xhc3NlcycpXHJcbiAgICAgICAgaWYgKHZbJzAnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMCcsJ3N0cm9rZS13aWR0aCcsdlsnMCddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMSddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8xJywnc3Ryb2tlLXdpZHRoJyx2WycxJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WycyJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzInLCdzdHJva2Utd2lkdGgnLHZbJzInXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzMnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMycsJ3N0cm9rZS13aWR0aCcsdlsnMyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9O1xyXG4gICAgb3V0LmdyYXRpY3VsZVN0cm9rZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdncmF0aWN1bGVTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLWdyYXRpY3VsZSBDU1MgY2xhc3MnKSwgdXBkYXRlQ1NTUnVsZSgnLmVtLWdyYXRpY3VsZScsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQuZ3JhdGljdWxlU3Ryb2tlV2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignZ3JhdGljdWxlU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLWdyYXRpY3VsZSBDU1MgY2xhc3MnKSwgdXBkYXRlQ1NTUnVsZSgnLmVtLWdyYXRpY3VsZScsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7XHJcbiAgICBvdXQubnV0c3JnU2VsRmlsbFN0eSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdudXRzcmdTZWxGaWxsU3R5KCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgaG92ZXJDb2xvcigpIGluc3RlYWQnKSwgb3V0LmhvdmVyQ29sb3JfID0gdiwgb3V0KTtcclxuICAgIG91dC50aXRsZUZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50aXRsZUZvbnRTaXplKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS10aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tdGl0bGUnLCdmb250LXNpemUnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnN1YnRpdGxlRm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnN1YnRpdGxlRm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN1YnRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zdWJ0aXRsZScsJ2ZvbnQtc2l6ZScsdiksIG91dCk7XHJcbiAgICBvdXQuc3VidGl0bGVGb250V2VpZ2h0ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5zdWJ0aXRsZUZvbnRXZWlnaHQoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN1YnRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zdWJ0aXRsZScsJ2ZvbnQtd2VpZ2h0Jyx2KSwgb3V0KTtcclxuICAgIG91dC50aXRsZUZpbGwgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnRpdGxlRmlsbCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tdGl0bGUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXRpdGxlJywnZmlsbCcsdiksIG91dCk7XHJcbiAgICBvdXQuc3VidGl0bGVGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5zdWJ0aXRsZUZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN1YnRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zdWJ0aXRsZScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmNudGJuU3Ryb2tlID0gKHYpID0+IHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2NudGJuU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1jbnRibiAuZW0tYm4tZXUgLmVtLWJuLWVmdGEgLmVtLWJuLWNjIC5lbS1ibi1vdGggQ1NTIGNsYXNzZXMnKVxyXG4gICAgICAgIGlmICh2WydldSddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1ldScsJ3N0cm9rZScsdlsnZXUnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2VmdGEnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tZWZ0YScsJ3N0cm9rZScsdlsnZWZ0YSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnY2MnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY2MnLCdzdHJva2UnLHZbJ2NjJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydvdGgnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tb3RoJywnc3Ryb2tlJyx2WydvdGgnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2NvJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWNvJywnc3Ryb2tlJyx2WydjbyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9O1xyXG4gICAgb3V0LmNudGJuU3Ryb2tlV2lkdGggPSAodikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignY250Ym5TdHJva2VXaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tY250Ym4gLmVtLXdvcmxkYm4gLmVtLWJuLWV1IC5lbS1ibi1lZnRhIC5lbS1ibi1jYyAuZW0tYm4tb3RoIENTUyBjbGFzc2VzJylcclxuICAgICAgICBpZiAodlsnZXUnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tZXUnLCdzdHJva2Utd2lkdGgnLHZbJ2V1J10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydlZnRhJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWVmdGEnLCdzdHJva2Utd2lkdGgnLHZbJ2VmdGEnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2NjJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWNjJywnc3Ryb2tlLXdpZHRoJyx2WydjYyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnb3RoJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLW90aCcsJ3N0cm9rZS13aWR0aCcsdlsnb3RoJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydjbyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZS13aWR0aCcsdlsnY28nXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC53b3JsZFN0cm9rZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAud29ybGRTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXdvcmxkYm4gLmVtLWJuLWNvIC5lbS1ibi1kIENTUyBjbGFzc2VzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXdvcmxkYm4nLCdzdHJva2UnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkU3Ryb2tlV2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXdvcmxkYm4gLmVtLWJuLWNvIC5lbS1ibi1kIENTUyBjbGFzc2VzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXdvcmxkYm4nLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkQ29hc3RTdHJva2UgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkQ29hc3RTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWJuLWNvIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQud29ybGRDb2FzdFN0cm9rZVdpZHRoID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZENvYXN0U3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWJuLWNvIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7XHJcbiAgICBvdXQud29ybGRGaWxsU3R5bGUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS13b3JsZHJnIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS13b3JsZHJnJywnZmlsbCcsdiksIG91dCk7IFxyXG4gICAgb3V0LmNvYXN0YWxNYXJnaW5XaWR0aCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY29hc3RhbE1hcmdpbldpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlICNlbS1jb2FzdC1tYXJnaW4gQ1NTIHJ1bGUnKSx1cGRhdGVDU1NSdWxlKCcjZW0tY29hc3QtbWFyZ2luJywnc3Ryb2tlLXdpZHRoJyx2KSwgb3V0KTsgIFxyXG4gICAgb3V0LmNvYXN0YWxNYXJnaW5Db2xvciA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY29hc3RhbE1hcmdpbkNvbG9yKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlICNlbS1jb2FzdC1tYXJnaW4gQ1NTIHJ1bGUnKSx1cGRhdGVDU1NSdWxlKCcjZW0tY29hc3QtbWFyZ2luJywnc3Ryb2tlJyx2KSwgb3V0KTtcclxuICAgIG91dC5mb250RmFtaWx5ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5mb250RmFtaWx5KCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1tYXAgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLW1hcCcsJ2ZvbnQtZmFtaWx5Jyx2KSwgb3V0KTtcclxuICAgIG91dC5ib3RUeHRGb250U2l6ZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuYm90VHh0Rm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZvb3Rub3RlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mb290bm90ZScsJ2ZvbnQtc2l6ZScsdiksIG91dCk7XHJcbiAgICBvdXQuYm90VHh0RmlsbCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuYm90VHh0RmlsbCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tZm9vdG5vdGUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLWZvb3Rub3RlJywnZmlsbCcsdiksIG91dCk7XHJcbiAgICBvdXQuc2NhbGViYXJGb250U2l6ZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuc2NhbGViYXJGb250U2l6ZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc2NhbGViYXItbGFiZWwgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXNjYWxlYmFyLWxhYmVsJywnZm9udC1zaXplJyx2KSwgb3V0KTtcclxuICAgIG91dC5mcmFtZVN0cm9rZSA9ICh2KT0+IChjb25zb2xlLndhcm4oJ21hcC5mcmFtZVN0cm9rZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tZnJhbWUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLWZyYW1lJywnc3Ryb2tlJyx2KSwgb3V0KTtcclxuICAgIG91dC5mcmFtZVN0cm9rZVdpZHRoID0gKHYpPT4gKGNvbnNvbGUud2FybignbWFwLmZyYW1lU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZyYW1lIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mcmFtZScsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7XHJcblxyXG4gICAvL290aGVyXHJcbiAgICBvdXQucHNDbGFzc2lmTWV0aG9kID0gKHYpID0+IChjb25zb2xlLndhcm4oJ3BzQ2xhc3NpZk1ldGhvZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHBzQ2xhc3NpZmljYXRpb25NZXRob2QgaW5zdGVhZCcpLG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9IHYsIG91dCk7XHJcbiAgICBvdXQuZ2VvQ2VudGVyID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5nZW9DZW50ZXIoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtYXAucG9zaXRpb24oe3gseSx6fSkgaW5zdGVhZC4nKSwgb3V0LnBvc2l0aW9uXy54ID0gdlswXSwgb3V0LnBvc2l0aW9uXy55ID0gdlsxXSwgb3V0KTtcclxuICAgIG91dC5waXhlbFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnBpeGVsU2l6ZSgpIGlzIG5vdyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSB6IHByb3BlcnR5IGluIG1hcC5wb3NpdGlvbih7eCx5LHp9KSBpbnN0ZWFkLicpLCBvdXQucG9zaXRpb25fLnogPSB2LCBvdXQpO1xyXG4gICAgb3V0LnBpeFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnBpeGVsU2l6ZSgpIGlzIG5vdyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSB6IHByb3BlcnR5IGluIG1hcC5wb3NpdGlvbih7eCx5LHp9KSBpbnN0ZWFkLicpLCBvdXQucG9zaXRpb25fLnogPSB2LCBvdXQpO1xyXG4gICAgb3V0LnRvb2x0aXBUZXh0ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50b29sdGlwVGV4dCgpIGlzIG5vdyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1hcC50b29sdGlwKGNvbmZpZy50ZXh0RnVuY3Rpb24pIGluc3RlYWQuIFNlZSBBUEkgcmVmZXJlbmNlIGZvciBkZXRhaWxzLicpLCBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gdiwgb3V0KTtcclxuICAgIG91dC5jbGFzc2lmTWV0aG9kID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jbGFzc2lmTWV0aG9kKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLmNsYXNzaWZpY2F0aW9uTWV0aG9kKCkgaW5zdGVhZC4nKSwgb3V0LmNsYXNzaWZpY2F0aW9uTWV0aG9kXyA9IHYsb3V0KTtcclxuICAgIG91dC50aHJlc2hvbGQgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnRocmVzaG9sZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC50aHJlc2hvbGRzKCkgaW5zdGVhZC4nKSwgb3V0LnRocmVzaG9sZHNfID0gdixvdXQpO1xyXG4gICAgb3V0LnBzVGhyZXNob2xkID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5wc1RocmVzaG9sZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC5wc1RocmVzaG9sZHMoKSBpbnN0ZWFkLicpLCBvdXQucHNUaHJlc2hvbGRzXyA9IHYsb3V0KTtcclxuICAgIG91dC5jbG5iID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jbG5iKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLm51bWJlck9mQ2xhc3NlcygpIGluc3RlYWQuJyksIG91dC5udW1iZXJPZkNsYXNzZXNfID0gdixvdXQpO1xyXG4gICAgb3V0Lm51dHNMdmwgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLm51dHNMdmwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBtYXAubnV0c0xldmVsKCkgaW5zdGVhZC4nKSwgb3V0Lm51dHNMZXZlbF8gPSB2LG91dCk7XHJcbiAgICBvdXQubGcgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxnKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLmxhbmd1YWdlKCkgaW5zdGVhZC4nKSwgb3V0Lmxhbmd1YWdlXyA9IHYsb3V0KTtcclxuICAgIG91dC5ib3R0b21UZXh0ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdHRvbVRleHQgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2UgdGhlIGZvb3Rub3RlKCkgbWV0aG9kIGFuZCBlbS1mb290bm90ZSBDU1MgY2xhc3MgaW5zdGVhZC4nKSxvdXQuZm9vdG5vdGVfID0gdixvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdFR4dEZvbnRTaXplIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIHRoZSBlbS1mb290bm90ZSBDU1MgY2xhc3MgaW5zdGVhZC4nKSxvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZpbGwgPSAodikgPT4gKGNvbnNvbGUud2FybignYm90VHh0RmlsbCBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSB0aGUgZW0tZm9vdG5vdGUgQ1NTIGNsYXNzIGluc3RlYWQuJyksb3V0KTtcclxuICAgIG91dC5ib3RUeHRQYWRkaW5nID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdFR4dFBhZGRpbmcgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2UgdGhlIGVtLWZvb3Rub3RlIENTUyBjbGFzcyBpbnN0ZWFkLicpLG91dCk7XHJcbiAgICBvdXQuYm90VHh0VG9vbHRpcFR4dCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdib3RUeHRUb29sdGlwVHh0IGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIGZvb3Rub3RlVG9vbHRpcFRleHQoKSBpbnN0ZWFkLicpLG91dCk7XHJcbiAgICBvdXQudG9vbHRpcFNob3dGbGFncyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ3Rvb2x0aXBTaG93RmxhZ3MgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LnRvb2x0aXAoe3Nob3dGbGFnc30pIGluc3RlYWQuJyksb3V0LnRvb2x0aXBfLnNob3dGbGFncyA9IHYsb3V0KTtcclxuICAgIG91dC5jb2xvckZ1biA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2NvbG9yRnVuIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5jb2xvckZ1bmN0aW9uKCkgaW5zdGVhZC4nKSxvdXQuY29sb3JGdW5jdGlvbl8gPSB2LG91dCk7XHJcbiAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW4gPSAodik9Pihjb25zb2xlLndhcm4oJ2ZpbHRlcnNEZWZpbml0aW9uRnVuIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uKCkgaW5zdGVhZC4nKSxvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8gPSB2LG91dCk7XHJcbiAgICBcclxuICAgIC8vbGFiZWxsaW5nXHJcbiAgICBvdXQubGFiZWxsaW5nID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxsaW5nIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe30pIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxzQ29uZmlnID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxzQ29uZmlnIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe2NvbmZpZzp5b3VyQ29uZmlnfSkgY29uZmlndXJhdGlvbiBvYmplY3QgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0LmxhYmVsc18gPU9iamVjdC5hc3NpZ24ob3V0LmxhYmVsc18gfHwge30sIHsgY29uZmlnOiB2IH0pLG91dCk7XHJcbiAgICBvdXQuc3RhdExhYmVsc1Bvc2l0aW9ucyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ3N0YXRMYWJlbHNQb3NpdGlvbnMgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7c3RhdExhYmVsc1Bvc2l0aW9uczp5b3VyUG9zaXRpb25zfSkgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0LmxhYmVsc18gPSBPYmplY3QuYXNzaWduKG91dC5sYWJlbHNfIHx8IHt9LCB7IHN0YXRMYWJlbHNQb3NpdGlvbnM6IHYgfSksb3V0KTtcclxuICAgIG91dC5sYWJlbHNUb1Nob3cgPSAodikgPT4oY29uc29sZS53YXJuKCdsYWJlbHNUb1Nob3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxGaWx0ZXJGdW5jdGlvbjp5b3VyRnVuY3Rpb24ocmVnaW9uLG1hcCl9KSBmdW5jdGlvbiBpbnN0ZWFkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKSxvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93c1RvU2hvdyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2xhYmVsU2hhZG93c1RvU2hvdyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbEZpbHRlckZ1bmN0aW9uOnlvdXJGdW5jdGlvbihyZWdpb24sbWFwKX0pIGZ1bmN0aW9uIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxTaGFkb3cgPSAodikgPT4oY29uc29sZS53YXJuKCdsYWJlbFNoYWRvdyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbFNoYWRvdzpib29sZWFufSkgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0KTtcclxuICAgIG91dC5sYWJlbFNoYWRvd1dpZHRoID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxTaGFkb3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxTaGFkb3c6Ym9vbGVhbn0pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxGaWx0ZXJGdW5jdGlvbiA9KHYpID0+KGNvbnNvbGUud2FybignbGFiZWxGaWx0ZXJGdW5jdGlvbiBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbEZpbHRlckZ1bmN0aW9uOnlvdXJGdW5jdGlvbihyZWdpb24sbWFwKX0pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbEZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU3Ryb2tlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbFN0cm9rZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxTdHJva2VXaWR0aCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxTdHJva2VXaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxPcGFjaXR5ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbE9wYWNpdHkoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsVmFsdWVzRm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsVmFsdWVzRm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93V2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsU2hhZG93V2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzLXNoYWRvd3MgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxTaGFkb3dDb2xvciA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxTaGFkb3dDb2xvcigpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMtc2hhZG93cyBDU1MgY2xhc3MnKSwgb3V0KTtcclxuXHJcbiAgICBvdXQuY291bnRyaWVzVG9TaG93ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jb3VudHJpZXNUb1Nob3coKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgbWFwLmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbigpIGZ1bmN0aW9uIGlmIHlvdSB3aXNoIHRvIGZpbHRlciB0aGUgZGVmYXVsdCBnZW9tZXRyaWVzLicpLCBvdXQpO1xyXG4gICAgb3V0LmJvcmRlcnNUb1Nob3cgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmJvcmRlcnNUb1Nob3coKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgbWFwLmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbigpIGZ1bmN0aW9uIGlmIHlvdSB3aXNoIHRvIGZpbHRlciB0aGUgZGVmYXVsdCBnZW9tZXRyaWVzLicpLCBvdXQpO1xyXG59XHJcbiIsIi8vIHRha2VzIGNhcmUgb2YgdGhlIG1hcCdzIGdlb21ldHJpZXNcclxuaW1wb3J0IHsganNvbiB9IGZyb20gJ2QzLWZldGNoJ1xyXG5pbXBvcnQgeyBmZWF0dXJlIH0gZnJvbSAndG9wb2pzb24tY2xpZW50J1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IHsga29zb3ZvQm5GZWF0dXJlcyB9IGZyb20gJy4va29zb3ZvJ1xyXG5pbXBvcnQgeyBnZW9HcmF0aWN1bGUgfSBmcm9tICdkMy1nZW8nXHJcbmltcG9ydCB7IGdldCwgc2V0IH0gZnJvbSAnaWRiLWtleXZhbCdcclxuXHJcbi8vIEdlb21ldHJpZXMgY2xhc3Mgd3JhcHBlZCBhcyBhIGZ1bmN0aW9uXHJcbmV4cG9ydCBjb25zdCBHZW9tZXRyaWVzID0gZnVuY3Rpb24gKG1hcCwgd2l0aENlbnRlclBvaW50cykge1xyXG4gICAgbGV0IG91dCA9IHt9XHJcblxyXG4gICAgLy8gZGVmYXVsdHNcclxuICAgIG91dC5kZWZhdWx0R2VvRGF0YSA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmFsbE5VVFNHZW9EYXRhID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuZ2VvSlNPTnMgPSB7XHJcbiAgICAgICAgbWl4ZWQ6IHsgcmcwOiB1bmRlZmluZWQsIHJnMTogdW5kZWZpbmVkLCByZzI6IHVuZGVmaW5lZCwgcmczOiB1bmRlZmluZWQgfSxcclxuICAgICAgICBjbnRibjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGNudHJnOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbnV0c2JuOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbnV0c3JnOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZ3JhOiB1bmRlZmluZWQsXHJcbiAgICAgICAgd29ybGRyZzogdW5kZWZpbmVkLFxyXG4gICAgICAgIHdvcmxkYm46IHVuZGVmaW5lZCxcclxuICAgICAgICBrb3Nvdm86IHVuZGVmaW5lZCxcclxuICAgIH1cclxuXHJcbiAgICAvLyB1c2VyIGRlZmluZWQgZ2VvbWV0cmllcyAobGF5ZXJzKVxyXG4gICAgb3V0LnVzZXJHZW9tZXRyaWVzID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy8gdXNlciBkZWZpbmVkIHN0YXRpc3RpY2FsIHJlZ2lvbnNcclxuICAgIG91dC5zdGF0aXN0aWNhbFJlZ2lvbnMgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL2NlbnRyb2lkcyBmb3IgcHJvcCBzeW1ib2xzIGV0Y1xyXG4gICAgb3V0LmNlbnRyb2lkc0RhdGEgPSB1bmRlZmluZWQgLy9yYXdcclxuICAgIG91dC5jZW50cm9pZHNGZWF0dXJlcyA9IHVuZGVmaW5lZCAvL2dlb2pzb24gZmVhdHVyZXNcclxuXHJcbiAgICAvLyBnZXQgZ2VvanNvbiBmZWF0dXJlcyBvZiBhbGwgc3RhdGlzdGljYWwgcmVnaW9uc1xyXG4gICAgb3V0LmdldFJlZ2lvbkZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChtYXAuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuZ2VvSlNPTnMud29ybGRyZ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtvdXQuZ2VvSlNPTnMubWl4ZWQucmcwLCBvdXQuZ2VvSlNPTnMubWl4ZWQucmcxLCBvdXQuZ2VvSlNPTnMubWl4ZWQucmcyLCBvdXQuZ2VvSlNPTnMubWl4ZWQucmczXVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5nZW9KU09Ocy5udXRzcmcuY29uY2F0KG91dC5nZW9KU09Ocy5jbnRyZylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbmQgcGFyc2VzICdkZWZhdWx0JyBnZW8gZGF0YSAoZm9yIE5VVFMgb3IgV29ybGQgbWFwcylcclxuICAgICAqL1xyXG4gICAgb3V0LmdldERlZmF1bHRHZW9EYXRhID0gZnVuY3Rpb24gKGdlbywgZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uLCBudXRzTGV2ZWwpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG91dC5nZXREZWZhdWx0R2VvRGF0YVByb21pc2UoKVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcclxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJHZW9tZXRyaWVzRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uKHJlc3VsdHMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXQuYWxsTlVUU0dlb0RhdGEgPSByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICBvdXQuZGVmYXVsdEdlb0RhdGEgPSByZXN1bHRzWzBdXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuY2VudHJvaWRzRGF0YSA9IG51dHNMZXZlbCA9PT0gJ21peGVkJyA/IFtyZXN1bHRzWzRdLCByZXN1bHRzWzVdLCByZXN1bHRzWzZdLCByZXN1bHRzWzddXSA6IHJlc3VsdHNbMV1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1dvcmxkID0gZ2VvID09PSAnV09STEQnXHJcbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgVG9wb0pTT04gdG8gR2VvSlNPTlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzV29ybGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMud29ybGRyZyA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5DTlRSX1JHXzIwTV8yMDIwXzQzMjYpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLndvcmxkYm4gPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMuQ05UUl9CTl8yME1fMjAyMF80MzI2KS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5rb3Nvdm8gPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMuTlVUU19CTl8yME1fMjAyMV9SU19YS19ib3JkZXIpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLmdyYXRpY3VsZSA9IFtnZW9HcmF0aWN1bGUoKS5zdGVwKFszMCwgMzBdKSgpXVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMuZ3JhdGljdWxlID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLmdyYSkuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMubnV0c3JnID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLm51dHNyZykuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMubnV0c2JuID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLm51dHNibikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMuY250cmcgPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMuY250cmcpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLmNudGJuID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLmNudGJuKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBmb3IgTnV0czJKU09OIHRvcG9qc29uIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXREZWZhdWx0R2VvRGF0YVByb21pc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgbnV0c0xldmVscyA9IFswLCAxLCAyLCAzXVxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW11cclxuXHJcbiAgICAgICAgY29uc3QgYnVpbGRVcmwgPSAoYmFzZSwgeWVhciwgZ2VvLCBwcm9qLCBzY2FsZSwgbGV2ZWwsIHdpdGhDZW50ZXIgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcGF0aCA9IGAke2Jhc2V9LyR7eWVhcn1gXHJcbiAgICAgICAgICAgIGlmIChnZW8gJiYgZ2VvICE9PSAnRVVSJyAmJiBnZW8gIT09ICdXT1JMRCcpIHBhdGggKz0gYC8ke2dlb31gXHJcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2dlbyA9PSAnV09STEQnID8gJzQzMjYnIDogcHJvan1gXHJcbiAgICAgICAgICAgIGlmICghd2l0aENlbnRlciAmJiBzY2FsZSkgcGF0aCArPSBgLyR7c2NhbGV9YFxyXG4gICAgICAgICAgICBwYXRoICs9IGAvJHt3aXRoQ2VudGVyID8gJ251dHNwdF8nIDogJyd9JHtsZXZlbH0uanNvbmBcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGhcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IFRUTF9NUyA9IDI0ICogNjAgKiA2MCAqIDEwMDAgLy8gY2FjaGUgcmVmcmVzaGVzIGV2ZXJ5IDI0IGhvdXJzXHJcblxyXG4gICAgICAgIGNvbnN0IGZldGNoV2l0aENhY2hlID0gYXN5bmMgKHVybCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGBnZW9qc29uLWNhY2hlOiR7dXJsfWBcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBhd2FpdCBnZXQoY2FjaGVLZXkpXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lc3RhbXAsIGRhdGEgfSA9IGNhY2hlZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnJlc2ggPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wIDwgVFRMX01TXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJlc2gpIHJldHVybiBkYXRhXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgcmVhZGluZyBmcm9tIEluZGV4ZWREQiBjYWNoZSBmb3IgJHt1cmx9OmAsIGUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlIC8vIE9wdGlvbmFsbHkgYWxsb3cgZmFpbHVyZSB0byBwcm9wYWdhdGVcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGpzb24odXJsKVxyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHNldChjYWNoZUtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgY2FjaGUgZGF0YSBpbiBJbmRleGVkREIgZm9yICR7dXJsfTpgLCBlKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZSAvLyBPcHRpb25hbGx5IGFsbG93IGZhaWx1cmUgdG8gcHJvcGFnYXRlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW1hcCB8fCAhbWFwLm51dHMyanNvbkJhc2VVUkxfKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBtYXAgY29udGV4dCBvciBjb25maWd1cmF0aW9uJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJyAmJiBtYXAuZ2VvXyAhPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICBudXRzTGV2ZWxzLmZvckVhY2goKGx2bCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gYnVpbGRVcmwobWFwLm51dHMyanNvbkJhc2VVUkxfLCBtYXAubnV0c1llYXJfLCBtYXAuZ2VvXywgbWFwLnByb2pfLCBtYXAuc2NhbGVfLCBsdmwpXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGZldGNoV2l0aENhY2hlKHVybCkpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBudXRzTGV2ZWxzLmZvckVhY2goKGx2bCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKG1hcC5udXRzMmpzb25CYXNlVVJMXywgbWFwLm51dHNZZWFyXywgbWFwLmdlb18sIG1hcC5wcm9qXywgbWFwLnNjYWxlXywgbHZsLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZmV0Y2hXaXRoQ2FjaGUodXJsKSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1hcC5nZW9fID09PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkTWFwVG9wb2pzb25VUkwgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUuaW5jbHVkZXMoJ2VjLmV1cm9wYS5ldScpXHJcbiAgICAgICAgICAgICAgICA/ICdodHRwczovL2VjLmV1cm9wYS5ldS9hc3NldHMvZXN0YXQvRS9FNC9naXNjby9JTUFHRS9XT1JMRF80MzI2Lmpzb24nXHJcbiAgICAgICAgICAgICAgICA6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXVyb3N0YXQvZXVyb3N0YXQtbWFwL21hc3Rlci9zcmMvYXNzZXRzL3RvcG9qc29uL1dPUkxEXzQzMjYuanNvbidcclxuXHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZmV0Y2hXaXRoQ2FjaGUod29ybGRNYXBUb3BvanNvblVSTCkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbWFpblVybCA9IGJ1aWxkVXJsKG1hcC5udXRzMmpzb25CYXNlVVJMXywgbWFwLm51dHNZZWFyXywgbWFwLmdlb18sIG1hcC5wcm9qXywgbWFwLnNjYWxlXywgbWFwLm51dHNMZXZlbF8pXHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZmV0Y2hXaXRoQ2FjaGUobWFpblVybCkpXHJcblxyXG4gICAgICAgICAgICBpZiAod2l0aENlbnRlclBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHRVcmwgPSBidWlsZFVybChtYXAubnV0czJqc29uQmFzZVVSTF8sIG1hcC5udXRzWWVhcl8sIG1hcC5nZW9fLCBtYXAucHJval8sIG1hcC5zY2FsZV8sIG1hcC5udXRzTGV2ZWxfLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChmZXRjaFdpdGhDYWNoZShwdFVybCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9taXNlc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVja3MgaWYgYWxsIGdlbyBkYXRhIGlzIHJlYWR5ICovXHJcbiAgICBvdXQuaXNHZW9SZWFkeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIW91dC5kZWZhdWx0R2VvRGF0YSAmJiAhb3V0LnVzZXJHZW9tZXRyaWVzKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgbGV0IGFsbFJlYWR5ID0gdHJ1ZVxyXG5cclxuICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG51bGwsIChpbnNldCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc2V0Lkdlb21ldHJpZXMuaXNHZW9SZWFkeSgpKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxSZWFkeSA9IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gYWxsUmVhZHlcclxuICAgIH1cclxuXHJcbiAgICBvdXQuc2V0VXNlckdlb21ldHJpZXMgPSBmdW5jdGlvbiAoZ2VvbWV0cmllcykge1xyXG4gICAgICAgIHRoaXMudXNlckdlb21ldHJpZXMgPSBnZW9tZXRyaWVzXHJcblxyXG4gICAgICAgIC8vIGdldCByZWdpb25zIHRoYXQgYXJlIGxpbmtlZCB0byB0aGUgc3RhdGlzdGljc1xyXG4gICAgICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbWV0cnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LnN0YXRpc3RpY2FsUmVnaW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0aXN0aWNhbFJlZ2lvbnMgPSBnZW9tZXRyeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBvdXQuYWRkRGVmYXVsdEdlb21ldHJpZXNUb01hcCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGRyYXdHcmF0aWN1bGUsIHBhdGhGdW5jdGlvbiwgbnV0c0xldmVsLCBudXRzWWVhciwgZ2VvLCBwcm9qLCBzY2FsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLmdyYXRpY3VsZSAmJiBkcmF3R3JhdGljdWxlKSB7XHJcbiAgICAgICAgICAgIC8vZHJhdyBncmF0aWN1bGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1ncmF0aWN1bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMuZ3JhdGljdWxlKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMuY250cmcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jbnRyZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY250cmcnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLmNudHJnKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoY250cmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaWRzIGZvciBSUyBhbmQgRUwgc28gdGhhdCB3ZSBjYW4gY2hvb3NlIG5vdCB0byBhZGQgc3RhdGlzdGljYWwgZGF0YSB0byB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY250cmcucHJvcGVydGllcy5pZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PSAnUlMnIHx8IGlkID09ICdFTCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbS1jbnRyZy0nICsgaWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IHdvcmxkIG1hcFxyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLndvcmxkcmcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS13b3JsZHJnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS13b3JsZHJnJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy53b3JsZHJnKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgTlVUUyByZWdpb25zXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMubnV0c3JnKSB7XHJcbiAgICAgICAgICAgIGlmIChudXRzTGV2ZWwgPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzAgPSB0aGlzLmdlb0pTT05zLm51dHNyZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzEgPSBmZWF0dXJlKG91dC5hbGxOVVRTR2VvRGF0YVsxXSwgb3V0LmFsbE5VVFNHZW9EYXRhWzFdLm9iamVjdHMubnV0c3JnKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzIgPSBmZWF0dXJlKG91dC5hbGxOVVRTR2VvRGF0YVsyXSwgb3V0LmFsbE5VVFNHZW9EYXRhWzJdLm9iamVjdHMubnV0c3JnKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzMgPSBmZWF0dXJlKG91dC5hbGxOVVRTR2VvRGF0YVszXSwgb3V0LmFsbE5VVFNHZW9EYXRhWzNdLm9iamVjdHMubnV0c3JnKS5mZWF0dXJlc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZm9yIG1peGVkIE5VVFMsIHdlIGFkZCBldmVyeSBOVVRTIHJlZ2lvbiBhY3Jvc3MgYWxsIGxldmVscyBhbmQgaGlkZSBsZXZlbCAxLDIsMyBieSBkZWZhdWx0LCBvbmx5IHNob3dpbmcgdGhlbSB3aGVuIHRoZXkgaGF2ZSBzdGF0IGRhdGFcclxuICAgICAgICAgICAgICAgIC8vIHNlZSB1cGRhdGVDbGFzc2lmaWNhdGlvbiBhbmQgdXBkYXRlU3R5bGUgaW4gbWFwLWNob3JvcGxldGguanMgZm9yIGhpZGluZy9zaG93aW5nXHJcbiAgICAgICAgICAgICAgICA7W3RoaXMuZ2VvSlNPTnMubWl4ZWQucmcwLCB0aGlzLmdlb0pTT05zLm1peGVkLnJnMSwgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzIsIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmczXS5mb3JFYWNoKChyLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hcHBlbmQgZWFjaCBudXRzIGxldmVsIHRvIG1hcFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBlbS1udXRzcmcgZW0tbnV0c3JnLSR7aX1gKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEocilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignbHZsJywgaSkgLy90byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIG51dHMgbGV2ZWxzXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vYWRkIGtvc292b1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbyA9PSAnRVVSJyAmJiAocHJvaiA9PSAnMzAzNScgfHwgcHJvaiA9PSAnNDMyNicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGtvc292byBtYW51YWxseVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZEtvc292b0JvcmRlcihjb250YWluZXIsIHBhdGhGdW5jdGlvbiwgcHJvaiwgc2NhbGUsIG51dHNZZWFyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBudXRzTGV2ZWwgaXMgbm90ICdtaXhlZCdcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMubnV0c3JnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBjb3VudHJ5IGJvdW5kYXJpZXNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5jbnRibikge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNudGJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jbnRibicpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMuY250Ym4pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmV1ID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZWZ0YSA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNjID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMub3RoID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY28gPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChibikgPT4gJ2VtLWJuLScgKyBibi5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTGlzdCA9IFtdXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmV1ID09PSAnVCcpIGNsYXNzTGlzdC5wdXNoKCdlbS1ibi1ldScpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZWZ0YSA9PT0gJ1QnKSBjbGFzc0xpc3QucHVzaCgnZW0tYm4tZWZ0YScpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY2MgPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLWNjJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5vdGggPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLW90aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY28gPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLWNvJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTGlzdC5qb2luKCcgJykgLy8gVXNlIGpvaW4gd2l0aCBhIHNwYWNlIHRvIGNyZWF0ZSBhIHZhbGlkIGNsYXNzIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBOVVRTIGJvdW5kYXJpZXNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5udXRzYm4gJiYgbnV0c0xldmVsICE9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VvSlNPTnMubnV0c2JuLnNvcnQoZnVuY3Rpb24gKGJuMSwgYm4yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYm4yLnByb3BlcnRpZXMubHZsIC0gYm4xLnByb3BlcnRpZXMubHZsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tbnV0c2JuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1udXRzYm4nKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLm51dHNibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmV1ID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZWZ0YSA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNjID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMub3RoID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY28gPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BzID0gYm4ucHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vS09TT1ZPXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmlkID4gMTAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZW0ta29zb3ZvLWJuJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuY28gPT09ICdUJykgcmV0dXJuICdlbS1ibi1jbydcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbCA9IFsnZW0tYm4tJyArIHByb3BzLmx2bF1cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChibi5vdGggPT09IFwiVFwiKSBjbC5wdXNoKFwiYm4tb3RoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbC5qb2luKCcgJylcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgd29ybGQgYm91bmRhcmllc1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLndvcmxkYm4pIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS13b3JsZGJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS13b3JsZGJuJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5QT0xfU1RBVCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kaXNwdXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2VtLWJuLWQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLkNPQVNfRkxBRyA9PT0gJ1QnID8gJ2VtLWJuLWNvJyA6ICdlbS13b3JsZGJuJ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8uYXR0cihcImlkXCIsIChibikgPT4gYm4ucHJvcGVydGllcy5DTlRSX0JOX0lEKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMua29zb3ZvKSB7XHJcbiAgICAgICAgICAgIC8vYWRkIGtvc292byB0byB3b3JsZCBtYXBzXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0ta29zb3ZvLWJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1rb3Nvdm8tYm4nKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLmtvc292bylcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRLb3Nvdm9Cb3JkZXIoY29udGFpbmVyLCBwYXRoRnVuY3Rpb24sIHByb2osIHNjYWxlLCBudXRzWWVhcikge1xyXG4gICAgICAgIGxldCBrb3Nvdm9GZWF0dXJlID0ga29zb3ZvQm5GZWF0dXJlc1tudXRzWWVhcl0gPyBrb3Nvdm9CbkZlYXR1cmVzW251dHNZZWFyXVtwcm9qXVtzY2FsZV0gOiBrb3Nvdm9CbkZlYXR1cmVzWzIwMjRdW3Byb2pdW3NjYWxlXVxyXG4gICAgICAgIGxldCBrb3Nvdm9CbiA9IGZlYXR1cmUoa29zb3ZvRmVhdHVyZSwgJ251dHNibl8xJykuZmVhdHVyZXNcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1rb3Nvdm8tYm4nKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0ta29zb3ZvLWJuIGVtLWJuLWNjJylcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXRhKGtvc292b0JuKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyB1c2VyLWRlZmluZWQgZ2VvbWV0cmllcyB0byB0aGUgbWFwXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBtYXAuZ2VvbWV0cmllcyhbXHJcbiAgICAgKiAgeyBpZDogJ3JlZ2lvbnMnLCBmZWF0dXJlczogZ2VvSlNPTi5mZWF0dXJlcywgY2xhc3M6IChmZWF0dXJlKSA9PiAncmVnaW9uJyB9LFxyXG4gICAgICogIHsgaWQ6ICdib3JkZXJzJywgZmVhdHVyZXM6IGJvcmRlcnNEYXRhLCBjbGFzczogKGZlYXR1cmUpID0+ICdib3JkZXInIH1cclxuICAgICAqIF0pXHJcbiAgICAgKiBAcGFyYW0gZ2VvbWV0cmllcyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgZ2VvSlNPTiBmZWF0dXJlc1xyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lciBkMyBzZWxlY3Rpb24gb2YgdGhlIHBhcmVudCB0aGF0IHdlIGFwcGVuZCB0aGUgZ2VvbWV0cmllcyB0b1xyXG4gICAgICogQHBhcmFtIHBhdGhGdW5jdGlvbiBkMyBwYXRoIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIG91dC5hZGRVc2VyR2VvbWV0cmllc1RvTWFwID0gZnVuY3Rpb24gKGdlb21ldHJpZXMsIGNvbnRhaW5lciwgcGF0aEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tZXRyeSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgZ2VvbWV0cnkuc3RhdGlzdGljYWxSZWdpb25zID8gJ2VtLXVzZXItcmVnaW9ucycgOiAnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGdlb21ldHJ5LmNsYXNzID8gZ2VvbWV0cnkuY2xhc3MgOiAnJylcclxuXHJcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IGdyb3VwLnNlbGVjdEFsbCgncGF0aCcpLmRhdGEoZ2VvbWV0cnkuZmVhdHVyZXMpLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBjYWxsIGNoYWluIG1vZGlmaWNhdGlvbnMgdGhyb3VnaCBvbkVhY2hcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW9tZXRyeS5vbkVhY2ggPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm9uRWFjaChlbGVtZW50cylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgbWFwVGVtcGxhdGUgfSBmcm9tICcuL21hcC10ZW1wbGF0ZSdcclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBpbnNldCBtYXBzIGZvciBhIG1hcCB0ZW1wbGF0ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJ1aWxkSW5zZXRzID0gZnVuY3Rpb24gKG91dCwgd2l0aENlbnRlclBvaW50cykge1xyXG4gICAgaWYgKCFvdXQuaW5zZXRCb3hQb3NpdGlvbl8pIHtcclxuICAgICAgICBvdXQuaW5zZXRCb3hQb3NpdGlvbl8gPSBbb3V0LndpZHRoXyAtIG91dC5pbnNldEJveFdpZHRoXyAtIDIgKiBvdXQuaW5zZXRCb3hQYWRkaW5nXywgMiAqIG91dC5pbnNldEJveFBhZGRpbmdfXVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBjb250YWluZXIgdG8gZHJhd2luZyBncm91cFxyXG4gICAgLy8gQ2Fubm90IHJlYWQgcHJvcGVydGllcyBvZiB1bmRlZmluZWQgKHJlYWRpbmcgJ3N2Z0lkJylcclxuICAgIGxldCBzdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkXylcclxuICAgIGxldCBkcmF3aW5nR3JvdXAgPSBzdmcuc2VsZWN0KCcjZW0tZHJhd2luZy0nICsgb3V0LnN2Z0lkXylcclxuICAgIGNvbnN0IGluZyA9IGRyYXdpbmdHcm91cFxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdlbS1pbnNldHMtZ3JvdXAnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1pbnNldHMnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBvdXQuaW5zZXRCb3hQb3NpdGlvbl9bMF0gKyAnLCcgKyBvdXQuaW5zZXRCb3hQb3NpdGlvbl9bMV0gKyAnKScpXHJcblxyXG4gICAgaWYgKG91dC5pbnNldHNfID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAvL2lmIG5lZWRlZCwgdXNlIGRlZmF1bHQgaW5zZXQgY29uZmlnXHJcbiAgICAgICAgb3V0Lmluc2V0c18gPSBkZWZhdWx0SW5zZXRDb25maWcob3V0Lmluc2V0Qm94V2lkdGhfLCBvdXQuaW5zZXRCb3hQYWRkaW5nXylcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBlbmQgZWFjaCBpbnNldCB0byBtYXBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmluc2V0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb25maWcgPSBvdXQuaW5zZXRzX1tpXVxyXG4gICAgICAgIGNvbmZpZy5zdmdJZCA9IGNvbmZpZy5zdmdJZCB8fCAnaW5zZXQnICsgY29uZmlnLmdlbyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KVxyXG5cclxuICAgICAgICAvL2dldCBzdmcgZWxlbWVudC5cclxuICAgICAgICBsZXQgc3ZnID0gc2VsZWN0KCcjJyArIGNvbmZpZy5zdmdJZClcclxuICAgICAgICBpZiAoc3ZnLnNpemUoKSA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBpdCBhcyBhbiBlbWJlZGVkIFNWRyBpZiBpdCBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAgICBjb25zdCB4ID0gY29uZmlnLnggPT0gdW5kZWZpbmVkID8gb3V0Lmluc2V0Qm94UGFkZGluZ18gOiBjb25maWcueFxyXG4gICAgICAgICAgICBjb25zdCB5ID0gY29uZmlnLnkgPT0gdW5kZWZpbmVkID8gb3V0Lmluc2V0Qm94UGFkZGluZ18gKyBpICogKG91dC5pbnNldEJveFBhZGRpbmdfICsgb3V0Lmluc2V0Qm94V2lkdGhfKSA6IGNvbmZpZy55XHJcbiAgICAgICAgICAgIGNvbnN0IGdnZW8gPSBpbmdcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWluc2V0LScgKyBjb25maWcuc3ZnSWQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0taW5zZXQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB5ICsgJyknKVxyXG4gICAgICAgICAgICBnZ2VvLmFwcGVuZCgnc3ZnJykuYXR0cignaWQnLCBjb25maWcuc3ZnSWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBidWlsZCBpbnNldFxyXG4gICAgICAgIC8vIEdJU0NPLTI2NzYgLSBQVCBhem9yZXMgaW5zZXQgaGFzIDIgaW5zZXRzIHdpdGggdGhlIHNhbWUgR2VvLCBzbyBzZWNvbmQgd2FzIG92ZXJyaWRpbmcgZmlyc3Q6XHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc19bY29uZmlnLmdlb10pIHtcclxuICAgICAgICAgICAgLy9pZiBpbnNldCBhbHJlYWR5IGV4aXN0cyBpbiBtYXAgd2l0aCBzYW1lIGdlbywgdGhlbiBwdXNoIGJvdGggdG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgbGV0IGluc2V0ID0gYnVpbGRJbnNldChjb25maWcsIG91dCwgd2l0aENlbnRlclBvaW50cylcclxuICAgICAgICAgICAgaW5zZXQuYnVpbGRNYXBUZW1wbGF0ZUJhc2UoKVxyXG4gICAgICAgICAgICBvdXQuaW5zZXRUZW1wbGF0ZXNfW2NvbmZpZy5nZW9dID0gW291dC5pbnNldFRlbXBsYXRlc19bY29uZmlnLmdlb10sIGluc2V0XVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBpbnNldCA9IGJ1aWxkSW5zZXQoY29uZmlnLCBvdXQsIHdpdGhDZW50ZXJQb2ludHMpXHJcbiAgICAgICAgICAgIGxldCBkcmF3bkluc2V0ID0gaW5zZXQuYnVpbGRNYXBUZW1wbGF0ZUJhc2UoKVxyXG4gICAgICAgICAgICBvdXQuaW5zZXRUZW1wbGF0ZXNfW2NvbmZpZy5nZW9dID0gZHJhd25JbnNldFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbi8qKiBCdWlsZCB0ZW1wbGF0ZSBmb3IgaW5zZXQsIGJhc2VkIG9uIG1haW4gb25lICovXHJcbmNvbnN0IGJ1aWxkSW5zZXQgPSBmdW5jdGlvbiAoY29uZmlnLCBvdXQsIHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgIC8vVE9ETyBmaW5kIGEgYmV0dGVyIHdheSB0byBkbyB0aGF0XHJcblxyXG4gICAgLy9jb3B5IG1hcFxyXG4gICAgLy9mb3IobGV0IGtleV9fIGluIG1hcCkge1xyXG4gICAgLy9tdFtrZXlfX10gPSBtYXBba2V5X19dO1xyXG4gICAgLy99XHJcblxyXG4gICAgY29uc3QgbXQgPSBtYXBUZW1wbGF0ZShjb25maWcsIHdpdGhDZW50ZXJQb2ludHMpXHJcblxyXG4gICAgLy9kZWZpbmUgZGVmYXVsdCB2YWx1ZXMgZm9yIGluc2V0IGNvbmZpZ3NcclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fVxyXG4gICAgY29uZmlnLnByb2ogPSBjb25maWcucHJvaiB8fCBfZGVmYXVsdENSU1tjb25maWcuZ2VvXVxyXG4gICAgY29uZmlnLnNjYWxlID0gY29uZmlnLnNjYWxlIHx8IG91dC5pbnNldFNjYWxlX1xyXG4gICAgY29uZmlnLmZvb3Rub3RlID0gY29uZmlnLmZvb3Rub3RlIHx8ICcnXHJcbiAgICBjb25maWcuc2hvd1NvdXJjZUxpbmsgPSBjb25maWcuc2hvd1NvdXJjZUxpbmsgfHwgZmFsc2VcclxuICAgIGNvbmZpZy56b29tRXh0ZW50ID0gY29uZmlnLnpvb21FeHRlbnQgfHwgb3V0Lmluc2V0Wm9vbUV4dGVudF9cclxuICAgIGNvbmZpZy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCBvdXQuaW5zZXRCb3hXaWR0aF9cclxuICAgIGNvbmZpZy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IG91dC5pbnNldEJveFdpZHRoX1xyXG4gICAgY29uZmlnLmluc2V0cyA9IGNvbmZpZy5pbnNldHMgfHwgW11cclxuICAgIGNvbmZpZy5pbnNldFRlbXBsYXRlcyA9IGNvbmZpZy5pbnNldFRlbXBsYXRlcyB8fCB7fVxyXG4gICAgY29uZmlnLmNhbGxiYWNrID0gY29uZmlnLmNhbGxiYWNrIHx8IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vY29weSBtYWluIG1hcCBhdHRyaWJ1dGVzXHJcbiAgICA7W1xyXG4gICAgICAgICdudXRzTGV2ZWxfJyxcclxuICAgICAgICAnbnV0c1llYXJfJyxcclxuICAgICAgICAnaG92ZXJDb2xvcl8nLFxyXG4gICAgICAgIC8vJ251dHNiblN0cm9rZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgLy8gJ251dHNiblN0cm9rZVdpZHRoXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnY250cmdGaWxsU3R5bGVfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjbnRiblN0cm9rZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2NudGJuU3Ryb2tlV2lkdGhfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdzZWFGaWxsU3R5bGVfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdkcmF3Q29hc3RhbE1hcmdpbl8nLFxyXG4gICAgICAgICdjb2FzdGFsTWFyZ2luQ29sb3JfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjb2FzdGFsTWFyZ2luV2lkdGhfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjb2FzdGFsTWFyZ2luU3RkRGV2XycsXHJcbiAgICAgICAgJ2dyYXRpY3VsZVN0cm9rZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2dyYXRpY3VsZVN0cm9rZVdpZHRoXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnbGdfJyxcclxuICAgICAgICAncHJvamVjdGlvbkZ1bmN0aW9uXycsXHJcbiAgICAgICAgJ2ZpbHRlckdlb21ldHJpZXNGdW5jdGlvbl8nLFxyXG4gICAgICAgICdwcm9jZXNzQ2VudHJvaWRzXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG10W2F0dF0gPSBvdXRbYXR0XVxyXG4gICAgfSlcclxuXHJcbiAgICAvL2NvcHkgc3RhdCBtYXAgYXR0cmlidXRlcy9tZXRob2RzXHJcbiAgICA7WydzdGF0JywgJ3N0YXREYXRhJywgJ2xlZ2VuZCcsICdsZWdlbmRPYmonLCAnbm9EYXRhVGV4dCcsICdsYW5ndWFnZScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndG9vbHRpcF8nLCAnY2xhc3NUb1RleHRfJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgbXRbYXR0XSA9IG91dFthdHRdXHJcbiAgICB9KVxyXG5cclxuICAgIC8vYXBwbHkgY29uZmlnIHZhbHVlcyBmb3IgaW5zZXRcclxuICAgIGZvciAobGV0IGtleSBpbiBjb25maWcpIG10W2tleSArICdfJ10gPSBjb25maWdba2V5XVxyXG5cclxuICAgIG10LmlzSW5zZXQgPSB0cnVlIC8vIGZsYWcgZm9yIGluc2V0LXNwZWNpZmljIHNldHRpbmdzIGUuZy4gQ1NTIGNsYXNzIGZvciB0aXRsZXNcclxuICAgIHJldHVybiBtdFxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGluc2V0cyBtYXBzIGZyb20gdGhlIERPTVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbW92ZUluc2V0cyA9IGZ1bmN0aW9uIChvdXQpIHtcclxuICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgZm9yIChsZXQgdGVtcGxhdGUgaW4gb3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBsZXQgaWQgPSBvdXQuaW5zZXRUZW1wbGF0ZXNfW3RlbXBsYXRlXS5zdmdJZF9cclxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nID0gc2VsZWN0KCcjJyArIGlkKVxyXG4gICAgICAgICAgICAvLyBpZiAoZXhpc3RpbmcpIGV4aXN0aW5nLnJlbW92ZSgpXHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZykgZXhpc3RpbmcuaHRtbCgnJykgLy8gZW1wdHkgdGhlbSwgYnV0IGRvbnQgcmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5pbnNldFRlbXBsYXRlc18gPSB7fSAvLyAgR0lTQ08tMjY3NlxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBpbnNldCBzZXR0aW5nLlxyXG4gKiBAcGFyYW0geyp9IHMgVGhlIHdpZHRoIG9mIHRoZSBpbnNldCBib3hcclxuICogQHBhcmFtIHsqfSBwIFRoZSBwYWRkaW5nXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0SW5zZXRDb25maWcgPSBmdW5jdGlvbiAocywgcCkge1xyXG4gICAgY29uc3Qgb3V0ID0gW1xyXG4gICAgICAgIHsgZ2VvOiAnSUMnLCB4OiAwLCB5OiAwLCB3aWR0aDogcywgaGVpZ2h0OiAwLjMgKiBzIH0sXHJcbiAgICAgICAgeyBnZW86ICdDQVJJQicsIHg6IDAsIHk6IDAuMyAqIHMgKyBwLCB3aWR0aDogMC41ICogcywgaGVpZ2h0OiBzIH0sXHJcbiAgICAgICAgeyBnZW86ICdHRicsIHg6IDAuNSAqIHMsIHk6IDAuMyAqIHMgKyBwLCB3aWR0aDogMC41ICogcywgaGVpZ2h0OiAwLjc1ICogcyB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnWVQnLFxyXG4gICAgICAgICAgICB4OiAwLjUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjA1ICogcyArIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnUkUnLFxyXG4gICAgICAgICAgICB4OiAwLjc1ICogcyxcclxuICAgICAgICAgICAgeTogMS4wNSAqIHMgKyBwLFxyXG4gICAgICAgICAgICB3aWR0aDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIGhlaWdodDogMC4yNSAqIHMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ1BUMjAnLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAxLjMgKiBzICsgMiAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjc1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnUFQzMCcsXHJcbiAgICAgICAgICAgIHg6IDAuNzUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjMgKiBzICsgMiAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgZ2VvOiAnTVQnLCB4OiAwLCB5OiAxLjU1ICogcyArIDMgKiBwLCB3aWR0aDogMC4yNSAqIHMsIGhlaWdodDogMC4yNSAqIHMgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ0xJJyxcclxuICAgICAgICAgICAgeDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuNTUgKiBzICsgMyAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnU0pfU1YnLFxyXG4gICAgICAgICAgICB4OiAwLjUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjU1ICogcyArIDMgKiBwLFxyXG4gICAgICAgICAgICB3aWR0aDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIGhlaWdodDogMC4yNSAqIHMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ1NKX0pNJyxcclxuICAgICAgICAgICAgeDogMC43NSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuNTUgKiBzICsgMyAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qe2dlbzpcIklDXCIsIHg6MCwgeTowfSwge2dlbzpcIlJFXCIsIHg6ZGQsIHk6MH0sIHtnZW86XCJZVFwiLCB4OjIqZGQsIHk6MH0sXHJcblx0XHR7Z2VvOlwiR1BcIiwgeDowLCB5OmRkfSwge2dlbzpcIk1RXCIsIHg6ZGQsIHk6ZGR9LCB7Z2VvOlwiR0ZcIixzY2FsZTpcIjEwTVwiLCB4OjIqZGQsIHk6ZGR9LFxyXG5cdFx0e2dlbzpcIlBUMjBcIiwgeDowLCB5OjIqZGR9LCB7Z2VvOlwiUFQzMFwiLCB4OmRkLCB5OjIqZGR9LCB7Z2VvOlwiTVRcIiwgeDoyKmRkLCB5OjIqZGR9LFxyXG5cdFx0e2dlbzpcIkxJXCIsc2NhbGU6XCIwMU1cIiwgeDowLCB5OjMqZGR9LCB7Z2VvOlwiU0pfU1ZcIiwgeDpkZCwgeTozKmRkfSwge2dlbzpcIlNKX0pNXCIsc2NhbGU6XCIwMU1cIiwgeDoyKmRkLCB5OjMqZGR9LCovXHJcbiAgICAgICAgLy97Z2VvOlwiQ0FSSUJcIiwgeDowLCB5OjMzMH0sIHtnZW86XCJJU1wiLCB4OmRkLCB5OjMzMH1cclxuICAgIF1cclxuICAgIC8vaGlkZSBncmF0aWN1bGUgZm9yIGluc2V0c1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIG91dFtpXS5kcmF3R3JhdGljdWxlID0gZmFsc2VcclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqIERlZmF1bHQgQ1JTIGZvciBlYWNoIGdlbyBhcmVhICovXHJcbmNvbnN0IF9kZWZhdWx0Q1JTID0ge1xyXG4gICAgRVVSOiAnMzAzNScsXHJcbiAgICBJQzogJzMyNjI4JyxcclxuICAgIEdQOiAnMzI2MjAnLFxyXG4gICAgTVE6ICczMjYyMCcsXHJcbiAgICBHRjogJzMyNjIyJyxcclxuICAgIFJFOiAnMzI3NDAnLFxyXG4gICAgWVQ6ICczMjczOCcsXHJcbiAgICBNVDogJzMwMzUnLFxyXG4gICAgUFQyMDogJzMyNjI2JyxcclxuICAgIFBUMzA6ICczMjYyOCcsXHJcbiAgICBMSTogJzMwMzUnLFxyXG4gICAgSVM6ICczMDM1JyxcclxuICAgIFNKX1NWOiAnMzAzNScsXHJcbiAgICBTSl9KTTogJzMwMzUnLFxyXG4gICAgQ0FSSUI6ICczMjYyMCcsXHJcbiAgICBXT1JMRDogJzU0MDMwJyxcclxufVxyXG4iLCIvLyBtaXhlZCBudXRzIGRvbnQgZHJhdyBudXRzYm4gc28gd2UgYWRkIHRoZW0gbWFudWFsbHlcclxuZXhwb3J0IGNvbnN0IGtvc292b0JuRmVhdHVyZXMgPSB7XHJcbiAgMjAyMTp7XHJcbiAgICAzMDM1OiB7XHJcbiAgICAgICcwM00nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMzA2MSwxMzAzXSxbLTE1MiwtNTldLFstMzIsLTY2XSxbLTY1LDcyXSxbLTk2LDddLFstMTYsNTldLFstNjQsMTldLFstNTYsLTM5XSxbLTEyMCwzOV0sWy0xODQsLTE5XSxbLTE2LDI2XSxbMzIsNTJdLFstMTYsNzJdLFsyNCw0MF0sWzgsMTgzXV0sW1syODg1LDBdLFstOCw0Nl0sWy02NSw4NV0sWy00MCwtN10sWy00MCw0MF0sWzAsMTExXSxbODAsMTNdLFsyNSw0Nl0sWzcyLDEzXSxbNDAsOThdLFstNTYsMTE4XSxbMTQ0LDE5Nl0sWy0yNCw3OV0sWzg4LDU5XSxbLTI0LDk4XSxbLTgsMjBdLFsyNCwzOV0sWzgsNTJdLFs0OCw3Ml0sWy04OCwxMjVdXSxbWzgyNSwyNjM4XSxbLTExMiwtOThdLFstNzIsLTddLFstODgsLTExOF0sWy0xNzYsLTM5XSxbNTYsLTkxXSxbODgsLTMzXSxbMjQsLTUzXSxbNTYsLTM5XSxbMjQsLTkxXSxbLTU2LC00Nl0sWzI0LC0xMDVdLFstNTYsLTkyXSxbLTEwNCwwXSxbLTQ4LC0xMDRdLFstMTYsLTQwXSxbLTU3LDddLFstNDAsLTUzXSxbLTE2LC03OF0sWzExMywtMTE4XSxbLTk3LC02NV0sWy04OCwtOTldLFstODAsMjBdLFstODAsLTM5XSxbLTI0LC0xM11dLFtbMTA5OCwyMzA0XSxbLTE5Myw2Nl0sWzI0LDM5XSxbLTE2LDM5XSxbNjUsMTNdLFswLDMzXSxbLTY1LDc5XSxbLTg4LDY1XV0sW1syMzA4LDE2ODldLFstMTUzLC0yMF0sWy02NCw1OV0sWy00MCw3XSxbLTk2LC0yN10sWy0xMDQsMTM4XSxbLTgsOTJdLFstMzIsNzhdLFstNjQsMjZdLFstMzIsLTU5XSxbLTI0LDBdLFstNTYsODZdLFstNDAsMTM3XSxbLTI1LDY1XSxbLTU2LDBdLFstNTYsNDZdLFstNjQsLTcyXSxbLTEyMCw1M10sWy04OCwtNDBdLFstODgsNDZdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlszNy43NjEwNDQ3NTI3Nzc1NjUsMzguNTQ3MzQyMDU2MjYxMTNdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDUsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcxME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbOTYyLDBdLFstMjksNzVdLFs0OCwxMzFdLFsyMSwzNV0sWzExLDM4XSxbMzIsMTE3XSxbLTI0LDQ0XV0sW1sxMDIxLDQ0MF0sWy02NCwtMjldLFstNzAsMzZdLFstMTIwLDJdLFszLDEyMV1dLFtbNzcwLDU3MF0sWy0xMjYsMTZdLFstNDAsOTFdLFstNDUsNF0sWy01MSw5M10sWy0xNDIsNF1dLFtbMjc1LDg5MV0sWy0xMzEsLTk5XSxbMzAsLTM2XSxbMjQsLTMxXSxbLTYsLTg2XSxbLTk4LC04Nl0sWzEzLC02NF0sWy0yNywtMzhdLFstODAsLTMxXV0sW1szNjYsNzc4XSxbLTM3LDIyXSxbLTU0LDkxXV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMTEzLjIwOTk0NDg1MTMwOTcsMTE0LjEyNzgyMDgxMzAzODAxXSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnMjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzUzNiwwXSxbLTI0LDQ1XSxbMTUsMzBdLFs0NSw5Ml0sWy0xLDQ0XSxbLTIsMzddXSxbWzU2OSwyNDhdLFstMTMwLDldLFstMTAsNjRdXSxbWzQyOSwzMjFdLFstNjQsMTBdLFstNzgsOTRdLFstODMsMTNdXSxbWzE1Myw1MDJdLFstNzMsLTUxXSxbMjYsLTg0XSxbLTQ4LC01M10sWy0zLC01Ml0sWy01NSwtMjVdXSxbWzIwNCw0MzhdLFstNTEsNjRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsyMDMuMTIzMDk2MDE0OTQxMjQsMjAyLjU2NTUxNDYzMDMxMjQ2XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnNjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzMxMCwxMzhdLFstMzYsLTJdLFstNDAsNDJdXSxbWzIzNCwxNzhdLFstMTIzLDY1XV0sW1s4NCwyNzhdLFstODQsLTE0N11dLFtbMTExLDI0M10sWy0yNywzNV1dLFtbMjkyLDBdLFsxOCwxMzhdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlszNzIuODQyODE3MzAyMTU2MzMsMzY0Ljg3NjExODk4NTgwNTM2XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNCxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAzLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDEsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMixcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA1LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19XHJcbiAgICB9LFxyXG4gICAgNDMyNjoge1xyXG4gICAgICAnMDNNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzE5MDAsMTI3NV0sWy0zMCwyN10sWy0yNywtMTNdLFstMzQsMjNdLFstODcsNl0sWzI1LDU5XSxbMSw3MF0sWzIwLDM0XSxbMjQsMTY3XV0sW1sxNzkyLDE2NDhdLFstMTE2LDFdLFstNjIsNzddLFstODksLThdLFstNjAsMTQ4XSxbNyw4Nl0sWy00LDE1XSxbLTEzLDYwXSxbLTQ1LDI4XSxbLTMzLC00OF0sWy0yNiw0XSxbLTMxLDE0Ml0sWy0xMSw1M10sWzUsNDNdLFstMTksNDRdLFstMzksOF0sWy00MCw0OV0sWy01MiwtNTldLFstOTMsNzFdLFstMzgsLTZdLFstMTYsLTI2XV0sW1s5NDUsMjM4OF0sWy01NCwyN10sWy0yMCwyOF0sWy0yMiwtM10sWy0xNywyMl0sWy0yNSwxXSxbLTEwLDEwXSxbNCwxN10sWzI3LDE0XSxbLTE1LDI5XSxbMSwxNl0sWzY4LDFdLFstOCwxNl0sWy01LDMwXSxbLTE0LDI5XSxbLTI3LDQyXSxbLTI1LDIyXSxbLTMwLDQxXV0sW1s3NzMsMjczMF0sWy04OSwtNjldLFstNjQsLTRdLFstODIsLTkyXSxbLTEzMywtMTVdLFsyNywtOTNdLFs2NCwtNDNdLFsxNiwtNTBdLFszOCwtNDRdLFs5LC03NV0sWy00OCwtNTFdLFs1LC00MV0sWzYsLTUwXSxbLTUyLC04NF0sWy03OCwxNF0sWy0zNSwtNjZdLFstMzMsLTYxXSxbLTQ1LDExXSxbLTM1LC00Ml0sWy0xOCwtNzJdLFszMywtNzFdLFs0OCwtNTVdXSxbWzEwMTcsMjMzMF0sWy03Miw1OF1dLFtbMzA3LDE2NzddLFstMzYsLTEyXSxbLTI1LC0yMV0sWy0yNiwtMTBdLFstNzYsLTkwXSxbLTE3LDRdLFstMzAsMzFdLFstNTIsLTE0XSxbLTI2LC0yM10sWy0xOSwxXV0sW1syMzE5LDExODVdLFstMTE2LC0zMl0sWy0zOSwtNTJdLFstNDIsNzBdLFstNjgsMjNdLFstMTIsNThdLFstNDMsMjNdLFstNDIsLTIzXSxbLTU3LDIzXV0sW1syMDQ0LDBdLFstNCw0M10sWy0zOCw4Ml0sWy0zNCw5XSxbLTI0LDQzXSxbMTMsOTddLFs2MSw0XSxbMzIsNDFdLFs0OSwwXSxbMzcsODJdLFstMjYsMTE4XSxbMTMwLDE2N10sWy04LDczXSxbNzQsNDZdLFstMiwxOF0sWy05LDkyXSxbMjQsMzVdLFs3LDQ5XSxbNDgsNTJdLFstNTUsMTM0XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDA2MDM4MzM5MjgzOTA4OTc0LDAuMDAwMzY5ODM0NzU1Njc3NjU5NzVdLFwidHJhbnNsYXRlXCI6WzIwLjM1MjkyODM5MzAwMDA3LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19LFxyXG4gICAgICAnMTBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzY1OSw0MzldLFstNTQsMTddLFsxNywxMTFdXSxbWzYyMiw1NjddLFstOTMsMzFdLFstMjUsOTJdLFstMzYsMTFdLFstMjksOTddLFstMjMsMV0sWy02MywzXV0sW1szMjgsODIyXSxbLTMzLDc0XSxbLTI3LDQ0XV0sW1syNjgsOTQwXSxbLTcyLC00NF0sWy0zOCwtMzFdLFsyNywtODZdLFstMTQsLTY1XSxbLTgxLC03OF0sWzE2LC01OF1dLFtbMzUzLDgwMl0sWy0yNSwyMF1dLFtbMTA2LDU3OF0sWy00MSwtMTldLFstNjUsLTI4XV0sW1s4MDUsNDA4XSxbLTU0LC0yMV0sWy05Miw1Ml1dLFtbNzA5LDBdLFstMjIsNzJdLFswLDE3XSxbNDAsMzZdLFsxOCw2N10sWzUzLDEwMV0sWzE2LDY0XSxbLTksNTFdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwMTc0MDUyMTU0NzkxMTUyNCwwLjAwMTA3NDA5NDU1NjM4Mjk5MDddLFwidHJhbnNsYXRlXCI6WzIwLjM1MjkyODM5MzAwMDA3LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19LFxyXG4gICAgICAnMjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzM4MCwyNTJdLFstMjEsMjZdLFswLDQ4XV0sW1szNTksMzI2XSxbLTQ5LDE3XSxbLTU2LDEwN10sWy01MSwxMV1dLFtbMTg5LDQ3Ml0sWy0zNCw2OF1dLFtbMTU1LDU0MF0sWy02NiwtMzldLFsxOCwtNjZdLFstNTQsLTY4XSxbOCwtMzVdXSxbWzYxLDMzMl0sWy0yMSwtMTNdLFstMTAsLTEyXSxbLTEzLDVdLFstMTcsLTddXSxbWzQ2NCwyMzRdLFstODQsMThdXSxbWzQwOSwwXSxbLTE0LDQ2XSxbNjEsMTEwXSxbOCw3OF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAzMDE4Mjc2ODMxODk2NDk4LDAuMDAxODY5NzIwMTUzNzAzNzI0NV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDcsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX0sXHJcbiAgICAgICc2ME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMjM1LDE1Nl0sWy0xMyw0Nl1dLFtbMjIyLDIwMl0sWy05Niw4NF1dLFtbMTE3LDI5M10sWy0yMSw0Ml1dLFtbOTYsMzM1XSxbLTU4LC0xMjldXSxbWzEyNiwyODZdLFstOSw3XV0sW1szOCwyMDZdLFstMzgsLTE3XV0sW1syODcsMTQ1XSxbLTUyLDExXV0sW1syNTMsMF0sWzM0LDE0NV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDA0ODc5NzIyODIyMjk5NTY0LDAuMDAzMDEzODc3MjYyNjg2NjAwNl0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDc0LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19XHJcbiAgICB9XHJcbiAgfSxcclxuICAyMDI0OntcclxuICAgIDMwMzU6IHtcclxuICAgICAgJzAzTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1s3MjgsMTUwOF0sWy00OCwxMl0sWy0yMiwxOF0sWy0xNSwtNV0sWy0xNiwxM10sWy0yMiwtNF0sWy0xMCw4XSxbMCwxM10sWzIxLDEzXSxbLTE2LDE3XSxbMCwxM10sWzU4LDldLFstNSw4XSxbLTEwLDIyXSxbLTE2LDE3XSxbLTI3LDI1XSxbLTIxLDEzXSxbLTMyLDI2XV0sW1sxOTEyLDBdLFstNiwzMF0sWy00Miw1MV0sWy0zMiwwXSxbLTIxLDMwXSxbMCw2OV0sWzUzLDhdLFsyMSwzNV0sWzQzLDRdLFsyNiw2MF0sWy0zNyw4MV0sWzk2LDEyOV0sWy0xNiw1MV0sWzU4LDQzXSxbMCw5XSxbLTIxLDY0XSxbMTYsMjZdLFs1LDM0XSxbMzIsNDNdLFstNTgsODVdXSxbWzI1MCw5NDJdLFstMjcsLTEzXSxbLTIxLC0xN10sWy0yMSwtOF0sWy01OSwtNzNdLFstMTYsMF0sWy0yNiwxN10sWy00MywtMTNdLFstMjEsLTIxXSxbLTE2LDBdXSxbWzE2NTcsODYxXSxbLTI3LDEzXSxbLTIxLC0xM10sWy0zMiwxM10sWy03NCwtOV0sWzE2LDQ3XSxbLTYsNDddLFsxMSwyNl0sWzUsMTIwXV0sW1sxNTI5LDExMDVdLFstMTAwLC0xN10sWy02NCw0N10sWy03NSwtMTddLFstNjMsOTRdLFstNiw2MF0sWy01LDEzXSxbLTE2LDM4XSxbLTQyLDEzXSxbLTIyLC0zOF0sWy0yMSwwXSxbLTQyLDk0XSxbLTE2LDM0XSxbMCwzMF0sWy0yMSwzMF0sWy0zMiwwXSxbLTM4LDMwXSxbLTQyLC00N10sWy04NSwzOV0sWy0zMiwtOV0sWy0xMCwtMjFdXSxbWzU0NywxNzI2XSxbLTY5LC02MF0sWy01MywtMTNdLFstNTksLTczXSxbLTExMSwtMjVdLFszMiwtNjBdLFs1OCwtMjJdLFsxNiwtMzRdLFszNywtMjZdLFsxNiwtNTFdLFstMzcsLTM5XSxbNSwtMzBdLFsxMSwtMzRdLFstMzcsLTY0XSxbLTY0LDRdLFstMjYsLTUxXSxbLTIyLC00N10sWy00Miw0XSxbLTIxLC0zNF0sWy0xMSwtNTJdLFszNywtNDddLFs0MywtMzBdXSxbWzc5NywxNDc4XSxbLTY5LDMwXV0sW1syMDI5LDg1Ml0sWy05NiwtMzhdLFstMzIsLTM5XSxbLTQyLDQzXSxbLTU5LDRdLFstMTYsMzldLFstNDIsMTNdLFstMzIsLTIyXSxbLTUzLDldXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOls1Ni45NzYyOTYwODM2MTExOSw1OC45MTUzNDY2NjUzNjMxOV0sXCJ0cmFuc2xhdGVcIjpbNTE2NzAyMC4wMzc0NTE4NzMsMjIwMjI3OC41MTAzMjU1MTY2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnMTBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzI0Miw1MDhdLFstMzMsNDddLFstMjcsMjddXSxbWzYzNywwXSxbLTI1LDQ2XSxbLTIsMTJdLFszMCwyOV0sWzcsNDddLFszNCw3NV0sWzcsNDVdLFstMTIsMzNdXSxbWzgzLDMxOF0sWy0zMiwtMThdLFstNTEsLTI2XV0sW1s1NTIsMjkwXSxbLTQ2LDVdLFszLDc4XV0sW1s1MDksMzczXSxbLTc5LDhdLFstMzAsNTldLFstMzAsM10sWy0zNCw2Ml0sWy0xOSwtMV0sWy01MiwtNl1dLFtbMTgyLDU4Ml0sWy01NSwtMzldLFstMjgsLTI1XSxbMzAsLTU2XSxbLTUsLTQ1XSxbLTU5LC02Ml0sWzE4LC0zN11dLFtbMjY1LDQ5OF0sWy0yMywxMF1dLFtbNjc2LDI4N10sWy00MywtMjFdLFstODEsMjRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsxNzEuMDc0NDk4Mjc0MzMzODIsMTc0LjcyMTQ1NzYzNjQ1NTA5XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA0XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA4XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA3XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAyXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAzXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA1XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA2XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAxXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcyME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbNTAsMTkxXSxbLTE3LC0xMV0sWy04LC0xMF0sWy0xMSwxXSxbLTE0LC02XV0sW1szMDUsMjI0XSxbLTQ0LDZdLFstNTgsNjhdLFstNDQsMl1dLFtbMTA5LDM1MF0sWy01MiwtMzZdLFsyMSwtNDVdLFstMzgsLTU0XSxbMTAsLTI0XV0sW1sxNTksMzAwXSxbLTE0LDZdXSxbWzE0NSwzMDZdLFstMzYsNDRdXSxbWzM4MSwwXSxbLTE3LDMxXSxbNDEsODVdLFstMSw1N11dLFtbNDA0LDE3M10sWy03NCwyXV0sW1szMzAsMTc1XSxbLTIwLDE1XSxbLTUsMzRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsyODYuMTMyOTQzNTYwNzU3OTUsMjkwLjUzNjgyMzg0MTE5MV0sXCJ0cmFuc2xhdGVcIjpbNTE2NzAyMC4wMzc0NTE4NzMsMjIwMjI3OC41MTAzMjU1MTY2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnNjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzI1OCwxMTFdLFstNDcsMV1dLFtbMzIsMTIzXSxbLTMyLC0xN11dLFtbMjExLDExMl0sWy0xNiwzMl1dLFtbMTk1LDE0NF0sWy05NCw0OV1dLFtbNzAsMjI1XSxbLTM4LC0xMDJdXSxbWzEwMSwxOTNdLFstOCw0XV0sW1s5MywxOTddLFstMjMsMjhdXSxbWzI0MywwXSxbMTUsMTExXV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbNDQ3Ljk4OTQzMTY0MjEyNTg1LDQ1MS45NDYxNzA0MTk2MzA1XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA3XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAxXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAyXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAzXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA1XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA2XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA0XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA4XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX1cclxuICAgIH0sXHJcbiAgICA0MzI2OiB7XHJcbiAgICAgICcwM00nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMTU0MywwXSxbLTQsMzJdLFstMjgsNjVdLFstMjQsNV0sWy0xOSwzM10sWzEwLDcwXSxbNDcsNV0sWzIzLDMzXSxbMzgsMF0sWzI4LDU5XSxbLTE5LDkyXSxbOTQsMTI0XSxbLTUsNTRdLFs1NiwzN10sWzAsMTFdLFstOSw3MF0sWzE5LDI3XSxbNCwzOF0sWzM4LDM4XSxbLTQyLDEwMl1dLFtbMTc1MCw4OTVdLFstODUsLTI3XSxbLTMyLC0zN10sWy0yOSw1NF0sWy01NiwxNl0sWy01LDQzXSxbLTMyLDE2XSxbLTMzLC0xNl0sWy00MywxNl1dLFtbMTQzNSw5NjBdLFstMjMsMjJdLFstMTksLTExXSxbLTI4LDE2XSxbLTY2LDVdLFsxOSw0NF0sWzAsNTRdLFsxNCwyNl0sWzE5LDEyNV1dLFtbMjMwLDEyNjJdLFstMjQsLTVdLFstMjMsLTE2XSxbLTE5LC0xMV0sWy01NiwtNjVdLFstMTQsMF0sWy0yNCwyN10sWy0zNywtMTFdLFstMTksLTIxXSxbLTE0LDVdXSxbWzEzNTEsMTI0MV0sWy04NCwwXSxbLTQ3LDU5XSxbLTcxLC02XSxbLTQyLDExNF0sWzUsNjRdLFstNSwxMV0sWy05LDQzXSxbLTMzLDIyXSxbLTI0LC0zOF0sWy0yMyw2XSxbLTIzLDEwOF0sWy01LDM3XSxbMCwzM10sWy0xNCwzMl0sWy0yOCw1XSxbLTI5LDM4XSxbLTQyLC00M10sWy03MCw1NF0sWy0yOCwtNV0sWy0xMCwtMjJdXSxbWzU4MiwyMDU1XSxbLTY2LC00OV0sWy00NywtNV0sWy02MSwtNzBdLFstMTAzLC0xMV0sWzE5LC03MF0sWzUxLC0zMl0sWzEwLC0zOF0sWzI4LC0zMl0sWzksLTU0XSxbLTM3LC00NF0sWzQsLTI2XSxbNSwtMzhdLFstMzcsLTY1XSxbLTYxLDExXSxbLTI5LC00OV0sWy0yMywtNDhdLFstMzMsMTFdLFstMjgsLTMzXSxbLTE0LC01NF0sWzI4LC01NF0sWzMzLC00M11dLFtbNzY5LDE3NTNdLFstNTYsNDhdXSxbWzcxMywxODAxXSxbLTQyLDE3XSxbLTE0LDIxXSxbLTE5LDBdLFstOSwxNl0sWy0xOSwwXSxbLTEwLDZdLFs1LDE2XSxbMTksMTFdLFstOSwyMV0sWzAsMTFdLFs1MSwwXSxbLTUsMTFdLFstNCwyMl0sWy0xMCwyNl0sWy0yMywyN10sWy0xOSwyMl0sWy0yMywyN11dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAwNzk5NDI2MTMyMDIwODg2MiwwLjAwMDQ5MTMzODQzNTUzNDkxNjldLFwidHJhbnNsYXRlXCI6WzIwLjM1MzYxNzY4MDg4NDA1LDQyLjI2MjE2MzEwODE1NTQwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzEwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1s1MzksMF0sWy0xNyw1Ml0sWzAsMTNdLFszMCwyN10sWzEzLDQ4XSxbNDEsNzRdLFsxMyw0N10sWy04LDM4XV0sW1s2MTEsMjk5XSxbLTQxLC0xNl0sWy02OSwzN11dLFtbNTAxLDMyMF0sWy00MSwxM10sWzEyLDgxXV0sW1s4MCw0MjFdLFstMzEsLTEyXSxbLTQ5LC0yMF1dLFtbNDcyLDQxNF0sWy03MSwyNF0sWy0xOCw2Nl0sWy0yOCw3XSxbLTIxLDcyXSxbLTE4LDBdLFstNDcsMl1dLFtbMjAzLDY4Nl0sWy01NCwtMzJdLFstMjksLTIyXSxbMjEsLTYzXSxbLTEyLC00N10sWy02MCwtNTddLFsxMSwtNDRdXSxbWzI2OSw1ODVdLFstMjAsMTZdXSxbWzI0OSw2MDFdLFstMjUsNTNdLFstMjEsMzJdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwMjI5MDA5ODM0OTgyODYzOCwwLjAwMTQ3MTg2NjU5NjI0NTI2ODVdLFwidHJhbnNsYXRlXCI6WzIwLjM1MzYxNzY4MDg4NDA1LDQyLjI2MjE2MzEwODE1NTQwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzIwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1szMzcsMF0sWy0xMiwzNl0sWzUxLDg0XSxbNiw2Ml1dLFtbMzgyLDE4Ml0sWy02OSwxM11dLFtbMzEzLDE5NV0sWy0xNywyMF0sWy0xLDM3XV0sW1s1MCwyNTZdLFstMTcsLTEwXSxbLTgsLThdLFstMTEsM10sWy0xNCwtNV1dLFtbMjk1LDI1Ml0sWy00MCwxM10sWy00Niw4Ml0sWy00MSw5XV0sW1sxMjcsNDE3XSxbLTU0LC0zMF0sWzE1LC01MV0sWy00NCwtNTNdLFs2LC0yN11dLFtbMTY4LDM1Nl0sWy0xMiwxMF1dLFtbMTU2LDM2Nl0sWy0yOSw1MV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAzNjYxODMyMzA2Mjc1MDAxNywwLjAwMjQyMTM0NDA4ODc4NzE4MDVdLFwidHJhbnNsYXRlXCI6WzIwLjM1MzYxNzY4MDg4NDA1LDQyLjI2MjE2MzEwODE1NTQwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzYwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1syMjAsMF0sWzI5LDExNl1dLFtbMjQ5LDExNl0sWy00NSw4XV0sW1syMDQsMTI0XSxbLTEyLDM3XV0sW1sxOTIsMTYxXSxbLTgzLDY2XV0sW1sxMDksMjI3XSxbLTgsNl1dLFtbMzMsMTYzXSxbLTMzLC0xMl1dLFtbODMsMjY2XSxbLTUwLC0xMDNdXSxbWzEwMSwyMzNdLFstMTgsMzNdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwNTYxNzc1MDc2NzA1NjQyNywwLjAwMzc5NTg2NjQ4NTA1MzU4N10sXCJ0cmFuc2xhdGVcIjpbMjAuMzUzNjE3NjgwODg0MDUsNDIuMjYyMTYzMTA4MTU1NDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IsIGV4ZWN1dGVGb3JBbGxJbnNldHMgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuLy8gaGFuZGxlcyBhbGwgbWFwIGxhYmVscyBlLmcuIHN0YXQgdmFsdWVzLCBvciBsYWJlbHMgc3BlY2lmaWVkIGluIG1hcC5sYWJlbHMoe2xhYmVsczpbdGV4dDonbXlMYWJlbCcsIHg6MTIzLCB5OiAxMjNdfSlcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gYWRkTGFiZWxzVG9NYXBcclxuICogQHBhcmFtIG1hcCBldXJvc3RhdG1hcCBtYXAgaW5zdGFuY2VcclxuICogQHBhcmFtIHpnIHpvb21ncm91cCAoZDMgc2VsZWN0aW9uIG9mIHpvb21hYmxlIGVsZW1lbnRzKVxyXG4gKiBAZGVzY3JpcHRpb24gYXBwZW5kcyB0ZXh0IGxhYmVscyB0byB0aGUgbWFwLiBMYWJlbHMgY2FuIGJlIGNvdW50cmllcywgY291bnRyeSBjb2Rlcywgb2NlYW4gbmFtZXMgb3Igc3RhdGlzdGljYWwgdmFsdWVzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWRkTGFiZWxzVG9NYXAgPSBmdW5jdGlvbiAobWFwLCB6Zykge1xyXG4gICAgLy8gc2V0IGRlZmF1bHRzXHJcbiAgICBpZiAoIW1hcC5sYWJlbHNfLmNvbmZpZykgbWFwLmxhYmVsc18uY29uZmlnID0gREVGQVVMVExBQkVMU1xyXG4gICAgaWYgKCFtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zKSBtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zID0gREVGQVVMVFNUQVRMQUJFTFBPU0lUSU9OU1xyXG5cclxuICAgIC8vIGNsZWFyIGV4aXN0aW5nIG9yIGFwcGVuZCBuZXcgY29udGFpbmVyXHJcbiAgICBsZXQgZXhpc3RpbmcgPSB6Zy5zZWxlY3QoJyNlbS1sYWJlbHMnKVxyXG4gICAgbGV0IGxhYmVsc0NvbnRhaW5lciA9IGV4aXN0aW5nLmVtcHR5KCkgPyB6Zy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1sYWJlbHMnKSA6IGV4aXN0aW5nXHJcblxyXG4gICAgLy9mb3Igc3RhdGlzdGljYWwgdmFsdWVzIG9uIG1hcHMgd2l0aG91dCBjZW50cm9pZHMsIHdlIG5lZWQgdG8gYWRkIGNlbnRyb2lkcyBpbml0aWFsbHksIHRoZW4gYWRkIHRleHQgdG8gdGhlbSBsYXRlciBvbmNlIHRoZSBzdGF0IGRhdGEgaXMgbG9hZGVkXHJcbiAgICBpZiAobWFwLmxhYmVsc18/LnZhbHVlcyAmJiBtYXAuX21hcFR5cGUgIT09ICdwcycpIGFwcGVuZFN0YXRMYWJlbENlbnRyb2lkc1RvTWFwKG1hcCwgbGFiZWxzQ29udGFpbmVyKVxyXG5cclxuICAgIC8vIGdldCBsYWJlbHMgYXJyYXlcclxuICAgIGxldCBsYWJlbHNBcnJheSA9IG1hcC5sYWJlbHNfPy5sYWJlbHMgfHwgREVGQVVMVExBQkVMU1tgJHttYXAuZ2VvfV8ke21hcC5wcm9qX30uY2NgXVxyXG5cclxuICAgIC8vIGFwcGVuZCBvdGhlciBsYWJlbHMgdG8gbWFwXHJcbiAgICBpZiAobGFiZWxzQXJyYXkpIHtcclxuICAgICAgICAvL2NvbW1vbiBzdHlsZXMgYmV0d2VlbiBhbGwgbGFiZWwgc2hhZG93c1xyXG4gICAgICAgIGNvbnN0IHNoYWRvd2cgPSBsYWJlbHNDb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGFiZWwtc2hhZG93cycpLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcblxyXG4gICAgICAgIC8vY29tbW9uIHN0eWxlcyBiZXR3ZWVuIGFsbCBsYWJlbHNcclxuICAgICAgICBjb25zdCBsYWJlbGcgPSBsYWJlbHNDb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGFiZWxzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAgICAgLy9TSEFET1dTXHJcbiAgICAgICAgaWYgKG1hcC5sYWJlbHNfPy5zaGFkb3dzKSB7XHJcbiAgICAgICAgICAgIGxldCBzaGFkb3dzID0gc2hhZG93Z1xyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShsYWJlbHNBcnJheSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAnZW0tbGFiZWwtc2hhZG93LScgKyBkLnRleHQucmVwbGFjZSgvXFxzKy9nLCAnLScpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgKGQpID0+ICdlbS1sYWJlbC1zaGFkb3cgZW0tbGFiZWwtc2hhZG93LScgKyBkLmNsYXNzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvL2ZvciByb3RhdGVkIHRleHQsIHggYW5kIHkgcG9zaXRpb25zIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVswXVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZC5yb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLy9mb3Igcm90YXRlZCB0ZXh0LCB4IGFuZCB5IHBvc2l0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgdHJhbnNmb3JtIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlbMV1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAtNykgLy8gc2V0IHkgcG9zaXRpb24gb2YgYm90dG9tIG9mIHRleHRcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gcG9zWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB5ID0gcG9zWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSkgcm90YXRlKCR7ZC5yb3RhdGV9KWBcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSgwKSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC50ZXh0XHJcbiAgICAgICAgICAgICAgICB9KSAvLyBkZWZpbmUgdGhlIHRleHQgdG8gZGlzcGxheVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9MQUJFTCB0ZXh0c1xyXG4gICAgICAgIGxhYmVsZ1xyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgLmRhdGEobGFiZWxzQXJyYXkpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gJ2VtLWxhYmVsLScgKyBkLnRleHQucmVwbGFjZSgvXFxzKy9nLCAnLScpKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAoZCkgPT4gJ2VtLWxhYmVsIGVtLWxhYmVsLScgKyBkLmNsYXNzKVxyXG4gICAgICAgICAgICAvL3Bvc2l0aW9uIGxhYmVsXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8vZm9yIHJvdGF0ZWQgdGV4dCwgeCBhbmQgeSBwb3NpdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVswXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5yb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvL2ZvciByb3RhdGVkIHRleHQsIHggYW5kIHkgcG9zaXRpb25zIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlbMV1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgLTcpIC8vIHNldCB5IHBvc2l0aW9uIG9mIGJvdHRvbSBvZiB0ZXh0XHJcbiAgICAgICAgICAgIC8vdHJhbnNmb3JtIGxhYmVscyB3aGljaCBoYXZlIGEgXCJyb3RhdGVcIiBwcm9wZXJ0eSBpbiB0aGUgbGFiZWxzIGNvbmZpZy4gRm9yIHJvdGF0ZWQgbGFiZWxzLCB0aGVpciBYLFkgbXVzdCBhbHNvIGJlIHNldCBpbiB0aGUgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICAvLyBub3RlOiBkb250IGFwcGx5IHRvIGNvdW50cnkgY29kZSBsYWJlbHNcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5yb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBwb3NbMF1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHBvc1sxXVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSkgcm90YXRlKCR7ZC5yb3RhdGV9KWBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyb3RhdGUoMCknXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC50ZXh0XHJcbiAgICAgICAgICAgIH0pIC8vIGRlZmluZSB0aGUgdGV4dCB0byBkaXNwbGF5XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gdXBkYXRlTGFiZWxzXHJcbiAqIEBkZXNjcmlwdGlvbiB1cGRhdGUgZXhpc3RpbmcgbWFwIGxhYmVsc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUxhYmVscyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGxhYmVsc1xyXG4gICAgICAgIGxldCBwcmV2TGFiZWxzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCcjZW0tbGFiZWxzID4gKicpXHJcbiAgICAgICAgaWYgKHByZXZMYWJlbHMpIHByZXZMYWJlbHMucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gTWFpbiBtYXBcclxuICAgICAgICBpZiAobWFwLmxhYmVsc18pIHtcclxuICAgICAgICAgICAgY29uc3QgbWFzdGVyQ29uZmlnID0gbWFwLmxhYmVsc19cclxuICAgICAgICAgICAgbGV0IHpnID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAgICAgYWRkTGFiZWxzVG9NYXAobWFwLCB6ZylcclxuICAgICAgICAgICAgaWYgKG1hc3RlckNvbmZpZy52YWx1ZXMgJiYgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERlZmluZSB0aGUgY2FsbGJhY2sgdG8gYXBwbHkgdG8gZWFjaCBpbnNldFxyXG4gICAgICAgICAgICBjb25zdCBhcHBseUxhYmVsc0NhbGxiYWNrID0gKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB6ZyA9IG1hcC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG1hcC5zdmdJZF8pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5sYWJlbHNfKSBhZGRMYWJlbHNUb01hcChtYXAsIHpnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXN0ZXJDb25maWcudmFsdWVzICYmIG1hcC51cGRhdGVWYWx1ZXNMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscyhtYXApXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBsYWJlbHMgdG8gYWxsIGluc2V0cyB1c2luZyB0aGUgZXhlY3V0ZUZvckFsbEluc2V0cyBmdW5jdGlvblxyXG4gICAgICAgICAgICBpZiAobWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhtYXAuaW5zZXRUZW1wbGF0ZXNfLCBtYXAuc3ZnSWRfLCBhcHBseUxhYmVsc0NhbGxiYWNrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSB0aGUgc3RhdGlzdGljYWwgdmFsdWVzIGxhYmVscyBvbiB0aGUgbWFwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgZXVyb3N0YXQtbWFwIG1hcCBpbnN0YW5jZVxyXG4gKiBAcmV0dXJuIHttYXB9IG91dFxyXG4gKiBOT1RFOiBUSElTIEZVTkNUSU9OIElTIE5PVCBDQUxMRUQgRk9SIFBST1BPUlRJT05BTCBTWU1CT0wgTUFQU1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVZhbHVlc0xhYmVscyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIGlmICghbWFwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBtYXAgc3BlY2lmaWVkJylcclxuICAgICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvL2NsZWFyIHByZXZpb3VzIGxhYmVsc1xyXG4gICAgbGV0IHByZXZMYWJlbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ2cuZW0tc3RhdC1sYWJlbCA+IConKVxyXG4gICAgcHJldkxhYmVscy5yZW1vdmUoKVxyXG4gICAgbGV0IHByZXZTaGFkb3dzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCdnLmVtLXN0YXQtbGFiZWwtc2hhZG93ID4gKicpXHJcbiAgICBwcmV2U2hhZG93cy5yZW1vdmUoKVxyXG4gICAgbGV0IHN0YXRMYWJlbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ2cuZW0tc3RhdC1sYWJlbCcpXHJcblxyXG4gICAgLy8gZmlsdGVyIHN0YXQtbGFiZWwgZWxlbWVudHMgdG8gb25seSBzaG93IHRob3NlIHdpdGggZGF0YVxyXG4gICAgY29uc3QgZmlsdGVyRnVuY3Rpb24gPSBtYXAubGFiZWxzXz8uc3RhdExhYmVsc0ZpbHRlckZ1bmN0aW9uID8gbWFwLmxhYmVsc18/LnN0YXRMYWJlbHNGaWx0ZXJGdW5jdGlvbiA6IGRlZmF1bHRTdGF0TGFiZWxGaWx0ZXJcclxuICAgIGNvbnN0IHN0YXREYXRhID0gbWFwLnN0YXREYXRhKClcclxuICAgIHN0YXRMYWJlbHNcclxuICAgICAgICAuZmlsdGVyKChyZykgPT4gZmlsdGVyRnVuY3Rpb24ocmcsIG1hcCkpXHJcbiAgICAgICAgLy8gLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHN0YXRMYWJlbHNUZXh0RnVuY3Rpb24oZCwgc3RhdERhdGEpIC8vIFVzZSAnZCcgZGlyZWN0bHkgZm9yIHRoZSBsYWJlbCB0ZXh0XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlIGJlaGluZCBsYWJlbFxyXG4gICAgICAgICAgICBpZiAobWFwLmxhYmVsc18uYmFja2dyb3VuZHMpIGFwcGVuZFJlY3QobGFiZWxUZXh0LCBzZWwpXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGV4dCBhZnRlciB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIHNlbC5hcHBlbmQoJ3RleHQnKS50ZXh0KGxhYmVsVGV4dCkuYXR0cignY2xhc3MnLCAnZW0tc3RhdC1sYWJlbC10ZXh0JylcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIGFwcGVuZCBhIHJlY3RhbmdsZSBiZWhpbmQgdGhlIGxhYmVsXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRSZWN0KGxhYmVsVGV4dCwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSA1IC8vIEFkZCBzb21lIHBhZGRpbmcgYXJvdW5kIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSAyIC8vIEFkZCBzb21lIHBhZGRpbmcgYXJvdW5kIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgdG8gZ2V0IHRoZSBzaXplXHJcbiAgICAgICAgY29uc3QgYmJveCA9IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykgLy8gTWFrZSB0aGUgdGVtcG9yYXJ5IHRleHQgaW52aXNpYmxlXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsVGV4dCkgLy8gU2V0IHRoZSBsYWJlbCB0ZXh0IHRvIGdldCBpdHMgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgIC5ub2RlKClcclxuICAgICAgICAgICAgLmdldEJCb3goKSAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGV4dFxyXG5cclxuICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gYmJveC53aWR0aFxyXG4gICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gYmJveC5oZWlnaHRcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgdGV4dCBlbGVtZW50IGFmdGVyIGdldHRpbmcgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3QoJ3RleHRbdmlzaWJpbGl0eT1cImhpZGRlblwiXScpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZSB0byBiZSBjZW50ZXJlZCBvbiB0aGUgdGV4dFxyXG4gICAgICAgIGNvbnN0IHggPSAtbGFiZWxXaWR0aCAvIDIgLSBwYWRkaW5nWCAvLyBDZW50ZXIgdGhlIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgY29uc3QgeSA9IC1sYWJlbEhlaWdodCAvIDIgLSBwYWRkaW5nWSAvLyBDZW50ZXIgdGhlIHJlY3QgdmVydGljYWxseVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlIHdpdGggcGFkZGluZ1xyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB4KSAvLyBQb3NpdGlvbiByZWN0IGhvcml6b250YWxseVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHkpIC8vIFBvc2l0aW9uIHJlY3QgdmVydGljYWxseVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBsYWJlbFdpZHRoICsgMiAqIHBhZGRpbmdYKSAvLyBXaWR0aCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGxhYmVsSGVpZ2h0ICsgMiAqIHBhZGRpbmdZKSAvLyBIZWlnaHQgb2YgdGhlIHJlY3Qgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgIH1cclxuXHJcbiAgICAvL2FkZCBzaGFkb3dzIHRvIGxhYmVsc1xyXG4gICAgaWYgKG1hcC5sYWJlbHNfPy5zaGFkb3dzKSB7XHJcbiAgICAgICAgbWFwLnN2Z19cclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZy5lbS1zdGF0LWxhYmVsLXNoYWRvdycpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHJnKSA9PiBmaWx0ZXJGdW5jdGlvbihyZywgbWFwKSlcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiBzdGF0TGFiZWxzVGV4dEZ1bmN0aW9uKGQsIHN0YXREYXRhKSkgLy8gVXNlICdkJyBkaXJlY3RseSBmb3IgdGhlIGxhYmVsIHRleHQpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gdGV4dCBmdW5jdGlvbiBmb3Igc3RhdGlzdGljYWwgbGFiZWxsaW5nXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIGQzIHNlbGVjdGlvbiBqc29uIGRhdGEgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdExhYmVsc1RleHRGdW5jdGlvbiA9IChkLCBzdGF0RGF0YSkgPT4ge1xyXG4gICAgaWYgKHN0YXREYXRhICYmIHN0YXREYXRhPy5nZXQpIHtcclxuICAgICAgICBjb25zdCBzdiA9IHN0YXREYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJydcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc3YudmFsdWUgIT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdi52YWx1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIHN0YXRpc3RpY2FsIGxhYmVsc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZCBkMyBzZWxlY3Rpb24ganNvbiBkYXRhIGVsZW1lbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRTdGF0TGFiZWxGaWx0ZXIgPSAocmVnaW9uLCBtYXApID0+IHtcclxuICAgIGNvbnN0IHMgPSBtYXAuc3RhdERhdGEoKVxyXG4gICAgY29uc3Qgc3YgPSBzLmdldChyZWdpb24ucHJvcGVydGllcy5pZClcclxuICAgIGlmICghc3YgfHwgKCFzdi52YWx1ZSAmJiBzdiAhPT0gMCAmJiBzdi52YWx1ZSAhPT0gMCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgYXBwZW5kU3RhdExhYmVsQ2VudHJvaWRzVG9NYXAgPSBmdW5jdGlvbiAobWFwLCBsYWJlbHNDb250YWluZXIpIHtcclxuICAgIC8vdmFsdWVzIGxhYmVsIHNoYWRvd3MgcGFyZW50IDxnPlxyXG4gICAgY29uc3QgZ3NscyA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVscy1zaGFkb3dzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAvLyB2YWx1ZXMgbGFiZWxzIHBhcmVudCA8Zz5cclxuICAgIGNvbnN0IHN0YXRMYWJlbHNHcm91cCA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVscycpLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcblxyXG4gICAgLy8gb3VyIGZlYXR1cmVzIGFycmF5XHJcbiAgICBsZXQgc3RhdExhYmVsUmVnaW9ucyA9IFtdXHJcblxyXG4gICAgLy8gZGVhZnVsdCBnZW9tZXRyaWVzXHJcbiAgICBpZiAobWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c3JnKSB7XHJcbiAgICAgICAgLy9hbGxvdyBmb3Igc3RhdCBsYWJlbCBwb3NpdGlvbmluZyBieSBhZGRpbmcgYSBnIGVsZW1lbnQgaGVyZSwgdGhlbiBhZGRpbmcgdGhlIHZhbHVlcyBpbiB0aGUgbWFwVHlwZSB1cGRhdGVWYWx1ZXNMYWJlbHMgZnVuY3Rpb25cclxuICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICBzdGF0TGFiZWxSZWdpb25zID0gbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmcwLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm1peGVkLnJnMSxcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm1peGVkLnJnMixcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm1peGVkLnJnMyxcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLmNudHJnIC8vIE5FVzogYWxsb3cgbGFiZWxzIGZvciBjbnRyZ1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdExhYmVsUmVnaW9ucyA9IG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm51dHNyZy5jb25jYXQobWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMuY250cmcpXHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykge1xyXG4gICAgICAgIC8vIHVzZXIgZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgc3RhdExhYmVsUmVnaW9ucyA9IG1hcC5HZW9tZXRyaWVzLnN0YXRpc3RpY2FsUmVnaW9ucy5mZWF0dXJlc1xyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETzogZG9udCBhZGQgbGFiZWxzIGZvciByZWdpb25zIHRoYXQgYXJlIG5vdCB2aXNpYmxlPyB3aGF0IGFib3V0IHBhbm5pbmcgYW5kIHpvb21pbmcgdGhvdWdoLiBPbmx5IHJlYWxseSBhbiBpc3N1ZSBmb3IgbWl4ZWQgTlVUUy5cclxuXHJcbiAgICAvLyBzdGF0cyBsYWJlbHNcclxuICAgIGNvbnN0IGZpbHRlcmVkUmVnaW9ucyA9IHN0YXRMYWJlbFJlZ2lvbnMuZmlsdGVyKChkLCBpLCBzZWxmKSA9PiBpID09PSBzZWxmLmZpbmRJbmRleCgodCkgPT4gdC5wcm9wZXJ0aWVzLmlkID09PSBkLnByb3BlcnRpZXMuaWQpKVxyXG4gICAgc3RhdExhYmVsc0dyb3VwXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgLmRhdGEoZmlsdGVyZWRSZWdpb25zKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSBwcmVkZWZpbmVkIGxhYmVsIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zW2QucHJvcGVydGllcy5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWFwLmxhYmVsc18uc3RhdExhYmVsc1Bvc2l0aW9uc1tkLnByb3BlcnRpZXMuaWRdXHJcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gbWFwLl9wcm9qZWN0aW9uKFtwb3NpdGlvbi54LCBwb3NpdGlvbi55XSlcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gcG9zWzBdLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gcG9zWzFdLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VudHJvaWQgPSBtYXAuX3BhdGhGdW5jdGlvbi5jZW50cm9pZChkKVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5wcm9jZXNzVmFsdWVMYWJlbENlbnRyb2lkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkID0gbWFwLmxhYmVsc18ucHJvY2Vzc1ZhbHVlTGFiZWxDZW50cm9pZHMoZCwgY2VudHJvaWQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgY2FsY3VsYXRlIGNlbnRyb2lkc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGNlbnRyb2lkICsgJyknXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVsJylcclxuXHJcbiAgICAvLyBzdGF0IGxhYmVscyBzaGFkb3dzXHJcbiAgICBpZiAobWFwLmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICBnc2xzLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgIC5kYXRhKHN0YXRMYWJlbFJlZ2lvbnMpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHVzZSBwcmVkZWZpbmVkIGxhYmVsIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmxhYmVsc18uc3RhdExhYmVsc1Bvc2l0aW9uc1tkLnByb3BlcnRpZXMuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IG1hcC5fcHJvamVjdGlvbihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnNbZC5wcm9wZXJ0aWVzLmlkXS54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zW2QucHJvcGVydGllcy5pZF0ueSxcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4ID0gcG9zWzBdLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHBvc1sxXS50b0ZpeGVkKDMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwke3l9KWBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbnRyb2lkID0gbWFwLl9wYXRoRnVuY3Rpb24uY2VudHJvaWQoZClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5sYWJlbHNfLnByb2Nlc3NWYWx1ZUxhYmVsQ2VudHJvaWRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkID0gbWFwLmxhYmVsc18ucHJvY2Vzc1ZhbHVlTGFiZWxDZW50cm9pZHMoZCwgY2VudHJvaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBjYWxjdWxhdGUgY2VudHJvaWRzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGNlbnRyb2lkICsgJyknXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc3RhdC1sYWJlbC1zaGFkb3cnKVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBsYWJlbHMgZm9yIGNvdW50cnkgLyBnZW9ncmFwaGljYWwgbmFtZXMuXHJcbiAqIFVzaW5nIGNlbnRyb2lkcyB3b3VsZCBjbGFzaCB3aXRoIHByb3BvcnRpb25hbCBzeW1ib2xzLCBhbmQgYXJlIGdlbmVyYWxseSBub3QgaWRlYWwgcGxhY2VtZW50cywgc28gbGFiZWxzIGFyZSBwb3NpdGlvbmVkIGluZGVwZW5kZW50bHlcclxuICogTGFiZWxzIGFyZSBwcm92aWRlZCBmb3IgYWxsIHN1cHBvcnRlZCBsYW5ndWFnZXM6IFwiZW5cIixcImZyXCIgYW5kIFwiZGVcIiAoZGVmaW5lZCB1c2luZyBtYXAubGFuZ3VhZ2UoKSlcclxuICovXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUTEFCRUxTID0ge1xyXG4gICAgRVVSXzMwMzU6IHtcclxuICAgICAgICBjYzogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTCcsIHg6IDUxNTAwMDAsIHk6IDIwNjAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FUJywgeDogNDY3MDAwMCwgeTogMjY5MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE4IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JFJywgeDogMzkzMDAwMCwgeTogMzAxMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JHJywgeDogNTU2NzAwMCwgeTogMjI1MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0hSJywgeDogNDg0MDAwMCwgeTogMjQ4MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NZJywgeDogNjQyNjAwMCwgeTogMTQ4MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NaJywgeDogNDcwNzAwMCwgeTogMjkyMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE4IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RLJywgeDogNDMxNjAwMCwgeTogMzYyMTAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VFJywgeDogNTIyMDAwMCwgeTogMzk5MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZJJywgeDogNTE1MDAwMCwgeTogNDQyNDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSJywgeDogMzc2Nzc0MCwgeTogMjY2MjgxNywgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RFJywgeDogNDM0NzI4NCwgeTogMzA5MzI3NiwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VMJywgeDogNTM3MDAwMCwgeTogMTc1MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0hVJywgeDogNTAyMDAwMCwgeTogMjYzMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lTJywgeDogMzA0MDAwMCwgeTogNDgzMzAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lFJywgeDogMzEzNjAwMCwgeTogMzM5NDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lUJywgeDogNDQ2OTk2NywgeTogMjE4MTk2MywgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xWJywgeDogNTI5MDAwMCwgeTogMzgwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xUJywgeDogNTE5MDAwMCwgeTogMzYzMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xVJywgeDogNDEyMDAwMCwgeTogMjk0MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01UJywgeDogNDczMTAwMCwgeTogMTMwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FJywgeDogNTA3MzAwMCwgeTogMjE4NTAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR0UnLCB4OiA2OTQyNjgwLCB5OiAyNjYwMDAwLCBjbGFzczogJ2NjJyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdVQScsIHg6IDU4OTAwMDAsIHk6IDMwNTAwMDAsIGNsYXNzOiAnY2MnIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JBJywgeDogNDk0OTI2MiwgeTogMjMzODY4OCwgY2xhc3M6ICdjYycgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUQnLCB4OiA1NzQwMDAwLCB5OiAyNzkwMDAwLCBjbGFzczogJ2NjJyB9LFxyXG5cclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUsnLCB4OiA1MzAwMDAwLCB5OiAyMDgwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTkwnLCB4OiA0MDIwMDAwLCB5OiAzMjA4MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk8nLCB4OiA0MzAwMDAwLCB5OiA0MTQ3MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUEwnLCB4OiA0OTY0MDAwLCB5OiAzMjAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUFQnLCB4OiAyNzcwMDAwLCB5OiAxOTkwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTggfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUk8nLCB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUlMnLCB4OiA1MjAwMDAwLCB5OiAyMzUwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0snLCB4OiA1MDQwMDAwLCB5OiAyODYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0knLCB4OiA0Njc1MDAwLCB5OiAyNTAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRVMnLCB4OiAzMTYwMDk2LCB5OiAxOTAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0UnLCB4OiA0NjMwMDAwLCB5OiA0MDAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ0gnLCB4OiA0MTcwMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTYgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFInLCB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVUsnLCB4OiAzNTU4MDAwLCB5OiAzMjUwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTcgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGVuOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FRElURVJSQU5FQU4gU0VBJywgeDogMzk4MDAwMCwgeTogMTYwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQVRMQU5USUMgT0NFQU4nLCB4OiAyODIwMDAwLCB5OiAyNTQwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JUSCBTRUEnLCB4OiAzOTE1MDAwLCB5OiAzNzAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCQUxUSUMgU0VBJywgeDogNDkwMDAwMCwgeTogMzczMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTUwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUldFR0lBTiBTRUEnLCB4OiAzODUwMDAwLCB5OiA0ODAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCTEFDSyBTRUEnLCB4OiA2MzAwMDAwLCB5OiAyNTAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogNCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTEJBTklBJywgY2M6ICdBTCcsIHg6IDUxMDAwMDAsIHk6IDIwNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiA4MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVVNUUklBJywgY2M6ICdBVCcsIHg6IDQ2NzAwMDAsIHk6IDI2MjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkVMR0lVTScsIGNjOiAnQkUnLCB4OiAzOTAwMDAwLCB5OiAzMDMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQlVMR0FSSUEnLCBjYzogJ0JHJywgeDogNTU2NzAwMCwgeTogMjI1NjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDUk9BVElBJywgY2M6ICdIUicsIHg6IDQ4NzYwMDAsIHk6IDI0NTUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDWVBSVVMnLCBjYzogJ0NZJywgeDogNjQyNjAwMCwgeTogMTQ4MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDWkVDSElBJywgY2M6ICdDWicsIHg6IDQ3MDcwMDAsIHk6IDI4ODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnREVOTUFSSycsIGNjOiAnREsnLCB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTVE9OSUEnLCBjYzogJ0VFJywgeDogNTIyMDAwMCwgeTogMzk5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZJTkxBTkQnLCBjYzogJ0ZJJywgeDogNTE1MDAwMCwgeTogNDQyNDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUkFOQ0UnLCBjYzogJ0ZSJywgeDogMzc2Nzc0MCwgeTogMjY2MjgxNywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdHRVJNQU5ZJywgY2M6ICdERScsIHg6IDQzNDcyODQsIHk6IDMwOTMyNzYsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR1JFRUNFJywgY2M6ICdFTCcsIHg6IDU0NzAwMDAsIHk6IDE4NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSFVOR0FSWScsIGNjOiAnSFUnLCB4OiA1MDIwMDAwLCB5OiAyNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lDRUxBTkQnLCBjYzogJ0lTJywgeDogMzA0MDAwMCwgeTogNDgzMzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJUkVMQU5EJywgY2M6ICdJRScsIHg6IDMxMzYwMDAsIHk6IDMzOTQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVRBTFknLCBjYzogJ0lUJywgeDogNDQ2OTk2NywgeTogMjE4MTk2MywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMQVRWSUEnLCBjYzogJ0xWJywgeDogNTI5MDAwMCwgeTogMzgwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xJVEhVQU5JQScsIGNjOiAnTFQnLCB4OiA1MTkwMDAwLCB5OiAzNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFVYLicsIGNjOiAnTFUnLCB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUFMVEEnLCBjYzogJ01UJywgeDogNDczMTAwMCwgeTogMTMzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01PTlQuJywgY2M6ICdNRScsIHg6IDUwNzMwMDAsIHk6IDIxODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOLiBNQUNFRE9OSUEnLCBjYzogJ01LJywgeDogNTMwMDAwMCwgeTogMjA4MjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05FVEhFUkxBTkRTJywgY2M6ICdOTCcsIHg6IDM5NzcwMDAsIHk6IDMyMDgwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JXQVknLCBjYzogJ05PJywgeDogNDMzMDAwMCwgeTogNDE0NzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9MQU5EJywgY2M6ICdQTCcsIHg6IDQ5NjQwMDAsIHk6IDMyNjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9SVFVHQUwnLCBjYzogJ1BUJywgeDogMjgzMDAwMCwgeTogMTk5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUk9NQU5JQScsIGNjOiAnUk8nLCB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NFUkJJQScsIGNjOiAnUlMnLCB4OiA1MjAwMDAwLCB5OiAyMzAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPVkFLSUEnLCBjYzogJ1NLJywgeDogNTA0MDAwMCwgeTogMjgzNTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9WRU5JQScsIGNjOiAnU0knLCB4OiA0NzM1MDAwLCB5OiAyNTIyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NQQUlOJywgY2M6ICdFUycsIHg6IDMxNjAwOTYsIHk6IDE4NTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU1dFREVOJywgY2M6ICdTRScsIHg6IDQ2MzAwMDAsIHk6IDQxMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NXSVRaRVJMQU5EJywgY2M6ICdDSCcsIHg6IDQyMDAwMDAsIHk6IDI1NjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUVVJLRVknLCBjYzogJ1RSJywgeDogNjUxMDAwMCwgeTogMjEwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdVLksuJywgY2M6ICdVSycsIHg6IDM1NTgwMDAsIHk6IDMyNTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGZyOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FUiBNw4lESVRFUlJBTsOJRScsIHg6IDU0NzIwMDAsIHk6IDEyNDIwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ09Dw4hBTiBBVExBTlRJUVVFJywgeDogMjgyMDAwMCwgeTogMjU0MDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIERVIE5PUkQnLCB4OiAzOTE1MDAwLCB5OiAzNzAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRVIgQkFMVElRVUUnLCB4OiA0OTAwMDAwLCB5OiAzNjcyMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIERFIE5PUlbDiEdFJywgeDogMzg1MDAwMCwgeTogNDgwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIE5PSVJFJywgeDogNjI2NTAwMCwgeTogMjQ3MjAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQUxCQU5JRScsIHg6IDUxMDAwMDAsIHk6IDIwNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiA4MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVVRSSUNIRScsIHg6IDQ2NzAwMDAsIHk6IDI2MjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkVMR0lRVUUnLCB4OiAzOTAwMDAwLCB5OiAzMDMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQlVMR0FSSUUnLCB4OiA1NTY3MDAwLCB5OiAyMjU2MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NST0FUSUUnLCB4OiA0ODc2MDAwLCB5OiAyNDU1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ0hZUFJFJywgeDogNjQyNjAwMCwgeTogMTQ4MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUQ0jDiVFVSUUnLCB4OiA0NzA3MDAwLCB5OiAyODg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RBTkVNQVJLJywgeDogNDMxNjAwMCwgeTogMzYyMTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFU1RPTklFJywgeDogNTIyMDAwMCwgeTogMzk5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGSU5MQU5ERScsIHg6IDUxMjUwMDAsIHk6IDQ0MjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlJBTkNFJywgeDogMzc2Nzc0MCwgeTogMjY2MjgxNywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTExFTUFHTkUnLCB4OiA0MzQ3Mjg0LCB5OiAzMDkzMjc2LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0dSw4hDRScsIHg6IDU0MjAwMDAsIHk6IDE4NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSE9OR1JJRScsIHg6IDUwMjAwMDAsIHk6IDI2NTQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVNMQU5ERScsIHg6IDMwNDAwMDAsIHk6IDQ4MzMwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVJMQU5ERScsIHg6IDMxMzYwMDAsIHk6IDMzOTQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVRBTElFJywgeDogNDUwMDAwMCwgeTogMjE4MTk2MywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMRVRUT05JRScsIHg6IDUyOTAwMDAsIHk6IDM3NzYwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTElUVUFOSUUnLCB4OiA1MTkwMDAwLCB5OiAzNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xVWC4nLCB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUFMVEUnLCB4OiA0NzMxMDAwLCB5OiAxMzM1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTU9OVC4nLCB4OiA1MDczMDAwLCB5OiAyMTg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUFDLiBEVSBOT1JEJywgeDogNTMwMDAwMCwgeTogMjA4MjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BBWVMtQkFTJywgeDogMzk3NzAwMCwgeTogMzIwODAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUlZFR0UnLCB4OiA0MzMwMDAwLCB5OiA0MTQ3MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT0xPR05FJywgeDogNDk2NDAwMCwgeTogMzI2OTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT1JUVUdBTCcsIHg6IDI4MzYxMzYsIHk6IDE5NTYxNzksIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JPVU1BTklFJywgeDogNTQ1MTAwMCwgeTogMjYwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTRVJCSUUnLCB4OiA1MjAwMDAwLCB5OiAyMzAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPVkFRVUlFJywgeDogNTA0MDAwMCwgeTogMjgzNTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9Ww4lOSUUnLCB4OiA0NzM1MDAwLCB5OiAyNTIyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTM1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTUEFHTkUnLCB4OiAzMTYwMDk2LCB5OiAxODUwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NVw4hERScsIHg6IDQ3MDAwMDAsIHk6IDQ0MDEwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NVSVNTRScsIHg6IDQyMDAwMDAsIHk6IDI1NjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUVVJRVUlFJywgeDogNjUxMDAwMCwgeTogMjEwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdST1lBVU1FLVVOSScsIHg6IDM1NTgwMDAsIHk6IDMyNTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRlOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01JVFRFTE1FRVInLCB4OiA1NDcyMDAwLCB5OiAxMjAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVExBTlRJU0NIRVIgT1pFQU4nLCB4OiAyODIwMDAwLCB5OiAyNTQwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JEU0VFJywgeDogMzkxNTAwMCwgeTogMzcwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnT1NUU0VFJywgeDogNDkwMDAwMCwgeTogMzY3MjAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTUwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUldFR0lTQ0hFIE1FRVInLCB4OiAzODUwMDAwLCB5OiA0ODAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTQ0hXQVJaRSBNRUVSJywgeDogNjMwMDAwMCwgeTogMjUwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQUxCQU5JRU4nLCB4OiA1MTAwMDAwLCB5OiAyMDYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogODAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnw5ZTVEVSUkVJQ0gnLCB4OiA0NjUwMDAwLCB5OiAyNjI5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkVMR0lFTicsIHg6IDM5MDAwMDAsIHk6IDMwMzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAzMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCVUxHQVJJRU4nLCB4OiA1NTY3MDAwLCB5OiAyMjU2MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0tST0FUSUVOJywgeDogNDg3NjAwMCwgeTogMjQ1NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1pZUEVSTicsIHg6IDY0MjYwMDAsIHk6IDE0ODAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFNDSEVDSElFTicsIHg6IDQ3MDcwMDAsIHk6IDI4ODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdEw4RORU1BUksnLCB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTVExBTkQnLCB4OiA1MjIwMDAwLCB5OiAzOTkwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRklOTkxBTkQnLCB4OiA1MTUwMDAwLCB5OiA0NDI0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSQU5LUkVJQ0gnLCB4OiAzNzY3NzQwLCB5OiAyNjYyODE3LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RFVVRTQ0hMQU5EJywgeDogNDM0NzI4NCwgeTogMzA5MzI3NiwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdHUklFQ0hFTkxBTkQnLCB4OiA1NTUwMDAwLCB5OiAxNTAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1VOR0FSTicsIHg6IDUwMjAwMDAsIHk6IDI2MzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVNMQU5EJywgeDogMzA0MDAwMCwgeTogNDgzMzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJUkxBTkQnLCB4OiAzMTM2MDAwLCB5OiAzMzk0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lUQUxJRU4nLCB4OiA0NDY5OTY3LCB5OiAyMTgxOTYzLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IDM1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xFVFRMQU5EJywgeDogNTI5MDAwMCwgeTogMzgwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xJVEFVRU4nLCB4OiA1MTkwMDAwLCB5OiAzNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFVYLicsIHg6IDQxMjAwMDAsIHk6IDI5NDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNQUxUQScsIHg6IDQ3MzEwMDAsIHk6IDEzMzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNT05ULicsIHg6IDUwNzMwMDAsIHk6IDIxODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JETUFaRURPTklFTicsIHg6IDUzNTAwMDAsIHk6IDIwODIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOSUVERVJMQU5ERScsIHg6IDM5NzcwMDAsIHk6IDMyMDgwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JXRUdFTicsIHg6IDQzMzAwMDAsIHk6IDQxNDcwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BPTEVOJywgeDogNDk2NDAwMCwgeTogMzI2OTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT1JUVUdBTCcsIHg6IDI4MzYxMzYsIHk6IDE5NTYxNzksIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JVTcOETklFTicsIHg6IDU0NTEwMDAsIHk6IDI2MDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0VSQklFTicsIHg6IDUyMDAwMDAsIHk6IDIzMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9XQUtFSScsIHg6IDUwNDAwMDAsIHk6IDI4MzUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAtMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPV0VOSUVOJywgeDogNDczNTAwMCwgeTogMjUyMjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTUEFOSUVOJywgeDogMzE2MDA5NiwgeTogMTg1MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTQ0hXRURFTicsIHg6IDQ2NzAwMDAsIHk6IDQxODAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NDSFdFSVonLCB4OiA0MjAwMDAwLCB5OiAyNTY0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFJVVEhBSE4nLCB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1ZFUkVJTklHVEVTJywgeDogMzU1MDAwMCwgeTogMzUyMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdLw5ZOSUdSRUlDSCcsIHg6IDM1NTAwMDAsIHk6IDM0MjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIElDXzMyNjI4OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdFUycsIHg6IDQyMDQ2OCwgeTogMzE4MDY0NywgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnQ2FuYXJ5IElzbGFuZHMnLCB4OiA0MjA0NjgsIHk6IDMxODA2NDcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZnI6IFt7IHRleHQ6ICdMZXMgw65sZXMgQ2FuYXJpZXMnLCB4OiA0MjA0NjgsIHk6IDMxODA2NDcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZGU6IFt7IHRleHQ6ICdLYW5hcmlzY2hlIEluc2VsbicsIHg6IDQxMDAwMCwgeTogMzE4MDY0NywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgIH0sXHJcbiAgICBHUF8zMjYyMDoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRlInLCB4OiA2NjcwMDAsIHk6IDE3NDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0d1YWRlbG91cGUnLCB4OiA3MDAwMDAsIHk6IDE4MTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICB9LFxyXG4gICAgTVFfMzI2MjA6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0ZSJywgeDogNzE2NTIxLCB5OiAxNjIxMzIyLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdNYXJ0aW5pcXVlJywgeDogNzE2NTIxLCB5OiAxNjIxMzIyLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgfSxcclxuICAgIEdGXzMyNjIyOiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdGUicsIHg6IDI2Njg1MiwgeTogNDQ0MDc0LCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdHdXlhbmUnLCB4OiAyNjY4NTIsIHk6IDQ0NDA3NCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ0d1YXlhbmEnLCB4OiAyNjY4NTIsIHk6IDQ0NDA3NCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgIH0sXHJcbiAgICBSRV8zMjc0MDoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRlInLCB4OiAzNDgwMTEsIHk6IDc2ODAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ1LDqXVuaW9uJywgeDogMzQ4MDExLCB5OiA3NjgwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgfSxcclxuICAgIFlUXzMyNzM4OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdGUicsIHg6IDUxNjU0OSwgeTogODU5MzkyMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnTWF5b3R0ZScsIHg6IDUxNjU0OSwgeTogODU5MzkyMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgIH0sXHJcbiAgICBNVF8zMDM1OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdNVCcsIHg6IDQ3MTk3NTUsIHk6IDE0MTA3MDEsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ01hbHRhJywgeDogNDcxOTc1NSwgeTogMTQxMDcwMSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgIH0sXHJcbiAgICBQVDIwXzMyNjI2OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdQVCcsIHg6IDM5NzQxOCwgeTogNDMyMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnQXpvcmVzJywgeDogMzk3NDE4LCB5OiA0MzIwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGZyOiBbeyB0ZXh0OiAnQcOnb3JlcycsIHg6IDM5NzQxOCwgeTogNDI3MTQ3MSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ0F6b3JlbicsIHg6IDM5NzQxOCwgeTogNDI3MTQ3MSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgIH0sXHJcbiAgICBQVDMwXzMyNjI4OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdQVCcsIHg6IDMzMzU4NiwgeTogMzYyNDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwLCByb3RhdGU6IDMwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnTWFkZWlyYScsIHg6IDMzMzU4NiwgeTogMzYyNDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCwgcm90YXRlOiAzMCB9XSxcclxuICAgICAgICBmcjogW3sgdGV4dDogJ01hZMOocmUnLCB4OiAzMzM1ODYsIHk6IDM2MjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogMzAgfV0sXHJcbiAgICB9LFxyXG4gICAgTElfMzAzNToge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnTEknLCB4OiA0Mjg3MDYwLCB5OiAyNjYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdMaWVjaHRlbnN0ZWluJywgeDogNDI4NzA2MCwgeTogMjY3OTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH1dLFxyXG4gICAgfSxcclxuICAgIElTXzMwMzU6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0lTJywgeDogMzAxMTgwNCwgeTogNDk2MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnSWNlbGFuZCcsIHg6IDMwMTE4MDQsIHk6IDQ5NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZnI6IFt7IHRleHQ6ICdJc2xhbmRlJywgeDogMzAxMTgwNCwgeTogNDk2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ0lzbGFuZCcsIHg6IDMwMTE4MDQsIHk6IDQ5NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICB9LFxyXG4gICAgU0pfU1ZfMzAzNToge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnTk8nLCB4OiA0NTcwMDAwLCB5OiA2MjYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdTdmFsYmFyZCcsIHg6IDQ1NzAwMDAsIHk6IDYyNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZGU6IFt7IHRleHQ6ICdTcGl0emJlcmdlbicsIHg6IDQ1NzAwMDAsIHk6IDYyNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9XSxcclxuICAgIH0sXHJcbiAgICBTSl9KTV8zMDM1OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdOTycsIHg6IDM2NDc3NjIsIHk6IDU0MjAzMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0phbiBNYXllbicsIHg6IDM2NDc3NjIsIHk6IDU0MjAzMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9XSxcclxuICAgIH0sXHJcbiAgICBDQVJJQl8zMjYyMDoge1xyXG4gICAgICAgIGNjOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSJywgeDogNzAwMDAwLCB5OiAxODEwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlInLCB4OiA2NDAwMDAsIHk6IDE1OTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUicsIHg6IDU0MDAwMCwgeTogMTk2MjAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDcgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGVuOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0d1YWRlbG91cGUnLCB4OiA3MDAwMDAsIHk6IDE4MTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTWFydGluaXF1ZScsIHg6IDU3MDAwMCwgeTogMTU5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTYWludCBNYXJ0aW4nLCB4OiA1OTcwMDAsIHk6IDE5NjIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAgLy8gbm90ZTogV09STEQgeC95IGFyZSBpbiBFUFNHOjQzMjYgdGhlbiByZXByb2plY3RlZCBieSBkMyB0byBFUFNHOjU0MDMwXHJcbiAgICBXT1JMRF81NDAzMDoge1xyXG4gICAgICAgIGVuOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUlRIIEFUTEFOVElDJywgeDogLTQ1LCB5OiAyNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU09VVEggQVRMQU5USUMnLCB4OiAtMTUsIHk6IC0yNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU09VVEggUEFDSUZJQycsIHg6IC0xMjYsIHk6IC0yNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SVEgnLCB4OiAtMTM2LCB5OiAyNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUEFDSUZJQycsIHg6IC0xMzQsIHk6IDIwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJTkRJQU4gT0NFQU4nLCB4OiA4MCwgeTogLTI1LCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTT1VUSEVSTiBPQ0VBTicsIHg6IC01LCB5OiAtNjcsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiA2IH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRTVEFUTEFCRUxQT1NJVElPTlMgPSB7XHJcbiAgICBBTDogeyB4OiA1MTUwMDAwLCB5OiAyMDAwMDAwIH0sXHJcbiAgICBBVDogeyB4OiA0NjcwMDAwLCB5OiAyNzQwMDAwIH0sXHJcbiAgICBCRTogeyB4OiAzOTMwMDAwLCB5OiAzMDYwMDAwIH0sXHJcbiAgICBCRzogeyB4OiA1NTY3MDAwLCB5OiAyMzAwMDAwIH0sXHJcbiAgICBIUjogeyB4OiA0NjU3NzE4LCB5OiAyNDAwMjQzIH0sXHJcbiAgICBDWTogeyB4OiA2NDI2MDAwLCB5OiAxNTcwMDAwIH0sXHJcbiAgICBDSDogeyB4OiA0MTcwMDAwLCB5OiAyNjAwMDAwIH0sXHJcbiAgICBDWjogeyB4OiA0NzA3MDAwLCB5OiAyOTUwMDAwIH0sXHJcbiAgICBESzogeyB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwIH0sXHJcbiAgICBFRTogeyB4OiA1MjIwMDAwLCB5OiA0MDUwMDAwIH0sXHJcbiAgICBGSTogeyB4OiA1MTUwMDAwLCB5OiA0NDI0MDAwIH0sXHJcbiAgICBGUjogeyB4OiAzNzY3NzQwLCB5OiAyNjYyODE3IH0sXHJcbiAgICBERTogeyB4OiA0MzQ3Mjg0LCB5OiAzMDkzMjc2IH0sXHJcbiAgICBFTDogeyB4OiA1MzcwMDAwLCB5OiAxNzUwMDAwIH0sXHJcbiAgICBIVTogeyB4OiA1MDIwMDAwLCB5OiAyNjcwMDAwIH0sXHJcbiAgICBJUzogeyB4OiAzMDQwMDAwLCB5OiA0ODMzMDAwIH0sXHJcbiAgICBJRTogeyB4OiAzMTM2MDAwLCB5OiAzMzk0MDAwIH0sXHJcbiAgICBJVDogeyB4OiA0NTAwMDAwLCB5OiAyMTgxOTYzIH0sXHJcbiAgICBMVjogeyB4OiA1MjkwMDAwLCB5OiAzODQwMDAwIH0sXHJcbiAgICBMVDogeyB4OiA1MTkwMDAwLCB5OiAzNjcwMDAwIH0sXHJcbiAgICBMVTogeyB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwIH0sXHJcbiAgICBNVDogeyB4OiA0ODgwMDAwLCB5OiAxNDgwMDAwIH0sXHJcbiAgICBHRTogeyB4OiA2OTEyNjgwLCB5OiAyNjk2NTU0IH0sXHJcbiAgICBVQTogeyB4OiA1ODY1NTA3LCB5OiAzMTMwMTU4IH0sXHJcbiAgICBCQTogeyB4OiA0OTU5MjYyLCB5OiAyMzY4Njg4IH0sXHJcbiAgICBNRDogeyB4OiA1NzM2MDE2LCB5OiAyODM1OTU3IH0sXHJcbiAgICBNRTogeyB4OiA1MDczMDAwLCB5OiAyMjMwMDAwIH0sXHJcbiAgICBNSzogeyB4OiA1MzAwMDAwLCB5OiAyMTMwMDAwIH0sXHJcbiAgICBOTDogeyB4OiA0MDIwMDAwLCB5OiAzMjA4MDAwIH0sXHJcbiAgICBOTzogeyB4OiA0MzAwMDAwLCB5OiA0MTQ3MDAwIH0sXHJcbiAgICBQTDogeyB4OiA0OTY0MDAwLCB5OiAzMjAwMDAwIH0sXHJcbiAgICBQVDogeyB4OiAyNzYwMDAwLCB5OiAxOTkwMDAwIH0sXHJcbiAgICBSTzogeyB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwIH0sXHJcbiAgICBSUzogeyB4OiA1MjAwMDAwLCB5OiAyMzcwMDAwIH0sXHJcbiAgICBTSzogeyB4OiA1MDQwMDAwLCB5OiAyODkwMDAwIH0sXHJcbiAgICBTSTogeyB4OiA0NjYwMDAwLCB5OiAyNTUwMDAwIH0sXHJcbiAgICBFUzogeyB4OiAzMjAwMDAwLCB5OiAyMDAwMDAwIH0sXHJcbiAgICBTRTogeyB4OiA0NjMwMDAwLCB5OiA0MDAwMDAwIH0sXHJcbiAgICBUUjogeyB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwIH0sXHJcbiAgICBVSzogeyB4OiAzNTU4MDAwLCB5OiAzMjUwMDAwIH0sXHJcbiAgICBSVTogeyB4OiA2ODQyMDg2LCB5OiAzMjMwNTE3IH0sXHJcbn1cclxuIiwiaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSAnZDMtem9vbSdcclxuaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGZvcm1hdERlZmF1bHRMb2NhbGUgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCB7IGdlb0lkZW50aXR5LCBnZW9QYXRoLCBnZW9DZW50cm9pZCB9IGZyb20gJ2QzLWdlbydcclxuaW1wb3J0IHsgZ2VvUm9iaW5zb24gfSBmcm9tICdkMy1nZW8tcHJvamVjdGlvbidcclxuaW1wb3J0IHsgZ2V0QkJPWEFzR2VvSlNPTiwgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Rm9udFNpemVGcm9tQ2xhc3MsIGdldFBhcmFtZXRlckJ5TmFtZSwgY29udmVydFJlY3RhbmdsZXNUb1BhdGhzIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IHsgYXBwZW5kQW5ub3RhdGlvbnMgfSBmcm9tICcuL2Fubm90YXRpb25zJ1xyXG5pbXBvcnQgeyBhZGRMYWJlbHNUb01hcCwgdXBkYXRlTGFiZWxzLCB1cGRhdGVWYWx1ZXNMYWJlbHMgfSBmcm9tICcuL2xhYmVscydcclxuaW1wb3J0IHsgZGVmaW5lRGVwcmVjYXRlZEZ1bmN0aW9ucyB9IGZyb20gJy4vZGVwcmVjYXRlZCdcclxuaW1wb3J0IHsgR2VvbWV0cmllcyB9IGZyb20gJy4vZ2VvbWV0cmllcydcclxuaW1wb3J0IHsgYnVpbGRJbnNldHMsIHJlbW92ZUluc2V0cyB9IGZyb20gJy4vaW5zZXRzJ1xyXG5pbXBvcnQgeyBhcHBlbmRTdGFtcCB9IGZyb20gJy4vc3RhbXBzJ1xyXG5pbXBvcnQgeyBidWlsZEdyaWRDYXJ0b2dyYW1CYXNlIH0gZnJvbSAnLi9jYXJ0b2dyYW1zJ1xyXG5pbXBvcnQgeyBhcHBlbmRNaW5pbWFwIH0gZnJvbSAnLi9taW5pbWFwcydcclxuXHJcbi8vIHNldCBkZWZhdWx0IGQzIGxvY2FsZVxyXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcclxuICAgIGRlY2ltYWw6ICcuJyxcclxuICAgIHRob3VzYW5kczogJyAnLFxyXG4gICAgZ3JvdXBpbmc6IFszXSxcclxuICAgIGN1cnJlbmN5OiBbJycsICfigqwnXSxcclxufSlcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFwIHRlbXBsYXRlOiBvbmx5IHRoZSBnZW9tZXRyaWNhbCBwYXJ0LlxyXG4gKiBUbyBiZSB1c2VkIGFzIGEgYmFzZSBtYXAgZm9yIGEgc3RhdGlzdGljYWwgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHdpdGhDZW50ZXJQb2ludHMgU2V0IHRvIHRydWUgKG9yIDEpIHRvIGFkZCByZWdpb25zIGNlbnRlciBwb2ludHMgdG8gdGhlIG1hcCB0ZW1wbGF0ZSwgdG8gYmUgdXNlZCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbHMgbWFwcyBmb3IgZXhhbXBsZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXBUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb25maWcsIHdpdGhDZW50ZXJQb2ludHMsIG1hcFR5cGUpIHtcclxuICAgIC8vYnVpbGQgbWFwIHRlbXBsYXRlIG9iamVjdFxyXG4gICAgY29uc3Qgb3V0ID0ge31cclxuICAgIG91dC5fbWFwVHlwZSA9IG1hcFR5cGVcclxuXHJcbiAgICAvLyBleHBvc2UgaW1wb3J0ZWQgZnVuY3Rpb24gdG8gb3RoZXIgbW9kdWxlc1xyXG4gICAgb3V0LnVwZGF0ZVZhbHVlc0xhYmVscyA9IHVwZGF0ZVZhbHVlc0xhYmVsc1xyXG5cclxuICAgIC8vbWFwXHJcbiAgICBvdXQuc3ZnSWRfID0gJ21hcCdcclxuICAgIG91dC5zdmdfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQud2lkdGhfID0gTWF0aC5taW4oNzk1LCB3aW5kb3cuaW5uZXJXaWR0aClcclxuICAgIG91dC5oZWlnaHRfID0gMFxyXG4gICAgb3V0LmNvbnRhaW5lcklkXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vZ2VvZ3JhcGhpY2FsIGZvY3VzXHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbV8gPSBmYWxzZSAvLyBkcmF3IGdlb21ldHJpZXMgYXMgZ3JpZCBjZWxsc1xyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1TaGFwZV8gPSAnc3F1YXJlJyAvLyBzcXVhcmUgb3IgaGV4YWdvblxyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zXyA9IHsgdG9wOiA4MCwgcmlnaHQ6IDUwLCBib3R0b206IDgwLCBsZWZ0OiAxNTAgfVxyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1DZWxsUGFkZGluZ18gPSA0XHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbVBvc2l0aW9uc18gPSB1bmRlZmluZWQgLy91c2VyIGRlZmluZWQgY2FydG9ncmFtc1xyXG4gICAgb3V0Lm51dHNMZXZlbF8gPSAzIC8vIDAsMSwyLDMsIG9yICdtaXhlZCdcclxuICAgIG91dC5udXRzWWVhcl8gPSAyMDI0XHJcbiAgICBvdXQuZ2VvXyA9ICdFVVInXHJcbiAgICBvdXQucHJval8gPSAnMzAzNSdcclxuICAgIG91dC5wcm9qZWN0aW9uRnVuY3Rpb25fID0gdW5kZWZpbmVkIC8vIGUuZy4gZDMuZ2VvUm9iaW5zb24oKVxyXG4gICAgb3V0LmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbl8gPSB1bmRlZmluZWQgLy8gdXNlciBkZWZpbmVkIGZpbHRlciBmdW5jdGlvblxyXG4gICAgb3V0LnNjYWxlXyA9ICcyME0nIC8vVE9ETyBjaG9vc2UgYXV0b21hdGljYWxseSwgZGVwZW5kaW5nIG9uIHBpeGVsU2l6ZSA/XHJcbiAgICBvdXQuem9vbUV4dGVudF8gPSB1bmRlZmluZWRcclxuICAgIG91dC5tYXhCb3VuZHNfID0geyB4TWluOiAtSW5maW5pdHksIHlNaW46IC1JbmZpbml0eSwgeE1heDogSW5maW5pdHksIHlNYXg6IEluZmluaXR5IH1cclxuICAgIG91dC5nZW9tZXRyaWVzXyA9IHVuZGVmaW5lZCAvLyBbe2lkOlN0cmluZywgZGF0YTpnZW9qc29uLCBjbGFzczpmdW5jdGlvbn1dIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICBvdXQucHJvY2Vzc0NlbnRyb2lkc18gPSB1bmRlZmluZWQgLy8gcnVucyBvdmVyIHN5bWJvbCBjZW50cm9pZHNcclxuICAgIG91dC5wb3NpdGlvbl8gPSB7IHg6IHVuZGVmaW5lZCwgeTogdW5kZWZpbmVkLCB6OiB1bmRlZmluZWQgfSAvLyBtYXAgdmlld1xyXG5cclxuICAgIC8vbWFwIHRpdGxlXHJcbiAgICBvdXQudGl0bGVfID0gJydcclxuICAgIG91dC50aXRsZVBvc2l0aW9uXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vbWFwIHN1YnRpdGxlXHJcbiAgICBvdXQuc3VidGl0bGVfID0gJydcclxuICAgIG91dC5zdWJ0aXRsZVBvc2l0aW9uXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vc2NhbGViYXJcclxuICAgIG91dC5zaG93U2NhbGViYXJfID0gZmFsc2VcclxuICAgIG91dC5zY2FsZWJhclBvc2l0aW9uXyA9IFtdXHJcbiAgICBvdXQuc2NhbGViYXJVbml0c18gPSAnIGttJyAvL2xhYmVsXHJcbiAgICBvdXQuc2NhbGViYXJUZXh0T2Zmc2V0XyA9IFswLCAxMl1cclxuICAgIG91dC5zY2FsZWJhck1heFdpZHRoXyA9IDE1MCAvL3B4XHJcbiAgICBvdXQuc2NhbGViYXJIZWlnaHRfID0gOTAgLy9weFxyXG4gICAgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfID0gMSAvL3B4XHJcbiAgICBvdXQuc2NhbGViYXJTZWdtZW50SGVpZ2h0XyA9IDZcclxuICAgIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfID0gOFxyXG5cclxuICAgIC8vIHN0YW1wIGFubm90YXRpb25cclxuICAgIG91dC5zdGFtcF8gPSB1bmRlZmluZWQgLy9lLmcge3gseSx0ZXh0LHNpemV9XHJcblxyXG4gICAgLy9taW5pbWFwXHJcbiAgICBvdXQubWluaW1hcF8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3Rvb2x0aXBcclxuICAgIG91dC50b29sdGlwXyA9IHtcclxuICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxyXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMjAwLFxyXG4gICAgICAgIHhPZmZzZXQ6IDAsXHJcbiAgICAgICAgeU9mZnNldDogMCxcclxuICAgICAgICB0ZXh0RnVuY3Rpb246IG51bGwsXHJcbiAgICAgICAgc2hvd0ZsYWdzOiBmYWxzZSxcclxuICAgICAgICBvbWl0TGlzdDogZmFsc2UsIC8vIGlmIHNwZWNpZmllZCwgdG9vbHRpcCB3aWxsIG5vdCBzaG93IHRoZSBsaXN0IG9mIHJlZ2lvbnNcclxuICAgIH0gLy8gIFNlZSB0b29sdGlwLmpzIGZvciBtb3JlIGRldGFpbHNcclxuXHJcbiAgICAvLyByZWdpb24gbW91c2VvdmVyIGNvbG9yXHJcbiAgICBvdXQuaG92ZXJDb2xvcl8gPSAncmVkJ1xyXG5cclxuICAgIC8vY29hc3RhbCBtYXJnaW5cclxuICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbl8gPSBmYWxzZVxyXG4gICAgb3V0LmNvYXN0YWxNYXJnaW5TdGREZXZfID0gM1xyXG5cclxuICAgIC8vZ3JhdGljdWxlXHJcbiAgICBvdXQuZHJhd0dyYXRpY3VsZV8gPSBmYWxzZVxyXG5cclxuICAgIC8vYmFja2dyb3VuZCBtYXAgdG9nZ2xlIChlLmcuIGZvciBkb3JsaW5nKVxyXG4gICAgb3V0LmJhY2tncm91bmRNYXBfID0gdHJ1ZVxyXG5cclxuICAgIC8vbGFiZWxsaW5nXHJcbiAgICAvLyBzZWUgZG9jc1xccmVmZXJlbmNlLm1kI2xhYmVsbGluZ1xyXG4gICAgb3V0LmxhYmVsc18gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL2Fubm90YXRpb25zXHJcbiAgICBvdXQuYW5ub3RhdGlvbnNfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuYW5ub3RhdGlvbnNBZGRlZCA9IGZhbHNlIC8vc2ltcGxlIGZsYWcgdG8ga25vdyB3aGVuIGFubm90YXRpb25zIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkXHJcblxyXG4gICAgLy9oYXRjaGluZ1xyXG4gICAgb3V0LnBhdHRlcm5GaWxsXyA9IHVuZGVmaW5lZCAvLyBlLmcuIHtwYXR0ZXJuOidoYXRjaGluZycscmVnaW9uSWRzOlsnREUnLCdGUiddfVxyXG5cclxuICAgIC8vZGF0YXNldCBzb3VyY2UgbGlua1xyXG4gICAgb3V0LnNob3dTb3VyY2VMaW5rXyA9IHRydWVcclxuXHJcbiAgICAvL2RlZmF1bHQgY29weXJpZ2h0IGFuZCBkaXNjbGFpbWVyIHRleHRcclxuICAgIG91dC5mb290bm90ZV8gPSAnQWRtaW5pc3RyYXRpdmUgYm91bmRhcmllczogXFx1MDBBOUV1cm9HZW9ncmFwaGljcyBcXHUwMEE5VU4tRkFPIFxcdTAwQTlJTlNUQVQgXFx1MDBBOVR1cmtzdGF0JyAvL1wiKEMpRXVyb0dlb2dyYXBoaWNzIChDKVVOLUZBTyAoQylUdXJrc3RhdFwiO1xyXG4gICAgb3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfID1cclxuICAgICAgICAnVGhlIGRlc2lnbmF0aW9ucyBlbXBsb3llZCBhbmQgdGhlIHByZXNlbnRhdGlvbiBvZiBtYXRlcmlhbCBvbiB0aGlzIG1hcCBkbyBub3QgaW1wbHkgdGhlIGV4cHJlc3Npb24gb2YgYW55IG9waW5pb24gd2hhdHNvZXZlciBvbiB0aGUgcGFydCBvZiB0aGUgRXVyb3BlYW4gVW5pb24gY29uY2VybmluZyB0aGUgbGVnYWwgc3RhdHVzIG9mIGFueSBjb3VudHJ5LCB0ZXJyaXRvcnksIGNpdHkgb3IgYXJlYSBvciBvZiBpdHMgYXV0aG9yaXRpZXMsIG9yIGNvbmNlcm5pbmcgdGhlIGRlbGltaXRhdGlvbiBvZiBpdHMgZnJvbnRpZXJzIG9yIGJvdW5kYXJpZXMuIEtvc292byo6IFRoaXMgZGVzaWduYXRpb24gaXMgd2l0aG91dCBwcmVqdWRpY2UgdG8gcG9zaXRpb25zIG9uIHN0YXR1cywgYW5kIGlzIGluIGxpbmUgd2l0aCBVTlNDUiAxMjQ0LzE5OTkgYW5kIHRoZSBJQ0ogT3BpbmlvbiBvbiB0aGUgS29zb3ZvIGRlY2xhcmF0aW9uIG9mIGluZGVwZW5kZW5jZS4nXHJcblxyXG4gICAgb3V0Lm51dHMyanNvbkJhc2VVUkxfID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmluY2x1ZGVzKCdlYy5ldXJvcGEuZXUnKVxyXG4gICAgICAgID8gJ2h0dHBzOi8vZWMuZXVyb3BhLmV1L2Fzc2V0cy9lc3RhdC9FL0U0L2dpc2NvL3B1Yi9udXRzMmpzb24vdjInXHJcbiAgICAgICAgOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V1cm9zdGF0L051dHMyanNvbi9tYXN0ZXIvcHViL3YyJ1xyXG5cclxuICAgIC8vc3R5bGUgZm9yIG5vIGRhdGEgcmVnaW9uc1xyXG4gICAgb3V0Lm5vRGF0YUZpbGxTdHlsZV8gPSAnI2JjYmNiYydcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2V0cy5cclxuICAgICAqIFRoZSBtYXAgdGVtcGxhdGUgaGFzIGEgcmVjdXJzaXZlIHN0cnVjdHVyZS5cclxuICAgICAqL1xyXG5cclxuICAgIC8vaW5zZXRzIHRvIHNob3csIGFzIGEgbGlzdCBvZiBtYXAgdGVtcGxhdGUgY29uZmlncy4gRXguOiBbe2dlbzpcIk1UXCJ9LHtnZW86XCJMSVwifSx7Z2VvOlwiUFQyMFwifV1cclxuICAgIG91dC5pbnNldHNfID0gW11cclxuICAgIC8vaW5zZXQgdGVtcGxhdGVzIC0gZWFjaCBpbnNldCBpcyBhIG1hcC10ZW1wbGF0ZSBpbnN0YW5jZS5cclxuICAgIG91dC5pbnNldFRlbXBsYXRlc18gPSB7fVxyXG5cclxuICAgIG91dC5pbnNldEJveFBvc2l0aW9uXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0Lmluc2V0Qm94UGFkZGluZ18gPSA1XHJcbiAgICBvdXQuaW5zZXRCb3hXaWR0aF8gPSAyMTBcclxuICAgIC8vb3V0Lmluc2V0Wm9vbUV4dGVudF8gPSBbMSwgM107XHJcbiAgICBvdXQuaW5zZXRab29tRXh0ZW50XyA9IG51bGwgLy96b29tIGRpc2FibGVkIGFzIGRlZmF1bHRcclxuICAgIG91dC5pbnNldFNjYWxlXyA9ICcwM00nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgZm9yIChjb25zdCBhdHQgaW4gb3V0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdhcm4gZXhpc3RpbmcgdXNlcnMgb2YgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGJhbmlzaGVkIHRvIHRoZSBzaGFkb3cgcmVhbG0uXHJcbiAgICBkZWZpbmVEZXByZWNhdGVkRnVuY3Rpb25zKG91dClcclxuXHJcbiAgICAvLyBjb252ZXJ0IGdlbyB0byB1cHBlcmNhc2VcclxuICAgIG91dC5nZW8gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5nZW9fXHJcbiAgICAgICAgb3V0Lmdlb18gPSB2LnRvVXBwZXJDYXNlKClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWFsIG9uZXMgd2hpY2ggYWZmZWN0IGFsc28gdGhlIGluc2V0c1xyXG4gICAgO1sndG9vbHRpcF8nLCAnbnV0czJqc29uQmFzZVVSTF8nLCAncHJvY2Vzc0NlbnRyb2lkc18nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xyXG4gICAgICAgICAgICAgICAgLy9vdmVycmlkZSBkZWZhdWx0IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0W2F0dF1bcF0gPSB2W3BdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9yZWN1cnNpdmUgY2FsbCB0byBpbnNldCBjb21wb25lbnRzXHJcbiAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKFxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5pbnNldFRlbXBsYXRlc18sXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnN2Z0lkXyxcclxuICAgICAgICAgICAgICAgICAgICAoaW5zZXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuTmFtZSA9IGF0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2V0W2ZuTmFtZV0odmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB2XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy90aXRsZSBnZXR0ZXIgYW5kIHNldHRlclxyXG4gICAgb3V0LnRpdGxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQudGl0bGVfXHJcbiAgICAgICAgb3V0LnRpdGxlXyA9IHZcclxuICAgICAgICBpZiAob3V0LnN2ZygpKVxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyN0aXRsZScgKyBvdXQuZ2VvKCkpXHJcbiAgICAgICAgICAgICAgICAudGV4dCh2KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL3N1YnRpdGxlIGdldHRlciBhbmQgc2V0dGVyXHJcbiAgICBvdXQuc3VidGl0bGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5zdWJ0aXRsZV9cclxuICAgICAgICBvdXQuc3VidGl0bGVfID0gdlxyXG4gICAgICAgIGlmIChvdXQuc3ZnKCkpXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnI3N1YnRpdGxlJyArIG91dC5nZW8oKSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KHYpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vaW5zZXRzIGdldHRlci9zZXR0ZXJcclxuICAgIG91dC5pbnNldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0Lmluc2V0c19cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIGFyZ3VtZW50c1swXSA9PT0gJ2RlZmF1bHQnKSBvdXQuaW5zZXRzXyA9ICdkZWZhdWx0J1xyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBhcmd1bWVudHNbMF0gPT09IGZhbHNlKSBvdXQuaW5zZXRzXyA9IGZhbHNlXHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkgb3V0Lmluc2V0c18gPSBhcmd1bWVudHNbMF1cclxuICAgICAgICBlbHNlIG91dC5pbnNldHNfID0gYXJndW1lbnRzXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGR5bmFtaWMgZHJhdyBncmF0aWN1bGVcclxuICAgIG91dC5kcmF3R3JhdGljdWxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuZHJhd0dyYXRpY3VsZV9cclxuICAgICAgICBvdXQuZHJhd0dyYXRpY3VsZV8gPSB2XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGdyYXRpY3VsZVxyXG4gICAgICAgIGxldCBncmF0aWN1bGUgPSBvdXQuc3ZnXyA/IG91dC5zdmcoKS5zZWxlY3QoJyNlbS1ncmF0aWN1bGUnKSA6IG51bGxcclxuICAgICAgICBsZXQgemcgPSBvdXQuc3ZnXyA/IG91dC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pIDogbnVsbFxyXG5cclxuICAgICAgICAvLyBpZiBleGlzdGluZyBhbmQgYXJndW1lbnQgaXMgZmFsc2VcclxuICAgICAgICBpZiAoZ3JhdGljdWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChncmF0aWN1bGUuX2dyb3Vwc1swXVswXSAmJiB2ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIGdyYXRpY3VsZS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIG1hcCBhbHJlYWR5IGNyZWF0ZWQgYW5kIGFyZ3VtZW50IGlzIHRydWVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5ncmF0aWN1bGUgJiYgb3V0Ll9wYXRoRnVuY3Rpb24gJiYgemcgJiYgdiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBleGlzdGluZyBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIGdyYXRpY3VsZS5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIG5ldyBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIHpnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMuZ3JhdGljdWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZ3JhdGljdWxlJylcclxuXHJcbiAgICAgICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tZ3JhdGljdWxlJylcclxuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZ3JhdGljdWxlIGJlaGluZCBsYW5kIG1hc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb18gPT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzNdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzFdKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vY29hc3RhbCBtYXJnaW4gb3ZlcnJpZGVcclxuICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmRyYXdDb2FzdGFsTWFyZ2luX1xyXG4gICAgICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbl8gPSB2XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGV4aXN0aW5nXHJcbiAgICAgICAgaWYgKG91dC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXJnaW4gPSBzZWxlY3RBbGwoJyNlbS1jb2FzdC1tYXJnaW4nKVxyXG4gICAgICAgICAgICBsZXQgZmlsdGVyID0gc2VsZWN0KCcjZW0tY29hc3RhbC1ibHVyJylcclxuICAgICAgICAgICAgbGV0IHpnID0gc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXykgfHwgbnVsbFxyXG4gICAgICAgICAgICBpZiAobWFyZ2luLl9ncm91cHNbMF1bMF0gJiYgdiA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ucmVtb3ZlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2ID09IHRydWUgJiYgb3V0Ll9wYXRoRnVuY3Rpb24gJiYgemcpIHtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGV4aXN0aW5nIGdyYXRpY3VsZVxyXG4gICAgICAgICAgICAgICAgbWFyZ2luLnJlbW92ZSgpXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIucmVtb3ZlKClcclxuICAgICAgICAgICAgICAgIC8vYWRkIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgb3V0LnN2Z19cclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdmaWx0ZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdGFsLWJsdXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICctMjAwJScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzQwMCUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnNDAwJScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZmVHYXVzc2lhbkJsdXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpbicsICdTb3VyY2VHcmFwaGljJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgb3V0LmNvYXN0YWxNYXJnaW5TdGREZXZfKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyBmb3IgbWFpbiBtYXAgLSBnZW9tZXRyaWVzIGFyZSBzdGlsbCBpbiBtZW1vcnkgc28gbm8gcmVidWlsZCBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdOZXdDb2FzdGFsTWFyZ2luID0gKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHpvb20gZ3JvdXAgbWlnaHQgbm90IGJlIGluc2lkZSBtYWluIG1hcCAob3V0LnN2Z18pXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgbmV3IGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2cgPSB6b29tR3JvdXAuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb3VudHJpZXMgYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLl9nZW9tLmNudGJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1jbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShtYXAuX2dlb20uY250Ym4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm4ucHJvcGVydGllcy5jbyA9PT0gJ1QnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIG1hcC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vbnV0cyBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuX2dlb20ubnV0c2JuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1udXRzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEobWFwLl9nZW9tLm51dHNibilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLmNvID09PSAnVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgbWFwLl9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLy93b3JsZCBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuX2dlb20ud29ybGRibilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4tbnV0cycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKG1hcC5fZ2VvbS53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuQ09BU19GTEFHID09PSAnVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgbWFwLl9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGZvciBpbnNldHMgLSByZXF1aXJlcyBnZW9tZXRyaWVzIHNvIHdlIGhhdmUgdG8gcmVidWlsZCBiYXNlIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXyAmJiBvdXQuZHJhd0NvYXN0YWxNYXJnaW5fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBkcmF3TmV3Q29hc3RhbE1hcmdpbilcclxuICAgICAgICAgICAgICAgICAgICBkcmF3TmV3Q29hc3RhbE1hcmdpbihvdXQpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBtYXJnaW4gdG8gYmFjayAoaW4gZnJvbnQgb2Ygc2VhKVxyXG4gICAgICAgICAgICAgICAgc2VsZWN0QWxsKCcjZW0tY29hc3QtbWFyZ2luJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb18gPT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXNbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlc1sxXSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vYW5ub3RhdGlvbnMgb3ZlcnJpZGUgKHVwZGF0ZSBhZnRlciBmaXJzdCBjYWxsKVxyXG4gICAgb3V0LmFubm90YXRpb25zID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvL2dldFxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5hbm5vdGF0aW9uc19cclxuICAgICAgICAvL3NldFxyXG4gICAgICAgIG91dC5hbm5vdGF0aW9uc18gPSB2XHJcbiAgICAgICAgLy91cGRhdGVcclxuICAgICAgICBhcHBlbmRBbm5vdGF0aW9ucyhvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhbXBzIG92ZXJyaWRlICh1cGRhdGUgYWZ0ZXIgZmlyc3QgY2FsbClcclxuICAgIG91dC5zdGFtcCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgLy9nZXRcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuc3RhbXBfXHJcbiAgICAgICAgLy9zZXRcclxuICAgICAgICBvdXQuc3RhbXBfID0gdlxyXG4gICAgICAgIC8vdXBkYXRlXHJcbiAgICAgICAgYXBwZW5kU3RhbXAob3V0LnN0YW1wXywgb3V0KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL21pbmltYXAgb3ZlcnJpZGUgKHVwZGF0ZSBhZnRlciBmaXJzdCBjYWxsKVxyXG4gICAgb3V0Lm1pbmltYXAgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIC8vZ2V0XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0Lm1pbmltYXBfXHJcbiAgICAgICAgLy9zZXRcclxuICAgICAgICBvdXQubWluaW1hcF8gPSB2XHJcbiAgICAgICAgLy91cGRhdGVcclxuICAgICAgICBhcHBlbmRNaW5pbWFwKG91dClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9sYWJlbHMgb3ZlcnJpZGUgKHVwZGF0ZSBhZnRlciBmaXJzdCBjYWxsKVxyXG4gICAgb3V0LmxhYmVscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgLy9nZXRcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQubGFiZWxzX1xyXG4gICAgICAgIC8vc2V0XHJcbiAgICAgICAgb3V0LmxhYmVsc18gPSB2XHJcbiAgICAgICAgLy91cGRhdGVcclxuICAgICAgICB1cGRhdGVMYWJlbHMob3V0KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbml0aWF0ZSBHZW9tZXRyaWVzIGNsYXNzXHJcbiAgICBvdXQuR2VvbWV0cmllcyA9IEdlb21ldHJpZXMob3V0LCB3aXRoQ2VudGVyUG9pbnRzKVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdHMgZ2VvZ3JhcGhpYyBkYXRhIGFuZCB0aGVuIGJ1aWxkcyB0aGUgbWFwIHRlbXBsYXRlXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGVHZW9NYXBUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIEVyYXNlIHByZXZpb3VzIGRhdGFcclxuICAgICAgICBvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YSA9IG51bGxcclxuICAgICAgICBvdXQuR2VvbWV0cmllcy5hbGxOVVRTR2VvRGF0YSA9IG51bGxcclxuICAgICAgICBvdXQuR2VvbWV0cmllcy5jZW50cm9pZHNEYXRhID0gbnVsbFxyXG5cclxuICAgICAgICBpZiAob3V0Lmdlb21ldHJpZXNfKSB7XHJcbiAgICAgICAgICAgIG91dC5HZW9tZXRyaWVzLnNldFVzZXJHZW9tZXRyaWVzKG91dC5nZW9tZXRyaWVzXylcclxuICAgICAgICAgICAgLy8gdXNlIGN1c3RvbSB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgICAgICBvdXQuYnVpbGRNYXBUZW1wbGF0ZSgpXHJcblxyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdXNlIGRlZmF1bHRcclxuICAgICAgICAgICAgb3V0Lkdlb21ldHJpZXMuZ2V0RGVmYXVsdEdlb0RhdGEob3V0Lmdlb18sIG91dC5maWx0ZXJHZW9tZXRyaWVzRnVuY3Rpb25fLCBvdXQubnV0c0xldmVsXykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvdXQuYnVpbGRNYXBUZW1wbGF0ZSgpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFjayBpZiBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBleGVjdXRlRm9yQWxsSW5zZXRzIGZvciByZWN1cnNpdmUgaW5zZXQgdXBkYXRlc1xyXG4gICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgKGluc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGluc2V0LnVwZGF0ZUdlb01hcFRlbXBsYXRlKGNhbGxiYWNrKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIGEgbWFwIG9iamVjdCwgaW5jbHVkaW5nIGNvbnRhaW5lciwgZnJhbWUsIG1hcCBzdmcsIGluc2V0cyBhbmQgZDMgem9vbVxyXG4gICAgICovXHJcbiAgICBvdXQuYnVpbGRNYXBUZW1wbGF0ZUJhc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9nZXQgc3ZnIGVsZW1lbnQuIENyZWF0ZSBpdCBpZiBpdCBkb2VzIG5vdCBleGlzdHNcclxuICAgICAgICBsZXQgc3ZnID0gc2VsZWN0KCcjJyArIG91dC5zdmdJZCgpKVxyXG4gICAgICAgIGlmIChzdmcuc2l6ZSgpID09IDApIHtcclxuICAgICAgICAgICAgc3ZnID0gc2VsZWN0KCdib2R5JykuYXBwZW5kKCdzdmcnKS5hdHRyKCdpZCcsIG91dC5zdmdJZCgpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdmcuYXR0cignY2xhc3MnLCAnZW0tbWFwJylcclxuICAgICAgICBvdXQuc3ZnXyA9IHN2Z1xyXG5cclxuICAgICAgICAvL3NldCBjb250YWluZXIgZm9yIGNhc2VzIHdoZXJlIGNvbnRhaW5lciBjb250YWlucyB2YXJpb3VzIG1hcHNcclxuICAgICAgICBpZiAoIW91dC5jb250YWluZXJJZF8pIG91dC5jb250YWluZXJJZF8gPSBvdXQuc3ZnSWRfXHJcbiAgICAgICAgLy90b29sdGlwIG5lZWRzIHRvIGtub3cgY29udGFpbmVyIHRvIHByZXZlbnQgb3ZlcmZsb3dcclxuICAgICAgICBpZiAoIW91dC50b29sdGlwXy5jb250YWluZXJJZCkge1xyXG4gICAgICAgICAgICBvdXQudG9vbHRpcF8uY29udGFpbmVySWQgPSBvdXQuY29udGFpbmVySWRfXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NsZWFyIFNWRyAodG8gYXZvaWQgYnVpbGRpbmcgbXVsdGlwbGUgc3ZncyBvbiB0b3Agb2YgZWFjaCBvdGhlciBkdXJpbmcgbXVsdGlwbGUgYnVpbGQoKSBjYWxscylcclxuICAgICAgICBzZWxlY3RBbGwoJyMnICsgb3V0LnN2Z0lkKCkgKyAnID4gKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vc2V0IFNWRyBkaW1lbnNpb25zXHJcbiAgICAgICAgaWYgKG91dC5nZW9fLnRvVXBwZXJDYXNlKCkgPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAvL2lmIG5vIGhlaWdodCB3YXMgc3BlY2lmaWVkLCB1c2UgNDUlIG9mIHRoZSB3aWR0aC5cclxuICAgICAgICAgICAgaWYgKCFvdXQuaGVpZ2h0KCkpIG91dC5oZWlnaHQoMC41NSAqIG91dC53aWR0aCgpKVxyXG4gICAgICAgICAgICBzdmcuYXR0cignd2lkdGgnLCBvdXQud2lkdGgoKSkuYXR0cignaGVpZ2h0Jywgb3V0LmhlaWdodCgpKVxyXG5cclxuICAgICAgICAgICAgLy9XT1JMRCBnZW8gb25seSBhY2NlcHRzIHByb2ogNTQwMzAgKHJvYmluc29uKSBhdCB0aGUgbW9tZW50XHJcbiAgICAgICAgICAgIG91dC5wcm9qXyA9IDU0MDMwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vaWYgbm8gaGVpZ2h0IHdhcyBzcGVjaWZpZWQsIHVzZSA4NSUgb2YgdGhlIHdpZHRoLlxyXG4gICAgICAgIGlmICghb3V0LmhlaWdodCgpKSBvdXQuaGVpZ2h0KDAuODUgKiBvdXQud2lkdGgoKSlcclxuICAgICAgICBzdmcuYXR0cignd2lkdGgnLCBvdXQud2lkdGgoKSkuYXR0cignaGVpZ2h0Jywgb3V0LmhlaWdodCgpKVxyXG5cclxuICAgICAgICAvLyBlYWNoIG1hcCB0ZW1wbGF0ZSBuZWVkcyBhIGNsaXBQYXRoIHRvIGF2b2lkIG92ZXJmbG93LiBTZWUgR0lTQ08tMjcwN1xyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZGVmcycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NsaXBQYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgb3V0LnN2Z0lkXyArICctY2xpcC1wYXRoJylcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgY29udmVydFJlY3RhbmdsZXNUb1BhdGhzKDAsIDAsIG91dC53aWR0aF8sIG91dC5oZWlnaHRfKSlcclxuXHJcbiAgICAgICAgaWYgKG91dC5kcmF3Q29hc3RhbE1hcmdpbl8pIHtcclxuICAgICAgICAgICAgLy9kZWZpbmUgZmlsdGVyIGZvciBjb2FzdGFsIG1hcmdpblxyXG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdmaWx0ZXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0YWwtYmx1cicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsICctMjAwJScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsICctMjAwJScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAnNDAwJScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgJzQwMCUnKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZmVHYXVzc2lhbkJsdXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0ZERldmlhdGlvbicsIG91dC5jb2FzdGFsTWFyZ2luU3RkRGV2XylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIGRyYXdpbmcgZ3JvdXAsIGFzIGZpcnN0IGNoaWxkXHJcbiAgICAgICAgY29uc3QgZGcgPSBzdmdcclxuICAgICAgICAgICAgLmluc2VydCgnZycsICc6Zmlyc3QtY2hpbGQnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tZHJhd2luZy0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWRyYXdpbmctZ3JvdXAnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xpcC1wYXRoJywgJ3VybCgjJyArIG91dC5zdmdJZF8gKyAnLWNsaXAtcGF0aCcgKyAnKScpXHJcblxyXG4gICAgICAgIC8vY3JlYXRlIG1haW4gem9vbSBncm91cFxyXG4gICAgICAgIGNvbnN0IHpnID0gZGdcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tem9vbS1ncm91cCcpIC8vb3V0LmdlbyBjaGFuZ2VkIHRvIG91dC5zdmdJZCBpbiBvcmRlciB0byBiZSB1bmlxdWVcclxuXHJcbiAgICAgICAgLy8gYnVpbGQgaW5zZXRzXHJcbiAgICAgICAgcmVtb3ZlSW5zZXRzKG91dCkgLy9yZW1vdmUgZXhpc3RpbmdcclxuICAgICAgICBidWlsZEluc2V0cyhvdXQsIHdpdGhDZW50ZXJQb2ludHMpIC8vYnVpbGQgbmV3XHJcblxyXG4gICAgICAgIC8vZHJhdyBmcmFtZVxyXG4gICAgICAgIGRnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1mcmFtZS0nICsgb3V0Lmdlb18pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1mcmFtZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQud2lkdGhfKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LmhlaWdodF8pXHJcblxyXG4gICAgICAgIGlmIChvdXQuc3RhbXBfKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZFN0YW1wKG91dC5zdGFtcF8sIG91dClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWQgYW4gZW1wdHkgbWFwIHRlbXBsYXRlLCBiYXNlZCBvbiB0aGUgZ2VvbWV0cmllcyBvbmx5LlxyXG4gICAgICovXHJcbiAgICBvdXQuYnVpbGRNYXBUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3ByZXBhcmUgZHJhd2luZyBncm91cFxyXG4gICAgICAgIGNvbnN0IHpvb21Hcm91cCA9IG91dC5zdmcoKS5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIC8vcmVtb3ZlIGFsbCBjaGlsZHJlblxyXG4gICAgICAgIHpvb21Hcm91cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvLyBzZXBhcmF0ZSBsb2dpYyBmb3IgY2FydG9ncmFtc1xyXG4gICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBidWlsZEdyaWRDYXJ0b2dyYW1CYXNlKG91dClcclxuICAgICAgICAgICAgb3V0LmZvb3Rub3RlXyA9IGZhbHNlIC8vZG9udCBuZWVkIGNvcHlyaWdodFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgZ2VvZ3JhcGhpYyBsb2dpY1xyXG5cclxuICAgICAgICAgICAgLy8gcG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKCFvdXQucG9zaXRpb25fLnggfHwgIW91dC5wb3NpdGlvbl8ueSkge1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lRGVmYXVsdFBvc2l0aW9uKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQucG9zaXRpb25fLnogPSBvdXQucG9zaXRpb25fLnogfHwgZ2V0RGVmYXVsdFooKVxyXG5cclxuICAgICAgICAgICAgLy8gZDMgcHJvamVjdGlvbi9wYXRoIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICBkZWZpbmVQcm9qZWN0aW9uKClcclxuICAgICAgICAgICAgZGVmaW5lUGF0aEZ1bmN0aW9uKClcclxuXHJcbiAgICAgICAgICAgIC8vIGQzIHpvb21cclxuICAgICAgICAgICAgaWYgKG91dC56b29tRXh0ZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGRlZmluZU1hcFpvb20oKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3V0LmJhY2tncm91bmRNYXBfKSB7XHJcbiAgICAgICAgICAgICAgICBkcmF3QmFja2dyb3VuZE1hcChvdXQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBncm91cCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbHMsIHdpdGggY2VudHJvaWRzXHJcbiAgICAgICAgaWYgKHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgICAgICAgICAgYWRkQ2VudHJvaWRzVG9NYXAob3V0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIGdlb2dyYXBoaWNhbCBsYWJlbHMgdG8gbWFwXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfKSB7XHJcbiAgICAgICAgICAgIGFkZExhYmVsc1RvTWFwKG91dCwgem9vbUdyb3VwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hbm5vdGF0aW9uc1xyXG4gICAgICAgIGlmIChvdXQuYW5ub3RhdGlvbnNfKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZEFubm90YXRpb25zKG91dClcclxuICAgICAgICAgICAgb3V0LmFubm90YXRpb25zQWRkZWQgPSB0cnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgaWYgKG91dC50aXRsZSgpKSB7XHJcbiAgICAgICAgICAgIC8vZGVmaW5lIGRlZmF1bHQgcG9zaXRpb25cclxuICAgICAgICAgICAgbGV0IGNzc0NsYXNzID0gb3V0LmlzSW5zZXQgPyAnZW0taW5zZXQtdGl0bGUnIDogJ2VtLXRpdGxlJ1xyXG4gICAgICAgICAgICBpZiAoIW91dC50aXRsZVBvc2l0aW9uKCkpIG91dC50aXRsZVBvc2l0aW9uKFsxMCwgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoY3NzQ2xhc3MpICsgKG91dC5pc0luc2V0ID8gMCA6IDEwKV0pXHJcbiAgICAgICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3RpdGxlJyArIG91dC5nZW9fKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgY3NzQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC50aXRsZVBvc2l0aW9uKClbMF0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC50aXRsZVBvc2l0aW9uKClbMV0pXHJcbiAgICAgICAgICAgICAgICAuaHRtbChvdXQudGl0bGUoKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc3VidGl0bGVcclxuICAgICAgICBpZiAob3V0LnN1YnRpdGxlKCkpIHtcclxuICAgICAgICAgICAgbGV0IGNzc1N1YnRpdGxlQ2xhc3MgPSBvdXQuaXNJbnNldCA/ICdlbS1pbnNldC1zdWJ0aXRsZScgOiAnZW0tc3VidGl0bGUnXHJcbiAgICAgICAgICAgIGxldCBjc3NUaXRsZUNsYXNzID0gb3V0LmlzSW5zZXQgPyAnZW0taW5zZXQtdGl0bGUnIDogJ2VtLXRpdGxlJ1xyXG4gICAgICAgICAgICAvL2RlZmluZSBkZWZhdWx0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGlmICghb3V0LnN1YnRpdGxlUG9zaXRpb24oKSkgb3V0LnN1YnRpdGxlUG9zaXRpb24oWzEwLCBnZXRGb250U2l6ZUZyb21DbGFzcyhjc3NUaXRsZUNsYXNzKSArIGdldEZvbnRTaXplRnJvbUNsYXNzKGNzc1N1YnRpdGxlQ2xhc3MpICsgMTVdKVxyXG4gICAgICAgICAgICAvL2RyYXcgc3VidGl0bGVcclxuICAgICAgICAgICAgb3V0LnN2ZygpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdzdWJ0aXRsZScgKyBvdXQuZ2VvXylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGNzc1N1YnRpdGxlQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5zdWJ0aXRsZVBvc2l0aW9uKClbMF0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5zdWJ0aXRsZVBvc2l0aW9uKClbMV0pXHJcbiAgICAgICAgICAgICAgICAuaHRtbChvdXQuc3VidGl0bGUoKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYm90dG9tIHRleHRcclxuICAgICAgICBpZiAob3V0LmZvb3Rub3RlXykge1xyXG4gICAgICAgICAgICBhZGRGb290bm90ZSgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NvdXJjZSBkYXRhc2V0IFVSTFxyXG4gICAgICAgIGlmIChvdXQuc2hvd1NvdXJjZUxpbmtfKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0XHJcbiAgICAgICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ID0gb3V0LnN0YXQoJ3NpemUnKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhdCA9IG91dC5zdGF0KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXQuZXVyb3N0YXREYXRhc2V0Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZGF0YXNldCBsaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBzdGF0LmV1cm9zdGF0RGF0YXNldENvZGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gYGh0dHBzOi8vZWMuZXVyb3BhLmV1L2V1cm9zdGF0L2RhdGFicm93c2VyL3ZpZXcvJHtjb2RlfS9kZWZhdWx0L3RhYmxlP2xhbmc9ZW5gXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBvdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2EnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc291cmNlLWRhdGFzZXQtbGluaycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdocmVmJywgdXJsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGFyZ2V0JywgJ19ibGFuaycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc291cmNlLWRhdGFzZXQtbGluay10ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQud2lkdGhfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5oZWlnaHRfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dCgnRVVST1NUQVQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV0ZXh0IFwiU291cmNlOlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmtXID0gbGluay5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKClcclxuICAgICAgICAgICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zb3VyY2UtcHJldGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LndpZHRoXyAtIGxpbmtXIC0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuaGVpZ2h0XylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoJ1NvdXJjZTonKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2NhbGViYXJcclxuICAgICAgICBpZiAob3V0LnNob3dTY2FsZWJhcl8pIHtcclxuICAgICAgICAgICAgaWYgKG91dC5zY2FsZWJhclBvc2l0aW9uXy5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICAgICAgICAgIG91dC5zY2FsZWJhclBvc2l0aW9uX1swXSA9IDE1XHJcbiAgICAgICAgICAgICAgICBvdXQuc2NhbGViYXJQb3NpdGlvbl9bMV0gPSBvdXQuaGVpZ2h0XyAtIDUwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkU2NhbGViYXJUb01hcCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL21pbmltYXBcclxuICAgICAgICBpZiAob3V0Lm1pbmltYXBfKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZE1pbmltYXAob3V0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyYXdCYWNrZ3JvdW5kTWFwID0gZnVuY3Rpb24gKG91dCkge1xyXG4gICAgICAgIC8vZHJhdyBiYWNrZ3JvdW5kIG1hcFxyXG4gICAgICAgIGNvbnN0IHpvb21Hcm91cCA9IG91dC5zdmcoKS5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIC8vZHJhdyBzZWFcclxuICAgICAgICB6b29tR3JvdXBcclxuICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdzZWEnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2VhJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAtNSAqIG91dC53aWR0aF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgLTUgKiBvdXQuaGVpZ2h0XylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTEgKiBvdXQud2lkdGhfKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTEgKiBvdXQuaGVpZ2h0XylcclxuXHJcbiAgICAgICAgLy9zcGhlcmUgZm9yIHdvcmxkIG1hcFxyXG4gICAgICAgIGlmIChvdXQuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIHpvb21Hcm91cC5hcHBlbmQoJ3BhdGgnKS5kYXR1bSh7IHR5cGU6ICdTcGhlcmUnIH0pLmF0dHIoJ2lkJywgJ3NwaGVyZScpLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbikuYXR0cignY2xhc3MnLCAnZW0tZ3JhdGljdWxlJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgaWYgKG91dC5kcmF3Q29hc3RhbE1hcmdpbl8pIHtcclxuICAgICAgICAgICAgYWRkQ29hc3RhbE1hcmdpblRvTWFwKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRyYXcgcG9seWdvbnMgYW5kIGJvcmRlcnNcclxuICAgICAgICBpZiAob3V0Lmdlb21ldHJpZXNfKSB7XHJcbiAgICAgICAgICAgIG91dC5HZW9tZXRyaWVzLmFkZFVzZXJHZW9tZXRyaWVzVG9NYXAob3V0Lmdlb21ldHJpZXNfLCB6b29tR3JvdXAsIG91dC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dC5HZW9tZXRyaWVzLmFkZERlZmF1bHRHZW9tZXRyaWVzVG9NYXAoXHJcbiAgICAgICAgICAgICAgICB6b29tR3JvdXAsXHJcbiAgICAgICAgICAgICAgICBvdXQuZHJhd0dyYXRpY3VsZV8sXHJcbiAgICAgICAgICAgICAgICBvdXQuX3BhdGhGdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIG91dC5udXRzTGV2ZWxfLFxyXG4gICAgICAgICAgICAgICAgb3V0Lm51dHNZZWFyXyxcclxuICAgICAgICAgICAgICAgIG91dC5nZW9fLFxyXG4gICAgICAgICAgICAgICAgb3V0LnByb2pfLFxyXG4gICAgICAgICAgICAgICAgb3V0LnNjYWxlX1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZURlZmF1bHRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0UG9zaXRpb24gPSBfZGVmYXVsdFBvc2l0aW9uW291dC5nZW9fICsgJ18nICsgb3V0LnByb2pfXVxyXG4gICAgICAgIGlmIChkZWZhdWx0UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy54ID0gb3V0LnBvc2l0aW9uXy54IHx8IGRlZmF1bHRQb3NpdGlvbi5nZW9DZW50ZXJbMF1cclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gb3V0LnBvc2l0aW9uXy55IHx8IGRlZmF1bHRQb3NpdGlvbi5nZW9DZW50ZXJbMV1cclxuICAgICAgICB9IGVsc2UgaWYgKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhPy5iYm94KSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gY2VudGVyIG9mIGdlb0RhdGEgYmJveFxyXG4gICAgICAgICAgICBvdXQucG9zaXRpb25fLnggPSBvdXQucG9zaXRpb25fLnggfHwgMC41ICogKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbMF0gKyBvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzJdKVxyXG4gICAgICAgICAgICBvdXQucG9zaXRpb25fLnkgPSBvdXQucG9zaXRpb25fLnkgfHwgMC41ICogKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbMV0gKyBvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzNdKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vVE9ETzogYXV0by1kZWZpbmUgdXNlcj1kZWZpbmVkIGdlb21ldHJpZXMgZ2VvQ2VudGVyXHJcbiAgICAgICAgICAgIC8vIG91dC5wb3NpdGlvbl8ueCA9IEdlb21ldHJpZXMudXNlckdlb21ldHJpZXNcclxuICAgICAgICAgICAgLy8gb3V0LnBvc2l0aW9uXy55ID0gR2VvbWV0cmllcy51c2VyR2VvbWV0cmllc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb3B0aW9uYWw6IHNldCBmcm9tIFVSTFxyXG4gICAgICAgIHNldFZpZXdGcm9tVVJMKClcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZXREZWZhdWx0WiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0UG9zaXRpb24gPSBfZGVmYXVsdFBvc2l0aW9uW291dC5nZW9fICsgJ18nICsgb3V0LnByb2pfXVxyXG4gICAgICAgIGlmIChkZWZhdWx0UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIChkZWZhdWx0UG9zaXRpb24ucGl4ZWxTaXplICogODAwKSAvIG91dC53aWR0aF9cclxuICAgICAgICB9IGVsc2UgaWYgKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhPy5iYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzJdIC0gb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFswXSkgLyBvdXQud2lkdGhfLFxyXG4gICAgICAgICAgICAgICAgKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbM10gLSBvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzFdKSAvIG91dC5oZWlnaHRfXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMTAwXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZVByb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRGVmaW5lIHByb2plY3Rpb24gYmFzZWQgb24gdGhlIGdlb2dyYXBoaWNhbCBjb250ZXh0XHJcblxyXG4gICAgICAgIGlmIChvdXQuZ2VvXyA9PT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAvLyBVc2UgUm9iaW5zb24gcHJvamVjdGlvbiBmb3IgdGhlIHdvcmxkIHdpdGggb3B0aW9uYWwgY3VzdG9tIHByb2plY3Rpb24gZnVuY3Rpb25cclxuICAgICAgICAgICAgb3V0Ll9wcm9qZWN0aW9uID1cclxuICAgICAgICAgICAgICAgIG91dC5wcm9qZWN0aW9uRnVuY3Rpb25fIHx8XHJcbiAgICAgICAgICAgICAgICBnZW9Sb2JpbnNvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbb3V0LndpZHRoXyAvIDIsIG91dC5oZWlnaHRfIC8gMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKChvdXQud2lkdGhfIC0gMjApIC8gKDIgKiBNYXRoLlBJKSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3Igbm9uLVdPUkxEIGdlbywgdXNlIGN1c3RvbSBvciBkZWZhdWx0IGlkZW50aXR5IHByb2plY3Rpb24gd2l0aCBjYWxjdWxhdGVkIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICBvdXQuX3Byb2plY3Rpb24gPVxyXG4gICAgICAgICAgICAgICAgb3V0LnByb2plY3Rpb25GdW5jdGlvbl8gfHwgZ2VvSWRlbnRpdHkoKS5yZWZsZWN0WSh0cnVlKS5maXRTaXplKFtvdXQud2lkdGhfLCBvdXQuaGVpZ2h0X10sIGdldEJCT1hBc0dlb0pTT04oZ2V0Q3VycmVudEJib3goKSkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgY3VycmVudCB2aWV3IGFzIGJib3hcclxuICAgIGNvbnN0IGdldEN1cnJlbnRCYm94ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IDAuNSAqIG91dC5wb3NpdGlvbl8ueiAqIG91dC53aWR0aF9cclxuICAgICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gMC41ICogb3V0LnBvc2l0aW9uXy56ICogb3V0LmhlaWdodF9cclxuICAgICAgICBjb25zdCBiYm94ID0gW291dC5wb3NpdGlvbl8ueCAtIGhhbGZXaWR0aCwgb3V0LnBvc2l0aW9uXy55IC0gaGFsZkhlaWdodCwgb3V0LnBvc2l0aW9uXy54ICsgaGFsZldpZHRoLCBvdXQucG9zaXRpb25fLnkgKyBoYWxmSGVpZ2h0XVxyXG4gICAgICAgIHJldHVybiBiYm94XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGVmaW5lUGF0aEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC5fcGF0aEZ1bmN0aW9uID0gZ2VvUGF0aCgpLnByb2plY3Rpb24ob3V0Ll9wcm9qZWN0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZU1hcFpvb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHN2ZyA9IHNlbGVjdCgnIycgKyBvdXQuc3ZnSWQoKSlcclxuICAgICAgICBsZXQgcHJldmlvdXNUID0gem9vbUlkZW50aXR5XHJcbiAgICAgICAgY29uc3QgeG9vID0gem9vbSgpXHJcbiAgICAgICAgICAgIC5zY2FsZUV4dGVudChvdXQuem9vbUV4dGVudCgpKVxyXG4gICAgICAgICAgICAub24oJ3pvb20nLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUudHJhbnNmb3JtXHJcbiAgICAgICAgICAgICAgICBpZiAodC5rICE9PSBwcmV2aW91c1Quaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb21IYW5kbGVyKGUsIHByZXZpb3VzVClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFuSGFuZGxlcihlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGRlZmF1bHQgdHJhbnNmb3JtIHRvIG1hcFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAgICAgICAgIHpvb21Hcm91cC5hdHRyKCd0cmFuc2Zvcm0nLCB0KVxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNUID0gdFxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBzdmcuY2FsbCh4b28pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gWm9vbSBoYW5kbGVyIGZ1bmN0aW9uXHJcbiAgICBjb25zdCB6b29tSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCwgcHJldmlvdXNUKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZXZlbnQudHJhbnNmb3JtXHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJvamVjdGVkIGNlbnRlclxyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSAob3V0LndpZHRoXyAvIDIgLSB0cmFuc2Zvcm0ueCkgLyB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSAob3V0LmhlaWdodF8gLyAyIC0gdHJhbnNmb3JtLnkpIC8gdHJhbnNmb3JtLmtcclxuXHJcbiAgICAgICAgLy8gVXNlIHRoZSBwcm9qZWN0aW9uIHRvIGdldCB0aGUgcHJvamVjdGVkIGNlbnRlciBpbiBFUFNHOjMwMzVcclxuICAgICAgICBjb25zdCBbcHJvamVjdGVkWCwgcHJvamVjdGVkWV0gPSBvdXQuX3Byb2plY3Rpb24uaW52ZXJ0KFtjZW50ZXJYLCBjZW50ZXJZXSlcclxuXHJcbiAgICAgICAgLy8gc2V0IG5ldyBwb3NpdGlvblxyXG4gICAgICAgIG91dC5wb3NpdGlvbl8ueCA9IHByb2plY3RlZFhcclxuICAgICAgICBvdXQucG9zaXRpb25fLnkgPSBwcm9qZWN0ZWRZXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy56ID0gZ2V0TWV0cmVzUGVyUGl4ZWwodHJhbnNmb3JtLmsgLyBwcmV2aW91c1QuaylcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHN0cm9rZSBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICAgIHNjYWxlU3Ryb2tlV2lkdGhzKHRyYW5zZm9ybSlcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHN0cm9rZSBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXz8udmFsdWVzKSBzY2FsZUxhYmVsVGV4dHModHJhbnNmb3JtKVxyXG5cclxuICAgICAgICAvLyBhZGp1c3Qgc3Ryb2tlIGR5bmFtaWNhbGx5IGFjY29yZGluZyB0byB6b29tXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfPy5iYWNrZ3JvdW5kcykgc2NhbGVMYWJlbEJhY2tncm91bmRzKHRyYW5zZm9ybSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhZGp1c3RzIHRleHQgZWxlbWVudHMgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAqIEBwYXJhbSB7Kn0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNjYWxlTGFiZWxCYWNrZ3JvdW5kcyA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBvdXQuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gem9vbUdyb3VwLnNlbGVjdEFsbCgnLmVtLWxhYmVsLWJhY2tncm91bmQnKVxyXG4gICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXVxyXG5cclxuICAgICAgICBlbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQsIHgsIGFuZCB5IGZyb20gZGF0YSBhdHRyaWJ1dGVzIG9yIGN1cnJlbnQgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtd2lkdGgnKSkgfHwgcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ3dpZHRoJykpXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtaGVpZ2h0JykpIHx8IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdoZWlnaHQnKSlcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxYID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEteCcpKSB8fCBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cigneCcpKVxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFkgPSBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cignZGF0YS15JykpIHx8IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCd5JykpXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZWxlbWVudHMgdGhhdCBoYXZlIHZhbGlkIHdpZHRoLCBoZWlnaHQsIHgsIGFuZCB5XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFdpZHRoID4gMCAmJiBvcmlnaW5hbEhlaWdodCA+IDAgJiYgIWlzTmFOKG9yaWdpbmFsWCkgJiYgIWlzTmFOKG9yaWdpbmFsWSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0LCB4LCBhbmQgeSBmb3IgdGhlIGZpcnN0IHRpbWUgaWYgbm90IGFscmVhZHkgc3RvcmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuYXR0cignZGF0YS13aWR0aCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXdpZHRoJywgb3JpZ2luYWxXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2RhdGEtaGVpZ2h0Jywgb3JpZ2luYWxIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXgnLCBvcmlnaW5hbFgpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXknLCBvcmlnaW5hbFkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgd2lkdGgsIGhlaWdodCwgeCwgYW5kIHkgYmFzZWQgb24gem9vbSBmYWN0b3IgKGludmVyc2Ugc2NhbGluZylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gb3JpZ2luYWxXaWR0aCAqICgxIC8gem9vbUZhY3RvcikgLy8gSW52ZXJzZSBzY2FsaW5nXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSBvcmlnaW5hbEhlaWdodCAqICgxIC8gem9vbUZhY3RvcikgLy8gSW52ZXJzZSBzY2FsaW5nXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRYID0gb3JpZ2luYWxYICogKDEgLyB6b29tRmFjdG9yKSAvLyBBZGp1c3QgeCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0WSA9IG9yaWdpbmFsWSAqICgxIC8gem9vbUZhY3RvcikgLy8gQWRqdXN0IHkgcG9zaXRpb25cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHN0eWxlIGNoYW5nZSB0byBhIGJhdGNoIGFycmF5XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goeyBlbGVtZW50LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRYLCB0YXJnZXRZIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBBcHBseSBhbGwgc3R5bGUgY2hhbmdlcyBhdCBvbmNlXHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKCh7IGVsZW1lbnQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRhcmdldFgsIHRhcmdldFkgfSkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LmF0dHIoJ3dpZHRoJywgdGFyZ2V0V2lkdGgpLmF0dHIoJ2hlaWdodCcsIHRhcmdldEhlaWdodCkuYXR0cigneCcsIHRhcmdldFgpLmF0dHIoJ3knLCB0YXJnZXRZKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhZGp1c3RzIHRleHQgZWxlbWVudHMgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAqIEBwYXJhbSB7Kn0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNjYWxlTGFiZWxUZXh0cyA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBvdXQuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHpvb21Hcm91cC5zZWxlY3QoJyNlbS1sYWJlbHMnKVxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gbGFiZWxzLnNlbGVjdEFsbCgnKicpIC8vIFNlbGVjdCBhbGwgbGFiZWxzXHJcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IHRyYW5zZm9ybS5rXHJcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdXHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGZvbnQtc2l6ZSBmcm9tIGlubGluZSBvciBjb21wdXRlZCBzdHlsZVxyXG4gICAgICAgICAgICBjb25zdCBpbmxpbmVGb250U2l6ZSA9IGVsZW1lbnQuYXR0cignZm9udC1zaXplJylcclxuICAgICAgICAgICAgY29uc3QgY3NzRm9udFNpemUgPSBjb21wdXRlZFN0eWxlLmZvbnRTaXplXHJcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gaW5saW5lRm9udFNpemUgfHwgY3NzRm9udFNpemVcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBlbGVtZW50cyB0aGF0IGhhdmUgYSBmb250IHNpemUgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgJiYgcGFyc2VGbG9hdChmb250U2l6ZSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtZnMnKSkgfHwgcGFyc2VGbG9hdChpbmxpbmVGb250U2l6ZSkgfHwgcGFyc2VGbG9hdChjc3NGb250U2l6ZSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgZm9udCBzaXplIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmF0dHIoJ2RhdGEtZnMnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS1mcycsIG9yaWdpbmFsRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgZm9udCBzaXplIGJhc2VkIG9uIHpvb20gZmFjdG9yXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRGb250U2l6ZSA9IG9yaWdpbmFsRm9udFNpemUgLyB6b29tRmFjdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzdHlsZSBjaGFuZ2UgdG8gYSBiYXRjaCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKHsgZWxlbWVudDogdGhpcywgdGFyZ2V0Rm9udFNpemUgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGFsbCBzdHlsZSBjaGFuZ2VzIGF0IG9uY2VcclxuICAgICAgICB1cGRhdGVzLmZvckVhY2goKHsgZWxlbWVudCwgdGFyZ2V0Rm9udFNpemUgfSkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdmb250LXNpemUnLCBgJHt0YXJnZXRGb250U2l6ZX1weGAsICdpbXBvcnRhbnQnKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYWRqdXN0cyBhbGwgc3Ryb2tlLXdpZHRocyBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICogQHBhcmFtIHsqfSB0cmFuc2Zvcm1cclxuICAgICAqL1xyXG4gICAgY29uc3Qgc2NhbGVTdHJva2VXaWR0aHMgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHpvb21Hcm91cC5zZWxlY3RBbGwoJyonKSAvLyBTZWxlY3QgYWxsIGVsZW1lbnRzIGluIHRoZSB6b29tIGdyb3VwXHJcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IHRyYW5zZm9ybS5rXHJcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdXHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHN0cm9rZS13aWR0aCBmcm9tIGlubGluZSBvciBjb21wdXRlZCBzdHlsZVxyXG4gICAgICAgICAgICBjb25zdCBpbmxpbmVTdHJva2VXaWR0aCA9IGVsZW1lbnQuYXR0cignc3Ryb2tlLXdpZHRoJylcclxuICAgICAgICAgICAgY29uc3QgY3NzU3Ryb2tlV2lkdGggPSBjb21wdXRlZFN0eWxlLnN0cm9rZVdpZHRoXHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gaW5saW5lU3Ryb2tlV2lkdGggfHwgY3NzU3Ryb2tlV2lkdGhcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBlbGVtZW50cyB0aGF0IGhhdmUgYSBzdHJva2Ugd2lkdGggZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoc3Ryb2tlV2lkdGggJiYgcGFyc2VGbG9hdChzdHJva2VXaWR0aCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0cm9rZVdpZHRoID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtc3cnKSkgfHwgcGFyc2VGbG9hdChpbmxpbmVTdHJva2VXaWR0aCkgfHwgcGFyc2VGbG9hdChjc3NTdHJva2VXaWR0aClcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgc3Ryb2tlIHdpZHRoIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmF0dHIoJ2RhdGEtc3cnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS1zdycsIG9yaWdpbmFsU3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgc3Ryb2tlIHdpZHRoXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRTdHJva2VXaWR0aCA9IG9yaWdpbmFsU3Ryb2tlV2lkdGggLyB6b29tRmFjdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzdHlsZSBjaGFuZ2UgdG8gYSBiYXRjaCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKHsgZWxlbWVudDogdGhpcywgdGFyZ2V0U3Ryb2tlV2lkdGggfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGFsbCBzdHlsZSBjaGFuZ2VzIGF0IG9uY2VcclxuICAgICAgICB1cGRhdGVzLmZvckVhY2goKHsgZWxlbWVudCwgdGFyZ2V0U3Ryb2tlV2lkdGggfSkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdzdHJva2Utd2lkdGgnLCBgJHt0YXJnZXRTdHJva2VXaWR0aH1weGAsICdpbXBvcnRhbnQnKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gZ2V0IHRoZSBjdXJyZW50IHZpZXcncyBtZXRyZXMgcGVyIHBpeGVsLCBiYXNlZCBvbiBhIHpvb21GYWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tRmFjdG9yIHRoaXMgem9vbSAvIHByZXZpb3VzIHpvb21cclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0TWV0cmVzUGVyUGl4ZWwgPSBmdW5jdGlvbiAoem9vbUZhY3Rvcikge1xyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGJvdW5kaW5nIGJveCB3aWR0aCBpbiBtZXRlcnNcclxuICAgICAgICBjb25zdCBiYm94ID0gZ2V0Q3VycmVudEJib3goKVxyXG4gICAgICAgIGNvbnN0IGJib3hXaWR0aCA9IGJib3hbMl0gLSBiYm94WzBdIC8vIEJCT1ggd2lkdGggaW4gbWV0ZXJzXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtZXRlcnMgcGVyIHBpeGVsXHJcbiAgICAgICAgY29uc3QgbWV0ZXJzUGVyUGl4ZWwgPSBiYm94V2lkdGggLyAob3V0LndpZHRoXyAqIHpvb21GYWN0b3IpXHJcblxyXG4gICAgICAgIHJldHVybiBtZXRlcnNQZXJQaXhlbFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhbiBoYW5kbGVyIGZ1bmN0aW9uXHJcbiAgICBjb25zdCBwYW5IYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50LCBwcmV2aW91c1QpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm1cclxuXHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJvamVjdGVkIGNlbnRlclxyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSAob3V0LndpZHRoXyAvIDIgLSB0cmFuc2Zvcm0ueCkgLyB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSAob3V0LmhlaWdodF8gLyAyIC0gdHJhbnNmb3JtLnkpIC8gdHJhbnNmb3JtLmtcclxuICAgICAgICBsZXQgW2dlb1gsIGdlb1ldID0gb3V0Ll9wcm9qZWN0aW9uLmludmVydChbY2VudGVyWCwgY2VudGVyWV0pXHJcblxyXG4gICAgICAgIC8vIENsYW1wIGdlb1ggYW5kIGdlb1kgdG8gbWF4IGJvdW5kcyBhbmQgYWRqdXN0IHRoZSBldmVudCB0cmFuc2Zvcm1cclxuICAgICAgICBpZiAob3V0Lm1heEJvdW5kc18ueE1pbiAhPT0gdW5kZWZpbmVkICYmIGdlb1ggPCBvdXQubWF4Qm91bmRzXy54TWluKSB7XHJcbiAgICAgICAgICAgIGdlb1ggPSBvdXQubWF4Qm91bmRzXy54TWluXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS54ID0gb3V0LndpZHRoXyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVswXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXQubWF4Qm91bmRzXy55TWluICE9PSB1bmRlZmluZWQgJiYgZ2VvWSA8IG91dC5tYXhCb3VuZHNfLnlNaW4pIHtcclxuICAgICAgICAgICAgZ2VvWSA9IG91dC5tYXhCb3VuZHNfLnlNaW5cclxuICAgICAgICAgICAgdHJhbnNmb3JtLnkgPSBvdXQuaGVpZ2h0XyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVsxXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXQubWF4Qm91bmRzXy54TWF4ICE9PSB1bmRlZmluZWQgJiYgZ2VvWCA+IG91dC5tYXhCb3VuZHNfLnhNYXgpIHtcclxuICAgICAgICAgICAgZ2VvWCA9IG91dC5tYXhCb3VuZHNfLnhNYXhcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnggPSBvdXQud2lkdGhfIC8gMiAtIG91dC5fcHJvamVjdGlvbihbZ2VvWCwgZ2VvWV0pWzBdICogdHJhbnNmb3JtLmtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG91dC5tYXhCb3VuZHNfLnlNYXggIT09IHVuZGVmaW5lZCAmJiBnZW9ZID4gb3V0Lm1heEJvdW5kc18ueU1heCkge1xyXG4gICAgICAgICAgICBnZW9ZID0gb3V0Lm1heEJvdW5kc18ueU1heFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0ueSA9IG91dC5oZWlnaHRfIC8gMiAtIG91dC5fcHJvamVjdGlvbihbZ2VvWCwgZ2VvWV0pWzFdICogdHJhbnNmb3JtLmtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldCBuZXcgcG9zaXRpb25cclxuICAgICAgICBvdXQucG9zaXRpb25fLnggPSBnZW9YXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gZ2VvWVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgeCx5LHogZWxlbWVudHMgZnJvbSBVUkwgYW5kIGFzc2lnbiB0aGVtIHRvIHRoZSB2aWV3LiAqL1xyXG4gICAgY29uc3Qgc2V0Vmlld0Zyb21VUkwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IGdldFBhcmFtZXRlckJ5TmFtZSgneCcpLFxyXG4gICAgICAgICAgICB5ID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCd5JyksXHJcbiAgICAgICAgICAgIHogPSBnZXRQYXJhbWV0ZXJCeU5hbWUoJ3onKVxyXG4gICAgICAgIGlmICh4ICE9IG51bGwgJiYgeCAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt4KSkgb3V0LnBvc2l0aW9uXy54ID0gK3hcclxuICAgICAgICBpZiAoeSAhPSBudWxsICYmIHkgIT0gdW5kZWZpbmVkICYmICFpc05hTigreSkpIG91dC5wb3NpdGlvbl8ueSA9ICt5XHJcbiAgICAgICAgaWYgKHogIT0gbnVsbCAmJiB6ICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4oK3opKSBvdXQucG9zaXRpb25fLnogPSArelxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZEZvb3Rub3RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWZvb3Rub3RlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZvb3Rub3RlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG91dC5oZWlnaHRfKVxyXG4gICAgICAgICAgICAuaHRtbChvdXQuZm9vdG5vdGVfKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG91dC5fdG9vbHRpcC5td19fXyA9IG91dC5fdG9vbHRpcC5zdHlsZSgnbWF4LXdpZHRoJylcclxuICAgICAgICAgICAgICAgIG91dC5fdG9vbHRpcC5zdHlsZSgnbWF4LXdpZHRoJywgJzQwMHB4JylcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuZm9vdG5vdGVUb29sdGlwVGV4dF8pIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5mb290bm90ZVRvb2x0aXBUZXh0Xykgb3V0Ll90b29sdGlwLm1vdXNlb3V0KGUpXHJcbiAgICAgICAgICAgICAgICBvdXQuX3Rvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcsIG91dC5fdG9vbHRpcC5td19fXylcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRDb2FzdGFsTWFyZ2luVG9NYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgemcgPSBvdXQuc3ZnKCkuc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAvL2RyYXcgY29hc3RhbCBtYXJnaW5cclxuICAgICAgICBjb25zdCBjZyA9IHpnLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbicpLmF0dHIoJ2NsYXNzJywgJ2VtLWNvYXN0LW1hcmdpbicpXHJcblxyXG4gICAgICAgIC8vY291bnRyaWVzIGJuXHJcbiAgICAgICAgaWYgKG91dC5HZW9tZXRyaWVzLmdlb0pTT05zLmNudGJuKSB7XHJcbiAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLWNudCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY29hc3QtbWFyZ2luLWNudCcpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKG91dC5HZW9tZXRyaWVzLmdlb0pTT05zLmNudGJuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuY28gPT09ICdUJ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbnV0cyBiblxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5udXRzYm4pIHtcclxuICAgICAgICAgICAgY2cuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4tbnV0cycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY29hc3QtbWFyZ2luLW51dHMnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5udXRzYm4pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm4ucHJvcGVydGllcy5jbyA9PT0gJ1QnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIG91dC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy93b3JsZCBiblxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy53b3JsZGJuKSB7XHJcbiAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLXdvcmxkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jb2FzdC1tYXJnaW4td29ybGQnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuQ09BU19GTEFHID09PSAnVCdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgb3V0Ll9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZENlbnRyb2lkc1RvTWFwID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIGxldCBjZW50cm9pZEZlYXR1cmVzXHJcblxyXG4gICAgICAgIGlmICghbWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YSkge1xyXG4gICAgICAgICAgICAvLyBpZiBjZW50cm9pZHMgZGF0YSBpcyBhYnNlbnQgKGUuZy4gZm9yIHdvcmxkIG1hcHMpIHRoZW4gY2FsY3VsYXRlIG1hbnVhbGx5XHJcbiAgICAgICAgICAgIGlmIChtYXAuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50cm9pZEZlYXR1cmVzID0gW11cclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLndvcmxkcmcuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdGZWF0dXJlID0geyAuLi5mZWF0dXJlIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gZm9yIEZyYW5jZSAoYmVjYXVzZSBndXlhbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUucHJvcGVydGllcy5pZCA9PSAnRlInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZlYXR1cmUuZ2VvbWV0cnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogWzIuMiwgNDYuMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmVhdHVyZS5nZW9tZXRyeSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBnZW9DZW50cm9pZChmZWF0dXJlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2VudHJvaWRGZWF0dXJlcy5wdXNoKG5ld0ZlYXR1cmUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGNlbnRyb2lkRmVhdHVyZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YVswXS5mZWF0dXJlcyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5tYXAuR2VvbWV0cmllcy5jZW50cm9pZHNEYXRhWzFdLmZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGFbMl0uZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YVszXS5mZWF0dXJlcyxcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNlbnRyb2lkRmVhdHVyZXMgPSBtYXAuR2VvbWV0cmllcy5jZW50cm9pZHNEYXRhLmZlYXR1cmVzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXAucHJvY2Vzc0NlbnRyb2lkc18pIGNlbnRyb2lkRmVhdHVyZXMgPSBtYXAucHJvY2Vzc0NlbnRyb2lkc18oY2VudHJvaWRGZWF0dXJlcylcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHNjcmVlbiBjb29yZGluYXRlcyBhbmQgc2F2ZSBjZW50cm9pZHMgdG8gbWFwXHJcbiAgICAgICAgbWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcyA9IGNlbnRyb2lkRmVhdHVyZXMubWFwKChkKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSBtYXAuX3Byb2plY3Rpb24oZC5nZW9tZXRyeS5jb29yZGluYXRlcylcclxuICAgICAgICAgICAgZC5wcm9wZXJ0aWVzLmNlbnRyb2lkID0gY29vcmRzXHJcbiAgICAgICAgICAgIHJldHVybiBkXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gZW0tcHJvcC1zeW1ib2xzIGlzIHRoZSBnIGVsZW1lbnQgY29udGFpbmluZyBhbGwgcHJvcG9ydGlvbmFsIHN5bWJvbHMgZm9yIHRoZSBtYXBcclxuICAgICAgICBjb25zdCB6ZyA9IG1hcC5zdmcoKS5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBtYXAuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IGdjcCA9IHpnLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLXByb3Atc3ltYm9scycpXHJcblxyXG4gICAgICAgIC8vIGFkZCBjZW50cm9pZCBlbGVtZW50c1xyXG4gICAgICAgIC8vIHRoZW4gc3ltYm9scyBhcmUgZHJhd24vYXBwZW5kZWQgdG8gdGhlc2UgY29udGFpbmVycyBpbiB0aGUgbWFwLXR5cGUganMgZmlsZVxyXG4gICAgICAgIGNvbnN0IHN5bWJvbENvbnRhaW5lcnMgPSBnY3BcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgIC5kYXRhKG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBkLnByb3BlcnRpZXMuY2VudHJvaWRbMF0udG9GaXhlZCgzKSArICcsJyArIGQucHJvcGVydGllcy5jZW50cm9pZFsxXS50b0ZpeGVkKDMpICsgJyknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jZW50cm9pZCcpIC8vIE9VUiBTWU1CT0wgQ09OVEFJTkVSXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAncHMnICsgZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGFkZFNjYWxlYmFyVG9NYXBcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhcHBlbmRzIGFuIFNWRyBzY2FsZWJhciB0byB0aGUgbWFwLiBVc2VzIHBpeGVsU2l6ZSB0byBjYWxjdWxhdGUgdW5pdHMgaW4ga21cclxuICAgICAqL1xyXG4gICAgY29uc3QgYWRkU2NhbGViYXJUb01hcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBKdWxpZW4ncyBuaWNlIHNjYWxlYmFyc1xyXG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSA1XHJcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoUGl4ID0gb3V0LnNjYWxlYmFyTWF4V2lkdGhfXHJcbiAgICAgICAgY29uc3QgdGV4dE9mZnNldFggPSBvdXQuc2NhbGViYXJUZXh0T2Zmc2V0X1swXVxyXG4gICAgICAgIGNvbnN0IHRleHRPZmZzZXRZID0gb3V0LnNjYWxlYmFyVGV4dE9mZnNldF9bMV1cclxuICAgICAgICBjb25zdCBwaXhlbFNpemVNID0gb3V0LnBvc2l0aW9uXy56XHJcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoTSA9IG1heExlbmd0aFBpeCAqIHBpeGVsU2l6ZU1cclxuICAgICAgICBjb25zdCBuaWNlTGVuZ3RoTSA9IG5pY2VTY2FsZUJhckxlbmd0aChtYXhMZW5ndGhNKVxyXG4gICAgICAgIGNvbnN0IG5pY2VMZW5ndGhQaXhlbCA9IG5pY2VMZW5ndGhNWzBdIC8gcGl4ZWxTaXplTVxyXG4gICAgICAgIGNvbnN0IHNjYWxlQmFyU3RhcnREaWdpdCA9IG5pY2VMZW5ndGhNWzFdXHJcbiAgICAgICAgY29uc3Qgc3ViZGl2aXNpb25OYnMgPSB7XHJcbiAgICAgICAgICAgIDE6IDQsXHJcbiAgICAgICAgICAgIDI6IDIsXHJcbiAgICAgICAgICAgIDU6IDUsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzY2FsZWJhckdyb3VwID0gb3V0XHJcbiAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtvdXQuc2NhbGViYXJQb3NpdGlvbl9bMF19LCR7b3V0LnNjYWxlYmFyUG9zaXRpb25fWzFdfSlgKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBtYXhMZW5ndGhQaXggKyAyMClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zY2FsZWJhckhlaWdodF8pXHJcblxyXG4gICAgICAgIC8vIHRvcCBsaW5lIGZ1bGwgd2lkdGhcclxuICAgICAgICAvLyBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgLy8gICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd5MScsIDEpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd4MicsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd5MicsIDEpXHJcblxyXG4gICAgICAgIC8vYm90dG9tIGxpbmUgZnVsbCB3aWR0aFxyXG4gICAgICAgIC8vIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAvLyAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lJylcclxuICAgICAgICAvLyAgICAgLmF0dHIoJ3gxJywgbWFyZ2luTGVmdClcclxuICAgICAgICAvLyAgICAgLmF0dHIoJ3kxJywgb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8pXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd4MicsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclNlZ21lbnRIZWlnaHRfKVxyXG5cclxuICAgICAgICAvL2ZpcnN0IHRpY2tcclxuICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfKVxyXG5cclxuICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbkxlZnQgKyB0ZXh0T2Zmc2V0WClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuc2NhbGViYXJUaWNrSGVpZ2h0XyArIHRleHRPZmZzZXRZKVxyXG4gICAgICAgICAgICAudGV4dCgnMCcpXHJcblxyXG4gICAgICAgIC8vbWlkZGxlIHRpY2tzXHJcbiAgICAgICAgY29uc3Qgc3ViZGl2aXNpb25OYiA9IHN1YmRpdmlzaW9uTmJzW3NjYWxlQmFyU3RhcnREaWdpdF1cclxuICAgICAgICBjb25zdCBkaXZpc2lvbldpZHRoID0gbmljZUxlbmd0aFBpeGVsIC8gc3ViZGl2aXNpb25OYlxyXG4gICAgICAgIGNvbnN0IGRpdmlzaW9uTWluV2lkdGggPSAxNVxyXG4gICAgICAgIGNvbnN0IG1pZGxpbmVZID0gb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8gLyAyICsgMVxyXG4gICAgICAgIGlmIChkaXZpc2lvbldpZHRoID49IGRpdmlzaW9uTWluV2lkdGgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdWJkaXZpc2lvbk5iOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgbWFyZ2luTGVmdCArIG91dC5zY2FsZWJhclN0cm9rZVdpZHRoXyAvIDIgKyBpICogZGl2aXNpb25XaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8pXHJcbiAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbkxlZnQgKyB0ZXh0T2Zmc2V0WCArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8gKyB0ZXh0T2Zmc2V0WSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChnZXRTY2FsZWJhckxhYmVsKChuaWNlTGVuZ3RoTVswXSAvIHN1YmRpdmlzaW9uTmIpICogaSkpXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lIGVtLXNjYWxlYmFyLW1pZGxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG1pZGxpbmVZKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeDEgPSBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIChpIC0gMSkgKiBkaXZpc2lvbldpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgxID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lIGVtLXNjYWxlYmFyLW1pZGxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBtaWRsaW5lWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBtaWRsaW5lWSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgZmluYWwgbWlkbGluZSBzZWdtZW50IChsYXN0IHNlZ21lbnQpXHJcbiAgICAgICAgICAgIGlmIChkaXZpc2lvbldpZHRoID49IGRpdmlzaW9uTWluV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZSBlbS1zY2FsZWJhci1taWRsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0ICsgKHN1YmRpdmlzaW9uTmIgLSAxKSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgbWFyZ2luTGVmdCArIHN1YmRpdmlzaW9uTmIgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG1pZGxpbmVZKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIGZ1bGwtbGVuZ3RoIGhvcml6b250YWwgbWlkLWxpbmVcclxuICAgICAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZSBlbS1zY2FsZWJhci1taWRsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLSAxKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGRpdmlzaW9uV2lkdGggKiBzdWJkaXZpc2lvbk5iKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgbWlkbGluZVkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xhc3QgdGlja1xyXG4gICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgbmljZUxlbmd0aFBpeGVsICsgbWFyZ2luTGVmdClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgbmljZUxlbmd0aFBpeGVsICsgbWFyZ2luTGVmdClcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8pXHJcbiAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBuaWNlTGVuZ3RoUGl4ZWwgKyBtYXJnaW5MZWZ0ICsgdGV4dE9mZnNldFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8gKyB0ZXh0T2Zmc2V0WSlcclxuICAgICAgICAgICAgLnRleHQoZ2V0U2NhbGViYXJMYWJlbChuaWNlTGVuZ3RoTVswXSkgKyBvdXQuc2NhbGViYXJVbml0c18pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmljZVNjYWxlQmFyTGVuZ3RoID0gZnVuY3Rpb24gKHNjYWxlQmFyTGVuZ3RoKSB7XHJcbiAgICAgICAgLy9jb21wdXRlIHRoZSAnbmljZScgcG93ZXIgb2YgdGVuXHJcbiAgICAgICAgY29uc3QgcG93MTAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzY2FsZUJhckxlbmd0aCkgLyBNYXRoLmxvZygxMCkpKVxyXG5cclxuICAgICAgICAvL2NoZWNrIGlmIDUgdGltZXMgdGhpcyB2YWx1ZSBmaXRzXHJcbiAgICAgICAgaWYgKDUgKiBwb3cxMCA8PSBzY2FsZUJhckxlbmd0aCkgcmV0dXJuIFs1ICogcG93MTAsIDVdXHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgMiB0aW1lcyB0aGlzIHZhbHVlIGZpdHNcclxuICAgICAgICBpZiAoMiAqIHBvdzEwIDw9IHNjYWxlQmFyTGVuZ3RoKSByZXR1cm4gWzIgKiBwb3cxMCwgMl1cclxuXHJcbiAgICAgICAgLy9yZXR1cm5zIHRoZSBwb3dlciBvZiB0ZW5cclxuICAgICAgICByZXR1cm4gW3BvdzEwLCAxXVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdldFNjYWxlYmFyTGFiZWwgPSBmdW5jdGlvbiAodmFsdWVNKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlTSA8IDAuMDEpIHJldHVybiB2YWx1ZU0gKiAxMDAwICsgJ21tJ1xyXG4gICAgICAgIGlmICh2YWx1ZU0gPCAxKSByZXR1cm4gdmFsdWVNICogMTAwICsgJ2NtJ1xyXG4gICAgICAgIGlmICh2YWx1ZU0gPCAxMDAwKSByZXR1cm4gdmFsdWVNICogMSArICdtJ1xyXG4gICAgICAgIHJldHVybiB2YWx1ZU0gLyAxMDAwXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKiogRGVmYXVsdCBnZW9jZW50ZXIgcG9zaXRpb25zIGFuZCBwaXhlbFNpemUgKGZvciBkZWZhdWx0IHdpZHRoID0gODAwcHgpIGZvciB0ZXJyaXRvcmllcyBhbmQgcHJvamVjdGlvbnMuICovXHJcbmNvbnN0IF9kZWZhdWx0UG9zaXRpb24gPSB7XHJcbiAgICBFVVJfMzAzNTogeyBnZW9DZW50ZXI6IFs0NzkwMDAwLCAzNDIwMDAwXSwgcGl4ZWxTaXplOiA2NDAwIH0sXHJcbiAgICBJQ18zMjYyODogeyBnZW9DZW50ZXI6IFs0NDM0NjgsIDMxNDU2NDddLCBwaXhlbFNpemU6IDEwMDAgfSxcclxuICAgIEdQXzMyNjIwOiB7IGdlb0NlbnRlcjogWzY2OTQ5OCwgMTc4NDU1Ml0sIHBpeGVsU2l6ZTogMTMwIH0sXHJcbiAgICBNUV8zMjYyMDogeyBnZW9DZW50ZXI6IFs3MTY1MjEsIDE2MjEzMjJdLCBwaXhlbFNpemU6IDEzMCB9LFxyXG4gICAgR0ZfMzI2MjI6IHsgZ2VvQ2VudGVyOiBbMjY2ODUyLCA0NDQwNzRdLCBwaXhlbFNpemU6IDUwMCB9LFxyXG4gICAgUkVfMzI3NDA6IHsgZ2VvQ2VudGVyOiBbMzQ4MDExLCA3NjYxNjI3XSwgcGl4ZWxTaXplOiAxMzAgfSxcclxuICAgIFlUXzMyNzM4OiB7IGdlb0NlbnRlcjogWzUxNjU0OSwgODU4MzkyMF0sIHBpeGVsU2l6ZTogNzAgfSxcclxuICAgIE1UXzMwMzU6IHsgZ2VvQ2VudGVyOiBbNDcxOTc1NSwgMTQ0MTcwMV0sIHBpeGVsU2l6ZTogNzAgfSxcclxuICAgIFBUMjBfMzI2MjY6IHsgZ2VvQ2VudGVyOiBbMzk3NDE4LCA0MjcxNDcxXSwgcGl4ZWxTaXplOiAxNTAwIH0sXHJcbiAgICBQVDMwXzMyNjI4OiB7IGdlb0NlbnRlcjogWzMzMzU4NiwgMzYyMjcwNl0sIHBpeGVsU2l6ZTogMTUwIH0sXHJcbiAgICBMSV8zMDM1OiB7IGdlb0NlbnRlcjogWzQyODcwNjAsIDI2NzIwMDBdLCBwaXhlbFNpemU6IDQwIH0sXHJcbiAgICBJU18zMDM1OiB7IGdlb0NlbnRlcjogWzMwMTE4MDQsIDQ5NjAwMDBdLCBwaXhlbFNpemU6IDcwMCB9LFxyXG4gICAgU0pfU1ZfMzAzNTogeyBnZW9DZW50ZXI6IFs0NTcwMDAwLCA2MTYwMTU2XSwgcGl4ZWxTaXplOiA4MDAgfSxcclxuICAgIFNKX0pNXzMwMzU6IHsgZ2VvQ2VudGVyOiBbMzY0Nzc2MiwgNTQwODMwMF0sIHBpeGVsU2l6ZTogMTAwIH0sXHJcbiAgICBDQVJJQl8zMjYyMDogeyBnZW9DZW50ZXI6IFs2MzYzNDUsIDE2Njk0MzldLCBwaXhlbFNpemU6IDUwMCB9LFxyXG4gICAgV09STERfNTQwMzA6IHsgZ2VvQ2VudGVyOiBbMTQsIDE3XSwgcGl4ZWxTaXplOiA5MDAwIH0sXHJcbn1cclxuIiwiaW1wb3J0IHsgZ2VvT3J0aG9ncmFwaGljLCBnZW9QYXRoLCBnZW9DZW50cm9pZCB9IGZyb20gJ2QzLWdlbydcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBmZWF0dXJlIH0gZnJvbSAndG9wb2pzb24tY2xpZW50J1xyXG5pbXBvcnQgeyBqc29uIH0gZnJvbSAnZDMtZmV0Y2gnXHJcblxyXG5leHBvcnQgY29uc3QgYXBwZW5kTWluaW1hcCA9IChtYXApID0+IHtcclxuICAgIGlmICghbWFwLnN2Z18pIHJldHVyblxyXG5cclxuICAgIGNvbnN0IG1pbmltYXBDb25maWcgPSBtYXAubWluaW1hcF8gfHwge31cclxuICAgIGNvbnN0IGNvdW50cnlJZCA9IG1pbmltYXBDb25maWcuY291bnRyeUlkIHx8ICdERScgLy8gZGVmYXVsdCB0byBDaGluYVxyXG4gICAgY29uc3QgeCA9IG1pbmltYXBDb25maWcueCB8fCA4MCAvLyBkZWZhdWx0IHggcG9zaXRpb25cclxuICAgIGNvbnN0IHkgPSBtaW5pbWFwQ29uZmlnLnkgfHwgODAgLy8gZGVmYXVsdCB5IHBvc2l0aW9uXHJcbiAgICBjb25zdCB6ID0gbWluaW1hcENvbmZpZy56IHx8IDE2MCAvLyBkZWZhdWx0IHpvb20gbGV2ZWxcclxuICAgIGNvbnN0IGNvbG9yID0gbWluaW1hcENvbmZpZy5jb2xvciB8fCAnIzM3OTJCNicgLy8gZGVmYXVsdCBjb2xvclxyXG5cclxuICAgIGNvbnN0IGRyYXdNaW5pbWFwID0gKGdlb21ldHJpZXMpID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBtYXAuc3ZnXy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1taW5pbWFwJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkgLy8gYWRqdXN0IGFzIG5lZWRlZFxyXG4gICAgICAgIC8vIGRpYW1ldGVyXHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IDE2MFxyXG4gICAgICAgIC8vIERyYXcgaW5uZXIgY2lyY2xlXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgc2l6ZSAvIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeCcsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3doaXRlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMylcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9IGdlb09ydGhvZ3JhcGhpYygpLnNjYWxlKHopLnRyYW5zbGF0ZShbMCwgMF0pXHJcblxyXG4gICAgICAgIGNvbnN0IHBhdGggPSBnZW9QYXRoKCkucHJvamVjdGlvbihwcm9qZWN0aW9uKVxyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZW9tZXRyaWVzLmZpbmQoKGQpID0+IGQucHJvcGVydGllcy5pZCA9PT0gY291bnRyeUlkKVxyXG4gICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm4gY29uc29sZS53YXJuKGBDb3VudHJ5IElEICR7Y291bnRyeUlkfSBub3QgZm91bmQgaW4gZ2VvbWV0cmllc2ApXHJcblxyXG4gICAgICAgIC8vIENlbnRlciB0aGUgZ2xvYmUgb24gdGhlIHNlbGVjdGVkIGNvdW50cnlcclxuICAgICAgICBjb25zdCBbW3gwLCB5MF0sIFt4MSwgeTFdXSA9IHBhdGguYm91bmRzKHRhcmdldClcclxuICAgICAgICBjb25zdCBjZW50cm9pZCA9IFsoeDAgKyB4MSkgLyAyLCAoeTAgKyB5MSkgLyAyXVxyXG4gICAgICAgIGNvbnN0IFtsb24sIGxhdF0gPSBwcm9qZWN0aW9uLmludmVydChjZW50cm9pZClcclxuICAgICAgICBwcm9qZWN0aW9uLnJvdGF0ZShbLWxvbiwgLWxhdF0pXHJcblxyXG4gICAgICAgIC8vIERlZmluZSBjaXJjdWxhciBjbGlwXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdjbGlwUGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdtaW5pbWFwLWNsaXAnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAuYXR0cigncicsIHNpemUgLyAyKVxyXG4gICAgICAgICAgICAuYXR0cignY3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cignY3knLCAwKVxyXG5cclxuICAgICAgICBjb25zdCBnbG9iZSA9IGNvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCNtaW5pbWFwLWNsaXApJylcclxuXHJcbiAgICAgICAgLy8gRHJhdyBhbGwgY291bnRyaWVzXHJcbiAgICAgICAgZ2xvYmUuc2VsZWN0QWxsKCdwYXRoLmNvdW50cnknKS5kYXRhKGdlb21ldHJpZXMpLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHBhdGgpLmF0dHIoJ2ZpbGwnLCAnI2UwZTBlMCcpXHJcbiAgICAgICAgLy8gLmF0dHIoJ3N0cm9rZScsICcjOTk5JylcclxuICAgICAgICAvLyAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC4zKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgY291bnRyeVxyXG4gICAgICAgIGdsb2JlLmFwcGVuZCgncGF0aCcpLmRhdHVtKHRhcmdldCkuYXR0cignZCcsIHBhdGgpLmF0dHIoJ2ZpbGwnLCBjb2xvcikuYXR0cignc3Ryb2tlJywgY29sb3IpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDAuNSlcclxuXHJcbiAgICAgICAgLy8gRHJhdyBvdXRlciBjaXJjbGVcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBzaXplIC8gMilcclxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDMpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLndvcmxkcmcpIHtcclxuICAgICAgICBkcmF3TWluaW1hcChtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy53b3JsZHJnKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBqc29uKCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXVyb3N0YXQvZXVyb3N0YXQtbWFwL21hc3Rlci9zcmMvYXNzZXRzL3RvcG9qc29uL1dPUkxEXzQzMjYuanNvbicpXHJcbiAgICAgICAgICAgIC50aGVuKCh0b3BvRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBmZWF0dXJlKHRvcG9EYXRhLCB0b3BvRGF0YS5vYmplY3RzLkNOVFJfUkdfMjBNXzIwMjBfNDMyNikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgIGRyYXdNaW5pbWFwKGZlYXR1cmVzKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgV09STERfNDMyNi5qc29uJywgZXJyKSlcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBnZXRSZWdpb25zU2VsZWN0b3IgfSBmcm9tICcuL3V0aWxzJ1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXR0ZXJuRmlsbChtYXAsIGNvbmZpZ3MgPSBbXSkge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3MpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdwYXR0ZXJuRmlsbCBleHBlY3RzIGFuIGFycmF5IG9mIGNvbmZpZ3MnKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGxldCBkZWZzID0gbWFwLnN2ZygpLnNlbGVjdCgnZGVmcycpXHJcbiAgICBpZiAoZGVmcy5lbXB0eSgpKSB7XHJcbiAgICAgICAgZGVmcyA9IG1hcC5zdmcoKS5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZXBhcmU6IG1hcCBlYWNoIHJlZ2lvbklkIHRvIGFuIGFycmF5IG9mIHBhdHRlcm5JZHNcclxuICAgIGNvbnN0IHJlZ2lvblRvUGF0dGVybklkcyA9IHt9XHJcblxyXG4gICAgY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+IHtcclxuICAgICAgICBjb25zdCB7IHBhdHRlcm4gPSAnaGF0Y2hpbmcnLCByZWdpb25JZHMgPSBbXSwgY29sb3IgPSAnIzAwMCcsIHN0cm9rZVdpZHRoID0gMSwgY3VzdG9tUGF0dGVybiB9ID0gY29uZmlnXHJcblxyXG4gICAgICAgIGxldCBwYXR0ZXJuSWRcclxuXHJcbiAgICAgICAgaWYgKGN1c3RvbVBhdHRlcm4pIHtcclxuICAgICAgICAgICAgY29uc3QgaWRNYXRjaCA9IGN1c3RvbVBhdHRlcm4ubWF0Y2goL2lkPVsnXCJdKFteJ1wiXSspWydcIl0vKVxyXG4gICAgICAgICAgICBpZiAoaWRNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgcGF0dGVybklkID0gaWRNYXRjaFsxXVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXAuc3ZnKCkuc2VsZWN0KGAjJHtwYXR0ZXJuSWR9YCkuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZnMubm9kZSgpLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgY3VzdG9tUGF0dGVybilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY3VzdG9tUGF0dGVybiBtdXN0IGluY2x1ZGUgYW4gaWQgYXR0cmlidXRlLicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yS2V5ID0gY29sb3IucmVwbGFjZSgnIycsICcnKS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgICAgIHBhdHRlcm5JZCA9IGAke3BhdHRlcm59LSR7Y29sb3JLZXl9LXN3JHtzdHJva2VXaWR0aH1gXHJcbiAgICAgICAgICAgIGRlZmluZVBhdHRlcm4obWFwLCBwYXR0ZXJuSWQsIHBhdHRlcm4sIGNvbG9yLCBzdHJva2VXaWR0aClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbmZpZy5wYXR0ZXJuSWQgPSBwYXR0ZXJuSWRcclxuXHJcbiAgICAgICAgcmVnaW9uSWRzLmZvckVhY2goKHJlZ2lvbklkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghcmVnaW9uVG9QYXR0ZXJuSWRzW3JlZ2lvbklkXSkge1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uVG9QYXR0ZXJuSWRzW3JlZ2lvbklkXSA9IFtdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVnaW9uVG9QYXR0ZXJuSWRzW3JlZ2lvbklkXS5wdXNoKHBhdHRlcm5JZClcclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBBcHBseSBhbGwgcGF0dGVybnMgZm9yIGVhY2ggcmVnaW9uIChzdGFja2luZyB0aGVtKVxyXG4gICAgbWFwLnN2ZygpXHJcbiAgICAgICAgLnNlbGVjdEFsbChnZXRSZWdpb25zU2VsZWN0b3IobWFwKSlcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGQ/LnByb3BlcnRpZXM/LmlkXHJcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5JZHMgPSByZWdpb25Ub1BhdHRlcm5JZHNbaWRdXHJcblxyXG4gICAgICAgICAgICBpZiAocGF0dGVybklkcyAmJiBwYXR0ZXJuSWRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBzZWxlY3QodGhpcylcclxuXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuSWRzLmZvckVhY2goKHBhdHRlcm5JZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gb3JpZ2luYWwubm9kZSgpLmNsb25lTm9kZSh0cnVlKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QoY2xvbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgYHVybCgjJHtwYXR0ZXJuSWR9KWApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgKG9yaWdpbmFsLmF0dHIoJ2NsYXNzJykgfHwgJycpICsgJyBwYXR0ZXJuLWZpbGwtb3ZlcmxheScpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLmFwcGVuZCgoKSA9PiBjbG9uZSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVQYXR0ZXJuKG1hcCwgcGF0dGVybklkLCBwYXR0ZXJuTmFtZSwgY29sb3IsIHN0cm9rZVdpZHRoKSB7XHJcbiAgICBjb25zdCBkZWZzID0gbWFwLnN2ZygpLnNlbGVjdCgnZGVmcycpXHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAgIG1hcFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdChgIyR7Q1NTLmVzY2FwZShwYXR0ZXJuSWQpfWApXHJcbiAgICAgICAgICAgIC5lbXB0eSgpXHJcbiAgICApIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gZGVmcy5hcHBlbmQoJ3BhdHRlcm4nKS5hdHRyKCdpZCcsIHBhdHRlcm5JZCkuYXR0cigncGF0dGVyblVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJykuYXR0cignd2lkdGgnLCA4KS5hdHRyKCdoZWlnaHQnLCA4KVxyXG5cclxuICAgICAgICBpZiAocGF0dGVybk5hbWUgPT09ICdoYXRjaGluZycpIHtcclxuICAgICAgICAgICAgcGF0dGVybi5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgJ00tMSwxIGwyLC0yIE0wLDggbDgsLTggTTcsOSBsMiwtMicpLmF0dHIoJ3N0cm9rZScsIGNvbG9yKS5hdHRyKCdzdHJva2Utd2lkdGgnLCBzdHJva2VXaWR0aClcclxuICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm5OYW1lID09PSAnY3Jvc3NoYXRjaCcpIHtcclxuICAgICAgICAgICAgcGF0dGVybi5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgJ00wLDAgbDgsOCBNOCwwIGwtOCw4JykuYXR0cignc3Ryb2tlJywgY29sb3IpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgIH0gZWxzZSBpZiAocGF0dGVybk5hbWUgPT09ICdkb3RzJykge1xyXG4gICAgICAgICAgICBwYXR0ZXJuLmFwcGVuZCgnY2lyY2xlJykuYXR0cignY3gnLCA0KS5hdHRyKCdjeScsIDQpLmF0dHIoJ3InLCBzdHJva2VXaWR0aCkuYXR0cignZmlsbCcsIGNvbG9yKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBwYXR0ZXJuIFwiJHtwYXR0ZXJuTmFtZX1cIiwgZGVmYXVsdGluZyB0byBoYXRjaGluZy5gKVxyXG4gICAgICAgICAgICBwYXR0ZXJuLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCAnTS0xLDEgbDIsLTIgTTAsOCBsOCwtOCBNNyw5IGwyLC0yJykuYXR0cignc3Ryb2tlJywgY29sb3IpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJleHBvcnQgY29uc3QgYXBwZW5kU3RhbXAgPSAoc3RhbXBDb25maWcsIG1hcCkgPT4ge1xyXG4gICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBtYXAuc3ZnXy5zZWxlY3QoJyNlbS1zdGFtcCcpXHJcbiAgICAgICAgZXhpc3RpbmcucmVtb3ZlKClcclxuXHJcbiAgICAgICAgaWYgKHN0YW1wQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5zdmdfLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLXN0YW1wJylcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBkZWZhdWx0c1xyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLnNpemUpIHN0YW1wQ29uZmlnLnNpemUgPSA2MFxyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLngpIHN0YW1wQ29uZmlnLnggPSAyMzBcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy55KSBzdGFtcENvbmZpZy55ID0gMTAwXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcudGV4dENvbG9yKSBzdGFtcENvbmZpZy50ZXh0Q29sb3IgPSAnIzAwMCdcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy5zdGFtcENvbG9yKSBzdGFtcENvbmZpZy5zdGFtcENvbG9yID0gJyMwMDAnXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcuc3Ryb2tlV2lkdGgpIHN0YW1wQ29uZmlnLnN0cm9rZVdpZHRoID0gMVxyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLmxpbmVIZWlnaHQpIHN0YW1wQ29uZmlnLmxpbmVIZWlnaHQgPSAxNVxyXG5cclxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgY2lyY2xlXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgc3RhbXBDb25maWcuc2l6ZSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHN0YW1wQ29uZmlnLngpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBzdGFtcENvbmZpZy55KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXN0YW1wLWNpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBzdGFtcENvbmZpZy5zdGFtcENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHN0YW1wQ29uZmlnLnN0cm9rZVdpZHRoKVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHRleHRcclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHN0YW1wQ29uZmlnLnRleHRcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0V2lkdGggPSBNYXRoLnNxcnQobWVhc3VyZVdpZHRoKHRleHQudHJpbSgpKSAqIHN0YW1wQ29uZmlnLmxpbmVIZWlnaHQpXHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gZ2V0TGluZXMoZ2V0V29yZHModGV4dC50cmltKCkpLCB0YXJnZXRXaWR0aClcclxuICAgICAgICAgICAgY29uc3QgdGV4dFJhZGl1cyA9IGdldFRleHRSYWRpdXMobGluZXMsIHN0YW1wQ29uZmlnLmxpbmVIZWlnaHQpXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgaW5zaWRlIGNpcmNsZVxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIHN0YW1wQ29uZmlnLnRleHRDb2xvcilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1zdGFtcC10ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7c3RhbXBDb25maWcueH0sJHtzdGFtcENvbmZpZy55fSkgc2NhbGUoJHtzdGFtcENvbmZpZy5zaXplIC8gdGV4dFJhZGl1c30pYClcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RzcGFuJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGxpbmVzKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RzcGFuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IChpIC0gbGluZXMubGVuZ3RoIC8gMiArIDAuOCkgKiBzdGFtcENvbmZpZy5saW5lSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnRleHQoKGQpID0+IGQudGV4dC5yZXBsYWNlQWxsKCd+JywgJyAnKS5yZXBsYWNlQWxsKCfCticsICcnKSkgLy8gUmVtb3ZlcyDCtiAobGluZSBicmVha2VyKSBhbmQgfiAobm9uIGJyZWFraW5nIHNwYWNlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8gU3BsaXR0aW5nIGJ5IGJvdGggc3BhY2VzIGFuZCBwaWxjcm93c1xyXG5jb25zdCBnZXRXb3JkcyA9ICh0ZXh0KSA9PiB7XHJcbiAgICByZXR1cm4gdGV4dFxyXG4gICAgICAgIC5zcGxpdCgvKD88PcK2KXxcXHMrL2cpXHJcbiAgICAgICAgLm1hcCgod29yZCkgPT4gd29yZC50cmltKCkpXHJcbiAgICAgICAgLmZpbHRlcigod29yZCkgPT4gd29yZC5sZW5ndGggPiAwKVxyXG59XHJcblxyXG4vLyBDb21wdXRlcyB0ZXh0IHdpZHRoXHJcbmNvbnN0IG1lYXN1cmVXaWR0aCA9ICh0ZXh0KSA9PiB7XHJcbiAgICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpXHJcbiAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAndGV4dCcpXHJcblxyXG4gICAgdGV4dEVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0XHJcbiAgICBzdmcuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpXHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2ZylcclxuXHJcbiAgICBjb25zdCB3aWR0aCA9IHRleHRFbGVtZW50LmdldENvbXB1dGVkVGV4dExlbmd0aCgpXHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHN2ZylcclxuXHJcbiAgICByZXR1cm4gd2lkdGggKyAxMFxyXG59XHJcblxyXG4vLyBDb21wdXRlIHRleHQgcmFkaXVzXHJcbmNvbnN0IGdldFRleHRSYWRpdXMgPSAobGluZXMsIGxpbmVIZWlnaHQpID0+IHtcclxuICAgIGxldCByYWRpdXMgPSAwXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGR5ID0gKE1hdGguYWJzKGkgLSBuIC8gMiArIDAuNSkgKyAwLjUpICogbGluZUhlaWdodFxyXG4gICAgICAgIGNvbnN0IGR4ID0gbGluZXNbaV0ud2lkdGggLyAyXHJcbiAgICAgICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCBNYXRoLnNxcnQoZHggKiogMiArIGR5ICoqIDIpKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhZGl1c1xyXG59XHJcblxyXG4vLyBIYW5kbGVzIGZvcmNlZCBsaW5lIGJyZWFrc1xyXG5jb25zdCBnZXRMaW5lcyA9ICh3b3JkcywgdGFyZ2V0V2lkdGgpID0+IHtcclxuICAgIGxldCBsaW5lcyA9IFtdXHJcbiAgICBsZXQgbGluZSA9IHsgd2lkdGg6IDAsIHRleHQ6ICcnIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHdvcmRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGlmICh3b3Jkc1tpXSA9PT0gJ8K2Jykge1xyXG4gICAgICAgICAgICAvLyBQdXNoIGN1cnJlbnQgbGluZSAoaWYgaXQgaGFzIHRleHQpXHJcbiAgICAgICAgICAgIGlmIChsaW5lLnRleHQpIGxpbmVzLnB1c2gobGluZSlcclxuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgZW1wdHkgbGluZVxyXG4gICAgICAgICAgICBsaW5lID0geyB3aWR0aDogMCwgdGV4dDogJycgfVxyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxpbmVUZXh0MSA9IChsaW5lLnRleHQgPyBsaW5lLnRleHQgKyAnICcgOiAnJykgKyB3b3Jkc1tpXVxyXG4gICAgICAgIGxldCBsaW5lV2lkdGgxID0gbWVhc3VyZVdpZHRoKGxpbmVUZXh0MSlcclxuXHJcbiAgICAgICAgaWYgKChsaW5lLndpZHRoICsgbGluZVdpZHRoMSkgLyAyIDwgdGFyZ2V0V2lkdGgpIHtcclxuICAgICAgICAgICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDFcclxuICAgICAgICAgICAgbGluZS50ZXh0ID0gbGluZVRleHQxXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKVxyXG4gICAgICAgICAgICBsaW5lID0geyB3aWR0aDogbWVhc3VyZVdpZHRoKHdvcmRzW2ldKSwgdGV4dDogd29yZHNbaV0gfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobGluZS50ZXh0KSBsaW5lcy5wdXNoKGxpbmUpIC8vIFB1c2ggbGFzdCBsaW5lIGlmIGl0IGV4aXN0c1xyXG5cclxuICAgIHJldHVybiBsaW5lc1xyXG59XHJcbiIsImltcG9ydCB7IGpzb24sIGNzdiB9IGZyb20gJ2QzLWZldGNoJ1xyXG5pbXBvcnQgeyBnZXRFc3RhdERhdGFVUkwgfSBmcm9tICcuL3V0aWxzJ1xyXG5pbXBvcnQgSlNPTnN0YXQgZnJvbSAnanNvbnN0YXQtdG9vbGtpdCdcclxuaW1wb3J0IHsgY3N2VG9JbmRleCwganNvbnN0YXRUb0luZGV4IH0gZnJvbSAnLi91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIHN0YXRpc3RpY2FsIGRhdGFzZXQsIHRvIGJlIHVzZWQgZm9yIGEgc3RhdGlzdGljYWwgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0YXREYXRhID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBzdGF0IGRhdGEgb2JqZWN0XHJcbiAgICBjb25zdCBvdXQgPSB7fVxyXG5cclxuICAgIG91dC5fX2RhdGEgPSB1bmRlZmluZWQgLy9mb3IgZGVidWdnaW5nXHJcblxyXG4gICAgLy9vdXQubWF4TnVtYmVyT2ZEZWNpbWFsc0luRGF0YXNldCA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0YXRpc3RpY2FsIHZhbHVlcywgaW5kZXhlZCBieSBOVVRTIGlkLlxyXG4gICAgICogRWFjaCBzdGF0IHZhbHVlIGlzIGFuIG9iamVjdCB7dmFsdWUsc3RhdHVzfS5cclxuICAgICAqL1xyXG4gICAgb3V0Ll9kYXRhXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzdGF0IHZhbHVlIHt2YWx1ZSxzdGF0dXN9IGZyb20gYSBudXRzIGlkLlxyXG4gICAgICogSWYgbm8gYXJndW1lbnQgaXMgc3BlY2lmaWVkLCByZXR1cm5zIHRoZSBlbnRpcmUgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0geyp9IG51dHNJZFxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0ID0gKG51dHNJZCkgPT4ge1xyXG4gICAgICAgIGlmICghbnV0c0lkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuX2RhdGFfXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG91dC5fZGF0YV8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuX2RhdGFfW251dHNJZF1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc3RhdCB2YWx1ZSBmcm9tIGEgbnV0cyBpZC5cclxuICAgICAqIEBwYXJhbSB7Kn0gbnV0c0lkXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXRWYWx1ZSA9IChudXRzSWQpID0+IHtcclxuICAgICAgICBjb25zdCBzID0gb3V0LmdldChudXRzSWQpXHJcbiAgICAgICAgcmV0dXJuIHMgPyBzLnZhbHVlIDogdW5kZWZpbmVkXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBzdGF0IHZhbHVlIGZyb20gYSBudXRzIGlkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBudXRzSWRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHx8IFN0cmluZyB8fCBOdW1iZXJ9IHN0YXQgVGhlIG5ldyBzdGF0aXN0aWNhbCBkYXRhLiBUaGUgZm9ybWF0IGNhbiBiZSBlaXRoZXIge3ZhbHVlOjM0LjMyNCxzdGF0dXM6XCJlXCJ9IG9yIGEgdGhlIHZhbHVlIG9ubHkuXHJcbiAgICAgKi9cclxuICAgIG91dC5zZXQgPSAobnV0c0lkLCBzdGF0KSA9PiB7XHJcbiAgICAgICAgb3V0Ll9kYXRhXyA9IG91dC5fZGF0YV8gfHwge31cclxuICAgICAgICBjb25zdCBzID0gb3V0Ll9kYXRhX1tudXRzSWRdXHJcblxyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBzLnZhbHVlID0gc3RhdC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgcy5zdGF0dXMgPSBzdGF0LnN0YXR1c1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYmUgY2FyZWZ1bCBoZXJlIHNldHRpbmcgdmFsdWVzIGhlcmUsIHdlIG5lZWQgdG8gbWFpbnRhaW4gc3RyaW5ncyB3aXRoIHRyYWlsaW5nIHplcm9zIGJlY2F1c2UgaW4gSlNPTiAxLjAgPT09IDEgYW5kIHRoZXkgYXJlIHJlbW92ZWQuIFVzZXIgbWlnaHQgd2FudCBzdGF0cyBsYWJlbHMgd2l0aCB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIHMudmFsdWUgPSBzdGF0XHJcbiAgICAgICAgICAgICAgICAvL3MudmFsdWUgPSBpc05hTigrc3RhdCkgPyBzdGF0IDogK3N0YXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNhcmVmdWwgaGVyZSBzZXR0aW5nIHZhbHVlcyBoZXJlLCB3ZSBuZWVkIHRvIG1haW50YWluIHN0cmluZ3Mgd2l0aCB0cmFpbGluZyB6ZXJvcyBiZWNhdXNlIGluIEpTT04gMS4wID09PSAxIGFuZCB0aGV5IGFyZSByZW1vdmVkLiBVc2VyIG1pZ2h0IHdhbnQgc3RhdHMgbGFiZWxzIHdpdGggdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIG91dC5fZGF0YV9bbnV0c0lkXSA9IHN0YXQudmFsdWUgPyBzdGF0IDogeyB2YWx1ZTogc3RhdCB9XHJcbiAgICAgICAgICAgIC8vb3V0Ll9kYXRhX1tudXRzSWRdID0gc3RhdC52YWx1ZSA/IHN0YXQgOiB7IHZhbHVlOiBpc05hTigrc3RhdCkgPyBzdGF0IDogK3N0YXR9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBzdGF0aXN0aWNhbCBkYXRhLCBhbHJlYWR5IGluZGV4ZWQgYnkgbnV0c0lkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFNvbWV0aGluZyBsaWtlOiB7IFwiUFRcIjowLjIsIFwiTFVcIjowLjYsIC4uLn0sIG9yIHdpdGggc3RhdHVzOiB7IFwiUFRcIjoge3ZhbHVlOjAuMiwgc3RhdHVzOlwiZVwifSwgXCJMVVwiOjAuNiwgLi4ufVxyXG4gICAgICovXHJcbiAgICBvdXQuc2V0RGF0YSA9IChkYXRhKSA9PiB7XHJcbiAgICAgICAgb3V0Ll9fZGF0YSA9IGRhdGEgLy8gZm9yIGRlYnVnZ2luZ1xyXG4gICAgICAgIG91dC5fZGF0YV8gPSB7fSAvLyBvdmVyd3JpdGUgZXhpc3RpbmcgZGF0YVxyXG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goKG51dHNJZCkgPT4gb3V0LnNldChudXRzSWQsIGRhdGFbbnV0c0lkXSkpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vZWcgZm9yIHNwYXJrbGluZXNcclxuICAgIG91dC5zZXRNYW51YWxNdWx0aURhdGUgPSBmdW5jdGlvbiAoZGF0YU9iamVjdCkge1xyXG4gICAgICAgIG91dC5fZGF0YV8gPSBvdXQuX2RhdGFfIHx8IHt9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgcmVnaW9uSWQgaW4gZGF0YU9iamVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRlVmFsdWVNYXAgPSBkYXRhT2JqZWN0W3JlZ2lvbklkXVxyXG4gICAgICAgICAgICBvdXQuX2RhdGFfW3JlZ2lvbklkXSA9IHt9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGUgaW4gZGF0ZVZhbHVlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGVWYWx1ZU1hcFtkYXRlXVxyXG4gICAgICAgICAgICAgICAgb3V0Ll9kYXRhX1tyZWdpb25JZF1bZGF0ZV0gPSB7IHZhbHVlOiB2YWx1ZSB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmV0dXJuIGFsbCBzdGF0IHZhbHVlcyBhcyBhbiBhcnJheS4gVGhpcyBjYW4gYmUgdXNlZCB0byBjbGFzc2lmeSB0aGUgdmFsdWVzLiAqL1xyXG4gICAgb3V0LmdldEFycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdXQuX2RhdGFfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dC5fZGF0YV8pXHJcbiAgICAgICAgICAgICAgICAubWFwKChzKSA9PiBzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocykgPT4gcyA9PSAwIHx8IHMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm4gc3RhdCB1bmlxdWUgdmFsdWVzLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBjYXRlZ29yaWNhbCBtYXBzLiAqL1xyXG4gICAgb3V0LmdldFVuaXF1ZVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhvdXQuX2RhdGFfKVxyXG4gICAgICAgICAgICAubWFwKChzKSA9PiBzLnZhbHVlKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChpdGVtLCBpLCBhcikgPT4gYXIuaW5kZXhPZihpdGVtKSA9PT0gaSlcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IG1pbiB2YWx1ZS4gKi9cclxuICAgIG91dC5nZXRNaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG91dC5fZGF0YV8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0Ll9kYXRhXylcclxuICAgICAgICAgICAgICAgIC5tYXAoKHMpID0+IHMudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzID09IDAgfHwgKHMgJiYgcyAhPT0gJzonKSlcclxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdikgPT4gTWF0aC5taW4oYWNjLCB2KSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogR2V0IG1heCB2YWx1ZS4gKi9cclxuICAgIG91dC5nZXRNYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG91dC5fZGF0YV8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0Ll9kYXRhXylcclxuICAgICAgICAgICAgICAgIC5tYXAoKHMpID0+IHMudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzID09IDAgfHwgKHMgJiYgcyAhPT0gJzonKSlcclxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdikgPT4gTWF0aC5tYXgoYWNjLCB2KSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENoZWNrIGlmIHRoZSBzdGF0IGRhdGEgaXMgcmVhZHkuICovXHJcbiAgICBvdXQuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gb3V0Ll9kYXRhXyAhPSB1bmRlZmluZWRcclxuICAgIH1cclxuXHJcbiAgICAvKiogU29tZSBtZXRhZGF0YSAqL1xyXG4gICAgb3V0Lm1ldGFkYXRhID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9hIHRleHQgZm9yIHRoZSBzdGF0aXRpY3MgdW5pdCBvZiBtZWFzdXJlLCB0byBiZSBzaG93biBpbiB0aGUgdG9vbHRpcFxyXG4gICAgb3V0LnVuaXRUZXh0XyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgc3RhdCBkYXRhIGZyb20gcmVtb3RlIGRhdGEgc291cmNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG51dHNMZXZlbFxyXG4gICAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvdXQucmV0cmlldmVGcm9tUmVtb3RlID0gZnVuY3Rpb24gKG51dHNMZXZlbCwgbGFuZywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAob3V0LmV1cm9zdGF0RGF0YXNldENvZGVfKSB1cGRhdGVFdXJvYmFzZShudXRzTGV2ZWwsIGxhbmcsIGNhbGxiYWNrKVxyXG4gICAgICAgIGVsc2UgaWYgKG91dC5jc3ZVUkxfKSB1cGRhdGVDU1YoY2FsbGJhY2spXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETyBkZWNvbXBvc2UgaW50byBFdXJvYmFzZS9qc29uc3RhdCBhbmQgQ1NWIHR5cGVzID9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV1cm9iYXNlL2pzb25zdGF0IGRhdGEgc291cmNlXHJcbiAgICAgKiBTZWUgaHR0cHM6Ly9lYy5ldXJvcGEuZXUvZXVyb3N0YXQvd2ViL2pzb24tYW5kLXVuaWNvZGUtd2ViLXNlcnZpY2VzL2dldHRpbmctc3RhcnRlZC9yZXN0LXJlcXVlc3RcclxuICAgICAqL1xyXG5cclxuICAgIC8qKiBUaGUgRXVyb2Jhc2UgZGF0YXNldCBjb2RlICovXHJcbiAgICBvdXQuZXVyb3N0YXREYXRhc2V0Q29kZV8gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUaGUgRXVyb2Jhc2UgY29kZSAqL1xyXG4gICAgb3V0LmZpbHRlcnNfID0geyBsYXN0VGltZVBlcmlvZDogMSB9XHJcbiAgICAvKiogVGhlIHByZWNpc2lvbiAobnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzKSAqL1xyXG4gICAgb3V0LnByZWNpc2lvbl8gPSAyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gcHJvbWlzZSBmb3IgRXVyb2Jhc2UvanNvbnN0YXQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0RXVyb2Jhc2VQcm9taXNlID0gZnVuY3Rpb24gKG51dHNMZXZlbCwgbGFuZykge1xyXG4gICAgICAgIC8vc2V0IHByZWNpc2lvbiAvL0RFUFJFQ0FURUQgMTYvMTEvMjAyMSBodHRwczovL2VjLmV1cm9wYS5ldS9ldXJvc3RhdC9vbmxpbmUtaGVscC9wdWJsaWMvZW4vTkFWSUdBVElPTl9XRERTVHJhbnNsYXRvcl9taWdyYXRpb25fZW4vI0RFQ09NTUlTU0lPTlxyXG4gICAgICAgIC8vb3V0LmZpbHRlcnNfW1wicHJlY2lzaW9uXCJdID0gb3V0LnByZWNpc2lvbl87XHJcbiAgICAgICAgLy9zZWxlY3Qgb25seSByZXF1aXJlZCBnZW8gZ3JvdXBzLCBkZXBlbmRpbmcgb24gdGhlIHNwZWNpZmllZCBudXRzIGxldmVsXHJcbiAgICAgICAgaWYgKCFvdXQuZmlsdGVyc18uZ2VvKSB7XHJcbiAgICAgICAgICAgIG91dC5maWx0ZXJzX1snZ2VvTGV2ZWwnXSA9IG51dHNMZXZlbCArICcnID09PSAnMCcgPyAnY291bnRyeScgOiAnbnV0cycgKyBudXRzTGV2ZWxcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZm9yY2UgZmlsdGVyaW5nIG9mIGV1cm8tZ2VvLWFnZ3JlZ2F0ZXNcclxuICAgICAgICAvL291dC5maWx0ZXJzX1tcImZpbHRlck5vbkdlb1wiXSA9IDE7IC8vREVQUkVDQVRFRCAxNi8xMS8yMDIxXHJcblxyXG4gICAgICAgIC8vcmV0cmlldmUgc3RhdCBkYXRhIGZyb20gRXVyb3N0YXQgQVBJXHJcbiAgICAgICAgcmV0dXJuIGpzb24oZ2V0RXN0YXREYXRhVVJMKG91dC5ldXJvc3RhdERhdGFzZXRDb2RlXywgb3V0LmZpbHRlcnNfLCBsYW5nKSlcclxuICAgIH1cclxuXHJcbiAgICAvL2ZvciBldXJvYmFzZSBzdGF0aXN0aWNhbCBkYXRhIHRvIHJldHJpZXZlIGZyb20gRXVyb3N0YXQgQVBJXHJcbiAgICBjb25zdCB1cGRhdGVFdXJvYmFzZSA9IGZ1bmN0aW9uIChudXRzTGV2ZWwsIGxhbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy9lcmFzZSBwcmV2aW91cyBkYXRhXHJcbiAgICAgICAgb3V0Ll9kYXRhXyA9IG51bGxcclxuXHJcbiAgICAgICAgZ2V0RXVyb2Jhc2VQcm9taXNlKG51dHNMZXZlbCwgbGFuZykudGhlbihmdW5jdGlvbiAoZGF0YV9fXykge1xyXG4gICAgICAgICAgICAvL2RlY29kZSBzdGF0IGRhdGFcclxuICAgICAgICAgICAgY29uc3QganNkID0gSlNPTnN0YXQoZGF0YV9fXylcclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUganNvbnN0YXQgbWV0YWRhdGFcclxuICAgICAgICAgICAgb3V0Lm1ldGFkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGpzZC5sYWJlbCxcclxuICAgICAgICAgICAgICAgIGhyZWY6IGpzZC5ocmVmLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBqc2Quc291cmNlLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDoganNkLnVwZGF0ZWQsXHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb246IGpzZC5leHRlbnNpb24sXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0Lm1ldGFkYXRhLnRpbWUgPSBqc2QuRGltZW5zaW9uKCd0aW1lJykuaWRbMF1cclxuXHJcbiAgICAgICAgICAgIC8vaW5kZXhcclxuICAgICAgICAgICAgb3V0Ll9kYXRhXyA9IGpzb25zdGF0VG9JbmRleChqc2QpXHJcbiAgICAgICAgICAgIC8vVE9ETzogdXNlIG1heWJlIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWRvc2EvSlNPTi1zdGF0L2Jsb2IvbWFzdGVyL3V0aWxzL2Zyb210YWJsZS5tZCB0byBidWlsZCBkaXJlY3RseSBhbiBpbmRleCA/XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB0aW1lIHN0YW1wIG9mIHRoZSBqc29uc3RhdCBkYXRhc2V0LlxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCB0ID0gb3V0LmZpbHRlcnNfLnRpbWVcclxuICAgICAgICBpZiAodCkgcmV0dXJuIHRcclxuICAgICAgICBpZiAoIW91dC5fZGF0YV8pIHJldHVyblxyXG4gICAgICAgIHJldHVybiBvdXQubWV0YWRhdGEudGltZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ1NWIGRhdGEgc291cmNlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKiogVGhlIENTViBmaWxlIFVSTCAqL1xyXG4gICAgb3V0LmNzdlVSTF8gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUaGUgQ1NWIGNvbHVtbiB3aXRoIHRoZSBOVVRTIGlkcyAqL1xyXG4gICAgb3V0Lmdlb0NvbF8gPSAnZ2VvJ1xyXG4gICAgLyoqIFRoZSBDU1YgY29sdW1uIHdpdGggdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyAqL1xyXG4gICAgb3V0LnZhbHVlQ29sXyA9ICd2YWx1ZSdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBwcm9taXNlIGZvciBDU1YgZGF0YS5cclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0Q1NWUHJvbWlzZSA9IGZ1bmN0aW9uIChudXRzTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gY3N2KG91dC5jc3ZVUkxfKVxyXG4gICAgfVxyXG5cclxuICAgIC8vZm9yIHN0YXRpc3RpY2FsIGRhdGEgdG8gcmV0cmlldmUgZnJvbSBDU1YgZmlsZVxyXG4gICAgY29uc3QgdXBkYXRlQ1NWID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy9lcmFzZSBwcmV2aW91cyBkYXRhXHJcbiAgICAgICAgb3V0Ll9kYXRhXyA9IG51bGxcclxuXHJcbiAgICAgICAgLy9yZXRyaWV2ZSBjc3YgZGF0YVxyXG4gICAgICAgIGdldENTVlByb21pc2UoKS50aGVuKGZ1bmN0aW9uIChkYXRhX19fKSB7XHJcbiAgICAgICAgICAgIC8vZGVjb2RlIHN0YXQgZGF0YVxyXG4gICAgICAgICAgICBvdXQuX2RhdGFfID0gY3N2VG9JbmRleChkYXRhX19fLCBvdXQuZ2VvQ29sXywgb3V0LnZhbHVlQ29sXylcclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUgc29tZSBtZXRhZGF0YVxyXG4gICAgICAgICAgICBvdXQubWV0YWRhdGEgPSB7IGhyZWY6IG91dC5jc3ZVUkxfIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1sndW5pdFRleHRfJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKSBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBvdXRba2V5ICsgJ18nXSA9IGNvbmZpZ1trZXldXHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IGFwcGx5SW5saW5lU3R5bGVzRnJvbUNTUywgZmxhZ3MsIHNlcmlhbGl6ZSwgcmFzdGVyaXplLCBnZXREb3dubG9hZFVSTCB9IGZyb20gJy4vdXRpbHMnXHJcbmltcG9ydCAqIGFzIE1hcFRlbXBsYXRlIGZyb20gJy4vbWFwLXRlbXBsYXRlJ1xyXG5pbXBvcnQgKiBhcyBTdGF0aXN0aWNhbERhdGEgZnJvbSAnLi9zdGF0LWRhdGEnXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kJ1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIHRwIGZyb20gJy4uL3Rvb2x0aXAvdG9vbHRpcCdcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBzdGF0aXN0aWNhbCBtYXA6IEEgbWFwIHRlbXBsYXRlIHdpdGggc3RhdGlzdGljYWwgZGF0YSwgd2l0aG91dCBhbnkgcGFydGljdWxhciBzdHlsaW5nIHJ1bGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gd2l0aENlbnRlclBvaW50cyBTZXQgdG8gdHJ1ZSAob3IgMSkgdG8gYWRkIHJlZ2lvbnMgY2VudGVyIHBvaW50cyB0byB0aGUgbWFwIHRlbXBsYXRlLCB0byBiZSB1c2VkIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9scyBtYXBzIGZvciBleGFtcGxlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0YXRNYXAgPSBmdW5jdGlvbiAoY29uZmlnLCB3aXRoQ2VudGVyUG9pbnRzLCBtYXBUeXBlKSB7XHJcbiAgICAvL2J1aWxkIHN0YXQgbWFwIGZyb20gbWFwIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBNYXBUZW1wbGF0ZS5tYXBUZW1wbGF0ZShjb25maWcsIHdpdGhDZW50ZXJQb2ludHMsIG1hcFR5cGUpXHJcblxyXG4gICAgLy9zdGF0aXN0aWNhbCBkYXRhXHJcblxyXG4gICAgLy90aGUgc3RhdGlzdGljYWwgZGF0YSBjb25maWd1cmF0aW9uLlxyXG4gICAgLy9BIG1hcCBjYW4gaGF2ZSBzZXZlcmFsIHN0YXQgZGF0YXNldHMuIFRoaXMgaXMgYSBkaWN0aW9uYXJ5IG9mIGFsbCBzdGF0IGNvbmZpZ3VyYXRpb25cclxuICAgIG91dC5zdGF0XyA9IHsgZGVmYXVsdDogdW5kZWZpbmVkIH1cclxuICAgIG91dC5zdGF0ID0gZnVuY3Rpb24gKGssIHYpIHtcclxuICAgICAgICAvL25vIGFyZ3VtZW50OiBnZXR0ZXIgLSByZXR1cm4gdGhlIGRlZmF1bHQgc3RhdFxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5zdGF0X1snZGVmYXVsdCddXHJcbiAgICAgICAgLy90d28gYXJndW1lbnRzOiBzZXR0ZXIgLSBzZXQgdGhlIGNvbmZpZyBrIHdpdGggdmFsdWUgdlxyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgb3V0LnN0YXRfW2tdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vb25lIHN0cmluZyBhcmd1bWVudDogZ2V0dGVyIC0gcmV0dXJuIHRoZSBjb25maWcga1xyXG4gICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ3N0cmluZycgfHwgayBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIG91dC5zdGF0X1trXVxyXG4gICAgICAgIC8vb25lIG5vbi1zdHJpbmcgYXJndW1lbnQ6IHNldHRlciAtIHNldCB0aGUgZW50aXJlIGRpY3Rpb25uYXJ5XHJcbiAgICAgICAgb3V0LnN0YXRfID0gay5kZWZhdWx0ID8gayA6IHsgZGVmYXVsdDogayB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vdGhlIHN0YXRpc3RpY2FsIGRhdGEsIHJldHJpZXZlZCBmcm9tIHRoZSBjb25maWcgaW5mb3JtYXRpb24uIEFzIGEgZGljdGlvbmFyeS5cclxuICAgIG91dC5zdGF0RGF0YV8gPSB7XHJcbiAgICAgICAgZGVmYXVsdDogU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKCksXHJcbiAgICAgICAgY29sb3I6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLFxyXG4gICAgICAgIHNpemU6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLFxyXG4gICAgICAgIHYxOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSxcclxuICAgICAgICB2MjogU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKCksIC8vYml2YXJpYXRlXHJcbiAgICAgICAgdjM6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLCAvL3RyaXZhcmlhdGVcclxuICAgIH1cclxuICAgIG91dC5zdGF0RGF0YSA9IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnN0YXREYXRhX1snZGVmYXVsdCddXHJcblxyXG4gICAgICAgIC8vIGxhenkgY3JlYXRlIGlmIG5vdCBleGlzdFxyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmICghb3V0LnN0YXREYXRhX1trXSkgb3V0LnN0YXREYXRhX1trXSA9IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpXHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuc3RhdERhdGFfW2tdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzZXR0ZXJcclxuICAgICAgICBvdXQuc3RhdERhdGFfW2tdID0gdlxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL3Rlc3QgZm9yIG5vIGRhdGEgY2FzZVxyXG4gICAgb3V0Lm5vRGF0YVRleHRfID0gJ05vIGRhdGEgYXZhaWxhYmxlJ1xyXG4gICAgLy9sYW5nYWdlIChjdXJyZW50bHkgdXNlZCBvbmx5IGZvciBldXJvc3RhdCBkYXRhIEFQSSlcclxuICAgIG91dC5sYW5ndWFnZV8gPSAnZW4nXHJcbiAgICAvL3RyYW5zaXRpb24gdGltZSBmb3IgcmVuZGVyaW5nXHJcbiAgICBvdXQudHJhbnNpdGlvbkR1cmF0aW9uXyA9IDUwMFxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSB1bmRlZmluZWRcclxuICAgIC8vZm9yIG1hcHMgdXNpbmcgc3BlY2lhbCBmaWxsIHBhdHRlcm5zLCB0aGlzIGlzIHRoZSBmdW5jdGlvbiB0byBkZWZpbmUgdGhlbSBpbiB0aGUgU1ZHIGltYWdlIC0gU2VlIGZ1bmN0aW9uczogZ2V0RmlsbFBhdHRlcm5MZWdlbmQgYW5kIGdldEZpbGxQYXR0ZXJuRGVmaW5pdGlvbkZ1blxyXG4gICAgb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fID0gdW5kZWZpbmVkXHJcbiAgICAvL2EgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgbWFwIGJ1aWxkIGlzIGNvbXBsZXRlLlxyXG4gICAgb3V0LmNhbGxiYWNrXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vbGVnZW5kIGNvbmZpZ3VyYXRpb25cclxuICAgIG91dC5sZWdlbmRfID0gdW5kZWZpbmVkXHJcbiAgICAvL2xlZ2VuZCBvYmplY3RcclxuICAgIG91dC5sZWdlbmRPYmpfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1snbGVnZW5kXycsICdsZWdlbmRPYmpfJywgJ25vRGF0YVRleHRfJywgJ2xhbmd1YWdlXycsICd0cmFuc2l0aW9uRHVyYXRpb25fJywgJ3Rvb2x0aXBUZXh0XycsICdmaWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXycsICdjYWxsYmFja18nXS5mb3JFYWNoKFxyXG4gICAgICAgIGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICApXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgaWYgKG91dFtrZXldICYmIGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcblxyXG4gICAgLy8gb3ZlcnJpZGUgbGVnZW5kIGZvciB1cGRhdGluZyBhZnRlciBidWlsZFxyXG4gICAgb3V0LmxlZ2VuZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmxlZ2VuZF9cclxuXHJcbiAgICAgICAgLy8gY2xlYXIgZXhpc3RpbmcgbGVnZW5kXHJcbiAgICAgICAgaWYgKHYgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kID0gb3V0LmxlZ2VuZE9iaigpXHJcbiAgICAgICAgICAgIGlmIChsZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZ2VuZFN2ZyA9IHNlbGVjdCgnIycgKyBsZWdlbmQuc3ZnSWQpXHJcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kU3ZnLnNpemUoKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdlbmRTdmcuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQubGVnZW5kXyA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgICAgICAvL3NldCBuZXcgbGVnZW5kIGNvbmZpZ1xyXG4gICAgICAgIG91dC5sZWdlbmRfID0gdlxyXG4gICAgICAgIC8vdXBkYXRlIGlmIGV4aXN0aW5nIGxlZ2VuZFxyXG4gICAgICAgIGlmIChvdXQubGVnZW5kT2JqXykgb3V0LnVwZGF0ZUxlZ2VuZCgpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIG91dC51cGRhdGVMZWdlbmQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmIChvdXQubGVnZW5kT2JqXykgb3V0LmxlZ2VuZE9iaigpLnVwZGF0ZSgpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgdGhlIG1hcC5cclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgb25jZSwgcHJlZmVyYWJseSBhZnRlciB0aGUgbWFwIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHNldCB0byBzb21lIGluaXRpYWwgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBvdXQuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG91dC5wcm9qZWN0aW9uRnVuY3Rpb25fKSBvdXQucHJvaignNDMyNicpIC8vd2hlbiB1c2luZyBjdXN0b20gZDMgcHJvamVjdGlvbiBmdW5jdGlvbiBhbHdheXMgcmVxdWVzdCBOVVRTMkpTT04gaW4gV0dTODRcclxuXHJcbiAgICAgICAgLy9idWlsZCBtYXAgdGVtcGxhdGUgYmFzZVxyXG4gICAgICAgIG91dC5idWlsZE1hcFRlbXBsYXRlQmFzZSgpXHJcblxyXG4gICAgICAgIC8vYWRkIGFkZGl0aW9uYWwgZmlsdGVycyBmb3IgZmlsbCBwYXR0ZXJucyBmb3IgZXhhbXBsZVxyXG4gICAgICAgIGlmIChvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8pIHtcclxuICAgICAgICAgICAgb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fKG91dC5zdmcoKSwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xlZ2VuZCBlbGVtZW50XHJcbiAgICAgICAgaWYgKG91dC5sZWdlbmQoKSkge1xyXG4gICAgICAgICAgICBvdXQuYnVpbGRMZWdlbmQoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kZWZpbmUgdG9vbHRpcFxyXG4gICAgICAgIC8vcHJlcGFyZSBtYXAgdG9vbHRpcFxyXG4gICAgICAgIGlmIChvdXQudG9vbHRpcF8pIHtcclxuICAgICAgICAgICAgb3V0Ll90b29sdGlwID0gdHAudG9vbHRpcChvdXQudG9vbHRpcF8pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9ubyBjb25maWcgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxyXG4gICAgICAgICAgICBvdXQuX3Rvb2x0aXAgPSB0cC50b29sdGlwKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbGF1bmNoIGdlbyBkYXRhIHJldHJpZXZhbFxyXG4gICAgICAgIG91dC51cGRhdGVHZW9EYXRhKClcclxuXHJcbiAgICAgICAgLy9sYXVuY2ggc3RhdCBkYXRhIHJldHJpZXZhbFxyXG4gICAgICAgIG91dC51cGRhdGVTdGF0RGF0YSgpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBvdXQuYnVpbGRMZWdlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9jcmVhdGUgbGVnZW5kIG9iamVjdFxyXG4gICAgICAgIG91dC5sZWdlbmRPYmoob3V0LmdldExlZ2VuZENvbnN0cnVjdG9yKCkob3V0LCBvdXQubGVnZW5kKCkpKVxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IG91dC5sZWdlbmRPYmooKVxyXG5cclxuICAgICAgICAvL2dldCBsZWdlbmQgc3ZnLiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGl0IGVtYmVkZWQgd2l0aGluIHRoZSBtYXBcclxuICAgICAgICBsZXQgbGVnZW5kU3ZnID0gc2VsZWN0KCcjJyArIGxlZ2VuZC5zdmdJZClcclxuICAgICAgICBpZiAobGVnZW5kU3ZnLnNpemUoKSA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGxlZ2VuZCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjb25zdCB4ID0gbGVnZW5kLnggPT0gdW5kZWZpbmVkID8gb3V0LndpZHRoKCkgLSAxMDAgLSBsZWdlbmQuYm94UGFkZGluZyA6IGxlZ2VuZC54XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBsZWdlbmQueSA9PSB1bmRlZmluZWQgPyBsZWdlbmQuYm94UGFkZGluZyA6IGxlZ2VuZC55XHJcblxyXG4gICAgICAgICAgICAvL2J1aWxkIGxlZ2VuZCBTVkcgaW4gYSBuZXcgZ3JvdXBcclxuICAgICAgICAgICAgb3V0LnN2ZygpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIGxlZ2VuZC5zdmdJZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB5ICsgJyknKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGVnZW5kLmJ1aWxkKClcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hlY2sgaWYgYWxsIHN0YXQgZGF0YXNldHMgaGF2ZSBiZWVuIGxvYWRlZC4gKi9cclxuICAgIGNvbnN0IGlzU3RhdERhdGFSZWFkeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvdXQuc3RhdERhdGFfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc0NvbmZpZyA9ICEhb3V0LnN0YXRfW2tleV1cclxuICAgICAgICAgICAgY29uc3QgaGFzTWFudWFsRGF0YSA9ICEhKG91dC5zdGF0RGF0YV9ba2V5XSAmJiBvdXQuc3RhdERhdGFfW2tleV0uZ2V0KCkpXHJcblxyXG4gICAgICAgICAgICBpZiAoIWhhc0NvbmZpZyAmJiAhaGFzTWFudWFsRGF0YSkgY29udGludWVcclxuICAgICAgICAgICAgaWYgKCFvdXQuc3RhdERhdGFfW2tleV0uaXNSZWFkeSgpKSByZXR1cm4gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExhdW5jaCBtYXAgZ2VvIGRhdGEgcmV0cmlldmFsLCBhbmQgbWFrZS91cGRhdGUgdGhlIG1hcCBvbmNlIHJlY2VpdmVkLlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhdHRyaWJ1dGVzIHJlbGF0ZWQgdG8gdGhlIG1hcCBnZW9tZXRyaWVzIGhhdmUgY2hhbmdlZCwgdG8gcmV0cmlldmUgdGhpcyBuZXcgZGF0YSBhbmQgcmVmcmVzaCB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlR2VvRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlR2VvTWFwVGVtcGxhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAvL2lmIHN0YXQgZGF0YXNldHMgaGF2ZSBub3QgYmVlbiBsb2FkZWQsIHdhaXQgYWdhaW5cclxuICAgICAgICAgICAgaWYgKCFpc1N0YXREYXRhUmVhZHkoKSkgcmV0dXJuXHJcblxyXG4gICAgICAgICAgICAvL3Byb2NlZWQgd2l0aCBtYXAgY29uc3RydWN0aW9uXHJcbiAgICAgICAgICAgIG91dC51cGRhdGVTdGF0VmFsdWVzKClcclxuICAgICAgICAgICAgLy9leGVjdXRlIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGlmIChvdXQuY2FsbGJhY2soKSkgb3V0LmNhbGxiYWNrKCkob3V0KVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExhdW5jaCBtYXAgZ2VvIHN0YXQgZGF0YXNldHMgcmV0cmlldmFsLCBhbmQgbWFrZS91cGRhdGUgdGhlIG1hcCBvbmNlIHJlY2VpdmVkLlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBzcGVjaWZpY2F0aW9ucyBvbiB0aGUgc3RhdCBkYXRhIHNvdXJjZXMgYXR0YWNoZWQgdG8gdGhlIG1hcCBoYXZlIGNoYW5nZWQsIHRvIHJldHJpZXZlIHRoaXMgbmV3IGRhdGEgYW5kIHJlZnJlc2ggdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZVN0YXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAobGV0IHN0YXRLZXkgaW4gb3V0LnN0YXRfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IG91dC5zdGF0KHN0YXRLZXkpXHJcbiAgICAgICAgICAgIGNvbnN0IG1hbnVhbERhdGEgPSBvdXQuc3RhdERhdGEoc3RhdEtleSkuZ2V0Py4oKVxyXG5cclxuICAgICAgICAgICAgLy8gU2tpcCBpZiBuZWl0aGVyIHN0YXQgY29uZmlnIG5vciBtYW51YWwgZGF0YVxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZyAmJiAhbWFudWFsRGF0YSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb25maWcsIGJ1aWxkIHRoZSBzdGF0RGF0YSBvYmplY3QgKG9yIHJlcGxhY2UgZXhpc3RpbmcpXHJcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXREYXRhID0gU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKGNvbmZpZylcclxuICAgICAgICAgICAgICAgIG91dC5zdGF0RGF0YShzdGF0S2V5LCBzdGF0RGF0YSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMYXVuY2ggcmVtb3RlIHJldHJpZXZhbFxyXG4gICAgICAgICAgICAgICAgbGV0IG5sID0gb3V0Lm51dHNMZXZlbF9cclxuICAgICAgICAgICAgICAgIGlmIChubCA9PT0gJ21peGVkJykgbmwgPSAwXHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdERhdGEucmV0cmlldmVGcm9tUmVtb3RlKG5sLCBvdXQubGFuZ3VhZ2UoKSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3V0Lkdlb21ldHJpZXMuaXNHZW9SZWFkeSgpKSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdERhdGFSZWFkeSgpKSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnVwZGF0ZVN0YXRWYWx1ZXMoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuY2FsbGJhY2soKSkgb3V0LmNhbGxiYWNrKCkob3V0KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZS91cGRhdGUgdGhlIG1hcCB3aXRoIG5ldyBzdGF0IGRhdGEuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHN0YXQgZGF0YSBhdHRhY2hlZCB0byB0aGUgbWFwIGhhdmUgY2hhbmdlZCwgdG8gcmVmcmVzaCB0aGUgbWFwLlxyXG4gICAgICogSWYgdGhlIHN0YXQgZGF0YSBzb3VyY2VzIGhhdmUgY2hhbmdlZCwgY2FsbCAqdXBkYXRlU3RhdERhdGEqIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGVTdGF0VmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vdXBkYXRlIGNsYXNzaWZpY2F0aW9uIGFuZCBzdHlsZXNcclxuICAgICAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24oKVxyXG4gICAgICAgIG91dC51cGRhdGVTdHlsZSgpXHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZCwgaWYgYW55XHJcbiAgICAgICAgaWYgKG91dC5sZWdlbmRfICYmIG91dC5sZWdlbmRPYmooKSkgb3V0LmxlZ2VuZE9iaigpLnVwZGF0ZSgpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IG1ldGhvZC5cclxuICAgICAqIE1ha2UvdXBkYXRlIHRoZSBtYXAgYWZ0ZXIgY2xhc3NpZmljYXRpb24gYXR0cmlidXRlcyBoYXZlIGJlZW4gY2hhbmdlZC5cclxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGUgbnVtYmVyIG9mIGNsYXNzZXMsIG9yIHRoZSBjbGFzc2lmaWNhdGlvbiBtZXRob2QgaGFzIGNoYW5nZWQsIGNhbGwgdGhpcyBtZXRob2QgdG8gdXBkYXRlIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTWFwIHVwZGF0ZUNsYXNzaWZpY2F0aW9uIGZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZCcpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgbWV0aG9kLlxyXG4gICAgICogTWFrZS91cGRhdGUgdGhlIG1hcCBhZnRlciBzdHlsaW5nIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGNoYW5nZWQuXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHN0eWxlIChjb2xvcj8pIGZvciBvbmUgbGVnZW5kIGVsZW1lbnQgaGFzIGNoYW5nZWQsIGNhbGwgdGhpcyBtZXRob2QgdG8gdXBkYXRlIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTWFwIHVwZGF0ZVN0eWxlIGZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZCcpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgbWV0aG9kLlxyXG4gICAgICogRnVuY3Rpb24gd2hpY2ggcmV0dXJuIHRoZSBsZWdlbmQgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTWFwIGdldExlZ2VuZENvbnN0cnVjdG9yIGZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZCcpXHJcbiAgICAgICAgcmV0dXJuIExlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSB0aW1lIHN0YW1wIG9mIHRoZSBtYXAsIGV2ZW4gaWYgbm90IHNwZWNpZmllZCBpbiB0aGUgZGltZW5zaW9uIGluaXRpYWxseS5cclxuICAgICAqIFRoaXMgYXBwbGllcyBvbmx5IGZvciBzdGF0IGRhdGEgcmV0cmlldmVkIGZyb20gRXVyb3N0YXQgQVBJLlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBleGFtcGxlIHdoZW4gdGhlIGRhdGEgcmV0cmlldmVkIGlzIHRoZSBmcmVzaGVzdCwgYW5kIG9uZSB3YW50cyB0byBrbm93IHdoYXQgdGhpcyBkYXRlIGlzLCBmb3IgZXhhbXBsZSB0byBkaXNwbGF5IGl0IGluIHRoZSBtYXAgdGl0bGUuXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBvdXQuc3RhdERhdGEoJ2RlZmF1bHQnKS5nZXRUaW1lKClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBzb21lIG1hcCBhdHRyaWJ1dGVzIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgVVJMIHBhcmFtZXRlcnM6XHJcbiAgICAgKiBcIndcIjp3aWR0aCwgXCJoXCI6aGVpZ2h0LCBcInhcIjp4R2VvQ2VudGVyLCBcInlcIjp5R2VvQ2VudGVyLCBcInpcIjpwaXhHZW9TaXplLCBcInNcIjpzY2FsZSwgXCJsdmxcIjpudXRzIGxldmVsLCBcInRpbWVcIjp0aW1lLFxyXG4gICAgICogXCJwcm9qXCI6Q1JTLCBcImdlb1wiOmdlbyB0ZXJyaXRvcnksIFwibnlcIjpudXRzIHZlcnNpb24sIFwibGFuZ3VhZ2VcIjpsYW5nYWdlLCBcIm51bWJlck9mQ2xhc3Nlc1wiOmNsYXNzIG51bWJlclxyXG4gICAgICovXHJcbiAgICBvdXQuc2V0RnJvbVVSTCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBvcHRzID0gZ2V0VVJMUGFyYW1ldGVycygpXHJcbiAgICAgICAgaWYgKG9wdHMudykgb3V0LndpZHRoKG9wdHMudylcclxuICAgICAgICBpZiAob3B0cy5oKSBvdXQuaGVpZ2h0KG9wdHMuaClcclxuICAgICAgICBpZiAob3B0cy54ICYmIG9wdHMueSkgb3V0Lmdlb0NlbnRlcihbb3B0cy54LCBvcHRzLnldKVxyXG4gICAgICAgIGlmIChvcHRzLnopIG91dC5waXhlbFNpemUob3B0cy56KVxyXG4gICAgICAgIGlmIChvcHRzLnMpIG91dC5zY2FsZShvcHRzLnMpXHJcbiAgICAgICAgaWYgKG9wdHMubHZsKSBvdXQubnV0c0xldmVsKG9wdHMubHZsKVxyXG4gICAgICAgIGlmIChvcHRzLnRpbWUpIHtcclxuICAgICAgICAgICAgb3V0LmZpbHRlcnNfLnRpbWUgPSBvcHRzLnRpbWVcclxuICAgICAgICAgICAgZGVsZXRlIG91dC5maWx0ZXJzXy5sYXN0VGltZVBlcmlvZFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0cy5wcm9qKSBvdXQucHJvaihvcHRzLnByb2opXHJcbiAgICAgICAgaWYgKG9wdHMuZ2VvKSBvdXQuZ2VvKG9wdHMuZ2VvKVxyXG4gICAgICAgIGlmIChvcHRzLm55KSBvdXQubnV0c1llYXIob3B0cy5ueSlcclxuICAgICAgICBpZiAob3B0cy5sYW5ndWFnZSkgb3V0Lmxhbmd1YWdlKG9wdHMubGFuZ3VhZ2UpXHJcbiAgICAgICAgaWYgKG9wdHMubnVtYmVyT2ZDbGFzc2VzKSBvdXQubnVtYmVyT2ZDbGFzc2VzKCtvcHRzLm51bWJlck9mQ2xhc3NlcylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gZXhwb3J0TWFwVG9TVkdcclxuICAgICAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRoZSBjdXJyZW50IG1hcCB3aXRoIHN0eWxpbmcgdG8gU1ZHIGFuZCBkb3dubG9hZHMgaXRcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIG91dC5leHBvcnRNYXBUb1NWRyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDbG9uZSB0aGUgb3JpZ2luYWwgU1ZHIG5vZGUgdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZSBET01cclxuICAgICAgICBjb25zdCBzdmdOb2RlQ2xvbmUgPSBvdXQuc3ZnXy5ub2RlKCkuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgICAgLy8gQWRkIFhNTCBuYW1lc3BhY2VzIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcclxuICAgICAgICBpZiAoIXN2Z05vZGVDbG9uZS5oYXNBdHRyaWJ1dGUoJ3htbG5zJykpIHtcclxuICAgICAgICAgICAgc3ZnTm9kZUNsb25lLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN2Z05vZGVDbG9uZS5oYXNBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJykpIHtcclxuICAgICAgICAgICAgc3ZnTm9kZUNsb25lLnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUZW1wb3JhcmlseSBhcHBlbmQgdGhlIGNsb25lIHRvIHRoZSBkb2N1bWVudCB0byBjb21wdXRlIHN0eWxlc1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnTm9kZUNsb25lKVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IENTUyB0byBpbmxpbmUgc3R5bGVzIGJlZm9yZSBzYXZpbmcgdGhlIFNWR1xyXG4gICAgICAgIGFwcGx5SW5saW5lU3R5bGVzRnJvbUNTUyhzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY2xvbmVkIFNWRyBmcm9tIHRoZSBkb2N1bWVudCBhZnRlciBhcHBseWluZyBzdHlsZXNcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHN2Z05vZGVDbG9uZSlcclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnVXJsID0gZ2V0RG93bmxvYWRVUkwoc3ZnTm9kZUNsb25lKVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBkb3dubG9hZCBsaW5rIGFuZCB0cmlnZ2VyIGRvd25sb2FkXHJcbiAgICAgICAgY29uc3QgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXHJcbiAgICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSBzdmdVcmxcclxuICAgICAgICBkb3dubG9hZExpbmsuZG93bmxvYWQgPSAnZXVyb3N0YXRtYXAuc3ZnJ1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKVxyXG4gICAgICAgIGRvd25sb2FkTGluay5jbGljaygpXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZExpbmspXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBleHBvcnRNYXBUb1BOR1xyXG4gICAgICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgdGhlIGN1cnJlbnQgbWFwIHdpdGggc3R5bGluZyB0byBQTkcgYW5kIGRvd25sb2FkcyBpdFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgb3V0LmV4cG9ydE1hcFRvUE5HID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBzdmdOb2RlQ2xvbmUgPSBvdXQuc3ZnXy5ub2RlKCkuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgICAgLy8gQ29udmVydCBDU1MgdG8gaW5saW5lIHN0eWxlcyBiZWZvcmUgc2F2aW5nIHRoZSBTVkdcclxuICAgICAgICBhcHBseUlubGluZVN0eWxlc0Zyb21DU1Moc3ZnTm9kZUNsb25lKVxyXG5cclxuICAgICAgICAvLyBTdGVwIDE6IFNlcmlhbGl6ZSB0aGUgU1ZHIG5vZGUgdG8gYSBzdHJpbmdcclxuICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKVxyXG4gICAgICAgIGNvbnN0IHN2Z1N0cmluZyA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoc3ZnTm9kZUNsb25lKVxyXG5cclxuICAgICAgICAvLyBTdGVwIDI6IENyZWF0ZSBhIEJsb2IgZnJvbSB0aGUgc2VyaWFsaXplZCBTVkdcclxuICAgICAgICBjb25zdCBzdmdCbG9iID0gbmV3IEJsb2IoW3N2Z1N0cmluZ10sIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCcgfSlcclxuXHJcbiAgICAgICAgLy8gU3RlcCAzOiBDcmVhdGUgYSBVUkwgZm9yIHRoZSBCbG9iXHJcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdmdCbG9iKVxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcyBmcm9tIHRoZSBTVkdcclxuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHN2Z05vZGVDbG9uZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJylcclxuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgc3ZnTm9kZUNsb25lLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JylcclxuXHJcbiAgICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU1ZHIHdpZHRoIG9yIGhlaWdodCBhdHRyaWJ1dGVzIGFyZSBtaXNzaW5nIG9yIGludmFsaWQuJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0ZXAgNDogQ3JlYXRlIGFuIEltYWdlIGVsZW1lbnQgYW5kIGxvYWQgdGhlIEJsb2IgVVJMXHJcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcclxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTdGVwIDU6IERyYXcgdGhlIGltYWdlIG9uIGEgY2FudmFzXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcnNlRmxvYXQod2lkdGgpIC8vIFNldCBjYW52YXMgd2lkdGggZnJvbSBTVkcncyB3aWR0aCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHBhcnNlRmxvYXQoaGVpZ2h0KSAvLyBTZXQgY2FudmFzIGhlaWdodCBmcm9tIFNWRydzIGhlaWdodCBhdHRyaWJ1dGVcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxyXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcclxuXHJcbiAgICAgICAgICAgIC8vIFN0ZXAgNjogQ29udmVydCB0aGUgY2FudmFzIHRvIGEgUE5HIGJsb2JcclxuICAgICAgICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAocG5nQmxvYikge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RlcCA3OiBEb3dubG9hZCB0aGUgUE5HIGZpbGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBuZ1VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwocG5nQmxvYilcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSBwbmdVcmxcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9ICdldXJvc3RhdC1tYXAucG5nJ1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZExpbmspXHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuY2xpY2soKVxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZExpbmspXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgVVJMc1xyXG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpXHJcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHBuZ1VybClcclxuICAgICAgICAgICAgfSwgJ2ltYWdlL3BuZycpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGltYWdlIHNvdXJjZSB0byB0aGUgQmxvYiBVUkxcclxuICAgICAgICBpbWcuc3JjID0gdXJsXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlIHNvbWUgVVJMIHBhcmFtZXRlcnMsIHdoaWNoIGNvdWxkIGJlIHRoZW4gcmV1c2VkIGFzIG1hcCBkZWZpbml0aW9uIHBhcmFtZXRlcnMuXHJcbiAqIFRoaXMgYWxsb3cgYSBxdWljayBtYXAgY3VzdG9taXNhdGlvbiBieSBzaW1wbHkgYWRkaW5nIGFuZCBjaGFuZ2luZyBzb21lIFVSTCBwYXJhbWV0ZXJzLlxyXG4gKiBTZWUgbWFwIG1ldGhvZDogc2V0RnJvbVVSTCguLi4pXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0VVJMUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IHBzID0ge31cclxuICAgIGNvbnN0IHAgPSBbJ3cnLCAnaCcsICd4JywgJ3knLCAneicsICdzJywgJ2x2bCcsICd0aW1lJywgJ3Byb2onLCAnZ2VvJywgJ255JywgJ2xhbmd1YWdlJywgJ3NsJywgJ251bWJlck9mQ2xhc3NlcyddXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHBzW3BbaV1dID0gZ2V0VVJMUGFyYW1ldGVyQnlOYW1lKHBbaV0pXHJcbiAgICByZXR1cm4gcHNcclxufVxyXG4iLCIvLyBlLmcuIHRvIGJlIHVzZWQgd2l0aCBkZXByZWNhdGVkIC5zdHlsZSgpIGZ1bmN0aW9ucy4gVGhleSB3aWxsIG5vdyB1cGRhdGUgQ1NTIGNsYXNzZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDU1NSdWxlKHNlbGVjdG9yLCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIC8vIFZhbGlkYXRlIHRoZSBzZWxlY3RvclxyXG4gICAgaWYgKCFzZWxlY3Rvci5zdGFydHNXaXRoKCcuJykgJiYgIXNlbGVjdG9yLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvcjogTXVzdCBzdGFydCB3aXRoIFwiLlwiIGZvciBjbGFzc2VzIG9yIFwiI1wiIGZvciBJRHMuJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgcnVsZSBhbHJlYWR5IGV4aXN0cyBpbiBhbnkgc3R5bGVzaGVldFxyXG4gICAgY29uc3Qgc3R5bGVTaGVldHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnN0eWxlU2hlZXRzKVxyXG4gICAgZm9yIChjb25zdCBzdHlsZVNoZWV0IG9mIHN0eWxlU2hlZXRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBzdHlsZVNoZWV0LmNzc1J1bGVzIHx8IHN0eWxlU2hlZXQucnVsZXNcclxuICAgICAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgcnVsZSBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICBydWxlLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFNvbWUgc3R5bGVzaGVldHMgKGUuZy4sIGNyb3NzLW9yaWdpbikgbWF5IG5vdCBiZSBhY2Nlc3NpYmxlXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGFjY2VzcyBydWxlcyBpbiBzdHlsZXNoZWV0OmAsIGUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBydWxlIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBzdHlsZXNoZWV0IGFuZCBhZGQgaXRcclxuICAgIGxldCBjdXN0b21TaGVldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXN0b20tc3R5bGVzJylcclxuICAgIGlmICghY3VzdG9tU2hlZXQpIHtcclxuICAgICAgICBjdXN0b21TaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcclxuICAgICAgICBjdXN0b21TaGVldC5pZCA9ICdjdXN0b20tc3R5bGVzJ1xyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY3VzdG9tU2hlZXQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHRoZSBuZXcgcnVsZSB0byB0aGUgY3VzdG9tIHN0eWxlc2hlZXRcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY3VzdG9tU2hlZXQuc2hlZXQuaW5zZXJ0UnVsZShgJHtzZWxlY3Rvcn0geyAke3Byb3BlcnR5fTogJHt2YWx1ZX07IH1gLCBjdXN0b21TaGVldC5zaGVldC5jc3NSdWxlcy5sZW5ndGgpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGluc2VydCBydWxlOiAke3NlbGVjdG9yfSB7ICR7cHJvcGVydHl9OiAke3ZhbHVlfTsgfWAsIGUpXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRGb250U2l6ZUZyb21DbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBjbGFzc1xyXG4gICAgY29uc3QgdGVtcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgdGVtcEVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lXHJcblxyXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlcyB0byBtaW5pbWl6ZSBsYXlvdXQgaW50ZXJmZXJlbmNlXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS53aWR0aCA9ICdhdXRvJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUubGluZUhlaWdodCA9ICdub3JtYWwnXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9ICdpbml0aWFsJ1xyXG5cclxuICAgIC8vIEFwcGVuZCBkaXJlY3RseSB0byB0aGUgYm9keVxyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRWxlbWVudClcclxuXHJcbiAgICAvLyBHZXQgdGhlIGNvbXB1dGVkIGZvbnQtc2l6ZSBwcm9wZXJ0eSBhbmQgcGFyc2UgaXQgdG8gYSBudW1iZXJcclxuICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZW1wRWxlbWVudCkuZm9udFNpemUpXHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZWxlbWVudCBmcm9tIHRoZSBkb2N1bWVudCBib2R5XHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KVxyXG5cclxuICAgIHJldHVybiBmb250U2l6ZSB8fCAwXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIHByb3BlcnR5TmFtZSkge1xyXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGNsYXNzXHJcbiAgICBjb25zdCB0ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICB0ZW1wRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWVcclxuXHJcbiAgICAvLyBBcHBseSBpbmxpbmUgc3R5bGVzIHRvIG1pbmltaXplIGxheW91dCBpbnRlcmZlcmVuY2VcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0bydcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5saW5lSGVpZ2h0ID0gJ25vcm1hbCdcclxuXHJcbiAgICAvLyBBcHBlbmQgZGlyZWN0bHkgdG8gdGhlIGJvZHlcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcEVsZW1lbnQpXHJcblxyXG4gICAgLy8gR2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XHJcbiAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGVtcEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKVxyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQgYm9keVxyXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudClcclxuXHJcbiAgICByZXR1cm4gcHJvcGVydHlWYWx1ZSB8fCBudWxsXHJcbn1cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYWxsIENTUyBydWxlcyBkZWZpbmVkIGluIHRoZSBkb2N1bWVudFxyXG5mdW5jdGlvbiBnZXRBbGxDU1NSdWxlcygpIHtcclxuICAgIGxldCBjc3NSdWxlcyA9IFtdXHJcbiAgICBmb3IgKGxldCBzaGVldCBvZiBkb2N1bWVudC5zdHlsZVNoZWV0cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFNvbWUgc3R5bGVzaGVldHMgbWF5IG5vdCBiZSBhY2Nlc3NpYmxlIGR1ZSB0byBDT1JTLCBzbyB3ZSBjYXRjaCBhbnkgZXJyb3JzXHJcbiAgICAgICAgICAgIGZvciAobGV0IHJ1bGUgb2Ygc2hlZXQuY3NzUnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIGNzc1J1bGVzLnB1c2gocnVsZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gYWNjZXNzIHN0eWxlc2hlZXQ6Jywgc2hlZXQuaHJlZiwgZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3NzUnVsZXNcclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBleHBsaWNpdGx5IGRlZmluZWQgc3R5bGVzIGZyb20gQ1NTIGZvciBhbiBlbGVtZW50XHJcbmZ1bmN0aW9uIGdldFN0eWxlc0Zyb21DU1MoZWxlbWVudCkge1xyXG4gICAgbGV0IG1hdGNoZWRSdWxlcyA9IFtdXHJcbiAgICBjb25zdCBjc3NSdWxlcyA9IGdldEFsbENTU1J1bGVzKClcclxuXHJcbiAgICBjc3NSdWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQubWF0Y2hlcyhydWxlLnNlbGVjdG9yVGV4dCkpIHtcclxuICAgICAgICAgICAgbWF0Y2hlZFJ1bGVzLnB1c2gocnVsZS5zdHlsZSlcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vIENyZWF0ZSBhbiBvYmplY3Qgb2YgdGhlIGV4cGxpY2l0bHkgc2V0IHN0eWxlc1xyXG4gICAgbGV0IGV4cGxpY2l0U3R5bGVzID0ge31cclxuICAgIG1hdGNoZWRSdWxlcy5mb3JFYWNoKChzdHlsZSkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzdHlsZVtpXVxyXG4gICAgICAgICAgICBleHBsaWNpdFN0eWxlc1twcm9wZXJ0eV0gPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIGV4cGxpY2l0U3R5bGVzXHJcbn1cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBpbmxpbmUgc3R5bGVzIGV4cGxpY2l0bHkgc2V0IGluIENTUy4gVXNlZnVsIGZvciBleHBvcnRpbmcgU1ZHcyB3aXRoIENTUyBzdHlsZXMuXHJcbmV4cG9ydCBjb25zdCBhcHBseUlubGluZVN0eWxlc0Zyb21DU1MgPSAoc3ZnRWxlbWVudCkgPT4ge1xyXG4gICAgY29uc3QgYWxsRWxlbWVudHMgPSBzdmdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKVxyXG5cclxuICAgIGFsbEVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcclxuICAgICAgICBjb25zdCBjc3NTdHlsZXMgPSBnZXRTdHlsZXNGcm9tQ1NTKGVsZW1lbnQpXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGVhY2ggZXhwbGljaXRseSBkZWZpbmVkIENTUyBzdHlsZSBhcyBhbiBpbmxpbmUgc3R5bGVcclxuICAgICAgICBPYmplY3Qua2V5cyhjc3NTdHlsZXMpLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3NzU3R5bGVzW3Byb3BlcnR5XVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByb3BlcnR5IGFscmVhZHkgaGFzIGFuIGlubGluZSBzdHlsZVxyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0lubGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxyXG5cclxuICAgICAgICAgICAgaWYgKCFleGlzdGluZ0lubGluZVN0eWxlICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBleGlzdGluZyBpbmxpbmUgc3R5bGUsIHNldCB0aGUgbmV3IHN0eWxlXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgR2VvSlNPTiBmZWF0dXJlIHJlcHJlc2VudGluZyBhIGJvdW5kaW5nIGJveCwgd2l0aCBtdWx0aXBvaW50IGdlb21ldHJ5LlxyXG4gKiBUaGlzIGJvdW5kaW5nIGJveCBpcyBhbiBhcnJheSBsaWtlIHRoZSBvbmUgaW4gdG9wb2pzb24gYmJveCBlbGVtZW50LlxyXG4gKiBbeG1pbix5bWluLHhtYXgseW1heF1cclxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHRvIGNhbGwgZDMuZml0U2l6ZShbdywgaF0sIGdldFRvcG9KU09ORXh0ZW50QXNHZW9KU09OKHRvcG8uYmJveCkpKVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGJiIFRoZSBib3VuZGluZyBib3ggW3htaW4seW1pbix4bWF4LHltYXhdLiBGb3IgdG9wb2pzb24gZGF0YSwganVzdCBnaXZlIHRoZSB0b3BvanNvbi5iYm94IGVsZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0QkJPWEFzR2VvSlNPTiA9IGZ1bmN0aW9uIChiYikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICAgICAgZ2VvbWV0cnk6IHtcclxuICAgICAgICAgICAgdHlwZTogJ011bHRpUG9pbnQnLFxyXG4gICAgICAgICAgICBjb29yZGluYXRlczogW1xyXG4gICAgICAgICAgICAgICAgW2JiWzBdLCBiYlsxXV0sXHJcbiAgICAgICAgICAgICAgICBbYmJbMl0sIGJiWzNdXSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICB9LFxyXG4gICAgfVxyXG59XHJcblxyXG4vLyBpbmRleGluZ1xyXG5cclxuLyoqXHJcbiAqIEluZGV4IEpTT05TdGF0IHN0YXQgdmFsdWVzIGJ5ICdnZW8nIGNvZGUuXHJcbiAqIFJldHVybiBhIHN0cnVjdHVyZSBsaWtlOiB7Z2VvOnt2YWx1ZTowLHN0YXR1czpcIlwifX1cclxuICpcclxuICogQHBhcmFtIHsqfSBqc0RhdGEgVGhlIEpTT05TdGF0IGRhdGEgdG8gaW5kZXhcclxuICovXHJcbmV4cG9ydCBjb25zdCBqc29uc3RhdFRvSW5kZXggPSBmdW5jdGlvbiAoanNEYXRhKSB7XHJcbiAgICBjb25zdCBpbmQgPSB7fVxyXG4gICAgY29uc3QgZ2VvcyA9IGpzRGF0YS5EaW1lbnNpb24oJ2dlbycpLmlkXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb3MubGVuZ3RoOyBpKyspIGluZFtnZW9zW2ldXSA9IGpzRGF0YS5EYXRhKGkpXHJcbiAgICByZXR1cm4gaW5kXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmRleCBDU1Ygc3RhdCB2YWx1ZXMgYnkgJ2dlbycgY29kZS5cclxuICogUmV0dXJuIGEgc3RydWN0dXJlIGxpa2U6IHtnZW86e3ZhbHVlOjAsc3RhdHVzOlwiXCJ9fVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNzdkRhdGEgVGhlIENTViBkYXRhIHRvIGluZGV4XHJcbiAqIEBwYXJhbSB7Kn0gZ2VvQ29sIFRoZSBuYW1lIG9mIHRoZSBnZW8gY29sdW1uIGluIHRoZSBDU1YgZGF0YVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlQ29sIFRoZSBuYW1lIG9mIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZSBjb2x1bW4gaW4gdGhlIENTViBmaWxlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNzdlRvSW5kZXggPSBmdW5jdGlvbiAoY3N2RGF0YSwgZ2VvQ29sLCB2YWx1ZUNvbCkge1xyXG4gICAgY29uc3QgaW5kID0ge31cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3N2RGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGQgPSBjc3ZEYXRhW2ldXHJcbiAgICAgICAgY29uc3QgdiA9IGRbdmFsdWVDb2xdXHJcbiAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgIGluZFtkW2dlb0NvbF1dID0geyB2YWx1ZTogJzonLCBzdGF0dXM6ICcnIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbmRbZFtnZW9Db2xdXSA9IHsgdmFsdWU6IGlzTmFOKCt2KSA/IHYgOiArdiwgc3RhdHVzOiAnJyB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZFxyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgc3RyaW5nIHdpdGggc3BhY2UgYXMgdGhvdXNhbmQgc2VwYXJhdG9yXHJcbiAqIEBmdW5jdGlvbiBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3JcclxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciA9IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgIHJldHVybiBudW1iZXIudG9Mb2NhbGVTdHJpbmcoJ2VuJykucmVwbGFjZSgvLC9naSwgJyAnKVxyXG59XHJcblxyXG4vL1JFU1QgQVBJXHJcbmV4cG9ydCBjb25zdCBnZXRFc3RhdFJlc3REYXRhVVJMQmFzZSA9ICdodHRwczovL2VjLmV1cm9wYS5ldS9ldXJvc3RhdC9hcGkvZGlzc2VtaW5hdGlvbi9zdGF0aXN0aWNzLzEuMC9kYXRhLydcclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBVUkwgdG8gZmV0Y2ggZGF0YSBmcm9tIGV1cm9iYXNlIFJFU1QgQVBJLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldENvZGUgVGhlIEV1cm9iYXNlIGRhdGFzZXQgY29kZVxyXG4gKiBAcGFyYW0ge29iamVjdD19IGZpbHRlcnMgVGhlIGZpbHRlciBwYXJhbWV0ZXJzIGFzIGZvciBleGFtcGxlOiB7a2V5OnZhbHVlLGtleTpbdmFsdWUxLHZhbHVlMix2YWx1ZTNdfVxyXG4gKiBAcGFyYW0ge251bWJlcj19IGxhbmdcclxuICogQHBhcmFtIHtudW1iZXI9fSBmb3JtYXRcclxuICogQHBhcmFtIHtudW1iZXI9fSB2ZXJzaW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RXN0YXREYXRhVVJMID0gZnVuY3Rpb24gKGRhdGFzZXRDb2RlLCBmaWx0ZXJzLCBsYW5nLCBmb3JtYXQpIHtcclxuICAgIGxhbmcgPSBsYW5nIHx8ICdlbidcclxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnanNvbidcclxuICAgIHZhciB1cmwgPSBbXVxyXG4gICAgdXJsLnB1c2goZ2V0RXN0YXRSZXN0RGF0YVVSTEJhc2UsIGRhdGFzZXRDb2RlLCAnPycsICdmb3JtYXQ9JywgZm9ybWF0LCAnJmxhbmc9JywgbGFuZylcclxuICAgIGlmIChmaWx0ZXJzKVxyXG4gICAgICAgIGZvciAodmFyIHBhcmFtIGluIGZpbHRlcnMpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSBmaWx0ZXJzW3BhcmFtXVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvKSkgZm9yICh2YXIgaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKSB1cmwucHVzaCgnJicsIHBhcmFtLCAnPScsIG9baV0pXHJcbiAgICAgICAgICAgIGVsc2UgdXJsLnB1c2goJyYnLCBwYXJhbSwgJz0nLCBvKVxyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB1cmwuam9pbignJylcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0VVJMUGFyYW1ldGVyQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKVxyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgbmFtZSArICc9KFteJiNdKiknKSxcclxuICAgICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpXHJcbiAgICByZXR1cm4gIXJlc3VsdHMgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpXHJcbn1cclxuXHJcbi8vZmxhZ3NcclxuZXhwb3J0IGNvbnN0IGZsYWdzID0ge1xyXG4gICAgYjogJ2JyZWFrIGluIHRpbWUgc2VyaWVzJyxcclxuICAgIGM6ICdjb25maWRlbnRpYWwnLFxyXG4gICAgZDogJ2RlZmluaXRpb24gZGlmZmVycywgc2VlIG1ldGFkYXRhJyxcclxuICAgIGU6ICdlc3RpbWF0ZWQnLFxyXG4gICAgZjogJ2ZvcmVjYXN0JyxcclxuICAgIG46ICdub3Qgc2lnbmlmaWNhbnQnLFxyXG4gICAgcDogJ3Byb3Zpc2lvbmFsJyxcclxuICAgIHI6ICdyZXZpc2VkJyxcclxuICAgIHM6ICdFdXJvc3RhdCBlc3RpbWF0ZScsXHJcbiAgICB1OiAnbG93IHJlbGlhYmlsaXR5JyxcclxuICAgIHo6ICdub3QgYXBwbGljYWJsZScsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gRXhlY3V0ZXMgYSBmdW5jdGlvbiBmb3IgYWxsIGluc2V0IG1hcHMuIFNvbWUgaW5zZXRzIG1pZ2h0IGJlIGV4dGVybmFsIFNWR3Mgd2hpY2ggaXMgd2h5IHRoaXMgZnVuY3Rpb24gd2FzIGNyZWF0ZWQuXHJcbiAqIEBwYXJhbSB7Kn0gaW5zZXRzIG1hcC5pbnNldHNcclxuICogQHBhcmFtIHsqfSBtYWluU3ZnSWQgdGhlIElEIG9mIHRoZSBtYXAncyBzdmdcclxuICogQHBhcmFtIHsqfSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBpbnNldFxyXG4gKiBAcGFyYW0geyp9IFtwYXJhbWV0ZXI9bnVsbF0gdGhlIHBhcmFtZXRlciB0byBwYXNzIHRvIHRoZSBjYWxsYmFja1xyXG4gKiBAcGFyYW0geyp9IFtwYXJhbWV0ZXIyPW51bGxdIHRoZSBwYXJhbWV0ZXIgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tcclxuICovXHJcbmV4cG9ydCBjb25zdCBleGVjdXRlRm9yQWxsSW5zZXRzID0gZnVuY3Rpb24gKGluc2V0cywgbWFpblN2Z0lkLCBjYWxsYmFjaywgcGFyYW1ldGVyID0gbnVsbCwgcGFyYW1ldGVyMiA9IG51bGwpIHtcclxuICAgIGZvciAoY29uc3QgZ2VvIGluIGluc2V0cykge1xyXG4gICAgICAgIGNvbnN0IGluc2V0R3JvdXAgPSBpbnNldHNbZ2VvXVxyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnNldEdyb3VwKSkge1xyXG4gICAgICAgICAgICBpbnNldEdyb3VwLmZvckVhY2goKGluc2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbmVzdGVkIGFycmF5cyBmb3IgbXVsdGlwbGUgaW5zZXRzIHdpdGggdGhlIHNhbWUgZ2VvXHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnNldC5mb3JFYWNoKChuZXN0ZWRJbnNldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkSW5zZXQuc3ZnSWRfICE9PSBtYWluU3ZnSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5lc3RlZEluc2V0LCBwYXJhbWV0ZXIsIHBhcmFtZXRlcjIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXQuc3ZnSWRfICE9PSBtYWluU3ZnSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaW5zZXQsIHBhcmFtZXRlciwgcGFyYW1ldGVyMilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY2FsbGJhY2sgdG8gdW5pcXVlIGluc2V0XHJcbiAgICAgICAgICAgIGlmIChpbnNldEdyb3VwLnN2Z0lkXyAhPT0gbWFpblN2Z0lkKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnNldEdyb3VwLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcjIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1cHBlckNhc2VGaXJzdExldHRlciA9IChzdHJpbmcpID0+IGAke3N0cmluZy5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpfSR7c3RyaW5nLnNsaWNlKDEpfWBcclxuXHJcbmV4cG9ydCBjb25zdCBsb3dlckNhc2VBbGxXb3Jkc0V4Y2VwdEZpcnN0TGV0dGVycyA9IChzdHJpbmcpID0+XHJcbiAgICBzdHJpbmcucmVwbGFjZUFsbCgvXFxTKi9nLCAod29yZCkgPT4gYCR7d29yZC5zbGljZSgwLCAxKX0ke3dvcmQuc2xpY2UoMSkudG9Mb3dlckNhc2UoKX1gKVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERvd25sb2FkVVJMKHN2Z05vZGUpIHtcclxuICAgIC8vIENyZWF0ZSBYTUwgaGVhZGVyIHRvIGVuc3VyZSB0aGUgU1ZHIGlzIHJlY29nbml6ZWQgcHJvcGVybHlcclxuICAgIGNvbnN0IHhtbEhlYWRlciA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJub1wiPz5cXG4nXHJcblxyXG4gICAgLy8gY3JlYXRlIGJsb2JcclxuICAgIGNvbnN0IHN2Z0NvbnRlbnQgPSB4bWxIZWFkZXIgKyBzdmdOb2RlLm91dGVySFRNTFxyXG4gICAgY29uc3Qgc3ZnQmxvYiA9IG5ldyBCbG9iKFtzdmdDb250ZW50XSwgeyB0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04JyB9KVxyXG4gICAgY29uc3Qgc3ZnVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdmdCbG9iKVxyXG4gICAgcmV0dXJuIHN2Z1VybFxyXG59XHJcblxyXG4vLyBSYXN0ZXJpemUgZnVuY3Rpb24gd2l0aCBhZGRpdGlvbmFsIGVycm9yIGhhbmRsaW5nXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoc3ZnKSB7XHJcbiAgICBjb25zdCB4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcclxuICAgIGNvbnN0IHhsaW5rbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcclxuICAgIGNvbnN0IHN2Z25zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xyXG4gICAgY29uc3QgZnJhZ21lbnQgPSB3aW5kb3cubG9jYXRpb24uaHJlZiArICcjJ1xyXG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihzdmcsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCBudWxsLCBmYWxzZSlcclxuICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiB3YWxrZXIuY3VycmVudE5vZGUuYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBpZiAoYXR0ci52YWx1ZS5pbmNsdWRlcyhmcmFnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGF0dHIudmFsdWUgPSBhdHRyLnZhbHVlLnJlcGxhY2UoZnJhZ21lbnQsICcjJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyh4bWxucywgJ3htbG5zJywgc3ZnbnMpXHJcbiAgICBzdmcuc2V0QXR0cmlidXRlTlMoeG1sbnMsICd4bWxuczp4bGluaycsIHhsaW5rbnMpXHJcbiAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3IHdpbmRvdy5YTUxTZXJpYWxpemVyKClcclxuICAgIGNvbnN0IHN0cmluZyA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKVxyXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtzdHJpbmddLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sJyB9KVxyXG59XHJcblxyXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9zYXZpbmctc3ZcclxuLy9zdmcgdG8gY2FudmFzIGJsb2IgcHJvbWlzZVxyXG5leHBvcnQgZnVuY3Rpb24gcmFzdGVyaXplKHN2Zykge1xyXG4gICAgbGV0IHJlc29sdmUsIHJlamVjdFxyXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCh5LCBuKSA9PiAoKHJlc29sdmUgPSB5KSwgKHJlamVjdCA9IG4pKSlcclxuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcclxuICAgIGltYWdlLm9uZXJyb3IgPSByZWplY3RcclxuICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCByZWN0ID0gc3ZnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgICAgICBjYW52YXMud2lkdGggPSByZWN0LndpZHRoXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KVxyXG4gICAgICAgIGNvbnRleHQuY2FudmFzLnRvQmxvYihyZXNvbHZlKVxyXG4gICAgfVxyXG4gICAgaW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzZXJpYWxpemUoc3ZnKSlcclxuICAgIHJldHVybiBwcm9taXNlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBVUkwgcGFyYW1ldGVyIGJ5IG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlckJ5TmFtZShuYW1lKSB7XHJcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dLywgJ1xcXFxdJylcclxuICAgIGxldCByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIG5hbWUgKyAnPShbXiYjXSopJyksXHJcbiAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWMobG9jYXRpb24uc2VhcmNoKVxyXG4gICAgcmV0dXJuICFyZXN1bHRzID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHRzWzFdLnJlcGxhY2UoL1xcKy9nLCAnICcpKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaGV4VG9SZ2IgPSAoaGV4KSA9PiB7XHJcbiAgICBoZXggPSBoZXgucmVwbGFjZSgnIycsICcnKVxyXG4gICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICBoZXggPSBoZXhcclxuICAgICAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgICAgICAubWFwKChoKSA9PiBoICsgaClcclxuICAgICAgICAgICAgLmpvaW4oJycpXHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnQgPSBwYXJzZUludChoZXgsIDE2KVxyXG4gICAgcmV0dXJuIFsoaW50ID4+IDE2KSAmIDI1NSwgKGludCA+PiA4KSAmIDI1NSwgaW50ICYgMjU1XVxyXG59XHJcblxyXG4vL2JsZW5kcyB0d28gY29sb3JzIHVzaW5nICdtdWx0aXBseScgYmxlbmRpbmcgbW9kZS4gUmV0dXJucyB0aGUgYmxlbmRlZCBjb2xvciBhcyBhbiBSR0Igc3RyaW5nXHJcbmV4cG9ydCBjb25zdCBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXggPSAoY29sb3JzKSA9PiB7XHJcbiAgICAvLyBDb252ZXJ0IGhleCBjb2xvciB0byBSR0JcclxuICAgIGNvbnN0IGhleFRvUmdiID0gKGhleCkgPT4ge1xyXG4gICAgICAgIGhleCA9IGhleC5yZXBsYWNlKCcjJywgJycpXHJcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICAgICAgaGV4ID0gaGV4XHJcbiAgICAgICAgICAgICAgICAuc3BsaXQoJycpXHJcbiAgICAgICAgICAgICAgICAubWFwKChoKSA9PiBoICsgaClcclxuICAgICAgICAgICAgICAgIC5qb2luKCcnKVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnQgPSBwYXJzZUludChoZXgsIDE2KVxyXG4gICAgICAgIHJldHVybiBbKGludCA+PiAxNikgJiAyNTUsIChpbnQgPj4gOCkgJiAyNTUsIGludCAmIDI1NV1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IFJHQiB0byBoZXhcclxuICAgIGNvbnN0IHJnYlRvSGV4ID0gKFtyLCBnLCBiXSkgPT4gYCMke1tyLCBnLCBiXS5tYXAoKGMpID0+IGMudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpfWBcclxuXHJcbiAgICAvLyBDb252ZXJ0IGFsbCBoZXggY29sb3JzIHRvIFJHQiBhcnJheXNcclxuICAgIGNvbnN0IHJnYkNvbG9ycyA9IGNvbG9ycy5tYXAoaGV4VG9SZ2IpXHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVzdWx0IHdpdGggdGhlIGZpcnN0IGNvbG9yXHJcbiAgICBsZXQgYmxlbmRlZCA9IFsuLi5yZ2JDb2xvcnNbMF1dXHJcblxyXG4gICAgLy8gU2VxdWVudGlhbGx5IG11bHRpcGx5IGVhY2ggY29sb3Igd2l0aCB0aGUgcmVzdWx0XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJnYkNvbG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGJsZW5kZWQgPSBibGVuZGVkLm1hcCgodiwgaWR4KSA9PiBNYXRoLnJvdW5kKCh2IC8gMjU1KSAqIChyZ2JDb2xvcnNbaV1baWR4XSAvIDI1NSkgKiAyNTUpKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybiB0aGUgYmxlbmRlZCBjb2xvciBhcyBhIGhleCBjb2RlXHJcbiAgICByZXR1cm4gcmdiVG9IZXgoYmxlbmRlZClcclxufVxyXG5cclxuLy8gY29udmVydCByZWN0IGF0dHJpYnV0ZXMgaW50byBhbiBTVkcgcGF0aCBzdHJpbmdcclxuLy8gdXNlZCBmb3Igd29ya2Fyb3VuZCB3aGVyZWJ5IGNsaXBQYXRocyB3aGljaCB1c2UgcmVjdCBlbGVtZW50cyBkbyBub3Qgd29yayBpbiBhZG9iZSBpbGx1c3RyYXRvclxyXG5leHBvcnQgY29uc3QgY29udmVydFJlY3RhbmdsZXNUb1BhdGhzID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciB4ID0gcGFyc2VGbG9hdCh4LCAxMClcclxuICAgIHZhciB5ID0gcGFyc2VGbG9hdCh5LCAxMClcclxuICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQod2lkdGgsIDEwKVxyXG4gICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQoaGVpZ2h0LCAxMClcclxuXHJcbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgd2lkdGggPCAwIHx8IGhlaWdodCA8IDApIHtcclxuICAgICAgICByZXR1cm4gJydcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJ00nICsgeCArICcsJyArIHkgKyAnTCcgKyAoeCArIHdpZHRoKSArICcsJyArIHkgKyAnICcgKyAoeCArIHdpZHRoKSArICcsJyArICh5ICsgaGVpZ2h0KSArICcgJyArIHggKyAnLCcgKyAoeSArIGhlaWdodCkgKyAneidcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRleHRDb2xvckZvckJhY2tncm91bmQgPSBmdW5jdGlvbiAoYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICBsZXQgciwgZywgYlxyXG5cclxuICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBlbGVtZW50IHRvIGhhbmRsZSBuYW1lZCBjb2xvcnNcclxuICAgIGlmICghYmFja2dyb3VuZENvbG9yLnN0YXJ0c1dpdGgoJ3JnYicpICYmICFiYWNrZ3JvdW5kQ29sb3Iuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICAgICAgdGVtcERpdi5zdHlsZS5jb2xvciA9IGJhY2tncm91bmRDb2xvclxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcERpdilcclxuICAgICAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGVtcERpdikuY29sb3JcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBEaXYpXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yID0gY29tcHV0ZWRDb2xvciAvLyBDb252ZXJ0IG5hbWVkIGNvbG9yIHRvIFJHQlxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBoZXggY29sb3JzIGxpa2UgJyNGRkZGRkYnIG9yICcjRkZGJ1xyXG4gICAgaWYgKGJhY2tncm91bmRDb2xvci5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgICBsZXQgaGV4ID0gYmFja2dyb3VuZENvbG9yLnJlcGxhY2UoJyMnLCAnJylcclxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICBoZXggPSBoZXhcclxuICAgICAgICAgICAgICAgIC5zcGxpdCgnJylcclxuICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IGMgKyBjKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNilcclxuICAgICAgICBnID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygyLCA0KSwgMTYpXHJcbiAgICAgICAgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNCwgNiksIDE2KVxyXG4gICAgfVxyXG4gICAgLy8gSGFuZGxlIFJHQiBjb2xvcnMgbGlrZSAncmdiKDI1NSwyNTUsMjU1KSdcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHJnYiA9IGJhY2tncm91bmRDb2xvci5tYXRjaCgvXFxkKy9nKVxyXG4gICAgICAgIHIgPSBwYXJzZUludChyZ2JbMF0pXHJcbiAgICAgICAgZyA9IHBhcnNlSW50KHJnYlsxXSlcclxuICAgICAgICBiID0gcGFyc2VJbnQocmdiWzJdKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBsdW1pbmFuY2VcclxuICAgIGNvbnN0IGx1bWluYW5jZSA9IDAuMjEyNiAqIChyIC8gMjU1KSArIDAuNzE1MiAqIChnIC8gMjU1KSArIDAuMDcyMiAqIChiIC8gMjU1KVxyXG5cclxuICAgIC8vIFJldHVybiBibGFjayBmb3IgbGlnaHQgYmFja2dyb3VuZHMsIHdoaXRlIGZvciBkYXJrIGJhY2tncm91bmRzXHJcbiAgICByZXR1cm4gbHVtaW5hbmNlID4gMC41ID8gJ2JsYWNrJyA6ICd3aGl0ZSdcclxufVxyXG5cclxuLy8gZ2V0IGNzcyBzZWxlY3Rvci4gRGlmZmVyZW50IG1hcHMgaGF2ZSBkaWZmZXJlbnQgc2VsZWN0b3JzIGZvciB0aGVpciByZWdpb25zLlxyXG5leHBvcnQgY29uc3QgZ2V0UmVnaW9uc1NlbGVjdG9yID0gKG1hcCkgPT4ge1xyXG4gICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSByZXR1cm4gJyNlbS11c2VyLXJlZ2lvbnMgcGF0aCdcclxuICAgIGlmIChtYXAuZ3JpZENhcnRvZ3JhbV8pIHJldHVybiAnI2VtLWdyaWQtY29udGFpbmVyIC5lbS1ncmlkLWNlbGwnXHJcbiAgICBpZiAobWFwLmdlb18gPT09ICdXT1JMRCcpIHJldHVybiAnI2VtLXdvcmxkcmcgcGF0aCdcclxuICAgIHJldHVybiAnI2VtLW51dHNyZyBwYXRoOm5vdCgjZW0tY250cmctUlMpOm5vdCgjZW0tY250cmctRUwpLCAjZW0tY250cmcgcGF0aDpub3QoI2VtLWNudHJnLVJTKTpub3QoI2VtLWNudHJnLUVMKSdcclxufVxyXG5cclxuLy8gZ2V0IGNzcyBzZWxlY3RvciBmb3IgbGVnZW5kIG1vdXNlIGhvdmVyLiBEaWZmZXJlbnQgbWFwcyBoYXZlIGRpZmZlcmVudCBzZWxlY3RvcnMgZm9yIHRoZWlyIHJlZ2lvbnNcclxuZXhwb3J0IGNvbnN0IGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvciA9IChtYXApID0+IHtcclxuICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgcmV0dXJuICcjZW0tdXNlci1yZWdpb25zJ1xyXG4gICAgaWYgKG1hcC5ncmlkQ2FydG9ncmFtXykgcmV0dXJuICcjZW0tZ3JpZC1jb250YWluZXInXHJcbiAgICBpZiAobWFwLmdlb18gPT09ICdXT1JMRCcpIHJldHVybiAnI2VtLXdvcmxkcmcnXHJcbiAgICByZXR1cm4gJyNlbS1udXRzcmcsICNlbS1jbnRyZydcclxufVxyXG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5vcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiaW1wb3J0ICogYXMgQ2hvcm9wbGV0aCBmcm9tICcuL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoJ1xyXG5pbXBvcnQgKiBhcyBQcm9wb3J0aW9uYWxTeW1ib2wgZnJvbSAnLi9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMnXHJcbmltcG9ydCAqIGFzIENhdGVnb3JpY2FsIGZyb20gJy4vbWFwdHlwZXMvbWFwLWNhdGVnb3JpY2FsJ1xyXG5pbXBvcnQgKiBhcyBCaXZhcmlhdGVDaG9yb3BsZXRoIGZyb20gJy4vbWFwdHlwZXMvbWFwLWNob3JvcGxldGgtYml2YXJpYXRlJ1xyXG5pbXBvcnQgKiBhcyBUcml2YXJpYXRlQ2hvcm9wbGV0aCBmcm9tICcuL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLXRyaXZhcmlhdGUnXHJcbmltcG9ydCAqIGFzIFN0cmlwZUNvbXBvc2l0aW9uIGZyb20gJy4vbWFwdHlwZXMvbWFwLXN0cmlwZS1jb21wb3NpdGlvbidcclxuaW1wb3J0ICogYXMgUGllQ2hhcnRzIGZyb20gJy4vbWFwdHlwZXMvbWFwLXBpZWNoYXJ0cydcclxuaW1wb3J0ICogYXMgU3BhcmtsaW5lcyBmcm9tICcuL21hcHR5cGVzL21hcC1zcGFya2xpbmVzJ1xyXG5pbXBvcnQgKiBhcyBGbG93TWFwIGZyb20gJy4vbWFwdHlwZXMvbWFwLWZsb3cnXHJcbmltcG9ydCAqIGFzIG10IGZyb20gJy4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0IHsgREVGQVVMVExBQkVMUyB9IGZyb20gJy4vY29yZS9sYWJlbHMnXHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGEgZXVyb3N0YXQtbWFwIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHsqfSB0eXBlIFRoZSB0eXBlIG9mIG1hcCAoJ2NoJyBmb3IgY2hvcm9wbGV0aCwgZXRjLilcclxuICogQHBhcmFtIHsqfSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBFeC46IHsgdGl0bGU6IFwiTWFwIHRpdGxlXCIsIGdlb0NlbnRlcjogWzIzMyw2NTRdLCAuLi59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvL2Nob3JvcGxldGggbWFwXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2Nob3JvcGxldGgnIHx8IHR5cGUgPT0gJ2NoJykgcmV0dXJuIENob3JvcGxldGgubWFwKGNvbmZpZylcclxuICAgICAgICAvL2NhdGVnb3JpY2FsIG1hcFxyXG4gICAgICAgIGlmICh0eXBlID09ICdjYXRlZ29yaWNhbCcgfHwgdHlwZSA9PSAnY3QnKSByZXR1cm4gQ2F0ZWdvcmljYWwubWFwKGNvbmZpZylcclxuICAgICAgICAvL3Byb3BvcnRpb25uYWwgc3ltYm9scyBtYXBcclxuICAgICAgICBpZiAodHlwZSA9PSAncHJvcG9ydGlvbmFsU3ltYm9sJyB8fCB0eXBlID09ICdwcycpIHJldHVybiBQcm9wb3J0aW9uYWxTeW1ib2wubWFwKGNvbmZpZylcclxuICAgICAgICAvL2JpdmFyaWF0ZSBjaG9yb3BsZXRoXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2JpdmFyaWF0ZUNob3JvcGxldGgnIHx8IHR5cGUgPT0gJ2NoYmknKSByZXR1cm4gQml2YXJpYXRlQ2hvcm9wbGV0aC5tYXAoY29uZmlnKVxyXG4gICAgICAgIC8vdHJpdmFyaWF0ZSBjaG9yb3BsZXRoXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ3RyaXZhcmlhdGVDaG9yb3BsZXRoJyB8fCB0eXBlID09ICdjaGJpJykgcmV0dXJuIFRyaXZhcmlhdGVDaG9yb3BsZXRoLm1hcChjb25maWcpXHJcbiAgICAgICAgLy9zdHJpcGVzIGNvbXBvc2l0aW9uXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ3N0cmlwZUNvbXBvc2l0aW9uJyB8fCB0eXBlID09ICdzY29tcCcpIHJldHVybiBTdHJpcGVDb21wb3NpdGlvbi5tYXAoY29uZmlnKVxyXG4gICAgICAgIC8vcHJvcG9ydGlvbmFsIHBpZSBjaGFydHNcclxuICAgICAgICBpZiAodHlwZSA9PSAncGllQ2hhcnQnIHx8IHR5cGUgPT0gJ3BpZScpIHJldHVybiBQaWVDaGFydHMubWFwKGNvbmZpZylcclxuICAgICAgICAvL3NwYXJrbGluZSBtYXBzXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ3NwYXJrbGluZScgfHwgdHlwZSA9PSAnc3BhcmsnIHx8IHR5cGUgPT0gJ3NwYXJrbGluZXMnKSByZXR1cm4gU3BhcmtsaW5lcy5tYXAoY29uZmlnKVxyXG4gICAgICAgIC8vZmxvdyBtYXBzXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2Zsb3cnIHx8IHR5cGUgPT0gJ2Zsb3dtYXAnKSByZXR1cm4gRmxvd01hcC5tYXAoY29uZmlnKVxyXG5cclxuICAgICAgICAvL2FkZCBuZXcgbWFwIHR5cGVzIGhlcmVcclxuICAgICAgICAvL2lmKHR5cGUgPT0gXCJYWFwiKSByZXR1cm4gbWFwWFgubWFwKGNvbmZpZyk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkIG1hcCB0eXBlOiAnICsgdHlwZSlcclxuICAgICAgICByZXR1cm4gbXQuc3RhdE1hcChjb25maWcsIHRydWUsIHR5cGUpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXVyb3N0YXQtbWFwLm1hcDogJyArIGUubWVzc2FnZSlcclxuICAgICAgICBjb25zb2xlLmVycm9yKGUpXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBidWlsZHMgZmlsbCBwYXR0ZXJucyBzdHlsZS5cclxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGhhcyBmb3IgYXJndW1lbnRzIHRoZSBTVkcgZWxlbWVudCB3aGVyZSB0byB1c2UgdGhlIGZpbGwgcGF0dGVybiwgYW5kIHRoZSBudW1iZXIgb2YgY2xhc3Nlcy5cclxuICpcclxuICogQHBhcmFtIHsqfSBvcHRzIFZhcmlvdXMgcGFyYW1ldGVycyBvbiB0aGUgZmlsbCBwYXR0ZXJuLlxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RmlsbFBhdHRlcm5EZWZpbml0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgb3B0cyA9IG9wdHMgfHwge31cclxuICAgIG9wdHMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICdjaXJjbGUnXHJcbiAgICBjb25zdCBwcyA9IG9wdHMucGF0dGVyblNpemUgfHwgNVxyXG4gICAgY29uc3Qgc21pbiA9IG9wdHMubWluU2l6ZSB8fCAxXHJcbiAgICBjb25zdCBzbWF4ID0gb3B0cy5tYXhTaXplIHx8IDUuNVxyXG4gICAgb3B0cy5iY2tDb2xvciA9IG9wdHMuYmNrQ29sb3IgfHwgJ3doaXRlJ1xyXG4gICAgb3B0cy5zeW1iQ29sb3IgPSBvcHRzLnN5bWJDb2xvciB8fCAnYmxhY2snXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN2ZywgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgLy9jbGVhciBwcmV2aW91c1xyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5lbS1maWxsLXBhdHRlcm4nKS5yZW1vdmUoKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2kgPSBzbWluICsgKChzbWF4IC0gc21pbikgKiBpKSAvIChudW1iZXJPZkNsYXNzZXMgLSAxKVxyXG4gICAgICAgICAgICBjb25zdCBwYXR0ID0gc3ZnXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1maWxsLXBhdHRlcm4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3BhdHRlcm5fJyArIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsICcwJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJzAnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgcHMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgcHMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncGF0dGVyblVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcclxuICAgICAgICAgICAgcGF0dC5hcHBlbmQoJ3JlY3QnKS5hdHRyKCd4JywgMCkuYXR0cigneScsIDApLmF0dHIoJ3dpZHRoJywgcHMpLmF0dHIoJ2hlaWdodCcsIHBzKS5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKS5zdHlsZSgnZmlsbCcsIG9wdHMuYmNrQ29sb3IpXHJcbiAgICAgICAgICAgIGlmIChvcHRzLnNoYXBlID09ICdzcXVhcmUnKVxyXG4gICAgICAgICAgICAgICAgcGF0dC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2kpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG9wdHMuc3ltYkNvbG9yKVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwYXR0LmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBwcyAqIDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBwcyAqIDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIHNpICogMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG9wdHMuc3ltYkNvbG9yKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gREVGQVVMVExBQkVMU1xyXG59XHJcblxyXG5pbXBvcnQgeyB2ZXJzaW9uIGFzIHBrZ1ZlcnNpb24gfSBmcm9tICcuLi9wYWNrYWdlLmpzb24nXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gcGtnVmVyc2lvblxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCB7IGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQtcGF0dGVybi1maWxsJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBjYXRlZ29yaWNhbCBtYXBzXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy90aGUgd2lkdGggb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZVdpZHRoID0gMTNcclxuICAgIC8vdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlSGVpZ2h0ID0gMTVcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlUGFkZGluZyA9IDVcclxuICAgIC8vdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGVnZW5kIGxhYmVsXHJcbiAgICBvdXQubGFiZWxGb250U2l6ZSA9IDEyXHJcbiAgICAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbGFiZWxcclxuICAgIG91dC5sYWJlbE9mZnNldCA9IDVcclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhID0gdHJ1ZVxyXG4gICAgLy9ubyBkYXRhIGxhYmVsIHRleHRcclxuICAgIG91dC5ub0RhdGFUZXh0ID0gJ05vIGRhdGEnXHJcbiAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIHRoZSBsZWdlbmQgZWxlbWVudHMgbWFudWFsbHkgYXMgYW4gYXJyYXlcclxuICAgIG91dC5vcmRlciA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgaWYgKG91dC5sZ2cubm9kZSgpICYmIG91dC5tYXAuY2xhc3NpZmllcl8pIHtcclxuICAgICAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgdGl0bGVcclxuICAgICAgICAgICAgaWYgKG91dC50aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2dldCBjYXRlZ29yeSBjb2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBkb21haW4gPSBtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpID8gT2JqZWN0LmtleXMobWFwLmNsYXNzVG9GaWxsU3R5bGUoKSkgOiBtYXAuY2xhc3NpZmllcl8uZG9tYWluKClcclxuICAgICAgICAgICAgY29uc3QgZWNscyA9IG91dC5vcmRlciA/IG91dC5vcmRlciA6IGRvbWFpblxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlY2xzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoZSBjbGFzc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsXyA9IGVjbHNbaV1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IG1hcC5jbGFzc2lmaWVyXyhlY2xfKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbENvbG9yID0gbWFwLmNsYXNzVG9GaWxsU3R5bGVfW2VjbF9dXHJcblxyXG4gICAgICAgICAgICAgICAgLy90aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyA6IDApICsgaSAqIChvdXQuc2hhcGVIZWlnaHQgKyBvdXQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBoaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbGFiZWxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChtYXAuY2xhc3NUb1RleHQoKSA/IG1hcC5jbGFzc1RvVGV4dCgpW2VjbF9dIDogZWNsXylcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgICAgICBpZiAob3V0Lm5vRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArIGVjbHMubGVuZ3RoICogKG91dC5zaGFwZUhlaWdodCArIG91dC5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtYXAubm9EYXRhRmlsbFN0eWxlXylcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIHVuaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgLy8nbm8gZGF0YScgbGFiZWxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQubm9EYXRhVGV4dClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHBhdHRlcm4gZmlsbCBsZWdlbmQgaXRlbXMgQkVMT1cgdGhlIG1haW4gbGVnZW5kXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBjaG9yb3BsZXRoIGxlZ2VuZCBib3hcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gb3V0LmxnZy5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodFxyXG4gICAgICAgICAgICBhcHBlbmRQYXR0ZXJuRmlsbExlZ2VuZChtYXAsIG91dC5sZ2csIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlV2lkdGg6IG91dC5zaGFwZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgc2hhcGVIZWlnaHQ6IG91dC5zaGFwZUhlaWdodCxcclxuICAgICAgICAgICAgICAgIGxhYmVsT2Zmc2V0OiBvdXQubGFiZWxPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBib3hQYWRkaW5nOiBvdXQuYm94UGFkZGluZyxcclxuICAgICAgICAgICAgICAgIG9mZnNldFk6IGxlZ2VuZEhlaWdodCArIG91dC5ib3hQYWRkaW5nICsgNSwgLy8gPDwgdGhpcyBzaGlmdHMgcGF0dGVybiBsZWdlbmQgZG93blxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIG91dC5zZXRCb3hEaW1lbnNpb24oKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHJlZ2lvbnMgdG8gd2hpdGVcclxuICAgICAgICBhbGxSZWdpb25zLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWdpb25zID0gYWxsUmVnaW9ucy5maWx0ZXIoXCJbZWNsPSdcIiArIGVjbCArIFwiJ11cIilcclxuICAgICAgICBzZWxlY3RlZFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHJlZ2lvbnNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCByZWdpb25zIHRvIHRoZWlyIG9yaWdpbmFsIGNvbG9ycyBvbiBtb3VzZW91dFxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKCdbZWNsXScpXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCByZWdpb24ncyBvcmlnaW5hbCBjb2xvciBmcm9tIHRoZSBmaWxsX19fIGF0dHJpYnV0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgbGluZSB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgY2hvcm9wbGV0aC1iaXZhcmlhdGUgbWFwc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vc2l6ZVxyXG4gICAgb3V0LnNxdWFyZVNpemUgPSAxMDBcclxuXHJcbiAgICAvL29yaWVudGF0aW9uXHJcbiAgICBvdXQucm90YXRpb24gPSAwXHJcblxyXG4gICAgLy9sYWJlbHNcclxuICAgIG91dC5sYWJlbDEgPSAnVmFyaWFibGUgMSdcclxuICAgIG91dC5sYWJlbDIgPSAnVmFyaWFibGUgMidcclxuXHJcbiAgICAvL2dldCB0aGUgZm9udCBzaXplIG9mIHRoZSB0ZXh0c1xyXG4gICAgb3V0LmF4aXNUaXRsZUZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlJylcclxuXHJcbiAgICAvL2JyZWFrc1xyXG4gICAgb3V0LmJyZWFrczEgPSB1bmRlZmluZWRcclxuICAgIG91dC5icmVha3MyID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuc2hvd0JyZWFrcyA9IGZhbHNlIC8vIGlmIHNldCB0byB0cnVlIGFuZCBicmVha3MxIGFuZCBicmVha3MyIGFyZSB1bmRlZmluZWQgdGhlbiBicmVha3MgYXJlIGF1dG9tYXRpY2FsbHkgZGVmaW5lZFxyXG4gICAgb3V0LnRpY2tMZW5ndGggPSA1IC8vIGxlbmd0aCBvZiB0aGUgdGlja3NcclxuXHJcbiAgICAvL2F4aXNcclxuICAgIG91dC55QXhpc0xhYmVsc09mZnNldCA9IHsgeDogMCwgeTogMCB9XHJcbiAgICBvdXQueEF4aXNMYWJlbHNPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfVxyXG5cclxuICAgIC8vYXhpcyB0aXRsZXNcclxuICAgIG91dC55QXhpc1RpdGxlT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH1cclxuICAgIG91dC54QXhpc1RpdGxlT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH1cclxuXHJcbiAgICAvL3Nob3cgbm8gZGF0YVxyXG4gICAgb3V0Lm5vRGF0YSA9IHRydWVcclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhU2hhcGVIZWlnaHQgPSAyMFxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlV2lkdGggPSAyNVxyXG5cclxuICAgIC8vbm8gZGF0YSB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubm9EYXRhVGV4dCA9ICdObyBkYXRhJ1xyXG5cclxuICAgIC8vb3ZlcnJpZGUgcGFkZGluZ1xyXG4gICAgb3V0LmJveFBhZGRpbmcgPSBvdXQubGFiZWxGb250U2l6ZVxyXG5cclxuICAgIC8vYWRkIGV4dHJhIGRpc3RhbmNlIGJldHdlZW4gbGVnZW5kIGFuZCBubyBkYXRhIGl0ZW1cclxuICAgIG91dC5ub0RhdGFZT2Zmc2V0ID0gMzBcclxuXHJcbiAgICAvL2Fycm93c1xyXG4gICAgb3V0LmF4aXNBcnJvd3MgPSB0cnVlIC8vIGlmIHNldCB0byB0cnVlLCBhcnJvd3MgYXJlIGRyYXduIGF0IHRoZSBlbmQgb2YgdGhlIGF4ZXNcclxuICAgIG91dC5hcnJvd0hlaWdodCA9IDE1XHJcbiAgICBvdXQuYXJyb3dXaWR0aCA9IDE0XHJcbiAgICBvdXQuYXJyb3dQYWRkaW5nID0gMTAgLy8gcGFkZGluZyBiZXR3ZWVuIGFycm93IGFuZCBheGlzIGxhYmVsXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICAvLyBIb3Jpem9udGFsIHNoaWZ0IHRvIG1vdmUgZXZlcnl0aGluZyByaWdodCAoYWRqdXN0IHRoaXMgdmFsdWUgYXMgbmVlZGVkKVxyXG4gICAgICAgIG91dC5faG9yaXpvbnRhbE9mZnNldCA9IG91dC5heGlzVGl0bGVGb250U2l6ZSArIG91dC5hcnJvd1BhZGRpbmcgLy8gQWRqdXN0IHRoaXMgdmFsdWUgdG8gbW92ZSB0aGUgd2hvbGUgbGVnZW5kIHRvIHRoZSByaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIG91dC5sZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vIERyYXcgdGl0bGVcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5sZ2dcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHhjICsgb3V0Ll9ob3Jpem9udGFsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgIG91dC5feSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKVxyXG5cclxuICAgICAgICAvLyBTcXVhcmUgZ3JvdXAgd2l0aCBob3Jpem9udGFsIG9mZnNldFxyXG4gICAgICAgIGFkZFNxdWFyZXMoKVxyXG5cclxuICAgICAgICAvLyBzZXQgYnJlYWtzIGlmIHVzZXIgaGFzbnQgZGVmaW5lZCB0aGVtIGJ1dCBoYXMgZW5hYmxlZCB0aGVtXHJcbiAgICAgICAgaWYgKCFvdXQuYnJlYWtzMSAmJiAhb3V0LmJyZWFrczIgJiYgb3V0LnNob3dCcmVha3MpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHF1YW50aWxlcyBmb3IgdGhlIGZpcnN0IHZhcmlhYmxlIChYIGF4aXMpIGFuZCB0cnVuY2F0ZSB0byBvbmUgZGVjaW1hbCBwbGFjZVxyXG4gICAgICAgICAgICBvdXQuYnJlYWtzMSA9IG1hcC5jbGFzc2lmaWVyMV8ucXVhbnRpbGVzKCkubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDApKSlcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBxdWFudGlsZXMgZm9yIHRoZSBzZWNvbmQgdmFyaWFibGUgKFkgYXhpcykgYW5kIHRydW5jYXRlIHRvIG9uZSBkZWNpbWFsIHBsYWNlXHJcbiAgICAgICAgICAgIG91dC5icmVha3MyID0gbWFwLmNsYXNzaWZpZXIyXy5xdWFudGlsZXMoKS5tYXAoKHZhbHVlKSA9PiBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQoMCkpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBicmVha3MgbGFiZWxzIDEgKFggYXhpcylcclxuICAgICAgICBhZGRCcmVha0xhYmVscygpXHJcblxyXG4gICAgICAgIG91dC5feEF4aXNBcnJvd1kgPSAwXHJcbiAgICAgICAgb3V0Ll95QXhpc0Fycm93WCA9IDBcclxuICAgICAgICBpZiAob3V0LmF4aXNBcnJvd3MpIHtcclxuICAgICAgICAgICAgYWRkQXhpc0Fycm93cygpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGRBeGlzVGl0bGVzKClcclxuXHJcbiAgICAgICAgLy8gQXJyb3cgZGVmc1xyXG4gICAgICAgIG91dC5sZ2dcclxuICAgICAgICAgICAgLmFwcGVuZCgnZGVmcycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ21hcmtlcicpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYDAgMCAke291dC5hcnJvd1dpZHRofSAke291dC5hcnJvd0hlaWdodH1gKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnYXJyb3doZWFkJylcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlgnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigncmVmWScsIDUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIG91dC5hcnJvd1dpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0Jywgb3V0LmFycm93SGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTSAwIDAgTCA1IDUgTCAwIDEwJylcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlci11bml0cycsICdzdHJva2VXaWR0aCcpXHJcblxyXG4gICAgICAgIC8vICdObyBkYXRhJyBsZWdlbmQgYm94XHJcbiAgICAgICAgaWYgKG91dC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgYWRkTm9EYXRhRWxlbWVudCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTm9EYXRhRWxlbWVudCgpIHtcclxuICAgICAgICBjb25zdCBub0RhdGFZT2Zmc2V0ID1cclxuICAgICAgICAgICAgb3V0LnJvdGF0aW9uID09PSAwID8gb3V0Lm5vRGF0YVlPZmZzZXQgKyBvdXQuc3F1YXJlU2l6ZSAvIG91dC5tYXAubnVtYmVyT2ZDbGFzc2VzXyArIG91dC5hcnJvd0hlaWdodCAvIDIgOiBvdXQubm9EYXRhWU9mZnNldFxyXG5cclxuICAgICAgICBsZXQgbm9EYXRhWSA9XHJcbiAgICAgICAgICAgIG91dC5yb3RhdGlvbiA9PT0gMCA/IG91dC5feSArIG91dC5zcXVhcmVTaXplICsgbm9EYXRhWU9mZnNldCA6IG91dC5feSArIDEuNDE0MiAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmcgKiAyICsgbm9EYXRhWU9mZnNldFxyXG5cclxuICAgICAgICBvdXQubGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLW5vZGF0YScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQubm9EYXRhU2hhcGVXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgbm9EYXRhWSArIChvdXQucm90YXRpb24gPT0gMCA/IDAgOiAtMTApKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQubm9EYXRhU2hhcGVXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5ub0RhdGFTaGFwZUhlaWdodClcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgb3V0Lm1hcC5ub0RhdGFGaWxsU3R5bGUoKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25zID0gb3V0Lm1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcgPyBzZWxlY3RBbGwoJyNlbS1udXRzcmcnKSA6IHNlbGVjdCgnI2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSByZWdpb25zLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgJ3JlZCcpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuUmcgPSBvdXQubWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJyA/IHNlbGVjdEFsbCgnI2VtLW51dHNyZycpIDogc2VsZWN0KCcjZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IG5SZy5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIilcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIG91dC5tYXAubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgb3V0LmxnZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1ub2RhdGEtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0Lm5vRGF0YVNoYXBlV2lkdGggKyAob3V0Lm5vRGF0YVNoYXBlV2lkdGggLyAyICsgNSkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgbm9EYXRhWSArIG91dC5ub0RhdGFTaGFwZUhlaWdodCAqIDAuNSArIDEgKyAob3V0LnJvdGF0aW9uID09IDAgPyAwIDogLTEwKSlcclxuICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkU3F1YXJlcygpIHtcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDbGFzc2VzID0gb3V0Lm1hcC5udW1iZXJPZkNsYXNzZXMoKVxyXG4gICAgICAgIGNvbnN0IHN6ID0gb3V0LnNxdWFyZVNpemUgLyBudW1iZXJPZkNsYXNzZXNcclxuICAgICAgICBjb25zdCB4YyA9IG91dC5yb3RhdGlvbiA9PT0gMCA/IDAgOiAwLjcwNzEgKiBvdXQuc3F1YXJlU2l6ZSArIG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFggPSAwXHJcblxyXG4gICAgICAgIGNvbnN0IHNxdWFyZSA9IGxnZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JpdmFyaWF0ZS1zcXVhcmVzLWNoYXJ0JylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgICAgICAgIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZyArIG91dC5faG9yaXpvbnRhbE9mZnNldH0sJHt4YyArIG91dC5feX0pIHJvdGF0ZSgke291dC5yb3RhdGlvbn0pIHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nfSwwKWBcclxuICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAvLyBEcmF3IHJlY3RhbmdsZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2xhc3NlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtYmVyT2ZDbGFzc2VzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBudW1iZXJPZkNsYXNzZXMgLSBpIC0gMVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsMiA9IG51bWJlck9mQ2xhc3NlcyAtIGogLSAxXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsID0gb3V0Lm1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoZWNsMSwgZWNsMilcclxuXHJcbiAgICAgICAgICAgICAgICBzcXVhcmVcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXNxdWFyZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBpbml0aWFsWCArIChudW1iZXJPZkNsYXNzZXMgLSAxIC0gaSkgKiBzeilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGogKiBzeilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzeilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc3opXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZmlsbClcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wxLCBlY2wyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbDEsIGVjbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnJhaXNlKCkgLy8gcmFpc2UgbGVnZW5kIHNxdWFyZSB0byBhdm9pZCBzdHJva2UgaXNzdWVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgZWNsMSwgZWNsMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZyYW1lXHJcbiAgICAgICAgc3F1YXJlXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWZyYW1lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBpbml0aWFsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc3F1YXJlU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zcXVhcmVTaXplKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC43KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEJyZWFrTGFiZWxzKCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0gb3V0LnJvdGF0aW9uID09PSAwID8gMCA6IDAuNzA3MSAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBjb25zdCBpbml0aWFsWCA9IDBcclxuICAgICAgICBjb25zdCBudW1iZXJPZkNsYXNzZXMgPSBvdXQubWFwLm51bWJlck9mQ2xhc3NlcygpXHJcbiAgICAgICAgY29uc3Qgc3ogPSBvdXQuc3F1YXJlU2l6ZSAvIG51bWJlck9mQ2xhc3Nlc1xyXG5cclxuICAgICAgICAvLyBncm91cCB3aXRoIGhvcml6b250YWwgb2Zmc2V0XHJcbiAgICAgICAgY29uc3QgYnJlYWtMYWJlbHMgPSBvdXQubGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYml2YXJpYXRlLWJyZWFrLWxhYmVscycpXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICAgICAgICBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmcgKyBvdXQuX2hvcml6b250YWxPZmZzZXR9LCR7eGMgKyBvdXQuX3l9KSByb3RhdGUoJHtvdXQucm90YXRpb259KSB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZ30sMClgXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBpZiAob3V0LmJyZWFrczEpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuYnJlYWtzMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGluaXRpYWxYICsgc3ogKiAoaSArIDEpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gb3V0LnNxdWFyZVNpemUgKyBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrTGFiZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHggKyBvdXQueEF4aXNMYWJlbHNPZmZzZXQueClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQueEF4aXNMYWJlbHNPZmZzZXQueSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQuYnJlYWtzMVtpXSlcclxuXHJcbiAgICAgICAgICAgICAgICBicmVha0xhYmVsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtdGljaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIG91dC5zcXVhcmVTaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zcXVhcmVTaXplICsgb3V0LnRpY2tMZW5ndGgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgYnJlYWtzIGxhYmVscyAyIChZIGF4aXMpXHJcbiAgICAgICAgaWYgKG91dC5icmVha3MyKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LmJyZWFrczIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBpbml0aWFsWFxyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHN6ICogKGkgKyAyKSAtIHN6XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWtMYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeCArIG91dC55QXhpc0xhYmVsc09mZnNldC54KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSAtIG91dC55QXhpc0xhYmVsc09mZnNldC55IC0gKG91dC50aWNrTGVuZ3RoICsgMikpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoWy4uLm91dC5icmVha3MyXS5yZXZlcnNlKClbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGByb3RhdGUoLTkwLCAke3h9LCAke3l9KWApXHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWtMYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCAtIG91dC50aWNrTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRBeGlzVGl0bGVzKCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0gb3V0LnJvdGF0aW9uID09PSAwID8gMCA6IDAuNzA3MSAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBjb25zdCBpbml0aWFsWCA9IDBcclxuXHJcbiAgICAgICAgY29uc3QgYXhpc1RpdGxlcyA9IG91dC5sZ2dcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdiaXZhcmlhdGUtYXhpcy10aXRsZXMnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICAgICAgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nICsgb3V0Ll9ob3Jpem9udGFsT2Zmc2V0fSwke3hjICsgb3V0Ll95fSkgcm90YXRlKCR7b3V0LnJvdGF0aW9ufSkgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmd9LDApYFxyXG4gICAgICAgICAgICApXHJcblxyXG4gICAgICAgIC8vIFggYXhpcyB0aXRsZVxyXG4gICAgICAgIGxldCB4QXhpc1RpdGxlWSA9IG91dC5zcXVhcmVTaXplICsgb3V0LnhBeGlzTGFiZWxzT2Zmc2V0LnkgKyAob3V0LmF4aXNBcnJvd3MgPyBvdXQuYXJyb3dQYWRkaW5nICsgb3V0LmFycm93SGVpZ2h0IDogNylcclxuICAgICAgICBsZXQgeEF4aXNUaXRsZVggPSBpbml0aWFsWFxyXG4gICAgICAgIGlmIChvdXQuc2hvd0JyZWFrcyB8fCAob3V0LmJyZWFrczEgJiYgb3V0LmJyZWFrczIpKSB4QXhpc1RpdGxlWSArPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKSAvLyBtb3ZlIG92ZXIgZm9yIHRpY2sgbGFiZWxzXHJcbiAgICAgICAgaWYgKG91dC54QXhpc1RpdGxlT2Zmc2V0KSB4QXhpc1RpdGxlWSArPSBvdXQueEF4aXNUaXRsZU9mZnNldC55XHJcbiAgICAgICAgaWYgKG91dC54QXhpc1RpdGxlT2Zmc2V0KSB4QXhpc1RpdGxlWCArPSBvdXQueEF4aXNUaXRsZU9mZnNldC54XHJcbiAgICAgICAgYXhpc1RpdGxlc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlIGVtLWJpdmFyaWF0ZS1heGlzLXRpdGxlLXgnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHhBeGlzVGl0bGVYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHhBeGlzVGl0bGVZKVxyXG4gICAgICAgICAgICAudGV4dChvdXQubGFiZWwxKVxyXG4gICAgICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXHJcblxyXG4gICAgICAgIC8vIFkgYXhpcyB0aXRsZVxyXG4gICAgICAgIGxldCB5QXhpc1RpdGxlWSA9IChvdXQuYXhpc0Fycm93cyA/IG91dC5feUF4aXNBcnJvd1ggLSBvdXQuYXJyb3dQYWRkaW5nIDogNykgKyAob3V0LnJvdGF0aW9uID09IC00NSA/IC00IDogLTEwKSAvLyBhZGp1c3QgZm9yIHJvdGF0aW9uXHJcbiAgICAgICAgaWYgKG91dC5zaG93QnJlYWtzIHx8IChvdXQuYnJlYWtzMSAmJiBvdXQuYnJlYWtzMikpIHhBeGlzVGl0bGVZICs9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1iaXZhcmlhdGUtdGljay1sYWJlbCcpIC8vIG1vdmUgb3ZlciBmb3IgdGljayBsYWJlbHNcclxuICAgICAgICBsZXQgeUF4aXNUaXRsZVggPSAtb3V0LnNxdWFyZVNpemVcclxuICAgICAgICAvL21hbnVhbCBvZmZzZXRzXHJcbiAgICAgICAgaWYgKG91dC55QXhpc1RpdGxlT2Zmc2V0KSB5QXhpc1RpdGxlWSArPSBvdXQueUF4aXNUaXRsZU9mZnNldC55XHJcbiAgICAgICAgaWYgKG91dC55QXhpc1RpdGxlT2Zmc2V0KSB5QXhpc1RpdGxlWCArPSBvdXQueUF4aXNUaXRsZU9mZnNldC54XHJcbiAgICAgICAgYXhpc1RpdGxlc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlIGVtLWJpdmFyaWF0ZS1heGlzLXRpdGxlLXknKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHlBeGlzVGl0bGVYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHlBeGlzVGl0bGVZKVxyXG4gICAgICAgICAgICAudGV4dChvdXQubGFiZWwyKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsIG91dC5yb3RhdGlvbiA8IDAgPyBgdHJhbnNsYXRlKCR7b3V0LmF4aXNBcnJvd3MgPyAtNTEgOiAtMTV9cHgsIDk1cHgpIHJvdGF0ZSg5MGRlZylgIDogJ3JvdGF0ZSgtOTBkZWcpJylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRBeGlzQXJyb3dzKCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0gb3V0LnJvdGF0aW9uID09PSAwID8gMCA6IDAuNzA3MSAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBjb25zdCBpbml0aWFsWCA9IDBcclxuXHJcbiAgICAgICAgLy8gZ3JvdXAgd2l0aCBob3Jpem9udGFsIG9mZnNldFxyXG4gICAgICAgIGNvbnN0IGF4aXNBcnJvd3MgPSBvdXQubGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYml2YXJpYXRlLWF4aXMtYXJyb3dzJylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgICAgICAgIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZyArIG91dC5faG9yaXpvbnRhbE9mZnNldH0sJHt4YyArIG91dC5feX0pIHJvdGF0ZSgke291dC5yb3RhdGlvbn0pIHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nfSwwKWBcclxuICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgWCBheGlzIGFycm93XHJcbiAgICAgICAgb3V0Ll94QXhpc0Fycm93WSA9IG91dC5zcXVhcmVTaXplICsgb3V0LnRpY2tMZW5ndGggKyBvdXQuYXJyb3dQYWRkaW5nXHJcbiAgICAgICAgaWYgKG91dC5zaG93QnJlYWtzIHx8IChvdXQuYnJlYWtzMSAmJiBvdXQuYnJlYWtzMikpIG91dC5feEF4aXNBcnJvd1kgKz0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJykgLyAxLjUgLy8gbW92ZSBvdmVyIGZvciB0aWNrIGxhYmVsc1xyXG5cclxuICAgICAgICBheGlzQXJyb3dzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWF4aXMtYXJyb3cnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdkJyxcclxuICAgICAgICAgICAgICAgIGxpbmUoKShbXHJcbiAgICAgICAgICAgICAgICAgICAgW2luaXRpYWxYLCBvdXQuX3hBeGlzQXJyb3dZXSxcclxuICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbFggKyBvdXQuc3F1YXJlU2l6ZSwgb3V0Ll94QXhpc0Fycm93WV0sXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgWSBheGlzIGFycm93XHJcbiAgICAgICAgb3V0Ll95QXhpc0Fycm93WCA9IC1vdXQudGlja0xlbmd0aCAtIG91dC5hcnJvd1BhZGRpbmdcclxuICAgICAgICBpZiAob3V0LnNob3dCcmVha3MgfHwgKG91dC5icmVha3MxICYmIG91dC5icmVha3MyKSkgb3V0Ll95QXhpc0Fycm93WCAtPSBvdXQubGFiZWxGb250U2l6ZSAvIDIgLy8gbW92ZSBvdmVyIGZvciB0aWNrIGxhYmVsc1xyXG5cclxuICAgICAgICBheGlzQXJyb3dzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWF4aXMtYXJyb3cnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdkJyxcclxuICAgICAgICAgICAgICAgIGxpbmUoKShbXHJcbiAgICAgICAgICAgICAgICAgICAgW291dC5feUF4aXNBcnJvd1gsIG91dC5zcXVhcmVTaXplXSxcclxuICAgICAgICAgICAgICAgICAgICBbb3V0Ll95QXhpc0Fycm93WCwgMF0sXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpZ2hsaWdodCBzZWxlY3RlZCByZWdpb25zIG9uIG1vdXNlb3ZlclxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGVjbDEsIGVjbDIpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKGBbZWNsMV1gKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHJlZ2lvbnMgdG8gd2hpdGVcclxuICAgICAgICBhbGxSZWdpb25zLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWdpb25zID0gYWxsUmVnaW9ucy5maWx0ZXIoYFtlY2wxPScke2VjbDF9J11gKS5maWx0ZXIoYFtlY2wyPScke2VjbDJ9J11gKVxyXG4gICAgICAgIHNlbGVjdGVkUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChgW2VjbDFdYClcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4IH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgY2hvcm9wbGV0aC10cml2YXJpYXRlIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vIERlZmF1bHQgc2V0dGluZ3NcclxuICAgIG91dC53aWR0aCA9IDIzMFxyXG4gICAgb3V0LmhlaWdodCA9IDIzMFxyXG5cclxuICAgIG91dC5sYWJlbDEgPSAnVmFyaWFibGUgMSdcclxuICAgIG91dC5sYWJlbDIgPSAnVmFyaWFibGUgMidcclxuICAgIG91dC5sYWJlbDMgPSAnVmFyaWFibGUgMycgLy8gQWRkIGEgbGFiZWwgZm9yIHRoZSB0aGlyZCB2YXJpYWJsZVxyXG4gICAgb3V0LmF4aXNUaXRsZUZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlJylcclxuICAgIG91dC5zaG93QnJlYWtzID0gZmFsc2VcclxuICAgIG91dC5ub0RhdGEgPSB0cnVlXHJcbiAgICBvdXQubm9EYXRhU2hhcGVIZWlnaHQgPSAyMFxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlV2lkdGggPSAyNVxyXG4gICAgb3V0Lm5vRGF0YVRleHQgPSAnTm8gZGF0YSdcclxuICAgIG91dC5ib3hQYWRkaW5nID0gNjAgLy8gZGVwZW5kcyBvbiB2YXJpYWJsZSAxIGxhYmVsIGxlbmd0aCByZWFsbHlcclxuICAgIG91dC5ub0RhdGFZT2Zmc2V0ID0gMjBcclxuICAgIG91dC5hcnJvd0hlaWdodCA9IDE1XHJcbiAgICBvdXQuYXJyb3dXaWR0aCA9IDE0XHJcbiAgICBvdXQuYXJyb3dQYWRkaW5nID0gMTBcclxuXHJcbiAgICBpZiAoY29uZmlnKSBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZSB0aGUgdXBkYXRlIG1ldGhvZCB0byBoYW5kbGUgdHJpdmFyaWF0ZSBsZWdlbmRzXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcbiAgICAgICAgY29uc3QgbGdnID0gb3V0LmxnZ1xyXG4gICAgICAgIGNvbnN0IG51bWJlck9mQ2xhc3NlcyA9IG91dC5tYXAubnVtYmVyT2ZDbGFzc2VzKClcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHBhZGRpbmcgdG8gdGhlIG1haW4gPGc+IGdyb3VwXHJcbiAgICAgICAgY29uc3QgcGFkZGVkR3JvdXAgPSBsZ2cuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nfSwgJHtvdXQuYm94UGFkZGluZ30pYClcclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIHtcclxuICAgICAgICAgICAgcGFkZGVkR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApIC8vIFN0YXJ0IGF0IDAgd2l0aGluIHRoZSBwYWRkZWQgZ3JvdXBcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnRpdGxlRm9udFNpemUpIC8vIFZlcnRpY2FsIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSB0cml2YXJpYXRlIFZlbm4gZGlhZ3JhbVxyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IFtvdXQubGFiZWwxLCBvdXQubGFiZWwyLCBvdXQubGFiZWwzXVxyXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IFtvdXQubWFwLmNvbG9yMV8sIG91dC5tYXAuY29sb3IyXywgb3V0Lm1hcC5jb2xvcjNfXVxyXG5cclxuICAgICAgICBkcmF3VHJpdmFyaWF0ZVZlbm5EaWFncmFtKHBhZGRlZEdyb3VwLCBjb2xvcnMsIGxhYmVscylcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHRyaXZhcmlhdGUgKFZlbm4gRGlhZ3JhbSkgb3IgYml2YXJpYXRlIChncmlkKSBsZWdlbmRcclxuICAgICAgICAvLyBpZiAobnVtYmVyT2ZDbGFzc2VzID09PSA3KSB7XHJcbiAgICAgICAgLy8gICAgIGRyYXdUcml2YXJpYXRlVmVubkRpYWdyYW0obGdnLCBvdXQpXHJcbiAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgZHJhd1RyaXZhcmlhdGVUZXJuYXJ5UGxvdChsZ2csIG91dCwgbnVtYmVyT2ZDbGFzc2VzKVxyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdUcml2YXJpYXRlVmVubkRpYWdyYW0oY29udGFpbmVyLCBjb2xvcnMsIGxhYmVscykge1xyXG4gICAgLy9zcGVjcyBmb3IgQ2lyY2xlIDFcclxuICAgIGNvbnN0IHhDZW50ZXIxID0gNTBcclxuICAgIGNvbnN0IHlDZW50ZXIxID0gNTBcclxuICAgIGNvbnN0IGNpcmNsZVJhZCA9IDMwXHJcblxyXG4gICAgLy9kcmF3IENpcmNsZSAxXHJcbiAgICAvLyBjb25zdCBjaXJjbGUxID0gY29udGFpbmVyXHJcbiAgICAvLyAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgIC8vICAgICAuYXR0cigncicsIGNpcmNsZVJhZClcclxuICAgIC8vICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeENlbnRlcjEgKyAnLCcgKyB5Q2VudGVyMSArICcpJylcclxuXHJcbiAgICAvL2FkZCdsIHNwZWNzIGZvciBDaXJjbGUgMlxyXG4gICAgY29uc3Qgb2Zmc2V0RmFjdG9yID0gMS4yXHJcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRGYWN0b3IgKiBjaXJjbGVSYWRcclxuICAgIGNvbnN0IHhDZW50ZXIyID0geENlbnRlcjEgKyBvZmZzZXRcclxuICAgIGNvbnN0IHlDZW50ZXIyID0geUNlbnRlcjEgLy9jcmVhdGluZyBuZXcgdmFyIGZvciBjbGFyaXR5XHJcblxyXG4gICAgLy9kcmF3IENpcmNsZSAyXHJcbiAgICAvLyBjb25zdCBjaXJjbGUyID0gY29udGFpbmVyXHJcbiAgICAvLyAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgIC8vICAgICAuYXR0cigncicsIGNpcmNsZVJhZClcclxuICAgIC8vICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeENlbnRlcjIgKyAnLCcgKyB5Q2VudGVyMiArICcpJylcclxuXHJcbiAgICAvL2FkZCdsIHNwZWNzIGZvciBDaXJjbGUgM1xyXG4gICAgY29uc3QgeENlbnRlcjMgPSB4Q2VudGVyMSArIG9mZnNldCAvIDJcclxuICAgIGNvbnN0IHlDZW50ZXIzID0geUNlbnRlcjEgKyAoTWF0aC5zcXJ0KDMpICogb2Zmc2V0KSAvIDJcclxuXHJcbiAgICAvL2RyYXcgQ2lyY2xlIDNcclxuICAgIC8vIGNvbnN0IGNpcmNsZTMgPSBjb250YWluZXJcclxuICAgIC8vICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgLy8gICAgIC5hdHRyKCdyJywgY2lyY2xlUmFkKVxyXG4gICAgLy8gICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4Q2VudGVyMyArICcsJyArIHlDZW50ZXIzICsgJyknKVxyXG5cclxuICAgIC8vY29tcHV0ZSBmaXJzdCBwb2ludHMgb2YgaW50ZXJzZWN0aW9uXHJcbiAgICBjb25zdCB0cmlIZWlnaHQgPSBNYXRoLnNxcnQoY2lyY2xlUmFkICoqIDIgLSAob2Zmc2V0IC8gMikgKiogMilcclxuICAgIC8vb3V0ZXIgaW50ZXJzZWN0aW9uIG9mIENpcmNsZXMgMSBhbmQgMlxyXG4gICAgY29uc3QgeElzZWN0MSA9IHhDZW50ZXIzXHJcbiAgICBjb25zdCB5SXNlY3QxID0geUNlbnRlcjEgLSB0cmlIZWlnaHRcclxuICAgIC8vaW5uZXIgaW50ZXJzZWN0aW9uIG9mIENpcmNsZXMgMSBhbmQgMlxyXG4gICAgY29uc3QgeElzZWN0NCA9IHhDZW50ZXIzXHJcbiAgICBjb25zdCB5SXNlY3Q0ID0geUNlbnRlcjEgKyB0cmlIZWlnaHRcclxuXHJcbiAgICAvL3RyZWF0IFwidHJpSGVpZ2h0XCIgYXMgdGhlIGh5cG90ZW5ldXNlIG9mIGEgMzAuNjAuOTAgdHJpYW5nbGUuXHJcbiAgICAvL3RoaXMgdGVsbHMgdXMgdGhlIHNoaWZ0IGZyb20gdGhlIG1pZHBvaW50IG9mIGEgbGVnIG9mIHRoZSB0cmlhbmdsZVxyXG4gICAgLy90byB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXHJcbiAgICBjb25zdCB4RGVsdGEgPSAodHJpSGVpZ2h0ICogTWF0aC5zcXJ0KDMpKSAvIDJcclxuICAgIGNvbnN0IHlEZWx0YSA9IHRyaUhlaWdodCAvIDJcclxuXHJcbiAgICBjb25zdCB4TWlkcG9pbnRDMUMzID0gKHhDZW50ZXIxICsgeENlbnRlcjMpIC8gMlxyXG4gICAgY29uc3QgeE1pZHBvaW50QzJDMyA9ICh4Q2VudGVyMiArIHhDZW50ZXIzKSAvIDJcclxuICAgIGNvbnN0IHlNaWRwb2ludEJvdGggPSAoeUNlbnRlcjEgKyB5Q2VudGVyMykgLyAyXHJcblxyXG4gICAgLy9maW5kIHRoZSByZXN0IG9mIHRoZSBwb2ludHMgb2YgaW50ZXJzZWN0aW9uXHJcbiAgICBjb25zdCB4SXNlY3QyID0geE1pZHBvaW50QzFDMyAtIHhEZWx0YVxyXG4gICAgY29uc3QgeUlzZWN0MiA9IHlNaWRwb2ludEJvdGggKyB5RGVsdGFcclxuICAgIGNvbnN0IHhJc2VjdDMgPSB4TWlkcG9pbnRDMkMzICsgeERlbHRhXHJcbiAgICBjb25zdCB5SXNlY3QzID0geU1pZHBvaW50Qm90aCArIHlEZWx0YVxyXG5cclxuICAgIGNvbnN0IHhJc2VjdDUgPSB4TWlkcG9pbnRDMUMzICsgeERlbHRhXHJcbiAgICBjb25zdCB5SXNlY3Q1ID0geU1pZHBvaW50Qm90aCAtIHlEZWx0YVxyXG4gICAgY29uc3QgeElzZWN0NiA9IHhNaWRwb2ludEMyQzMgLSB4RGVsdGFcclxuICAgIGNvbnN0IHlJc2VjdDYgPSB5TWlkcG9pbnRCb3RoIC0geURlbHRhXHJcblxyXG4gICAgY29uc3QgeFBvaW50cyA9IFt4SXNlY3QxLCB4SXNlY3QyLCB4SXNlY3QzLCB4SXNlY3Q0LCB4SXNlY3Q1LCB4SXNlY3Q2XVxyXG4gICAgY29uc3QgeVBvaW50cyA9IFt5SXNlY3QxLCB5SXNlY3QyLCB5SXNlY3QzLCB5SXNlY3Q0LCB5SXNlY3Q1LCB5SXNlY3Q2XVxyXG5cclxuICAgIGNvbnN0IG1ha2VJcm9uU2hhcGVzID0gKFt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBgTSAke3gxfSAke3kxfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAxICR7eDJ9ICR7eTJ9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDAgJHt4M30gJHt5M31cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMSAke3gxfSAke3kxfWBcclxuICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ha2VTdW5TaGFwZXMgPSAoW3gxLCB4MiwgeDMsIHkxLCB5MiwgeTNdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGBNICR7eDF9ICR7eTF9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDAgJHt4Mn0gJHt5Mn1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMCAke3gzfSAke3kzfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMSAxICR7eDF9ICR7eTF9YFxyXG4gICAgICAgIHJldHVybiBwYXRoXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWFrZVJvdW5kZWRUcmkgPSAoW3gxLCB4MiwgeDMsIHkxLCB5MiwgeTNdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGBNICR7eDF9ICR7eTF9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDEgJHt4Mn0gJHt5Mn1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMSAke3gzfSAke3kzfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAxICR7eDF9ICR7eTF9YFxyXG4gICAgICAgIHJldHVybiBwYXRoXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXJvblBvaW50cyA9IFtcclxuICAgICAgICBbMSwgNSwgNl0sXHJcbiAgICAgICAgWzMsIDQsIDVdLFxyXG4gICAgICAgIFsyLCA2LCA0XSxcclxuICAgIF1cclxuICAgIGNvbnN0IHN1blBvaW50cyA9IFtcclxuICAgICAgICBbMywgNSwgMV0sXHJcbiAgICAgICAgWzIsIDQsIDNdLFxyXG4gICAgICAgIFsxLCA2LCAyXSxcclxuICAgIF1cclxuICAgIGNvbnN0IHJvdW5kZWRUcmlQb2ludHMgPSBbWzUsIDQsIDZdXVxyXG5cclxuICAgIC8vIG1haW4gY2lyY2xlcyAocmF3IGNvbG9ycylcclxuICAgIHN1blBvaW50cy5mb3JFYWNoKChwb2ludHMsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHRDeWNsZSA9IHBvaW50cy5tYXAoKGkpID0+IHhQb2ludHNbaSAtIDFdKS5jb25jYXQocG9pbnRzLm1hcCgoaSkgPT4geVBvaW50c1tpIC0gMV0pKVxyXG4gICAgICAgIGNvbnN0IHNoYXBlID0gbWFrZVN1blNoYXBlcyhwdEN5Y2xlKVxyXG5cclxuICAgICAgICBjb250YWluZXIuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHNoYXBlKS5hdHRyKCdjbGFzcycsICdzZWdtZW50JykuYXR0cignZmlsbCcsIGNvbG9yc1tpbmRleF0pLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBmaXJzdCBpbnRlcnNlY3RzIChjb21iaW5hdGlvbiBvZiAyIGNvbG9ycylcclxuICAgIGlyb25Qb2ludHMuZm9yRWFjaCgocG9pbnRzLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHB0Q3ljbGUgPSBwb2ludHMubWFwKChpKSA9PiB4UG9pbnRzW2kgLSAxXSkuY29uY2F0KHBvaW50cy5tYXAoKGkpID0+IHlQb2ludHNbaSAtIDFdKSlcclxuICAgICAgICBjb25zdCBzaGFwZSA9IG1ha2VJcm9uU2hhcGVzKHB0Q3ljbGUpXHJcblxyXG4gICAgICAgIGxldCBjb2xvclxyXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcnNbMl0sIGNvbG9yc1swXV0pIC8vIHBpbmsgKyBjeWFuXHJcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcnNbMV0sIGNvbG9yc1swXV0pIC8vIGN5YW4gKyB5ZWxsb3dcclxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09IDIpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yc1sxXSwgY29sb3JzWzJdXSkgLy8gcGluayArIHllbGxvd1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBzaGFwZSkuYXR0cignY2xhc3MnLCAnc2VnbWVudCcpLmF0dHIoJ2ZpbGwnLCBjb2xvcikuYXR0cignb3BhY2l0eScsIDEpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIG51Y2xldXMgKGNvbWJpbmF0aW9uIG9mIGFsbCAzIGNvbG9ycylcclxuICAgIHJvdW5kZWRUcmlQb2ludHMuZm9yRWFjaCgocG9pbnRzLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHB0Q3ljbGUgPSBwb2ludHMubWFwKChpKSA9PiB4UG9pbnRzW2kgLSAxXSkuY29uY2F0KHBvaW50cy5tYXAoKGkpID0+IHlQb2ludHNbaSAtIDFdKSlcclxuICAgICAgICBjb25zdCBzaGFwZSA9IG1ha2VSb3VuZGVkVHJpKHB0Q3ljbGUpXHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoY29sb3JzKVxyXG5cclxuICAgICAgICBjb250YWluZXIuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHNoYXBlKS5hdHRyKCdjbGFzcycsICdzZWdtZW50JykuYXR0cignZmlsbCcsIGNvbG9yKS5hdHRyKCdvcGFjaXR5JywgMSlcclxuICAgIH0pXHJcblxyXG4gICAgY29udGFpbmVyXHJcbiAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5zZWdtZW50JylcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKCdvcGFjaXR5JywgMC44KS5kdXJhdGlvbig1MDApXHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmF0dHIoJ29wYWNpdHknLCAxKS5kdXJhdGlvbig1MDApXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvLyBsYWJlbCBpbnRlcnNlY3RzXHJcbiAgICBjb25zdCB5T2Zmc2V0ID0gY29udGFpbmVyXHJcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQobGFiZWxzWzBdKVxyXG4gICAgICAgIC5hdHRyKCd4JywgeENlbnRlcjEgLSBjaXJjbGVSYWQgLSAzKVxyXG4gICAgICAgIC5hdHRyKCd5JywgeENlbnRlcjEpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Zlbm4tbGFiZWwnKVxyXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgY29udGFpbmVyXHJcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQobGFiZWxzWzFdKVxyXG4gICAgICAgIC5hdHRyKCd4JywgeENlbnRlcjIgKyBjaXJjbGVSYWQgKyAzKVxyXG4gICAgICAgIC5hdHRyKCd5JywgeUNlbnRlcjIpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Zlbm4tbGFiZWwnKVxyXG4gICAgY29udGFpbmVyXHJcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQobGFiZWxzWzJdKVxyXG4gICAgICAgIC5hdHRyKCd4JywgeENlbnRlcjMpXHJcbiAgICAgICAgLmF0dHIoJ3knLCB5Q2VudGVyMyArIGNpcmNsZVJhZCArIDE1KVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZW5uLWxhYmVsJylcclxuICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIGEgdHJpdmFyaWF0ZSBsZWdlbmQgYXMgYSBWZW5uIERpYWdyYW1cclxuICovXHJcbmZ1bmN0aW9uIGRyYXdUcml2YXJpYXRlVmVubkRpYWdyYW0yKHN2ZywgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgbGFiZWxzLCBjb2xvcnMpIHtcclxuICAgIGNvbnN0IHJhZGl1cyA9IGNvbnRhaW5lcldpZHRoIC8gNSAvLyBSYWRpdXMgb2YgZWFjaCBjaXJjbGVcclxuICAgIGNvbnN0IGNlbnRlclggPSBjb250YWluZXJXaWR0aCAvIDJcclxuICAgIGNvbnN0IGNlbnRlclkgPSBjb250YWluZXJIZWlnaHQgLyAyXHJcbiAgICBjb25zdCBvZmZzZXQgPSByYWRpdXMgLyAxLjVcclxuXHJcbiAgICAvLyBEZWZpbmUgY2lyY2xlIHBvc2l0aW9uc1xyXG4gICAgY29uc3QgY2lyY2xlcyA9IFtcclxuICAgICAgICB7IGlkOiAnY2lyY2xlMScsIGN4OiBjZW50ZXJYIC0gb2Zmc2V0LCBjeTogY2VudGVyWSwgbGFiZWw6IGxhYmVsc1swXSwgY29sb3I6IGNvbG9yc1swXSB9LFxyXG4gICAgICAgIHsgaWQ6ICdjaXJjbGUyJywgY3g6IGNlbnRlclggKyBvZmZzZXQsIGN5OiBjZW50ZXJZLCBsYWJlbDogbGFiZWxzWzFdLCBjb2xvcjogY29sb3JzWzFdIH0sXHJcbiAgICAgICAgeyBpZDogJ2NpcmNsZTMnLCBjeDogY2VudGVyWCwgY3k6IGNlbnRlclkgKyBvZmZzZXQgKiAxLjUsIGxhYmVsOiBsYWJlbHNbMl0sIGNvbG9yOiBjb2xvcnNbMl0gfSxcclxuICAgIF1cclxuXHJcbiAgICAvLyBEcmF3IGNpcmNsZXNcclxuICAgIGNpcmNsZXMuZm9yRWFjaCgoeyBpZCwgY3gsIGN5LCBsYWJlbCwgY29sb3IgfSwgaW5kZXgpID0+IHtcclxuICAgICAgICBzdmcuYXBwZW5kKCdjaXJjbGUnKS5hdHRyKCdpZCcsIGlkKS5hdHRyKCdjeCcsIGN4KS5hdHRyKCdjeScsIGN5KS5hdHRyKCdyJywgcmFkaXVzKS5zdHlsZSgnZmlsbCcsIGNvbG9yKS5zdHlsZSgnb3BhY2l0eScsIDEpXHJcblxyXG4gICAgICAgIC8vIEFkZCBsYWJlbHMgd2l0aCBzcGVjaWZpYyBwb3NpdGlvbmluZ1xyXG4gICAgICAgIGNvbnN0IGxhYmVsWCA9XHJcbiAgICAgICAgICAgIGluZGV4ID09PSAwXHJcbiAgICAgICAgICAgICAgICA/IGN4IC0gcmFkaXVzIC0gMTAgLy8gTGVmdCBvZiB0aGUgZmlyc3QgY2lyY2xlXHJcbiAgICAgICAgICAgICAgICA6IGluZGV4ID09PSAxXHJcbiAgICAgICAgICAgICAgICAgID8gY3ggKyByYWRpdXMgKyAxMCAvLyBSaWdodCBvZiB0aGUgc2Vjb25kIGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgICA6IGN4IC8vIEJlbG93IHRoZSB0aGlyZCBjaXJjbGVcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWxZID0gaW5kZXggPCAyID8gY3kgOiBjeSArIHJhZGl1cyArIDIwIC8vIFNhbWUgeSBmb3IgZmlyc3QgdHdvIGNpcmNsZXMsIGJlbG93IGZvciB0aGUgdGhpcmRcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbGFiZWxYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGxhYmVsWSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgaW5kZXggPCAyID8gKGluZGV4ID09PSAwID8gJ2VuZCcgOiAnc3RhcnQnKSA6ICdtaWRkbGUnKSAvLyBBZGp1c3QgYWxpZ25tZW50XHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZW5uLWxhYmVsJylcclxuICAgICAgICAgICAgLnRleHQobGFiZWwpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIGEgdHJpdmFyaWF0ZSBsZWdlbmQgYXMgYSB0ZXJuYXJ5IHBsb3RcclxuICovXHJcbmZ1bmN0aW9uIGRyYXdUcml2YXJpYXRlVGVybmFyeVBsb3QobGdnLCBvdXQsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgY29uc3Qgc2l6ZSA9IG91dC5zcXVhcmVTaXplIC8vIFNpemUgb2YgdGhlIGxlZ2VuZCBhcmVhXHJcbiAgICBjb25zdCBwYWRkaW5nID0gMjAgLy8gUGFkZGluZyBhcm91bmQgdGhlIHBsb3RcclxuICAgIGNvbnN0IHJhZGl1cyA9IDUgLy8gUmFkaXVzIG9mIGVhY2ggY2xhc3MgcG9pbnRcclxuICAgIGNvbnN0IHRyaWFuZ2xlSGVpZ2h0ID0gKE1hdGguc3FydCgzKSAvIDIpICogc2l6ZVxyXG5cclxuICAgIGNvbnN0IHRlcm5hcnlHcm91cCA9IGxnZ1xyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd0cml2YXJpYXRlLXRlcm5hcnktcGxvdCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZyArIHNpemUgLyAyfSwgJHtvdXQuYm94UGFkZGluZyArIHRyaWFuZ2xlSGVpZ2h0IC8gMn0pYClcclxuXHJcbiAgICAvLyBEcmF3IHRoZSB0cmlhbmdsZVxyXG4gICAgY29uc3QgdmVydGljZXMgPSBbXHJcbiAgICAgICAgeyB4OiAwLCB5OiAtdHJpYW5nbGVIZWlnaHQgLyAyIH0sIC8vIFRvcCB2ZXJ0ZXggKFZhcmlhYmxlIDEpXHJcbiAgICAgICAgeyB4OiAtc2l6ZSAvIDIsIHk6IHRyaWFuZ2xlSGVpZ2h0IC8gMiB9LCAvLyBCb3R0b20tbGVmdCB2ZXJ0ZXggKFZhcmlhYmxlIDIpXHJcbiAgICAgICAgeyB4OiBzaXplIC8gMiwgeTogdHJpYW5nbGVIZWlnaHQgLyAyIH0sIC8vIEJvdHRvbS1yaWdodCB2ZXJ0ZXggKFZhcmlhYmxlIDMpXHJcbiAgICBdXHJcblxyXG4gICAgdGVybmFyeUdyb3VwXHJcbiAgICAgICAgLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgLmF0dHIoJ3BvaW50cycsIHZlcnRpY2VzLm1hcCgoZCkgPT4gYCR7ZC54fSwke2QueX1gKS5qb2luKCcgJykpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcblxyXG4gICAgLy8gTGFiZWwgdGhlIHZlcnRpY2VzXHJcbiAgICBjb25zdCBsYWJlbHMgPSBbb3V0LmxhYmVsMSwgb3V0LmxhYmVsMiwgb3V0LmxhYmVsM11cclxuICAgIHZlcnRpY2VzLmZvckVhY2goKHZlcnRleCwgaSkgPT4ge1xyXG4gICAgICAgIHRlcm5hcnlHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB2ZXJ0ZXgueClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCB2ZXJ0ZXgueSAtIChpID09PSAwID8gMTAgOiAtMjApKSAvLyBPZmZzZXQgbGFiZWxzXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0ZXJuYXJ5LWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsc1tpXSlcclxuICAgIH0pXHJcblxyXG4gICAgLy8gUGxvdCB0aGUgcG9pbnRzIGluc2lkZSB0aGUgdGVybmFyeSBwbG90XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2xhc3NlczsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJPZkNsYXNzZXMgLSBpOyBqKyspIHtcclxuICAgICAgICAgICAgY29uc3QgayA9IG51bWJlck9mQ2xhc3NlcyAtIGkgLSBqIC0gMSAvLyBFbnN1cmUgc3VtIG9mIGkgKyBqICsgayA9IG51bWJlck9mQ2xhc3NlcyAtIDFcclxuICAgICAgICAgICAgY29uc3QgeCA9ICgoaiAtIGspICogc2l6ZSkgLyAoMiAqIChudW1iZXJPZkNsYXNzZXMgLSAxKSkgLy8gSG9yaXpvbnRhbCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjb25zdCB5ID0gKGkgKiAtdHJpYW5nbGVIZWlnaHQpIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpIC8vIFZlcnRpY2FsIHBvc2l0aW9uXHJcblxyXG4gICAgICAgICAgICBjb25zdCBmaWxsID0gb3V0Lm1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoaSwgaiwgaylcclxuXHJcbiAgICAgICAgICAgIHRlcm5hcnlHcm91cFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCByYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGZpbGwpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGksIGosIGspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGksIGosIGspXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgaSwgaiwgaylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wxLCBlY2wyKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gb3V0Lmdlb18gPT09ICdXT1JMRCcgPyAnI2VtLXdvcmxkcmcnIDogJyNlbS1udXRzcmcnXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSBzZWxlY3RvciA9ICcjZW0tdXNlci1yZWdpb25zJyAvLyBmb3IgdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoYFtlY2wxXWApXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVnaW9ucyB0byB3aGl0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBhbGxSZWdpb25zLmZpbHRlcihgW2VjbDE9JyR7ZWNsMX0nXWApLmZpbHRlcihgW2VjbDI9JyR7ZWNsMn0nXWApXHJcbiAgICAgICAgc2VsZWN0ZWRSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgcmVnaW9ucyB0byB0aGVpciBvcmlnaW5hbCBjb2xvcnMgb24gbW91c2VvdXRcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChgW2VjbDFdYClcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldEZvbnRTaXplRnJvbUNsYXNzLCBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBhcHBlbmRQYXR0ZXJuRmlsbExlZ2VuZCB9IGZyb20gJy4vbGVnZW5kLXBhdHRlcm4tZmlsbCdcclxuaW1wb3J0IHsgY3JlYXRlSGlzdG9ncmFtTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQtaGlzdG9ncmFtJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBjaG9yb3BsZXRoIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IChpbmhlcml0KVxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgb3V0LmxhYmVsVHlwZSA9ICd0aHJlc2hvbGRzJyAvLyB0aHJlc2hvbGRzIHx8IHJhbmdlc1xyXG4gICAgLy90aGUgb3JkZXIgb2YgdGhlIGxlZ2VuZCBlbGVtZW50cy4gU2V0IHRvIGZhbHNlIHRvIGludmVydC5cclxuICAgIG91dC5hc2NlbmRpbmcgPSB0cnVlXHJcbiAgICAvL3RoZSB3aWR0aCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlV2lkdGggPSAyNVxyXG4gICAgLy90aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVIZWlnaHQgPSAyMFxyXG4gICAgLy90aGUgc2VwYXJhdGlvbiBsaW5lIGxlbmd0aFxyXG4gICAgb3V0LnNlcExpbmVMZW5ndGggPSBvdXQuc2hhcGVXaWR0aFxyXG4gICAgLy90aWNrIGxpbmUgbGVuZ3RoIGluIHBpeGVsc1xyXG4gICAgb3V0LnRpY2tMZW5ndGggPSA0XHJcbiAgICAvL3RoZSBudW1iZXIgb2YgZGVjaW1hbCBmb3IgdGhlIGxlZ2VuZCBsYWJlbHNcclxuICAgIG91dC5kZWNpbWFscyA9IDBcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxlZ2VuZCBib3ggZWxlbWVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBsYWJlbFxyXG4gICAgb3V0LmxhYmVsT2Zmc2V0ID0gM1xyXG4gICAgLy9sYWJlbEZvcm1hdHRlciBmdW5jdGlvblxyXG4gICAgb3V0LmxhYmVsRm9ybWF0dGVyID0gbnVsbFxyXG4gICAgLy8gbWFudWFsbHkgZGVmaW5lIGxhYmVsc1xyXG4gICAgb3V0LmxhYmVscyA9IG51bGxcclxuXHJcbiAgICAvLyBIaXN0b2dyYW0gY29uZmlnIGFzIG5lc3RlZCBvYmplY3RcclxuICAgIG91dC5oaXN0b2dyYW0gPSBudWxsXHJcblxyXG4gICAgLy9kaXZlcmdpbmcgbGluZVxyXG4gICAgb3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwgPSB1bmRlZmluZWRcclxuICAgIG91dC5wb2ludE9mRGl2ZXJnZW5jZSA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnBvaW50T2ZEaXZlcmdlbmNlUGFkZGluZyA9IDdcclxuICAgIG91dC5kaXZlcmdpbmdMaW5lTGVuZ3RoID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuZGl2ZXJnaW5nQXJyb3dMZW5ndGggPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3Nob3cgbm8gZGF0YVxyXG4gICAgb3V0Lm5vRGF0YSA9IHRydWVcclxuICAgIC8vbm8gZGF0YSB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubm9EYXRhVGV4dCA9ICdObyBkYXRhJ1xyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdoaXN0b2dyYW0nICYmIHR5cGVvZiBjb25maWdba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIG91dC5oaXN0b2dyYW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcclxuICAgICAgICAgICAgICAgICAgICBzaG93Q291bnRzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBzaG93UGVyY2VudGFnZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsUm90YXRpb246IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLmhpc3RvZ3JhbSxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgaWYgKG91dC5sZ2cubm9kZSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gb3V0LmxnZ1xyXG5cclxuICAgICAgICAgICAgLy8gRHJhdyBsZWdlbmQgYmFja2dyb3VuZCBib3ggYW5kIHRpdGxlIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcbiAgICAgICAgICAgIGlmIChvdXQudGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjc3NGb250U2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5ib3hQYWRkaW5nICsgY3NzRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2V4aXQgZWFybHkgaWYgbm8gY2xhc3NpZmllclxyXG4gICAgICAgICAgICBpZiAoIW1hcC5jbGFzc1RvRmlsbFN0eWxlKCkpIHJldHVyblxyXG5cclxuICAgICAgICAgICAgLy9zZXQgZGVmYXVsdCBwb2ludCBvZiBkaXZlcmdlbmNlIGlmIGFwcGxpY2FibGVcclxuICAgICAgICAgICAgaWYgKG91dC5wb2ludE9mRGl2ZXJnZW5jZUxhYmVsICYmICFvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIG91dC5wb2ludE9mRGl2ZXJnZW5jZSA9IG1hcC5udW1iZXJPZkNsYXNzZXNfIC8gMlxyXG5cclxuICAgICAgICAgICAgaWYgKG91dC5oaXN0b2dyYW0pIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUhpc3RvZ3JhbUxlZ2VuZChvdXQsIGdldFRocmVzaG9sZHMoKSwgZ2V0Q29sb3JzKCksIGdldERhdGEoKSwgZ2V0TGFiZWxGb3JtYXR0ZXIoKSwgaGlnaGxpZ2h0UmVnaW9ucywgdW5oaWdobGlnaHRSZWdpb25zKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5sYWJlbFR5cGUgPT09ICdyYW5nZXMnKSBjcmVhdGVSYW5nZXNMZWdlbmQoKVxyXG4gICAgICAgICAgICAgICAgZWxzZSBjcmVhdGVUaHJlc2hvbGRzTGVnZW5kKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGNob3JvcGxldGggbGVnZW5kIGJveFxyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBvdXQubGdnLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcGF0dGVybiBmaWxsIGxlZ2VuZCBpdGVtcyBCRUxPVyB0aGUgbWFpbiBsZWdlbmRcclxuICAgICAgICAgICAgYXBwZW5kUGF0dGVybkZpbGxMZWdlbmQobWFwLCBvdXQubGdnLCB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVdpZHRoOiBvdXQuc2hhcGVXaWR0aCxcclxuICAgICAgICAgICAgICAgIHNoYXBlSGVpZ2h0OiBvdXQuc2hhcGVIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBsYWJlbE9mZnNldDogb3V0LmxhYmVsT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgYm94UGFkZGluZzogb3V0LmJveFBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiBsZWdlbmRIZWlnaHQgKyBvdXQuYm94UGFkZGluZyArIDUsIC8vIDw8IHRoaXMgc2hpZnRzIHBhdHRlcm4gbGVnZW5kIGRvd25cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRocmVzaG9sZHMoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPVxyXG4gICAgICAgICAgICBtYXAudGhyZXNob2xkc18ubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyBtYXAudGhyZXNob2xkc19cclxuICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbSh7IGxlbmd0aDogbWFwLm51bWJlck9mQ2xhc3Nlc18gfSlcclxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKF8sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jbGFzc2lmaWVyKCkuaW52ZXJ0RXh0ZW50KGluZGV4KVtvdXQuYXNjZW5kaW5nID8gMCA6IDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDEpIC8vIFJlbW92ZSB0aGUgZmlyc3QgZW50cnkgYW5kIHJldHVybiB0aGUgcmVzdCBhcyBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICByZXR1cm4gbWFwLmNvbG9yc19cclxuICAgICAgICAgICAgPyBtYXAuY29sb3JzX1xyXG4gICAgICAgICAgICA6IEFycmF5LmZyb20oeyBsZW5ndGg6IG1hcC5udW1iZXJPZkNsYXNzZXNfIH0pLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoaW5kZXgsIG1hcC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwLnN0YXREYXRhKCkuX2RhdGFfKS5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxGb3JtYXR0ZXIoKSB7XHJcbiAgICAgICAgaWYgKG91dC5sYWJlbFR5cGUgPT0gJ3JhbmdlcycpIHtcclxuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IGdldFRocmVzaG9sZHMoKVxyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0TGFiZWxsZXIgPSAobGFiZWwsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxGb3JtYXR0ZXIgPSBmb3JtYXQoYC4ke291dC5kZWNpbWFsc31mYClcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSByZXR1cm4gYD4gJHtkZWNpbWFsRm9ybWF0dGVyKHRocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSAxXSl9YCAvL3RvcFxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRocmVzaG9sZHMubGVuZ3RoKSByZXR1cm4gYDwgJHtkZWNpbWFsRm9ybWF0dGVyKHRocmVzaG9sZHNbMF0pfWAgLy9ib3R0b21cclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtkZWNpbWFsRm9ybWF0dGVyKHRocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpIC0gMV0pfSAtIDwgJHtkZWNpbWFsRm9ybWF0dGVyKHRocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpXSl9ICBgIC8vaW4tYmV0d2VlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQubGFiZWxGb3JtYXR0ZXIgfHwgZGVmYXVsdExhYmVsbGVyXHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXQubGFiZWxUeXBlID09ICd0aHJlc2hvbGRzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmxhYmVsRm9ybWF0dGVyIHx8IGZvcm1hdChgLiR7b3V0LmRlY2ltYWxzfWZgKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQubGFiZWxGb3JtYXR0ZXIgfHwgZm9ybWF0KGAuJHtvdXQuZGVjaW1hbHN9ZmApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRocmVzaG9sZHNMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbSA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcbiAgICAgICAgbGV0IGJhc2VZID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAvLyBMYWJlbCBmb3JtYXR0ZXJcclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IGdldExhYmVsRm9ybWF0dGVyKClcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSBiYXNlWSA9IGJhc2VZICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpICsgOCAvLyB0aXRsZSBzaXplICsgcGFkZGluZ1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5udW1iZXJPZkNsYXNzZXNfOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgeSA9IGJhc2VZICsgaSAqIG91dC5zaGFwZUhlaWdodFxyXG4gICAgICAgICAgICBjb25zdCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gb3V0LmFzY2VuZGluZyA/IG0ubnVtYmVyT2ZDbGFzc2VzKCkgLSBpIC0gMSA6IGlcclxuICAgICAgICAgICAgY29uc3QgZmlsbENvbG9yID0gbS5jbGFzc1RvRmlsbFN0eWxlKCkoZWNsLCBtLm51bWJlck9mQ2xhc3Nlc18pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlIGZvciBlYWNoIGNsYXNzXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZpbGxDb2xvcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgc2VwYXJhdGlvbiBsaW5lXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGdnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1zZXBhcmF0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2VwTGluZUxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGljayBsaW5lXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGdnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aWNrJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBvdXQuYm94UGFkZGluZyArIG91dC5zZXBMaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2VwTGluZUxlbmd0aCArIG91dC50aWNrTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBsYWJlbFxyXG4gICAgICAgICAgICBpZiAoaSA8IG0ubnVtYmVyT2ZDbGFzc2VzKCkgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGxhYmVsIHNvIHdlIGNhbiBtb3ZlIGl0IGluIGRyYXdEaXZlcmdpbmdMaW5lXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGxnZ1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBNYXRoLm1heChvdXQuc2hhcGVXaWR0aCwgb3V0LnNlcExpbmVMZW5ndGggKyBvdXQudGlja0xlbmd0aCkgKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQubGFiZWxzID8gb3V0LmxhYmVsc1tpXSA6IGxhYmVsRm9ybWF0dGVyKG0uY2xhc3NpZmllcigpLmludmVydEV4dGVudChlY2wpW291dC5hc2NlbmRpbmcgPyAwIDogMV0pKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1hcmsgbGFiZWwgc28gd2UgY2FuIG1vdmUgaXQgaW4gZHJhd0RpdmVyZ2luZ0xpbmVcclxuICAgICAgICAgICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCAmJiBpID09IG91dC5wb2ludE9mRGl2ZXJnZW5jZSAtIDEpIGxhYmVsLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCBlbS1sZWdlbmQtbGFiZWwtZGl2ZXJnZW5jZScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgZGl2ZXJnaW5nIGxpbmUgaWYgYXBwbGljYWJsZS4gV2UgZHJhdyBpdCBhZnRlcndhcmRzIHNvIHRoYXQgd2UgY2FuIGNhbGN1bGF0ZSB0aGUgbWF4IGxlbmd0aCBvZiB0aGUgbGVnZW5kIGxhYmVscyBzbyBpdCBkb2VzbnQgY292ZXIgdGhlbVxyXG4gICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5udW1iZXJPZkNsYXNzZXNfOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gYmFzZVkgKyBpICogb3V0LnNoYXBlSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAvLyBwb2ludCBvZiBkaXZlcmdlbmNlIGluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd0RpdmVyZ2luZ0xpbmUoeSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ05vIGRhdGEnIGJveCBhbmQgbGFiZWwgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgIGlmIChvdXQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBiYXNlWSArIG0ubnVtYmVyT2ZDbGFzc2VzKCkgKiBvdXQuc2hhcGVIZWlnaHQgKyBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgb3V0Lm1hcC5ub0RhdGFGaWxsU3R5bGVfKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZXNMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2dcclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IGdldExhYmVsRm9ybWF0dGVyKClcclxuXHJcbiAgICAgICAgbGV0IGJhc2VZID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSBiYXNlWSA9IGJhc2VZICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpICsgOCAvLyB0aXRsZSBzaXplICsgcGFkZGluZ1xyXG5cclxuICAgICAgICAvLyBmb3IgZWFjaCBjbGFzc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLm51bWJlck9mQ2xhc3Nlc187IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgeSA9IGJhc2VZICsgaSAqIG91dC5zaGFwZUhlaWdodFxyXG4gICAgICAgICAgICBjb25zdCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gb3V0LmFzY2VuZGluZyA/IG1hcC5udW1iZXJPZkNsYXNzZXMoKSAtIGkgLSAxIDogaVxyXG4gICAgICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSBtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgbWFwLm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Db250YWluZXIgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0nKVxyXG5cclxuICAgICAgICAgICAgLy8gc2hpZnQgbGVnZW5kIGl0ZW1zIGRvd24gYWZ0ZXIgcG9pbnQgb2YgZGl2ZXJnZW5jZSBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCAmJiBpID49IG91dC5wb2ludE9mRGl2ZXJnZW5jZSkgeSArPSBvdXQucG9pbnRPZkRpdmVyZ2VuY2VQYWRkaW5nXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZpbGxDb2xvcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5yYWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBzZXBhcmF0aW9uIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1zZXBhcmF0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2VwTGluZUxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgbGFiZWxzXHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgTWF0aC5tYXgob3V0LnNoYXBlV2lkdGgsIG91dC5zZXBMaW5lTGVuZ3RoICsgb3V0LnRpY2tMZW5ndGgpICsgb3V0LmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LmxhYmVscyA/IG91dC5sYWJlbHNbaV0gOiBsYWJlbEZvcm1hdHRlcihtYXAuY2xhc3NpZmllcigpLmludmVydEV4dGVudChlY2wpW291dC5hc2NlbmRpbmcgPyAwIDogMV0sIGkpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBkaXZlcmdpbmcgbGluZSBpZiBhcHBsaWNhYmxlLiBXZSBkcmF3IGl0IGFmdGVyd2FyZHMgc28gdGhhdCB3ZSBjYW4gY2FsY3VsYXRlIHRoZSBtYXggbGVuZ3RoIG9mIHRoZSBsZWdlbmQgbGFiZWxzIHNvIGl0IGRvZXNudCBjb3ZlciB0aGVtXHJcbiAgICAgICAgaWYgKG91dC5wb2ludE9mRGl2ZXJnZW5jZUxhYmVsKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLm51bWJlck9mQ2xhc3Nlc187IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBiYXNlWSArIGkgKiBvdXQuc2hhcGVIZWlnaHRcclxuICAgICAgICAgICAgICAgIC8vIHBvaW50IG9mIGRpdmVyZ2VuY2UgaW5kaWNhdG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3RGl2ZXJnaW5nTGluZSh5KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAnTm8gZGF0YScgYm94IGFuZCBsYWJlbCBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgaWYgKG91dC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9EYXRhSXRlbUNvbnRhaW5lciA9IGNvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaXRlbScpXHJcbiAgICAgICAgICAgIGxldCB5ID0gYmFzZVkgKyBtYXAubnVtYmVyT2ZDbGFzc2VzKCkgKiBvdXQuc2hhcGVIZWlnaHQgKyBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICAvL2lmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIHkgKz0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlUGFkZGluZyAvLyBzaGlmdCBsZWdlbmQgaXRlbXMgZG93biBhZnRlciBwb2ludCBvZiBkaXZlcmdlbmNlXHJcbiAgICAgICAgICAgIG5vRGF0YUl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBvdXQubWFwLm5vRGF0YUZpbGxTdHlsZV8pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykucmFpc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMobWFwLmluc2V0VGVtcGxhdGVzXywgbWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhtYXAuaW5zZXRUZW1wbGF0ZXNfLCBtYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgbm9EYXRhSXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdEaXZlcmdpbmdMaW5lKHkpIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdlbmNlLWNvbnRhaW5lcicpXHJcbiAgICAgICAgY29uc3QgbWFya2VySGVpZ2h0ID0gNlxyXG4gICAgICAgIGNvbnN0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGlmIChvdXQubGFiZWxUeXBlID09ICdyYW5nZXMnKSB5ID0geSArIG91dC5wb2ludE9mRGl2ZXJnZW5jZVBhZGRpbmcgLyAyIC8vIG1vdmUgdG8gdGhlIG1pZGRsZSBvZiB0aGUgc3BhY2UgYmV0d2VlbiBsZWdlbmQgaXRlbVxyXG4gICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IG91dC5sZ2dcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5ub2RlcygpXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKG1heCwgbm9kZSkgPT4gTWF0aC5tYXgobWF4LCBub2RlLmdldEJCb3goKS53aWR0aCksIDApXHJcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IG91dC5kaXZlcmdpbmdMaW5lTGVuZ3RoIHx8IG1heExhYmVsTGVuZ3RoICsgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIDEwIC8vICsgcGFkZGluZ1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBob3Jpem9udGFsIGRpdmVyZ2VuY2UgbGluZVxyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgeClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCArIGxpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtZGl2ZXJnaW5nLWxpbmUnKVxyXG5cclxuICAgICAgICAvLyBkaXZlcmdlbmNlIGxpbmUgd2l0aCB1cCBhbmQgZG93biBhcnJvd3NcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbC5zcGxpdCgnfCcpXHJcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkxpbmVMZW5ndGggPSBvdXQuZGl2ZXJnaW5nQXJyb3dMZW5ndGggfHwgMzBcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uTGluZVggPSB4ICsgbGluZUxlbmd0aFxyXG4gICAgICAgICAgICAvLyBBZGQgYXJyb3doZWFkIG1hcmtlciBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGRlZnMgPSBjb250YWluZXIuYXBwZW5kKCdkZWZzJylcclxuICAgICAgICAgICAgZGVmcy5hcHBlbmQoJ21hcmtlcicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnYXJyb3doZWFkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIG1hcmtlckhlaWdodClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCBtYXJrZXJIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncmVmWCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncmVmWScsIG1hcmtlckhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgYDAgMCwgJHttYXJrZXJIZWlnaHR9ICR7bWFya2VySGVpZ2h0IC8gMn0sIDAgJHttYXJrZXJIZWlnaHR9YClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuXHJcbiAgICAgICAgICAgIC8vIFVwd2FyZCBsaW5lIHdpdGggYXJyb3doZWFkXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGRpcmVjdGlvbkxpbmVYKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGRpcmVjdGlvbkxpbmVYKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSAtIGRpcmVjdGlvbkxpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG5cclxuICAgICAgICAgICAgLy8gRG93bndhcmQgbGluZSB3aXRoIGFycm93aGVhZFxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdpbmctbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkgKyBkaXJlY3Rpb25MaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCAndXJsKCNhcnJvd2hlYWQpJylcclxuXHJcbiAgICAgICAgICAgIC8vIExhYmVscyBmb3IgdXB3YXJkIGFuZCBkb3dud2FyZCBsaW5lc1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGRpcmVjdGlvbkxpbmVYICsgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgLSBkaXJlY3Rpb25MaW5lTGVuZ3RoICsgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGxhYmVsc1swXSlcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZGlyZWN0aW9uTGluZVggKyAxMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIGRpcmVjdGlvbkxpbmVMZW5ndGggLSAxMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQobGFiZWxzWzFdKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGp1c3QgdGhlIHNpbmdsZSBsYWJlbFxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdpbmctbGFiZWwgZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeCArIGxpbmVMZW5ndGggKyA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbW92ZSB0aHJlc2hvbGQgbGFiZWwgb3V0IG9mIHRoZSB3YXkgb2YgdGhlIGxpbmVcclxuICAgICAgICBpZiAob3V0LmxhYmVsVHlwZSA9PSAndGhyZXNob2xkcycpIHtcclxuICAgICAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGl0IHRvIGVuZCBvZiBsaW5lXHJcbiAgICAgICAgICAgICAgICBvdXQubGdnLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbC1kaXZlcmdlbmNlJykuYXR0cigneCcsIHggKyBsaW5lTGVuZ3RoICsgMTApXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGljayBsaW5lXHJcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd4MScsIHggKyBsaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLmF0dHIoJ3gyJywgeCArIGxpbmVMZW5ndGggKyA1KVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBpdCBzbyBpdCBkb2VzbnQgY2xhc2ggd2l0aCBwb2ludE9mRGl2ZXJnZW5jZUxhYmVsXHJcbiAgICAgICAgICAgICAgICBvdXQubGdnLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbC1kaXZlcmdlbmNlJykucmVtb3ZlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKCdbZWNsXScpXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVnaW9ucyB0byB3aGl0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBhbGxSZWdpb25zLmZpbHRlcihcIltlY2w9J1wiICsgZWNsICsgXCInXVwiKVxyXG4gICAgICAgIHNlbGVjdGVkUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9kZXByZWNhdGVkXHJcbiAgICBvdXQubGFiZWxEZWNOYiA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdsYWJlbERlY05iIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIGRlY2ltYWxzIGluc3RlYWQuJyksIG91dClcclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ2QzLWZvcm1hdCdcclxuXHJcbi8vc2V0IGxlZ2VuZCBsYWJlbHMgbG9jYWxlXHJcbmZvcm1hdERlZmF1bHRMb2NhbGUoe1xyXG4gICAgZGVjaW1hbDogJy4nLFxyXG4gICAgdGhvdXNhbmRzOiAnICcsXHJcbiAgICBncm91cGluZzogWzNdLFxyXG4gICAgY3VycmVuY3k6IFsnJywgJ+KCrCddLFxyXG59KVxyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9sIG1hcFxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgY29uZmlnc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gY29uZmlnW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNvbG9yTGVnZW5kID09IGZhbHNlKSBvdXQuY29sb3JMZWdlbmQgPSBmYWxzZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGxlZ2VuZCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmIChtLmxlZ2VuZF8pXHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBtLmxlZ2VuZF8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ2NvbG9yTGVnZW5kJyB8fCBrZXkgPT0gJ3NpemVMZWdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIG0ubGVnZW5kX1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5sZWdlbmRfW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV1bcF0gPSBtLmxlZ2VuZF9ba2V5XVtwXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRba2V5XSA9IG0ubGVnZW5kX1trZXldXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgYnVpbGRGbG93TGVnZW5kKClcclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgd2hpY2ggaWxsdXN0cmF0ZXMgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgZmxvdyBzeW1ib2wgc2l6ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gY29udGFpbmVyIHBhcmVudCBsZWdlbmQgb2JqZWN0IGZyb20gY29yZS9sZWdlbmQuanNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRGbG93TGVnZW5kKG0pIHt9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNjYWxlQmFuZCwgc2NhbGVMaW5lYXIgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBheGlzTGVmdCwgYXhpc0JvdHRvbSB9IGZyb20gJ2QzLWF4aXMnXHJcbmltcG9ydCB7IG1heCB9IGZyb20gJ2QzLWFycmF5J1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlSGlzdG9ncmFtTGVnZW5kID0gKGxlZ2VuZCwgdGhyZXNob2xkcywgY29sb3JzLCBkYXRhLCBsYWJlbEZvcm1hdHRlciwgaGlnaGxpZ2h0UmVnaW9ucywgdW5oaWdobGlnaHRSZWdpb25zKSA9PiB7XHJcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IGxlZ2VuZC5oaXN0b2dyYW0ub3JpZW50YXRpb24gfHwgJ2hvcml6b250YWwnXHJcbiAgICBjb25zdCBzaG93Q291bnRzID0gbGVnZW5kLmhpc3RvZ3JhbS5zaG93Q291bnRzXHJcbiAgICBjb25zdCBzaG93UGVyY2VudGFnZXMgPSBsZWdlbmQuaGlzdG9ncmFtLnNob3dQZXJjZW50YWdlc1xyXG4gICAgY29uc3QgbGFiZWxSb3RhdGlvbiA9IGxlZ2VuZC5oaXN0b2dyYW0ubGFiZWxSb3RhdGlvbiB8fCAwXHJcbiAgICBjb25zdCBtYXJnaW4gPSBsZWdlbmQuaGlzdG9ncmFtLm1hcmdpbiB8fCB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9XHJcbiAgICBjb25zdCBoZWlnaHQgPSBsZWdlbmQuaGlzdG9ncmFtLmhlaWdodCB8fCAyMDBcclxuICAgIGNvbnN0IHdpZHRoID0gbGVnZW5kLmhpc3RvZ3JhbS53aWR0aCB8fCAyNzBcclxuXHJcbiAgICBsZXQgY291bnRzID0gbmV3IEFycmF5KG1hcC5udW1iZXJPZkNsYXNzZXNfKS5maWxsKDApXHJcbiAgICBkYXRhLmZvckVhY2goKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xhc3NJbmRleCA9IG1hcC5jbGFzc2lmaWVyKCkodmFsdWUpXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc0luZGV4ID09PSAnbnVtYmVyJyAmJiBjbGFzc0luZGV4ID49IDAgJiYgY2xhc3NJbmRleCA8IGNvdW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY291bnRzW2NsYXNzSW5kZXhdKytcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnN0IHJldmVyc2VkQ291bnRzID0gY291bnRzLnNsaWNlKCkucmV2ZXJzZSgpXHJcbiAgICBjb25zdCB0b3RhbCA9IGNvdW50cy5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgZCwgMClcclxuICAgIGNvbnN0IHJldmVyc2VkUGVyY2VudGFnZXMgPSByZXZlcnNlZENvdW50cy5tYXAoKGQpID0+ICh0b3RhbCA+IDAgPyAoZCAvIHRvdGFsKSAqIDEwMCA6IDApKVxyXG4gICAgY29uc3QgYmFzZVkgPSBsZWdlbmQuYm94UGFkZGluZyArIChsZWdlbmQudGl0bGUgPyBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLXRpdGxlJykgKyAxMCA6IDMwKVxyXG4gICAgY29uc3QgYmFyR3JvdXAgPSBsZWdlbmQubGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1oaXN0b2dyYW0nKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7YmFzZVl9KWApXHJcblxyXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgZHJhd1ZlcnRpY2FsSGlzdG9ncmFtKGJhckdyb3VwKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkcmF3SG9yaXpvbnRhbEhpc3RvZ3JhbShiYXJHcm91cClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3VmVydGljYWxIaXN0b2dyYW0oYmFyR3JvdXApIHtcclxuICAgICAgICBjb25zdCB5U2NhbGUgPSBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAuZG9tYWluKHJldmVyc2VkQ291bnRzLm1hcCgoXywgaSkgPT4gaSkpXHJcbiAgICAgICAgICAgIC5yYW5nZShbbWFyZ2luLnRvcCwgaGVpZ2h0IC0gbWFyZ2luLmJvdHRvbV0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nKDAuMSlcclxuICAgICAgICBjb25zdCB4U2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oWzAsIG1heChyZXZlcnNlZENvdW50cyldKVxyXG4gICAgICAgICAgICAubmljZSgpXHJcbiAgICAgICAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHdpZHRoIC0gbWFyZ2luLnJpZ2h0XSlcclxuXHJcbiAgICAgICAgLy8gQmFyc1xyXG4gICAgICAgIGJhckdyb3VwXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZGF0YShyZXZlcnNlZENvdW50cylcclxuICAgICAgICAgICAgLmpvaW4oJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWhpc3RvZ3JhbS1iYXInKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChfLCBpKSA9PiB5U2NhbGUoaSkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB5U2NhbGUuYmFuZHdpZHRoKCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiB4U2NhbGUoZCkgLSBtYXJnaW4ubGVmdClcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoXywgaSkgPT4gY29sb3JzW2NvbG9ycy5sZW5ndGggLSBpIC0gMV0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdlY2wnLCAoXywgaSkgPT4gaSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBoYW5kbGVNb3VzZU92ZXIpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBoYW5kbGVNb3VzZU91dClcclxuXHJcbiAgICAgICAgLy8gQmFyIGxhYmVsc1xyXG4gICAgICAgIGlmIChzaG93Q291bnRzIHx8IHNob3dQZXJjZW50YWdlcykge1xyXG4gICAgICAgICAgICBiYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dC5lbS1oaXN0b2dyYW0tbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocmV2ZXJzZWRDb3VudHMpXHJcbiAgICAgICAgICAgICAgICAuam9pbigndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsIGVtLWhpc3RvZ3JhbS1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiB4U2NhbGUoZCkgKyA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoXywgaSkgPT4geVNjYWxlKGkpICsgeVNjYWxlLmJhbmR3aWR0aCgpIC8gMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KChfLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3dQZXJjZW50YWdlcyA/IGAke3JldmVyc2VkUGVyY2VudGFnZXNbaV0udG9GaXhlZCgxKX0lYCA6IHJldmVyc2VkQ291bnRzW2ldXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXhpc1xyXG4gICAgICAgIGNvbnN0IGF4aXNHcm91cCA9IGJhckdyb3VwLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLWxlZ2VuZC1oaXN0b2dyYW0teS1heGlzJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwgMClgKVxyXG5cclxuICAgICAgICBheGlzR3JvdXAuY2FsbChcclxuICAgICAgICAgICAgYXhpc0xlZnQoeVNjYWxlKVxyXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplT3V0ZXIoMClcclxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgwKVxyXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoKF8sIGkpID0+IChsYWJlbEZvcm1hdHRlciA/IGxhYmVsRm9ybWF0dGVyKHRocmVzaG9sZHNbaV0sIGkpIDogdGhyZXNob2xkc1tpXSkpXHJcbiAgICAgICAgKVxyXG5cclxuICAgICAgICBheGlzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsIGVtLXRpY2stbGFiZWwnKS5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgIC8vLmF0dHIoJ3RyYW5zZm9ybScsIGByb3RhdGUoLSR7bGFiZWxSb3RhdGlvbn0pYClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3SG9yaXpvbnRhbEhpc3RvZ3JhbShiYXJHcm91cCkge1xyXG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5kb21haW4ocmV2ZXJzZWRDb3VudHMubWFwKChfLCBpKSA9PiBpKSlcclxuICAgICAgICAgICAgLnJhbmdlKFttYXJnaW4ubGVmdCwgd2lkdGggLSBtYXJnaW4ucmlnaHRdKVxyXG4gICAgICAgICAgICAucGFkZGluZygwLjEpXHJcblxyXG4gICAgICAgIGNvbnN0IHlTY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLmRvbWFpbihbMCwgbWF4KHJldmVyc2VkQ291bnRzKV0pXHJcbiAgICAgICAgICAgIC5uaWNlKClcclxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQgLSBtYXJnaW4uYm90dG9tLCBtYXJnaW4udG9wXSlcclxuXHJcbiAgICAgICAgLy8gQmFyc1xyXG4gICAgICAgIGJhckdyb3VwXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZGF0YShyZXZlcnNlZENvdW50cylcclxuICAgICAgICAgICAgLmpvaW4oJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWhpc3RvZ3JhbS1iYXInKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIChfLCBpKSA9PiB4U2NhbGUoaSkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeFNjYWxlLmJhbmR3aWR0aCgpKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQpID0+IGhlaWdodCAtIG1hcmdpbi5ib3R0b20gLSB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgKF8sIGkpID0+IGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gaSAtIDFdKVxyXG4gICAgICAgICAgICAuYXR0cignZWNsJywgKF8sIGkpID0+IGkpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgaGFuZGxlTW91c2VPdmVyKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgaGFuZGxlTW91c2VPdXQpXHJcblxyXG4gICAgICAgIC8vIEJhciBsYWJlbHMgKGNlbnRlcmVkKVxyXG4gICAgICAgIGlmIChzaG93Q291bnRzIHx8IHNob3dQZXJjZW50YWdlcykge1xyXG4gICAgICAgICAgICBiYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dC5lbS1oaXN0b2dyYW0tbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocmV2ZXJzZWRDb3VudHMpXHJcbiAgICAgICAgICAgICAgICAuam9pbigndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsIGVtLWhpc3RvZ3JhbS1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIChfLCBpKSA9PiB4U2NhbGUoaSkgKyB4U2NhbGUuYmFuZHdpZHRoKCkgLyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4geVNjYWxlKGQpIC0gNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoKF8sIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvd1BlcmNlbnRhZ2VzID8gYCR7cmV2ZXJzZWRQZXJjZW50YWdlc1tpXS50b0ZpeGVkKDEpfSVgIDogcmV2ZXJzZWRDb3VudHNbaV1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBeGlzIChvbmx5IGZvciBsYWJlbFR5cGUgPT09ICd0aHJlc2hvbGRzJylcclxuICAgICAgICBjb25zdCBheGlzR3JvdXAgPSBiYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWxlZ2VuZC1oaXN0b2dyYW0teC1heGlzJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtoZWlnaHQgLSBtYXJnaW4uYm90dG9tfSlgKVxyXG5cclxuICAgICAgICBpZiAobGVnZW5kLmxhYmVsVHlwZSA9PT0gJ3RocmVzaG9sZHMnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdXHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRocmVzaG9sZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhbmRJbmRleCA9IHRocmVzaG9sZHMubGVuZ3RoIC0gaSAtIDFcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4U2NhbGUoYmFuZEluZGV4KVxyXG4gICAgICAgICAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkgcG9zaXRpb25zLnB1c2goeCArIHhTY2FsZS5iYW5kd2lkdGgoKSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgYm91bmRhcnlTY2FsZSA9IHNjYWxlTGluZWFyKCkuZG9tYWluKFswLCB3aWR0aF0pLnJhbmdlKFswLCB3aWR0aF0pXHJcbiAgICAgICAgICAgIGF4aXNHcm91cC5jYWxsKFxyXG4gICAgICAgICAgICAgICAgYXhpc0JvdHRvbShib3VuZGFyeVNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aWNrVmFsdWVzKHBvc2l0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgoXywgaSkgPT4gKGxhYmVsRm9ybWF0dGVyID8gbGFiZWxGb3JtYXR0ZXIodGhyZXNob2xkc1tpXSwgaSkgOiB0aHJlc2hvbGRzW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoMClcclxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemVPdXRlcigwKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIGlmIChsZWdlbmQubGFiZWxUeXBlID09PSAncmFuZ2VzJykge1xyXG4gICAgICAgICAgICBheGlzR3JvdXAuY2FsbChcclxuICAgICAgICAgICAgICAgIGF4aXNCb3R0b20oeFNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZU91dGVyKDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoKF8sIGkpID0+IChsYWJlbEZvcm1hdHRlciA/IGxhYmVsRm9ybWF0dGVyKHRocmVzaG9sZHNbaV0sIGkpIDogdGhyZXNob2xkc1tpXSkpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF4aXNHcm91cFxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCBlbS10aWNrLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgcm90YXRlKC0ke2xhYmVsUm90YXRpb259KWApXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VPdmVyKF8sIGkpIHtcclxuICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcykuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRJbmRleCA9IGNvbG9ycy5sZW5ndGggLSAxIC0gcGFyc2VJbnQoZWNsLCAxMClcclxuICAgICAgICBoaWdobGlnaHRSZWdpb25zKG1hcCwgcmV2ZXJzZWRJbmRleClcclxuICAgICAgICBpZiAobWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU91dChfLCBpKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG1hcClcclxuICAgICAgICBpZiAobWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGdldEZvbnRTaXplRnJvbUNsYXNzIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRQYXR0ZXJuRmlsbExlZ2VuZChtYXAsIGNvbnRhaW5lciwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgc2hhcGVXaWR0aCA9IDI1LFxyXG4gICAgICAgIHNoYXBlSGVpZ2h0ID0gMjAsXHJcbiAgICAgICAgbGFiZWxPZmZzZXQgPSAzLFxyXG4gICAgICAgIGJveFBhZGRpbmcgPSA1LFxyXG4gICAgICAgIG9mZnNldFkgPSAwLCAvLyA8PCBuZXdcclxuICAgIH0gPSBvcHRpb25zXHJcblxyXG4gICAgaWYgKCFtYXAucGF0dGVybkZpbGxfKSByZXR1cm5cclxuXHJcbiAgICBtYXAucGF0dGVybkZpbGxfLmZvckVhY2goKGNmZywgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoIWNmZy5sZWdlbmRMYWJlbCkgcmV0dXJuIC8vIHNraXAgaWYgbm8gbGFiZWxcclxuXHJcbiAgICAgICAgY29uc3QgeSA9IG9mZnNldFkgKyBpbmRleCAqIChzaGFwZUhlaWdodCArIGJveFBhZGRpbmcpXHJcblxyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0gcGF0dGVybi1maWxsLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIGNvbnN0IHBhdHRlcm5Db2xvciA9IGNmZy5jb2xvciB8fCAnIzAwMCcgLy8gZmFsbGJhY2sgdG8gYmxhY2sgaWYgbm8gY29sb3IgcHJvdmlkZWRcclxuICAgICAgICBjb25zdCBpc1doaXRlUGF0dGVybiA9IHBhdHRlcm5Db2xvci50b0xvd2VyQ2FzZSgpID09PSAnI2ZmZicgfHwgcGF0dGVybkNvbG9yLnRvTG93ZXJDYXNlKCkgPT09ICd3aGl0ZSdcclxuXHJcbiAgICAgICAgLy8gQWRkIGJhY2tncm91bmQgaWYgcGF0dGVybiBpcyB3aGl0ZVxyXG4gICAgICAgIGlmIChpc1doaXRlUGF0dGVybikge1xyXG4gICAgICAgICAgICBpdGVtLmFwcGVuZCgncmVjdCcpLmF0dHIoJ3gnLCBib3hQYWRkaW5nKS5hdHRyKCd5JywgeSkuYXR0cignd2lkdGgnLCBzaGFwZVdpZHRoKS5hdHRyKCdoZWlnaHQnLCBzaGFwZUhlaWdodCkuYXR0cignZmlsbCcsICcjZGRkJykgLy8gbGlnaHQgZ3JheSBiYWNrZ3JvdW5kXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgcGF0dGVybiBvdmVybGF5XHJcbiAgICAgICAgaXRlbS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIGJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGB1cmwoIyR7Y2ZnLnBhdHRlcm5JZCB8fCBjZmcucGF0dGVybn0pYClcclxuXHJcbiAgICAgICAgLy8gQWRkIGxhYmVsXHJcbiAgICAgICAgaXRlbS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBib3hQYWRkaW5nICsgc2hhcGVXaWR0aCArIGxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHkgKyBzaGFwZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAudGV4dChjZmcubGVnZW5kTGFiZWwpXHJcbiAgICB9KVxyXG59XHJcbiIsImltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4vbGVnZW5kJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2wgbWFwXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy9zcGFjaW5nIGJldHdlZW4gY29sb3IgJiBzaXplIGxlZ2VuZHMgKGlmIGFwcGxpY2FibGUpXHJcbiAgICBvdXQubGVnZW5kU3BhY2luZyA9IDE1XHJcblxyXG4gICAgLy9zaXplIGxlZ2VuZCBjb25maWcgKGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIHZhbHVlcyBvZiBkaWZmZXJlbnQgcGllIHNpemVzKVxyXG4gICAgb3V0LnNpemVMZWdlbmQgPSB7XHJcbiAgICAgICAgdGl0bGU6IG51bGwsXHJcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAzMCwgLy9wYWRkaW5nIGJldHdlZW4gdGl0bGUgYW5kIGJvZHlcclxuICAgICAgICB2YWx1ZXM6IG51bGwsXHJcbiAgICB9XHJcblxyXG4gICAgLy9jb2xvdXIgbGVnZW5kIGNvbmZpZyAobGVnZW5kIGlsbHVzdHJhdGluZyB0aGUgdmFsdWVzIG9mIGRpZmZlcmVudCBwaWUgY29sb3VycylcclxuICAgIG91dC5jb2xvckxlZ2VuZCA9IHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICBsYWJlbE9mZnNldDogNSwgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICAgICAgc2hhcGVXaWR0aDogMjUsIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICAgICAgc2hhcGVIZWlnaHQ6IDIwLCAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgICAgICBzaGFwZVBhZGRpbmc6IDUsIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgICAgIG5vRGF0YTogdHJ1ZSwgLy9zaG93IG5vIGRhdGFcclxuICAgICAgICBub0RhdGFUZXh0OiAnTm8gZGF0YScsIC8vbm8gZGF0YSBsYWJlbCB0ZXh0XHJcbiAgICB9XHJcblxyXG4gICAgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ID0gMFxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgY29uZmlnc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gY29uZmlnW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vIGxlZ2VuZCBmb3Igc2l6ZXNcclxuICAgICAgICBpZiAobWFwLnNpemVDbGFzc2lmaWVyXykge1xyXG4gICAgICAgICAgICBidWlsZFNpemVMZWdlbmQoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGVnZW5kIGZvciBwcyBjb2xvciB2YWx1ZXNcclxuICAgICAgICBidWlsZENvbG9yTGVnZW5kKClcclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgd2hpY2ggaWxsdXN0cmF0ZXMgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgcGllIGNoYXJ0IHNpemVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBtIG1hcFxyXG4gICAgICogQHBhcmFtIHsqfSBsZ2cgcGFyZW50IGxlZ2VuZCBvYmplY3QgZnJvbSBjb3JlL2xlZ2VuZC5qc1xyXG4gICAgICogQHBhcmFtIHsqfSBjb25maWcgc2l6ZSBsZWdlbmQgY29uZmlnIG9iamVjdCAoc2l6ZUxlZ2VuZCBvYmplY3Qgc3BlY2lmaWVkIGFzIHByb3BlcnR5IG9mIGxlZ2VuZCgpIGNvbmZpZyBvYmplY3QpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2l6ZUxlZ2VuZCgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3QgY29uZmlnID0gb3V0LnNpemVMZWdlbmRcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZS1zaXplLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IG1hcC5zaXplQ2xhc3NpZmllcl8uZG9tYWluKClcclxuXHJcbiAgICAgICAgLy8gQXNzaWduIGRlZmF1bHQgY2lyY2xlIHJhZGlpIGlmIG5vbmUgc3BlY2lmaWVkIGJ5IHVzZXJcclxuICAgICAgICBpZiAoIWNvbmZpZy52YWx1ZXMpIHtcclxuICAgICAgICAgICAgY29uZmlnLnZhbHVlcyA9IFtNYXRoLmZsb29yKGRvbWFpblsxXSksIE1hdGguZmxvb3IoZG9tYWluWzBdKV1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBjaXJjbGUgc2l6ZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxlZ2VuZFxyXG4gICAgICAgIGxldCBtYXhTaXplID0gbWFwLnNpemVDbGFzc2lmaWVyXyhtYXgoY29uZmlnLnZhbHVlcykpXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgdGl0bGUgdG8gdGhlIGNvbnRhaW5lciBpZiBhdmFpbGFibGVcclxuICAgICAgICBpZiAoIWNvbmZpZy50aXRsZSAmJiBvdXQudGl0bGUpIGNvbmZpZy50aXRsZSA9IG91dC50aXRsZSAvLyBBbGxvdyByb290IGxlZ2VuZCB0aXRsZVxyXG4gICAgICAgIGxldCB0aXRsZUhlaWdodCA9IDAgLy8gVGhpcyB3aWxsIGJlIGFkanVzdGVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHRpdGxlIGV4aXN0c1xyXG4gICAgICAgIGlmIChjb25maWcudGl0bGUpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKSAvLyBQb3NpdGlvbiB0aGUgdGl0bGUgYXQgdGhlIGxlZnQgZWRnZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKSAvLyBUaXRsZSBhdCB0b3AsIHdpdGhpbiBwYWRkaW5nXHJcbiAgICAgICAgICAgICAgICAudGV4dChjb25maWcudGl0bGUpXHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3QgdGl0bGUgaGVpZ2h0ICh1c2luZyB0aGUgdGl0bGUgZm9udCBzaXplIGFzIGEgcHJveHkpXHJcbiAgICAgICAgICAgIHRpdGxlSGVpZ2h0ID0gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyArIGNvbmZpZy50aXRsZVBhZGRpbmdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdyBwb3NpdGlvbiB0aGUgY2lyY2xlcyAqKmJlbG93KiogdGhlIHRpdGxlXHJcbiAgICAgICAgbGV0IHkgPSB0aXRsZUhlaWdodCArIG91dC5ib3hQYWRkaW5nICsgbWF4U2l6ZSAqIDIgLy8gUG9zaXRpb24gY2lyY2xlcyBhZnRlciB0aXRsZSBoZWlnaHRcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBsZWdlbmQgY2lyY2xlc1xyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1zID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShjb25maWcudmFsdWVzKVxyXG4gICAgICAgICAgICAuam9pbignZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtaXRlbScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWF4U2l6ZSArIG91dC5ib3hQYWRkaW5nfSwgJHt5fSlgKSAvLyBEeW5hbWljYWxseSBtb3ZlIHRoZSBjaXJjbGVzIGRvd25cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGNpcmNsZXMgdG8gZWFjaCBncm91cFxyXG4gICAgICAgIGxlZ2VuZEl0ZW1zXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtY2lyY2xlJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgKGQpID0+IC1tYXAuc2l6ZUNsYXNzaWZpZXJfKGQpKSAvLyBQb3NpdGlvbiBjaXJjbGVzIGJhc2VkIG9uIHRoZWlyIHNpemVcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBtYXAuc2l6ZUNsYXNzaWZpZXJfKSAvLyBSYWRpdXMgaXMgY2FsY3VsYXRlZCBmcm9tIHNpemUgY2xhc3NpZmllclxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgbGFiZWxzIHRvIGVhY2ggZ3JvdXBcclxuICAgICAgICBsZWdlbmRJdGVtc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+IC0yICogbWFwLnNpemVDbGFzc2lmaWVyXyhkKSAtIG91dC5sYWJlbEZvbnRTaXplIC0gMikgLy8gUG9zaXRpb24gbGFiZWxzIHJlbGF0aXZlIHRvIGNpcmNsZXNcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAzMCkgLy8gU2V0IHRoZSB4LXBvc2l0aW9uIGZvciB0aGUgbGFiZWxzXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4bWw6c3BhY2UnLCAncHJlc2VydmUnKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gZC50b0xvY2FsZVN0cmluZygnZW4nKS5yZXBsYWNlKC8sL2dpLCAnICcpKSAvLyBGb3JtYXQgdGhlIGxhYmVsIHRleHRcclxuXHJcbiAgICAgICAgLy8gQWRkIGxpbmVzIHBvaW50aW5nIHRvIHRoZSB0b3Agb2YgdGhlIGNvcnJlc3BvbmRpbmcgY2lyY2xlXHJcbiAgICAgICAgbGVnZW5kSXRlbXNcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIDMwKVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAoZCkgPT4gLTIgKiBtYXAuc2l6ZUNsYXNzaWZpZXJfKGQpKSAvLyBQb3NpdGlvbiBsaW5lcyByZWxhdGl2ZSB0byBjaXJjbGVzXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIChkKSA9PiAtMiAqIG1hcC5zaXplQ2xhc3NpZmllcl8oZCkpIC8vIFNhbWUgcG9zaXRpb24gZm9yIHRoZSB5MiB0byBtYWtlIGEgaG9yaXpvbnRhbCBsaW5lXHJcblxyXG4gICAgICAgIC8vIFNhdmUgdGhlIGhlaWdodCB2YWx1ZSBmb3IgcG9zaXRpb25pbmcgdGhlIGNvbG9yIGxlZ2VuZCAoaWYgbmVlZGVkKVxyXG4gICAgICAgIG91dC5fc2l6ZUxlZ2VuZEhlaWdodCA9IHlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgb2YgdGhlIHBpZSBjaGFydHMnIGRpZmZlcmVudCBjb2xvdXJzXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZENvbG9yTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBjb25maWcgPSBvdXQuY29sb3JMZWdlbmRcclxuICAgICAgICAvL2NvbnRhaW5lclxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tcGllLWNvbG9yLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChjb25maWcudGl0bGUpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ICsgb3V0LmxlZ2VuZFNwYWNpbmcgKyBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoY29uZmlnLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICBsZXQgaSA9IDBcclxuICAgICAgICBjb25zdCBzY3MgPSBtYXAuY2F0Q29sb3JzKClcclxuICAgICAgICBmb3IgKGxldCBjb2RlIGluIHNjcykge1xyXG4gICAgICAgICAgICAvL3RoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgeSA9XHJcbiAgICAgICAgICAgICAgICBvdXQuX3NpemVMZWdlbmRIZWlnaHQgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmxlZ2VuZFNwYWNpbmcgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmJveFBhZGRpbmcgK1xyXG4gICAgICAgICAgICAgICAgKGNvbmZpZy50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArXHJcbiAgICAgICAgICAgICAgICBpICogKGNvbmZpZy5zaGFwZUhlaWdodCArIGNvbmZpZy5zaGFwZVBhZGRpbmcpXHJcbiAgICAgICAgICAgIC8vdGhlIGNvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IG1hcC5jYXRDb2xvcnMoKVtjb2RlXSB8fCAnbGlnaHRncmF5J1xyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29uZmlnLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29uZmlnLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgc2NzW2NvZGVdKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC41KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vbGFiZWxcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIGNvbmZpZy5zaGFwZVdpZHRoICsgY29uZmlnLmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgY29uZmlnLnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChtYXAuY2F0TGFiZWxzKClbY29kZV0gfHwgY29kZSlcclxuXHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChjb25maWcubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPVxyXG4gICAgICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ICtcclxuICAgICAgICAgICAgICAgIG91dC5sZWdlbmRTcGFjaW5nICtcclxuICAgICAgICAgICAgICAgIG91dC5ib3hQYWRkaW5nICtcclxuICAgICAgICAgICAgICAgIChjb25maWcudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgK1xyXG4gICAgICAgICAgICAgICAgaSAqIChjb25maWcuc2hhcGVIZWlnaHQgKyBjb25maWcuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29uZmlnLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29uZmlnLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbWFwLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vJ25vIGRhdGEnIGxhYmVsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBjb25maWcuc2hhcGVXaWR0aCArIGNvbmZpZy5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIGNvbmZpZy5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KGNvbmZpZy5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgc2VnbWVudHMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgY29kZSkge1xyXG4gICAgICAgIGNvbnN0IGFsbFNlZ21lbnRzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCcucGllY2hhcnQnKS5zZWxlY3RBbGwoJ3BhdGhbY29kZV0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHNlZ21lbnRzIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsU2VnbWVudHMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgc2VnbWVudHMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTZWdtZW50cyA9IGFsbFNlZ21lbnRzLmZpbHRlcihcInBhdGhbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKVxyXG4gICAgICAgIHNlbGVjdGVkU2VnbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHNlZ21lbnRzXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgc2VnbWVudHMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3QgYWxsU2VnbWVudHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJy5waWVjaGFydCcpLnNlbGVjdEFsbCgncGF0aFtjb2RlXScpXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCBzZWdtZW50cydzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsU2VnbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgc3ltYm9sc0xpYnJhcnkgfSBmcm9tICcuLi9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMnXHJcbmltcG9ydCB7IHN5bWJvbCB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuaW1wb3J0IHsgZm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCB7IGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQtcGF0dGVybi1maWxsJ1xyXG5cclxuLy9zZXQgbGVnZW5kIGxhYmVscyBsb2NhbGVcclxuZm9ybWF0RGVmYXVsdExvY2FsZSh7XHJcbiAgICBkZWNpbWFsOiAnLicsXHJcbiAgICB0aG91c2FuZHM6ICcgJyxcclxuICAgIGdyb3VwaW5nOiBbM10sXHJcbiAgICBjdXJyZW5jeTogWycnLCAn4oKsJ10sXHJcbn0pXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2wgbWFwXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgb3V0LmFzY2VuZGluZyA9IGZhbHNlIC8vdGhlIG9yZGVyIG9mIHRoZSBsZWdlbmQgZWxlbWVudHMuIFNldCB0byBmYWxzZSB0byBpbnZlcnQuXHJcbiAgICBvdXQubGVnZW5kU3BhY2luZyA9IDM1IC8vc3BhY2luZyBiZXR3ZWVuIGNvbG9yICYgc2l6ZSBsZWdlbmRzIChpZiBhcHBsaWNhYmxlKVxyXG4gICAgb3V0LmxhYmVsRm9udFNpemUgPSAxMiAvL3RoZSBmb250IHNpemUgb2YgdGhlIGxlZ2VuZCBsYWJlbHNcclxuXHJcbiAgICBvdXQubm9EYXRhU2hhcGVXaWR0aCA9IDI1XHJcbiAgICBvdXQubm9EYXRhU2hhcGVIZWlnaHQgPSAyMFxyXG5cclxuICAgIC8vc2l6ZSBsZWdlbmQgY29uZmlnIChsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSB2YWx1ZXMgb2YgZGlmZmVyZW50IHN5bWJvbCBzaXplcylcclxuICAgIG91dC5zaXplTGVnZW5kID0ge1xyXG4gICAgICAgIHRpdGxlOiBudWxsLFxyXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDEyLFxyXG4gICAgICAgIHRpdGxlUGFkZGluZzogNSwgLy9wYWRkaW5nIGJldHdlZW4gdGl0bGUgYW5kIGxlZ2VuZCBib2R5XHJcbiAgICAgICAgdmFsdWVzOiB1bmRlZmluZWQsIC8vbWFudWFsbHkgZGVmaW5lIHJhdyBkYXRhIHZhbHVlc1xyXG4gICAgICAgIGNlbGxOYjogMywgLy9udW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxlZ2VuZFxyXG4gICAgICAgIHNoYXBlUGFkZGluZzogNSwgLy90aGUgeSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGxlZ2VuZCBzaGFwZSBlbGVtZW50c1xyXG4gICAgICAgIHNoYXBlT2Zmc2V0OiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICBzaGFwZUZpbGw6ICd3aGl0ZScsXHJcbiAgICAgICAgc2hhcGVTdHJva2U6IG51bGwsXHJcbiAgICAgICAgbGFiZWxPZmZzZXQ6IHsgeDogMTAsIHk6IDAgfSwgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICAgICAgZGVjaW1hbHM6IDAsIC8vdGhlIG51bWJlciBvZiBkZWNpbWFsIGZvciB0aGUgbGVnZW5kIGxhYmVsc1xyXG4gICAgICAgIGxhYmVsRm9ybWF0dGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgX3RvdGFsQmFyc0hlaWdodDogMCxcclxuICAgICAgICBfdG90YWxEM1N5bWJvbHNIZWlnaHQ6IDAsXHJcbiAgICAgICAgbm9EYXRhOiBmYWxzZSwgLy8gc2hvdyBubyBkYXRhIGxlZ2VuZCBpdGVtXHJcbiAgICAgICAgbm9EYXRhVGV4dDogJ05vIGRhdGEnLCAvL25vIGRhdGEgdGV4dCBsYWJlbFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbG9yIGxlZ2VuZCBjb25maWcgKGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIGRhdGEtZHJpdmVuIGNvbG91ciBjbGFzc2VzKVxyXG4gICAgb3V0LmNvbG9yTGVnZW5kID0ge1xyXG4gICAgICAgIHRpdGxlOiBudWxsLFxyXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDEyLFxyXG4gICAgICAgIHRpdGxlUGFkZGluZzogMTAsIC8vcGFkZGluZyBiZXR3ZWVuIHRpdGxlIGFuZCBsZWdlbmQgYm9keVxyXG4gICAgICAgIG1hcmdpblRvcDogMzAsIC8vIG1hcmdpbiB0b3AgKGRpc3RhbmNlIGJldHdlZW4gY29sb3IgYW5kIHNpemUgbGVnZW5kKVxyXG4gICAgICAgIHNoYXBlV2lkdGg6IDI1LCAvL3RoZSB3aWR0aCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgICAgIHNoYXBlSGVpZ2h0OiAyMCwgLy90aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICAgICAgc2hhcGVQYWRkaW5nOiAxLCAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGxlZ2VuZCBzaGFwZSBlbGVtZW50cyBpbiB0aGUgY29sb3IgbGVnZW5kXHJcbiAgICAgICAgbGFiZWxPZmZzZXQ6IHsgeDogNSwgeTogMCB9LCAvL2Rpc3RhbmNlICh4KSBiZXR3ZWVuIGxhYmVsIHRleHQgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHNoYXBlIGVsZW1lbnRcclxuICAgICAgICBkZWNpbWFsczogMCwgLy90aGUgbnVtYmVyIG9mIGRlY2ltYWwgZm9yIHRoZSBsZWdlbmQgbGFiZWxzXHJcbiAgICAgICAgbGFiZWxGb3JtYXR0ZXI6IHVuZGVmaW5lZCwgLy8gdXNlci1kZWZpbmVkIGQzIGZvcm1hdCBmdW5jdGlvblxyXG4gICAgICAgIGxhYmVsVHlwZTogJ3RocmVzaG9sZHMnLCAvLyB0eXBlIG9mIGxhYmVscyB0byBzaG93OiB0aHJlc2hvbGRzIG9yIHJhbmdlc1xyXG4gICAgICAgIGxhYmVsczogbnVsbCwgLy8gdXNlci1kZWZpbmVkIGxhYmVscyBmb3IgZWFjaCBjbGFzc1xyXG4gICAgICAgIG5vRGF0YTogdHJ1ZSwgLy9zaG93IG5vIGRhdGFcclxuICAgICAgICBub0RhdGFUZXh0OiAnTm8gZGF0YScsIC8vbm8gZGF0YSB0ZXh0IGxhYmVsXHJcbiAgICAgICAgc2VwTGluZUxlbmd0aDogMjQsIC8vIC8vdGhlIHNlcGFyYXRpb24gbGluZSBsZW5ndGhcclxuICAgICAgICBzZXBMaW5lU3Ryb2tlOiAnYmxhY2snLCAvL3RoZSBzZXBhcmF0aW9uIGxpbmUgY29sb3JcclxuICAgICAgICBzZXBMaW5lU3Ryb2tlV2lkdGg6IDEsIC8vdGhlIHNlcGFyYXRpb24gbGluZSB3aWR0aFxyXG4gICAgICAgIHRpY2tMZW5ndGg6IDUsIC8vIHRocmVzaG9sZCB0aWNrcyBsZW5ndGggaW4gcHhcclxuICAgIH1cclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSAnY29sb3JMZWdlbmQnIHx8IGtleSA9PSAnc2l6ZUxlZ2VuZCcpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgaW4gb3V0W2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIGNvbmZpZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRba2V5XVtwXSA9IGNvbmZpZ1trZXldW3BdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jb2xvckxlZ2VuZCA9PSBmYWxzZSkgb3V0LmNvbG9yTGVnZW5kID0gZmFsc2VcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgaWYgKG91dC5sZ2cubm9kZSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBvdXQubWFwXHJcbiAgICAgICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICAgICAgbGdnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgICAgICAvLyByZXNldCBoZWlnaHQgY291bnRlcnNcclxuICAgICAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsQmFyc0hlaWdodCA9IDBcclxuICAgICAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ID0gMFxyXG5cclxuICAgICAgICAgICAgLy8gbGVnZW5kIGZvciBzaXplXHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZE5vZGUgPSBsZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc2l6ZS1sZWdlbmQtY29udGFpbmVyJylcclxuICAgICAgICAgICAgaWYgKG0uY2xhc3NpZmllclNpemVfKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZFNpemVMZWdlbmQobSwgb3V0LnNpemVMZWdlbmQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbGVnZW5kIGZvciBwcyBjb2xvciB2YWx1ZXNcclxuICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGUgPSBsZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnY29sb3ItbGVnZW5kLWNvbnRhaW5lcicpXHJcblxyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBpdCBiZWxvdyBzaXplIGxlZ2VuZFxyXG4gICAgICAgICAgICBpZiAob3V0Ll9zaXplTGVnZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGUuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCR7b3V0Ll9zaXplTGVnZW5kTm9kZS5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodH0pYClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG0uY2xhc3NpZmllckNvbG9yXyAmJiBvdXQuY29sb3JMZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkQ29sb3JMZWdlbmQobSwgb3V0LmNvbG9yTGVnZW5kKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcGF0dGVybiBmaWxsIGxlZ2VuZCBpdGVtcyBCRUxPVyB0aGUgbWFpbiBsZWdlbmRcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGNob3JvcGxldGggbGVnZW5kIGJveFxyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBvdXQubGdnLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgIGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kKG1hcCwgb3V0LmxnZywge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVXaWR0aDogb3V0LnNoYXBlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBzaGFwZUhlaWdodDogb3V0LnNoYXBlSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgbGFiZWxPZmZzZXQ6IG91dC5sYWJlbE9mZnNldCxcclxuICAgICAgICAgICAgICAgIGJveFBhZGRpbmc6IG91dC5ib3hQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogbGVnZW5kSGVpZ2h0ICsgb3V0LmJveFBhZGRpbmcgKyA1LCAvLyA8PCB0aGlzIHNoaWZ0cyBwYXR0ZXJuIGxlZ2VuZCBkb3duXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvL3NldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIGEgbGVnZW5kIHdoaWNoIGlsbHVzdHJhdGVzIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgb2YgZGlmZmVyZW50IHN5bWJvbCBzaXplc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBjb250YWluZXIgcGFyZW50IGxlZ2VuZCBvYmplY3QgZnJvbSBjb3JlL2xlZ2VuZC5qc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZFNpemVMZWdlbmQobSkge1xyXG4gICAgICAgIGlmICghbS5wc0N1c3RvbVNWR18gJiYgbS5wc1NoYXBlXyA9PSAnY2lyY2xlJykge1xyXG4gICAgICAgICAgICBidWlsZENpcmNsZUxlZ2VuZChtLCBvdXQuc2l6ZUxlZ2VuZClcclxuICAgICAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBvdXQuX3NpemVMZWdlbmROb2RlLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0ICsgMjVcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX3NpemVMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLW5vLWRhdGEtbGVnZW5kJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYClcclxuICAgICAgICAgICAgICAgIGJ1aWxkTm9EYXRhTGVnZW5kKGNvbnRhaW5lciwgb3V0LnNpemVMZWdlbmQubm9EYXRhVGV4dClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9IGVsc2UgaWYgKG0ucHNTaGFwZV8gPT0gJ3NwaWtlJykge1xyXG4gICAgICAgICAgICBidWlsZFNwaWtlTGVnZW5kKG0sIG91dC5zaXplTGVnZW5kKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZGVmaW5lIGZvcm1hdCBmb3IgbGFiZWxzXHJcbiAgICAgICAgbGV0IGxhYmVsRm9ybWF0dGVyID0gb3V0LnNpemVMZWdlbmQubGFiZWxGb3JtYXR0ZXIgfHwgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yXHJcbiAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnNpemVMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZG9tYWluID0gbS5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClcclxuICAgICAgICBsZXQgbWF4VmFsID0gZG9tYWluWzFdIC8vbWF4aW11bSB2YWx1ZSBvZiBkYXRhc2V0ICh1c2VkIGZvciBmaXJzdCBvciBsYXN0IHN5bWJvbCBieSBkZWZhdWx0KVxyXG5cclxuICAgICAgICAvLyBpZiB1c2VyIGRlZmluZXMgdmFsdWVzIGZvciBsZWdlbmQgbWFudWFsbHlcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIG91dC5zaXplTGVnZW5kLmNlbGxOYiA9IG91dC5zaXplTGVnZW5kLnZhbHVlcy5sZW5ndGhcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBsZWdlbmQgZWxlbWVudHMgZm9yIGNsYXNzZXM6IHN5bWJvbCArIGxhYmVsXHJcblxyXG4gICAgICAgIC8vIGZvciBjdXN0b20gcGF0aHNcclxuICAgICAgICBtLmN1c3RvbVN5bWJvbHMgPSB7IG5vZGVIZWlnaHRzOiAwIH0gLy8gc2F2ZSBzb21lIGN1c3RvbSBzZXR0aW5ncyBmb3IgYnVpbGRDdXN0b21TVkdJdGVtXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3V0LnNpemVMZWdlbmQuY2VsbE5iICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vZGVmaW5lIGNsYXNzIG51bWJlclxyXG4gICAgICAgICAgICBjb25zdCBjID0gb3V0LmFzY2VuZGluZyA/IG91dC5zaXplTGVnZW5kLmNlbGxOYiAtIGkgKyAxIDogaVxyXG4gICAgICAgICAgICAvL2RlZmluZSByYXcgdmFsdWVcclxuICAgICAgICAgICAgbGV0IHZhbCA9IG91dC5zaXplTGVnZW5kLnZhbHVlcyA/IG91dC5zaXplTGVnZW5kLnZhbHVlc1tjIC0gMV0gOiBtYXhWYWwgLyBjXHJcbiAgICAgICAgICAgIC8vY2FsY3VsYXRlIHNoYXBlIHNpemVcclxuICAgICAgICAgICAgbGV0IHN5bWJvbFNpemUgPSBtLmNsYXNzaWZpZXJTaXplXyh2YWwpXHJcblxyXG4gICAgICAgICAgICBpZiAobS5wc1NoYXBlXyA9PSAnYmFyJykge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRCYXJzSXRlbShtYXAsIHZhbCwgc3ltYm9sU2l6ZSwgaSwgbGFiZWxGb3JtYXR0ZXIpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobS5wc1NoYXBlXyA9PSAnY3VzdG9tJyB8fCBtLnBzQ3VzdG9tU1ZHXykge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRDdXN0b21TVkdJdGVtKG1hcCwgdmFsLCBzeW1ib2xTaXplLCBpLCBsYWJlbEZvcm1hdHRlcilcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkRDNTeW1ib2xJdGVtKG1hcCwgdmFsLCBzeW1ib2xTaXplLCBpLCBsYWJlbEZvcm1hdHRlcilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUubm9kZSgpLmdldEJCb3goKS5oZWlnaHRcclxuICAgICAgICAgICAgaWYgKG91dC5jb2xvckxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgeSArPSBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgKyA1XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcblxyXG4gICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5zaXplTGVnZW5kLm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkU3Bpa2VMZWdlbmQobWFwLCBzaXplTGVnZW5kQ29uZmlnKSB7XHJcbiAgICAgICAgY29uc3Qgc3Bpa2UgPSAobGVuZ3RoLCB3aWR0aCA9IG1hcC5wc1NwaWtlV2lkdGhfKSA9PiBgTSR7LXdpZHRoIC8gMn0sMEwwLCR7LWxlbmd0aH1MJHt3aWR0aCAvIDJ9LDBgXHJcblxyXG4gICAgICAgIGxldCBtYXhTaXplID0gbWFwLmNsYXNzaWZpZXJTaXplXyhtYXAuY2xhc3NpZmllclNpemVfLmRvbWFpbigpWzFdKVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdmFsdWVzIGZvciB0aGUgbGVnZW5kXHJcbiAgICAgICAgbGV0IGxlZ2VuZFZhbHVlcyA9IG91dC5zaXplTGVnZW5kLnZhbHVlcyB8fCBtYXAuY2xhc3NpZmllclNpemVfLnRpY2tzKDQpLnNsaWNlKDEpIC8vIFVzZSB1c2VyLWRlZmluZWQgdmFsdWVzIG9yIGRlZmF1bHQgdGlja3NcclxuXHJcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLWxhYmVsJykgLy8gQWRqdXN0IGZvbnQgc2l6ZVxyXG4gICAgICAgIGNvbnN0IGxhYmVsU3BhY2luZyA9IGZvbnRTaXplIC0gMiAvLyBFbnN1cmUgbGFiZWxzIGFyZSBqdXN0IGJlbG93IHRoZSBzcGlrZXNcclxuXHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gb3V0Ll9zaXplTGVnZW5kTm9kZVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXNwaWtlLWxlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmcgKyA1fSwwKWApXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgYCR7Zm9udFNpemV9cHhgKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKClcclxuICAgICAgICAgICAgLmRhdGEobGVnZW5kVmFsdWVzKSAvLyBOb3cgdXNlcyB1c2VyLWRlZmluZWQgdmFsdWVzIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIC5qb2luKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgdHJhbnNsYXRlKCR7NDAgKiBpICsgb3V0LmJveFBhZGRpbmd9LCR7bWF4U2l6ZSArIDV9KWApIC8vIEluY3JlYXNlIHNwYWNpbmdcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHNwaWtlc1xyXG4gICAgICAgIGxlZ2VuZFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBtYXAucHNGaWxsXylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIG1hcC5wc0ZpbGxPcGFjaXR5XylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIG1hcC5wc1N0cm9rZV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBtYXAucHNTdHJva2VXaWR0aF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgKGQpID0+IHNwaWtlKG1hcC5jbGFzc2lmaWVyU2l6ZV8oZCkpKSAvLyBDb3JyZWN0bHkgbWFwcyB2YWx1ZXMgdG8gc3Bpa2Ugc2l6ZVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgbGFiZWxzIGRpcmVjdGx5IGJlbG93IGVhY2ggc3Bpa2VcclxuICAgICAgICBsZWdlbmRcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCBsYWJlbFNwYWNpbmcpIC8vIEVuc3VyZSB0ZXh0IGlzIHJpZ2h0IGJlbG93IHNwaWtlc1xyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gbWFwLmNsYXNzaWZpZXJTaXplXy50aWNrRm9ybWF0KDQsICdzJykoZCkpXHJcblxyXG4gICAgICAgIC8vIPCflLkgQWRkIFwiTm8gRGF0YVwiIGl0ZW0gd2l0aCBtb3JlIHNwYWNpbmdcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0TGFiZWxZID0gbWF4U2l6ZSArIGxhYmVsU3BhY2luZyArIGZvbnRTaXplICsgNSAvLyBBZGp1c3QgcG9zaXRpb24gYmVsb3cgdGhlIGxhYmVsc1xyXG4gICAgICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX3NpemVMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLW5vLWRhdGEtbGVnZW5kJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7bGFzdExhYmVsWX0pYClcclxuICAgICAgICAgICAgYnVpbGROb0RhdGFMZWdlbmQoY29udGFpbmVyLCBvdXQuc2l6ZUxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLydubyBkYXRhJyBsZWdlbmQgYm94XHJcbiAgICBmdW5jdGlvbiBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG5vRGF0YVRleHQpIHtcclxuICAgICAgICBsZXQgbSA9IG91dC5tYXBcclxuXHJcbiAgICAgICAgLy9hcHBlbmQgc3ltYm9sICYgc3R5bGVcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG0ubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5jb2xvckxlZ2VuZCA/IG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoIDogb3V0Lm5vRGF0YVNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuY29sb3JMZWdlbmQgPyBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgOiBvdXQubm9EYXRhU2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLydubyBkYXRhJyBsYWJlbFxyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmNvbG9yTGVnZW5kID8gb3V0LmNvbG9yTGVnZW5kLnNoYXBlV2lkdGggKyBvdXQuY29sb3JMZWdlbmQubGFiZWxPZmZzZXQueCA6IG91dC5ub0RhdGFTaGFwZVdpZHRoICsgNSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuY29sb3JMZWdlbmQgPyBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgLyAyIDogb3V0Lm5vRGF0YVNoYXBlSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgLnRleHQobm9EYXRhVGV4dClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsKSB7XHJcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRoaXMgdG8gZXN0YXQgbG9naWMgb2YgbWFraW5nIGFsbCBvdGhlciBjbGFzc2VzIHRyYW5zcGFyZW50P1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3Qgc2VsID0gbWFwLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiW2VjbD0nXCIgKyBlY2wgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGVjbCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3Qgc2VsID0gbWFwLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiW2VjbD0nXCIgKyBlY2wgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBidWlsZHMgYSBzaXplIGxlZ2VuZCBpdGVtIGZvciBwcm9wb3J0aW9uYWwgRDMgc2hhcGVzIChlLmcuIHNxdWFyZSwgdHJpYW5nbGUsIHN0YXIpXHJcbiAgICAgKiBAcGFyYW0geyp9IG0gbWFwIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ltYm9sU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgc3ltYm9sIGl0ZW1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGREM1N5bWJvbEl0ZW0obSwgdmFsdWUsIHN5bWJvbFNpemUsIGluZGV4LCBsYWJlbEZvcm1hdHRlcikge1xyXG4gICAgICAgIGxldCBzeW1ib2xIZWlnaHQgPSBvdXQubWFwLnBzU2hhcGVfID09ICd0cmlhbmdsZScgfHwgb3V0Lm1hcC5wc1NoYXBlXyA9PSAnZGlhbW9uZCcgPyBzeW1ib2xTaXplIDogc3ltYm9sU2l6ZSAvIDJcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ID09IDApIG91dC5zaXplTGVnZW5kLl90b3RhbEQzU3ltYm9sc0hlaWdodCArPSBzeW1ib2xIZWlnaHQgKyBvdXQuYm94UGFkZGluZyAvL2FkZCBmaXJzdCBpdGVtIGhlaWdodCB0byB5XHJcbiAgICAgICAgbGV0IG1heFNpemUgPSBtLmNsYXNzaWZpZXJTaXplXyhtLmNsYXNzaWZpZXJTaXplXy5kb21haW4oKVsxXSlcclxuICAgICAgICAvLyB4IGFuZCB5IHBvc2l0aW9uIG9mIGl0ZW0gaW4gbGVnZW5kXHJcbiAgICAgICAgbGV0IHggPSBtYXhTaXplXHJcbiAgICAgICAgbGV0IHkgPVxyXG4gICAgICAgICAgICAob3V0LnNpemVMZWdlbmQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5zaXplTGVnZW5kLnRpdGxlUGFkZGluZyA6IDApICtcclxuICAgICAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ICtcclxuICAgICAgICAgICAgKG91dC5zaXplTGVnZW5kLnNoYXBlUGFkZGluZyAqIGluZGV4IC0gMSlcclxuXHJcbiAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ICs9IHN5bWJvbFNpemVcclxuXHJcbiAgICAgICAgLy9jb250YWluZXIgZm9yIHN5bWJvbCBhbmQgbGFiZWxcclxuICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgIC8vIGRyYXcgRDMgc3ltYm9sXHJcbiAgICAgICAgbGV0IHNoYXBlID0gZ2V0U2hhcGUoKVxyXG4gICAgICAgIGxldCBkID0gc2hhcGUuc2l6ZShzeW1ib2xTaXplICogc3ltYm9sU2l6ZSkoKVxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC8vIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgc2Vjb25kYXJ5IHN0YXQgdmFyaWFibGUgaXMgdXNlZCBmb3Igc3ltYm9sIGNvbG91cmluZywgdGhlbiBkb250IGNvbG91ciB0aGUgbGVnZW5kIHN5bWJvbHMgdXNpbmcgcHNGaWxsKClcclxuICAgICAgICAgICAgICAgIHJldHVybiBtLmNsYXNzaWZpZXJDb2xvcl8gPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZUZpbGwgOiBtLnBzRmlsbF9cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBtLnBzRmlsbE9wYWNpdHkoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA/IG91dC5zaXplTGVnZW5kLnNoYXBlU3Ryb2tlIDogbS5wc1N0cm9rZSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIG0ucHNTdHJva2VXaWR0aCgpKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KWBcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9sYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBsYWJlbFggPSBtYXhTaXplIC8gMiArIG91dC5zaXplTGVnZW5kLmxhYmVsT2Zmc2V0LnggKyBvdXQuYm94UGFkZGluZ1xyXG5cclxuICAgICAgICAvL2FwcGVuZCBsYWJlbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAuYXR0cigneCcsIGxhYmVsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAudGV4dChsYWJlbEZvcm1hdHRlcih2YWx1ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gbVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHsqfSBzeW1ib2xTaXplXHJcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4XHJcbiAgICAgKiBAcGFyYW0geyp9IGxhYmVsRm9ybWF0dGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ3VzdG9tU1ZHSXRlbShtLCB2YWx1ZSwgc3ltYm9sU2l6ZSwgaW5kZXgsIGxhYmVsRm9ybWF0dGVyKSB7XHJcbiAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZyAvL3NldCBYIG9mZnNldFxyXG4gICAgICAgIGxldCB5XHJcblxyXG4gICAgICAgIC8vZmlyc3QgaXRlbVxyXG4gICAgICAgIGlmICghbS5jdXN0b21TeW1ib2xzLnByZXZTeW1iKSB7XHJcbiAgICAgICAgICAgIHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LnNpemVMZWdlbmQudGl0bGVQYWRkaW5nIDogMCkgKyAyMFxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMuaW5pdGlhbFRyYW5zbGF0ZVkgPSB5XHJcbiAgICAgICAgICAgIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGUgPSBzeW1ib2xTaXplXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2ZvbGxvd2luZyBpdGVtc1xyXG4gICAgICAgIGlmIChtLmN1c3RvbVN5bWJvbHMucHJldlN5bWIpIHtcclxuICAgICAgICAgICAgbGV0IHByZXZOb2RlID0gbS5jdXN0b21TeW1ib2xzLnByZXZTeW1iLm5vZGUoKVxyXG4gICAgICAgICAgICBsZXQgYmJveCA9IHByZXZOb2RlLmdldEJCb3goKVxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMubm9kZUhlaWdodHMgPSBtLmN1c3RvbVN5bWJvbHMubm9kZUhlaWdodHMgKyBiYm94LmhlaWdodCAqIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGVcclxuICAgICAgICAgICAgeSA9IG0uY3VzdG9tU3ltYm9scy5pbml0aWFsVHJhbnNsYXRlWSArIG0uY3VzdG9tU3ltYm9scy5ub2RlSGVpZ2h0cyArIG91dC5zaXplTGVnZW5kLnNoYXBlUGFkZGluZyAqIChpbmRleCAtIDEpXHJcbiAgICAgICAgICAgIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGUgPSBzeW1ib2xTaXplXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnRhaW5lciBmb3Igc3ltYm9sIGFuZCBsYWJlbFxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKS5hdHRyKCdjbGFzcycsICdlbS1zaXplLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy8gZHJhdyBzdGFuZGFyZCBzeW1ib2xcclxuICAgICAgICBtLmN1c3RvbVN5bWJvbHMucHJldlN5bWIgPSBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtc3ltYm9sJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHNlY29uZGFyeSBzdGF0IHZhcmlhYmxlIGlzIHVzZWQgZm9yIHN5bWJvbCBjb2xvdXJpbmcsIHRoZW4gZG9udCBjb2xvdXIgdGhlIGxlZ2VuZCBzeW1ib2xzIHVzaW5nIHBzRmlsbCgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5jbGFzc2lmaWVyQ29sb3JfID8gb3V0LnNpemVMZWdlbmQuc2hhcGVGaWxsIDogbS5wc0ZpbGxfXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgbS5wc0ZpbGxPcGFjaXR5KCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA6IG0ucHNTdHJva2UoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBtLnBzU3Ryb2tlV2lkdGgoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuaHRtbChvdXQubWFwLnBzQ3VzdG9tU1ZHXylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLnBzQ3VzdG9tU1ZHXykgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KSBzY2FsZSgke3N5bWJvbFNpemV9KWBcclxuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KWBcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9sYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBsYWJlbFggPSB4ICsgbS5jbGFzc2lmaWVyU2l6ZV8obS5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClbMF0pICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueFxyXG4gICAgICAgIGxldCBsYWJlbFkgPSBvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55IC8gMiArIDEgLy95ICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueVxyXG5cclxuICAgICAgICAvL2FwcGVuZCBsYWJlbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAuYXR0cigneCcsIGxhYmVsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBsYWJlbFkpXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsRm9ybWF0dGVyKHZhbHVlKSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogQHBhcmFtIHsqfSBtXHJcbiAgICAgKiBAcGFyYW0geyp9IHN5bWJvbFNpemVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRCYXJzSXRlbShtLCB2YWx1ZSwgc3ltYm9sU2l6ZSwgaW5kZXgsIGxhYmVsRm9ybWF0dGVyKSB7XHJcbiAgICAgICAgLy8gZm9yIHZlcnRpY2FsIGJhcnMgd2UgZG9udCB1c2UgYSBkeW5hbWljIFggb2Zmc2V0IGJlY2F1c2UgYWxsIGJhcnMgaGF2ZSB0aGUgc2FtZSB3aWR0aFxyXG4gICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAvL3dlIGFsc28gZG9udCBuZWVkIHRoZSB5IG9mZnNldFxyXG4gICAgICAgIGxldCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnNpemVMZWdlbmQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5zaXplTGVnZW5kLnRpdGxlUGFkZGluZyA6IDApICsgb3V0LnNpemVMZWdlbmQuX3RvdGFsQmFyc0hlaWdodCArIDEwXHJcblxyXG4gICAgICAgIG91dC5zaXplTGVnZW5kLl90b3RhbEJhcnNIZWlnaHQgKz0gc3ltYm9sU2l6ZSArIDEwXHJcblxyXG4gICAgICAgIC8vc2V0IHNoYXBlIHNpemUgYW5kIGRlZmluZSAnZCcgYXR0cmlidXRlXHJcbiAgICAgICAgbGV0IHNoYXBlID0gZ2V0U2hhcGUoKVxyXG4gICAgICAgIGxldCBkID0gc2hhcGUuc2l6ZShzeW1ib2xTaXplICogc3ltYm9sU2l6ZSkoKVxyXG5cclxuICAgICAgICAvL2NvbnRhaW5lciBmb3Igc3ltYm9sIGFuZCBsYWJlbFxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKS5hdHRyKCdjbGFzcycsICdlbS1zaXplLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy8gZHJhdyBiYXIgc3ltYm9sXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHNlY29uZGFyeSBzdGF0IHZhcmlhYmxlIGlzIHVzZWQgZm9yIHN5bWJvbCBjb2xvdXJpbmcsIHRoZW4gZG9udCBjb2xvdXIgdGhlIGxlZ2VuZCBzeW1ib2xzIHVzaW5nIHBzRmlsbCgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5jbGFzc2lmaWVyQ29sb3JfID8gb3V0LnNpemVMZWdlbmQuc2hhcGVGaWxsIDogbS5wc0ZpbGxfXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgbS5wc0ZpbGxPcGFjaXR5KCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA6IG0ucHNTdHJva2UoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBtLnBzU3Ryb2tlV2lkdGgoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5wc0N1c3RvbVNWR18pIHJldHVybiBgdHJhbnNsYXRlKCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueH0sJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55fSkgc2NhbGUoJHtzeW1ib2xTaXplfSlgXHJcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBgdHJhbnNsYXRlKCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueH0sJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55fSlgXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgLy9sYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBsYWJlbFggPSB4ICsgb3V0Lm1hcC5wc0JhcldpZHRoXyArIG91dC5zaXplTGVnZW5kLmxhYmVsT2Zmc2V0LnhcclxuICAgICAgICBsZXQgbGFiZWxZID0gc3ltYm9sU2l6ZSAvIDIgKyBvdXQuc2l6ZUxlZ2VuZC5sYWJlbE9mZnNldC55XHJcblxyXG4gICAgICAgIC8vYXBwZW5kIGxhYmVsXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbGFiZWxYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGxhYmVsWSlcclxuICAgICAgICAgICAgLnRleHQobGFiZWxGb3JtYXR0ZXIodmFsdWUpKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGJ1aWxkcyBhIG5lc3RlZCBjaXJjbGUgbGVnZW5kIGZvciBwcm9wb3J0aW9uYWwgY2lyY2xlc1xyXG4gICAgICogQHBhcmFtIHsqfSBtIG1hcFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZENpcmNsZUxlZ2VuZChtKSB7XHJcbiAgICAgICAgLy9hc3NpZ24gZGVmYXVsdCBjaXJjbGUgcmFkaXVzZXMgaWYgbm9uZSBzcGVjaWZpZWQgYnkgdXNlclxyXG4gICAgICAgIGxldCBkb21haW4gPSBtLmNsYXNzaWZpZXJTaXplXy5kb21haW4oKVxyXG4gICAgICAgIGlmICghb3V0LnNpemVMZWdlbmQudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgbGVnZW5kIHZhbHVlc1xyXG4gICAgICAgICAgICBvdXQuX3NpemVMZWdlbmRWYWx1ZXMgPSBbTWF0aC5mbG9vcihkb21haW5bMV0pLCBNYXRoLmZsb29yKGRvbWFpblsxXSAvIDIpLCBNYXRoLmZsb29yKGRvbWFpblswXSldXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdXNlciBkZWZpbmVkIGxlZ2VuZCB2YWx1ZXNcclxuICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kVmFsdWVzID0gb3V0LnNpemVMZWdlbmQudmFsdWVzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgdGl0bGVcclxuICAgICAgICBpZiAoIW91dC5zaXplTGVnZW5kLnRpdGxlICYmIG91dC50aXRsZSkgb3V0LnNpemVMZWdlbmQudGl0bGUgPSBvdXQudGl0bGUgLy9pZiB1bnNwZWNpZmllZCwgc2V0IHNpemUgbGVnZW5kIHRpdGxlIGFzIHJvb3QgbGVnZW5kIHRpdGxlXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnNpemVMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWF4UmFkaXVzID0gbS5jbGFzc2lmaWVyU2l6ZV8obWF4KG91dC5fc2l6ZUxlZ2VuZFZhbHVlcykpIC8vbWF4aW11bSBjaXJjbGUgcmFkaXVzIHRvIGJlIHNob3duIGluIGxlZ2VuZFxyXG4gICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmcgKyBtYXhSYWRpdXNcclxuICAgICAgICBsZXQgeSA9IG91dC5ib3hQYWRkaW5nICsgbWF4UmFkaXVzICogMiArIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LnNpemVMZWdlbmQudGl0bGVQYWRkaW5nIDogMCkgKyAyMFxyXG5cclxuICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY2lyY2xlLWxlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdyaWdodCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShvdXQuX3NpemVMZWdlbmRWYWx1ZXMuZmlsdGVyKChkKSA9PiBtLmNsYXNzaWZpZXJTaXplXyhkKSkpIC8vIEZpbHRlciBkYXRhIGJlZm9yZSBiaW5kaW5nXHJcbiAgICAgICAgICAgIC5qb2luKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy9jaXJjbGVzXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWNpcmNsZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIChkKSA9PiAtbS5jbGFzc2lmaWVyU2l6ZV8oZCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgbS5jbGFzc2lmaWVyU2l6ZV8pXHJcblxyXG4gICAgICAgIC8vbGFiZWxzXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gLTEgLSAyICogbS5jbGFzc2lmaWVyU2l6ZV8oZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB5XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbWF4UmFkaXVzICsgNSlcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlU3RyaW5nKCdlbicpLnJlcGxhY2UoLywvZ2ksICcgJylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAvL2xpbmUgcG9pbnRpbmcgdG8gdG9wIG9mIGNvcnJlc3BvbmRpbmcgY2lyY2xlOlxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsIDIpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2dyZXknKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCAyKVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSAtMSAtIDIgKiBtLmNsYXNzaWZpZXJTaXplXyhkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgbWF4UmFkaXVzICsgNSlcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gLTEgLSAyICogbS5jbGFzc2lmaWVyU2l6ZV8oZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB5XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBhIGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgc3ltYm9sIGNvbG91cnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG0gbWFwXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ29sb3JMZWdlbmQobSkge1xyXG4gICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQubGFiZWxUeXBlID09PSAncmFuZ2VzJykge1xyXG4gICAgICAgICAgICBidWlsZENvbG9yUmFuZ2VzTGVnZW5kKG0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVpbGRDb2xvclRocmVzaG9sZHNMZWdlbmQobSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JUaHJlc2hvbGRzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID1cclxuICAgICAgICAgICAgbWFwLnBzVGhyZXNob2xkc18ubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyBtYXAucHNUaHJlc2hvbGRzX1xyXG4gICAgICAgICAgICAgICAgOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBtYXAucHNDbGFzc2VzXyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwLmNsYXNzaWZpZXJDb2xvcl8uaW52ZXJ0RXh0ZW50KGluZGV4KVtvdXQuYXNjZW5kaW5nID8gMCA6IDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDEpIC8vIFJlbW92ZSB0aGUgZmlyc3QgZW50cnkgYW5kIHJldHVybiB0aGUgcmVzdCBhcyBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRDb2xvclJhbmdlc0xlZ2VuZChtKSB7XHJcbiAgICAgICAgY29uc3QgZiA9IG91dC5jb2xvckxlZ2VuZC5sYWJlbEZvcm1hdHRlciB8fCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3JcclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gZ2V0Q29sb3JUaHJlc2hvbGRzKClcclxuICAgICAgICBjb25zdCBudW1iZXJPZkNsYXNzZXMgPSBtLnBzQ2xhc3Nlc19cclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQudGl0bGUpIHtcclxuICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQudGl0bGVGb250U2l6ZSArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3ApXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQuY29sb3JMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB4ID0gb3V0LmJveFBhZGRpbmdcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgeSA9XHJcbiAgICAgICAgICAgICAgICBvdXQudGl0bGVGb250U2l6ZSArXHJcbiAgICAgICAgICAgICAgICBvdXQuY29sb3JMZWdlbmQudGl0bGVQYWRkaW5nICtcclxuICAgICAgICAgICAgICAgIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3AgK1xyXG4gICAgICAgICAgICAgICAgaSAqIChvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgKyBvdXQuY29sb3JMZWdlbmQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZWNsID0gb3V0LmFzY2VuZGluZyA/IGkgOiBudW1iZXJPZkNsYXNzZXMgLSBpIC0gMVxyXG5cclxuICAgICAgICAgICAgY29uc3QgaXRlbUNvbnRhaW5lciA9IG91dC5fY29sb3JMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgICAgIC8vIFJlY3RhbmdsZVxyXG4gICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtLnBzQ2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gTGFiZWxcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoICsgb3V0LmNvbG9yTGVnZW5kLmxhYmVsT2Zmc2V0LngpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5jb2xvckxlZ2VuZC5sYWJlbHMpIHJldHVybiBvdXQuY29sb3JMZWdlbmQubGFiZWxzW2ldIC8vIHVzZXItZGVmaW5lZCBsYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIGA+ICR7Zih0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gMV0pfWBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhyZXNob2xkcy5sZW5ndGgpIHJldHVybiBgPCAke2YodGhyZXNob2xkc1swXSl9YFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtmKHRocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpIC0gMV0pfSAtIDwgJHtmKHRocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpXSl9YFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9wdGlvbmFsbHkgYWRkIG5vLWRhdGFcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmNvbG9yTGVnZW5kLm1hcmdpblRvcCArIG51bWJlck9mQ2xhc3NlcyAqIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCArIDIwIC8vIGFkZCAyMCB0byBzZXBhcmF0ZSBpdCBmcm9tIHRoZSByZXN0XHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX2NvbG9yTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcblxyXG4gICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5jb2xvckxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZENvbG9yVGhyZXNob2xkc0xlZ2VuZChtKSB7XHJcbiAgICAgICAgLy9kZWZpbmUgZm9ybWF0IGZvciBsYWJlbHNcclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IG91dC5jb2xvckxlZ2VuZC5sYWJlbEZvcm1hdHRlciB8fCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3JcclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQudGl0bGUpIHtcclxuICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQudGl0bGVGb250U2l6ZSArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3ApXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQuY29sb3JMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4IHBvc2l0aW9uIG9mIGNvbG9yIGxlZ2VuZCBjZWxsc1xyXG4gICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICBsZXQgbnVtYmVyT2ZDbGFzc2VzID0gbS5wc0NsYXNzZXNfXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICAgICAgLy90aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBlbGVtZW50XHJcbiAgICAgICAgICAgIGxldCB5ID0gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuY29sb3JMZWdlbmQudGl0bGVQYWRkaW5nICsgb3V0LmNvbG9yTGVnZW5kLm1hcmdpblRvcCArIGkgKiBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgLy8gYWNjb3VudCBmb3IgdGl0bGUgKyBtYXJnaW5cclxuXHJcbiAgICAgICAgICAgIC8vdGhlIGNsYXNzIG51bWJlciwgZGVwZW5kaW5nIG9uIG9yZGVyXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IG91dC5hc2NlbmRpbmcgPyBpIDogbnVtYmVyT2ZDbGFzc2VzIC0gaSAtIDFcclxuXHJcbiAgICAgICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9jb2xvckxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0nKVxyXG5cclxuICAgICAgICAgICAgLy9hcHBlbmQgc3ltYm9sICYgc3R5bGVcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbS5wc0NsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG51bWJlck9mQ2xhc3NlcykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9zZXBhcmF0aW9uIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1zZXBhcmF0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCAwICsgb3V0LmNvbG9yTGVnZW5kLnNlcExpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgMClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHRpY2sgbGluZVxyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmNvbG9yTGVnZW5kLnNlcExpbmVMZW5ndGggKyBvdXQuY29sb3JMZWdlbmQudGlja0xlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCAwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2xhYmVsXHJcbiAgICAgICAgICAgIGlmIChpIDwgbnVtYmVyT2ZDbGFzc2VzIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuY29sb3JMZWdlbmQuc2VwTGluZUxlbmd0aCArIG91dC5jb2xvckxlZ2VuZC50aWNrTGVuZ3RoICsgb3V0LmNvbG9yTGVnZW5kLmxhYmVsT2Zmc2V0LngpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5jb2xvckxlZ2VuZC5sYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3V0LmNvbG9yTGVnZW5kLmxhYmVsc1tpXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsYWJlbEZvcm1hdHRlcihtLmNsYXNzaWZpZXJDb2xvcl8uaW52ZXJ0RXh0ZW50KG91dC5hc2NlbmRpbmcgPyBlY2wgKyAxIDogZWNsIC0gMSlbb3V0LmFzY2VuZGluZyA/IDAgOiAxXSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vJ25vIGRhdGEnIGxlZ2VuZCBib3hcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmNvbG9yTGVnZW5kLm1hcmdpblRvcCArIG51bWJlck9mQ2xhc3NlcyAqIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCArIDIwIC8vIGFkZCAyMCB0byBzZXBhcmF0ZSBpdCBmcm9tIHRoZSByZXN0XHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX2NvbG9yTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcblxyXG4gICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5jb2xvckxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHRoZSBkMy5zeW1ib2wgb2JqZWN0IGNob3NlbiBieSB0aGUgdXNlclxyXG4gICAgICogQHJldHVybiB7ZDMuc2hhcGUgfHwgU1ZHfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRTaGFwZSgpIHtcclxuICAgICAgICBsZXQgc2hhcGVcclxuICAgICAgICBpZiAob3V0Lm1hcC5wc0N1c3RvbVNWR18pIHtcclxuICAgICAgICAgICAgc2hhcGUgPSBvdXQubWFwLnBzQ3VzdG9tU1ZHX1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0Lm1hcC5wc0N1c3RvbVNoYXBlXykge1xyXG4gICAgICAgICAgICBzaGFwZSA9IG91dC5tYXAucHNDdXN0b21TaGFwZV9cclxuICAgICAgICB9IGVsc2UgaWYgKG91dC5tYXAucHNTaGFwZV8gPT0gJ2JhcicpIHtcclxuICAgICAgICAgICAgLy9mb3IgcmVjdGFuZ2xlcywgd2UgdXNlIGEgY3VzdG9tIGQzIHN5bWJvbFxyXG4gICAgICAgICAgICBsZXQgZHJhd1JlY3RhbmdsZSA9IChjb250ZXh0LCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5zcXJ0KHNpemUpXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ob3V0Lm1hcC5wc0JhcldpZHRoXywgaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ob3V0Lm1hcC5wc0JhcldpZHRoXywgMClcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIDApXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2hhcGUgPSBzeW1ib2woKS50eXBlKHsgZHJhdzogZHJhd1JlY3RhbmdsZSB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBzeW1ib2xUeXBlID0gc3ltYm9sc0xpYnJhcnlbb3V0Lm1hcC5wc1NoYXBlX10gfHwgc3ltYm9sc0xpYnJhcnlbJ2NpcmNsZSddXHJcbiAgICAgICAgICAgIHNoYXBlID0gc3ltYm9sKCkudHlwZShzeW1ib2xUeXBlKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hhcGVcclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICAvL2ZvciBwcywgdGhlIHN5bWJvbHMgYXJlIHRoZSBjaGlsZHJlbiBvZiBlYWNoIGVtLXByb3Atc3ltYm9scyBlbGVtZW50XHJcbiAgICAgICAgY29uc3QgYWxsU3ltYm9scyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHN5bWJvbHMgdG8gd2hpdGVcclxuICAgICAgICBhbGxTeW1ib2xzLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IHNlbGVjdCh0aGlzLmNoaWxkTm9kZXNbMF0pXHJcbiAgICAgICAgICAgIHN5bWJvbC5zdHlsZSgnZmlsbCcsICd3aGl0ZScpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTeW1ib2xzID0gYWxsU3ltYm9scy5maWx0ZXIoXCJbZWNsPSdcIiArIGVjbCArIFwiJ11cIilcclxuICAgICAgICBzZWxlY3RlZFN5bWJvbHMuZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gc2VsZWN0KHRoaXMuY2hpbGROb2Rlc1swXSlcclxuICAgICAgICAgICAgc3ltYm9sLnN0eWxlKCdmaWxsJywgc3ltYm9sLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgLy9mb3IgcHMsIHRoZSBzeW1ib2xzIGFyZSB0aGUgY2hpbGRyZW4gb2YgZWFjaCBlbS1wcm9wLXN5bWJvbHMgZWxlbWVudFxyXG4gICAgICAgIGNvbnN0IGFsbFN5bWJvbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJyNlbS1wcm9wLXN5bWJvbHMnKS5zZWxlY3RBbGwoJ1tlY2xdJylcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsU3ltYm9scy5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICBzeW1ib2wuc3R5bGUoJ2ZpbGwnLCBzeW1ib2wuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgY2hvcm9wbGV0aCBtYXBzXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy90aGUgd2lkdGggb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZVdpZHRoID0gMjVcclxuICAgIC8vdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlSGVpZ2h0ID0gMjBcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlUGFkZGluZyA9IDVcclxuICAgIC8vdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGVnZW5kIGxhYmVsXHJcbiAgICBvdXQubGFiZWxGb250U2l6ZSA9IDEyXHJcbiAgICAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbGFiZWxcclxuICAgIG91dC5sYWJlbE9mZnNldCA9IDVcclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhID0gdHJ1ZVxyXG4gICAgLy9ubyBkYXRhIGxhYmVsIHRleHRcclxuICAgIG91dC5ub0RhdGFUZXh0ID0gJ05vIGRhdGEnXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IHN2Z01hcCA9IG0uc3ZnKClcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIHtcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC50aXRsZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBsZWdlbmQgZWxlbWVudHMgZm9yIGNsYXNzZXM6IHJlY3RhbmdsZSArIGxhYmVsXHJcbiAgICAgICAgbGV0IGkgPSAwXHJcbiAgICAgICAgY29uc3Qgc2NzID0gbS5jYXRDb2xvcnMoKVxyXG4gICAgICAgIGZvciAobGV0IGNvZGUgaW4gc2NzKSB7XHJcbiAgICAgICAgICAgIC8vdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyA6IDApICsgaSAqIChvdXQuc2hhcGVIZWlnaHQgKyBvdXQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgLy90aGUgY29sb3JcclxuICAgICAgICAgICAgY29uc3QgY29sID0gbS5jYXRDb2xvcnMoKVtjb2RlXSB8fCAnbGlnaHRncmF5J1xyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHNjc1tjb2RlXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDAuNSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5yYWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vbGFiZWxcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG0uY2F0TGFiZWxzKClbY29kZV0gfHwgY29kZSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Z01hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInJlY3RbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IG0uY2F0Q29sb3JzKClbY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuICAgICAgICAgICAgICAgICAgICBzdmdNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJyZWN0W2NvZGU9J1wiICsgY29kZSArIFwiJ11cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY29sKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChvdXQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgKyBpICogKG91dC5zaGFwZUhlaWdodCArIG91dC5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAvL3JlY3RhbmdsZVxyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbS5ub0RhdGFGaWxsU3R5bGUoKSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Z01hcC5zZWxlY3QoJyNlbS1udXRzcmcnKS5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIikuc3R5bGUoJ2ZpbGwnLCBtLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBtLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHN2Z01hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5ub0RhdGFGaWxsU3R5bGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIG0ubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8nbm8gZGF0YScgbGFiZWxcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5ub0RhdGFUZXh0KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnTWFwLnNlbGVjdCgnI2VtLW51dHNyZycpLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKS5zdHlsZSgnZmlsbCcsIG0uaG92ZXJDb2xvcigpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc3ZnTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyNlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiW25kPSduZCddXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm5vRGF0YUZpbGxTdHlsZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGNvZGUpIHtcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKCdwYXR0ZXJuJykuc2VsZWN0QWxsKCdyZWN0Jyk7XHJcbiAgICBcclxuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIGNvbG9ycyBpZiBub3QgYWxyZWFkeSBzdG9yZWRcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IHNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCFlbC5hdHRyKCdkYXRhLW9yaWdpbmFsLWZpbGwnKSkge1xyXG4gICAgICAgICAgICAgICAgZWwuYXR0cignZGF0YS1vcmlnaW5hbC1maWxsJywgZWwuc3R5bGUoJ2ZpbGwnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKTsgLy8gU2V0IGFsbCByZWdpb25zIHRvIHdoaXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICBcclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoXCJwYXR0ZXJuXCIpLnNlbGVjdEFsbChcInJlY3RbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKTtcclxuICAgICAgICBzZWxlY3RlZFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBlbC5zdHlsZSgnZmlsbCcsIGVsLmF0dHIoJ2RhdGEtb3JpZ2luYWwtZmlsbCcpKTsgLy8gUmVzdG9yZSBvcmlnaW5hbCBmaWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKCdwYXR0ZXJuJykuc2VsZWN0QWxsKCdyZWN0Jyk7XHJcbiAgICBcclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgc3RvcmVkIGF0dHJpYnV0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZpbGwgPSBlbC5hdHRyKCdkYXRhLW9yaWdpbmFsLWZpbGwnKTtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRmlsbCkge1xyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUoJ2ZpbGwnLCBvcmlnaW5hbEZpbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGdldEZvbnRTaXplRnJvbUNsYXNzIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGV1cm9zdGF0LW1hcCBsZWdlbmQuIFRoaXMgaXMgYW4gYWJzdHJhY3QgbWV0aG9kLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIC8vYnVpbGQgbGVnZW5kIG9iamVjdFxyXG4gICAgY29uc3Qgb3V0ID0ge31cclxuXHJcbiAgICAvL2xpbmsgbWFwIHRvIGxlZ2VuZFxyXG4gICAgb3V0Lm1hcCA9IG1hcFxyXG5cclxuICAgIC8vdGhlIFNWRyB3aGVyZSB0byBtYWtlIHRoZSBsZWdlbmRcclxuICAgIG91dC5zdmdJZCA9ICdsZWdlbmRfJyArIE1hdGgucm91bmQoMTBlMTUgKiBNYXRoLnJhbmRvbSgpKVxyXG4gICAgb3V0LnN2ZyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmxnZyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vdGhlIGxlZ2VuZCBlbGVtZW50IHBvc2l0aW9uLCBpbiBjYXNlIGl0IGlzIGVtYmVkZWQgd2l0aGluIHRoZSBtYXAgU1ZHXHJcbiAgICBvdXQueCA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnkgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3RoZSBsZWdlbmQgYm94XHJcbiAgICBvdXQuYm94UGFkZGluZyA9IDdcclxuICAgIG91dC5ib3hPcGFjaXR5ID0gMC43XHJcblxyXG4gICAgLy9sZWdlbmQgdGl0bGVcclxuICAgIG91dC50aXRsZSA9ICcnXHJcbiAgICAvLyB3ZSBub3cgdXNlIENTUyBpbnN0ZWFkIG9mIGlubGluZSBzdHlsZXNcclxuICAgIG91dC50aXRsZUZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAvLyB3ZSBub3cgdXNlIENTUyBpbnN0ZWFkIG9mIGlubGluZSBzdHlsZXNcclxuICAgIG91dC5sYWJlbEZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcblxyXG4gICAgLyoqIEJ1aWxkIGxlZ2VuZC4gKi9cclxuICAgIG91dC5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3NldCBTVkcgZWxlbWVudCBhbmQgYWRkIG1haW4gZHJhd2luZyBncm91cFxyXG4gICAgICAgIG91dC5zdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkKVxyXG4gICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGxlZ2VuZChzKVxyXG4gICAgICAgIG91dC5zdmcuc2VsZWN0QWxsKCcjZW0tbGVnZW5kLScgKyBvdXQuc3ZnSWQpLnJlbW92ZSgpXHJcbiAgICAgICAgLy8gYXBwZW5kIG5ldyBsZWdlbmQgZ3JvdXBcclxuICAgICAgICBvdXQubGdnID0gb3V0LnN2Z1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWxlZ2VuZC0nICsgb3V0LnN2Z0lkKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgbGVnZW5kIGVsZW1lbnQuXHJcbiAgICAgKiBUaGlzIGlzIGFuIGFic3RyYWN0IG1ldGhvZCB0byBiZSBkZWZpbmVkIGZvciBlYWNoIHNwZWNpZmljIGxlZ2VuZC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTGVnZW5kIHVwZGF0ZSBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBvdXQudXBkYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnXHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9jaGVjayBpZiBwcm92aWRlZCBleHRlcm5hbCBzdmdJZCBoYXMgY2hhbmdlZFxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZFNWRyA9IG91dC5zdmdcclxuICAgICAgICBpZiAobGVnZW5kU1ZHLmF0dHIoJ2lkJykgIT09IG1hcC5sZWdlbmRfLnN2Z0lkKSB7XHJcbiAgICAgICAgICAgIG91dC5idWlsZCgpIC8vIHNldHMgbmV3IHN2ZyBhbmQgbGdnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG91dC51cGRhdGVDb25maWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIC8vIFVwZGF0ZSBsZWdlbmQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAobWFwLmxlZ2VuZF8pIHtcclxuICAgICAgICAgICAgZGVlcE1lcmdlRXhpc3RpbmdLZXlzKG91dCwgbWFwLmxlZ2VuZF8pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3BzXHJcbiAgICAgICAgLy8gLy8gdXBkYXRlIGxlZ2VuZCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIC8vIGlmIChtLmxlZ2VuZF8pXHJcbiAgICAgICAgLy8gICAgIGZvciAobGV0IGtleSBpbiBtLmxlZ2VuZF8pIHtcclxuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkgPT0gJ2NvbG9yTGVnZW5kJyB8fCBrZXkgPT0gJ3NpemVMZWdlbmQnKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIG0ubGVnZW5kX1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBpZiAobS5sZWdlbmRfW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV1bcF0gPSBtLmxlZ2VuZF9ba2V5XVtwXVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBvdXRba2V5XSA9IG0ubGVnZW5kX1trZXldXHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0l0IHBlcmZvcm1zIGEgc2hhbGxvdyBjb3B5IOKAlCBuZXN0ZWQgb2JqZWN0cyB3aWxsIGJlIGNvcGllZCBieSByZWZlcmVuY2UsIG5vdCBkdXBsaWNhdGVkLlxyXG4gICAgLy9JdCBtb2RpZmllcyB0aGUgdGFyZ2V0IG9iamVjdCAob3V0KSBpbiBwbGFjZS5cclxuICAgIC8vVXNlZnVsIGZvciBtZXJnaW5nIG9iamVjdHMgb3IgZXh0ZW5kaW5nIGV4aXN0aW5nIG9uZXMuXHJcbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2VFeGlzdGluZ0tleXModGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMgPSB7fSwgc2VlbiA9IG5ldyBXZWFrU2V0KCksIGRlcHRoID0gMCkge1xyXG4gICAgICAgIGNvbnN0IE1BWF9ERVBUSCA9IG9wdGlvbnMubWF4RGVwdGggfHwgMTAwXHJcblxyXG4gICAgICAgIGlmIChzZWVuLmhhcyh0YXJnZXQpKSByZXR1cm4gdGFyZ2V0XHJcbiAgICAgICAgc2Vlbi5hZGQodGFyZ2V0KVxyXG5cclxuICAgICAgICBpZiAoZGVwdGggPiBNQVhfREVQVEgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBNYXggcmVjdXJzaW9uIGRlcHRoICgke01BWF9ERVBUSH0pIHJlYWNoZWQuYClcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0YXJnZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlVmFsID0gc291cmNlW2tleV1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZ1bmN0aW9uczogb3ZlcndyaXRlIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgcGxhaW4gb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVZhbCkgJiYgaXNQbGFpbk9iamVjdCh0YXJnZXRWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcE1lcmdlRXhpc3RpbmdLZXlzKHRhcmdldFZhbCwgc291cmNlVmFsLCBvcHRpb25zLCBzZWVuLCBkZXB0aCArIDEpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhcnJheXM6IG92ZXJ3cml0ZSAob3IgbWVyZ2UgaWYgb3B0aW9uIHNldClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VWYWwpICYmIEFycmF5LmlzQXJyYXkodGFyZ2V0VmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gb3B0aW9ucy5tZXJnZUFycmF5cyA/IFsuLi5uZXcgU2V0KFsuLi50YXJnZXRWYWwsIC4uLnNvdXJjZVZhbF0pXSA6IFsuLi5zb3VyY2VWYWxdXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBEYXRlc1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWwgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgRGF0ZShzb3VyY2VWYWwuZ2V0VGltZSgpKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUmVnRXhwXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbmV3IFJlZ0V4cChzb3VyY2VWYWwpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBNYXAgYW5kIFNldFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWwgaW5zdGFuY2VvZiBNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBNYXAoc291cmNlVmFsKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWwgaW5zdGFuY2VvZiBTZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBTZXQoc291cmNlVmFsKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVyd3JpdGUgcHJpbWl0aXZlcyBhbmQgb3RoZXIgdHlwZXNcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhlbHBlciB0byBjaGVjayBmb3IgcGxhaW4gb2JqZWN0c1xyXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveCAqL1xyXG4gICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC5sZ2cuYXBwZW5kKCdyZWN0JykuYXR0cignaWQnLCAnbGVnZW5kQlInKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtYmFja2dyb3VuZCcpLnN0eWxlKCdvcGFjaXR5Jywgb3V0LmJveE9wYWNpdHkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNldCBsZWdlbmQgYm94IGRpbWVuc2lvbnMsIGVuc3VyaW5nIGl0IGhhcyBzdWl0YWJsZSBkaW1lbnNpb25zIHRvIGZpdCB0byBhbGwgbGVnZW5kIGdyYXBoaWMgZWxlbWVudHMgKi9cclxuICAgIG91dC5zZXRCb3hEaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG91dC5sZ2cubm9kZSgpKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGxlZ2VuZCBlbGVtZW50cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgY29uc3QgYmIgPSBvdXQubGdnLm5vZGUoKS5nZXRCQm94KHsgc3Ryb2tlOiB0cnVlIH0pXHJcbiAgICAgICAgICAgIC8vYXBwbHkgdG8gbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBvdXQuc3ZnXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcjbGVnZW5kQlInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBiYi54IC0gcClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYmIueSAtIHApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBiYi53aWR0aCArIDIgKiBwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGJiLmhlaWdodCArIDIgKiBwKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0LCBzdHlsZSB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgc2NhbGVPcmRpbmFsIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IHNjaGVtZVNldDMgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgQ2F0ZWdvcmljYWxMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1jYXRlZ29yaWNhbCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIGdldFJlZ2lvbnNTZWxlY3RvciwgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCB7IGFwcGx5UGF0dGVybkZpbGwgfSBmcm9tICcuLi9jb3JlL3BhdHRlcm4tZmlsbCdcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY2F0ZWdvcmljYWwgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIGZhbHNlLCAnY3QnKVxyXG5cclxuICAgIC8qKiBGaWxsIHN0eWxlIGZvciBlYWNoIGNhdGVnb3J5L2NsYXNzLiBFeC46IHsgdXJiOiBcIiNmZGI0NjJcIiwgaW50OiBcIiNmZmZmYjNcIiwgcnVyOiBcIiNjY2ViYzVcIiB9ICovXHJcbiAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUZXh0IGxhYmVsIGZvciBlYWNoIGNhdGVnb3J5L2NsYXNzLiBFeC46IHsgXCJ1cmJcIjogXCJVcmJhblwiLCBcImludFwiOiBcIkludGVybWVkaWF0ZVwiLCBcInJ1clwiOiBcIlJ1cmFsXCIgfSAqL1xyXG4gICAgb3V0LmNsYXNzVG9UZXh0XyA9IHVuZGVmaW5lZFxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSB0b29sdGlwVGV4dEZ1bkNhdFxyXG5cclxuICAgIC8vdGhlIGNsYXNzaWZpZXI6IGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbJ2NsYXNzVG9GaWxsU3R5bGVfJywgJ2NsYXNzVG9UZXh0XycsICdub0RhdGFGaWxsU3R5bGVfJywgJ3Rvb2x0aXBUZXh0XycsICdjbGFzc2lmaWVyXyddLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbJ2NsYXNzVG9GaWxsU3R5bGUnLCAnY2xhc3NUb1RleHQnLCAnbm9EYXRhRmlsbFN0eWxlJywgJ3Rvb2x0aXBUZXh0JywgJ2NsYXNzaWZpZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICAvL2dldCBkb21haW4gKHVuaXF1ZSB2YWx1ZXMpXHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gb3V0LnN0YXREYXRhKCkuZ2V0VW5pcXVlVmFsdWVzKClcclxuXHJcbiAgICAgICAgLy9nZXQgcmFuZ2UgWzAsMSwyLDMsLi4uLGRvbWFpbi5sZW5ndGgtMV1cclxuICAgICAgICBjb25zdCByYW5nZSA9IFsuLi5BcnJheShkb21haW4ubGVuZ3RoKS5rZXlzKCldXHJcblxyXG4gICAgICAgIC8vbWFrZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgLy9vbmx5IHVzZSB1c2VyLWRlZmluZSBjbGFzc2VzXHJcbiAgICAgICAgY29uc3QgY3RmcyA9IG91dC5jbGFzc1RvRmlsbFN0eWxlXyA/IG91dC5jbGFzc1RvRmlsbFN0eWxlKCkgOiB1bmRlZmluZWRcclxuICAgICAgICBpZiAoY3Rmcykge1xyXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gT2JqZWN0LmtleXMoY3RmcylcclxuICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoXHJcbiAgICAgICAgICAgICAgICBzY2FsZU9yZGluYWwoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oY2F0ZWdvcmllcykgLy8gT25seSBjbGFzc2lmeSBrbm93biBjYXRlZ29yaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKGNhdGVnb3JpZXMubWFwKChfLCBpKSA9PiBpKSkgLy8gQXNzaWduIG51bWVyaWNhbCBjbGFzc2VzXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2UgYWxsIHVuaXF1ZSB2YWx1ZXMgaWYgbm8gdXNlci1kZWZpbmVkIGNsYXNzZXMgZXhpc3RcclxuICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVPcmRpbmFsKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgY2xhc3NpZmllciBhbmQgc2V0ICdlY2wnIGF0dHJpYnV0ZSB0byByZWdpb25zIGJhc2VkIG9uIHZhbHVlXHJcbiAgICAgICAgY29uc3QgY2xhc3NpZnlSZWdpb25zID0gKHJlZ2lvbnMpID0+IHtcclxuICAgICAgICAgICAgcmVnaW9ucy5hdHRyKCdlY2wnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAnOicpIHJldHVybiAnbmQnIC8vIE5vIGRhdGFcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlzTmFOKHYpID8gdiA6ICt2IC8vIENvbnZlcnQgbnVtYmVycywga2VlcCBzdHJpbmdzIGFzIGlzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8g8J+UuSBFbnN1cmUgb25seSBrbm93biB2YWx1ZXMgYXJlIGNsYXNzaWZpZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzaWZpZXJEb21haW4gPSBvdXQuY2xhc3NpZmllcigpLmRvbWFpbigpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNsYXNzaWZpZXJEb21haW4uaW5jbHVkZXModmFsdWUpKSByZXR1cm4gLy8gU2tpcCB1bmtub3duIHZhbHVlc1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NpZmllcigpKHZhbHVlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcikpXHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBtaXhlZCBOVVRTIGxldmVsLCBzZXBhcmF0aW5nIE5VVFMgbGV2ZWwgMFxyXG4gICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICBjb25zdCBudXRzMFJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobnV0czBSZWdpb25zKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm8gY29sb3Igc3BlY2lmaWVkLCB1c2Ugc29tZSBkZWZhdWx0IGNvbG9yc1xyXG4gICAgICAgIGlmICghb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdGZzID0ge31cclxuICAgICAgICAgICAgY29uc3QgZG9tID0gb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5sZW5ndGg7IGkrKykgY3Rmc1tkb21baV1dID0gc2NoZW1lU2V0M1tpICUgMTJdXHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGN0ZnMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseVN0eWxlVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVUb01hcChtYXApIHtcclxuICAgICAgICAvLyBBcHBseSBjb2xvciBhbmQgZXZlbnRzIHRvIHJlZ2lvbnMgaWYgU1ZHIGV4aXN0c1xyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmQgc2V0IGluaXRpYWwgZmlsbCBjb2xvcnMgd2l0aCBkYXRhLWRyaXZlbiBsb2dpY1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgcmVnaW9uc0ZpbGxGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICByZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBhZGRNb3VzZUV2ZW50c1RvUmVnaW9ucyhtYXAsIHJlZ2lvbnMpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb250IGNvbG9yIGZvciBncmlkIGNhcnRvZ3JhbXMgKGNvbnRyYXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC10ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29sb3IgPSBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKGNlbGxDb2xvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgdHJhbnNpdGlvbiB0byByZWdpb25zOicsIGVycilcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBhZGRpdGlvbmFsIHNldHRpbmdzIGZvciBtaXhlZCBOVVRTIGxldmVsIHZpZXdcclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYWJlbHMgZm9yIHN0YXRpc3RpY2FsIHZhbHVlcyBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICBpZiAob3V0LmxhYmVsc18pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXy52YWx1ZXMpIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMobWFwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2FkZCBoYXRjaGluZyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKG91dC5wYXR0ZXJuRmlsbF8pIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5UGF0dGVybkZpbGwobWFwLCBvdXQucGF0dGVybkZpbGxfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gbWl4aW5nIGRpZmZlcmVudCBOVVRTIGxldmVscyAoZS5nLiBzaG93aW5nIE5VVFMgMSBhbmQgTlVUUyAyIGRhdGEgc2ltdWx0YW5lb3VzbHkpXHJcbiAgICBjb25zdCBzdHlsZU1peGVkTlVUUyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBtYXAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbChnZXRSZWdpb25zU2VsZWN0b3IobWFwKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWNsIHx8IGx2bCA9PT0gJzAnID8gJ2Jsb2NrJyA6ICdub25lJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHNlbC5zdHlsZSgnc3Ryb2tlJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBlY2wgJiYgbHZsICE9PSAnMCcgPyBzdHJva2UgfHwgJyM3NzcnIDogbnVsbFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVjbCAmJiBsdmwgIT09ICcwJyA/IHN0cm9rZVdpZHRoIHx8IDAuMiA6IG51bGxcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWdpb25zRmlsbEZ1bmN0aW9uID0gZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgY29uc3QgZWNsID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbCcpIC8vICd0aGlzJyByZWZlcnMgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcclxuICAgICAgICBpZiAob3V0Lkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKVxyXG4gICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmNsYXNzVG9GaWxsU3R5bGVfW291dC5jbGFzc2lmaWVyKCkuZG9tYWluKClbZWNsXV1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3V0Lmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIG91dC5jbnRyZ0ZpbGxTdHlsZV9cclxuICAgICAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV9bb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVtlY2xdXVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGxTdHlsZSB8fCBvdXQuY250cmdGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOVVRTIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudHJ5SWQgPSByZy5wcm9wZXJ0aWVzLmlkLnNsaWNlKDAsIDIpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jbGFzc1RvRmlsbFN0eWxlX1tvdXQuY2xhc3NpZmllcigpLmRvbWFpbigpW2VjbF1dXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMgPSBmdW5jdGlvbiAobWFwLCByZWdpb25zKSB7XHJcbiAgICAgICAgLy8gU2V0IHVwIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKSAvLyBBcHBseSBoaWdobGlnaHQgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKSAvLyBSZXZlcnQgdG8gb3JpZ2luYWwgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKipcclxuICogU3BlY2lmaWMgZnVuY3Rpb24gZm9yIHRvb2x0aXAgdGV4dC5cclxuICpcclxuICogQHBhcmFtIHsqfSByZyBUaGUgcmVnaW9uIHRvIHNob3cgaW5mb3JtYXRpb24gb24uXHJcbiAqIEBwYXJhbSB7Kn0gbWFwIFRoZSBtYXAgZWxlbWVudFxyXG4gKi9cclxuY29uc3QgdG9vbHRpcFRleHRGdW5DYXQgPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgY29uc3QgYnVmID0gW11cclxuICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj4nICsgcmcucHJvcGVydGllcy5uYSArICcgKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPC9kaXY+JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+JyArIHJnLnByb3BlcnRpZXMubmEgKyAnPC9kaXY+JylcclxuICAgIH1cclxuICAgIC8vZ2V0IHN0YXQgdmFsdWVcclxuICAgIGNvbnN0IHN2ID0gbWFwLnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAvL2Nhc2Ugd2hlbiBubyBkYXRhIGF2YWlsYWJsZVxyXG4gICAgaWYgKCFzdiB8fCAoc3YudmFsdWUgIT0gMCAmJiAhc3YudmFsdWUpKSB7XHJcbiAgICAgICAgYnVmLnB1c2gobWFwLm5vRGF0YVRleHRfKVxyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbCA9IHN2LnZhbHVlXHJcbiAgICBpZiAobWFwLmNsYXNzVG9UZXh0Xykge1xyXG4gICAgICAgIGNvbnN0IGxibCA9IG1hcC5jbGFzc1RvVGV4dF9bdmFsXVxyXG4gICAgICAgIC8vZGlzcGxheSBsYWJlbCBhbmQgdmFsdWVcclxuICAgICAgICBidWYucHVzaChgXHJcbiAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPlxyXG4gICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgPHRib2R5PlxyXG4gICAgPHRyPlxyXG4gICAgPHRkPlxyXG4gICAgJHtsYmwgPyBsYmwgOiB2YWx9XHJcbiAgICA8L3RkPlxyXG4gICAgPC90cj5cclxuICAgIDwvdGJvZHk+XHJcbiAgICA8L3RhYmxlPlxyXG4gICAgPC9kaXY+XHJcbmApXHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG4gICAgfVxyXG4gICAgLy9kaXNwbGF5IGp1c3QgdmFsdWVcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0XCI+XHJcbiAgICA8dGFibGUgY2xhc3M9XCJudXRzLXRhYmxlXCI+XHJcbiAgICA8dGJvZHk+XHJcbiAgICA8dHI+XHJcbiAgICA8dGQ+XHJcbiAgICAke3ZhbH1cclxuICAgIDwvdGQ+XHJcbiAgICA8L3RyPlxyXG4gICAgPC90Ym9keT5cclxuICAgIDwvdGFibGU+XHJcbiAgICA8L2Rpdj5cclxuYClcclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVSZ2IgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBCaXZhcmlhdGVMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLWJpdmFyaWF0ZSdcclxuaW1wb3J0IHsgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciwgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBiaXZhcmlhdGUgY2hvcm9wbGV0aCBtYXAuXHJcbiAqIFNlZTogaHR0cHM6Ly9naXN0Ym9rLnVjZ2lzLm9yZy9ib2stdG9waWNzL211bHRpdmFyaWF0ZS1tYXBwaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgZmFsc2UsICdjaGJpJylcclxuXHJcbiAgICAvL251bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgY2xhc3NpZmljYXRpb24uIFNhbWUgZm9yIGJvdGggdmFyaWFibGVzLlxyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSAzXHJcbiAgICAvL3N0ZXZlbnMuZ3JlZW5ibHVlXHJcbiAgICAvL1RPRE8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZGl2ZXJnaW5nIGNvbG9yIHJhbXBzID9cclxuICAgIG91dC5zdGFydENvbG9yXyA9ICcjZThlOGU4J1xyXG4gICAgb3V0LmNvbG9yMV8gPSAnIzczYWU4MCdcclxuICAgIG91dC5jb2xvcjJfID0gJyM2YzgzYjUnXHJcbiAgICBvdXQuZW5kQ29sb3JfID0gJyMyYTVhNWInXHJcbiAgICAvL2EgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvcnMgZm9yIHRoZSBjbGFzc2VzIGksalxyXG4gICAgb3V0LmNsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyOiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybiBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyMV8gPSB1bmRlZmluZWRcclxuICAgIG91dC5jbGFzc2lmaWVyMl8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHRvb2x0aXBUZXh0RnVuQml2XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ3N0YXJ0Q29sb3JfJyxcclxuICAgICAgICAnY29sb3IxXycsXHJcbiAgICAgICAgJ2NvbG9yMl8nLFxyXG4gICAgICAgICdlbmRDb2xvcl8nLFxyXG4gICAgICAgICdjbGFzc1RvRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyMV8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyMl8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgWydudW1iZXJPZkNsYXNzZXMnLCAnc3RhcnRDb2xvcicsICdjb2xvcjEnLCAnY29sb3IyJywgJ2VuZENvbG9yJywgJ2NsYXNzVG9GaWxsU3R5bGUnLCAnbm9EYXRhRmlsbFN0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9zZXQgY2xhc3NpZmllcnNcclxuICAgICAgICBjb25zdCBzZXR1cENsYXNzaWZpZXJzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RhdDEgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgICAgICBsZXQgc3RhdDIgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0QXJyYXkoKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBbLi4uQXJyYXkob3V0Lm51bWJlck9mQ2xhc3NlcygpKS5rZXlzKCldXHJcbiAgICAgICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIxXykgb3V0LmNsYXNzaWZpZXIxKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDEpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgaWYgKCFvdXQuY2xhc3NpZmllcjJfKSBvdXQuY2xhc3NpZmllcjIoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihzdGF0MikucmFuZ2UocmFuZ2UpKVxyXG5cclxuICAgICAgICAgICAgLy9kZWZpbmUgYml2YXJpYXRlIHNjYWxlXHJcbiAgICAgICAgICAgIGlmICghb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBzY2FsZUJpdmFyaWF0ZShvdXQubnVtYmVyT2ZDbGFzc2VzKCksIG91dC5zdGFydENvbG9yKCksIG91dC5jb2xvcjEoKSwgb3V0LmNvbG9yMigpLCBvdXQuZW5kQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKHNjYWxlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjbGFzc2lmeVJlZ2lvbnMgPSAocmVnaW9ucykgPT4ge1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmcucHJvcGVydGllcy5pZC5sZW5ndGggPT0gNCkgY29uc29sZS5sb2cocmcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIyXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbmQnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdjEgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YyID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YxIHx8ICFzdjIpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2ID0gc3YxLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBzdjIudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgc2V0dXBDbGFzc2lmaWVycygpXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNsYXNzaWZpY2F0aW9uIGFuZCBhc3NpZ24gJ2VjbCcgYXR0cmlidXRlIGJhc2VkIG9uIG1hcCB0eXBlXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNsYXNzaWZ5UmVnaW9ucyhtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKSlcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtaXhlZCBOVVRTIGxldmVsLCBzZXBhcmF0aW5nIE5VVFMgbGV2ZWwgMFxyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG51dHMwUmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoJ3BhdGguZW0tbnV0c3JnMCcpXHJcbiAgICAgICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobnV0czBSZWdpb25zKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgc3R5bGUgdG8gaW5zZXRzXHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0c1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlTdHlsZVRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseVN0eWxlVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vYXBwbHkgc3R5bGUgdG8gbnV0cyByZWdpb25zXHJcblxyXG4gICAgICAgIC8vIHNldCBjb2xvdXIgb2YgcmVnaW9uc1xyXG4gICAgICAgIGlmIChtYXAuc3ZnKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wxID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDEnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDIgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMicpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlY2wxICYmICFlY2wyKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJykgLy8gR0lTQ08tMjY3OCAtIGxhY2sgb2YgZGF0YSBubyBsb25nZXIgbWVhbnMgbm8gZGF0YSwgaW5zdGVhZCBpdCBpcyBleHBsaWNpdGx5IHNldCB1c2luZyAnOicuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVjbDIgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSgrZWNsMSwgK2VjbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMobWFwLCByZWdpb25zKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZvbnQgY29sb3IgZm9yIGdyaWQgY2FydG9ncmFtcyAoY29udHJhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbG9yID0gc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQoY2VsbENvbG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiBtaXhpbmcgZGlmZmVyZW50IE5VVFMgbGV2ZWxzIChlLmcuIHNob3dpbmcgTlVUUyAxIGFuZCBOVVRTIDIgZGF0YSBzaW11bHRhbmVvdXNseSlcclxuICAgIGNvbnN0IHN0eWxlTWl4ZWROVVRTID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBzZWwuYXR0cignZWNsMScpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gc2VsLmF0dHIoJ2VjbDInKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGRpc3BsYXkgdmlzaWJpbGl0eXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVjbDEgfHwgZWNsMiB8fCBsdmwgPT09ICcwJ1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHN0eWxlcyBlZmZpY2llbnRseVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdkaXNwbGF5JywgaXNWaXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJylcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGVjbDEgfHwgZWNsMikgJiYgbHZsICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpIHx8ICcjNzc3J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKSB8fCAwLjJcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ3N0cm9rZScsIHN0cm9rZSkuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zID0gZnVuY3Rpb24gKG1hcCwgcmVnaW9ucykge1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmlsbCA9IHNlbC5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJpdmFyaWF0ZUxlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmNvbnN0IHNjYWxlQml2YXJpYXRlID0gZnVuY3Rpb24gKG51bWJlck9mQ2xhc3Nlcywgc3RhcnRDb2xvciwgY29sb3IxLCBjb2xvcjIsIGVuZENvbG9yKSB7XHJcbiAgICAvL2NvbG9yIHJhbXBzLCBieSByb3dcclxuICAgIGNvbnN0IGNzID0gW11cclxuICAgIC8vaW50ZXJwb2xhdGUgZnJvbSBmaXJzdCBhbmQgbGFzdCBjb2x1bW5zXHJcbiAgICBjb25zdCByYW1wUzEgPSBpbnRlcnBvbGF0ZVJnYihzdGFydENvbG9yLCBjb2xvcjEpXHJcbiAgICBjb25zdCByYW1wMkUgPSBpbnRlcnBvbGF0ZVJnYihjb2xvcjIsIGVuZENvbG9yKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHQgPSBpIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpXHJcbiAgICAgICAgY29uc3QgY29sRnVuID0gaW50ZXJwb2xhdGVSZ2IocmFtcFMxKHQpLCByYW1wMkUodCkpXHJcbiAgICAgICAgY29uc3Qgcm93ID0gW11cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bWJlck9mQ2xhc3NlczsgaisrKSByb3cucHVzaChjb2xGdW4oaiAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSkpXHJcbiAgICAgICAgY3MucHVzaChyb3cpXHJcbiAgICB9XHJcbiAgICAvL1RPRE8gY29tcHV0ZSBvdGhlciBtYXRyaXggYmFzZWQgb24gcm93cywgYW5kIGF2ZXJhZ2UgYm90aD9cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbDEsIGVjbDIpIHtcclxuICAgICAgICByZXR1cm4gY3NbZWNsMV1bZWNsMl1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNwZWNpZmljIGZ1bmN0aW9uIGZvciB0b29sdGlwIHRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcmcgVGhlIHJlZ2lvbiB0byBzaG93IGluZm9ybWF0aW9uIG9uLlxyXG4gKiBAcGFyYW0geyp9IG1hcCBUaGUgbWFwIGVsZW1lbnRcclxuICovXHJcbmNvbnN0IHRvb2x0aXBUZXh0RnVuQml2ID0gZnVuY3Rpb24gKHJnLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcbiAgICAvL3JlZ2lvbiBuYW1lXHJcbiAgICBjb25zdCByZWdpb25OYW1lID0gcmcucHJvcGVydGllcy5uYSB8fCByZy5wcm9wZXJ0aWVzLm5hbWVcclxuICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIiA+JyArIHJlZ2lvbk5hbWUgKyAnICgnICsgcmcucHJvcGVydGllcy5pZCArICcpIDwvZGl2PicpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vcmVnaW9uIG5hbWVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiID4nICsgcmVnaW9uTmFtZSArICc8L2Rpdj4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhdCAxIHZhbHVlXHJcbiAgICBjb25zdCBzdjEgPSBtYXAuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICBjb25zdCB1bml0MSA9IG1hcC5zdGF0RGF0YSgndjEnKS51bml0VGV4dCgpXHJcbiAgICAvL3N0YXQgMiB2YWx1ZVxyXG4gICAgY29uc3Qgc3YyID0gbWFwLnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDIgPSBtYXAuc3RhdERhdGEoJ3YyJykudW5pdFRleHQoKVxyXG5cclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiIHN0eWxlPVwiYmFja2dyb3VuZDogI2ZmZmZmZjtjb2xvcjogIzE3MWEyMjtwYWRkaW5nOiA0cHg7Zm9udC1zaXplOjE1cHg7XCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgIDx0Ym9keT5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICR7c3YxICYmIHN2MS52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpIDogJyd9ICR7dW5pdDEgJiYgc3YxICYmIHN2MS52YWx1ZSA/IHVuaXQxIDogJyd9XHJcbiAgICAgICAgJHshc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICR7c3YyICYmIHN2Mi52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjIudmFsdWUpIDogJyd9ICR7dW5pdDIgJiYgc3YyICYmIHN2Mi52YWx1ZSA/IHVuaXQyIDogJyd9XHJcbiAgICAgICAgJHshc3YyIHx8IChzdjIudmFsdWUgIT0gMCAmJiAhc3YyLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVSZ2IgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBUcml2YXJpYXRlTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aC10cml2YXJpYXRlJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yLCBleGVjdXRlRm9yQWxsSW5zZXRzLCBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgsIGdldFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgdHJpdmFyaWF0ZSBjaG9yb3BsZXRoIG1hcC5cclxuICogU2VlOiBodHRwczovL2dpc3Rib2sudWNnaXMub3JnL2Jvay10b3BpY3MvbXVsdGl2YXJpYXRlLW1hcHBpbmdcclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCBmYWxzZSwgJ2NodHJpJylcclxuXHJcbiAgICAvL251bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgY2xhc3NpZmljYXRpb24uIFNhbWUgZm9yIGJvdGggdmFyaWFibGVzLlxyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSAzXHJcbiAgICAvL3N0ZXZlbnMuZ3JlZW5ibHVlXHJcbiAgICAvL1RPRE8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZGl2ZXJnaW5nIGNvbG9yIHJhbXBzID9cclxuICAgIG91dC5zdGFydENvbG9yXyA9ICcjZThlOGU4J1xyXG4gICAgb3V0LmNvbG9yMV8gPSAnIzA5RjhGRidcclxuICAgIG91dC5jb2xvcjJfID0gJyNGNUQzMDAnXHJcbiAgICBvdXQuY29sb3IzXyA9ICcjRkYxNDkzJ1xyXG4gICAgb3V0LmVuZENvbG9yXyA9ICcjMmE1YTViJ1xyXG4gICAgLy9hIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3JzIGZvciB0aGUgY2xhc3NlcyBpLGpcclxuICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlXyA9IHVuZGVmaW5lZFxyXG4gICAgLy90aGUgY2xhc3NpZmllcjogYSBmdW5jdGlvbiB3aGljaCByZXR1cm4gYSBjbGFzcyBudW1iZXIgZnJvbSBhIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllcjFfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllcjJfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllcjNfID0gdW5kZWZpbmVkXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHRvb2x0aXBUZXh0RnVuY3Rpb25Ucml2YXJpYXRlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ3N0YXJ0Q29sb3JfJyxcclxuICAgICAgICAnY29sb3IxXycsXHJcbiAgICAgICAgJ2NvbG9yMl8nLFxyXG4gICAgICAgICdjb2xvcjNfJyxcclxuICAgICAgICAnZW5kQ29sb3JfJyxcclxuICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjFfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjJfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFsnbnVtYmVyT2ZDbGFzc2VzJywgJ3N0YXJ0Q29sb3InLCAnY29sb3IxJywgJ2NvbG9yMicsICdjb2xvcjMnLCAnZW5kQ29sb3InLCAnY2xhc3NUb0ZpbGxTdHlsZScsICdub0RhdGFGaWxsU3R5bGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChtYXApIHtcclxuICAgICAgICAvL3NldCBjbGFzc2lmaWVyc1xyXG4gICAgICAgIGxldCBzdGF0MSA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXRBcnJheSgpXHJcbiAgICAgICAgbGV0IHN0YXQyID0gb3V0LnN0YXREYXRhKCd2MicpLmdldEFycmF5KClcclxuICAgICAgICBsZXQgc3RhdDMgPSBvdXQuc3RhdERhdGEoJ3YzJykuZ2V0QXJyYXkoKVxyXG5cclxuICAgICAgICBjb25zdCByYW5nZSA9IFsuLi5BcnJheSg3KS5rZXlzKCldXHJcbiAgICAgICAgaWYgKCFvdXQuY2xhc3NpZmllcjFfKSBvdXQuY2xhc3NpZmllcjEoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihzdGF0MSkucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIyXykgb3V0LmNsYXNzaWZpZXIyKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDIpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICBpZiAoIW91dC5jbGFzc2lmaWVyM18pIG91dC5jbGFzc2lmaWVyMyhzY2FsZVF1YW50aWxlKCkuZG9tYWluKHN0YXQzKS5yYW5nZShyYW5nZSkpXHJcblxyXG4gICAgICAgIC8vYXNzaWduIGNsYXNzIHRvIG51dHMgcmVnaW9ucywgYmFzZWQgb24gdGhlaXIgdmFsdWVcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDEnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIyXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMycsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MycpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyM18oK3YpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3JlZ2lvbkNsYXNzJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMSA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wxJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDInKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDMgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMycpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnIHx8IGVjbDIgPT09ICduZCcgfHwgZWNsMyA9PT0gJ25kJykgcmV0dXJuICduZCcgLy8gSGFuZGxlICdubyBkYXRhJ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoZSBjbGFzc2lmaWVyIHJlc3VsdHMgaW50byBhIHNpbmdsZSBjbGFzcyAoMS03KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmICFlY2wyICYmICFlY2wzKSByZXR1cm4gMSAvLyBvbmx5IHZhcmlhYmxlIDEgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsMSAmJiBlY2wyICYmICFlY2wzKSByZXR1cm4gMiAvLyBvbmx5IHZhcmlhYmxlIDIgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsMSAmJiAhZWNsMiAmJiBlY2wzKSByZXR1cm4gMyAvLyBvbmx5IHZhcmlhYmxlIDMgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmIGVjbDIgJiYgIWVjbDMpIHJldHVybiA0IC8vIHZhcmlhYmxlcyAxICYgMiBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVjbDEgJiYgIWVjbDIgJiYgZWNsMykgcmV0dXJuIDUgLy8gdmFyaWFibGVzIDEgJiAzIHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgZWNsMiAmJiBlY2wzKSByZXR1cm4gNiAvLyB2YXJpYWJsZXMgMiAmIDMgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmIGVjbDIgJiYgZWNsMykgcmV0dXJuIDcgLy8gYWxsIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIC5hdHRyKCduZCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAvLyAgICAgY29uc3Qgc3YxID0gb3V0LnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKSB8fCBvdXQuc3RhdERhdGEoKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgLy8gICAgIGNvbnN0IHN2MiA9IG91dC5zdGF0RGF0YSgndjInKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgLy8gICAgIGlmICghc3YxIHx8ICFzdjIpIHJldHVyblxyXG4gICAgICAgICAgICAvLyAgICAgbGV0IHYgPSBzdjEudmFsdWVcclxuICAgICAgICAgICAgLy8gICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgLy8gICAgIHYgPSBzdjIudmFsdWVcclxuICAgICAgICAgICAgLy8gICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiAnJ1xyXG4gICAgICAgICAgICAvLyB9KVxyXG5cclxuICAgICAgICAgICAgLy93aGVuIG1peGluZyBOVVRTLCBsZXZlbCAwIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0IChjbGFzcyBudXRzcmcwKVxyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5lbS1udXRzcmcwJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIxXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjJfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDMnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YzJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyM18oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kZWZpbmUgdHJpdmFyaWF0ZSBzY2FsZVxyXG4gICAgICAgICAgICBpZiAoIW91dC5jbGFzc1RvRmlsbFN0eWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVUcml2YXJpYXRlKG91dC5jb2xvcjEoKSwgb3V0LmNvbG9yMigpLCBvdXQuY29sb3IzKCkpXHJcbiAgICAgICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShzY2FsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy93aGVuIG1peGluZyBOVVRTLCBsZXZlbCAwIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0ICh1c2luZyBjbGFzcyBudXRzcmcwKVxyXG4gICAgICAgICAgICBpZiAob3V0Lm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnN2Z19cclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wxJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDInLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyMl8oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMycsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjMnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIzXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNjYWxlVHJpdmFyaWF0ZSA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMiwgY29sb3IzKSB7XHJcbiAgICAgICAgLy8gQmxlbmRpbmcgcHJpbWFyeSBjb2xvcnMgYW5kIHRoZWlyIG92ZXJsYXBzXHJcbiAgICAgICAgY29uc3Qgb3ZlcmxhcENvbG9ycyA9IFtcclxuICAgICAgICAgICAgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcjEsIGNvbG9yMl0pLCAvLyBDbGFzcyA0IChPdmVybGFwIG9mIGNvbG9yMSBhbmQgY29sb3IyKVxyXG4gICAgICAgICAgICBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yMiwgY29sb3IzXSksIC8vIENsYXNzIDUgKE92ZXJsYXAgb2YgY29sb3IyIGFuZCBjb2xvcjMpXHJcbiAgICAgICAgICAgIG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3IxLCBjb2xvcjNdKSwgLy8gQ2xhc3MgNiAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcjEsIGNvbG9yMiwgY29sb3IzXSksIC8vIENsYXNzIDcgKE92ZXJsYXAgb2YgYWxsIHRocmVlKVxyXG4gICAgICAgIF1cclxuXHJcbiAgICAgICAgLy8gQ2xhc3MtdG8tY29sb3IgbWFwcGluZ1xyXG4gICAgICAgIGNvbnN0IGNsYXNzQ29sb3JzID0gW1xyXG4gICAgICAgICAgICBjb2xvcjEsIC8vIENsYXNzIDEgKEZpcnN0IGNvbG9yKVxyXG4gICAgICAgICAgICBjb2xvcjIsIC8vIENsYXNzIDIgKFNlY29uZCBjb2xvcilcclxuICAgICAgICAgICAgY29sb3IzLCAvLyBDbGFzcyAzIChUaGlyZCBjb2xvcilcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1swXSwgLy8gQ2xhc3MgNCAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMilcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1sxXSwgLy8gQ2xhc3MgNSAoT3ZlcmxhcCBvZiBjb2xvcjIgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1syXSwgLy8gQ2xhc3MgNiAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1szXSwgLy8gQ2xhc3MgNyAoT3ZlcmxhcCBvZiBhbGwgdGhyZWUpXHJcbiAgICAgICAgXVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gZnVuY3Rpb24gdG8gZ2V0IGNvbG9yIGJhc2VkIG9uIHJlZ2lvbidzIGNsYXNzICgxIHRvIDcpXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc0luZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc0luZGV4ID49IDEgJiYgY2xhc3NJbmRleCA8PSA3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NDb2xvcnNbY2xhc3NJbmRleCAtIDFdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAvLyBSZXR1cm4gbnVsbCBvciBhIGRlZmF1bHQgY29sb3IgaWYgdGhlIGNsYXNzSW5kZXggaXMgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBzdHlsZSB0byBpbnNldHNcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseVN0eWxlVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9hcHBseSBzdHlsZSB0byBudXRzIHJlZ2lvbnNcclxuXHJcbiAgICAgICAgLy8gc2V0IGNvbG91ciBvZiByZWdpb25zXHJcbiAgICAgICAgaWYgKG1hcC5zdmcoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKG91dC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMScpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMiA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wyJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wzID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDMnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wyID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wzID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgIWVjbDIgJiYgIWVjbDMpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKSAvLyBHSVNDTy0yNjc4IC0gbGFjayBvZiBkYXRhIG5vIGxvbmdlciBtZWFucyBubyBkYXRhLCBpbnN0ZWFkIGl0IGlzIGV4cGxpY2l0bHkgc2V0IHVzaW5nICc6Jy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlZ2lvbkNsYXNzID0gc2VsZWN0KHRoaXMpLmF0dHIoJ3JlZ2lvbkNsYXNzJylcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8ocmVnaW9uQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlTWl4ZWROVVRTKG1hcClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBUcml2YXJpYXRlTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuY29uc3Qgc3R5bGVNaXhlZE5VVFMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICBtYXAuc3ZnKClcclxuICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgIC5zdHlsZSgnZGlzcGxheScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50cnlJZCA9IHJnLnByb3BlcnRpZXMuaWQuc2xpY2UoMCwgMilcclxuICAgICAgICAgICAgcmV0dXJuIGVjbCB8fCBsdmwgPT09ICcwJyA/ICdibG9jaycgOiAnbm9uZSdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpXHJcbiAgICAgICAgICAgIHJldHVybiBlY2wgJiYgbHZsICE9PSAnMCcgPyBzdHJva2UgfHwgJyM3NzcnIDogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBsdmwgPSBzZWwuYXR0cignbHZsJylcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKVxyXG4gICAgICAgICAgICByZXR1cm4gZWNsICYmIGx2bCAhPT0gJzAnID8gc3Ryb2tlV2lkdGggfHwgMC4yIDogbnVsbFxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcGVjaWZpYyBmdW5jdGlvbiBmb3IgdG9vbHRpcCB0ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHJnIFRoZSByZWdpb24gdG8gc2hvdyBpbmZvcm1hdGlvbiBvbi5cclxuICogQHBhcmFtIHsqfSBtYXAgVGhlIG1hcCBlbGVtZW50XHJcbiAqL1xyXG5jb25zdCB0b29sdGlwVGV4dEZ1bmN0aW9uVHJpdmFyaWF0ZSA9IGZ1bmN0aW9uIChyZywgbWFwKSB7XHJcbiAgICBjb25zdCBidWYgPSBbXVxyXG4gICAgLy9yZWdpb24gbmFtZVxyXG4gICAgaWYgKHJnLnByb3BlcnRpZXMuaWQpIHtcclxuICAgICAgICAvL25hbWUgYW5kIGNvZGVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiID4nICsgcmcucHJvcGVydGllcy5uYSArICcgKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPC9kaXY+JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCIgPicgKyByZy5wcm9wZXJ0aWVzLm5hICsgJzwvZGl2PicpXHJcbiAgICB9XHJcblxyXG4gICAgLy9zdGF0IDEgdmFsdWVcclxuICAgIGNvbnN0IHN2MSA9IG1hcC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgIGNvbnN0IHVuaXQxID0gbWFwLnN0YXREYXRhKCd2MScpLnVuaXRUZXh0KClcclxuICAgIC8vc3RhdCAyIHZhbHVlXHJcbiAgICBjb25zdCBzdjIgPSBtYXAuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICBjb25zdCB1bml0MiA9IG1hcC5zdGF0RGF0YSgndjInKS51bml0VGV4dCgpXHJcbiAgICAvL3N0YXQgMyB2YWx1ZVxyXG4gICAgY29uc3Qgc3YzID0gbWFwLnN0YXREYXRhKCd2MycpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDMgPSBtYXAuc3RhdERhdGEoJ3YyJykudW5pdFRleHQoKVxyXG5cclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiIHN0eWxlPVwiYmFja2dyb3VuZDogI2ZmZmZmZjtjb2xvcjogIzE3MWEyMjtwYWRkaW5nOiA0cHg7Zm9udC1zaXplOjE1cHg7XCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgIDx0Ym9keT5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgIFZhcmlhYmxlIDE6ICR7c3YxICYmIHN2MS52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpIDogJyd9ICR7dW5pdDEgJiYgc3YxICYmIHN2MS52YWx1ZSA/IHVuaXQxIDogJyd9XHJcbiAgICAgICAgJHshc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICBWYXJpYWJsZSAyOiAke3N2MiAmJiBzdjIudmFsdWUgPyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YyLnZhbHVlKSA6ICcnfSAke3VuaXQyICYmIHN2MiAmJiBzdjIudmFsdWUgPyB1bml0MiA6ICcnfVxyXG4gICAgICAgICR7IXN2MiB8fCAoc3YyLnZhbHVlICE9IDAgJiYgIXN2Mi52YWx1ZSkgPyBtYXAubm9EYXRhVGV4dF8gOiAnJ31cclxuICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICAgICAgPHRyPlxyXG4gICAgICAgIDx0ZD5cclxuICAgICAgICAgVmFyaWFibGUgMzogJHtzdjMgJiYgc3YzLnZhbHVlID8gc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2My52YWx1ZSkgOiAnJ30gJHt1bml0MyAmJiBzdjMgJiYgc3YzLnZhbHVlID8gdW5pdDMgOiAnJ31cclxuICAgICAgICAkeyFzdjMgfHwgKHN2My52YWx1ZSAhPSAwICYmICFzdjMudmFsdWUpID8gbWFwLm5vRGF0YVRleHRfIDogJyd9XHJcbiAgICAgICAgPC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2NhbGVRdWFudGlsZSwgc2NhbGVRdWFudGl6ZSwgc2NhbGVUaHJlc2hvbGQgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVZbEduQnUgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCB7IHBpZWNld2lzZSwgaW50ZXJwb2xhdGVMYWIgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBDaG9yb3BsZXRoTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kLCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBqZW5rcywgY2ttZWFucyB9IGZyb20gJ3NpbXBsZS1zdGF0aXN0aWNzJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCB7IGFwcGx5UGF0dGVybkZpbGwgfSBmcm9tICcuLi9jb3JlL3BhdHRlcm4tZmlsbCdcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY2hyb3JvcGxldGggbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIGZhbHNlLCAnY2gnKVxyXG5cclxuICAgIC8vdGhlIG51bWJlciBvZiBjbGFzc2VzXHJcbiAgICBvdXQubnVtYmVyT2ZDbGFzc2VzXyA9IDdcclxuICAgIC8vdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZFxyXG4gICAgb3V0LmNsYXNzaWZpY2F0aW9uTWV0aG9kXyA9ICdxdWFudGlsZScgLy8gb3I6IGVxdWludGVyLCB0aHJlc2hvbGRcclxuICAgIC8vdGhlIHRocmVzaG9sZCwgd2hlbiB0aGUgY2xhc3NpZmljYXRpb24gbWV0aG9kIGlzICd0aHJlc2hvbGQnXHJcbiAgICBvdXQudGhyZXNob2xkc18gPSBbMF1cclxuICAgIC8vY29sb3JzIHRvIHVzZSBmb3IgY2xhc3Nlc1xyXG4gICAgb3V0LmNvbG9yc18gPSBudWxsXHJcbiAgICAvL3doZW4gY29tcHV0ZWQgYXV0b21hdGljYWxseSwgZW5zdXJlIHRoZSB0aHJlc2hvbGQgYXJlIG5pY2Ugcm91bmRlZCB2YWx1ZXNcclxuICAgIG91dC5tYWtlQ2xhc3NpZk5pY2VfID0gdHJ1ZVxyXG4gICAgLy90aGUgY29sb3IgZnVuY3Rpb24gWzAsMV0gLT4gY29sb3JcclxuICAgIGxldCBldXJvc3RhdE11bHRpaHVlID0gWycjRkZFQjk5JywgJyNEMUU5QjAnLCAnIzhERDZCOScsICcjNThDMUMwJywgJyMzNzkyQjYnLCAnIzEzNDg5MScsICcjMWQyYjZmJ11cclxuICAgIG91dC5jb2xvckZ1bmN0aW9uXyA9ICh0KSA9PiBwaWVjZXdpc2UoaW50ZXJwb2xhdGVMYWIsIGV1cm9zdGF0TXVsdGlodWUpKE1hdGgubWluKE1hdGgubWF4KDAsIHQpLCAxKSkgLy8gZGVmYXVsdFxyXG4gICAgLy9hIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3IgZnJvbSB0aGUgY2xhc3MgaVxyXG4gICAgb3V0LmNsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyOiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybiBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyXyA9IHVuZGVmaW5lZFxyXG4gICAgLy8gc2V0IHRvb2x0aXAgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBjaG9yb3BsZXRoVG9vbHRpcEZ1bmN0aW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpY2F0aW9uTWV0aG9kXycsXHJcbiAgICAgICAgJ3RocmVzaG9sZHNfJyxcclxuICAgICAgICAnbWFrZUNsYXNzaWZOaWNlXycsXHJcbiAgICAgICAgJ2NvbG9yRnVuY3Rpb25fJyxcclxuICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAnY2xhc3NpZmllcl8nLFxyXG4gICAgICAgICdjb2xvcnNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIG9mIHNvbWUgc3BlY2lhbCBnZXR0ZXJzL3NldHRlcnNcclxuICAgIG91dC5jb2xvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5jb2xvckZ1bmN0aW9uX1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdXQuY29sb3JGdW5jdGlvbl8gPSB2XHJcbiAgICAgICAgLy8gdXBkYXRlIGNsYXNzIHN0eWxlIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXykge1xyXG4gICAgICAgICAgICAvLyBpZiBkb3QgZGVuc2l0eVxyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRGaWxsUGF0dGVybkxlZ2VuZCgpKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGdldENvbG9yTGVnZW5kKG91dC5jb2xvckZ1bmN0aW9uKCksIG91dC5jb2xvcnNfKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG4gICAgb3V0LnRocmVzaG9sZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnRocmVzaG9sZHNfXHJcbiAgICAgICAgb3V0LnRocmVzaG9sZHNfID0gdlxyXG4gICAgICAgIG91dC5udW1iZXJPZkNsYXNzZXModi5sZW5ndGggKyAxKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuICAgIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl9cclxuICAgICAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8gPSB2XHJcbiAgICAgICAgaWYgKG91dC5zdmcoKSkgb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fKG91dC5zdmcoKSwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzJyxcclxuICAgICAgICAgICAgJ2NsYXNzaWZpY2F0aW9uTWV0aG9kJyxcclxuICAgICAgICAgICAgJ3RocmVzaG9sZCcsXHJcbiAgICAgICAgICAgICdtYWtlQ2xhc3NpZk5pY2UnLFxyXG4gICAgICAgICAgICAnY29sb3JGdW5jdGlvbicsXHJcbiAgICAgICAgICAgICdjbGFzc1RvRmlsbFN0eWxlJyxcclxuICAgICAgICAgICAgJ25vRGF0YUZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdjb2xvcnNfJyxcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBtYWluIG1hcCdzIFNWR1xyXG4gICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1cGRhdGVDbGFzc2lmaWNhdGlvbjonLCBlLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHJhbmdlIFswLCAxLCAyLCAuLi4sIG5iLTFdXHJcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVSYW5nZSA9IChuYikgPT4gWy4uLkFycmF5KG5iKS5rZXlzKCldXHJcblxyXG4gICAgICAgIC8vIENvbmZpZ3VyZSBjbGFzc2lmaWVyIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBjbGFzc2lmaWNhdGlvbiBtZXRob2RcclxuICAgICAgICBjb25zdCBzZXR1cENsYXNzaWZpZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG91dC5zdGF0RGF0YSgpLmdldEFycmF5KClcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZW5lcmF0ZVJhbmdlKG91dC5udW1iZXJPZkNsYXNzZXNfKVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChvdXQuY2xhc3NpZmljYXRpb25NZXRob2RfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFudGlsZSc6IHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuY2xhc3NpZmllcihzY2FsZVF1YW50aWxlKCkuZG9tYWluKGRhdGFBcnJheSkucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcXVhbC1pbnRlcnZhbCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcXVpbnRlcic6IHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuY2xhc3NpZmllcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVRdWFudGl6ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFttaW4oZGF0YUFycmF5KSwgbWF4KGRhdGFBcnJheSldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHJhbmdlKVxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1ha2VDbGFzc2lmTmljZV8pIG91dC5jbGFzc2lmaWVyKCkubmljZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RocmVzaG9sZCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQubnVtYmVyT2ZDbGFzc2VzKG91dC50aHJlc2hvbGRzXy5sZW5ndGggKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKHNjYWxlVGhyZXNob2xkKCkuZG9tYWluKG91dC50aHJlc2hvbGRzXykucmFuZ2UoZ2VuZXJhdGVSYW5nZShvdXQubnVtYmVyT2ZDbGFzc2VzXykpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdqZW5rcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqZW5rc0JyZWFrcyA9IGplbmtzKGRhdGFBcnJheSwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pIC8vIENhbGN1bGF0ZSBicmVha3MgZm9yIEplbmtzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gamVua3NCcmVha3Muc2xpY2UoMSwgLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVUaHJlc2hvbGQoKS5kb21haW4oZG9tYWluKS5yYW5nZShyYW5nZSkpIC8vIFVzZSBKZW5rcyBicmVha3MgaW4gc2NhbGVcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2ttZWFucyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY2ttZWFucyBicmVha3MsIGV4dHJhY3RpbmcgdGhlIG1heGltdW0gdmFsdWUgZnJvbSBlYWNoIGNsdXN0ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBja21lYW5zQnJlYWtzID0gY2ttZWFucyhkYXRhQXJyYXksIG91dC5udW1iZXJPZkNsYXNzZXNfKS5tYXAoKGNsdXN0ZXIpID0+IGNsdXN0ZXIucG9wKCkpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgZG9tYWluIGZvciBzY2FsZVRocmVzaG9sZCBleGNsdWRpbmcgdGhlIGxhc3QgdmFsdWUsIGFzIGl0IHNlcnZlcyBhcyB0aGUgdXBwZXIgYm91bmRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBja21lYW5zQnJlYWtzLnNsaWNlKDAsIC0xKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGNrbWVhbnMgYnJlYWtzIGluIHRoZSBzY2FsZVRocmVzaG9sZCBhbmQgc2V0IHRoZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVUaHJlc2hvbGQoKS5kb21haW4oZG9tYWluKS5yYW5nZShyYW5nZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgY2xhc3NpZmllciBhbmQgc2V0ICdlY2wnIGF0dHJpYnV0ZSB0byByZWdpb25zIGJhc2VkIG9uIHZhbHVlXHJcbiAgICAgICAgY29uc3QgY2xhc3NpZnlSZWdpb25zID0gKHJlZ2lvbnMpID0+IHtcclxuICAgICAgICAgICAgcmVnaW9ucy5hdHRyKCdlY2wnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lvbkRhdGEgPSBvdXQuc3RhdERhdGEoKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmICghcmVnaW9uRGF0YSkgcmV0dXJuIC8vIExhY2sgb2YgZGF0YSBpcyBoYW5kbGVkIGV4cGxpY2l0bHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVnaW9uRGF0YS52YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnOicgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/ICtvdXQuY2xhc3NpZmllcl8odmFsdWUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIGNsYXNzaWZpZXJcclxuICAgICAgICBzZXR1cENsYXNzaWZpZXIoKVxyXG5cclxuICAgICAgICAvLyBBcHBseSBjbGFzc2lmaWNhdGlvbiBhbmQgYXNzaWduICdlY2wnIGF0dHJpYnV0ZSBiYXNlZCBvbiBtYXAgdHlwZVxyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcikpXHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgbWl4ZWQgTlVUUyBsZXZlbCwgc2VwYXJhdGluZyBOVVRTIGxldmVsIDBcclxuICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBudXRzMFJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICAgICAgY2xhc3NpZnlSZWdpb25zKG51dHMwUmVnaW9ucylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIGFwcGx5IHN0eWxlIHRvIGluc2V0c1xyXG4gICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseVN0eWxlVG9NYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1cGRhdGVTdHlsZTonLCBlLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vIERlZmluZSBmdW5jdGlvbiB0byBnZXQgYSBjbGFzcycgY29sb3JcclxuICAgICAgICBpZiAob3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fKSB7XHJcbiAgICAgICAgICAgIC8vIERvdCBkZW5zaXR5IHN0eWxlXHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGdldEZpbGxQYXR0ZXJuTGVnZW5kKCkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ29sb3IgbGVnZW5kIHN0eWxlXHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGdldENvbG9yTGVnZW5kKG91dC5jb2xvckZ1bmN0aW9uKCksIG91dC5jb2xvcnNfKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNvbG9yIGFuZCBldmVudHMgdG8gcmVnaW9ucyBpZiBTVkcgZXhpc3RzXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSB0cmFuc2l0aW9uIGFuZCBzZXQgaW5pdGlhbCBmaWxsIGNvbG9ycyB3aXRoIGRhdGEtZHJpdmVuIGxvZ2ljXHJcbiAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCByZWdpb25zRmlsbEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGNvbG9yIGZvciBlYWNoIHJlZ2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIHNlbC5zdHlsZSgnZmlsbCcpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHVwIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zKG1hcCwgcmVnaW9ucylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZvbnQgY29sb3IgZm9yIGdyaWQgY2FydG9ncmFtcyAoY29udHJhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5ncmlkQ2FydG9ncmFtXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb2xvciA9IHNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQoY2VsbENvbG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKCdFcnJvciBhcHBseWluZyB0cmFuc2l0aW9uIHRvIHJlZ2lvbnM6JywgZXJyKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGFkZGl0aW9uYWwgc2V0dGluZ3MgZm9yIG1peGVkIE5VVFMgbGV2ZWwgdmlld1xyXG4gICAgICAgICAgICBpZiAob3V0Lm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlTWl4ZWROVVRTKG1hcClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGxhYmVscyBmb3Igc3RhdGlzdGljYWwgdmFsdWVzIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5sYWJlbHNfLnZhbHVlcykgb3V0LnVwZGF0ZVZhbHVlc0xhYmVscyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vYWRkIGhhdGNoaW5nIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZiAob3V0LnBhdHRlcm5GaWxsXykge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlQYXR0ZXJuRmlsbChtYXAsIG91dC5wYXR0ZXJuRmlsbF8pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQ2hvcm9wbGV0aExlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICAvLyB3aGVuIG1peGluZyBkaWZmZXJlbnQgTlVUUyBsZXZlbHMgKGUuZy4gc2hvd2luZyBOVVRTIDEgYW5kIE5VVFMgMiBkYXRhIHNpbXVsdGFuZW91c2x5KVxyXG4gICAgY29uc3Qgc3R5bGVNaXhlZE5VVFMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcCkpXHJcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlbS1jbnRyZycpKSByZXR1cm4gLy8gU2tpcCBjb3VudHJ5IHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsdmwgPSBzZWwuYXR0cignbHZsJylcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZGlzcGxheSB2aXNpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBlY2wgfHwgbHZsID09PSAnMCdcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBzdHlsZXMgZWZmaWNpZW50bHlcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZGlzcGxheScsIGlzVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZScpXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVjbCAmJiBsdmwgIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHNlbC5zdHlsZSgnc3Ryb2tlJykgfHwgJyM3NzcnXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBzZWwuc3R5bGUoJ3N0cm9rZS13aWR0aCcpIHx8IDAuMlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnc3Ryb2tlJywgc3Ryb2tlKS5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVnaW9uc0ZpbGxGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgIGNvbnN0IGVjbCA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wnKSAvLyAndGhpcycgcmVmZXJzIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XHJcbiAgICAgICAgaWYgKG91dC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSB7XHJcbiAgICAgICAgICAgIGlmICghZWNsKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJylcclxuICAgICAgICAgICAgaWYgKGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5jbGFzc1RvRmlsbFN0eWxlKCkoZWNsLCBvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3V0Lmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIG91dC5jbnRyZ0ZpbGxTdHlsZV9cclxuICAgICAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8oZWNsLCBvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxsU3R5bGUgfHwgb3V0LmNudHJnRmlsbFN0eWxlX1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTlVUUyB0ZW1wbGF0ZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRyeUlkID0gcmcucHJvcGVydGllcy5pZC5zbGljZSgwLCAyKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgaWYgKGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMgPSBmdW5jdGlvbiAobWFwLCByZWdpb25zKSB7XHJcbiAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBtYXAuaG92ZXJDb2xvcl8pIC8vIEFwcGx5IGhpZ2hsaWdodCBjb2xvclxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpIC8vIFJldmVydCB0byBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbi8vYnVpbGQgYSBjb2xvciBsZWdlbmQgb2JqZWN0XHJcbmV4cG9ydCBjb25zdCBnZXRDb2xvckxlZ2VuZCA9IGZ1bmN0aW9uIChjb2xvckZ1bmN0aW9uLCBjb2xvckFycmF5KSB7XHJcbiAgICBjb2xvckZ1bmN0aW9uID0gY29sb3JGdW5jdGlvbiB8fCBpbnRlcnBvbGF0ZVlsR25CdVxyXG4gICAgaWYgKGNvbG9yQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckFycmF5W2VjbF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb24oZWNsIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpKVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQnVpbGQgYSBmaWxsIHBhdHRlcm4gbGVnZW5kIG9iamVjdCB7IG5kOlwid2hpdGVcIiwgMDpcInVybCgjcGF0dGVybl8wKVwiLCAxOlwidXJsKCNwYXR0ZXJuXzEpXCIsIC4uLiB9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RmlsbFBhdHRlcm5MZWdlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCkge1xyXG4gICAgICAgIHJldHVybiAndXJsKCNwYXR0ZXJuXycgKyBlY2wgKyAnKSdcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgY2hvcm9wbGV0aFRvb2x0aXBGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZWdpb24sIG1hcCkge1xyXG4gICAgaWYgKG1hcC50b29sdGlwXy5vbWl0UmVnaW9ucyAmJiBtYXAudG9vbHRpcF8ub21pdFJlZ2lvbnMuaW5jbHVkZXMocmVnaW9uLnByb3BlcnRpZXMuaWQpKSB7XHJcbiAgICAgICAgcmV0dXJuICcnIC8vIFNraXAgdG9vbHRpcCBmb3Igb21pdHRlZCByZWdpb25zXHJcbiAgICB9XHJcbiAgICBjb25zdCBidWYgPSBbXVxyXG5cclxuICAgIC8vIEhlYWRlciB3aXRoIHJlZ2lvbiBuYW1lIGFuZCBJRFxyXG4gICAgY29uc3QgcmVnaW9uTmFtZSA9IHJlZ2lvbi5wcm9wZXJ0aWVzLm5hIHx8IHJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWVcclxuICAgIGNvbnN0IHJlZ2lvbklkID0gcmVnaW9uLnByb3BlcnRpZXMuaWRcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+XHJcbiAgICAgICAgICAgIDxiPiR7cmVnaW9uTmFtZX08L2I+JHtyZWdpb25JZCA/IGAgKCR7cmVnaW9uSWR9KWAgOiAnJ31cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgLy8gUmV0cmlldmUgcmVnaW9uJ3MgZGF0YSB2YWx1ZSBhbmQgdW5pdFxyXG4gICAgY29uc3Qgc3RhdERhdGEgPSBtYXAuc3RhdERhdGEoKVxyXG4gICAgY29uc3Qgc3YgPSBzdGF0RGF0YS5nZXQocmVnaW9uSWQpXHJcbiAgICBjb25zdCB1bml0ID0gc3RhdERhdGEudW5pdFRleHQoKSB8fCAnJ1xyXG5cclxuICAgIC8vIE5vIGRhdGEgY2FzZVxyXG4gICAgaWYgKCFzdiB8fCAoc3YudmFsdWUgIT09IDAgJiYgIXN2LnZhbHVlKSB8fCBzdi52YWx1ZSA9PT0gJzonKSB7XHJcbiAgICAgICAgYnVmLnB1c2goYFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dCBuby1kYXRhXCI+XHJcbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJudXRzLXRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPiR7bWFwLm5vRGF0YVRleHRffTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgYClcclxuICAgICAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGF0YSBkaXNwbGF5XHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIj5cclxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+JHtzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YudmFsdWUpfSAke3VuaXR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgLy8gT3B0aW9uYWwgc3RhdHVzIGZsYWdcclxuICAgIGNvbnN0IHN0YXR1c0ZsYWcgPSBzdi5zdGF0dXNcclxuICAgIGlmIChzdGF0dXNGbGFnICYmIG1hcC50b29sdGlwXy5zaG93RmxhZ3MpIHtcclxuICAgICAgICBjb25zdCBmbGFnVGV4dCA9IG1hcC50b29sdGlwXy5zaG93RmxhZ3MgPT09ICdzaG9ydCcgPyBzdGF0dXNGbGFnIDogZmxhZ3Nbc3RhdHVzRmxhZ10gfHwgc3RhdHVzRmxhZ1xyXG4gICAgICAgIGJ1Zi5wdXNoKGAgPHNwYW4gY2xhc3M9XCJzdGF0dXMtZmxhZ1wiPiR7ZmxhZ1RleHR9PC9zcGFuPmApXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsIi8vIEltcG9ydCByZXF1aXJlZCBEMyBtb2R1bGVzXHJcbi8vIGltcG9ydCB7IHNhbmtleSwgc2Fua2V5TGlua0hvcml6b250YWwgfSBmcm9tICdkMy1zYW5rZXknXHJcbmltcG9ydCB7IGxpbmtIb3Jpem9udGFsIH0gZnJvbSAnZDMtc2hhcGUnXHJcbmltcG9ydCB7IHN1bSwgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCB7IHNjYWxlTGluZWFyIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgRmxvd0xlZ2VuZCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kLWZsb3cnXHJcbmltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCB7IGdldFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGZsb3cgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIHRydWUsICdmbG93JylcclxuICAgIG91dC5zdHJva2VXaWR0aFNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgb3V0LmxhYmVsT2Zmc2V0WCA9IDE1XHJcbiAgICBvdXQubGFiZWxPZmZzZXRZID0gNVxyXG4gICAgb3V0LmxhYmVsRm9ybWF0dGVyID0gKGQpID0+IGZvcm1hdCgnLjJzJykoZClcclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBmbG93TWFwVG9vbHRpcEZ1bmN0aW9uXHJcbiAgICBvdXQuZmxvd0NvbG9yXyA9ICcjNzJiYjZmJ1xyXG4gICAgb3V0LmZsb3dPdmVybGF5Q29sb3JzXyA9IFsnI2JiZDdlZScsICcjYzdlM2M2J10gLy8gZXhwb3J0ZXIsIGltcG9ydGVyc1xyXG4gICAgb3V0LmZsb3dNYXhXaWR0aF8gPSAzMFxyXG4gICAgb3V0LmZsb3dNaW5XaWR0aF8gPSAxXHJcbiAgICBvdXQuZmxvd0Fycm93c18gPSB0cnVlXHJcbiAgICBvdXQuZmxvd091dGxpbmVzXyA9IHRydWVcclxuICAgIG91dC5mbG93VGFyZ2V0T2Zmc2V0XyA9IDEgLy8gRGVmYXVsdCB0byBub3JtYWwgb2Zmc2V0IGJlaGF2aW9yXHJcbiAgICBvdXQuZmxvd0dyYWRpZW50XyA9IHRydWVcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZsb3dtYXAtc3BlY2lmaWMgc2V0dGVycy9nZXR0ZXJzXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ2Zsb3dHcmFwaF8nLFxyXG4gICAgICAgICdmbG93Q29sb3JfJyxcclxuICAgICAgICAnZmxvd092ZXJsYXlDb2xvcnNfJyxcclxuICAgICAgICAnZmxvd0Fycm93c18nLFxyXG4gICAgICAgICdmbG93VGFyZ2V0T2Zmc2V0XycsXHJcbiAgICAgICAgJ2Zsb3dNYXhXaWR0aF8nLFxyXG4gICAgICAgICdmbG93TWluV2lkdGhfJyxcclxuICAgICAgICAnZmxvd091dGxpbmVzXycsXHJcbiAgICAgICAgJ2Zsb3dHcmFkaWVudF8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdHlwZTogXCJGZWF0dXJlXCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzOiBPYmplY3Qge2lkOiBcIkVTXCIsIG5hOiBcIkVzcGHDsWFcIn1cclxuICAgICAgICAvLyBnZW9tZXRyeTogT2JqZWN0IHt0eXBlOiBcIk11bHRpUG9seWdvblwiLCBjb29yZGluYXRlczogQXJyYXkoNyl9XHJcbiAgICAgICAgLy8gc291cmNlOiBcIkZSXCJcclxuICAgICAgICAvLyB0YXJnZXQ6IFwiRVNcIlxyXG4gICAgICAgIC8vIHZhbHVlOiA0NTQyMjMyNy41NlxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgc3Ryb2tlIHdpZHRoIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IG91dC5mbG93R3JhcGhfLmxpbmtzXHJcbiAgICAgICAgb3V0LnN0cm9rZVdpZHRoU2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oWzAsIG1heChkYXRhLCAoZCkgPT4gZC52YWx1ZSldKVxyXG4gICAgICAgICAgICAucmFuZ2UoW291dC5mbG93TWluV2lkdGhfLCBvdXQuZmxvd01heFdpZHRoX10pXHJcblxyXG4gICAgICAgIGNyZWF0ZUZsb3dNYXBTVkcob3V0LmZsb3dHcmFwaF8pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHt9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL1RPRE86IGRlZmluZSBsZWdlbmRcclxuICAgICAgICByZXR1cm4gRmxvd0xlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY3JlYXRlIGEgbWFwIHdpdGggU2Fua2V5IGRpYWdyYW0gYW5kIG90aGVyIGVsZW1lbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGggLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIGRhdGEgZm9yIHRoZSBtYXBcclxuICAgICAqIGV4YW1wbGVHcmFwaCA9IHtcclxuICAgICAgICAgICAgICAgIG5vZGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogJ0ZSJywgeDogNjgxLjE4NTE4MDA3NTkyNjMsIHk6IDIzMC4zMTEyNDc2MzY0ODU4MyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6ICdERScsIHg6IDgyNC41NDM3NzgyMTU0NDg5LCB5OiAxMjMuNzAzMDI2NDkwMzIxOTkgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBsaW5rczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgc291cmNlOiAnRlInLCB0YXJnZXQ6ICdERScsIHZhbHVlOiA4MjAxODM2OS43MiB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93TWFwU1ZHKGdyYXBoKSB7XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gb3V0LnN2Z19cclxuXHJcbiAgICAgICAgLy8gaWYgbm9kZXMgaW4gdGhlIGdyYXBoIGRvbnQgaGF2ZSBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdGhlbiB1c2UgbnV0czJqc29uIGNlbnRyb2lkcyBpbnN0ZWFkXHJcbiAgICAgICAgYWRkQ29vcmRpbmF0ZXNUb0dyYXBoKGdyYXBoKVxyXG5cclxuICAgICAgICB2YXIgeyBub2RlcywgbGlua3MgfSA9IHNhbmtleShncmFwaClcclxuXHJcbiAgICAgICAgLy8gRGVmaW5lIG1hcmtlciBhbmQgZ3JhZGllbnQgSURzXHJcbiAgICAgICAgY29uc3QgZGVmcyA9IHN2Zy5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgICAgIGNvbnN0IGFycm93SWQgPSBnZW5lcmF0ZVVuaXF1ZUlkKCdhcnJvdycpXHJcbiAgICAgICAgY29uc3QgYXJyb3dPdXRsaW5lSWQgPSBnZW5lcmF0ZVVuaXF1ZUlkKCdhcnJvdy1vdXRsaW5lJylcclxuICAgICAgICBjb25zdCBncmFkaWVudElkcyA9IGxpbmtzLm1hcCgoKSA9PiBnZW5lcmF0ZVVuaXF1ZUlkKCdncmFkaWVudCcpKVxyXG5cclxuICAgICAgICAvLyBBZGQgYXJyb3cgbWFya2Vyc1xyXG4gICAgICAgIGlmIChvdXQuZmxvd0Fycm93c18pIHtcclxuICAgICAgICAgICAgYWRkQXJyb3dNYXJrZXIoZGVmcywgYXJyb3dJZCwgb3V0LmZsb3dDb2xvcl8pXHJcbiAgICAgICAgICAgIGFkZEFycm93TWFya2VyKGRlZnMsIGFycm93T3V0bGluZUlkLCAnI2ZmZmZmZicpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgZmxvdyBncmFkaWVudHNcclxuICAgICAgICBpZiAob3V0LmZsb3dHcmFkaWVudF8pIHtcclxuICAgICAgICAgICAgYWRkRmxvd0dyYWRpZW50cyhkZWZzLCBncmFkaWVudElkcywgbGlua3MpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWZpbmUgb3VyIGNvbnRhaW5lciBTVkdcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBzZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IHNhbmtleUNvbnRhaW5lciA9IHpvb21Hcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93LWNvbnRhaW5lcicpXHJcblxyXG4gICAgICAgIC8vIEFkZCBnZW9ncmFwaGljYWwgbGF5ZXJzXHJcbiAgICAgICAgYWRkT3ZlcmxheVBvbHlnb25zKHNhbmtleUNvbnRhaW5lciwgZ3JhcGgpXHJcblxyXG4gICAgICAgIC8vIEFkZCBTYW5rZXkgZmxvd3NcclxuICAgICAgICBhZGRTYW5rZXlGbG93cyhzYW5rZXlDb250YWluZXIsIGxpbmtzLCBhcnJvd0lkLCBhcnJvd091dGxpbmVJZCwgZ3JhZGllbnRJZHMpXHJcblxyXG4gICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIG5vZGVzIChmaWxsIGdhcHMpXHJcbiAgICAgICAgYWRkRmlsbEdhcHMoc2Fua2V5Q29udGFpbmVyLCBub2RlcylcclxuXHJcbiAgICAgICAgLy8gQWRkIGxhYmVscyB0byBub2Rlc1xyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXykgYWRkTGFiZWxzKHNhbmtleUNvbnRhaW5lciwgbm9kZXMpXHJcblxyXG4gICAgICAgIHJldHVybiBzdmcubm9kZSgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGdlb2dyYXBoaWNhbCBsYXllcnMgKHJlZ2lvbnMsIFBPSSBvdmVybGF5LCBib3JkZXJzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiBTVkcgY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZE92ZXJsYXlQb2x5Z29ucyhzdmcsIGdyYXBoKSB7XHJcbiAgICAgICAgY29uc3QgaW1wb3J0ZXJJZHMgPSBbXVxyXG4gICAgICAgIGNvbnN0IGV4cG9ydGVySWRzID0gW11cclxuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IG91dC5HZW9tZXRyaWVzLmdldFJlZ2lvbkZlYXR1cmVzKClcclxuICAgICAgICBpZiAoZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgZ3JhcGgubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBmZWF0dXJlLnByb3BlcnRpZXMuaWQpIHJldHVybiBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzSW1wb3J0ZXIgPSBncmFwaC5saW5rcy5zb21lKChsaW5rKSA9PiBsaW5rLnNvdXJjZSA9PSBub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ltcG9ydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVySWRzLnB1c2gobm9kZS5pZClcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlcklkcy5wdXNoKG5vZGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjb3VsZCBub3QgZmluZCBnZW9tZXRyeSBmb3InLCBub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy91cGRhdGUgZXhpc3RpbmcgcmVnaW9uIGZpbGxzXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG91dClcclxuICAgICAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG91dC5zdmdfLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHJcbiAgICAgICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCAocmVnaW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydGVySWRzLmluY2x1ZGVzKHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKSkgcmV0dXJuIG91dC5mbG93T3ZlcmxheUNvbG9yc19bMF1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZXJJZHMuaW5jbHVkZXMocmVnaW9uLnByb3BlcnRpZXMuaWQpKSByZXR1cm4gb3V0LmZsb3dPdmVybGF5Q29sb3JzX1sxXVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgbm9kZXMgaW4gdGhlIGdyYXBoIGRvbnQgaGF2ZSBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdGhlbiB1c2UgbnV0czJqc29uIGNlbnRyb2lkcyBpbnN0ZWFkXHJcbiAgICBmdW5jdGlvbiBhZGRDb29yZGluYXRlc1RvR3JhcGgoZ3JhcGgpIHtcclxuICAgICAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZS54ICYmICFub2RlLnkgJiYgb3V0Lkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBvdXQuR2VvbWV0cmllcy5jZW50cm9pZEZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBmZWF0dXJlLnByb3BlcnRpZXMuaWQpIHJldHVybiBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjZW50cm9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbkNvb3JkcyA9IG91dC5fcHJvamVjdGlvbihbY2VudHJvaWQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGNlbnRyb2lkLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXSlcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnggPSBzY3JlZW5Db29yZHNbMF1cclxuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSBzY3JlZW5Db29yZHNbMV1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignY291bGQgbm90IGZpbmQgY29vcmRpbmF0ZXMgZm9yJywgbm9kZS5pZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGNlbnRyb2lkcyBkYXRhLCBjYWxjdWxhdGUgb24gdGhlIGZseVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBvdXQuR2VvbWV0cmllcy5nZXRSZWdpb25GZWF0dXJlcygpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXMuZmluZCgoZmVhdHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09IGZlYXR1cmUucHJvcGVydGllcy5pZCkgcmV0dXJuIGZlYXR1cmVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50cm9pZCA9IGZlYXR1cmUucHJvcGVydGllcy5jZW50cm9pZCB8fCBvdXQuX3BhdGhGdW5jdGlvbi5jZW50cm9pZChmZWF0dXJlKVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuQ29vcmRzID0gb3V0Ll9wcm9qZWN0aW9uKFtjZW50cm9pZFswXSwgY2VudHJvaWRbMV1dKVxyXG4gICAgICAgICAgICAgICAgbm9kZS54ID0gc2NyZWVuQ29vcmRzWzBdXHJcbiAgICAgICAgICAgICAgICBub2RlLnkgPSBzY3JlZW5Db29yZHNbMV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgY29uc29sZS5sb2coZ3JhcGgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgRE9NIElEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gUHJlZml4IGZvciB0aGUgSURcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVuaXF1ZSBJRFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZUlkKHByZWZpeCkge1xyXG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gYXJyb3cgbWFya2VyIHRvIHRoZSBkZWZzIHNlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzIC0gRDMgc2VsZWN0aW9uIG9mIGRlZnNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIE1hcmtlciBJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gRmlsbCBjb2xvciBvZiB0aGUgbWFya2VyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEFycm93TWFya2VyKGRlZnMsIGlkLCBjb2xvcikge1xyXG4gICAgICAgIGRlZnMuYXBwZW5kKCdtYXJrZXInKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCBpZClcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCAxLjUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGNvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsICdNMCwwIHEwLDEsMC41LDEuNSBxLTAuNSwwLjUsLTAuNSwxLjUgcTAuNzUsLTAuNzUsMiwtMS41IHEtMS4yNSwtMC43NSwtMiwtMS41WicpXHJcblxyXG4gICAgICAgIC8vIGFkZCBhIGNvcHkgZm9yIG1vdXNlb3ZlciB3aXRoIGhvdmVyZWQgY29sb3JcclxuICAgICAgICBkZWZzLmFwcGVuZCgnbWFya2VyJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgaWQgKyAnbW91c2VvdmVyJylcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCAxLjUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMCBxMCwxLDAuNSwxLjUgcS0wLjUsMC41LC0wLjUsMS41IHEwLjc1LC0wLjc1LDIsLTEuNSBxLTEuMjUsLTAuNzUsLTIsLTEuNVonKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBsaW5lYXIgZ3JhZGllbnQgZGVmaW5pdGlvbnMgZm9yIGZsb3cgbGlua3NcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzIC0gRDMgc2VsZWN0aW9uIG9mIGRlZnNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdyYWRpZW50SWRzIC0gQXJyYXkgb2YgZ3JhZGllbnQgSURzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5rcyAtIFNhbmtleSBsaW5rcyBkYXRhXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEZsb3dHcmFkaWVudHMoZGVmcywgZ3JhZGllbnRJZHMsIGxpbmtzKSB7XHJcbiAgICAgICAgZGVmcy5zZWxlY3RBbGwoJ2xpbmVhckdyYWRpZW50JylcclxuICAgICAgICAgICAgLmRhdGEobGlua3MpXHJcbiAgICAgICAgICAgIC5qb2luKCdsaW5lYXJHcmFkaWVudCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChfLCBpKSA9PiBncmFkaWVudElkc1tpXSlcclxuICAgICAgICAgICAgLmF0dHIoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCAoZCkgPT4gZC5zb3VyY2UueDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIChkKSA9PiBkLnRhcmdldC54MClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgKGQpID0+IGQueTApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIChkKSA9PiBkLnkxKVxyXG4gICAgICAgICAgICAuY2FsbCgoZykgPT4gZy5hcHBlbmQoJ3N0b3AnKS5hdHRyKCdvZmZzZXQnLCAnNSUnKS5hdHRyKCdzdG9wLWNvbG9yJywgb3V0LmZsb3dPdmVybGF5Q29sb3JzX1swXSkpXHJcbiAgICAgICAgICAgIC5jYWxsKChnKSA9PiBnLmFwcGVuZCgnc3RvcCcpLmF0dHIoJ29mZnNldCcsICc1MCUnKS5hdHRyKCdzdG9wLWNvbG9yJywgb3V0LmZsb3dDb2xvcl8pKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBTYW5rZXkgZmxvd3MgKGxpbmtzIHdpdGggbWFya2VycyBhbmQgZ3JhZGllbnRzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiBTVkdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmtzIC0gU2Fua2V5IGxpbmtzIGRhdGFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcnJvd0lkIC0gQXJyb3cgbWFya2VyIElEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJyb3dPdXRsaW5lSWQgLSBBcnJvdyBvdXRsaW5lIG1hcmtlciBJRFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3JhZGllbnRJZHMgLSBHcmFkaWVudCBJRHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkU2Fua2V5Rmxvd3Moc3ZnLCBsaW5rcywgYXJyb3dJZCwgYXJyb3dPdXRsaW5lSWQsIGdyYWRpZW50SWRzKSB7XHJcbiAgICAgICAgY29uc3QgZmxvd3NHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93cy1ncm91cCcpXHJcbiAgICAgICAgY29uc3QgZmxvd3MgPSBmbG93c0dyb3VwLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWZsb3ctZmxvd3MnKVxyXG4gICAgICAgIGNvbnN0IG91dGxpbmVzID0gZmxvd3NHcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93LW91dGxpbmVzJylcclxuXHJcbiAgICAgICAgbGlua3MuZm9yRWFjaCgobGluaywgaSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBPdXRsaW5lIHBhdGhcclxuICAgICAgICAgICAgaWYgKG91dC5mbG93T3V0bGluZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRsaW5lc1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgc2Fua2V5TGlua0hvcml6b250YWwoKShsaW5rKSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNmZmZmZmYnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1mbG93LWxpbmstb3V0bGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGxpbmsud2lkdGggKyAxLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCBgdXJsKCMke2Fycm93T3V0bGluZUlkfSlgKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWluIHBhdGhcclxuICAgICAgICAgICAgZmxvd3NcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGxpbmspKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1saW5rJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBvdXQuZmxvd0dyYWRpZW50XyA/IGB1cmwoIyR7Z3JhZGllbnRJZHNbaV19KWAgOiBvdXQuZmxvd0NvbG9yXylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBsaW5rLndpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCBvdXQuZmxvd0Fycm93c18gPyBgdXJsKCMke2Fycm93SWR9KWAgOiAnJylcclxuICAgICAgICAgICAgICAgIC8vIGFkZCBob3ZlciBlZmZlY3RcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3ZlcmVkQ29sb3IgPSBvdXQuaG92ZXJDb2xvcl9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBzdHJva2UgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignc3Ryb2tlJywgaG92ZXJlZENvbG9yKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcmtlci1lbmQgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LmZsb3dBcnJvd3NfKSBzZWxlY3QodGhpcykuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZCArICdtb3VzZW92ZXInfSlgKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUb29sdGlwIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKGxpbmssIG91dCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgc3Ryb2tlIGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5mbG93R3JhZGllbnRfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5hdHRyKCdzdHJva2UnLCBgdXJsKCMke2dyYWRpZW50SWRzW2ldfSlgKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5hdHRyKCdzdHJva2UnLCBvdXQuZmxvd0NvbG9yXylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgbWFya2VyLWVuZCB0byB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LmZsb3dBcnJvd3NfKSBzZWxlY3QodGhpcykuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZH0pYClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9vbHRpcCBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHJlY3RhbmdsZXMgdG8gZmlsbCBnYXBzIGxlZnQgYnkgU2Fua2V5IGxpbmtzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnIC0gRDMgc2VsZWN0aW9uIG9mIFNWR1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgLSBTYW5rZXkgbm9kZXMgZGF0YVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRGaWxsR2FwcyhzdmcsIG5vZGVzKSB7XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1mbG93LWZpbGwtaW4tZ2FwcycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZGF0YShub2RlcylcclxuICAgICAgICAgICAgLmpvaW4oJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChkKSA9PiBkLmRlcHRoICYmIGQuaGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiBkLngwIC0gMC41KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiBkLnkwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQpID0+IGQueTEgLSBkLnkwKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIG91dC5mbG93Q29sb3JfKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGxhYmVscyBmb3IgZGF0YSBwb2ludHMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnIC0gRDMgc2VsZWN0aW9uIG9mIHRoZSBTVkcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkTGFiZWxzKHN2Zywgbm9kZXMpIHtcclxuICAgICAgICAvLyBGaWx0ZXIgdGhlIG5vZGVzXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWROb2RlcyA9IG5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS50YXJnZXRMaW5rcyAmJiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbHMnKVxyXG5cclxuICAgICAgICAvLyBBZGQgaGFsbyBlZmZlY3RcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxzU2hhZG93R3JvdXAgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbC1zaGFkb3cnKVxyXG4gICAgICAgICAgICBsYWJlbHNTaGFkb3dHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShmaWx0ZXJlZE5vZGVzKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gJ3N0YXJ0JyA6ICdlbmQnKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gZC54ICsgb3V0LmxhYmVsT2Zmc2V0WCA6IGQueCAtIG91dC5sYWJlbE9mZnNldFgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gZC55ICsgb3V0LmxhYmVsT2Zmc2V0WSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiBvdXQubGFiZWxGb3JtYXR0ZXIoZC52YWx1ZSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgbGFiZWxzXHJcbiAgICAgICAgY29uc3QgbGFiZWxzR3JvdXAgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbCcpXHJcbiAgICAgICAgLy9hZGQgYmFja2dyb3VuZFxyXG4gICAgICAgIC8vIEFkZCBiYWNrZ3JvdW5kIHJlY3RhbmdsZXMgYW5kIHRleHRcclxuICAgICAgICBjb25zdCBsYWJlbEVsZW1lbnRzID0gbGFiZWxzR3JvdXBcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpIC8vIFVzZSBhIGdyb3VwIGZvciBlYWNoIGxhYmVsIHRvIGNvbWJpbmUgcmVjdCBhbmQgdGV4dFxyXG4gICAgICAgICAgICAuZGF0YShmaWx0ZXJlZE5vZGVzKVxyXG4gICAgICAgICAgICAuam9pbignZycpIC8vIEFwcGVuZCBhIGdyb3VwIGZvciBlYWNoIGxhYmVsXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gYHRyYW5zbGF0ZSgke2QueH0sICR7ZC55fSlgKSAvLyBQb3NpdGlvbiBncm91cCBhdCB0aGUgbm9kZVxyXG5cclxuICAgICAgICAvLyBBZGQgdGV4dCBmaXJzdCB0byBjYWxjdWxhdGUgaXRzIHNpemVcclxuICAgICAgICBsYWJlbEVsZW1lbnRzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGFiZWwtdGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIChkKSA9PiAoZC54ID4gZC50YXJnZXRMaW5rc1swXS5zb3VyY2UueCA/ICdzdGFydCcgOiAnZW5kJykpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gb3V0LmxhYmVsT2Zmc2V0WCA6IC1vdXQubGFiZWxPZmZzZXRYKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQubGFiZWxPZmZzZXRZKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gb3V0LmxhYmVsRm9ybWF0dGVyKGQudmFsdWUpKVxyXG5cclxuICAgICAgICAvLyBBZGQgYmFja2dyb3VuZCByZWN0YW5nbGVzIGFmdGVyIHRleHQgaXMgcmVuZGVyZWRcclxuXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfLmJhY2tncm91bmRzKSB7XHJcbiAgICAgICAgICAgIGxhYmVsRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IHNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJveCA9IHRleHRFbGVtZW50Lm5vZGUoKS5nZXRCQm94KCkgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiB0aGUgdGV4dFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdYID0gNSAvLyBIb3Jpem9udGFsIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdZID0gMiAvLyBWZXJ0aWNhbCBwYWRkaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlY3RhbmdsZSBjZW50ZXJlZCBiZWhpbmQgdGhlIHRleHRcclxuICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAndGV4dCcpIC8vIEluc2VydCByZWN0IGJlZm9yZSB0ZXh0IGluIERPTVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGJib3gueCAtIHBhZGRpbmdYKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYmJveC55IC0gcGFkZGluZ1kpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYmJveC53aWR0aCArIDIgKiBwYWRkaW5nWClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYmJveC5oZWlnaHQgKyAyICogcGFkZGluZ1kpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIGFwcGVuZCBhIHJlY3RhbmdsZSBiZWhpbmQgdGhlIGxhYmVsXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRMYWJlbFJlY3QobGFiZWxUZXh0LCBjb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IDUgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDIgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHRleHQgZWxlbWVudCB0byBnZXQgdGhlIHNpemVcclxuICAgICAgICBjb25zdCBiYm94ID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlzaWJpbGl0eScsICdoaWRkZW4nKSAvLyBNYWtlIHRoZSB0ZW1wb3JhcnkgdGV4dCBpbnZpc2libGVcclxuICAgICAgICAgICAgLnRleHQobGFiZWxUZXh0KSAvLyBTZXQgdGhlIGxhYmVsIHRleHQgdG8gZ2V0IGl0cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgLm5vZGUoKVxyXG4gICAgICAgICAgICAuZ2V0QkJveCgpIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBiYm94LndpZHRoXHJcbiAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSBiYm94LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgYWZ0ZXIgZ2V0dGluZyB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdCgndGV4dFt2aXNpYmlsaXR5PVwiaGlkZGVuXCJdJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIHRvIGJlIGNlbnRlcmVkIG9uIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgeCA9IC1sYWJlbFdpZHRoIC8gMiAtIHBhZGRpbmdYIC8vIENlbnRlciB0aGUgcmVjdCBob3Jpem9udGFsbHlcclxuICAgICAgICBjb25zdCB5ID0gLWxhYmVsSGVpZ2h0IC8gMiAtIHBhZGRpbmdZIC8vIENlbnRlciB0aGUgcmVjdCB2ZXJ0aWNhbGx5XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHgpIC8vIFBvc2l0aW9uIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSkgLy8gUG9zaXRpb24gcmVjdCB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGxhYmVsV2lkdGggKyAyICogcGFkZGluZ1gpIC8vIFdpZHRoIG9mIHRoZSByZWN0IHdpdGggcGFkZGluZ1xyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgbGFiZWxIZWlnaHQgKyAyICogcGFkZGluZ1kpIC8vIEhlaWdodCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxhYmVsLWJhY2tncm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZyb20gdGhpcyBwb2ludCBvbiBhbGwgY29kZSBpcyByZWxhdGVkIHdpdGggc3BhdGlhbCBzYW5rZXkuIEFkb3B0ZWQgZnJvbSB0aGlzIG5vdGVib29rOiBodHRwczovL29ic2VydmFibGVocS5jb20vQGJheXJlL2RlY29uc3RydWN0ZWQtc2Fua2V5LWRpYWdyYW1cclxuICAgIC8vIFNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGpvZXdkYXZpZXMvZmxvdy1tYXAtb2YtZXVyb3BlXHJcbiAgICBmdW5jdGlvbiBjbG9uZSh7IG5vZGVzLCBsaW5rcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLm1hcCgoZCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgZCkpLCBsaW5rczogbGlua3MubWFwKChkKSA9PiBPYmplY3QuYXNzaWduKHt9LCBkKSkgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNhbmtleSh7IG5vZGVzLCBsaW5rcyB9KSB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGggPSBjbG9uZSh7IG5vZGVzLCBsaW5rcyB9KVxyXG4gICAgICAgIGNvbXB1dGVOb2RlTGlua3MoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVWYWx1ZXMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVEZXB0aHMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVIZWlnaHRzKGdyYXBoKVxyXG4gICAgICAgIGNvbXB1dGVOb2RlQnJlYWR0aHMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZUxpbmtCcmVhZHRocyhncmFwaClcclxuICAgICAgICByZXR1cm4gZ3JhcGhcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUxpbmtzKHsgbm9kZXMsIGxpbmtzIH0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IFtpLCBub2RlXSBvZiBub2Rlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgbm9kZS5pbmRleCA9IGlcclxuICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcyA9IFtdXHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlQnlJZCA9IG5ldyBNYXAobm9kZXMubWFwKChkLCBpKSA9PiBbaWQoZCwgaSwgbm9kZXMpLCBkXSkpXHJcbiAgICAgICAgZm9yIChjb25zdCBbaSwgbGlua10gb2YgbGlua3MuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGxpbmsuaW5kZXggPSBpXHJcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBsaW5rXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykgc291cmNlID0gbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBzb3VyY2UpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JykgdGFyZ2V0ID0gbGluay50YXJnZXQgPSBmaW5kKG5vZGVCeUlkLCB0YXJnZXQpXHJcbiAgICAgICAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspXHJcbiAgICAgICAgICAgIHRhcmdldC50YXJnZXRMaW5rcy5wdXNoKGxpbmspXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIChsaW5rU29ydCAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gICAgIGZvciAoY29uc3QgeyBzb3VyY2VMaW5rcywgdGFyZ2V0TGlua3MgfSBvZiBub2Rlcykge1xyXG4gICAgICAgIC8vICAgICAgICAgc291cmNlTGlua3Muc29ydChsaW5rU29ydClcclxuICAgICAgICAvLyAgICAgICAgIHRhcmdldExpbmtzLnNvcnQobGlua1NvcnQpXHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZChub2RlQnlJZCwgaWQpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZUJ5SWQuZ2V0KGlkKVxyXG4gICAgICAgIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nOiAnICsgaWQpXHJcbiAgICAgICAgcmV0dXJuIG5vZGVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBuZXcgU2V0KG5vZGVzKVxyXG4gICAgICAgIGxldCBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgbGV0IHggPSAwXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuc2l6ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5kZXB0aCA9IHhcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQgfSBvZiBub2RlLnNvdXJjZUxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5hZGQodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgrK3ggPiBuKSB0aHJvdyBuZXcgRXJyb3IoJ2NpcmN1bGFyIGxpbmsnKVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dFxyXG4gICAgICAgICAgICBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlSGVpZ2h0cyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBuZXcgU2V0KG5vZGVzKVxyXG4gICAgICAgIGxldCBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgbGV0IHggPSAwXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuc2l6ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgc291cmNlIH0gb2Ygbm9kZS50YXJnZXRMaW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKHNvdXJjZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKyt4ID4gbikgdGhyb3cgbmV3IEVycm9yKCdjaXJjdWxhciBsaW5rJylcclxuICAgICAgICAgICAgY3VycmVudCA9IG5leHRcclxuICAgICAgICAgICAgbmV4dCA9IG5ldyBTZXQoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUJyZWFkdGhzKHsgbm9kZXMgfSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGxpbmsgd2lkdGhzXHJcbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MuZm9yRWFjaCgobGluaykgPT4gKGxpbmsud2lkdGggPSBvdXQuc3Ryb2tlV2lkdGhTY2FsZShsaW5rLnZhbHVlKSkpXHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MuZm9yRWFjaCgobGluaykgPT4gKGxpbmsud2lkdGggPSBvdXQuc3Ryb2tlV2lkdGhTY2FsZShsaW5rLnZhbHVlKSkpXHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgdG90YWwgc3BhY2UgbmVlZGVkIGJ5IGxpbmtzXHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTGlua1dpZHRoID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICBzdW0obm9kZS5zb3VyY2VMaW5rcywgKGQpID0+IGQud2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgc3VtKG5vZGUudGFyZ2V0TGlua3MsIChkKSA9PiBkLndpZHRoKVxyXG4gICAgICAgICAgICApXHJcblxyXG4gICAgICAgICAgICBub2RlLngwID0gbm9kZS54MSA9IG5vZGUueFxyXG4gICAgICAgICAgICBub2RlLnkwID0gbm9kZS55IC0gdG90YWxMaW5rV2lkdGggLyAyXHJcbiAgICAgICAgICAgIG5vZGUueTEgPSBub2RlLnkgKyB0b3RhbExpbmtXaWR0aCAvIDJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlb3JkZXJMaW5rcyhub2RlcylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTGlua0JyZWFkdGhzKHsgbm9kZXMgfSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBsZXQgeTAgPSBub2RlLnkwXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLnNvdXJjZUxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLnkwID0geTAgKyBsaW5rLndpZHRoIC8gMlxyXG4gICAgICAgICAgICAgICAgeTAgKz0gbGluay53aWR0aFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgeTEgPSBub2RlLnkwXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLnRhcmdldExpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLnkxID0geTEgKyBsaW5rLndpZHRoIC8gMlxyXG4gICAgICAgICAgICAgICAgeTEgKz0gbGluay53aWR0aFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdyb3VwIG5vZGVzIGJ5IGRlcHRoIGFuZCBzdGFjayB2ZXJ0aWNhbGx5XHJcbiAgICBmdW5jdGlvbiBzdGFja05vZGVZcyhub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IGJ5RGVwdGggPSBuZXcgTWFwKClcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFieURlcHRoLmhhcyhub2RlLmRlcHRoKSkgYnlEZXB0aC5zZXQobm9kZS5kZXB0aCwgW10pXHJcbiAgICAgICAgICAgIGJ5RGVwdGguZ2V0KG5vZGUuZGVwdGgpLnB1c2gobm9kZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgW2RlcHRoLCBncm91cF0gb2YgYnlEZXB0aC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgLy8gU29ydCBieSB2YWx1ZSBvciBpZCB0byBlbnN1cmUgY29uc2lzdGVuY3lcclxuICAgICAgICAgICAgZ3JvdXAuc29ydCgoYSwgYikgPT4gYi52YWx1ZSAtIGEudmFsdWUpXHJcblxyXG4gICAgICAgICAgICBsZXQgeSA9IDEwMCAvLyBzdGFydGluZyB5IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSA1XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBncm91cCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUhlaWdodCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgIHN1bShub2RlLnNvdXJjZUxpbmtzLCAoZCkgPT4gZC53aWR0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VtKG5vZGUudGFyZ2V0TGlua3MsIChkKSA9PiBkLndpZHRoKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgbm9kZS55ID0geSArIG5vZGVIZWlnaHQgLyAyXHJcbiAgICAgICAgICAgICAgICB5ICs9IG5vZGVIZWlnaHQgKyBwYWRkaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaG9yaXpvbnRhbFNvdXJjZShkKSB7XHJcbiAgICAgICAgcmV0dXJuIFtkLnNvdXJjZS54MSwgZC55MF1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBob3Jpem9udGFsVGFyZ2V0KGQpIHtcclxuICAgICAgICByZXR1cm4gW2QudGFyZ2V0LngwLCBkLnkxXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlVmFsdWVzKHsgbm9kZXMgfSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBub2RlLnZhbHVlID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICBzdW0obm9kZS5zb3VyY2VMaW5rcywgKGQpID0+IGQudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgc3VtKG5vZGUudGFyZ2V0TGlua3MsIChkKSA9PiBkLnZhbHVlKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlb3JkZXJMaW5rcyhub2Rlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBzb3VyY2VMaW5rcywgdGFyZ2V0TGlua3MgfSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBzb3VyY2VMaW5rcy5zb3J0KGFzY2VuZGluZ1RhcmdldFkpXHJcbiAgICAgICAgICAgIHRhcmdldExpbmtzLnNvcnQoYXNjZW5kaW5nU291cmNlWSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXNjZW5kaW5nVGFyZ2V0WSA9IChhLCBiKSA9PiBhLnRhcmdldC55IC0gYi50YXJnZXQueVxyXG4gICAgY29uc3QgYXNjZW5kaW5nU291cmNlWSA9IChhLCBiKSA9PiBhLnNvdXJjZS55IC0gYi5zb3VyY2UueVxyXG5cclxuICAgIGNvbnN0IGlkID0gKGQpID0+IGQuaWQgLy8gdXNlZCBpbiBzYW5rZXkgaW1wb3J0XHJcblxyXG4gICAgY29uc3Qgc2Fua2V5TGlua0hvcml6b250YWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtIb3Jpem9udGFsKCkuc291cmNlKGhvcml6b250YWxTb3VyY2UpLnRhcmdldChob3Jpem9udGFsVGFyZ2V0KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuY29uc3QgZmxvd01hcFRvb2x0aXBGdW5jdGlvbiA9IGZ1bmN0aW9uIChsaW5rLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcblxyXG4gICAgLy8gSGVhZGVyIHdpdGggcmVnaW9uIG5hbWUgYW5kIElEXHJcbiAgICBjb25zdCB0aXRsZSA9IGAke2xpbmsuc291cmNlLm5hbWUgfHwgbGluay5zb3VyY2UuaWR9IHRvICR7bGluay50YXJnZXQubmFtZSB8fCBsaW5rLnRhcmdldC5pZH1gXHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPlxyXG4gICAgICAgICAgICA8Yj4ke3RpdGxlfTwvYj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgLy8gVmFsdWVcclxuICAgIGJ1Zi5wdXNoKGA8ZGl2IGNsYXNzPSdlc3RhdC12aXMtdG9vbHRpcC10ZXh0Jz5cclxuICAgICAgICAke2xpbmsudmFsdWV9XHJcbiAgICAgICAgPC9kaXY+YClcclxuXHJcbiAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbn1cclxuIiwiaW1wb3J0IHsgc2NhbGVTcXJ0IH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBhcmMsIHBpZSB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBleHRlbnQsIHN1bSB9IGZyb20gJ2QzLWFycmF5J1xyXG5pbXBvcnQgeyBpbnRlcnBvbGF0ZU9yUmQsIHNjaGVtZUNhdGVnb3J5MTAgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgUGllY2hhcnRMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1waWVjaGFydHMnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldFJlZ2lvbnNTZWxlY3Rvciwgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvcG9ydGlvbmFsIHBpZSBjaGFydCBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgdHJ1ZSwgJ3BpZScpXHJcblxyXG4gICAgLy8gcGllIGNoYXJ0c1xyXG4gICAgb3V0LnBpZU1pblJhZGl1c18gPSA1XHJcbiAgICBvdXQucGllTWF4UmFkaXVzXyA9IDE1XHJcbiAgICBvdXQucGllQ2hhcnRJbm5lclJhZGl1c18gPSAwXHJcbiAgICBvdXQucGllU3Ryb2tlRmlsbF8gPSAnd2hpdGUnXHJcbiAgICBvdXQucGllU3Ryb2tlV2lkdGhfID0gMC4zXHJcblxyXG4gICAgLy90b29sdGlwIHBpZSBjaGFydFxyXG4gICAgb3V0LnRvb2x0aXBQaWVSYWRpdXNfID0gNDBcclxuICAgIG91dC50b29sdGlwUGllSW5uZXJSYWRpdXNfID0gMFxyXG5cclxuICAgIC8vY29sb3JzIC0gaW5kZXhlZCBieSBjYXRlZ29yeSBjb2RlXHJcbiAgICBvdXQuY2F0Q29sb3JzXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9sYWJlbHMgLSBpbmRleGVkIGJ5IGNhdGVnb3J5IGNvZGVcclxuICAgIG91dC5jYXRMYWJlbHNfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy8gJ290aGVyJyBzZWN0aW9uIG9mIHRoZSBwaWUgY2hhcnQgZm9yIHdoZW4gJ291dC50b3RhbENvZGVfJyBpcyBkZWZpbmVkIHdpdGggc3RhdFBpZSgpXHJcbiAgICBvdXQucGllT3RoZXJDb2xvcl8gPSAnI0ZGQ0M4MCdcclxuICAgIG91dC5waWVPdGhlclRleHRfID0gJ090aGVyJ1xyXG5cclxuICAgIC8vc2hvdyBwaWVjaGFydHMgb25seSB3aGVuIGRhdGEgZm9yIGFsbCBjYXRlZ29yaWVzIGlzIGNvbXBsZXRlLlxyXG4gICAgLy9PdGhlcndpc2UsIGNvbnNpZGVyIHRoZSByZWdpb25zIGFzIGJlaW5nIHdpdGggbm8gZGF0YSBhdCBhbGwuXHJcbiAgICBvdXQuc2hvd09ubHlXaGVuQ29tcGxldGVfID0gZmFsc2VcclxuXHJcbiAgICBvdXQuc2l6ZUNsYXNzaWZpZXJfID0gbnVsbCAvL2QzIHNjYWxlIGZvciBzY2FsaW5nIHBpZSBzaXplc1xyXG4gICAgb3V0LnN0YXRQaWVfID0gbnVsbFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ2NhdENvbG9yc18nLFxyXG4gICAgICAgICdjYXRMYWJlbHNfJyxcclxuICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGVfJyxcclxuICAgICAgICAnbm9EYXRhRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ3BpZU1heFJhZGl1c18nLFxyXG4gICAgICAgICdwaWVNaW5SYWRpdXNfJyxcclxuICAgICAgICAncGllQ2hhcnRJbm5lclJhZGl1c18nLFxyXG4gICAgICAgICdwaWVPdGhlckNvbG9yXycsXHJcbiAgICAgICAgJ3BpZU90aGVyVGV4dF8nLFxyXG4gICAgICAgICdwaWVTdHJva2VGaWxsXycsXHJcbiAgICAgICAgJ3BpZVN0cm9rZVdpZHRoXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdjYXRDb2xvcnMnLFxyXG4gICAgICAgICAgICAnY2F0TGFiZWxzJyxcclxuICAgICAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlJyxcclxuICAgICAgICAgICAgJ25vRGF0YUZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdwaWVNYXhSYWRpdXMnLFxyXG4gICAgICAgICAgICAncGllTWluUmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXMnLFxyXG4gICAgICAgICAgICAncGllT3RoZXJDb2xvcicsXHJcbiAgICAgICAgICAgICdwaWVPdGhlclRleHQnLFxyXG4gICAgICAgICAgICAncGllU3Ryb2tlRmlsbCcsXHJcbiAgICAgICAgICAgICdwaWVTdHJva2VXaWR0aCcsXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvKiogVGhlIGNvZGVzIG9mIHRoZSBjYXRlZ29yaWVzIHRvIGNvbnNpZGVyIGZvciB0aGUgY29tcG9zaXRpb24uICovXHJcbiAgICBvdXQuc3RhdENvZGVzXyA9IHVuZGVmaW5lZFxyXG4gICAgLyoqIFRoZSBjb2RlIG9mIHRoZSBcInRvdGFsXCIgY2F0ZWdvcnkgaW4gdGhlIGV1cm9zdGF0IGRhdGFiYXNlICovXHJcbiAgICBvdXQudG90YWxDb2RlX18gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdG8gZGVmaW5lIGEgcGllIGNoYXJ0IG1hcCBlYXNpbHksIHdpdGhvdXQgcmVwZXRpdGlvbiBvZiBpbmZvcm1hdGlvbi5cclxuICAgICAqIE9ubHkgZm9yIGV1cm9iYXNlIGRhdGEgc291cmNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHN0YXQgQSBwYXR0ZXJuIGZvciB0aGUgc3RhdCBkYXRhIHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRpbSBUaGUgZGltZW5zaW9uIChkZWZpbmVkIGluIGV1cm9zdGF0IFJFU1QgQVBJKSBvZiB0aGUgY29tcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2RlcyBUaGUgY2F0ZWdvcnkgY29kZXMgb2YgdGhlIGNvbXBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsYWJlbHMgT3B0aW9uYWw6IFRoZSBsYWJlbHMgZm9yIHRoZSBjYXRlZ29yeSBjb2Rlc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sb3JzIE9wdGlvbmFsOiBUaGUgY29sb3JzIGZvciB0aGUgY2F0ZWdvcnlcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0Q29kZSBPcHRpb25hbDogVGhlIGNhdGVnb3J5IGNvZGUgb2YgdGhlIHRvdGFsICh1c2VkIHRvIGNhbGN1bGF0ZSB0b3RhbCAmIFwib3RoZXJcIiB2YWx1ZXMgaWYgY29kZXMgYXJyYXkgZG9udCByZXByZXNlbnQgYWxsIHBvc3NpYmxlIGNhdGVnb3JpZXMpXHJcbiAgICAgKi9cclxuICAgIG91dC5zdGF0UGllID0gZnVuY3Rpb24gKHN0YXQsIGRpbSwgY29kZXMsIGxhYmVscywgY29sb3JzLCB0Q29kZSkge1xyXG4gICAgICAgIC8vYWRkIG9uZSBkYXRhc2V0IChzdGF0KSBjb25maWcgZm9yIGVhY2ggY2F0ZWdvcnkgKGNvZGUpXHJcbiAgICAgICAgc3RhdC5maWx0ZXJzID0gc3RhdC5maWx0ZXJzIHx8IHt9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL2NhdGVnb3J5IGNvZGVcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGNvZGVzW2ldXHJcbiAgICAgICAgICAgIHN0YXQuZmlsdGVyc1tkaW1dID0gY29kZVxyXG4gICAgICAgICAgICBjb25zdCBzY18gPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdCkge1xyXG4gICAgICAgICAgICAgICAgc2NfW2tleV0gPSBzdGF0W2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzY18uZmlsdGVycyA9IHt9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0LmZpbHRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHNjXy5maWx0ZXJzW2tleV0gPSBzdGF0LmZpbHRlcnNba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dC5zdGF0KGNvZGUsIHNjXylcclxuXHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGNvbG9yXHJcbiAgICAgICAgICAgIGlmIChjb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRDb2xvcnNfID0gb3V0LmNhdENvbG9yc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRDb2xvcnNfW2NvZGVdID0gY29sb3JzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiBzcGVjaWZpZWQsIHJldHJpZXZlIGFuZCBhc3NpZ24gbGFiZWxcclxuICAgICAgICAgICAgaWYgKGxhYmVscykge1xyXG4gICAgICAgICAgICAgICAgb3V0LmNhdExhYmVsc18gPSBvdXQuY2F0TGFiZWxzXyB8fCB7fVxyXG4gICAgICAgICAgICAgICAgb3V0LmNhdExhYmVsc19bY29kZV0gPSBsYWJlbHNbaV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgb3V0LnN0YXRDb2Rlc19cclxuICAgICAgICBvdXQuc3RhdENvZGVzXyA9IGNvZGVzXHJcblxyXG4gICAgICAgIC8vc2V0IG91dC50b3RhbENvZGVfXHJcbiAgICAgICAgaWYgKHRDb2RlKSB7XHJcbiAgICAgICAgICAgIG91dC50b3RhbENvZGVfID0gdENvZGVcclxuICAgICAgICAgICAgc3RhdC5maWx0ZXJzW2RpbV0gPSB0Q29kZVxyXG4gICAgICAgICAgICBjb25zdCBzY18gPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdCkgc2NfW2tleV0gPSBzdGF0W2tleV1cclxuICAgICAgICAgICAgc2NfLmZpbHRlcnMgPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdC5maWx0ZXJzKSBzY18uZmlsdGVyc1trZXldID0gc3RhdC5maWx0ZXJzW2tleV1cclxuICAgICAgICAgICAgb3V0LnN0YXQodENvZGUsIHNjXylcclxuXHJcbiAgICAgICAgICAgIC8vd2hlbiB0b3RhbCBjb2RlIGlzIHVzZWQsIGFuICdvdGhlcicgc2VjdGlvbiBpcyBhZGRlZCB0byB0aGUgcGllXHJcbiAgICAgICAgICAgIG91dC5jYXRDb2xvcnNfWydvdGhlciddID0gb3V0LnBpZU90aGVyQ29sb3JfXHJcbiAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfWydvdGhlciddID0gb3V0LnBpZU90aGVyVGV4dF9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICAvL2lmIG5vdCBwcm92aWRlZCwgZ2V0IGxpc3Qgb2Ygc3RhdCBjb2RlcyBmcm9tIHRoZSBtYXAgc3RhdCBkYXRhXHJcbiAgICAgICAgaWYgKCFvdXQuc3RhdENvZGVzXykge1xyXG4gICAgICAgICAgICAvL2dldCBsaXN0IG9mIHN0YXQgY29kZXMuXHJcbiAgICAgICAgICAgIG91dC5zdGF0Q29kZXNfID0gT2JqZWN0LmtleXMob3V0LnN0YXREYXRhXylcclxuICAgICAgICAgICAgLy9yZW1vdmUgXCJkZWZhdWx0XCIsIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvdXQuc3RhdENvZGVzXy5pbmRleE9mKCdkZWZhdWx0JylcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIG91dC5zdGF0Q29kZXNfLnNwbGljZShpbmRleCwgMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZGVmaW5lIHNpemUgc2NhbGluZyBmdW5jdGlvblxyXG4gICAgICAgIGxldCBkb21haW4gPSBnZXREYXRhc2V0TWF4TWluKClcclxuICAgICAgICBpZiAoIWlzTmFOKGRvbWFpblswXSkpIHtcclxuICAgICAgICAgICAgb3V0LnNpemVDbGFzc2lmaWVyXyA9IHNjYWxlU3FydCgpLmRvbWFpbihkb21haW4pLnJhbmdlKFtvdXQucGllTWluUmFkaXVzXywgb3V0LnBpZU1heFJhZGl1c19dKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9pZiBub3Qgc3BlY2lmaWVkLCBidWlsZCBkZWZhdWx0IGNvbG9yIHJhbXBcclxuICAgICAgICBpZiAoIW91dC5jYXRDb2xvcnNfKSB7XHJcbiAgICAgICAgICAgIG91dC5jYXRDb2xvcnMoe30pXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LnN0YXRDb2Rlc18ubGVuZ3RoOyBpKyspIG91dC5jYXRDb2xvcnNfW291dC5zdGF0Q29kZXNfW2ldXSA9IHNjaGVtZUNhdGVnb3J5MTBbaSAlIDEwXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiBub3Qgc3BlY2lmaWVkLCBpbml0aWFsaXNlIGNhdGVnb3J5IGxhYmVsc1xyXG4gICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuXHJcbiAgICAgICAgLy9idWlsZCBhbmQgYXNzaWduIHBpZSBjaGFydHMgdG8gdGhlIHJlZ2lvbnNcclxuICAgICAgICAvL2NvbGxlY3QgbnV0cyBpZHMgZnJvbSBnIGVsZW1lbnRzLiBUT0RPOiBmaW5kIGJldHRlciB3YXkgb2Ygc2hhcmluZyByZWdpb25zIHdpdGggcGllc1xyXG4gICAgICAgIGxldCByZWdpb25GZWF0dXJlcyA9IFtdXHJcbiAgICAgICAgaWYgKG91dC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCBzID0gb3V0LnN2Z18uc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJylcclxuICAgICAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzeW0gPSBzLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgICAgICAgICBzeW0uYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tcGllJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uRmVhdHVyZXMucHVzaChyZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwaWVfJyArIHJnLnByb3BlcnRpZXMuaWRcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNldCByZWdpb24gaG92ZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG91dClcclxuICAgICAgICAgICAgICAgIGxldCByZWdpb25zID0gb3V0LnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgb3V0LmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24ocmcsIG91dCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGwgPSBzZWwuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgYWRkUGllQ2hhcnRzVG9NYXAocmVnaW9uRmVhdHVyZXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY29tcHV0ZSBjb21wb3NpdGlvbiBmb3IgcmVnaW9uIGlkLCBmb3IgZWFjaCBjYXRlZ29yeS5cclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCwgZm9yIGVhY2ggY2F0ZWdvcnksIHRoZSBzaGFyZSBbMCwxXSBvZiB0aGUgY2F0ZWdvcnkuXHJcbiAgICAgKiBAcGFyYW0geyp9IGlkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldENvbXBvc2l0aW9uID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgbGV0IGNvbXAgPSB7fSxcclxuICAgICAgICAgICAgc3VtID0gMFxyXG4gICAgICAgIC8vZ2V0IHN0YXQgdmFsdWUgZm9yIGVhY2ggY2F0ZWdvcnkuIENvbXB1dGUgdGhlIHN1bS5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5zdGF0Q29kZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vcmV0cmlldmUgY29kZSBhbmQgc3RhdCB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBzYyA9IG91dC5zdGF0Q29kZXNfW2ldXHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBvdXQuc3RhdERhdGEoc2MpLmdldChpZClcclxuXHJcbiAgICAgICAgICAgIC8vY2FzZSB3aGVuIHNvbWUgZGF0YSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbXBbc2NdID0gcy52YWx1ZVxyXG4gICAgICAgICAgICBzdW0gKz0gcy52YWx1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd2hlbiBvdXQudG90YWxDb2RlXyBpcyBzcGVjaWZpZWQsIHVzZSBpdCBhcyB0aGUgc3VtIGluc3RlYWQgb2YgdGhlIHN1bSBvZiB0aGUgc3BlY2lmaWVkIGNhdGVnb3JpZXMuXHJcbiAgICAgICAgaWYgKG91dC50b3RhbENvZGVfKSB7XHJcbiAgICAgICAgICAgIGxldCBzID0gb3V0LnN0YXREYXRhKG91dC50b3RhbENvZGVfKS5nZXQoaWQpXHJcbiAgICAgICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gPT0gMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2Nhc2Ugd2hlbiBubyBkYXRhXHJcbiAgICAgICAgaWYgKHN1bSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSByYXRpb3NcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5zdGF0Q29kZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbXBbb3V0LnN0YXRDb2Rlc19baV1dIC89IHN1bVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hZGQgXCJvdGhlclwiIGNhdGVnb3J5IHdoZW4gb3V0LnRvdGFsQ29kZV8gaXMgdXNlZFxyXG4gICAgICAgIGlmIChvdXQudG90YWxDb2RlXykge1xyXG4gICAgICAgICAgICBsZXQgdG90YWxQZXJjID0gMFxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29tcCkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxQZXJjID0gdG90YWxQZXJjICsgY29tcFtrZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tcFsnb3RoZXInXSA9IDEgLSB0b3RhbFBlcmNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gZ2V0RGF0YXNldE1heE1pblxyXG4gICAgICogQGRlc2NyaXB0aW9uIGdldHMgdGhlIG1heGltdW0gYW5kIG1pbmltdW0gdG90YWwgb2YgYWxsIGRpbWVuc2lvbnMgY29tYmluZWQgZm9yIGVhY2ggcmVnaW9uLiBVc2VkIHRvIGRlZmluZSB0aGUgZG9tYWluIG9mIHRoZSBwaWUgc2l6ZSBzY2FsaW5nIGZ1bmN0aW9uLlxyXG4gICAgICogQHJldHVybnMgW21pbixtYXhdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldERhdGFzZXRNYXhNaW4oKSB7XHJcbiAgICAgICAgbGV0IHRvdGFscyA9IFtdXHJcbiAgICAgICAgbGV0IHNlbCA9IG91dC5zdmcoKS5zZWxlY3RBbGwoJyNlbS1wcm9wLXN5bWJvbHMnKS5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKS5kYXRhKClcclxuXHJcbiAgICAgICAgc2VsLmZvckVhY2goKHJnKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpZCA9IHJnLnByb3BlcnRpZXMuaWRcclxuICAgICAgICAgICAgbGV0IHRvdGFsID0gZ2V0UmVnaW9uVG90YWwoaWQpXHJcbiAgICAgICAgICAgIGlmICh0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxzLnB1c2godG90YWwpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBsZXQgbWlubWF4ID0gZXh0ZW50KHRvdGFscylcclxuICAgICAgICByZXR1cm4gbWlubWF4XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWJzb2x1dGUgdG90YWwgdmFsdWUgb2YgY29tYmluZWQgc3RhdGlzdGljYWwgdmFsdWVzIGZvciBhIHNwZWNpZmljIHJlZ2lvbi4gRS5nIHRvdGFsIGxpdmVzdG9ja1xyXG4gICAgICogQHBhcmFtIHsqfSBpZCBudXRzIHJlZ2lvbiBpZFxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRSZWdpb25Ub3RhbCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGxldCBzdW0gPSAwXHJcbiAgICAgICAgbGV0IHNcclxuICAgICAgICBpZiAob3V0LnRvdGFsQ29kZV8pIHtcclxuICAgICAgICAgICAgLy93aGVuIHRvdGFsIGlzIGEgc3RhdCBjb2RlXHJcbiAgICAgICAgICAgIHMgPSBvdXQuc3RhdERhdGEob3V0LnRvdGFsQ29kZV8pLmdldChpZClcclxuICAgICAgICAgICAgLy9jYXNlIHdoZW4gc29tZSBkYXRhIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgaWYgKCFzIHx8IChzLnZhbHVlICE9IDAgJiYgIXMudmFsdWUpIHx8IGlzTmFOKHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN1bSA9IHMudmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IHN0YXQgdmFsdWUgZm9yIGVhY2ggY2F0ZWdvcnkuIENvbXB1dGUgdGhlIHN1bS5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy9yZXRyaWV2ZSBjb2RlIGFuZCBzdGF0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzYyA9IG91dC5zdGF0Q29kZXNfW2ldXHJcbiAgICAgICAgICAgICAgICBzID0gb3V0LnN0YXREYXRhKHNjKS5nZXQoaWQpXHJcbiAgICAgICAgICAgICAgICAvL2Nhc2Ugd2hlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzIHx8IChzLnZhbHVlICE9IDAgJiYgIXMudmFsdWUpIHx8IGlzTmFOKHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3VtICs9IHMudmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jYXNlIHdoZW4gbm8gZGF0YVxyXG4gICAgICAgIGlmIChzdW0gPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgIHJldHVybiBzdW1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRQaWVDaGFydHNUb01hcChyZWdpb25GZWF0dXJlcykge1xyXG4gICAgICAgIHJlZ2lvbkZlYXR1cmVzLmZvckVhY2goKHJlZ2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZWdpb25JZCA9IHJlZ2lvbi5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgIC8vcHJlcGFyZSBkYXRhIGZvciBwaWUgY2hhcnRcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IFtdXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSBnZXRDb21wb3NpdGlvbihyZWdpb25JZClcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcCkgZGF0YS5wdXNoKHsgY29kZToga2V5LCB2YWx1ZTogY29tcFtrZXldIH0pXHJcblxyXG4gICAgICAgICAgICAvL2Nhc2Ugb2YgcmVnaW9ucyB3aXRoIG5vIGRhdGFcclxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NyZWF0ZSBzdmcgZm9yIHBpZSBjaGFydFxyXG4gICAgICAgICAgICAvLyBjYW4gYmUgbW9yZSB0aGFuIG9uZSBjZW50ZXIgcG9pbnQgZm9yIGVhY2ggbnV0cyBJRCAoZS5nLiBNYWx0YSB3aGVuIGluY2x1ZGVkIGluIGluc2V0cylcclxuICAgICAgICAgICAgbGV0IG5vZGVzID0gb3V0LnN2ZygpLnNlbGVjdEFsbCgnI3BpZV8nICsgcmVnaW9uSWQpXHJcblxyXG4gICAgICAgICAgICAvLyBkZWZpbmUgcmFkaXVzXHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBvdXQuc2l6ZUNsYXNzaWZpZXJfKGdldFJlZ2lvblRvdGFsKHJlZ2lvbklkKSlcclxuICAgICAgICAgICAgY29uc3QgaXIgPSBvdXQucGllQ2hhcnRJbm5lclJhZGl1c19cclxuXHJcbiAgICAgICAgICAgIC8vbWFrZSBwaWUgY2hhcnQuIFNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGQzL3BpZS1jaGFydFxyXG4gICAgICAgICAgICBjb25zdCBwaWVfID0gcGllKClcclxuICAgICAgICAgICAgICAgIC5zb3J0KG51bGwpXHJcbiAgICAgICAgICAgICAgICAudmFsdWUoKGQpID0+IGQudmFsdWUpXHJcbiAgICAgICAgICAgIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBvdXQucGllU3Ryb2tlRmlsbF8pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgb3V0LnBpZVN0cm9rZVdpZHRoXyArICdweCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncGllY2hhcnQnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShwaWVfKGRhdGEpKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNhdENvbG9yc19bZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGxfX18nLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2F0Q29sb3JzX1tkLmRhdGEuY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY29kZScsIChkKSA9PiBkLmRhdGEuY29kZSkgLy9mb3IgbW91c2VvdmVyIGxlZ2VuZCBoaWdobGlnaHRpbmcgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgYXJjKCkuaW5uZXJSYWRpdXMoaXIpLm91dGVyUmFkaXVzKHIpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBhIHRoaWNrIHN0cm9rZSB3aWR0aCB0byB0aGUgcGFyZW50IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBzZWxlY3Qoc2VsLm5vZGUoKS5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgJzFweCcpLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKSAvLyBTZXQgc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJlZ2lvbiwgb3V0KSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHN0cm9rZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHNlbGVjdChzZWwubm9kZSgpLnBhcmVudE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnN0eWxlKCdzdHJva2Utd2lkdGgnLCBvdXQucGllU3Ryb2tlV2lkdGhfKS5zdHlsZSgnc3Ryb2tlJywgb3V0LnBpZVN0cm9rZUZpbGxfKSAvLyBTZXQgc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBQaWVjaGFydExlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZywgbWFwKSB7XHJcbiAgICAgICAgLy9nZXQgdG9vbHRpcFxyXG4gICAgICAgIGNvbnN0IHRwID0gc2VsZWN0KCcjdG9vbHRpcF9ldXJvc3RhdCcpXHJcblxyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0cC5odG1sKCcnKVxyXG4gICAgICAgIHRwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgICAgIC8vbmFtZSBhbmQgY29kZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZXN0YXQtdmlzLXRvb2x0aXAtYmFyJylcclxuICAgICAgICAgICAgICAgIC5odG1sKHJnLnByb3BlcnRpZXMubmEgKyAnICgnICsgcmcucHJvcGVydGllcy5pZCArICcpJylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL3JlZ2lvbiBuYW1lXHJcbiAgICAgICAgICAgIHRwLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnZXN0YXQtdmlzLXRvb2x0aXAtYmFyJykuaHRtbChyZy5wcm9wZXJ0aWVzLm5hKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9wcmVwYXJlIGRhdGEgZm9yIHBpZSBjaGFydFxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXVxyXG4gICAgICAgIGNvbnN0IGNvbXAgPSBnZXRDb21wb3NpdGlvbihyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXApIGRhdGEucHVzaCh7IGNvZGU6IGtleSwgdmFsdWU6IGNvbXBba2V5XSB9KVxyXG5cclxuICAgICAgICAvL2Nhc2Ugb2YgcmVnaW9ucyB3aXRoIG5vIGRhdGFcclxuICAgICAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmh0bWwob3V0Lm5vRGF0YVRleHQoKSlcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NyZWF0ZSBzdmcgZm9yIHBpZSBjaGFydFxyXG4gICAgICAgIC8vIHNldCB0aGUgZGltZW5zaW9ucyBhbmQgbWFyZ2lucyBvZiB0aGUgZ3JhcGhcclxuICAgICAgICBsZXQgd2lkdGggPSAxNTBcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gMTUwXHJcbiAgICAgICAgbGV0IG1hcmdpbiA9IDI1XHJcblxyXG4gICAgICAgIC8vIFRoZSByYWRpdXMgb2YgdGhlIHBpZXBsb3QgaXMgaGFsZiB0aGUgd2lkdGggb3IgaGFsZiB0aGUgaGVpZ2h0IChzbWFsbGVzdCBvbmUpLiBJIHN1YnRyYWN0IGEgYml0IG9mIG1hcmdpbi5cclxuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIgLSBtYXJnaW5cclxuXHJcbiAgICAgICAgLy93aWR0aCA9IHRwLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRwLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnZW0tdG9vbHRpcC1waWVjaGFydC1jb250YWluZXInKVxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tdG9vbHRpcC1waWVjaGFydC1zdmcnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlld2JveCcsIGAwLCAwLCAke3dpZHRofSwgJHtoZWlnaHR9YClcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgLSBtYXJnaW4gLyAyKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHdpZHRoIC8gMiArICcsJyArIGhlaWdodCAvIDIgKyAnKScpXHJcblxyXG4gICAgICAgIC8vbWFrZSBwaWUgY2hhcnQuIFNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGQzL3BpZS1jaGFydFxyXG4gICAgICAgIGNvbnN0IHBpZV8gPSBwaWUoKVxyXG4gICAgICAgICAgICAuc29ydChudWxsKVxyXG4gICAgICAgICAgICAudmFsdWUoKGQpID0+IGQudmFsdWUpXHJcblxyXG4gICAgICAgIGNvbnN0IGlubmVyQXJjID0gYXJjKClcclxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKDApIC8vIFRoaXMgaXMgdGhlIHNpemUgb2YgdGhlIGRvbnV0IGhvbGVcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOClcclxuXHJcbiAgICAgICAgLy8gQW5vdGhlciBhcmMgdGhhdCB3b24ndCBiZSBkcmF3bi4gSnVzdCBmb3IgbGFiZWxzIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgY29uc3Qgb3V0ZXJBcmMgPSBhcmMoKVxyXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzICogMC45KVxyXG4gICAgICAgICAgICAub3V0ZXJSYWRpdXMocmFkaXVzICogMC45KVxyXG5cclxuICAgICAgICBjb25zdCBwaWVEYXRhID0gcGllXyhkYXRhKVxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJ2FsbFNsaWNlcycpXHJcbiAgICAgICAgICAgIC5kYXRhKHBpZURhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGlubmVyQXJjKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jYXRDb2xvcnMoKVtkLmRhdGEuY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICd3aGl0ZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgJzFweCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNylcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBwb2x5bGluZXMgYmV0d2VlbiBjaGFydCBhbmQgbGFiZWxzOlxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJ2FsbFBvbHlsaW5lcycpXHJcbiAgICAgICAgICAgIC5kYXRhKHBpZURhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BvbHlsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuZGF0YS52YWx1ZSA+IDAuMDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NBID0gaW5uZXJBcmMuY2VudHJvaWQoZCkgLy8gbGluZSBpbnNlcnRpb24gaW4gdGhlIHNsaWNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQiA9IG91dGVyQXJjLmNlbnRyb2lkKGQpIC8vIGxpbmUgYnJlYWs6IHdlIHVzZSB0aGUgb3RoZXIgYXJjIGdlbmVyYXRvciB0aGF0IGhhcyBiZWVuIGJ1aWx0IG9ubHkgZm9yIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NDID0gb3V0ZXJBcmMuY2VudHJvaWQoZCkgLy8gTGFiZWwgcG9zaXRpb24gPSBhbG1vc3QgdGhlIHNhbWUgYXMgcG9zQlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pZGFuZ2xlID0gZC5zdGFydEFuZ2xlICsgKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gMiAvLyB3ZSBuZWVkIHRoZSBhbmdsZSB0byBzZWUgaWYgdGhlIFggcG9zaXRpb24gd2lsbCBiZSBhdCB0aGUgZXh0cmVtZSByaWdodCBvciBleHRyZW1lIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICBwb3NDWzBdID0gcmFkaXVzICogMC45NSAqIChtaWRhbmdsZSA8IE1hdGguUEkgPyAxIDogLTEpIC8vIG11bHRpcGx5IGJ5IDEgb3IgLTEgdG8gcHV0IGl0IG9uIHRoZSByaWdodCBvciBvbiB0aGUgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcG9zQSwgcG9zQiwgcG9zQ11cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBsYWJlbHM6XHJcbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnYWxsTGFiZWxzJylcclxuICAgICAgICAgICAgLmRhdGEocGllRGF0YSlcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5kYXRhLnZhbHVlID4gMC4wMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gKGQuZGF0YS52YWx1ZSAqIDEwMCkudG9GaXhlZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihuKSkgcmV0dXJuIG4gKyAnJSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gb3V0ZXJBcmMuY2VudHJvaWQoZClcclxuICAgICAgICAgICAgICAgIHZhciBtaWRhbmdsZSA9IGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDJcclxuICAgICAgICAgICAgICAgIHBvc1swXSA9IHJhZGl1cyAqIDAuOTkgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvcyArICcpJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaWRhbmdsZSA9IGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDJcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRhbmdsZSA8IE1hdGguUEkgPyAnc3RhcnQnIDogJ2VuZCdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCAnMTJweCcpXHJcblxyXG4gICAgICAgIC8vIGFkZCByZWdpb24gdmFsdWVzIHRvIHRvb2x0aXBcclxuICAgICAgICBsZXQgYnJlYWtkb3duRGl2ID0gdHAuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdlbS10b29sdGlwLXBpZWNoYXJ0LWJyZWFrZG93bicpXHJcblxyXG4gICAgICAgIC8vIHNob3cgdmFsdWUgZm9yIGVhY2ggY2F0ZWdvcnlcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5zdGF0Q29kZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuc3RhdENvZGVzX1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzID0gb3V0LnN0YXREYXRhKHNjKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHMgYW5kIHMudmFsdWUgYXJlIHZhbGlkIChoYW5kbGUgbnVsbCwgdW5kZWZpbmVkLCBvciAwKVxyXG4gICAgICAgICAgICBpZiAocyAmJiBzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcy52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0cmluZyA9IGA8c3Ryb25nPiR7b3V0LmNhdExhYmVsc19bc2NdfTwvc3Ryb25nPjogJHtzLnZhbHVlLnRvRml4ZWQoKX08YnI+YFxyXG4gICAgICAgICAgICAgICAgYnJlYWtkb3duRGl2Lmh0bWwoYnJlYWtkb3duRGl2Lmh0bWwoKSArIHN0cmluZykgLy8gc2FmZWx5IHVwZGF0ZSB0aGUgSFRNTFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3cml0ZSB0b3RhbCAoaGFuZGxlIG51bGwsIHVuZGVmaW5lZCwgb3IgMCB2YWx1ZXMgZm9yIHRvdGFsKVxyXG4gICAgICAgIGxldCB0b3RhbCA9IGdldFJlZ2lvblRvdGFsKHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgaWYgKHRvdGFsICE9PSB1bmRlZmluZWQgJiYgdG90YWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgYnJlYWtkb3duRGl2Lmh0bWwoYnJlYWtkb3duRGl2Lmh0bWwoKSArIGA8c3Ryb25nPlRvdGFsPC9zdHJvbmc+OiAke3RvdGFsLnRvRml4ZWQoKX08YnI+YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNjYWxlU3FydCwgc2NhbGVMaW5lYXIsIHNjYWxlUXVhbnRpbGUsIHNjYWxlUXVhbnRpemUsIHNjYWxlVGhyZXNob2xkIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IGV4dGVudCB9IGZyb20gJ2QzLWFycmF5J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGludGVycG9sYXRlT3JSZCB9IGZyb20gJ2QzLXNjYWxlLWNocm9tYXRpYydcclxuaW1wb3J0IHsgZm9yY2VTaW11bGF0aW9uLCBmb3JjZU1hbnlCb2R5LCBmb3JjZUNlbnRlciwgZm9yY2VDb2xsaWRlLCBmb3JjZVgsIGZvcmNlWSB9IGZyb20gJ2QzLWZvcmNlJ1xyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIFByb3BvcnRpb25hbFN5bWJvbExlZ2VuZCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kLXByb3BvcnRpb25hbC1zeW1ib2xzJ1xyXG5pbXBvcnQgeyBzeW1ib2wsIHN5bWJvbENpcmNsZSwgc3ltYm9sRGlhbW9uZCwgc3ltYm9sU3Rhciwgc3ltYm9sQ3Jvc3MsIHN5bWJvbFNxdWFyZSwgc3ltYm9sVHJpYW5nbGUsIHN5bWJvbFd5ZSB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IsIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzLCBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRSZWdpb25zU2VsZWN0b3IsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBhcHBseVBhdHRlcm5GaWxsIH0gZnJvbSAnLi4vY29yZS9wYXR0ZXJuLWZpbGwnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb3BvcnRpb25hbCBzeW1ib2wgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIHRydWUsICdwcycpXHJcblxyXG4gICAgLy9zaGFwZVxyXG4gICAgb3V0LnBzU2hhcGVfID0gJ2NpcmNsZScgLy8gYWNjZXB0ZWQgdmFsdWVzOiBjaXJjbGUsIGJhciwgc3F1YXJlLCBzdGFyLCBkaWFtb25kLCB3eWUsIGNyb3NzXHJcbiAgICBvdXQucHNDdXN0b21TaGFwZV8gLy8gc2VlIGh0dHA6Ly91c2luZy1kM2pzLmNvbS8wNV8xMF9zeW1ib2xzLmh0bWwjaF82NmlJUTVzSklUXHJcbiAgICBvdXQucHNDdXN0b21TVkdfIC8vIHNlZSBodHRwOi8vYmwub2Nrcy5vcmcvamVzc2loYW1lbC85NjQ4NDk1XHJcbiAgICBvdXQucHNTcGlrZVdpZHRoXyA9IDcgLy8gJ3NwaWtlJyBzaGFwZSB3aWR0aHNcclxuICAgIG91dC5wc09mZnNldF8gPSB7IHg6IDAsIHk6IDAgfVxyXG5cclxuICAgIC8vc2l6ZVxyXG4gICAgb3V0LnBzTWF4U2l6ZV8gPSAzMCAvLyBtYXggc3ltYm9sIHNpemVcclxuICAgIG91dC5wc01pblNpemVfID0gNSAvLyBtaW4gc3ltYm9sIHNpemVcclxuICAgIG91dC5wc0JhcldpZHRoXyA9IDEwIC8vZm9yIHZlcnRpY2FsIGJhcnNcclxuICAgIG91dC5wc01heFZhbHVlXyA9IHVuZGVmaW5lZCAvLyBhbGxvdyB0aGUgdXNlciB0byBtYW51YWxseSBkZWZpbmUgdGhlIGRvbWFpbiBvZiB0aGUgc2l6aW5nIHNjYWxlLiBFLmcuIGlmIHRoZSB1c2VyIHdhbnRzIHRvIHVzZSB0aGUgc2FtZSBzY2FsZSBhY3Jvc3MgZGlmZmVyZW50IG1hcHMuXHJcbiAgICBvdXQucHNNaW5WYWx1ZV8gPSB1bmRlZmluZWRcclxuICAgIG91dC5wc1NpemVTY2FsZV8gPSB1bmRlZmluZWQgLy8gJ3NxcnQnIG9yICdsaW5lYXInXHJcblxyXG4gICAgLy9jb2xvdXJcclxuICAgIG91dC5wc0ZpbGxfID0gJyMyZDUwYTAnIC8vc2FtZSBmaWxsIGZvciBhbGwgc3ltYm9scyB3aGVuIG5vIHZpc3VhbCB2YXJpYWJsZSAoc2V0RGF0YSgpKSBmb3IgJ2NvbG9yJyBpcyBzcGVjaWZpZWRcclxuICAgIG91dC5wc0ZpbGxPcGFjaXR5XyA9IDFcclxuICAgIG91dC5wc1N0cm9rZV8gPSAnI2ZmZmZmZidcclxuICAgIG91dC5wc1N0cm9rZVdpZHRoXyA9IDAuMlxyXG4gICAgb3V0LnBzQ2xhc3Nlc18gPSA1IC8vIG51bWJlciBvZiBjbGFzc2VzIHRvIHVzZSBmb3IgY29sb3VyaW5nXHJcbiAgICBvdXQucHNDb2xvcnNfID0gbnVsbCAvL2NvbG91cnMgdG8gdXNlIGZvciB0aHJlc2hvbGQgY29sb3VyaW5nXHJcbiAgICBvdXQucHNDb2xvckZ1bl8gPSBpbnRlcnBvbGF0ZU9yUmRcclxuICAgIG91dC5wc0NsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkIC8vYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIGZyb20gdGhlIGNsYXNzIGlcclxuXHJcbiAgICAvL3RoZSB0aHJlc2hvbGQsIHdoZW4gdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZCBpcyAndGhyZXNob2xkJ1xyXG4gICAgb3V0LnBzVGhyZXNob2xkc18gPSBbMF1cclxuICAgIC8vdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZFxyXG4gICAgb3V0LnBzQ2xhc3NpZmljYXRpb25NZXRob2RfID0gJ3F1YW50aWxlJyAvLyBvcjogZXF1aW50ZXIsIHRocmVzaG9sZFxyXG4gICAgLy93aGVuIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHksIGVuc3VyZSB0aGUgdGhyZXNob2xkIGFyZSBuaWNlIHJvdW5kZWQgdmFsdWVzXHJcbiAgICBvdXQubWFrZUNsYXNzaWZOaWNlXyA9IHRydWVcclxuICAgIC8vXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyOiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybiB0aGUgc3ltYm9sIHNpemUvY29sb3IgZnJvbSB0aGUgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyU2l6ZV8gPSB1bmRlZmluZWRcclxuICAgIG91dC5jbGFzc2lmaWVyQ29sb3JfID0gdW5kZWZpbmVkXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHRvb2x0aXBUZXh0RnVuUHNcclxuXHJcbiAgICAvL2RvcmxpbmcgY2FydG9ncmFtXHJcbiAgICBvdXQuZG9ybGluZ18gPSBmYWxzZVxyXG4gICAgb3V0LmRvcmxpbmdTdHJlbmd0aF8gPSB7IHg6IDEsIHk6IDEgfVxyXG4gICAgb3V0LmRvcmxpbmdJdGVyYXRpb25zXyA9IDFcclxuICAgIG91dC5wc0NvZGVMYWJlbHNfID0gZmFsc2UgLy8gc2hvdyBjb3VudHJ5IGNvZGVzIGluIHN5bWJvbHNcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7W1xyXG4gICAgICAgICdwc01heFNpemVfJyxcclxuICAgICAgICAncHNNaW5TaXplXycsXHJcbiAgICAgICAgJ3BzTWF4VmFsdWVfJyxcclxuICAgICAgICAncHNNaW5WYWx1ZV8nLFxyXG4gICAgICAgICdwc0ZpbGxfJyxcclxuICAgICAgICAncHNGaWxsT3BhY2l0eV8nLFxyXG4gICAgICAgICdwc1N0cm9rZV8nLFxyXG4gICAgICAgICdwc1N0cm9rZVdpZHRoXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpZXJTaXplXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpZXJDb2xvcl8nLFxyXG4gICAgICAgICdwc1NoYXBlXycsXHJcbiAgICAgICAgJ3BzQ3VzdG9tU2hhcGVfJyxcclxuICAgICAgICAncHNCYXJXaWR0aF8nLFxyXG4gICAgICAgICdwc0NsYXNzVG9GaWxsU3R5bGVfJyxcclxuICAgICAgICAncHNDb2xvckZ1bl8nLFxyXG4gICAgICAgICdwc1NpemVTY2FsZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAncHNUaHJlc2hvbGRzXycsXHJcbiAgICAgICAgJ3BzQ29sb3JzXycsXHJcbiAgICAgICAgJ3BzQ3VzdG9tU1ZHXycsXHJcbiAgICAgICAgJ3BzT2Zmc2V0XycsXHJcbiAgICAgICAgJ3BzQ2xhc3NpZmljYXRpb25NZXRob2RfJyxcclxuICAgICAgICAncHNDbGFzc2VzXycsXHJcbiAgICAgICAgJ2RvcmxpbmdfJyxcclxuICAgICAgICAnZG9ybGluZ1N0cmVuZ3RoXycsXHJcbiAgICAgICAgJ3BzU3Bpa2VXaWR0aF8nLFxyXG4gICAgICAgICdwc0NvZGVMYWJlbHNfJyxcclxuICAgICAgICAnZG9ybGluZ0l0ZXJhdGlvbnNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ3BzTWF4U2l6ZScsXHJcbiAgICAgICAgICAgICdwc01pblNpemUnLFxyXG4gICAgICAgICAgICAncHNGaWxsJyxcclxuICAgICAgICAgICAgJ3BzRmlsbE9wYWNpdHknLFxyXG4gICAgICAgICAgICAncHNTdHJva2UnLFxyXG4gICAgICAgICAgICAncHNTdHJva2VXaWR0aCcsXHJcbiAgICAgICAgICAgICdjbGFzc2lmaWVyU2l6ZScsXHJcbiAgICAgICAgICAgICdjbGFzc2lmaWVyQ29sb3InLFxyXG4gICAgICAgICAgICAncHNTaGFwZScsXHJcbiAgICAgICAgICAgICdwc0N1c3RvbVNoYXBlJyxcclxuICAgICAgICAgICAgJ3BzQmFyV2lkdGgnLFxyXG4gICAgICAgICAgICAncHNDbGFzc1RvRmlsbFN0eWxlJyxcclxuICAgICAgICAgICAgJ3BzQ29sb3JGdW4nLFxyXG4gICAgICAgICAgICAnbm9EYXRhRmlsbFN0eWxlJyxcclxuICAgICAgICAgICAgJ3BzVGhyZXNob2xkJyxcclxuICAgICAgICAgICAgJ3BzQ29sb3JzJyxcclxuICAgICAgICAgICAgJ3BzQ3VzdG9tU1ZHJyxcclxuICAgICAgICAgICAgJ3BzT2Zmc2V0JyxcclxuICAgICAgICAgICAgJ3BzQ2xhc3NpZmljYXRpb25NZXRob2QnLFxyXG4gICAgICAgICAgICAncHNDbGFzc2VzJyxcclxuICAgICAgICAgICAgJ2RvcmxpbmdJdGVyYXRpb25zXycsXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIG9mIHNvbWUgc3BlY2lhbCBnZXR0ZXJzL3NldHRlcnNcclxuICAgIG91dC5wc0NvbG9yRnVuID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQucHNDb2xvckZ1bl9cclxuICAgICAgICBvdXQucHNDb2xvckZ1bl8gPSB2XHJcbiAgICAgICAgb3V0LnBzQ2xhc3NUb0ZpbGxTdHlsZV8gPSBnZXRDb2xvckxlZ2VuZChvdXQucHNDb2xvckZ1bl8sIG91dC5wc0NvbG9yc18pXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG4gICAgb3V0LnBzVGhyZXNob2xkcyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnBzVGhyZXNob2xkc19cclxuICAgICAgICBvdXQucHNUaHJlc2hvbGRzXyA9IHZcclxuICAgICAgICBvdXQucHNDbGFzc2VzKHYubGVuZ3RoICsgMSlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvL2RlZmluZSBjbGFzc2lmaWVycyBmb3Igc2l6aW5nIGFuZCBjb2xvdXJpbmcgKG91dC5jbGFzc2lmaWVyU2l6ZV8gJiBvdXQuY2xhc3NpZmllckNvbG9yXylcclxuICAgICAgICAgICAgZGVmaW5lQ2xhc3NpZmllcnMoKVxyXG5cclxuICAgICAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBtYWluIG1hcCdzIFNWR1xyXG4gICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwcm9wb3J0aW9uYWwgc3ltYm9scyBjbGFzc2lmaWNhdGlvbjogJyArIGUubWVzc2FnZSlcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhc3NpZ25zIGEgY29sb3IgdG8gZWFjaCBzeW1ib2wsIGJhc2VkIG9uIHRoZWlyIHN0YXRpc3RpY2FsIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSB7XHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQuY2xhc3NpZmllckNvbG9yXykge1xyXG4gICAgICAgICAgICAgICAgLy9hc3NpZ24gY29sb3IgY2xhc3MgdG8gZWFjaCBzeW1ib2wsIGJhc2VkIG9uIHRoZWlyIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGUgc3ltYm9sIHBhdGggaGFzbnQgYmVlbiBhcHBlbmRlZC4gT25seSB0aGUgcGFyZW50IGcgZWxlbWVudCAoLmVtLWNlbnRyb2lkKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JEYXRhID0gbWFwLnN0YXREYXRhKCdjb2xvcicpXHJcbiAgICAgICAgICAgICAgICBtYXAuc3ZnXy5zZWxlY3RBbGwoJy5lbS1jZW50cm9pZCcpLmF0dHIoJ2VjbCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gY29sb3JEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9PSAwICYmICF2KSB8fCB2ID09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgYyA9ICtvdXQuY2xhc3NpZmllckNvbG9yXygrdilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBkZWZpbmVzIGNsYXNzaWZpZXIgZnVuY3Rpb25zIChvdXQuY2xhc3NpZmllckNvbG9yIGFuZCBvdXQuY2xhc3NpZmllclNpemUpIGZvciBib3RoIHN5bWJvbCBzaXplIGFuZCBjb2xvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWZpbmVDbGFzc2lmaWVycygpIHtcclxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBzY2FsZVxyXG4gICAgICAgIGlmICghb3V0LnBzU2l6ZVNjYWxlXykge1xyXG4gICAgICAgICAgICBpZiAob3V0LnBzU2hhcGVfID09ICdzcGlrZScpIHtcclxuICAgICAgICAgICAgICAgIG91dC5wc1NpemVTY2FsZV8gPSAnbGluZWFyJ1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0LnBzU2l6ZVNjYWxlXyA9ICdzcXJ0J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NpbXBseSByZXR1cm4gdGhlIGFycmF5IFswLDEsMiwzLC4uLixuYi0xXVxyXG4gICAgICAgIGNvbnN0IGdldEEgPSBmdW5jdGlvbiAobmIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsuLi5BcnJheShuYikua2V5cygpXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXNlIHNpemUgZGF0YXNldFxyXG4gICAgICAgIGxldCByYXdEYXRhID0gb3V0LnN0YXREYXRhKCdzaXplJykuZ2V0QXJyYXkoKSB8fCBvdXQuc3RhdERhdGEoKS5nZXRBcnJheSgpXHJcbiAgICAgICAgbGV0IGRhdGEgPSByYXdEYXRhLmZpbHRlcigoZCkgPT4gdHlwZW9mIGQgPT09ICdudW1iZXInICYmICFpc05hTihkKSAmJiBpc0Zpbml0ZShkKSlcclxuICAgICAgICBsZXQgW21pblZhbCwgbWF4VmFsXSA9IGV4dGVudChkYXRhKVxyXG4gICAgICAgIGxldCBtaW4gPSBvdXQucHNNaW5WYWx1ZV8gPz8gbWluVmFsXHJcbiAgICAgICAgbGV0IG1heCA9IG91dC5wc01heFZhbHVlXyA/PyBtYXhWYWxcclxuICAgICAgICBsZXQgc2l6ZURvbWFpbiA9IGRhdGEgPyBbbWluLCBtYXhdIDogW291dC5zdGF0RGF0YSgpLmdldE1pbigpLCBvdXQuc3RhdERhdGEoKS5nZXRNYXgoKV1cclxuXHJcbiAgICAgICAgbGV0IHNjYWxlID0gb3V0LnBzU2l6ZVNjYWxlXyA9PSAnc3FydCcgPyBzY2FsZVNxcnQgOiBzY2FsZUxpbmVhclxyXG4gICAgICAgIG91dC5jbGFzc2lmaWVyU2l6ZShzY2FsZSgpLmRvbWFpbihzaXplRG9tYWluKS5yYW5nZShbb3V0LnBzTWluU2l6ZV8sIG91dC5wc01heFNpemVfXSkpXHJcblxyXG4gICAgICAgIC8vIGNvbG91clxyXG4gICAgICAgIGlmIChvdXQuc3RhdERhdGEoJ2NvbG9yJykuZ2V0QXJyYXkoKSkge1xyXG4gICAgICAgICAgICAvL3VzZSBzdWl0YWJsZSBjbGFzc2lmaWNhdGlvbiB0eXBlIGZvciBjb2xvdXJpbmdcclxuICAgICAgICAgICAgaWYgKG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9PT0gJ3F1YW50aWxlJykge1xyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpbGUtc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBvdXQuc3RhdERhdGEoJ2NvbG9yJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRBKG91dC5wc0NsYXNzZXNfKVxyXG4gICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXJDb2xvcihzY2FsZVF1YW50aWxlKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9PT0gJ2VxdWludGVyJykge1xyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpemUtc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBvdXQuc3RhdERhdGEoJ2NvbG9yJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRBKG91dC5wc0NsYXNzZXNfKVxyXG4gICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXJDb2xvcihcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZVF1YW50aXplKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbbWluKGRvbWFpbiksIG1heChkb21haW4pXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHJhbmdlKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYWtlQ2xhc3NpZk5pY2VfKSBvdXQuY2xhc3NpZmllckNvbG9yKCkubmljZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzQ2xhc3NpZmljYXRpb25NZXRob2RfID09PSAndGhyZXNob2xkJykge1xyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlc1xyXG4gICAgICAgICAgICAgICAgb3V0LnBzQ2xhc3NlcyhvdXQucHNUaHJlc2hvbGRzKCkubGVuZ3RoICsgMSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0QShvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyQ29sb3Ioc2NhbGVUaHJlc2hvbGQoKS5kb21haW4ob3V0LnBzVGhyZXNob2xkcygpKS5yYW5nZShyYW5nZSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHByb3BvcnRpb25hbCBzeW1ib2wgc3R5bGluZyB0byBhIG1hcCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcFxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vc2VlIGh0dHBzOi8vYmwub2Nrcy5vcmcvbWJvc3RvY2svNDM0MjA0NSBhbmQgaHR0cHM6Ly9ib3N0Lm9ja3Mub3JnL21pa2UvYnViYmxlLW1hcC9cclxuICAgICAgICAvL2RlZmluZSBzdHlsZSBwZXIgY2xhc3NcclxuICAgICAgICBpZiAoIW91dC5wc0NsYXNzVG9GaWxsU3R5bGUoKSkgb3V0LnBzQ2xhc3NUb0ZpbGxTdHlsZShnZXRDb2xvckxlZ2VuZChvdXQucHNDb2xvckZ1bl8sIG91dC5wc0NvbG9yc18pKVxyXG5cclxuICAgICAgICAvLyBpZiBzaXplIGRhdGFzZXQgbm90IGRlZmluZWQgdGhlbiB1c2UgZGVmYXVsdFxyXG4gICAgICAgIGxldCBzaXplRGF0YSA9IG1hcC5zdGF0RGF0YSgnc2l6ZScpLmdldEFycmF5KCkgPyBtYXAuc3RhdERhdGEoJ3NpemUnKSA6IG1hcC5zdGF0RGF0YSgpXHJcblxyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICAvL2NsZWFyIHByZXZpb3VzIGNlbnRyb2lkc1xyXG4gICAgICAgICAgICBsZXQgcHJldlN5bWJvbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJzpub3QoI2VtLWluc2V0cy1ncm91cCkgZy5lbS1jZW50cm9pZCA+IConKVxyXG4gICAgICAgICAgICBwcmV2U3ltYm9scy5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgLy8gJ3NtYWxsJyBjZW50cm9pZHMgb24gdG9wIG9mIGJpZyBvbmVzXHJcbiAgICAgICAgICAgIHVwZGF0ZVN5bWJvbHNEcmF3T3JkZXIobWFwKVxyXG5cclxuICAgICAgICAgICAgLy8gYXBwZW5kIHN5bWJvbHMgdG8gY2VudHJvaWRzXHJcbiAgICAgICAgICAgIGxldCBzeW1iXHJcbiAgICAgICAgICAgIGlmIChvdXQucHNDdXN0b21TVkdfKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kQ3VzdG9tU3ltYm9sc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzU2hhcGVfID09ICdiYXInKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kQmFyc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzU2hhcGVfID09ICdjaXJjbGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kQ2lyY2xlc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzU2hhcGVfID09ICdzcGlrZScpIHtcclxuICAgICAgICAgICAgICAgIHN5bWIgPSBhcHBlbmRTcGlrZXNUb01hcChtYXAsIHNpemVEYXRhKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2lyY2xlLCBjcm9zcywgc3RhciwgdHJpYW5nbGUsIGRpYW1vbmQsIHNxdWFyZSwgd3llIG9yIGN1c3RvbVxyXG4gICAgICAgICAgICAgICAgc3ltYiA9IGFwcGVuZEQzU3ltYm9sc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRvcmxpbmcgY2FydG9ncmFtXHJcbiAgICAgICAgICAgIGlmIChvdXQuZG9ybGluZ18pIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5RG9ybGluZ0ZvcmNlKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnNpbXVsYXRpb24pIHN0b3BTaW11bGF0aW9uKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXBwZW5kTGFiZWxzVG9TeW1ib2xzKG1hcCwgc2l6ZURhdGEpXHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgc3R5bGUgb2Ygc3ltYm9sc1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXAuZ2VvXyAhPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRTeW1ib2xzVG9NaXhlZE5VVFMobWFwLCBzaXplRGF0YSwgcmVnaW9ucylcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhcHBseSAnbmQnIGNsYXNzIHRvIG5vIGRhdGEgcmVnaW9ucyBmb3IgbGVnZW5kIGl0ZW0gaG92ZXJcclxuICAgICAgICAgICAgICAgIHJlZ2lvbnMuYXR0cignZWNsJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICghc3YudmFsdWUgJiYgc3YgIT09IDAgJiYgc3YudmFsdWUgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PIElOUFVUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbmknXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdiAmJiBzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3YudmFsdWUgPT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEQVRBIE5PVCBBVkFJTEFCTEUgKG5vIGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2V0U3ltYm9sU3R5bGVzKHN5bWIpXHJcblxyXG4gICAgICAgICAgICBhZGRNb3VzZUV2ZW50cyhtYXApXHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgbGFiZWxzIGZvciBzdGF0aXN0aWNhbCB2YWx1ZXMgaWYgcmVxdWlyZWRcclxuICAgICAgICAgICAgaWYgKG91dC5sYWJlbHNfPy52YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMobWFwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2FkZCBoYXRjaGluZyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKG91dC5wYXR0ZXJuRmlsbF8pIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5UGF0dGVybkZpbGwobWFwLCBvdXQucGF0dGVybkZpbGxfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXBcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBlbmRMYWJlbHNUb1N5bWJvbHMgPSBmdW5jdGlvbiAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIGxldCBzeW1ib2xDb250YWluZXJzID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgLy9jb3VudHJ5IGNvZGUgbGFiZWxzXHJcbiAgICAgICAgaWYgKG91dC5wc0NvZGVMYWJlbHNfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50cnlDb2RlTGFiZWwgPSBzeW1ib2xDb250YWluZXJzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bT8udmFsdWUgIT09ICc6JyAmJiBkYXR1bT8udmFsdWUgIT0gbnVsbCAvLyBJZ25vcmUgYCc6J2AsIGBudWxsYCwgYW5kIGB1bmRlZmluZWRgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY2lyY2xlLWNvZGUtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtPy52YWx1ZSA9PT0gJzonID8gJycgOiBkLnByb3BlcnRpZXMuaWQgLy8gSGlkZSB0ZXh0IGlmIHZhbHVlIGlzICc6J1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpemUgYWRqdXN0bWVudCBmYWN0b3IgZGVwZW5kcyBvbiBzeW1ib2wgdHlwZSwgYW5kIHdoZXRoZXIgc3RhdCB2YWx1ZXMgYXJlIGFsc28gYWRkZWQgdG8gdGhlIGNpcmNsZXNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gb3V0LmxhYmVsc18/LnZhbHVlcyAmJiBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKT8udmFsdWUgPyAwLjggOiAwLjlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LnBzU2hhcGVfID09PSAnc3F1YXJlJykgZmFjdG9yID0gZmFjdG9yIC0gMC40XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3JhZGl1cyAqIGZhY3Rvcn1weGBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQob3V0LnBzRmlsbF8pKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgKGQpID0+IChvdXQubGFiZWxzXz8udmFsdWVzICYmIHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpPy52YWx1ZSA/ICctMC4zZW0nIDogJzAnKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc3RhdCBsYWJlbHNcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18/LnZhbHVlcykge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0TGFiZWxzID0gc3ltYm9sQ29udGFpbmVyc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0/LnZhbHVlICE9PSAnOicgJiYgZGF0dW0/LnZhbHVlICE9IG51bGwgLy8gSWdub3JlIGAnOidgLCBgbnVsbGAsIGFuZCBgdW5kZWZpbmVkYFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNpcmNsZS1zdGF0LWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXR1bT8udmFsdWUpIHJldHVybiBkYXR1bS52YWx1ZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtyYWRpdXMgKiAwLjR9cHhgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKG91dC5wc0ZpbGxfKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIChkKSA9PiAob3V0LnBzQ29kZUxhYmVsc18gPyAnMC42ZW0nIDogJzAnKSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkTW91c2VFdmVudHMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgbGV0IHN5bWJvbHMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICBzeW1ib2xzXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGwgPSBzZWwuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG5ld0ZpbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBzZXRzIGNvbG9yL3N0cm9rZS9vcGFjaXR5IHN0eWxlcyBvZiBhbGwgc3ltYm9sc1xyXG4gICAgICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IHN5bWIgc3ltYm9scyBkMyBzZWxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0U3ltYm9sU3R5bGVzKHN5bWIpIHtcclxuICAgICAgICBzeW1iLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBvdXQucHNGaWxsT3BhY2l0eSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIG91dC5wc1N0cm9rZSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIG91dC5wc1N0cm9rZVdpZHRoKCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuY2xhc3NpZmllckNvbG9yXykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZm9yIHBzLCBlY2wgYXR0cmlidXRlIGJlbG9uZ3MgdG8gdGhlIHBhcmVudCBnLmVtLWNlbnRyb2lkIG5vZGUgY3JlYXRlZCBpbiBtYXAtdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsIHx8IGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGVfIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IG91dC5wc0NsYXNzVG9GaWxsU3R5bGVfKGVjbCwgb3V0LnBzQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQucHNGaWxsX1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbF9fXycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxsID0gc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxsIC8vIHNhdmUgZm9yIGxlZ2VuZCBtb3VzZW92ZXJcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSBkcmF3IG9yZGVyIG9mIHRoZSBzeW1ib2xzIGFjY29yZGluZyB0byB0aGVpciBkYXRhIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHsqfSBtYXAgbWFwIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bWJvbHNEcmF3T3JkZXIobWFwKSB7XHJcbiAgICAgICAgY29uc3QgZ2NwID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tcHJvcC1zeW1ib2xzJylcclxuICAgICAgICBjb25zdCBzaXplRGF0YSA9IG1hcC5zdGF0RGF0YSgnc2l6ZScpPy5nZXRBcnJheT8uKCkgPyBtYXAuc3RhdERhdGEoJ3NpemUnKSA6IG1hcC5zdGF0RGF0YSgpXHJcblxyXG4gICAgICAgIC8vIDEuIEZpbHRlciBhbmQgc29ydCBmZWF0dXJlcyB3aXRoIGRhdGFcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcykge1xyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWQgPSBtYXAuR2VvbWV0cmllcy5jZW50cm9pZEZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNpemVEYXRhLmdldD8uKGYucHJvcGVydGllcy5pZCk/LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgIT0gbnVsbCAmJiB2ICE9PSAnOidcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplRGF0YS5nZXQoYi5wcm9wZXJ0aWVzLmlkKS52YWx1ZSAtIHNpemVEYXRhLmdldChhLnByb3BlcnRpZXMuaWQpLnZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gMi4gQ2xlYXIgYW5kIHJlYmluZFxyXG4gICAgICAgICAgICBnY3Auc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgICAgIGdjcC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoc29ydGVkLCAoZCkgPT4gZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAncHMnICsgZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiBgdHJhbnNsYXRlKCR7ZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzBdLnRvRml4ZWQoMyl9LCR7ZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzFdLnRvRml4ZWQoMyl9KWApXHJcblxyXG4gICAgICAgICAgICAvLyAzLiBhZGQgdGhlIGVjbCBhdHRyaWJ1dGUgYmFjayB0byB0aGUgbmV3bHkgY3JlYXRlZCBnIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChtYXApIC8vXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGVuZFNwaWtlc1RvTWFwKG1hcCwgc2l6ZURhdGEpIHtcclxuICAgICAgICAvL1RoZSBzcGlrZSBmdW5jdGlvbiBjcmVhdGVzIGEgdHJpYW5ndWxhciBwYXRoIG9mIHRoZSBnaXZlbiBsZW5ndGggKGhlaWdodCkgd2l0aCBhIGJhc2Ugd2lkdGggb2YgNyBwaXhlbHMuXHJcbiAgICAgICAgY29uc3Qgc3Bpa2UgPSAobGVuZ3RoLCB3aWR0aCA9IG91dC5wc1NwaWtlV2lkdGhfKSA9PiBgTSR7LXdpZHRoIC8gMn0sMEwwLCR7LWxlbmd0aH1MJHt3aWR0aCAvIDJ9LDBgXHJcbiAgICAgICAgbGV0IHN5bWJvbENvbnRhaW5lcnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGNpcmNsZXMgdG8gZWFjaCBzeW1ib2wgY29udGFpbmVyXHJcbiAgICAgICAgY29uc3Qgc3Bpa2VzID0gc3ltYm9sQ29udGFpbmVyc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSBzcGlrZSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiBkLmNvbG9yIHx8ICdzdGVlbGJsdWUnKSAvLyBBZGp1c3QgY29sb3IgYXMgbmVlZGVkXHJcbiAgICAgICAgICAgIC8vLmF0dHIoJ2ZpbGwnLCBtYXAucHNGaWxsXylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIG1hcC5wc0ZpbGxPcGFjaXR5XylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIG1hcC5wc1N0cm9rZV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBtYXAucHNTdHJva2VXaWR0aF8pXHJcblxyXG4gICAgICAgIHJldHVybiBzcGlrZXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIDxjaXJjbGU+IGVsZW1lbnRzIGZvciBlYWNoIHJlZ2lvbiBpbiB0aGUgbWFwIFNWR1xyXG4gICAgICogQHBhcmFtIHsqfSBtYXAgbWFwIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0geyp9IHNpemVEYXRhIHN0YXRpc3RpY2FsIGRhdGEgZm9yIHNpemUgZS5nLiBtYXAuc3RhdERhdGEoJ3NpemUnKVxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwZW5kQ2lyY2xlc1RvTWFwKG1hcCwgc2l6ZURhdGEpIHtcclxuICAgICAgICAvLyBBcHBlbmQgY2lyY2xlcyB0byBlYWNoIHN5bWJvbCBjb250YWluZXJcclxuICAgICAgICBjb25zdCBjaXJjbGVzID0gbWFwXHJcbiAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGQucHJvcGVydGllcy5pZCA9PSAnREUnKSBjb25zb2xlLmxvZyhkYXR1bSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bSAmJiBkYXR1bS52YWx1ZSAhPT0gJzonICYmIGRhdHVtLnZhbHVlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpXHJcbiAgICAgICAgICAgICAgICBpZiAocmFkaXVzIDwgMCkgY29uc29sZS5lcnJvcignTmVnYXRpdmUgcmFkaXVzIGZvciBjaXJjbGU6JywgZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHJhZGl1cykpIGNvbnNvbGUuZXJyb3IoJ05hTiByYWRpdXMgZm9yIGNpcmNsZTonLCBkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFkaXVzXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBjaXJjbGVzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlEb3JsaW5nRm9yY2UobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIGxldCBzeW1ib2xDb250YWluZXJzID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcblxyXG4gICAgICAgIGlmIChvdXQuc2ltdWxhdGlvbikge1xyXG4gICAgICAgICAgICBzdG9wU2ltdWxhdGlvbigpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBmb3JjZSBzaW11bGF0aW9uXHJcbiAgICAgICAgY29uc29sZS5sb2coJ25ldyBkb3JsaW5nIHNpbXVsYXRpb24nKVxyXG4gICAgICAgIG91dC5zaW11bGF0aW9uID0gZm9yY2VTaW11bGF0aW9uKG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpXHJcbiAgICAgICAgICAgIC5mb3JjZShcclxuICAgICAgICAgICAgICAgICd4JyxcclxuICAgICAgICAgICAgICAgIGZvcmNlWCgoZCkgPT4gZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzBdKS5zdHJlbmd0aChvdXQuZG9ybGluZ1N0cmVuZ3RoXy54KSAvLyBTdHJvbmdlciBwdWxsIHRvIG9yaWdpbmFsIHhcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuZm9yY2UoXHJcbiAgICAgICAgICAgICAgICAneScsXHJcbiAgICAgICAgICAgICAgICBmb3JjZVkoKGQpID0+IGQucHJvcGVydGllcy5jZW50cm9pZFsxXSkuc3RyZW5ndGgob3V0LmRvcmxpbmdTdHJlbmd0aF8ueSkgLy8gU3Ryb25nZXIgcHVsbCB0byBvcmlnaW5hbCB5XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmZvcmNlKFxyXG4gICAgICAgICAgICAgICAgJ2NvbGxpZGUnLFxyXG4gICAgICAgICAgICAgICAgZm9yY2VDb2xsaWRlKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gZGF0dW0gPyBvdXQuY2xhc3NpZmllclNpemVfKGRhdHVtLnZhbHVlKSA6IDBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5wc1NoYXBlXyA9PT0gJ3NxdWFyZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzaXplIC8gMikgKiBNYXRoLlNRUlQyIC8vIEFkanVzdCBmb3IgZGlhZ29uYWwgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgLy8gRGVmYXVsdCBmb3IgY2lyY2xlc1xyXG4gICAgICAgICAgICAgICAgfSkuaXRlcmF0aW9ucyhvdXQuZG9ybGluZ0l0ZXJhdGlvbnNfKSAvLyBNb3JlIGl0ZXJhdGlvbnMgdG8gaW1wcm92ZSBjb2xsaXNpb24gaGFuZGxpbmdcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAvLy5hbHBoYVRhcmdldCgwLjMpIC8vIEhlbHBzIGtlZXAgY2VudHJvaWRzIGFuY2hvcmVkXHJcbiAgICAgICAgICAgIC5vbigndGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBlbGVtZW50cyB3aXRoIHRoZSBuZXcgcG9zaXRpb25zIGFuZCByYWRpaVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sQ29udGFpbmVycy5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvL291dC5zaW11bGF0aW9uLmFscGhhKDEpLnJlc3RhcnQoKSAvLyBFbnN1cmVzIHNpbXVsYXRpb24gc3RhcnRzIHdpdGggZnVsbCBzdHJlbmd0aFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0b3BTaW11bGF0aW9uKCkge1xyXG4gICAgICAgIG91dC5zaW11bGF0aW9uLnN0b3AoKSAvLyBTdG9wcyB0aGUgaW50ZXJuYWwgdGljayBsb29wXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24ub24oJ3RpY2snLCBudWxsKSAvLyBSZW1vdmUgdGljayBldmVudCBsaXN0ZW5lclxyXG4gICAgICAgIG91dC5zaW11bGF0aW9uLm9uKCdlbmQnLCBudWxsKSAvLyBSZW1vdmUgZW5kIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24gPSBudWxsIC8vIFJlbW92ZSByZWZlcmVuY2VcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIDxwYXRoPiBlbGVtZW50cyBjb250YWluaW5nIHN5bWJvbHMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBtYXAgU1ZHXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGEgZS5nLiBtYXAuc3RhdERhdGEoJ3NpemUnKVxyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwZW5kRDNTeW1ib2xzVG9NYXAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBtYXBcclxuICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc3YgJiYgc3YudmFsdWUgIT09ICc6JykgcmV0dXJuIHJnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBzaXplXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNpemVEYXRhKSByZXR1cm5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc3YgIT0gMCAmJiAhc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBvdXQuY2xhc3NpZmllclNpemVfKCtzdi52YWx1ZSkgfHwgMFxyXG5cclxuICAgICAgICAgICAgICAgIC8vYXBwbHkgc2l6ZSB0byBzaGFwZVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5wc0N1c3RvbVNoYXBlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQucHNDdXN0b21TaGFwZV8uc2l6ZShzaXplICogc2l6ZSkoKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xUeXBlID0gc3ltYm9sc0xpYnJhcnlbb3V0LnBzU2hhcGVfXSB8fCBzeW1ib2xzTGlicmFyeVsnY2lyY2xlJ11cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnR5cGUoc3ltYm9sVHlwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNpemUoc2l6ZSAqIHNpemUpKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIDxyZWN0PiBlbGVtZW50cyBjb250YWluaW5nIGJhcnMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBtYXAgU1ZHXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGEgZS5nLiBtYXAuc3RhdERhdGEoJ3NpemUnKVxyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwZW5kQmFyc1RvTWFwKG1hcCwgc2l6ZURhdGEpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBtYXBcclxuICAgICAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdiAmJiBzdi52YWx1ZSAhPT0gJzonKSByZXR1cm4gcmdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQucHNCYXJXaWR0aF8pXHJcbiAgICAgICAgICAgICAgICAvL2ZvciB2ZXJ0aWNhbCBiYXJzIHdlIHNjYWxlIHRoZSBoZWlnaHQgYXR0cmlidXRlIHVzaW5nIHRoZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICFzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oK3N2LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYlJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHstdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgLyAyfWAgKyBgLCAtJHt0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyl9KWBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIHRvIHVzZSB0cmFuc2l0aW9ucyB3ZSBuZWVkIHRvIHJlZmFjdG9yIHRoZSBkcmF3aW5nIGZ1bmN0aW9ucyB0byBwcm9taXNlcyBlLmcuIGFwcGVuZEJhcnNUb01hcCgpLnRoZW4oKCk9Pnt9KVxyXG4gICAgICAgICAgICAvL3RoaXMgaXMgYmVjYXVzZSAuYXR0cignZmlsbF9fXycsIGZ1bmN0aW9uICgpIHtzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnKX0pIGRvZXNudCB3b3JrIHVubGVzcyB5b3UgZXhlY3V0ZSBpdCBhZnRlciB0aGUgdHJhbnNpdGlvbiBlbmRzLlxyXG4gICAgICAgICAgICAvLyBlLmcuXHJcbiAgICAgICAgICAgIC8vIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLy8gLmR1cmF0aW9uKG91dC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgLy8gLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKHJnKSB7fSlcclxuICAgICAgICAgICAgLy8gLmVuZCgpXHJcbiAgICAgICAgICAgIC8vIC50aGVuKClcclxuICAgICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQXBwZW5kcyBjdXN0b20gU1ZHIHN5bWJvbHMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBtYXBcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAgICAgKiBAcGFyYW0geyp9IHNpemVEYXRhXHJcbiAgICAgKiBAcmV0dXJuIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRDdXN0b21TeW1ib2xzVG9NYXAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBtYXBcclxuICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJyNlbS1wcm9wLXN5bWJvbHMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKHN2ICYmIHN2LnZhbHVlICE9PSAnOicpIHJldHVybiByZ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncHMnKVxyXG4gICAgICAgICAgICAuaHRtbChvdXQucHNDdXN0b21TVkdfKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBzaXplXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBvdXQuY2xhc3NpZmllclNpemVfKCtzdi52YWx1ZSlcclxuICAgICAgICAgICAgICAgIGlmIChzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQucHNPZmZzZXRfLnggKiBzaXplfSwke291dC5wc09mZnNldF8ueSAqIHNpemV9KSBzY2FsZSgke3NpemV9KWBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhZGRzIHByb3BvcnRpb25hbCBzeW1ib2xzIHRvIGVhY2ggcmVnaW9ucyBpbiBhIG1hcCB3aXRoIG1peGVkIE5VVFMgbGV2ZWxzIChJTUFHRSlcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAgICAgKiBAcGFyYW0geyp9IHNpemVEYXRhXHJcbiAgICAgKiBAcGFyYW0geyp9IHJlZ2lvbnNcclxuICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZFN5bWJvbHNUb01peGVkTlVUUyhtYXAsIHNpemVEYXRhLCByZWdpb25zKSB7XHJcbiAgICAgICAgLy8gdG9nZ2xlIGRpc3BsYXkgb2YgbWl4ZWQgTlVUUyBsZXZlbHNcclxuICAgICAgICByZWdpb25zLnN0eWxlKCdkaXNwbGF5JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlbS1jbnRyZycpKSByZXR1cm4gLy8gU2tpcCBjb3VudHJ5IHJlZ2lvbnNcclxuICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gc3ltYm9sIGZvciBubyBkYXRhXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwLmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdibG9jaydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIG51dHMgYm9yZGVyIHN0cm9rZVxyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdiB8fCAhc3YudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGx2bCAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJva2UgfHwgJyM3NzcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gbnV0cyBib3JkZXIgc3Ryb2tlIHdpZHRoXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBzZWwuc3R5bGUoJ3N0cm9rZS13aWR0aCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdiB8fCAhc3YudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0Lmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsdmwgIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Ryb2tlV2lkdGggfHwgJyM3NzcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICAgICAgYXBwbHlTdHlsZVRvTWFwKG91dClcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IHN0eWxlIHRvIGluc2V0c1xyXG4gICAgICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdlbyBpbiBvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXRzIHdpdGggc2FtZSBnZW8gdGhhdCBkbyBub3Qgc2hhcmUgdGhlIHNhbWUgcGFyZW50IGluc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY2FzZSB3aGVuIHRoZXJlIGFyZSBtb3JlIHRoYW4gMiBkaWZmZXJlbnQgaW5zZXRzIHdpdGggdGhlIHNhbWUgZ2VvLiBFLmcuIDMgaW5zZXRzIGZvciBQVDIwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV0ubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXVtjXS5zdmdJZF8gIT09IG91dC5zdmdJZF8pIGFwcGx5U3R5bGVUb01hcChvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV1bY10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dW2ldLnN2Z0lkXyAhPT0gb3V0LnN2Z0lkXykgYXBwbHlTdHlsZVRvTWFwKG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuaXF1ZSBpbnNldCBnZW9fXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb10uc3ZnSWRfICE9PSBvdXQuc3ZnSWRfKSBhcHBseVN0eWxlVG9NYXAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcHJvcG9ydGlvbmFsIHN5bWJvbHMgc3R5bGluZzogJyArIGUubWVzc2FnZSlcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9wb3J0aW9uYWxTeW1ib2xMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vL2J1aWxkIGEgY29sb3IgbGVnZW5kIG9iamVjdFxyXG5leHBvcnQgY29uc3QgZ2V0Q29sb3JMZWdlbmQgPSBmdW5jdGlvbiAoY29sb3JGdW4sIGNvbG9yQXJyYXkpIHtcclxuICAgIGNvbG9yRnVuID0gY29sb3JGdW4gfHwgaW50ZXJwb2xhdGVPclJkXHJcbiAgICBpZiAoY29sb3JBcnJheSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWNsLCBudW1iZXJPZkNsYXNzZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yQXJyYXlbZWNsXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoZWNsLCBudW1iZXJPZkNsYXNzZXMpIHtcclxuICAgICAgICByZXR1cm4gY29sb3JGdW4oZWNsIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpKVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIGdpdmUgYSBkMyBzeW1ib2wgZnJvbSBhIHNoYXBlIG5hbWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBzeW1ib2xzTGlicmFyeSA9IHtcclxuICAgIGNyb3NzOiBzeW1ib2xDcm9zcyxcclxuICAgIHNxdWFyZTogc3ltYm9sU3F1YXJlLFxyXG4gICAgZGlhbW9uZDogc3ltYm9sRGlhbW9uZCxcclxuICAgIHRyaWFuZ2xlOiBzeW1ib2xUcmlhbmdsZSxcclxuICAgIHN0YXI6IHN5bWJvbFN0YXIsXHJcbiAgICB3eWU6IHN5bWJvbFd5ZSxcclxuICAgIGNpcmNsZTogc3ltYm9sQ2lyY2xlLFxyXG59XHJcblxyXG4vKipcclxuICogU3BlY2lmaWMgZnVuY3Rpb24gZm9yIHRvb2x0aXAgdGV4dC5cclxuICpcclxuICogQHBhcmFtIHsqfSByZyBUaGUgcmVnaW9uIHRvIHNob3cgaW5mb3JtYXRpb24gb24uXHJcbiAqIEBwYXJhbSB7Kn0gbWFwIFRoZSBtYXAgZWxlbWVudFxyXG4gKi9cclxuXHJcbmNvbnN0IHRvb2x0aXBUZXh0RnVuUHMgPSBmdW5jdGlvbiAocmVnaW9uLCBtYXApIHtcclxuICAgIGlmIChtYXAudG9vbHRpcF8ub21pdFJlZ2lvbnMgJiYgbWFwLnRvb2x0aXBfLm9taXRSZWdpb25zLmluY2x1ZGVzKHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKSkge1xyXG4gICAgICAgIHJldHVybiAnJyAvLyBTa2lwIHRvb2x0aXAgZm9yIG9taXR0ZWQgcmVnaW9uc1xyXG4gICAgfVxyXG4gICAgY29uc3QgYnVmID0gW11cclxuXHJcbiAgICAvLyBIZWFkZXIgd2l0aCByZWdpb24gbmFtZSBhbmQgSURcclxuICAgIGNvbnN0IHJlZ2lvbk5hbWUgPSByZWdpb24ucHJvcGVydGllcy5uYVxyXG4gICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgYnVmLnB1c2goYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj5cclxuICAgICAgICAgICAgPGI+JHtyZWdpb25OYW1lfTwvYj4ke3JlZ2lvbklkID8gYCAoJHtyZWdpb25JZH0pYCA6ICcnfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYClcclxuXHJcbiAgICAvL3N0YXQgMSB2YWx1ZVxyXG4gICAgY29uc3QgdjEgPSBtYXAuc3RhdERhdGEoJ3NpemUnKS5nZXRBcnJheSgpID8gbWFwLnN0YXREYXRhKCdzaXplJykgOiBtYXAuc3RhdERhdGEoKVxyXG4gICAgY29uc3Qgc3YxID0gdjEuZ2V0KHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgaWYgKCFzdjEgfHwgKHN2MS52YWx1ZSAhPSAwICYmICFzdjEudmFsdWUpKSB7XHJcbiAgICAgICAgYnVmLnB1c2gobWFwLm5vRGF0YVRleHRfKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL3VuaXQgMVxyXG4gICAgICAgIGNvbnN0IHVuaXQxID0gdjEudW5pdFRleHQoKVxyXG4gICAgICAgIGJ1Zi5wdXNoKGA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPiR7c3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2MS52YWx1ZSl9ICR7dW5pdDEgPyB1bml0MSA6ICcgJ308L2Rpdj5gKVxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhdCAyIHZhbHVlXHJcbiAgICBpZiAobWFwLnN0YXREYXRhKCdjb2xvcicpLmdldEFycmF5KCkpIHtcclxuICAgICAgICBjb25zdCBzdjIgPSBtYXAuc3RhdERhdGEoJ2NvbG9yJykuZ2V0KHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgIGlmICghc3YyIHx8IChzdjIudmFsdWUgIT0gMCAmJiAhc3YyLnZhbHVlKSkgYnVmLnB1c2gobWFwLm5vRGF0YVRleHRfKVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvL3N0YXQgMlxyXG4gICAgICAgICAgICBjb25zdCB1bml0MiA9IG1hcC5zdGF0RGF0YSgnY29sb3InKS51bml0VGV4dCgpXHJcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPiR7c3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2Mi52YWx1ZSl9ICR7dW5pdDIgPyB1bml0MiA6ICcgJ308L2Rpdj5gKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0LCBjcmVhdGUgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlTGluZWFyLCBzY2FsZVNxcnQgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgbGluZSwgYXJlYSB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBleHRlbnQsIG1pbiwgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCB7IGF4aXNCb3R0b20sIGF4aXNMZWZ0LCBheGlzUmlnaHQgfSBmcm9tICdkMy1heGlzJ1xyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIGxnY2ggZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoJ1xyXG5pbXBvcnQgeyBnZXRSZWdpb25zU2VsZWN0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgKiBhcyBTdGF0aXN0aWNhbERhdGEgZnJvbSAnLi4vY29yZS9zdGF0LWRhdGEnXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BhcmtsaW5lIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCB0cnVlLCAnc3BhcmsnKVxyXG5cclxuICAgIG91dC5zcGFya0xpbmVDb2xvcl8gPSAnYmxhY2snXHJcbiAgICBvdXQuc3BhcmtBcmVhQ29sb3JfID0gJyM0MWFmYWEnXHJcbiAgICBvdXQuc3BhcmtMaW5lV2lkdGhfID0gMzBcclxuICAgIG91dC5zcGFya0xpbmVIZWlnaHRfID0gMjBcclxuICAgIG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8gPSAwLjRcclxuICAgIG91dC5zcGFya0xpbmVPcGFjaXR5XyA9IDAuNlxyXG4gICAgb3V0LnNwYXJrVHlwZV8gPSAnbGluZSdcclxuICAgIG91dC5zcGFya0xpbmVDaXJjbGVSYWRpdXNfID0gMFxyXG4gICAgb3V0LnNwYXJrVG9vbHRpcENoYXJ0XyA9IHtcclxuICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgIGhlaWdodDogNTAsXHJcbiAgICAgICAgbWFyZ2luOiB7IGxlZnQ6IDYwLCByaWdodDogNDAsIHRvcDogNDAsIGJvdHRvbTogNDAgfSxcclxuICAgICAgICBjaXJjbGVSYWRpdXM6IDEuNSxcclxuICAgIH1cclxuXHJcbiAgICAvL3Nob3cgc3BhcmtsaW5lcyBvbmx5IHdoZW4gZGF0YSBmb3IgYWxsIGRhdGVzIGlzIGNvbXBsZXRlLlxyXG4gICAgLy9PdGhlcndpc2UsIGNvbnNpZGVyIHRoZSByZWdpb25zIGFzIGJlaW5nIHdpdGggbm8gZGF0YSBhdCBhbGwuXHJcbiAgICBvdXQuc2hvd09ubHlXaGVuQ29tcGxldGVfID0gZmFsc2VcclxuICAgIG91dC5zcGFya0xpbmVDaGFydEZ1bmN0aW9uXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIG91dC5zdGF0U3BhcmtfID0gbnVsbFxyXG4gICAgb3V0LnNwYXJrSGVpZ2h0Q2xhc3NpZmllcl8gPSBudWxsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnc3BhcmtMaW5lQ29sb3JfJyxcclxuICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGVfJyxcclxuICAgICAgICAnc3BhcmtUeXBlXycsXHJcbiAgICAgICAgJ3NwYXJrTGluZVdpZHRoXycsXHJcbiAgICAgICAgJ3NwYXJrTGluZUhlaWdodF8nLFxyXG4gICAgICAgICdzcGFya0xpbmVTdHJva2VXaWR0aF8nLFxyXG4gICAgICAgICdzcGFya0xpbmVPcGFjaXR5XycsXHJcbiAgICAgICAgJ3NwYXJrTGluZUNpcmNsZVJhZGl1c18nLFxyXG4gICAgICAgICdzcGFya0xpbmVBcmVhQ29sb3JfJyxcclxuICAgICAgICAnc3BhcmtUb29sdGlwQ2hhcnRfJyxcclxuICAgICAgICAnc3BhcmtMaW5lQ2hhcnRGdW5jdGlvbl8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnc3BhcmtMaW5lQ29sb3InLFxyXG4gICAgICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGUnLFxyXG4gICAgICAgICAgICAnc3BhcmtUeXBlJyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZVdpZHRoJyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZUhlaWdodCcsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVTdHJva2VXaWR0aCcsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVPcGFjaXR5JyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZUNpcmNsZVJhZGl1c18nLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lQXJlYUNvbG9yJyxcclxuICAgICAgICAgICAgJ3NwYXJrVG9vbHRpcENoYXJ0XycsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVDaGFydEZ1bmN0aW9uXycsXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvLyBBbGxvdyB1c2VycyBtYW51YWxseSBhZGQgc3BhcmtsaW5lIGRhdGFcclxuICAgIG91dC5zcGFya2xpbmVEYXRhXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnNwYXJrbGluZURhdGEgPSBmdW5jdGlvbiAoZGF0YU9iamVjdCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGVzID0gT2JqZWN0LmtleXMoZGF0YU9iamVjdFtPYmplY3Qua2V5cyhkYXRhT2JqZWN0KVswXV0pXHJcbiAgICAgICAgb3V0Ll9zdGF0RGF0ZXMgPSBkYXRlc1xyXG5cclxuICAgICAgICBkYXRlcy5mb3JFYWNoKChkYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXREYXRhID0gU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKClcclxuICAgICAgICAgICAgY29uc3QgcGVyRGF0ZVZhbHVlcyA9IHt9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlZ2lvbklkIGluIGRhdGFPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lvblZhbHVlcyA9IGRhdGFPYmplY3RbcmVnaW9uSWRdXHJcbiAgICAgICAgICAgICAgICBwZXJEYXRlVmFsdWVzW3JlZ2lvbklkXSA9IHJlZ2lvblZhbHVlc1tkYXRlXVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGF0RGF0YS5zZXREYXRhKHBlckRhdGVWYWx1ZXMpXHJcbiAgICAgICAgICAgIG91dC5zdGF0RGF0YShkYXRlLCBzdGF0RGF0YSlcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRlZmluZSBhIHNwYXJrbGluZSBtYXAgZWFzaWx5LCB3aXRob3V0IHJlcGV0aXRpb24gb2YgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBPbmx5IGZvciBldXJvYmFzZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0IEEgcGF0dGVybiBmb3IgdGhlIHN0YXQgZGF0YSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGVzIFRoZSBkYXRlcyBvZiB0aGUgY29tcG9zaXRpb24gKHRpbWUgcGFyYW1ldGVyKVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxzIE9wdGlvbmFsOiBUaGUgbGFiZWxzIGZvciB0aGUgZGF0ZXNcclxuICAgICAqL1xyXG4gICAgb3V0LnN0YXRTcGFyayA9IGZ1bmN0aW9uIChzdGF0LCBkYXRlcywgbGFiZWxzKSB7XHJcbiAgICAgICAgLy9hZGQgb25lIGRhdGFzZXQgY29uZmlnIGZvciBlYWNoIGNhdGVnb3J5XHJcbiAgICAgICAgc3RhdC5maWx0ZXJzID0gc3RhdC5maWx0ZXJzIHx8IHt9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL2NhdGVnb3J5IGNvZGVcclxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGRhdGVzW2ldXHJcbiAgICAgICAgICAgIHN0YXQuZmlsdGVycy50aW1lID0gZGF0ZVxyXG4gICAgICAgICAgICBjb25zdCBzY18gPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdCkgc2NfW2tleV0gPSBzdGF0W2tleV1cclxuICAgICAgICAgICAgc2NfLmZpbHRlcnMgPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdC5maWx0ZXJzKSBzY18uZmlsdGVyc1trZXldID0gc3RhdC5maWx0ZXJzW2tleV1cclxuICAgICAgICAgICAgb3V0LnN0YXQoZGF0ZSwgc2NfKVxyXG5cclxuICAgICAgICAgICAgLy9pZiBzcGVjaWZpZWQsIHJldHJpZXZlIGFuZCBhc3NpZ24gbGFiZWxcclxuICAgICAgICAgICAgaWYgKGxhYmVscykge1xyXG4gICAgICAgICAgICAgICAgb3V0LmNhdExhYmVsc18gPSBvdXQuY2F0TGFiZWxzXyB8fCB7fVxyXG4gICAgICAgICAgICAgICAgb3V0LmNhdExhYmVsc19bZGF0ZV0gPSBsYWJlbHNbaV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgc3RhdENvZGVzXHJcbiAgICAgICAgb3V0Ll9zdGF0RGF0ZXMgPSBkYXRlc1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBjb2RlcyBvZiB0aGUgY2F0ZWdvcmllcyB0byBjb25zaWRlciBmb3IgdGhlIGNvbXBvc2l0aW9uLiAqL1xyXG4gICAgb3V0Ll9zdGF0RGF0ZXMgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNvbXB1dGUgY29tcG9zaXRpb24gZm9yIHJlZ2lvbiBpZCwgZm9yIGVhY2ggZGF0ZS5cclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCwgZm9yIGVhY2ggZGF0ZSwgaXRzIHN0YXRpc3RpY2FsIHZhbHVlIGZvciB0aGUgcmVnaW9uXHJcbiAgICAgKiBAcGFyYW0geyp9IGlkXHJcbiAgICAgKiBAcmV0dXJucyBbe2RhdGUsdmFsdWV9XVxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGxldCBjb21wID0gW10sXHJcbiAgICAgICAgICAgIHN1bSA9IDBcclxuXHJcbiAgICAgICAgLy8gR2V0IHN0YXQgdmFsdWUgZm9yIGVhY2ggY2F0ZWdvcnkgYW5kIGNvbXB1dGUgdGhlIHN1bS5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5fc3RhdERhdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG91dC5fc3RhdERhdGVzW2ldXHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBvdXQuc3RhdERhdGEoZGF0ZSkuZ2V0KGlkKVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FzZSB3aGVuIHNvbWUgZGF0YSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbXAucHVzaCh7IGRhdGU6IGRhdGUsIHZhbHVlOiBzLnZhbHVlIH0pXHJcbiAgICAgICAgICAgIHN1bSArPSBzLnZhbHVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYXNlIHdoZW4gbm8gZGF0YVxyXG4gICAgICAgIGlmIChzdW0gPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgeWVhci1vbi15ZWFyIHBlcmNlbnRhZ2UgY2hhbmdlXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb21wLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBjb21wW2kgLSAxXS52YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjb21wW2ldLnZhbHVlXHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGVyY2VudGFnZSBjaGFuZ2UgZnJvbSBwcmV2aW91cyB2YWx1ZVxyXG4gICAgICAgICAgICBjb21wW2ldLnBlcmNlbnRhZ2VDaGFuZ2UgPSBwcmV2aW91c1ZhbHVlID09PSAwID8gMC4wMDEgOiAoKGN1cnJlbnRWYWx1ZSAtIHByZXZpb3VzVmFsdWUpIC8gcHJldmlvdXNWYWx1ZSkgKiAxMDBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBmaXJzdCBkYXRhIHBvaW50IGRvZXNuJ3QgaGF2ZSBhIHByZXZpb3VzIHZhbHVlIHRvIGNvbXBhcmUgd2l0aFxyXG4gICAgICAgIC8vY29tcFswXS5wZXJjZW50YWdlQ2hhbmdlID0gMC4wMDEgLy8gb3IgeW91IGNhbiBsZWF2ZSBpdCB1bmRlZmluZWQgb3IgbnVsbCwgZGVwZW5kaW5nIG9uIGhvdyB5b3Ugd2FudCB0byBoYW5kbGUgaXRcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm90IHByb3ZpZGVkLCBnZXQgbGlzdCBvZiBzdGF0IGNvZGVzIGZyb20gdGhlIG1hcCBzdGF0IGRhdGFcclxuICAgICAgICBpZiAoIW91dC5fc3RhdERhdGVzKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGxpc3Qgb2Ygc3RhdCBjb2Rlcy5cclxuICAgICAgICAgICAgb3V0Ll9zdGF0RGF0ZXMgPSBPYmplY3Qua2V5cyhvdXQuc3RhdERhdGFfKVxyXG4gICAgICAgICAgICAvL3JlbW92ZSBcImRlZmF1bHRcIiwgaWYgcHJlc2VudFxyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG91dC5fc3RhdERhdGVzLmluZGV4T2YoJ2RlZmF1bHQnKVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkgb3V0Ll9zdGF0RGF0ZXMuc3BsaWNlKGluZGV4LCAxKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZGVmaW5lIHNpemUgc2NhbGluZyBmdW5jdGlvblxyXG4gICAgICAgIC8vIERlZmluZSB0aGUgZG9tYWluIGNvcnJlY3RseSBmb3IgdGhlIGxvZyBzY2FsZVxyXG4gICAgICAgIG91dC5kb21haW4gPSBnZXREYXRhc2V0TWF4TWluKCkgLy8gQXZvaWQgMCBmb3IgbG9nIHNjYWxlXHJcblxyXG4gICAgICAgIC8vIGZvciBhcmVhIGNoYXJ0c1xyXG4gICAgICAgIG91dC53aWR0aENsYXNzaWZpZXJfID0gc2NhbGVTcXJ0KCkuZG9tYWluKG91dC5kb21haW4pLnJhbmdlKFswLCBvdXQuc3BhcmtMaW5lV2lkdGhfXSlcclxuICAgICAgICBvdXQuaGVpZ2h0Q2xhc3NpZmllcl8gPSBzY2FsZVNxcnQoKS5kb21haW4ob3V0LmRvbWFpbikucmFuZ2UoWzAsIG91dC5zcGFya0xpbmVIZWlnaHRfXSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9idWlsZCBhbmQgYXNzaWduIHBpZSBjaGFydHMgdG8gdGhlIHJlZ2lvbnNcclxuICAgICAgICAvL2NvbGxlY3QgbnV0cyBpZHMgZnJvbSBnIGVsZW1lbnRzLiBUT0RPOiBmaW5kIGJldHRlciB3YXkgb2YgZ2V0dGluZyBJRHNcclxuICAgICAgICBsZXQgbnV0c0lkcyA9IFtdXHJcbiAgICAgICAgbGV0IHMgPSBvdXQuc3ZnKCkuc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJylcclxuICAgICAgICBsZXQgc3ltID0gcy5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKS5hdHRyKCdpZCcsIChyZykgPT4ge1xyXG4gICAgICAgICAgICBudXRzSWRzLnB1c2gocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgcmV0dXJuICdzcGFya18nICsgcmcucHJvcGVydGllcy5pZFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIHNldCByZWdpb24gaG92ZXIgZnVuY3Rpb25cclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihvdXQpXHJcbiAgICAgICAgbGV0IHJlZ2lvbnMgPSBvdXQuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBnZXRDb21wb3NpdGlvbihyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIHNlbC5zdHlsZSgnZmlsbCcpKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24ocmcsIG91dCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEZpbGwgPSBzZWwuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGwgPSBzZWwuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgYWRkU3BhcmtMaW5lc1RvTWFwKG51dHNJZHMpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFNwYXJrTGluZXNUb01hcChpZHMpIHtcclxuICAgICAgICBpZHMuZm9yRWFjaCgobnV0c2lkKSA9PiB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIHN2ZyBmb3Igc3BhcmtsaW5lXHJcbiAgICAgICAgICAgIC8vIGNhbiBiZSBtb3JlIHRoYW4gb25lIGNlbnRlciBwb2ludCBmb3IgZWFjaCBudXRzIElEIChlLmcuIE1hbHRhIHdoZW4gaW5jbHVkZWQgaW4gaW5zZXRzKVxyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IG91dC5zdmcoKS5zZWxlY3QoJyNzcGFya18nICsgbnV0c2lkKVxyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGdldENvbXBvc2l0aW9uKG51dHNpZClcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVTcGFya0xpbmVDaGFydChub2RlLCBkYXRhLCBvdXQuc3BhcmtMaW5lV2lkdGhfLCBvdXQuc3BhcmtMaW5lSGVpZ2h0XylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlU3BhcmtMaW5lQ2hhcnQobm9kZSwgZGF0YSwgd2lkdGgsIGhlaWdodCwgaXNGb3JUb29sdGlwID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBjYWxsIGN1c3RvbSB1c2VyIGZ1bmN0aW9uIHRvIGRyYXcgdGhlIHNwYXJrbGluZVxyXG4gICAgICAgIGlmIChvdXQuc3BhcmtMaW5lQ2hhcnRGdW5jdGlvbl8gJiYgb3V0LnNwYXJrTGluZUNoYXJ0RnVuY3Rpb25fICE9PSBjcmVhdGVTcGFya0xpbmVDaGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0LnNwYXJrTGluZUNoYXJ0RnVuY3Rpb25fKG5vZGUsIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGlzRm9yVG9vbHRpcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLmRvbWFpbihbMCwgb3V0Ll9zdGF0RGF0ZXMubGVuZ3RoIC0gMV0pXHJcbiAgICAgICAgICAgIC5yYW5nZShbMC41LCB3aWR0aCAtIDAuNV0pXHJcblxyXG4gICAgICAgIGNvbnN0IG1pblZhbHVlID0gbWluKGRhdGEubWFwKChkKSA9PiBkLnZhbHVlKSkgfHwgMFxyXG4gICAgICAgIGNvbnN0IG1heFZhbHVlID0gbWF4KGRhdGEubWFwKChkKSA9PiBkLnZhbHVlKSkgfHwgMVxyXG5cclxuICAgICAgICBjb25zdCB5U2NhbGUgPSBzY2FsZUxpbmVhcigpLmRvbWFpbihbbWluVmFsdWUsIG1heFZhbHVlXSkucmFuZ2UoW2hlaWdodCwgMF0pXHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlZERhdGEgPSBkYXRhLm1hcCgoZCwgaSkgPT4gKHtcclxuICAgICAgICAgICAgLi4uZCxcclxuICAgICAgICAgICAgc2NhbGVkWFZhbHVlOiB4U2NhbGUoaSksXHJcbiAgICAgICAgICAgIHNjYWxlZFlWYWx1ZTogeVNjYWxlKGQudmFsdWUpLFxyXG4gICAgICAgIH0pKVxyXG5cclxuICAgICAgICBjb25zdCB6ZXJvWSA9IHlTY2FsZSgwKVxyXG5cclxuICAgICAgICBpZiAoaXNGb3JUb29sdGlwKSB7XHJcbiAgICAgICAgICAgIC8vIFgtYXhpcyBhdCBib3R0b21cclxuICAgICAgICAgICAgbm9kZS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMteCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke2hlaWdodH0pYClcclxuICAgICAgICAgICAgICAgIC5jYWxsKFxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNCb3R0b20oeFNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja3Mob3V0Ll9zdGF0RGF0ZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgoZCwgaSkgPT4gb3V0Ll9zdGF0RGF0ZXNbaV0pXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsICctLjhlbScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjE1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICdyb3RhdGUoLTY1KScpXHJcblxyXG4gICAgICAgICAgICAvLyBZLWF4aXMgd2l0aCByYXcgdmFsdWUgbGFiZWxzXHJcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnYXhpcy15JykuY2FsbChheGlzTGVmdCh5U2NhbGUpLnRpY2tzKDUpKVxyXG5cclxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCB6ZXJvIHJlZmVyZW5jZSBsaW5lIOKGkiBvbmx5IGlmIG1pbiA8IDAgYW5kIG1heCA+IDBcclxuICAgICAgICAgICAgaWYgKG1pblZhbHVlIDwgMCAmJiBtYXhWYWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHplcm9ZKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHplcm9ZKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZ3JheScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnMiwyJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGluZUdlbmVyYXRvciA9IGxpbmUoKVxyXG4gICAgICAgICAgICAueCgoZCkgPT4gZC5zY2FsZWRYVmFsdWUpXHJcbiAgICAgICAgICAgIC55KChkKSA9PiBkLnNjYWxlZFlWYWx1ZSlcclxuXHJcbiAgICAgICAgaWYgKG91dC5zcGFya1R5cGVfID09PSAnYXJlYScpIHtcclxuICAgICAgICAgICAgbm9kZS5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdHVtKHNjYWxlZERhdGEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIHR5cGVvZiBvdXQuc3BhcmtBcmVhQ29sb3JfID09PSAnZnVuY3Rpb24nID8gKGQsIGkpID0+IG91dC5zcGFya0FyZWFDb2xvcl8oZCwgaSkgOiBvdXQuc3BhcmtBcmVhQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5Jywgb3V0LnNwYXJrTGluZU9wYWNpdHlfKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuMylcclxuICAgICAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgICAgICdkJyxcclxuICAgICAgICAgICAgICAgICAgICBhcmVhKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLngoKGQpID0+IGQuc2NhbGVkWFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAueTAoemVyb1kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC55MSgoZCkgPT4gZC5zY2FsZWRZVmFsdWUpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub2RlLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXR1bShzY2FsZWREYXRhKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBvdXQuc3BhcmtMaW5lT3BhY2l0eV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCB0eXBlb2Ygb3V0LnNwYXJrTGluZUNvbG9yXyA9PT0gJ2Z1bmN0aW9uJyA/IChkLCBpKSA9PiBvdXQuc3BhcmtMaW5lQ29sb3JfKGQsIGkpIDogb3V0LnNwYXJrTGluZUNvbG9yXylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJyxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBvdXQuc3BhcmtMaW5lU3Ryb2tlV2lkdGhfID09PSAnZnVuY3Rpb24nID8gKGQsIGkpID0+IG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8oZCwgaSkgOiBvdXQuc3BhcmtMaW5lU3Ryb2tlV2lkdGhfICsgJ3B4J1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgbGluZUdlbmVyYXRvcilcclxuXHJcbiAgICAgICAgbm9kZS5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5kYXRhKHNjYWxlZERhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeCcsIChkKSA9PiBkLnNjYWxlZFhWYWx1ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgKGQpID0+IGQuc2NhbGVkWVZhbHVlKVxyXG4gICAgICAgICAgICAuYXR0cigncicsIG91dC5zcGFya0xpbmVDaXJjbGVSYWRpdXNfKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdyZWQnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gZnVuY3Rpb24gKHJlZ2lvbiwgbWFwKSB7XHJcbiAgICAgICAgY29uc3QgYnVmID0gW11cclxuXHJcbiAgICAgICAgY29uc3QgcmVnaW9uTmFtZSA9IHJlZ2lvbi5wcm9wZXJ0aWVzLm5hXHJcbiAgICAgICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8Yj4ke3JlZ2lvbk5hbWV9PC9iPiR7cmVnaW9uSWQgPyBgICgke3JlZ2lvbklkfSlgIDogJyd9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgYClcclxuXHJcbiAgICAgICAgY29uc3QgY2hhcnRIZWlnaHQgPSBvdXQuc3BhcmtUb29sdGlwQ2hhcnRfLmhlaWdodFxyXG4gICAgICAgIGNvbnN0IGNoYXJ0V2lkdGggPSBvdXQuc3BhcmtUb29sdGlwQ2hhcnRfLndpZHRoXHJcbiAgICAgICAgY29uc3QgbWFyZ2luID0gb3V0LnNwYXJrVG9vbHRpcENoYXJ0Xy5tYXJnaW5cclxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Q29tcG9zaXRpb24ocmVnaW9uLnByb3BlcnRpZXMuaWQpXHJcblxyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIFRvdGFsIFNWRyBzaXplIChpbmNsdWRpbmcgbWFyZ2lucylcclxuICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IGNoYXJ0V2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodFxyXG4gICAgICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IGNoYXJ0SGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b21cclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBkZXRhY2hlZCBkaXZcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlKCdkaXYnKS5hdHRyKCdjbGFzcycsICdlbS10b29sdGlwLWNoYXJ0LWNvbnRhaW5lcicpXHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgU1ZHIHdpdGggZnVsbCBzaXplXHJcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGNvbnRhaW5lci5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtY2hhcnQtc3ZnJykuYXR0cignd2lkdGgnLCB0b3RhbFdpZHRoKS5hdHRyKCdoZWlnaHQnLCB0b3RhbEhlaWdodClcclxuXHJcbiAgICAgICAgICAgIC8vIElubmVyIGdyb3VwIHdoZXJlIGNoYXJ0IGlzIGRyYXduXHJcbiAgICAgICAgICAgIGNvbnN0IGcgPSBzdmcuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwgJHttYXJnaW4udG9wfSlgKVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCBzcGFya2xpbmUgZHJhd2luZyBvbiB0aGUgaW5uZXIgYXJlYSBvbmx5XHJcbiAgICAgICAgICAgIGNyZWF0ZVNwYXJrTGluZUNoYXJ0KGcsIGRhdGEsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCB0cnVlKVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHJlc3VsdCB0byB0b29sdGlwIGJ1ZmZlclxyXG4gICAgICAgICAgICBidWYucHVzaChjb250YWluZXIubm9kZSgpLm91dGVySFRNTClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBnZXREYXRhc2V0TWF4TWluXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gZ2V0cyB0aGUgbWF4aW11bSBhbmQgbWluaW11bSB2YWx1ZXMgb2YgYWxsIGRhdGVzIGZvciBlYWNoIHJlZ2lvbi4gVXNlZCB0byBkZWZpbmUgdGhlIGRvbWFpbiBvZiB0aGUgc3BhcmtsaW5lIFkgYXhpcy5cclxuICAgICAqIEByZXR1cm5zIFttaW4sbWF4XVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXREYXRhc2V0TWF4TWluKCkge1xyXG4gICAgICAgIGNvbnN0IG1heHMgPSBbXVxyXG4gICAgICAgIGNvbnN0IHNlbCA9IG91dC5zdmcoKS5zZWxlY3RBbGwoJyNlbS1wcm9wLXN5bWJvbHMnKS5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKS5kYXRhKClcclxuXHJcbiAgICAgICAgc2VsLmZvckVhY2goKHJnKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gcmcucHJvcGVydGllcy5pZFxyXG4gICAgICAgICAgICBjb25zdCByZWdpb25NYXggPSBnZXRSZWdpb25NYXgoaWQpXHJcbiAgICAgICAgICAgIGlmIChyZWdpb25NYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbWF4cy5wdXNoKHJlZ2lvbk1heClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGlmIChtYXhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWzAsIDFdIC8vIGZhbGxiYWNrIGlmIG5vIGRhdGEgZm91bmRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBleHRlbnQobWF4cylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhYnNvbHV0ZSB0b3RhbCB2YWx1ZSBvZiBjb21iaW5lZCBzdGF0aXN0aWNhbCB2YWx1ZXMgZm9yIGEgc3BlY2lmaWMgcmVnaW9uLiBFLmcgdG90YWwgbGl2ZXN0b2NrXHJcbiAgICAgKiBAcGFyYW0geyp9IGlkIG51dHMgcmVnaW9uIGlkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldFJlZ2lvbk1heCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGxldCBtYXggPSAwXHJcblxyXG4gICAgICAgIC8vIGdldCBzdGF0IHZhbHVlIGZvciBlYWNoIGRhdGUgYW5kIGZpbmQgdGhlIG1heFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Ll9zdGF0RGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG91dC5fc3RhdERhdGVzW2ldXHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXREYXRhID0gb3V0LnN0YXREYXRhKGRhdGUpXHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0YXREYXRhIHx8IHR5cGVvZiBzdGF0RGF0YS5nZXQgIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICBjb25zdCBzID0gc3RhdERhdGEuZ2V0KGlkKVxyXG4gICAgICAgICAgICBpZiAoIXMgfHwgKHMudmFsdWUgIT09IDAgJiYgIXMudmFsdWUpIHx8IGlzTmFOKHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlKCkpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzLnZhbHVlID4gbWF4KSBtYXggPSBzLnZhbHVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWF4ID09PSAwKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgcmV0dXJuIG1heFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9UT0RPIGRlZmluZSBsZWdlbmRcclxuICAgICAgICByZXR1cm4gbGdjaC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbi8vYnVpbGQgYSBjb2xvciBsZWdlbmQgb2JqZWN0XHJcbmV4cG9ydCBjb25zdCBnZXRDb2xvckxlZ2VuZCA9IGZ1bmN0aW9uIChjb2xvckZ1bikge1xyXG4gICAgY29sb3JGdW4gPSBjb2xvckZ1biB8fCBpbnRlcnBvbGF0ZVlsT3JSZFxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBjb2xvckZ1bihlY2wgLyAobnVtYmVyT2ZDbGFzc2VzIC0gMSkpXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBhcmMsIHBpZSB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBzY2hlbWVDYXRlZ29yeTEwIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJ1xyXG4vL3NjaGVtZVNldDMgc2NoZW1lRGFyazIgc2NoZW1lUGFzdGVsMSBzY2hlbWVUYWJsZWF1MTBcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBTdHJpcGVDb21wb3NpdGlvbkxlZ2VuZCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kLXN0cmlwZS1jb21wb3NpdGlvbidcclxuaW1wb3J0IHsgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIGdldFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBzdHJpcGUgY29tcG9zaXRpb24gbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIGZhbHNlLCAnc2NvbXAnKVxyXG5cclxuICAgIC8vd2lkdGggb2YgdGhlIHN0cmlwZXMgc2VyaWVcclxuICAgIG91dC5zdHJpcGVXaWR0aF8gPSA1MFxyXG4gICAgLy9vcmllbnRhdGlvbiAtIHZlcnRpY2FsIGJ5IGRlZmF1bHRcclxuICAgIG91dC5zdHJpcGVPcmllbnRhdGlvbl8gPSAwXHJcblxyXG4gICAgLy9jb2xvcnMgLSBpbmRleGVkIGJ5IGNhdGVnb3J5IGNvZGVcclxuICAgIG91dC5jYXRDb2xvcnNfID0gdW5kZWZpbmVkXHJcbiAgICAvL2xhYmVscyAtIGluZGV4ZWQgYnkgY2F0ZWdvcnkgY29kZVxyXG4gICAgb3V0LmNhdExhYmVsc18gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3Nob3cgc3RyaXBlcyBvbmx5IHdoZW4gZGF0YSBmb3IgYWxsIGNhdGVnb3JpZXMgaXMgY29tcGxldGUuXHJcbiAgICAvL090aGVyd2lzZSwgY29uc2lkZXIgdGhlIHJlZ2lvbnMgYXMgYmVpbmcgd2l0aCBubyBkYXRhIGF0IGFsbC5cclxuICAgIG91dC5zaG93T25seVdoZW5Db21wbGV0ZV8gPSBmYWxzZVxyXG5cclxuICAgIC8vdG9vbHRpcCBwaWUgY2hhcnRcclxuICAgIG91dC5waWVDaGFydFJhZGl1c18gPSA0MFxyXG4gICAgb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXNfID0gMTVcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7W1xyXG4gICAgICAgICdzdHJpcGVXaWR0aF8nLFxyXG4gICAgICAgICdzdHJpcGVPcmllbnRhdGlvbl8nLFxyXG4gICAgICAgICdjYXRDb2xvcnNfJyxcclxuICAgICAgICAnY2F0TGFiZWxzXycsXHJcbiAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwaWVDaGFydFJhZGl1c18nLFxyXG4gICAgICAgICdwaWVDaGFydElubmVyUmFkaXVzXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdzdHJpcGVXaWR0aCcsXHJcbiAgICAgICAgICAgICdzdHJpcGVPcmllbnRhdGlvbicsXHJcbiAgICAgICAgICAgICdjYXRDb2xvcnMnLFxyXG4gICAgICAgICAgICAnY2F0TGFiZWxzJyxcclxuICAgICAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlJyxcclxuICAgICAgICAgICAgJ25vRGF0YUZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdwaWVDaGFydFJhZGl1cycsXHJcbiAgICAgICAgICAgICdwaWVDaGFydElubmVyUmFkaXVzJyxcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0byBkZWZpbmUgYSBzdHJpcGUgbWFwIGVhc2lseSwgd2l0aG91dCByZXBldGl0aW9uIG9mIGluZm9ybWF0aW9uLlxyXG4gICAgICogT25seSBmb3IgZXVyb2Jhc2UgZGF0YSBzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gc3RhdCBBIHBhdHRlcm4gZm9yIHRoZSBzdGF0IGRhdGEgc291cmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGltIFRoZSBkaW1lbnNpb24gb2YgdGhlIGNvbXBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29kZXMgVGhlIGNhdGVnb3J5IGNvZGVzIG9mIHRoZSBjb21wb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxzIE9wdGlvbmFsOiBUaGUgbGFiZWxzIGZvciB0aGUgY2F0ZWdvcnkgY29kZXNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBPcHRpb25hbDogVGhlIGNvbG9ycyBmb3IgdGhlIGNhdGVnb3J5XHJcbiAgICAgKi9cclxuICAgIG91dC5zdGF0Q29tcCA9IGZ1bmN0aW9uIChzdGF0LCBkaW0sIGNvZGVzLCBsYWJlbHMsIGNvbG9ycykge1xyXG4gICAgICAgIC8vYWRkIG9uZSBkYXRhc2V0IGNvbmZpZyBmb3IgZWFjaCBjYXRlZ29yeVxyXG4gICAgICAgIHN0YXQuZmlsdGVycyA9IHN0YXQuZmlsdGVycyB8fCB7fVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9jYXRlZ29yeSBjb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBjb2Rlc1tpXVxyXG4gICAgICAgICAgICBzdGF0LmZpbHRlcnNbZGltXSA9IGNvZGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIHNjXy5maWx0ZXJzID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQuZmlsdGVycykgc2NfLmZpbHRlcnNba2V5XSA9IHN0YXQuZmlsdGVyc1trZXldXHJcbiAgICAgICAgICAgIG91dC5zdGF0KGNvZGUsIHNjXylcclxuXHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGNvbG9yXHJcbiAgICAgICAgICAgIGlmIChjb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRDb2xvcnNfID0gb3V0LmNhdENvbG9yc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRDb2xvcnNfW2NvZGVdID0gY29sb3JzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiBzcGVjaWZpZWQsIHJldHJpZXZlIGFuZCBhc3NpZ24gbGFiZWxcclxuICAgICAgICAgICAgaWYgKGxhYmVscykge1xyXG4gICAgICAgICAgICAgICAgb3V0LmNhdExhYmVsc18gPSBvdXQuY2F0TGFiZWxzXyB8fCB7fVxyXG4gICAgICAgICAgICAgICAgb3V0LmNhdExhYmVsc19bY29kZV0gPSBsYWJlbHNbaV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgc3RhdENvZGVzXHJcbiAgICAgICAgc3RhdENvZGVzID0gY29kZXNcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgY29kZXMgb2YgdGhlIGNhdGVnb3JpZXMgdG8gY29uc2lkZXIgZm9yIHRoZSBjb21wb3NpdGlvbi4gKi9cclxuICAgIGxldCBzdGF0Q29kZXMgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNvbXB1dGUgY29tcG9zaXRpb24gZm9yIHJlZ2lvbiBpZCwgZm9yIGVhY2ggY2F0ZWdvcnkuXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGgsIGZvciBlYWNoIGNhdGVnb3J5LCB0aGUgc2hhcmUgWzAsMV0gb2YgdGhlIGNhdGVnb3J5LlxyXG4gICAgICogQHBhcmFtIHsqfSBpZFxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGxldCBjb21wID0ge30sXHJcbiAgICAgICAgICAgIHN1bSA9IDBcclxuICAgICAgICAvL2dldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5LiBDb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0Q29kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9yZXRyaWV2ZSBjb2RlIGFuZCBzdGF0IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IHNjID0gc3RhdENvZGVzW2ldXHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBvdXQuc3RhdERhdGEoc2MpLmdldChpZClcclxuXHJcbiAgICAgICAgICAgIC8vY2FzZSB3aGVuIHNvbWUgZGF0YSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbXBbc2NdID0gcy52YWx1ZVxyXG4gICAgICAgICAgICBzdW0gKz0gcy52YWx1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jYXNlIHdoZW4gbm8gZGF0YVxyXG4gICAgICAgIGlmIChzdW0gPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL2NvbXB1dGUgcmF0aW9zXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0Q29kZXMubGVuZ3RoOyBpKyspIGNvbXBbc3RhdENvZGVzW2ldXSAvPSBzdW1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm90IHByb3ZpZGVkLCBnZXQgbGlzdCBvZiBzdGF0IGNvZGVzIGZyb20gdGhlIG1hcCBzdGF0IGRhdGFcclxuICAgICAgICBpZiAoIXN0YXRDb2Rlcykge1xyXG4gICAgICAgICAgICAvL2dldCBsaXN0IG9mIHN0YXQgY29kZXMuXHJcbiAgICAgICAgICAgIHN0YXRDb2RlcyA9IE9iamVjdC5rZXlzKG91dC5zdGF0RGF0YV8pXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIFwiZGVmYXVsdFwiLCBpZiBwcmVzZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3RhdENvZGVzLmluZGV4T2YoJ2RlZmF1bHQnKVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkgc3RhdENvZGVzLnNwbGljZShpbmRleCwgMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgYnVpbGQgZGVmYXVsdCBjb2xvciByYW1wXHJcbiAgICAgICAgaWYgKCFvdXQuY2F0Q29sb3JzKCkpIHtcclxuICAgICAgICAgICAgb3V0LmNhdENvbG9ycyh7fSlcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0Q29kZXMubGVuZ3RoOyBpKyspIG91dC5jYXRDb2xvcnMoKVtzdGF0Q29kZXNbaV1dID0gc2NoZW1lQ2F0ZWdvcnkxMFtpICUgMTBdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2lmIG5vdCBzcGVjaWZpZWQsIGluaXRpYWxpc2UgY2F0ZWdvcnkgbGFiZWxzXHJcbiAgICAgICAgb3V0LmNhdExhYmVsc18gPSBvdXQuY2F0TGFiZWxzXyB8fCB7fVxyXG5cclxuICAgICAgICAvL2J1aWxkIGFuZCBhc3NpZ24gdGV4dHVyZSB0byB0aGUgcmVnaW9uc1xyXG4gICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihvdXQpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VtLWNudHJnJykpIHJldHVybiAvLyBTa2lwIGNvdW50cnkgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBkLnByb3BlcnRpZXMuaWRcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY29tcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0aW9uID0gZ2V0Q29tcG9zaXRpb24oaWQpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gb3IgbWlzc2luZyBkYXRhXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvc2l0aW9uKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFrZSBzdHJpcGUgcGF0dGVyblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dCA9IG91dFxyXG4gICAgICAgICAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdHRlcm4nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdwYXR0ZXJuXycgKyBpZClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICcwJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICcwJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc3RyaXBlV2lkdGgoKSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncGF0dGVyblVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcclxuICAgICAgICAgICAgICAgIC8vdXNlIG9yaWVudGF0aW9uLCBpZiBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc3RyaXBlT3JpZW50YXRpb24oKSkgcGF0dC5hdHRyKCdwYXR0ZXJuVHJhbnNmb3JtJywgJ3JvdGF0ZSgnICsgb3V0LnN0cmlwZU9yaWVudGF0aW9uKCkgKyAnKScpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgICAgICBwYXR0LmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc3RyaXBlV2lkdGgoKSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbGlnaHRncmF5JylcclxuXHJcbiAgICAgICAgICAgICAgICAvL21ha2Ugc3RyaXBlcywgb25lIHBlciBjYXRlZ29yeVxyXG4gICAgICAgICAgICAgICAgbGV0IHggPSAwXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlIGluIGNvbXBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgc3RyaXBlIHNpemVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZHggPSBjb21wb3NpdGlvbltjb2RlXVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZHgpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgZHggKj0gb3V0LnN0cmlwZVdpZHRoKClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgc3RyaXBlIGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gb3V0LmNhdENvbG9ycygpW2NvZGVdIHx8ICdsaWdodGdyYXknXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIHN0cmlwZSB0byBwYXR0ZXJuOiBhIHRoaW4gcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY29kZScsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNvbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90cmFuc2l0aW9uIGFsb25nIHhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBkeClcclxuICAgICAgICAgICAgICAgICAgICB4ICs9IGR4XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gcGF0dGVybiByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAndXJsKCNwYXR0ZXJuXycgKyBpZCArICcpJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignbmQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFnZXRDb21wb3NpdGlvbihkLnByb3BlcnRpZXMuaWQpID8gJ25kJyA6ICcnXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIHNldCByZWdpb24gaG92ZXIgZnVuY3Rpb25cclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihvdXQpXHJcbiAgICAgICAgbGV0IHJlZ2lvbnMgPSBvdXQuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRGaWxsID0gc2VsLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0ZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBTdHJpcGVDb21wb3NpdGlvbkxlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZywgbWFwKSB7XHJcbiAgICAgICAgLy9nZXQgdG9vbHRpcFxyXG4gICAgICAgIGNvbnN0IHRwID0gc2VsZWN0KCcjdG9vbHRpcF9ldXJvc3RhdCcpXHJcblxyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0cC5odG1sKCcnKVxyXG4gICAgICAgIHRwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vd3JpdGUgcmVnaW9uIG5hbWVcclxuICAgICAgICBjb25zdCByZWdpb25OYW1lID0gcmcucHJvcGVydGllcy5uYSB8fCByZy5wcm9wZXJ0aWVzLm5hbWVcclxuICAgICAgICBpZiAocmcucHJvcGVydGllcy5pZCkge1xyXG4gICAgICAgICAgICAvL25hbWUgYW5kIGNvZGVcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKS5odG1sKCc8Yj4nICsgcmVnaW9uTmFtZSArICc8L2I+ICgnICsgcmcucHJvcGVydGllcy5pZCArICcpIDxicj4nKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vcmVnaW9uIG5hbWVcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKS5odG1sKCc8Yj4nICsgcmVnaW9uTmFtZSArICc8L2I+PGJyPicpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3ByZXBhcmUgZGF0YSBmb3IgcGllIGNoYXJ0XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdXHJcbiAgICAgICAgY29uc3QgY29tcCA9IGdldENvbXBvc2l0aW9uKHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcCkgZGF0YS5wdXNoKHsgY29kZToga2V5LCB2YWx1ZTogY29tcFtrZXldIH0pXHJcblxyXG4gICAgICAgIC8vY2FzZSBvZiByZWdpb25zIHdpdGggbm8gZGF0YVxyXG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRwLmFwcGVuZCgnZGl2JykuaHRtbChvdXQubm9EYXRhVGV4dCgpKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIHN2ZyBmb3IgcGllIGNoYXJ0XHJcbiAgICAgICAgY29uc3QgciA9IG91dC5waWVDaGFydFJhZGl1cygpLFxyXG4gICAgICAgICAgICBpciA9IG91dC5waWVDaGFydElubmVyUmFkaXVzKClcclxuICAgICAgICBjb25zdCBzdmcgPSB0cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlld0JveCcsIFstciwgLXIsIDIgKiByLCAyICogcl0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDIgKiByKVxyXG5cclxuICAgICAgICAvL21ha2UgcGllIGNoYXJ0LiBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9waWUtY2hhcnRcclxuICAgICAgICBjb25zdCBwaWVfID0gcGllKClcclxuICAgICAgICAgICAgLnNvcnQobnVsbClcclxuICAgICAgICAgICAgLnZhbHVlKChkKSA9PiBkLnZhbHVlKVxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2RhcmtncmF5JylcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXRhKHBpZV8oZGF0YSkpXHJcbiAgICAgICAgICAgIC5qb2luKCdwYXRoJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2F0Q29sb3JzKClbZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgYXJjKCkuaW5uZXJSYWRpdXMoaXIpLm91dGVyUmFkaXVzKHIpKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcblxyXG4vKipcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBjb25zdCB0b29sdGlwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9XHJcbiAgICBjb25maWcuY29udGFpbmVySWQgPSBjb25maWcuY29udGFpbmVySWQgfHwgJ21hcCdcclxuICAgIGNvbmZpZy5kaXYgPSBjb25maWcuZGl2IHx8ICd0b29sdGlwX2V1cm9zdGF0J1xyXG4gICAgY29uZmlnLm1heFdpZHRoID0gY29uZmlnLm1heFdpZHRoIHx8ICcyMDBweCdcclxuICAgIGNvbmZpZy5mb250U2l6ZSA9IGNvbmZpZy5mb250U2l6ZSB8fCAnMTRweCdcclxuICAgIGNvbmZpZy5iYWNrZ3JvdW5kID0gY29uZmlnLmJhY2tncm91bmQgfHwgJ3doaXRlJ1xyXG4gICAgY29uZmlnLnBhZGRpbmcgPSBjb25maWcucGFkZGluZyB8fCAnMHB4J1xyXG4gICAgY29uZmlnLmJvcmRlciA9IGNvbmZpZy5ib3JkZXIgfHwgJzBweCdcclxuICAgIGNvbmZpZy5ib3JkZXJSYWRpdXMgPSBjb25maWcuYm9yZGVyUmFkaXVzIHx8ICcwcHgnXHJcbiAgICBjb25maWcuYm94U2hhZG93ID0gY29uZmlnLmJveFNoYWRvdyB8fCAnMHB4IDBweCAwcHggZ3JleSdcclxuICAgIGNvbmZpZy50cmFuc2l0aW9uRHVyYXRpb24gPSBjb25maWcudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDBcclxuICAgIGNvbmZpZy54T2Zmc2V0ID0gY29uZmlnLnhPZmZzZXQgfHwgMzBcclxuICAgIGNvbmZpZy55T2Zmc2V0ID0gY29uZmlnLnlPZmZzZXQgfHwgMjBcclxuXHJcbiAgICBsZXQgdG9vbHRpcFxyXG5cclxuICAgIGZ1bmN0aW9uIG15KCkge1xyXG4gICAgICAgIHRvb2x0aXAgPSBzZWxlY3QoJyMnICsgY29uZmlnLmRpdilcclxuICAgICAgICBpZiAodG9vbHRpcC5lbXB0eSgpKSB0b29sdGlwID0gc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKS5hdHRyKCdpZCcsIGNvbmZpZy5kaXYpXHJcblxyXG4gICAgICAgIHRvb2x0aXAuYXR0cignY2xhc3MnLCAndG9vbHRpcC1ldXJvc3RhdCcpXHJcbiAgICB9XHJcblxyXG4gICAgbXkubW91c2VvdmVyID0gZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgICB0b29sdGlwLmh0bWwoaHRtbClcclxuICAgICAgICBpZiAoaHRtbCkge1xyXG4gICAgICAgICAgICBsZXQgeCA9IGV2ZW50LnBhZ2VYXHJcbiAgICAgICAgICAgIGxldCB5ID0gZXZlbnQucGFnZVlcclxuICAgICAgICAgICAgbXkuZW5zdXJlVG9vbHRpcE9uU2NyZWVuKHgsIHkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG15Lm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGxldCB4ID0gZXZlbnQucGFnZVhcclxuICAgICAgICBsZXQgeSA9IGV2ZW50LnBhZ2VZXHJcbiAgICAgICAgdGhpcy5lbnN1cmVUb29sdGlwT25TY3JlZW4oeCwgeSlcclxuICAgIH1cclxuXHJcbiAgICBteS5tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0b29sdGlwLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgIH1cclxuXHJcbiAgICBteS5zdHlsZSA9IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRvb2x0aXAuc3R5bGUoaylcclxuICAgICAgICB0b29sdGlwLnN0eWxlKGssIHYpXHJcbiAgICAgICAgcmV0dXJuIG15XHJcbiAgICB9XHJcblxyXG4gICAgbXkuYXR0ciA9IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRvb2x0aXAuYXR0cihrKVxyXG4gICAgICAgIHRvb2x0aXAuYXR0cihrLCB2KVxyXG4gICAgICAgIHJldHVybiBteVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGVuc3VyZVRvb2x0aXBPblNjcmVlblxyXG4gICAgICogQGRlc2NyaXB0aW9uIFByZXZlbnRzIHRoZSB0b29sdGlwIGZyb20gb3ZlcmZsb3dpbmcgb2ZmIHNjcmVlblxyXG4gICAgICovXHJcbiAgICBteS5lbnN1cmVUb29sdGlwT25TY3JlZW4gPSBmdW5jdGlvbiAoZXZlbnRYLCBldmVudFkpIHtcclxuICAgICAgICB0b29sdGlwLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICBsZXQgbm9kZSA9IHRvb2x0aXAubm9kZSgpXHJcblxyXG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGV2ZW50WCArIGNvbmZpZy54T2Zmc2V0ICsgJ3B4J1xyXG4gICAgICAgIG5vZGUuc3R5bGUudG9wID0gZXZlbnRZIC0gY29uZmlnLnlPZmZzZXQgKyAncHgnXHJcblxyXG4gICAgICAgIGxldCBwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25maWcuY29udGFpbmVySWQpXHJcbiAgICAgICAgbGV0IHJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgLy8gZ2V0IHRoZSBib3VuZGluZyByZWN0YW5nbGVcclxuICAgICAgICBsZXQgcGFyZW50V2lkdGggPSByZWN0LndpZHRoXHJcbiAgICAgICAgbGV0IHBhcmVudEhlaWdodCA9IHJlY3QuaGVpZ2h0XHJcblxyXG4gICAgICAgIC8vdG9vIGZhciByaWdodFxyXG4gICAgICAgIC8vdGFraW5nIGludG8gYWNjb3VudCBvZmYgc2NyZWVuIHNwYWNlIGJ1dCBzaG91bGRudCBiZVxyXG4gICAgICAgIGlmIChub2RlLm9mZnNldExlZnQgPiByZWN0LmxlZnQgKyBwYXJlbnRXaWR0aCAtIG5vZGUuY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgbGV0IGxlZnQgPSBldmVudFggLSBub2RlLmNsaWVudFdpZHRoIC0gY29uZmlnLnhPZmZzZXRcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCdcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbW91c2UgY292ZXJzIHRvb2x0aXBcclxuICAgICAgICAgICAgaWYgKG5vZGUub2Zmc2V0TGVmdCArIG5vZGUuY2xpZW50V2lkdGggPiBldmVudFgpIHtcclxuICAgICAgICAgICAgICAgIC8vbW92ZSB0b29sdGlwIGxlZnQgc28gaXQgZG9lc250IGNvdmVyIG1vdXNlXHJcbiAgICAgICAgICAgICAgICBsZXQgbGVmdDIgPSBldmVudFggLSBub2RlLmNsaWVudFdpZHRoIC0gY29uZmlnLnhPZmZzZXRcclxuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQyICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUudG9wID0gbm9kZS5vZmZzZXRUb3AgKyBjb25maWcueU9mZnNldCArIFwicHhcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdG9vIGZhciBkb3duXHJcbiAgICAgICAgaWYgKG5vZGUub2Zmc2V0VG9wICsgbm9kZS5jbGllbnRIZWlnaHQgPiByZWN0LnRvcCArIHBhcmVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBub2RlLnN0eWxlLnRvcCA9IG5vZGUub2Zmc2V0VG9wIC0gbm9kZS5jbGllbnRIZWlnaHQgKyAncHgnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG15KClcclxuICAgIHJldHVybiBteVxyXG59XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsImltcG9ydCAnLi9jc3MvaW5kZXguY3NzJ1xyXG5leHBvcnQgKiBmcm9tICcuL2V1cm9zdGF0LW1hcCdcclxuLy9leHBvcnQgeyBzdGF0RGF0YSB9IGZyb20gXCIuL2NvcmUvc3RhdC1kYXRhLmpzXCI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==