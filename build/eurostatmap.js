(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["eurostatmap"] = factory();
	else
		root["eurostatmap"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* STYLING OF NUTS REGIONS AND BOUNDARIES */
/* Default region fill */
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    fill: #e1e1e1;
}

.em-nutsrg,
.em-cntrg,
.em-grid-cell,
#em-user-regions {
    cursor: pointer;
}

/*  boundaries stroke-width */
.em-bn-0 {
    stroke: none;
}
.em-bn-1,
.em-bn-2,
.em-bn-3,
/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-bn-co {
    stroke-width: 0.2;
}

/* all boudnaries and regions linecap/linejoin */
#em-nutsbn,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-co,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* national boundaries */
.em-cntbn {
    stroke: #000;
    stroke-width: 0.6px;
}

/* NUTS boundaries stroke color */
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'] {
    stroke: #696969;
}

/* coastal boundaries */
.em-bn-co {
    stroke: white;
}

/* kosovo */
.em-kosovo-bn {
    stroke: #000;
    stroke-width: 0.15;
}



/* dont fill certain elements */
.em-frame,
.em-graticule,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-co {
    fill: none;
}

/* target non cc/eu/efta borders */
/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {
    stroke-width: 0;
} */
`, "",{"version":3,"sources":["webpack://./src/css/NUTS.css"],"names":[],"mappings":"AAAA,2CAA2C;AAC3C,wBAAwB;AACxB;;;IAGI,aAAa;AACjB;;AAEA;;;;IAII,eAAe;AACnB;;AAEA,6BAA6B;AAC7B;IACI,YAAY;AAChB;AACA;;;;;;;;IAQI,iBAAiB;AACrB;;AAEA,gDAAgD;AAChD;;;;;;;;;;;;;;IAcI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA,wBAAwB;AACxB;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA,iCAAiC;AACjC;;;;;;IAMI,eAAe;AACnB;;AAEA,uBAAuB;AACvB;IACI,aAAa;AACjB;;AAEA,WAAW;AACX;IACI,YAAY;IACZ,kBAAkB;AACtB;;;;AAIA,+BAA+B;AAC/B;;;;;;;;;IASI,UAAU;AACd;;AAEA,kCAAkC;AAClC;;GAEG","sourcesContent":["/* STYLING OF NUTS REGIONS AND BOUNDARIES */\r\n/* Default region fill */\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    fill: #e1e1e1;\r\n}\r\n\r\n.em-nutsrg,\r\n.em-cntrg,\r\n.em-grid-cell,\r\n#em-user-regions {\r\n    cursor: pointer;\r\n}\r\n\r\n/*  boundaries stroke-width */\r\n.em-bn-0 {\r\n    stroke: none;\r\n}\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-bn-co {\r\n    stroke-width: 0.2;\r\n}\r\n\r\n/* all boudnaries and regions linecap/linejoin */\r\n#em-nutsbn,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-co,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n/* national boundaries */\r\n.em-cntbn {\r\n    stroke: #000;\r\n    stroke-width: 0.6px;\r\n}\r\n\r\n/* NUTS boundaries stroke color */\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'] {\r\n    stroke: #696969;\r\n}\r\n\r\n/* coastal boundaries */\r\n.em-bn-co {\r\n    stroke: white;\r\n}\r\n\r\n/* kosovo */\r\n.em-kosovo-bn {\r\n    stroke: #000;\r\n    stroke-width: 0.15;\r\n}\r\n\r\n\r\n\r\n/* dont fill certain elements */\r\n.em-frame,\r\n.em-graticule,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-co {\r\n    fill: none;\r\n}\r\n\r\n/* target non cc/eu/efta borders */\r\n/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {\r\n    stroke-width: 0;\r\n} */\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-annotation-group {
    /* pointer-events: none; */
}
`, "",{"version":3,"sources":["webpack://./src/css/annotations.css"],"names":[],"mappings":"AAAA;IACI,0BAA0B;AAC9B","sourcesContent":[".em-annotation-group {\r\n    /* pointer-events: none; */\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/index.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./map.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./tooltip.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./legend.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./labels.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./annotations.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./NUTS.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./world.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css");
// Imports









var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `
`, "",{"version":3,"sources":[],"names":[],"mappings":"","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/labels.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#em-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}

.em-label {
    font-size: 12px;
}
.em-label-background {
    fill: #ffffff;
    pointer-events: none;
}
.em-label-shadow {
    font-size: 12px;
    stroke-width: 2px;
    stroke: white;
}
.em-stat-label {
    opacity: 1;
    font-size: 13px;
    stroke-width: 3px;
    fill: #313131;
    font-weight: bold;
}
.em-stat-label-shadow {
    opacity: 1;
    font-size: 13px;
    stroke-width: 4px;
    stroke: white;
}
.em-label-cc {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-cc {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-countries {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-countries {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-seas {
    font-size: 9px;
    fill: #003399;
    stroke: #003399;
    stroke-width: 0.2px;
    letter-spacing: 3px;
}
.em-label-shadow-seas {
    font-size: 9px;
    letter-spacing: 3px;
    stroke: white;
    stroke-width: 3px;
}

.em-flow-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}
.em-flow-label {
    font-size: 13px;
    fill: black;
    font-weight: bold;
}
.em-flow-label-shadow {
    font-size: 13px;
    stroke-width: 4px;
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/labels.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;;AAEA;IACI,eAAe;AACnB;AACA;IACI,aAAa;IACb,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB;AACA;IACI,UAAU;IACV,eAAe;IACf,iBAAiB;IACjB,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,UAAU;IACV,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,cAAc;IACd,aAAa;IACb,eAAe;IACf,mBAAmB;IACnB,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;IACnB,aAAa;IACb,iBAAiB;AACrB;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;AACA;IACI,eAAe;IACf,WAAW;IACX,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB","sourcesContent":["#em-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n\r\n.em-label {\r\n    font-size: 12px;\r\n}\r\n.em-label-background {\r\n    fill: #ffffff;\r\n    pointer-events: none;\r\n}\r\n.em-label-shadow {\r\n    font-size: 12px;\r\n    stroke-width: 2px;\r\n    stroke: white;\r\n}\r\n.em-stat-label {\r\n    opacity: 1;\r\n    font-size: 13px;\r\n    stroke-width: 3px;\r\n    fill: #313131;\r\n    font-weight: bold;\r\n}\r\n.em-stat-label-shadow {\r\n    opacity: 1;\r\n    font-size: 13px;\r\n    stroke-width: 4px;\r\n    stroke: white;\r\n}\r\n.em-label-cc {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-cc {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-countries {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-countries {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-seas {\r\n    font-size: 9px;\r\n    fill: #003399;\r\n    stroke: #003399;\r\n    stroke-width: 0.2px;\r\n    letter-spacing: 3px;\r\n}\r\n.em-label-shadow-seas {\r\n    font-size: 9px;\r\n    letter-spacing: 3px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n\r\n.em-flow-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n.em-flow-label {\r\n    font-size: 13px;\r\n    fill: black;\r\n    font-weight: bold;\r\n}\r\n.em-flow-label-shadow {\r\n    font-size: 13px;\r\n    stroke-width: 4px;\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/legend.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-legend-background {
    fill: white;
    opacity: 0.7;
    rx: 0;
    ry: 0;
    pointer-events: none;
}
.em-legend-label {
    font-size: 15px;
    stroke: none;
    fill: black;
    dominant-baseline: unset;
}
.em-legend-title {
    font-size: 16px;
    fill: black;
}
.em-legend-separator {
    stroke: white;
    stroke-width: 1;
}
.em-legend-tick {
    stroke: #d8d8d8;
    stroke-width: 1;
}
.em-bivariate-frame {
    fill: none;
    stroke: black;
}
.em-bivariate-nodata {
    stroke: black;
    stroke-width: 0.5;
    cursor: pointer;
}
.em-bivariate-axis-title {
    font-size: 15px;
}
.em-bivariate-nodata-label {
    font-size: 14px;
    dominant-baseline: middle;
}
.em-bivariate-tick {
    stroke: black;
    stroke-width: 1;
}
.em-bivariate-tick-label {
    text-anchor: middle;
    font-size: 12px;
}
.em-bivariate-square,
.em-legend-rect {
    cursor: pointer;
    stroke: white;
}

.em-bivariate-square:hover,
.em-legend-rect:hover {
    stroke-width: 2;
    stroke: red;
}

.em-pie-size-legend-line {
    stroke-dasharray: 2;
    stroke: grey;
}

.em-legend-diverging-line {
    stroke: black;
}

.em-legend-histogram-bar {
    cursor: pointer;
}
`, "",{"version":3,"sources":["webpack://./src/css/legend.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,YAAY;IACZ,KAAK;IACL,KAAK;IACL,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,YAAY;IACZ,WAAW;IACX,wBAAwB;AAC5B;AACA;IACI,eAAe;IACf,WAAW;AACf;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,eAAe;IACf,eAAe;AACnB;AACA;IACI,UAAU;IACV,aAAa;AACjB;AACA;IACI,aAAa;IACb,iBAAiB;IACjB,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,yBAAyB;AAC7B;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,eAAe;AACnB;AACA;;IAEI,eAAe;IACf,aAAa;AACjB;;AAEA;;IAEI,eAAe;IACf,WAAW;AACf;;AAEA;IACI,mBAAmB;IACnB,YAAY;AAChB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,eAAe;AACnB","sourcesContent":[".em-legend-background {\r\n    fill: white;\r\n    opacity: 0.7;\r\n    rx: 0;\r\n    ry: 0;\r\n    pointer-events: none;\r\n}\r\n.em-legend-label {\r\n    font-size: 15px;\r\n    stroke: none;\r\n    fill: black;\r\n    dominant-baseline: unset;\r\n}\r\n.em-legend-title {\r\n    font-size: 16px;\r\n    fill: black;\r\n}\r\n.em-legend-separator {\r\n    stroke: white;\r\n    stroke-width: 1;\r\n}\r\n.em-legend-tick {\r\n    stroke: #d8d8d8;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-frame {\r\n    fill: none;\r\n    stroke: black;\r\n}\r\n.em-bivariate-nodata {\r\n    stroke: black;\r\n    stroke-width: 0.5;\r\n    cursor: pointer;\r\n}\r\n.em-bivariate-axis-title {\r\n    font-size: 15px;\r\n}\r\n.em-bivariate-nodata-label {\r\n    font-size: 14px;\r\n    dominant-baseline: middle;\r\n}\r\n.em-bivariate-tick {\r\n    stroke: black;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-tick-label {\r\n    text-anchor: middle;\r\n    font-size: 12px;\r\n}\r\n.em-bivariate-square,\r\n.em-legend-rect {\r\n    cursor: pointer;\r\n    stroke: white;\r\n}\r\n\r\n.em-bivariate-square:hover,\r\n.em-legend-rect:hover {\r\n    stroke-width: 2;\r\n    stroke: red;\r\n}\r\n\r\n.em-pie-size-legend-line {\r\n    stroke-dasharray: 2;\r\n    stroke: grey;\r\n}\r\n\r\n.em-legend-diverging-line {\r\n    stroke: black;\r\n}\r\n\r\n.em-legend-histogram-bar {\r\n    cursor: pointer;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/map.css ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* General text settings */
text {
    pointer-events: none;
}

a text {
    pointer-events: all;
}

/* Main map */
.em-map,
.em-legend {
    font-family: Arial, Helvetica, sans-serif;
}

/* Coastal margin */
#em-coast-margin {
    filter: url(#em-coastal-blur);
    stroke-linejoin: round;
    stroke-linecap: round;
    fill: none;
    stroke-width: 5;
    stroke: rgb(161, 198, 237);
}

/* Title and subtitle styling */
.em-title,
.em-inset-title {
    fill: black;
    stroke: none;
}

.em-title {
    font-size: 21px;
    font-weight: bold;
}

.em-inset-title {
    font-size: 12px;
}

.em-subtitle,
.em-inset-subtitle {
    fill: #848280;
    stroke: none;
    stroke-linejoin: round;
    paint-order: stroke;
}

.em-subtitle {
    font-size: 18px;
    font-weight: 100;
}

.em-inset-subtitle {
    font-size: 12px;
}

.em-source-pretext {
    font-size: 11px;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link {
    font-size: 11px;
    fill: #0e47cb;
    cursor: pointer;
    text-decoration: underline;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link:hover {
    fill: #082b7a;
    cursor: pointer;
    text-decoration: underline;
}

.em-frame {
    stroke-width: 0;
    stroke: grey;
}

.em-insets .em-frame {
    /* this will give a frame to inset maps */
    stroke: grey;
    stroke-width: 0.3px !important;
}

.em-sea {
    fill: white;
    /* pointer-events: none; */
}
.em-scalebar-line {
    stroke: black;
    stroke-width: 0.8px;
}
.em-scalebar-label {
    font-size: 9px;
    text-anchor: middle;
}

/* Bottom text and symbol styling */
.em-footnote {
    pointer-events: all;
    cursor: default;
    font-size: 11px;
    transform: translate(5px, -5px);
}
.em-footnote a {
    fill: #0e47cb;
    text-decoration: underline;
}
.em-footnote a:hover {
    fill: #0a328e;
}

.em-centroid {
    cursor: pointer;
}

/* Graticule styling */
.em-graticule {
    stroke: lightgray;
    stroke-width: 1;
}

.em-flow-link {
    cursor: pointer;
}
.em-flow-link-outline {
    cursor: pointer;
}
.em-flow-labels {
    font-size: 15px;
    stroke-width: 1px;
    fill: black;
    pointer-events: none;
}
.em-flow-labels-halo {
    font-size: 15px;
    stroke-width: 2px;
    fill: white;
    pointer-events: none;
}

.em-grid-rect,
.em-grid-hexagon {
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/map.css"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B;IACI,oBAAoB;AACxB;;AAEA;IACI,mBAAmB;AACvB;;AAEA,aAAa;AACb;;IAEI,yCAAyC;AAC7C;;AAEA,mBAAmB;AACnB;IACI,6BAA6B;IAC7B,sBAAsB;IACtB,qBAAqB;IACrB,UAAU;IACV,eAAe;IACf,0BAA0B;AAC9B;;AAEA,+BAA+B;AAC/B;;IAEI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,iBAAiB;AACrB;;AAEA;IACI,eAAe;AACnB;;AAEA;;IAEI,aAAa;IACb,YAAY;IACZ,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,eAAe;IACf,gBAAgB;AACpB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,gCAAgC;AACpC;AACA;IACI,eAAe;IACf,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,gCAAgC;AACpC;AACA;IACI,aAAa;IACb,eAAe;IACf,0BAA0B;AAC9B;;AAEA;IACI,eAAe;IACf,YAAY;AAChB;;AAEA;IACI,yCAAyC;IACzC,YAAY;IACZ,8BAA8B;AAClC;;AAEA;IACI,WAAW;IACX,0BAA0B;AAC9B;AACA;IACI,aAAa;IACb,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;AACvB;;AAEA,mCAAmC;AACnC;IACI,mBAAmB;IACnB,eAAe;IACf,eAAe;IACf,+BAA+B;AACnC;AACA;IACI,aAAa;IACb,0BAA0B;AAC9B;AACA;IACI,aAAa;AACjB;;AAEA;IACI,eAAe;AACnB;;AAEA,sBAAsB;AACtB;IACI,iBAAiB;IACjB,eAAe;AACnB;;AAEA;IACI,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;;AAEA;;IAEI,aAAa;AACjB","sourcesContent":["/* General text settings */\r\ntext {\r\n    pointer-events: none;\r\n}\r\n\r\na text {\r\n    pointer-events: all;\r\n}\r\n\r\n/* Main map */\r\n.em-map,\r\n.em-legend {\r\n    font-family: Arial, Helvetica, sans-serif;\r\n}\r\n\r\n/* Coastal margin */\r\n#em-coast-margin {\r\n    filter: url(#em-coastal-blur);\r\n    stroke-linejoin: round;\r\n    stroke-linecap: round;\r\n    fill: none;\r\n    stroke-width: 5;\r\n    stroke: rgb(161, 198, 237);\r\n}\r\n\r\n/* Title and subtitle styling */\r\n.em-title,\r\n.em-inset-title {\r\n    fill: black;\r\n    stroke: none;\r\n}\r\n\r\n.em-title {\r\n    font-size: 21px;\r\n    font-weight: bold;\r\n}\r\n\r\n.em-inset-title {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-subtitle,\r\n.em-inset-subtitle {\r\n    fill: #848280;\r\n    stroke: none;\r\n    stroke-linejoin: round;\r\n    paint-order: stroke;\r\n}\r\n\r\n.em-subtitle {\r\n    font-size: 18px;\r\n    font-weight: 100;\r\n}\r\n\r\n.em-inset-subtitle {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-source-pretext {\r\n    font-size: 11px;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link {\r\n    font-size: 11px;\r\n    fill: #0e47cb;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link:hover {\r\n    fill: #082b7a;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n}\r\n\r\n.em-frame {\r\n    stroke-width: 0;\r\n    stroke: grey;\r\n}\r\n\r\n.em-insets .em-frame {\r\n    /* this will give a frame to inset maps */\r\n    stroke: grey;\r\n    stroke-width: 0.3px !important;\r\n}\r\n\r\n.em-sea {\r\n    fill: white;\r\n    /* pointer-events: none; */\r\n}\r\n.em-scalebar-line {\r\n    stroke: black;\r\n    stroke-width: 0.8px;\r\n}\r\n.em-scalebar-label {\r\n    font-size: 9px;\r\n    text-anchor: middle;\r\n}\r\n\r\n/* Bottom text and symbol styling */\r\n.em-footnote {\r\n    pointer-events: all;\r\n    cursor: default;\r\n    font-size: 11px;\r\n    transform: translate(5px, -5px);\r\n}\r\n.em-footnote a {\r\n    fill: #0e47cb;\r\n    text-decoration: underline;\r\n}\r\n.em-footnote a:hover {\r\n    fill: #0a328e;\r\n}\r\n\r\n.em-centroid {\r\n    cursor: pointer;\r\n}\r\n\r\n/* Graticule styling */\r\n.em-graticule {\r\n    stroke: lightgray;\r\n    stroke-width: 1;\r\n}\r\n\r\n.em-flow-link {\r\n    cursor: pointer;\r\n}\r\n.em-flow-link-outline {\r\n    cursor: pointer;\r\n}\r\n.em-flow-labels {\r\n    font-size: 15px;\r\n    stroke-width: 1px;\r\n    fill: black;\r\n    pointer-events: none;\r\n}\r\n.em-flow-labels-halo {\r\n    font-size: 15px;\r\n    stroke-width: 2px;\r\n    fill: white;\r\n    pointer-events: none;\r\n}\r\n\r\n.em-grid-rect,\r\n.em-grid-hexagon {\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.estat-vis-tooltip-text {
    background: #ffffff;
    color: #171a22;
    padding: 4px;
    font-size: 16px;
}
.estat-vis-tooltip-bar {
    background: #515560;
    color: #ffffff;
    padding: 6px;
    font-size: 16px;
}
.tooltip-eurostat {
    font-family: Arial;
    max-width: 250px;
    overflow: hidden;
    background: white;
    padding: 0px;
    border: 0px;
    border-radius: 0px;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);
    position: absolute;
    font-family: Helvetica, Arial, sans-serif;
    pointer-events: none;
    opacity: 0;
    z-index: 99999999;
}
.em-tooltip-piechart-breakdown {
    padding: 10px;
    font-size: 14px;
}
.em-tooltip-piechart-container {
    text-align: center;
}
`, "",{"version":3,"sources":["webpack://./src/css/tooltip.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,gBAAgB;IAChB,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,kBAAkB;IAClB,2EAA2E;IAC3E,kBAAkB;IAClB,yCAAyC;IACzC,oBAAoB;IACpB,UAAU;IACV,iBAAiB;AACrB;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,kBAAkB;AACtB","sourcesContent":[".estat-vis-tooltip-text {\r\n    background: #ffffff;\r\n    color: #171a22;\r\n    padding: 4px;\r\n    font-size: 16px;\r\n}\r\n.estat-vis-tooltip-bar {\r\n    background: #515560;\r\n    color: #ffffff;\r\n    padding: 6px;\r\n    font-size: 16px;\r\n}\r\n.tooltip-eurostat {\r\n    font-family: Arial;\r\n    max-width: 250px;\r\n    overflow: hidden;\r\n    background: white;\r\n    padding: 0px;\r\n    border: 0px;\r\n    border-radius: 0px;\r\n    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);\r\n    position: absolute;\r\n    font-family: Helvetica, Arial, sans-serif;\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    z-index: 99999999;\r\n}\r\n.em-tooltip-piechart-breakdown {\r\n    padding: 10px;\r\n    font-size: 14px;\r\n}\r\n.em-tooltip-piechart-container {\r\n    text-align: center;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/world.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#g_worldbn,
.em-worldrg,
.em-worldbn {
    stroke-linecap: round;
    stroke-linejoin: round;
}

.em-worldbn {
    stroke: #000;
    stroke-width: 0.3px;
}

.em-worldbn {
    fill: none;
}

.em-worldrg {
    fill: #efefef;
    cursor: pointer;
}

.em-bn-d {
    /* disputed */
    stroke: #000;
    stroke-width: 0.1;
    fill: none;
}
`, "",{"version":3,"sources":["webpack://./src/css/world.css"],"names":[],"mappings":"AAAA;;;IAGI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA;IACI,UAAU;AACd;;AAEA;IACI,aAAa;IACb,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,iBAAiB;IACjB,UAAU;AACd","sourcesContent":["#g_worldbn,\r\n.em-worldrg,\r\n.em-worldbn {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n.em-worldbn {\r\n    stroke: #000;\r\n    stroke-width: 0.3px;\r\n}\r\n\r\n.em-worldbn {\r\n    fill: none;\r\n}\r\n\r\n.em-worldrg {\r\n    fill: #efefef;\r\n    cursor: pointer;\r\n}\r\n\r\n.em-bn-d {\r\n    /* disputed */\r\n    stroke: #000;\r\n    stroke-width: 0.1;\r\n    fill: none;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bisectCenter: () => (/* binding */ bisectCenter),
/* harmony export */   bisectLeft: () => (/* binding */ bisectLeft),
/* harmony export */   bisectRight: () => (/* binding */ bisectRight),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_number_js__WEBPACK_IMPORTED_MODULE_2__["default"]).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-array/src/descending.js");



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"] || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extent)
/* harmony export */ });
function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}


/***/ }),

/***/ "./node_modules/d3-array/src/fsum.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/fsum.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adder: () => (/* binding */ Adder),
/* harmony export */   fcumsum: () => (/* binding */ fcumsum),
/* harmony export */   fsum: () => (/* binding */ fsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "./node_modules/d3-array/src/greatest.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/greatest.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ greatest)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");


function greatest(values, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, maxValue) > 0
          : (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/maxIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/maxIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxIndex)
/* harmony export */ });
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/minIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/minIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minIndex)
/* harmony export */ });
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number),
/* harmony export */   numbers: () => (/* binding */ numbers)
/* harmony export */ });
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ permute)
/* harmony export */ });
function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   quantileIndex: () => (/* binding */ quantileIndex),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maxIndex.js */ "./node_modules/d3-array/src/maxIndex.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./minIndex.js */ "./node_modules/d3-array/src/minIndex.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "./node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");
/* harmony import */ var _greatest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./greatest.js */ "./node_modules/d3-array/src/greatest.js");









function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantileIndex(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)));
  if (p <= 0) return (0,_minIndex_js__WEBPACK_IMPORTED_MODULE_4__["default"])(numbers);
  if (p >= 1) return (0,_maxIndex_js__WEBPACK_IMPORTED_MODULE_5__["default"])(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  (0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(index, i, 0, j, (i, j) => (0,_sort_js__WEBPACK_IMPORTED_MODULE_6__.ascendingDefined)(numbers[i], numbers[j]));
  i = (0,_greatest_js__WEBPACK_IMPORTED_MODULE_7__["default"])(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/quickselect.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-array/src/quickselect.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? _sort_js__WEBPACK_IMPORTED_MODULE_0__.ascendingDefined : (0,_sort_js__WEBPACK_IMPORTED_MODULE_0__.compareDefined)(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ range)
/* harmony export */ });
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sort.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/sort.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascendingDefined: () => (/* binding */ ascendingDefined),
/* harmony export */   compareDefined: () => (/* binding */ compareDefined),
/* harmony export */   "default": () => (/* binding */ sort)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _permute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./permute.js */ "./node_modules/d3-array/src/permute.js");



function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return (0,_permute_js__WEBPACK_IMPORTED_MODULE_0__["default"])(values, index);
  }
  return values.sort(compareDefined(f));
}

function compareDefined(compare = _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
  if (compare === _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}


/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sum)
/* harmony export */ });
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ticks),
/* harmony export */   tickIncrement: () => (/* binding */ tickIncrement),
/* harmony export */   tickStep: () => (/* binding */ tickStep)
/* harmony export */ });
const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log10(step)),
      error = step / Math.pow(10, power),
      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}

function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
  }
  return ticks;
}

function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}

function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/axis.js":
/*!******************************************!*\
  !*** ./node_modules/d3-axis/src/axis.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   axisBottom: () => (/* binding */ axisBottom),
/* harmony export */   axisLeft: () => (/* binding */ axisLeft),
/* harmony export */   axisRight: () => (/* binding */ axisRight),
/* harmony export */   axisTop: () => (/* binding */ axisTop)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-axis/src/identity.js");


var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + x + ",0)";
}

function translateY(y) {
  return "translate(0," + y + ")";
}

function number(scale) {
  return d => +scale(d);
}

function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return d => +scale(d) + offset;
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + offset,
        range1 = +range[range.length - 1] + offset,
        position = (scale.bandwidth ? center : number)(scale.copy(), offset),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient === right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d) + offset); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = Array.from(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  axis.offset = function(_) {
    return arguments.length ? (offset = +_, axis) : offset;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/identity.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-axis/src/identity.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ brighter),
/* harmony export */   darker: () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hcl: () => (/* binding */ Hcl),
/* harmony export */   Lab: () => (/* binding */ Lab),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   gray: () => (/* binding */ gray),
/* harmony export */   hcl: () => (/* binding */ hcl),
/* harmony export */   lch: () => (/* binding */ lch)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   radians: () => (/* binding */ radians)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csvFormat: () => (/* binding */ csvFormat),
/* harmony export */   csvFormatBody: () => (/* binding */ csvFormatBody),
/* harmony export */   csvFormatRow: () => (/* binding */ csvFormatRow),
/* harmony export */   csvFormatRows: () => (/* binding */ csvFormatRows),
/* harmony export */   csvFormatValue: () => (/* binding */ csvFormatValue),
/* harmony export */   csvParse: () => (/* binding */ csvParse),
/* harmony export */   csvParseRows: () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tsvFormat: () => (/* binding */ tsvFormat),
/* harmony export */   tsvFormatBody: () => (/* binding */ tsvFormatBody),
/* harmony export */   tsvFormatRow: () => (/* binding */ tsvFormatRow),
/* harmony export */   tsvFormatRows: () => (/* binding */ tsvFormatRows),
/* harmony export */   tsvFormatValue: () => (/* binding */ tsvFormatValue),
/* harmony export */   tsvParse: () => (/* binding */ tsvParse),
/* harmony export */   tsvParseRows: () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csv: () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   tsv: () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_3__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-force/src/collide.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/jiggle.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force/src/lcg.js":
/*!******************************************!*\
  !*** ./node_modules/d3-force/src/lcg.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force/src/simulation.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["default"])("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/x.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/y.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatPrefix: () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatDecimalParts: () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   prefixExponent: () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatSpecifier: () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionFixed.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionFixed.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionPrefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionPrefix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionRound.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionRound.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(step)) + 1;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adder: () => (/* binding */ Adder),
/* harmony export */   fcumsum: () => (/* binding */ fcumsum),
/* harmony export */   fsum: () => (/* binding */ fsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cartesian: () => (/* binding */ cartesian),
/* harmony export */   cartesianAddInPlace: () => (/* binding */ cartesianAddInPlace),
/* harmony export */   cartesianCross: () => (/* binding */ cartesianCross),
/* harmony export */   cartesianDot: () => (/* binding */ cartesianDot),
/* harmony export */   cartesianNormalizeInPlace: () => (/* binding */ cartesianNormalizeInPlace),
/* harmony export */   cartesianScale: () => (/* binding */ cartesianScale),
/* harmony export */   spherical: () => (/* binding */ spherical)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circleStream: () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   haversin: () => (/* binding */ haversin),
/* harmony export */   hypot: () => (/* binding */ hypot),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");




function longitude(point) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi)
    return point[0];
  else
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  var sum = new d3_array__WEBPACK_IMPORTED_MODULE_1__.Adder();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) ^ (winding & 1);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fitExtent: () => (/* binding */ fitExtent),
/* harmony export */   fitHeight: () => (/* binding */ fitHeight),
/* harmony export */   fitSize: () => (/* binding */ fitSize),
/* harmony export */   fitWidth: () => (/* binding */ fitWidth)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   projectionMutator: () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"], // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"], // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"]), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rotateRadians: () => (/* binding */ rotateRadians)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   arcosh: () => (/* binding */ arcosh),
/* harmony export */   arsinh: () => (/* binding */ arsinh),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   cosh: () => (/* binding */ cosh),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sinci: () => (/* binding */ sinci),
/* harmony export */   sinh: () => (/* binding */ sinh),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   sqrt1_2: () => (/* binding */ sqrt1_2),
/* harmony export */   sqrt2: () => (/* binding */ sqrt2),
/* harmony export */   sqrtPi: () => (/* binding */ sqrtPi),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tanh: () => (/* binding */ tanh),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/robinson.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/robinson.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   robinsonRaw: () => (/* binding */ robinsonRaw)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/src/math.js");



var K = [
  [0.9986, -0.062],
  [1.0000, 0.0000],
  [0.9986, 0.0620],
  [0.9954, 0.1240],
  [0.9900, 0.1860],
  [0.9822, 0.2480],
  [0.9730, 0.3100],
  [0.9600, 0.3720],
  [0.9427, 0.4340],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.8350, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1.0000]
];

K.forEach(function(d) {
  d[1] *= 1.0144;
});

function robinsonRaw(lambda, phi) {
  var i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) * 36 / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i),
      di = i - i0,
      ax = (k = K[i0])[0],
      ay = k[1],
      bx = (k = K[++i0])[0],
      by = k[1],
      cx = (k = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, ++i0)])[0],
      cy = k[1],
      k;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    (phi > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}

robinsonRaw.invert = function(x, y) {
  var yy = y / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
      phi = yy * 90,
      i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi / 5)),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i));
  do {
    var ay = K[i0][1],
        by = K[i0 + 1][1],
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1],
        u = cy - ay,
        v = cy - 2 * by + ay,
        t = 2 * ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(yy) - by) / u,
        c = v / u,
        di = t * (1 - c * t * (1 - 2 * c * t));
    if (di >= 0 || i0 === 1) {
      phi = (y >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) / 5);
        i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i);
        di = i - i0;
        ay = K[i0][1];
        by = K[i0 + 1][1];
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1];
        phi -= (delta = (y >= 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
      } while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K[i0][0],
      bx = K[i0 + 1][0],
      cx = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][0];
  return [
    x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])(robinsonRaw)
      .scale(152.63);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "./node_modules/d3-geo/src/stream.js");





var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(cx, cy, cz),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 = 0;
  X2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Y2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Z2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, centroidStream);

  var x = +X2,
      y = +Y2,
      z = +Z2,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) x = X0, y = Y0, z = Z0;
    m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / m) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rectangle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rectangle.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rejoin.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rejoin.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graticule),
/* harmony export */   graticule10: () => (/* binding */ graticule10)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X)
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function(x) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(x))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function(y) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   haversin: () => (/* binding */ haversin),
/* harmony export */   hypot: () => (/* binding */ hypot),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
    areaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(areaRingSum));
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (areaStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (centroidStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathContext)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};


/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure.js */ "./node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-geo/src/path/string.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  let digits = 3,
      pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
    return _area_js__WEBPACK_IMPORTED_MODULE_1__["default"].result();
  };

  path.measure = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _measure_js__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.bounds = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function(_) {
    if (!arguments.length) return projection;
    projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_5__["default"]) : (projection = _).stream;
    return path;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_6__["default"](digits)) : new _context_js__WEBPACK_IMPORTED_MODULE_7__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  path.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) digits = null;
    else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    if (context === null) contextStream = new _string_js__WEBPACK_IMPORTED_MODULE_6__["default"](digits);
    return path;
  };

  return path.projection(projection).digits(digits).context(context);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/measure.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lengthStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathString)
/* harmony export */ });
// Simple caching for constant-radius points.
let cacheDigits, cacheAppend, cacheRadius, cacheCircle;

class PathString {
  constructor(digits) {
    this._append = digits == null ? append : appendRound(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x, y) {
    switch (this._point) {
      case 0: {
        this._append`M${x},${y}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x},${y}`;
        break;
      }
      default: {
        this._append`M${x},${y}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s = this._;
          this._ = ""; // stash the old string so we can cache the circle path fragment
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
}

function append(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15) return append;
  if (d !== cacheDigits) {
    const k = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k) / k + strings[i];
      }
    };
  }
  return cacheAppend;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fitExtent: () => (/* binding */ fitExtent),
/* harmony export */   fitHeight: () => (/* binding */ fitHeight),
/* harmony export */   fitSize: () => (/* binding */ fitSize),
/* harmony export */   fitWidth: () => (/* binding */ fitWidth)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians, sa = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.sin)(alpha), ca = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.cos)(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_3__.degrees;
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitExtent)(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitSize)(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitWidth)(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitHeight)(projection, height, object);
  };

  return projection;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   genericArray: () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return ((0,_numberArray_js__WEBPACK_IMPORTED_MODULE_0__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ piecewise)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_2__["default"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_4__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_2__["default"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_6__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_6__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_7__.genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathRound: () => (/* binding */ pathRound)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}

class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x, y) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y) {
    this._append`L${this._x1 = +x},${this._y1 = +y}`;
  }
  quadraticCurveTo(x1, y1, x, y) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    }

    // Otherwise, draw an arc!
    else {
      let x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }

      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
    }
  }
  rect(x, y, w, h) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}

function path() {
  return new Path;
}

// Allow instanceof d3.path
path.prototype = Path.prototype;

function pathRound(digits = 3) {
  return new Path(+digits);
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set3.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/category10.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/category10.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/colors.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/colors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/ramp.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/ramp.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scheme => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.rgbBasis)(scheme[scheme.length - 1]));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale/src/band.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/band.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ band),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _ordinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ordinal.js */ "./node_modules/d3-scale/src/ordinal.js");




function band() {
  var scale = (0,_ordinal_js__WEBPACK_IMPORTED_MODULE_0__["default"])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}


/***/ }),

/***/ "./node_modules/d3-scale/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constants)
/* harmony export */ });
function constants(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-scale/src/continuous.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/continuous.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (/* binding */ continuous),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/src/number.js");





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"],
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initInterpolator: () => (/* binding */ initInterpolator),
/* harmony export */   initRange: () => (/* binding */ initRange)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/linear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/linear.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ linear),
/* harmony export */   linearish: () => (/* binding */ linearish)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickFormat.js */ "./node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat_js__WEBPACK_IMPORTED_MODULE_1__["default"])(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, linear());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number)
/* harmony export */ });
function number(x) {
  return +x;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/ordinal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/ordinal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ordinal),
/* harmony export */   implicit: () => (/* binding */ implicit)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/internmap/src/index.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



const implicit = Symbol("implicit");

function ordinal() {
  var index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    let i = index.get(d);
    if (i === undefined) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap();
    for (const value of _) {
      if (index.has(value)) continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/pow.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/pow.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pow),
/* harmony export */   powish: () => (/* binding */ powish),
/* harmony export */   sqrt: () => (/* binding */ sqrt)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantize.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantize.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantize)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_linear_js__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/threshold.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/threshold.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ threshold)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/tickFormat.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/tickFormat.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tickFormat)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");



function tickFormat(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__["default"])(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__["default"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__["default"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_creator_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([(0,_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(arc);

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle. If this
        // intersection fails, it’s probably because the arc is too small, so
        // disable the corner radius entirely.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
                lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
            rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(area);

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bump.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bump.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpRadial: () => (/* binding */ bumpRadial),
/* harmony export */   bumpX: () => (/* binding */ bumpX),
/* harmony export */   bumpY: () => (/* binding */ bumpY)
/* harmony export */ });
/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");


class Bump {
  constructor(context, x) {
    this._context = context;
    this._x = x;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x, y);
        else this._context.moveTo(x, y);
        break;
      }
      case 1: this._point = 2; // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
        break;
      }
    }
    this._x0 = x, this._y0 = y;
  }
}

class BumpRadial {
  constructor(context) {
    this._context = context;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {}
  point(x, y) {
    x = +x, y = +y;
    if (this._point === 0) {
      this._point = 1;
    } else {
      const p0 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0);
      const p1 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0 = (this._y0 + y) / 2);
      const p2 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, this._y0);
      const p3 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, y);
      this._context.moveTo(...p0);
      this._context.bezierCurveTo(...p1, ...p2, ...p3);
    }
    this._x0 = x, this._y0 = y;
  }
}

function bumpX(context) {
  return new Bump(context, true);
}

function bumpY(context) {
  return new Bump(context, false);
}

function bumpRadial(context) {
  return new BumpRadial(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/identity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(line);

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/link.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   link: () => (/* binding */ link),
/* harmony export */   linkHorizontal: () => (/* binding */ linkHorizontal),
/* harmony export */   linkRadial: () => (/* binding */ linkRadial),
/* harmony export */   linkVertical: () => (/* binding */ linkVertical)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_bump_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curve/bump.js */ "./node_modules/d3-shape/src/curve/bump.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  let source = linkSource,
      target = linkTarget,
      x = _point_js__WEBPACK_IMPORTED_MODULE_0__.x,
      y = _point_js__WEBPACK_IMPORTED_MODULE_0__.y,
      context = null,
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.withPath)(link);

  function link() {
    let buffer;
    const argv = _array_js__WEBPACK_IMPORTED_MODULE_2__.slice.call(arguments);
    const s = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null) output = curve(buffer = path());
    output.lineStart();
    argv[0] = s, output.point(+x.apply(this, argv), +y.apply(this, argv));
    argv[0] = t, output.point(+x.apply(this, argv), +y.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
  };

  return link;
}

function linkHorizontal() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpX);
}

function linkVertical() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpY);
}

function linkRadial() {
  const l = link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/path.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   withPath: () => (/* binding */ withPath)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");


function withPath(shape) {
  let digits = 3;

  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };

  return () => new d3_path__WEBPACK_IMPORTED_MODULE_0__.Path(digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pie.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/pie.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      sortValues = _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0),
      endAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0);

  function pie(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pointRadial.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/pointRadial.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-shape/src/symbol.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Symbol),
/* harmony export */   symbolsFill: () => (/* binding */ symbolsFill),
/* harmony export */   symbolsStroke: () => (/* binding */ symbolsStroke)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/asterisk.js */ "./node_modules/d3-shape/src/symbol/asterisk.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/diamond2.js */ "./node_modules/d3-shape/src/symbol/diamond2.js");
/* harmony import */ var _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbol/plus.js */ "./node_modules/d3-shape/src/symbol/plus.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/square2.js */ "./node_modules/d3-shape/src/symbol/square2.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/triangle2.js */ "./node_modules/d3-shape/src/symbol/triangle2.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol/times.js */ "./node_modules/d3-shape/src/symbol/times.js");
















// These symbols are designed to be filled.
const symbolsFill = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__["default"]
];

// These symbols are designed to be stroked (with a width of 1.5px and round caps).
const symbolsStroke = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__["default"]
];

function Symbol(type, size) {
  let context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_13__.withPath)(symbol);

  type = typeof type === "function" ? type : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  size = typeof size === "function" ? size : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(size === undefined ? 64 : +size);

  function symbol() {
    let buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/asterisk.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/asterisk.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u = t * sqrt3;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u, -t);
    context.lineTo(u, t);
    context.moveTo(-u, t);
    context.lineTo(u, -t);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/circle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/cross.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/cross.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const tan30 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(1 / 3);
const tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / tan30_2);
    const x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond2.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond2.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/plus.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/plus.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const w = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size);
    const x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square2.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square2.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/star.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/star.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const ka = 0.89081309152928522810;
const kr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10);
const kx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;
const ky = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size * ka);
    const x = kx * r;
    const y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (let i = 1; i < 5; ++i) {
      const a = _math_js__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5;
      const c = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a);
      const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/times.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/times.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle2.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle2.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.6824;
    const t = s  / 2;
    const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
    context.moveTo(0, -s);
    context.lineTo(u, t);
    context.lineTo(-u, t);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/wye.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/wye.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const c = -0.5;
const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3) / 2;
const k = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(12);
const a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / a);
    const x0 = r / 2, y0 = r * k;
    const x1 = x0, y1 = r * k + r;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/indexRollupNext.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-svg-annotation/indexRollupNext.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotation: () => (/* binding */ annotation),
/* harmony export */   annotationBadge: () => (/* binding */ d3Badge),
/* harmony export */   annotationCallout: () => (/* binding */ d3Callout),
/* harmony export */   annotationCalloutCircle: () => (/* binding */ d3CalloutCircle),
/* harmony export */   annotationCalloutCurve: () => (/* binding */ d3CalloutCurve),
/* harmony export */   annotationCalloutElbow: () => (/* binding */ d3CalloutElbow),
/* harmony export */   annotationCalloutRect: () => (/* binding */ d3CalloutRect),
/* harmony export */   annotationCustomType: () => (/* binding */ customType),
/* harmony export */   annotationLabel: () => (/* binding */ d3Label),
/* harmony export */   annotationTypeBase: () => (/* binding */ Type),
/* harmony export */   annotationXYThreshold: () => (/* binding */ d3XYThreshold),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js");
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");





var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Annotation = function () {
  function Annotation(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === undefined ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === undefined ? 0 : _ref$y,
        nx = _ref.nx,
        ny = _ref.ny,
        _ref$dy = _ref.dy,
        dy = _ref$dy === undefined ? 0 : _ref$dy,
        _ref$dx = _ref.dx,
        dx = _ref$dx === undefined ? 0 : _ref$dx,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? "grey" : _ref$color,
        data = _ref.data,
        type = _ref.type,
        subject = _ref.subject,
        connector = _ref.connector,
        note = _ref.note,
        disable = _ref.disable,
        id = _ref.id,
        className = _ref.className;
    classCallCheck(this, Annotation);

    this._dx = nx !== undefined ? nx - x : dx;
    this._dy = ny !== undefined ? ny - y : dy;
    this._x = x;
    this._y = y;
    this._color = color;
    this.id = id;
    this._className = className || "";

    this._type = type || "";
    this.data = data;

    this.note = note || {};
    this.connector = connector || {};
    this.subject = subject || {};

    this.disable = disable || [];
  }

  createClass(Annotation, [{
    key: "updatePosition",
    value: function updatePosition() {
      if (this.type.setPosition) {
        this.type.setPosition();
        if (this.type.subject && this.type.subject.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawSubject();
        }
      }
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.type.clearComponents && this.type.clearComponents();
    }
  }, {
    key: "updateOffset",
    value: function updateOffset() {
      if (this.type.setOffset) {
        this.type.setOffset();

        if (this.type.connector.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawConnector();
        }

        this.type.redrawNote();
      }
    }
  }, {
    key: "className",
    get: function get$$1() {
      return this._className;
    },
    set: function set$$1(className) {
      this._className = className;
      if (this.type.setClassName) this.type.setClassName();
    }
  }, {
    key: "type",
    get: function get$$1() {
      return this._type;
    },
    set: function set$$1(type) {
      this._type = type;
      this.clearComponents();
    }
  }, {
    key: "x",
    get: function get$$1() {
      return this._x;
    },
    set: function set$$1(x) {
      this._x = x;
      this.updatePosition();
    }
  }, {
    key: "y",
    get: function get$$1() {
      return this._y;
    },
    set: function set$$1(y) {
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "color",
    get: function get$$1() {
      return this._color;
    },
    set: function set$$1(color) {
      this._color = color;
      this.updatePosition();
    }
  }, {
    key: "dx",
    get: function get$$1() {
      return this._dx;
    },
    set: function set$$1(dx) {
      this._dx = dx;
      this.updateOffset();
    }
  }, {
    key: "dy",
    get: function get$$1() {
      return this._dy;
    },
    set: function set$$1(dy) {
      this._dy = dy;
      this.updateOffset();
    }
  }, {
    key: "nx",
    set: function set$$1(nx) {
      this._dx = nx - this._x;
      this.updateOffset();
    }
  }, {
    key: "ny",
    set: function set$$1(ny) {
      this._dy = ny - this._y;
      this.updateOffset();
    }
  }, {
    key: "offset",
    get: function get$$1() {
      return { x: this._dx, y: this._dy };
    },
    set: function set$$1(_ref2) {
      var x = _ref2.x,
          y = _ref2.y;

      this._dx = x;
      this._dy = y;
      this.updateOffset();
    }
  }, {
    key: "position",
    get: function get$$1() {
      return { x: this._x, y: this._y };
    },
    set: function set$$1(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      this._x = x;
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "translation",
    get: function get$$1() {
      return {
        x: this._x + this._dx,
        y: this._y + this._dy
      };
    }
  }, {
    key: "json",
    get: function get$$1() {
      var json = {
        x: this._x,
        y: this._y,
        dx: this._dx,
        dy: this._dy
      };

      if (this.data && Object.keys(this.data).length > 0) json.data = this.data;
      if (this.type) json.type = this.type;
      if (this._className) json.className = this._className;

      if (Object.keys(this.connector).length > 0) json.connector = this.connector;
      if (Object.keys(this.subject).length > 0) json.subject = this.subject;
      if (Object.keys(this.note).length > 0) json.note = this.note;

      return json;
    }
  }]);
  return Annotation;
}();

var AnnotationCollection = function () {
  function AnnotationCollection(_ref) {
    var annotations = _ref.annotations,
        accessors = _ref.accessors,
        accessorsInverse = _ref.accessorsInverse;
    classCallCheck(this, AnnotationCollection);

    this.accessors = accessors;
    this.accessorsInverse = accessorsInverse;
    this.annotations = annotations;
  }

  createClass(AnnotationCollection, [{
    key: "clearTypes",
    value: function clearTypes(newSettings) {
      this.annotations.forEach(function (d) {
        d.type = undefined;
        d.subject = newSettings && newSettings.subject || d.subject;
        d.connector = newSettings && newSettings.connector || d.connector;
        d.note = newSettings && newSettings.note || d.note;
      });
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors() {
      var _this = this;

      this.annotations.forEach(function (d) {
        d.type.setPositionWithAccessors(_this.accessors);
      });
    }
  }, {
    key: "editMode",
    value: function editMode(_editMode) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.editMode = _editMode;
          a.type.updateEditMode();
        }
      });
    }
  }, {
    key: "updateDisable",
    value: function updateDisable(disable) {
      this.annotations.forEach(function (a) {
        a.disable = disable;
        if (a.type) {
          disable.forEach(function (d) {
            if (a.type[d]) {
              a.type[d].remove && a.type[d].remove();
              a.type[d] = undefined;
            }
          });
        }
      });
    }
  }, {
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.updateTextWrap) {
          a.type.updateTextWrap(textWrap);
        }
      });
    }
  }, {
    key: "updateText",
    value: function updateText() {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.drawText) {
          a.type.drawText();
        }
      });
    }
  }, {
    key: "updateNotePadding",
    value: function updateNotePadding(notePadding) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.notePadding = notePadding;
        }
      });
    }
  }, {
    key: "json",
    get: function get$$1() {
      var _this2 = this;

      return this.annotations.map(function (a) {
        var json = a.json;
        if (_this2.accessorsInverse && a.data) {
          json.data = {};
          Object.keys(_this2.accessorsInverse).forEach(function (k) {
            json.data[k] = _this2.accessorsInverse[k]({ x: a.x, y: a.y });

            //TODO make this feasible to map back to data for other types of subjects
          });
        }
        return json;
      });
    }
  }, {
    key: "noteNodes",
    get: function get$$1() {
      return this.annotations.map(function (a) {
        return _extends({}, a.type.getNoteBBoxOffset(), { positionX: a.x, positionY: a.y });
      });
    }

    //TODO: come back and rethink if a.x and a.y are applicable in all situations
    // get connectorNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))
    // }

    // get subjectNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))
    // }

    // get annotationNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))
    // }

  }]);
  return AnnotationCollection;
}();

var pointHandle = function pointHandle(_ref) {
  var _ref$cx = _ref.cx,
      cx = _ref$cx === undefined ? 0 : _ref$cx,
      _ref$cy = _ref.cy,
      cy = _ref$cy === undefined ? 0 : _ref$cy;

  return { move: { x: cx, y: cy } };
};

var circleHandles = function circleHandles(_ref2) {
  var _ref2$cx = _ref2.cx,
      cx = _ref2$cx === undefined ? 0 : _ref2$cx,
      _ref2$cy = _ref2.cy,
      cy = _ref2$cy === undefined ? 0 : _ref2$cy,
      r1 = _ref2.r1,
      r2 = _ref2.r2,
      padding = _ref2.padding;

  var h = { move: { x: cx, y: cy } };

  if (r1 !== undefined) {
    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
  }

  if (r2 !== undefined) {
    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
  }

  if (padding !== undefined) {
    h.padding = { x: cx + r1 + padding, y: cy };
  }

  return h;
};





//arc handles
var addHandles = function addHandles(_ref5) {
  var group = _ref5.group,
      handles = _ref5.handles,
      _ref5$r = _ref5.r,
      r = _ref5$r === undefined ? 10 : _ref5$r;

  //give it a group and x,y to draw handles
  //then give it instructions on what the handles change
  var h = group.selectAll("circle.handle").data(handles);

  h.enter().append("circle").attr("class", "handle").attr("fill", "grey").attr("fill-opacity", 0.1).attr("cursor", "move").attr("stroke-dasharray", 5).attr("stroke", "grey").call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
    return d.start && d.start(d);
  }).on("drag", function (d) {
    return d.drag && d.drag(d);
  }).on("end", function (d) {
    return d.end && d.end(d);
  }));

  group.selectAll("circle.handle").attr("cx", function (d) {
    return d.x;
  }).attr("cy", function (d) {
    return d.y;
  }).attr("r", function (d) {
    return d.r || r;
  }).attr("class", function (d) {
    return "handle " + (d.className || "");
  });

  h.exit().remove();
};

var leftRightDynamic = function leftRightDynamic(align, y) {
  if (align === "dynamic" || align === "left" || align === "right") {
    if (y < 0) {
      align = "top";
    } else {
      align = "bottom";
    }
  }
  return align;
};

var topBottomDynamic = function topBottomDynamic(align, x) {
  if (align === "dynamic" || align === "top" || align === "bottom") {
    if (x < 0) {
      align = "right";
    } else {
      align = "left";
    }
  }
  return align;
};

var orientationTopBottom = ["topBottom", "top", "bottom"];
var orientationLeftRight = ["leftRight", "left", "right"];

var noteAlignment = (function (_ref) {
  var _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$bbox = _ref.bbox,
      bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
      align = _ref.align,
      orientation = _ref.orientation,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

  var x = -bbox.x;
  var y = 0; //-bbox.y
  if (orientationTopBottom.indexOf(orientation) !== -1) {
    align = topBottomDynamic(align, offset.x);
    if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
      y -= bbox.height + padding;
    } else {
      y += padding;
    }

    if (align === "middle") {
      x -= bbox.width / 2;
    } else if (align === "right") {
      x -= bbox.width;
    }
  } else if (orientationLeftRight.indexOf(orientation) !== -1) {
    align = leftRightDynamic(align, offset.y);
    if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
      x -= bbox.width + padding;
    } else {
      x += padding;
    }

    if (align === "middle") {
      y -= bbox.height / 2;
    } else if (align === "top") {
      y -= bbox.height;
    }
  }

  return { x: x, y: y };
});

var lineBuilder = function lineBuilder(_ref) {
  var data = _ref.data,
      _ref$curve = _ref.curve,
      curve = _ref$curve === undefined ? d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveLinear : _ref$curve,
      canvasContext = _ref.canvasContext,
      className = _ref.className,
      classID = _ref.classID;

  var lineGen = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.line)().curve(curve);

  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {
    builder.attrs = {
      d: lineGen(data)
    };
  }

  return builder;
};

var arcBuilder = function arcBuilder(_ref2) {
  var data = _ref2.data,
      canvasContext = _ref2.canvasContext,
      className = _ref2.className,
      classID = _ref2.classID;


  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  var arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.arc)().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

  if (canvasContext) {
    arcShape.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {

    builder.attrs = {
      d: arcShape()
    };
  }

  return builder;
};

var noteVertical = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      bbox = _ref.bbox,
      offset = _ref.offset;

  align = leftRightDynamic(align, offset.y);

  if (align === "top") {
    y -= bbox.height;
  } else if (align === "middle") {
    y -= bbox.height / 2;
  }

  var data = [[x, y], [x, y + bbox.height]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var noteHorizontal = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      offset = _ref.offset,
      bbox = _ref.bbox;

  align = topBottomDynamic(align, offset.x);

  if (align === "right") {
    x -= bbox.width;
  } else if (align === "middle") {
    x -= bbox.width / 2;
  }

  var data = [[x, y], [x + bbox.width, y]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var lineSetup = function lineSetup(_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;

  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    var angle = Math.asin(-y2 / h);
    var r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0);

    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
  }

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  return [[x1, y1], [x2, y2]];
};

var connectorLine = (function (connectorData) {
  var data = lineSetup(connectorData);
  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorElbow = (function (_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;


  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  var data = [[x1, y1], [x2, y2]];

  var diffY = y2 - y1;
  var diffX = x2 - x1;
  var xe = x2;
  var ye = y2;
  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

  if (Math.abs(diffX) < Math.abs(diffY)) {
    xe = x2;
    ye = y1 + diffX * opposite;
  } else {
    ye = y2;
    xe = x1 + diffY * opposite;
  }

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0);
    var length = r / Math.sqrt(2);

    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
      x1 = length * (x2 < 0 ? -1 : 1);
      y1 = length * (y2 < 0 ? -1 : 1);
      data = [[x1, y1], [xe, ye], [x2, y2]];
    } else if (Math.abs(diffX) > Math.abs(diffY)) {
      var angle = Math.asin(-y2 / r);
      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      data = [[x1, y2], [x2, y2]];
    } else {
      var _angle = Math.acos(x2 / r);
      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
      data = [[x2, y1], [x2, y2]];
    }
  } else {
    data = [[x1, y1], [xe, ye], [x2, y2]];
  }

  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorCurve = (function (_ref) {
  var type = _ref.type,
      connectorData = _ref.connectorData,
      subjectType = _ref.subjectType;


  if (!connectorData) {
    connectorData = {};
  }
  if (!connectorData.points || typeof connectorData.points === "number") {
    connectorData.points = createPoints(type.annotation.offset, connectorData.points);
  }
  if (!connectorData.curve) {
    connectorData.curve = d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveCatmullRom;
  }

  var handles = [];

  if (type.editMode) {
    var cHandles = connectorData.points.map(function (c, i) {
      return _extends({}, pointHandle({ cx: c[0], cy: c[1] }), { index: i });
    });

    var updatePoint = function updatePoint(index) {
      connectorData.points[index][0] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      connectorData.points[index][1] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      type.redrawConnector();
    };

    handles = type.mapHandles(cHandles.map(function (h) {
      return _extends({}, h.move, { drag: updatePoint.bind(type, h.index) });
    }));
  }

  var data = lineSetup({ type: type, subjectType: subjectType });
  data = [data[0]].concat(toConsumableArray(connectorData.points), [data[1]]);
  var components = [lineBuilder({ data: data, curve: connectorData.curve, className: "connector" })];

  return { components: components, handles: handles };
});

var createPoints = function createPoints(offset) {
  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
  var p = [];

  var i = 1;
  for (; i <= anchors; i++) {
    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
  }
  return p;
};

var connectorArrow = (function (_ref) {
  var annotation = _ref.annotation,
      start = _ref.start,
      end = _ref.end,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var offset = annotation.position;
  if (!start) {
    start = [annotation.dx, annotation.dy];
  } else {
    start = [-end[0] + start[0], -end[1] + start[1]];
  }
  if (!end) {
    end = [annotation.x - offset.x, annotation.y - offset.y];
  }

  var x1 = end[0],
      y1 = end[1];

  var dx = start[0];
  var dy = start[1];

  var size = 10 * scale;
  var angleOffset = 16 / 180 * Math.PI;
  var angle = Math.atan(dy / dx);

  if (dx < 0) {
    angle += Math.PI;
  }

  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

  //TODO add in reverse
  // if (canvasContext.arrowReverse){
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // } else {
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // }

  return {
    components: [lineBuilder({
      data: data,
      className: "connector-end connector-arrow",
      classID: "connector-end"
    })]
  };
});

var connectorDot = (function (_ref) {
  var line$$1 = _ref.line,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var dot = arcBuilder({
    className: "connector-end connector-dot",
    classID: "connector-end",
    data: { radius: 3 * Math.sqrt(scale) }
  });
  dot.attrs.transform = "translate(" + line$$1.data[0][0] + ", " + line$$1.data[0][1] + ")";

  return { components: [dot] };
});

var subjectCircle = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.radius && !subjectData.outerRadius) {
    subjectData.radius = 20;
  }

  var handles = [];
  var c = arcBuilder({ data: subjectData, className: "subject" });
  if (type.editMode) {
    var h = circleHandles({
      r1: c.data.outerRadius || c.data.radius,
      r2: c.data.innerRadius,
      padding: subjectData.radiusPadding
    });

    var updateRadius = function updateRadius(attr) {
      var r = subjectData[attr] + d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx * Math.sqrt(2);
      subjectData[attr] = r;
      type.redrawSubject();
      type.redrawConnector();
    };

    var cHandles = [_extends({}, h.r1, {
      drag: updateRadius.bind(type, subjectData.outerRadius !== undefined ? "outerRadius" : "radius")
    })];

    if (subjectData.innerRadius) {
      cHandles.push(_extends({}, h.r2, { drag: updateRadius.bind(type, "innerRadius") }));
    }
    handles = type.mapHandles(cHandles);
  }

  c.attrs["fill-opacity"] = 0;

  return { components: [c], handles: handles };
});

var subjectRect = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.width) {
    subjectData.width = 100;
  }
  if (!subjectData.height) {
    subjectData.height = 100;
  }

  var handles = [];
  var width = subjectData.width,
      height = subjectData.height;


  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
  var rect = lineBuilder({ data: data, className: "subject" });

  if (type.editMode) {
    var updateWidth = function updateWidth() {
      subjectData.width = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x;
      type.redrawSubject();
      type.redrawConnector();
    };

    var updateHeight = function updateHeight() {
      subjectData.height = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y;
      type.redrawSubject();
      type.redrawConnector();
    };

    var rHandles = [{ x: width, y: height / 2, drag: updateWidth.bind(type) }, { x: width / 2, y: height, drag: updateHeight.bind(type) }];

    handles = type.mapHandles(rHandles);
  }
  rect.attrs["fill-opacity"] = 0.1;
  return { components: [rect], handles: handles };
});

var subjectThreshold = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  var offset = type.annotation.position;

  var x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x,
      x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x,
      y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y,
      y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y;

  var data = [[x1, y1], [x2, y2]];
  return { components: [lineBuilder({ data: data, className: 'subject' })] };
});

var subjectBadge = (function (_ref) {
  var _ref$subjectData = _ref.subjectData,
      subjectData = _ref$subjectData === undefined ? {} : _ref$subjectData,
      _ref$type = _ref.type,
      type = _ref$type === undefined ? {} : _ref$type;
  var annotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var typeSettings = type.typeSettings && type.typeSettings.subject;

  if (!subjectData.radius) {
    if (typeSettings && typeSettings.radius) {
      subjectData.radius = typeSettings.radius;
    } else {
      subjectData.radius = 14;
    }
  }
  if (!subjectData.x) {
    if (typeSettings && typeSettings.x) {
      subjectData.x = typeSettings.x;
    }
  }
  if (!subjectData.y) {
    if (typeSettings && typeSettings.y) {
      subjectData.y = typeSettings.y;
    }
  }

  var handles = [];
  var components = [];
  var radius = subjectData.radius;
  var innerRadius = radius * 0.7;
  var x = 0;
  var y = 0;

  var notCornerOffset = Math.sqrt(2) * radius;
  var placement = {
    xleftcorner: -radius,
    xrightcorner: radius,
    ytopcorner: -radius,
    ybottomcorner: radius,
    xleft: -notCornerOffset,
    xright: notCornerOffset,
    ytop: -notCornerOffset,
    ybottom: notCornerOffset
  };

  if (subjectData.x && !subjectData.y) {
    x = placement["x" + subjectData.x];
  } else if (subjectData.y && !subjectData.x) {
    y = placement["y" + subjectData.y];
  } else if (subjectData.x && subjectData.y) {
    x = placement["x" + subjectData.x + "corner"];
    y = placement["y" + subjectData.y + "corner"];
  }

  var transform = "translate(" + x + ", " + y + ")";
  var circlebg = arcBuilder({ className: "subject", data: { radius: radius } });
  circlebg.attrs.transform = transform;
  circlebg.attrs.fill = annotation.color;
  circlebg.attrs["stroke-linecap"] = "round";
  circlebg.attrs["stroke-width"] = "3px";

  var circle = arcBuilder({
    className: "subject-ring",
    data: { outerRadius: radius, innerRadius: innerRadius }
  });

  circle.attrs.transform = transform;
  // circle.attrs.fill = annotation.color
  circle.attrs["stroke-width"] = "3px";
  circle.attrs.fill = "white";

  var pointer = void 0;
  if (x && y || !x && !y) {
    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
    });
  } else if (x || y) {
    var notCornerPointerXY = function notCornerPointerXY(v) {
      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
    };

    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
    });
  }

  if (pointer) {
    pointer.attrs.fill = annotation.color;
    pointer.attrs["stroke-linecap"] = "round";
    pointer.attrs["stroke-width"] = "3px";
    components.push(pointer);
  }

  if (type.editMode) {
    var dragBadge = function dragBadge() {
      subjectData.x = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x < -radius * 2 ? "left" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x > radius * 2 ? "right" : undefined;
      subjectData.y = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y < -radius * 2 ? "top" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y > radius * 2 ? "bottom" : undefined;

      type.redrawSubject();
    };

    var bHandles = { x: x * 2, y: y * 2, drag: dragBadge.bind(type) };
    if (!bHandles.x && !bHandles.y) {
      bHandles.y = -radius;
    }

    handles = type.mapHandles([bHandles]);
  }

  var text = void 0;
  if (subjectData.text) {
    text = {
      type: "text",
      className: "badge-text",
      attrs: {
        fill: "white",
        stroke: "none",
        "font-size": ".7em",
        text: subjectData.text,
        "text-anchor": "middle",
        dy: ".25em",
        x: x,
        y: y
      }
    };
  }

  components.push(circlebg);
  components.push(circle);
  components.push(text);

  return { components: components, handles: handles };
});

//Note options
//Connector options
//Subject options
var Type = function () {
  function Type(_ref) {
    var a = _ref.a,
        annotation = _ref.annotation,
        editMode = _ref.editMode,
        dispatcher = _ref.dispatcher,
        notePadding = _ref.notePadding,
        accessors = _ref.accessors;
    classCallCheck(this, Type);

    this.a = a;

    this.note = annotation.disable.indexOf("note") === -1 && a.select("g.annotation-note");
    this.noteContent = this.note && a.select("g.annotation-note-content");
    this.connector = annotation.disable.indexOf("connector") === -1 && a.select("g.annotation-connector");
    this.subject = annotation.disable.indexOf("subject") === -1 && a.select("g.annotation-subject");
    this.dispatcher = dispatcher;

    if (dispatcher) {
      var handler = addHandlers.bind(null, dispatcher, annotation);
      handler({ component: this.note, name: "note" });
      handler({ component: this.connector, name: "connector" });
      handler({ component: this.subject, name: "subject" });
    }

    this.annotation = annotation;
    this.editMode = annotation.editMode || editMode;
    this.notePadding = notePadding !== undefined ? notePadding : 3;
    this.offsetCornerX = 0;
    this.offsetCornerY = 0;

    if (accessors && annotation.data) {
      this.init(accessors);
    }
  }

  createClass(Type, [{
    key: "init",
    value: function init(accessors) {
      if (!this.annotation.x) {
        this.mapX(accessors);
      }
      if (!this.annotation.y) {
        this.mapY(accessors);
      }
    }
  }, {
    key: "mapY",
    value: function mapY(accessors) {
      if (accessors.y) {
        this.annotation.y = accessors.y(this.annotation.data);
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      if (accessors.x) {
        this.annotation.x = accessors.x(this.annotation.data);
      }
    }
  }, {
    key: "updateEditMode",
    value: function updateEditMode() {
      this.a.selectAll("circle.handle").remove();
    }
  }, {
    key: "drawOnSVG",
    value: function drawOnSVG(component, builders) {
      var _this = this;

      if (!Array.isArray(builders)) {
        builders = [builders];
      }

      builders.filter(function (b) {
        return b;
      }).forEach(function (_ref2) {
        var type = _ref2.type,
            className = _ref2.className,
            attrs = _ref2.attrs,
            handles = _ref2.handles,
            classID = _ref2.classID;

        if (type === "handle") {
          addHandles({ group: component, r: attrs && attrs.r, handles: handles });
        } else {
          newWithClass(component, [_this.annotation], type, className, classID);
          var el = component.select(type + "." + (classID || className));
          var addAttrs = Object.keys(attrs);
          var removeAttrs = [];

          var currentAttrs = el.node().attributes;
          for (var i = currentAttrs.length - 1; i >= 0; i--) {
            var name = currentAttrs[i].name;
            if (addAttrs.indexOf(name) === -1 && name !== "class") removeAttrs.push(name);
          }

          addAttrs.forEach(function (attr) {
            if (attr === "text") {
              el.text(attrs[attr]);
            } else {
              el.attr(attr, attrs[attr]);
            }
          });

          removeAttrs.forEach(function (attr) {
            return el.attr(attr, null);
          });
        }
      });
    }

    //TODO: how to extend this to a drawOnCanvas mode?

  }, {
    key: "getNoteBBox",
    value: function getNoteBBox() {
      return bboxWithoutHandles(this.note, ".annotation-note-content text");
    }
  }, {
    key: "getNoteBBoxOffset",
    value: function getNoteBBoxOffset() {
      var bbox = bboxWithoutHandles(this.note, ".annotation-note-content");
      var transform = this.noteContent.attr("transform").split(/\(|\,|\)/g);
      bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx;
      bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy;
      bbox.offsetX = this.annotation.dx;
      bbox.offsetY = this.annotation.dy;
      return bbox;
    }
  }, {
    key: "drawSubject",
    value: function drawSubject() {
      var _this2 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var subjectData = this.annotation.subject;
      var type = context.type;
      var subjectParams = { type: this, subjectData: subjectData };

      var subject = {};
      if (type === "circle") subject = subjectCircle(subjectParams);else if (type === "rect") subject = subjectRect(subjectParams);else if (type === "threshold") subject = subjectThreshold(subjectParams);else if (type === "badge") subject = subjectBadge(subjectParams, this.annotation);

      var _subject = subject,
          _subject$components = _subject.components,
          components = _subject$components === undefined ? [] : _subject$components,
          _subject$handles = _subject.handles,
          handles = _subject$handles === undefined ? [] : _subject$handles;

      components.forEach(function (c) {
        if (c && c.attrs && !c.attrs.stroke) {
          c.attrs.stroke = _this2.annotation.color;
        }
      });

      if (this.editMode) {
        handles = handles.concat(this.mapHandles([{ drag: this.dragSubject.bind(this) }]));
        components.push({ type: "handle", handles: handles });
      }

      return components;
    }
  }, {
    key: "drawConnector",
    value: function drawConnector() {
      var _this3 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var connectorData = this.annotation.connector;
      var type = connectorData.type || context.type;
      var connectorParams = { type: this, connectorData: connectorData };
      connectorParams.subjectType = this.typeSettings && this.typeSettings.subject && this.typeSettings.subject.type;

      var connector = {};
      if (type === "curve") connector = connectorCurve(connectorParams);else if (type === "elbow") connector = connectorElbow(connectorParams);else connector = connectorLine(connectorParams);
      var _connector = connector,
          _connector$components = _connector.components,
          components = _connector$components === undefined ? [] : _connector$components,
          _connector$handles = _connector.handles,
          handles = _connector$handles === undefined ? [] : _connector$handles;

      var line$$1 = components[0];
      //TODO: genericize this into fill t/f stroke t/f
      if (line$$1) {
        line$$1.attrs.stroke = this.annotation.color;
        line$$1.attrs.fill = "none";
      }
      var endType = connectorData.end || context.end;
      var end = {};
      if (endType === "arrow") {
        var s = line$$1.data[1];
        var e = line$$1.data[0];
        var distance = Math.sqrt(Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2));
        if (distance < 5 && line$$1.data[2]) {
          s = line$$1.data[2];
        }
        end = connectorArrow({
          annotation: this.annotation,
          start: s,
          end: e,
          scale: connectorData.endScale
        });
      } else if (endType === "dot") {
        end = connectorDot({ line: line$$1, scale: connectorData.endScale });
      } else if (!endType || endType === "none") {
        this.connector && this.connector.select(".connector-end").remove();
      }

      if (end.components) {
        end.components.forEach(function (c) {
          c.attrs.fill = _this3.annotation.color;
          c.attrs.stroke = _this3.annotation.color;
        });
        components = components.concat(end.components);
      }

      if (this.editMode) {
        if (handles.length !== 0) components.push({ type: "handle", handles: handles });
      }
      return components;
    }
  }, {
    key: "drawNote",
    value: function drawNote() {
      var _this4 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var noteData = this.annotation.note;
      var align = noteData.align || context.align || "dynamic";
      var noteParams = {
        bbox: context.bbox,
        align: align,
        offset: this.annotation.offset
      };
      var lineType = noteData.lineType || context.lineType;
      var note = {};
      if (lineType === "vertical") note = noteVertical(noteParams);else if (lineType === "horizontal") note = noteHorizontal(noteParams);

      var _note = note,
          _note$components = _note.components,
          components = _note$components === undefined ? [] : _note$components,
          _note$handles = _note.handles,
          handles = _note$handles === undefined ? [] : _note$handles;

      components.forEach(function (c) {
        c.attrs.stroke = _this4.annotation.color;
      });

      if (this.editMode) {
        handles = this.mapHandles([{ x: 0, y: 0, drag: this.dragNote.bind(this) }]);
        components.push({ type: "handle", handles: handles });

        var dragging = this.dragNote.bind(this),
            start = this.dragstarted.bind(this),
            end = this.dragended.bind(this);
        this.note.call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
          return start(d);
        }).on("drag", function (d) {
          return dragging(d);
        }).on("end", function (d) {
          return end(d);
        }));
      } else {
        this.note.on("mousedown.drag", null);
      }
      return components;
    }
  }, {
    key: "drawNoteContent",
    value: function drawNoteContent(context) {
      var noteData = this.annotation.note;
      var padding = noteData.padding !== undefined ? noteData.padding : this.notePadding;
      var orientation = noteData.orientation || context.orientation || "topBottom";
      var lineType = noteData.lineType || context.lineType;
      var align = noteData.align || context.align || "dynamic";

      if (lineType === "vertical") orientation = "leftRight";else if (lineType === "horizontal") orientation = "topBottom";

      var noteParams = {
        padding: padding,
        bbox: context.bbox,
        offset: this.annotation.offset,
        orientation: orientation,
        align: align
      };

      var _noteAlignment = noteAlignment(noteParams),
          x = _noteAlignment.x,
          y = _noteAlignment.y;

      this.offsetCornerX = x + this.annotation.dx;
      this.offsetCornerY = y + this.annotation.dy;
      this.note && this.noteContent.attr("transform", "translate(" + x + ", " + y + ")");

      return [];
    }
  }, {
    key: "drawOnScreen",
    value: function drawOnScreen(component, drawFunction) {
      return this.drawOnSVG(component, drawFunction);
    }
  }, {
    key: "redrawSubject",
    value: function redrawSubject() {
      this.subject && this.drawOnScreen(this.subject, this.drawSubject());
    }
  }, {
    key: "redrawConnector",
    value: function redrawConnector() {
      this.connector && this.drawOnScreen(this.connector, this.drawConnector());
    }
  }, {
    key: "redrawNote",
    value: function redrawNote() {
      var bbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNoteBBox();

      this.noteContent && this.drawOnScreen(this.noteContent, this.drawNoteContent({ bbox: bbox }));
      this.note && this.drawOnScreen(this.note, this.drawNote({ bbox: bbox }));
    }
  }, {
    key: "setPosition",
    value: function setPosition() {
      var position = this.annotation.position;
      this.a.attr("transform", "translate(" + position.x + ", " + position.y + ")");
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.subject && this.subject.select("*").remove();
      this.connector && this.connector.select("*").remove();
      // this.note && this.note.select("*").remove()
    }
  }, {
    key: "setOffset",
    value: function setOffset() {
      if (this.note) {
        var offset = this.annotation.offset;
        this.note.attr("transform", "translate(" + offset.x + ", " + offset.y + ")");
      }
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors(accessors) {
      if (accessors && this.annotation.data) {
        this.mapX(accessors);
        this.mapY(accessors);
      }
      this.setPosition();
    }
  }, {
    key: "setClassName",
    value: function setClassName() {
      this.a.attr("class", "annotation " + (this.className && this.className()) + " " + (this.editMode ? "editable" : "") + " " + (this.annotation.className || ""));
    }
  }, {
    key: "draw",
    value: function draw() {
      this.setClassName();
      this.setPosition();
      this.setOffset();
      this.redrawSubject();
      this.redrawConnector();
      this.redrawNote();
    }
  }, {
    key: "dragstarted",
    value: function dragstarted() {
      d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.sourceEvent.stopPropagation();
      this.dispatcher && this.dispatcher.call("dragstart", this.a, this.annotation);
      this.a.classed("dragging", true);
      this.a.selectAll("circle.handle").style("pointer-events", "none");
    }
  }, {
    key: "dragended",
    value: function dragended() {
      this.dispatcher && this.dispatcher.call("dragend", this.a, this.annotation);
      this.a.classed("dragging", false);
      this.a.selectAll("circle.handle").style("pointer-events", "all");
    }
  }, {
    key: "dragSubject",
    value: function dragSubject() {
      var position = this.annotation.position;
      position.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      position.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.position = position;
    }
  }, {
    key: "dragNote",
    value: function dragNote() {
      var offset = this.annotation.offset;
      offset.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      offset.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.offset = offset;
    }
  }, {
    key: "mapHandles",
    value: function mapHandles(handles) {
      var _this5 = this;

      return handles.map(function (h) {
        return _extends({}, h, {
          start: _this5.dragstarted.bind(_this5),
          end: _this5.dragended.bind(_this5)
        });
      });
    }
  }]);
  return Type;
}();

var customType = function customType(initialType, typeSettings, _init) {
  return function (_initialType) {
    inherits(customType, _initialType);

    function customType(settings) {
      classCallCheck(this, customType);

      var _this6 = possibleConstructorReturn(this, (customType.__proto__ || Object.getPrototypeOf(customType)).call(this, settings));

      _this6.typeSettings = typeSettings;

      if (typeSettings.disable) {
        typeSettings.disable.forEach(function (d) {
          _this6[d] && _this6[d].remove();

          _this6[d] = undefined;
          if (d === "note") {
            _this6.noteContent = undefined;
          }
        });
      }
      return _this6;
    }

    createClass(customType, [{
      key: "className",
      value: function className() {
        return "" + (typeSettings.className || get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this) && get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this).call(this) || "");
      }
    }, {
      key: "drawSubject",
      value: function drawSubject(context) {
        this.typeSettings.subject = _extends({}, typeSettings.subject, this.typeSettings.subject);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawSubject", this).call(this, _extends({}, context, this.typeSettings.subject));
      }
    }, {
      key: "drawConnector",
      value: function drawConnector(context) {
        this.typeSettings.connector = _extends({}, typeSettings.connector, this.typeSettings.connector);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawConnector", this).call(this, _extends({}, context, typeSettings.connector, this.typeSettings.connector));
      }
    }, {
      key: "drawNote",
      value: function drawNote(context) {
        this.typeSettings.note = _extends({}, typeSettings.note, this.typeSettings.note);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNote", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }, {
      key: "drawNoteContent",
      value: function drawNoteContent(context) {
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNoteContent", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }], [{
      key: "init",
      value: function init(annotation, accessors) {
        get(customType.__proto__ || Object.getPrototypeOf(customType), "init", this).call(this, annotation, accessors);
        if (_init) {
          annotation = _init(annotation, accessors);
        }
        return annotation;
      }
    }]);
    return customType;
  }(initialType);
};

var d3NoteText = function (_Type) {
  inherits(d3NoteText, _Type);

  function d3NoteText(params) {
    classCallCheck(this, d3NoteText);

    var _this7 = possibleConstructorReturn(this, (d3NoteText.__proto__ || Object.getPrototypeOf(d3NoteText)).call(this, params));

    _this7.textWrap = params.textWrap || 120;
    _this7.drawText();
    return _this7;
  }

  createClass(d3NoteText, [{
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.textWrap = textWrap;
      this.drawText();
    }

    //TODO: add update text functionality

  }, {
    key: "drawText",
    value: function drawText() {
      if (this.note) {
        newWithClass(this.note, [this.annotation], "g", "annotation-note-content");

        var noteContent = this.note.select("g.annotation-note-content");
        newWithClass(noteContent, [this.annotation], "rect", "annotation-note-bg");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-label");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-title");

        var titleBBox = { height: 0 };
        var label = this.a.select("text.annotation-note-label");
        var wrapLength = this.annotation.note && this.annotation.note.wrap || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrap || this.textWrap;

        var wrapSplitter = this.annotation.note && this.annotation.note.wrapSplitter || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrapSplitter;

        var bgPadding = this.annotation.note && this.annotation.note.bgPadding || this.typeSettings && this.typeSettings.note && this.typeSettings.note.bgPadding;

        var bgPaddingFinal = { top: 0, bottom: 0, left: 0, right: 0 };
        if (typeof bgPadding === "number") {
          bgPaddingFinal = {
            top: bgPadding,
            bottom: bgPadding,
            left: bgPadding,
            right: bgPadding
          };
        } else if (bgPadding && (typeof bgPadding === "undefined" ? "undefined" : _typeof(bgPadding)) === "object") {
          bgPaddingFinal = _extends(bgPaddingFinal, bgPadding);
        }

        if (this.annotation.note.title) {
          var title = this.a.select("text.annotation-note-title");
          title.text(this.annotation.note.title);
          title.attr("fill", this.annotation.color);
          title.attr("font-weight", "bold");
          title.call(wrap, wrapLength, wrapSplitter);
          titleBBox = title.node().getBBox();
        }

        label.text(this.annotation.note.label).attr("dx", "0");
        label.call(wrap, wrapLength, wrapSplitter);

        label.attr("y", titleBBox.height * 1.1 || 0);
        label.attr("fill", this.annotation.color);

        var bbox = this.getNoteBBox();

        this.a.select("rect.annotation-note-bg").attr("width", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right).attr("height", bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom).attr("x", bbox.x - bgPaddingFinal.left).attr("y", -bgPaddingFinal.top).attr("fill", "white").attr("fill-opacity", 0);
      }
    }
  }]);
  return d3NoteText;
}(Type);

var d3Label = customType(d3NoteText, {
  className: "label",
  note: { align: "middle" }
});

var d3Callout = customType(d3NoteText, {
  className: "callout",
  note: { lineType: "horizontal" }
});

var d3CalloutElbow = customType(d3Callout, {
  className: "callout elbow",
  connector: { type: "elbow" }
});

var d3CalloutCurve = customType(d3Callout, {
  className: "callout curve",
  connector: { type: "curve" }
});

var d3Badge = customType(Type, {
  className: "badge",
  subject: { type: "badge" },
  disable: ["connector", "note"]
});

var d3CalloutCircle = customType(d3NoteText, {
  className: "callout circle",
  subject: { type: "circle" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var d3CalloutRect = customType(d3NoteText, {
  className: "callout rect",
  subject: { type: "rect" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var ThresholdMap = function (_d3Callout) {
  inherits(ThresholdMap, _d3Callout);

  function ThresholdMap() {
    classCallCheck(this, ThresholdMap);
    return possibleConstructorReturn(this, (ThresholdMap.__proto__ || Object.getPrototypeOf(ThresholdMap)).apply(this, arguments));
  }

  createClass(ThresholdMap, [{
    key: "mapY",
    value: function mapY(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapY", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {
        a.y = accessors.y(a.data);
      }
      if ((a.subject.x1 || a.subject.x2) && !a.x) {
        a.x = a.subject.x1 || a.subject.x2;
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapX", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {
        a.x = accessors.x(a.data);
      }
      if ((a.subject.y1 || a.subject.y2) && !a.y) {
        a.y = a.subject.y1 || a.subject.y2;
      }
    }
  }]);
  return ThresholdMap;
}(d3Callout);

var d3XYThreshold = customType(ThresholdMap, {
  className: "callout xythreshold",
  subject: { type: "threshold" }
});

var newWithClass = function newWithClass(a, d, type, className, classID) {
  var group = a.selectAll(type + "." + (classID || className)).data(d);
  group.enter().append(type).merge(group).attr("class", className);

  group.exit().remove();
  return a;
};

var addHandlers = function addHandlers(dispatcher, annotation, _ref3) {
  var component = _ref3.component,
      name = _ref3.name;

  if (component) {
    component.on("mouseover.annotations", function () {
      dispatcher.call(name + "over", component, annotation);
    }).on("mouseout.annotations", function () {
      return dispatcher.call(name + "out", component, annotation);
    }).on("click.annotations", function () {
      return dispatcher.call(name + "click", component, annotation);
    });
  }
};

//Text wrapping code adapted from Mike Bostock
var wrap = function wrap(text, width, wrapSplitter) {
  var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.2;

  text.each(function () {
    var text = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this),
        words = text.text().split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
      return w !== "";
    });
    var word = void 0,
        line$$1 = [],
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", 0.8 + "em");

    while (word = words.pop()) {
      line$$1.push(word);
      tspan.text(line$$1.join(" "));
      if (tspan.node().getComputedTextLength() > width && line$$1.length > 1) {
        line$$1.pop();
        tspan.text(line$$1.join(" "));
        line$$1 = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + "em").text(word);
      }
    }
  });
};

var bboxWithoutHandles = function bboxWithoutHandles(selection) {
  var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ":not(.handle)";

  if (!selection) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }

  return selection.selectAll(selector).nodes().reduce(function (p, c) {
    var bbox = c.getBBox();
    p.x = Math.min(p.x, bbox.x);
    p.y = Math.min(p.y, bbox.y);
    p.width = Math.max(p.width, bbox.width);

    var yOffset = c && c.attributes && c.attributes.y;
    p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
    return p;
  }, { x: 0, y: 0, width: 0, height: 0 });
};

function annotation() {
  var annotations = [],
      collection = void 0,
      context = void 0,
      //TODO: add canvas functionality
  disable = [],
      accessors = {},
      accessorsInverse = {},
      editMode = false,
      ids = void 0,
      type = d3Callout,
      textWrap = void 0,
      notePadding = void 0,
      annotationDispatcher = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_3__.dispatch)("subjectover", "subjectout", "subjectclick", "connectorover", "connectorout", "connectorclick", "noteover", "noteout", "noteclick", "dragend", "dragstart"),
      sel = void 0;

  var annotation = function annotation(selection) {
    sel = selection;
    //TODO: check to see if this is still needed
    if (!editMode) {
      selection.selectAll("circle.handle").remove();
    }

    var translatedAnnotations = annotations.map(function (a) {
      if (!a.type) {
        a.type = type;
      }
      if (!a.disable) {
        a.disable = disable;
      }
      return new Annotation(a);
    });

    collection = collection || new AnnotationCollection({
      annotations: translatedAnnotations,
      accessors: accessors,
      accessorsInverse: accessorsInverse,
      ids: ids
    });

    var annotationG = selection.selectAll("g").data([collection]);
    annotationG.enter().append("g").attr("class", "annotations");

    var group = selection.select("g.annotations");
    newWithClass(group, collection.annotations, "g", "annotation");

    var annotation = group.selectAll("g.annotation");

    annotation.each(function (d) {
      var a = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this);

      a.attr("class", "annotation");

      newWithClass(a, [d], "g", "annotation-connector");
      newWithClass(a, [d], "g", "annotation-subject");
      newWithClass(a, [d], "g", "annotation-note");
      newWithClass(a.select("g.annotation-note"), [d], "g", "annotation-note-content");
      d.type = d.type.toString() === "[object Object]" ? d.type : new d.type({
        a: a,
        annotation: d,
        textWrap: textWrap,
        notePadding: notePadding,
        editMode: editMode,
        dispatcher: annotationDispatcher,
        accessors: accessors
      });
      d.type.draw();
      d.type.drawText && d.type.drawText();
    });
  };

  annotation.json = function () {
    /* eslint-disable no-console */
    console.log("Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.", collection.json);
    /* eslint-enable no-console */
    window.copy(JSON.stringify(collection.json.map(function (a) {
      delete a.type;
      return a;
    })));
    return annotation;
  };

  annotation.update = function () {
    if (annotations && collection) {
      annotations = collection.annotations.map(function (a) {
        a.type.draw();
        return a;
      });
    }
    return annotation;
  };

  annotation.updateText = function () {
    if (collection) {
      collection.updateText(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.updatedAccessors = function () {
    collection.setPositionWithAccessors();
    annotations = collection.annotations;
    return annotation;
  };

  annotation.disable = function (_) {
    if (!arguments.length) return disable;
    disable = _;
    if (collection) {
      collection.updateDisable(disable);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    if (collection) {
      collection.updateTextWrap(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.notePadding = function (_) {
    if (!arguments.length) return notePadding;
    notePadding = _;
    if (collection) {
      collection.updateNotePadding(notePadding);
      annotations = collection.annotations;
    }
    return annotation;
  };
  //todo think of how to handle when undefined is sent
  annotation.type = function (_, settings) {
    if (!arguments.length) return type;
    type = _;
    if (collection) {
      collection.annotations.map(function (a) {
        a.type.note && a.type.note.selectAll("*:not(.annotation-note-content)").remove();
        a.type.noteContent && a.type.noteContent.selectAll("*").remove();
        a.type.subject && a.type.subject.selectAll("*").remove();
        a.type.connector && a.type.connector.selectAll("*").remove();
        a.type.typeSettings = {};
        a.type = type;

        a.subject = settings && settings.subject || a.subject;
        a.connector = settings && settings.connector || a.connector;
        a.note = settings && settings.note || a.note;
      });

      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.annotations = function (_) {
    if (!arguments.length) return collection && collection.annotations || annotations;
    annotations = _;

    if (collection && collection.annotations) {
      var rerun = annotations.some(function (d) {
        return !d.type || d.type.toString() !== "[object Object]";
      });

      if (rerun) {
        collection = null;
        annotation(sel);
      } else {
        collection.annotations = annotations;
      }
    }
    return annotation;
  };

  annotation.context = function (_) {
    if (!arguments.length) return context;
    context = _;
    return annotation;
  };

  annotation.accessors = function (_) {
    if (!arguments.length) return accessors;
    accessors = _;
    return annotation;
  };

  annotation.accessorsInverse = function (_) {
    if (!arguments.length) return accessorsInverse;
    accessorsInverse = _;
    return annotation;
  };

  annotation.ids = function (_) {
    if (!arguments.length) return ids;
    ids = _;
    return annotation;
  };

  annotation.editMode = function (_) {
    if (!arguments.length) return editMode;
    editMode = _;

    if (sel) {
      sel.selectAll("g.annotation").classed("editable", editMode);
    }

    if (collection) {
      collection.editMode(editMode);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.collection = function (_) {
    if (!arguments.length) return collection;
    collection = _;
    return annotation;
  };

  annotation.on = function () {
    var value = annotationDispatcher.on.apply(annotationDispatcher, arguments);
    return value === annotationDispatcher ? annotation : value;
  };

  return annotation;
}

var index = {
  annotation: annotation,
  annotationTypeBase: Type,
  annotationLabel: d3Label,
  annotationCallout: d3Callout,
  annotationCalloutCurve: d3CalloutCurve,
  annotationCalloutElbow: d3CalloutElbow,
  annotationCalloutCircle: d3CalloutCircle,
  annotationCalloutRect: d3CalloutRect,
  annotationXYThreshold: d3XYThreshold,
  annotationBadge: d3Badge,
  annotationCustomType: customType
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);
//# sourceMappingURL=indexRollupNext.js.map


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dispatch: () => (/* reexport safe */ _src_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js");



/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.x, y: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__.dispatch)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__.mouse, this, arguments);
    if (!gesture) return;
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
    mousemoving = false;
    mousedownx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX;
    mousedowny = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    if (!mousemoving) {
      var dx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX - mousedownx, dy = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag mouseup.drag", null);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__.yesdrag)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view, mousemoving);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__.touch, this, arguments)) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragEvent)
/* harmony export */ });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drag: () => (/* reexport safe */ _drag__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   dragDisable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   dragEnable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__.yesdrag)
/* harmony export */ });
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");




/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (path);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clientPoint: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   create: () => (/* reexport safe */ _create__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   creator: () => (/* reexport safe */ _creator__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   customEvent: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.customEvent),
/* harmony export */   event: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.event),
/* harmony export */   local: () => (/* reexport safe */ _local__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   matcher: () => (/* reexport safe */ _matcher__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mouse: () => (/* reexport safe */ _mouse__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   namespace: () => (/* reexport safe */ _namespace__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   namespaces: () => (/* reexport safe */ _namespaces__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   select: () => (/* reexport safe */ _select__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   selectAll: () => (/* reexport safe */ _selectAll__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   selection: () => (/* reexport safe */ _selection_index__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   selector: () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   selectorAll: () => (/* reexport safe */ _selectorAll__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   style: () => (/* reexport safe */ _selection_style__WEBPACK_IMPORTED_MODULE_13__.styleValue),
/* harmony export */   touch: () => (/* reexport safe */ _touch__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   touches: () => (/* reexport safe */ _touches__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   window: () => (/* reexport safe */ _window__WEBPACK_IMPORTED_MODULE_16__["default"])
/* harmony export */ });
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js");
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mouse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js");
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _selection_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./touch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js");
/* harmony import */ var _touches__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./touches */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js");
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");




















/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ local)
/* harmony export */ });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  var event = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js");




var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./join */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sort */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./call */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodes */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./node */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./size */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./empty */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./each */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./property */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classed */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./text */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./html */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./raise */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lower */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./append */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./insert */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./datum */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js");
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  join: _join__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_8__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_9__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_10__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_11__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_12__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_13__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_14__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_15__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_16__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_17__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_18__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_19__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_20__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_21__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_22__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_23__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_24__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_25__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_26__["default"],
  clone: _clone__WEBPACK_IMPORTED_MODULE_27__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_28__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_29__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_30__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customEvent: () => (/* binding */ customEvent),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   event: () => (/* binding */ event)
/* harmony export */ });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches) {
  if (touches == null) touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arc: () => (/* reexport safe */ _src_arc__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   area: () => (/* reexport safe */ _src_area__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   curveBasis: () => (/* reexport safe */ _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   curveBasisClosed: () => (/* reexport safe */ _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   curveBasisOpen: () => (/* reexport safe */ _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   curveBundle: () => (/* reexport safe */ _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   curveCardinal: () => (/* reexport safe */ _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   curveCardinalClosed: () => (/* reexport safe */ _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   curveCardinalOpen: () => (/* reexport safe */ _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   curveCatmullRom: () => (/* reexport safe */ _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   curveCatmullRomClosed: () => (/* reexport safe */ _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   curveCatmullRomOpen: () => (/* reexport safe */ _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   curveLinear: () => (/* reexport safe */ _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   curveLinearClosed: () => (/* reexport safe */ _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   curveMonotoneX: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneX),
/* harmony export */   curveMonotoneY: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneY),
/* harmony export */   curveNatural: () => (/* reexport safe */ _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   curveStep: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   curveStepAfter: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepAfter),
/* harmony export */   curveStepBefore: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepBefore),
/* harmony export */   line: () => (/* reexport safe */ _src_line__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   pie: () => (/* reexport safe */ _src_pie__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   radialArea: () => (/* reexport safe */ _src_radialArea__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   radialLine: () => (/* reexport safe */ _src_radialLine__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   stack: () => (/* reexport safe */ _src_stack__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   stackOffsetExpand: () => (/* reexport safe */ _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   stackOffsetNone: () => (/* reexport safe */ _src_offset_none__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   stackOffsetSilhouette: () => (/* reexport safe */ _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   stackOffsetWiggle: () => (/* reexport safe */ _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   stackOrderAscending: () => (/* reexport safe */ _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   stackOrderDescending: () => (/* reexport safe */ _src_order_descending__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   stackOrderInsideOut: () => (/* reexport safe */ _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   stackOrderNone: () => (/* reexport safe */ _src_order_none__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   stackOrderReverse: () => (/* reexport safe */ _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   symbol: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   symbolCircle: () => (/* reexport safe */ _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   symbolCross: () => (/* reexport safe */ _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   symbolDiamond: () => (/* reexport safe */ _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   symbolSquare: () => (/* reexport safe */ _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   symbolStar: () => (/* reexport safe */ _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   symbolTriangle: () => (/* reexport safe */ _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   symbolWye: () => (/* reexport safe */ _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   symbols: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__.symbols)
/* harmony export */ });
/* harmony import */ var _src_arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/arc */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js");
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _src_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _src_pie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pie */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js");
/* harmony import */ var _src_radialArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/radialArea */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js");
/* harmony import */ var _src_radialLine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");
/* harmony import */ var _src_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/symbol */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/curve/basisClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/curve/basisOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/curve/basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/curve/bundle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/curve/cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/curve/cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/curve/cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/curve/catmullRomClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/curve/catmullRomOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/curve/catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/curve/linearClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/curve/monotone */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/curve/natural */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var _src_curve_step__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/curve/step */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var _src_stack__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/stack */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js");
/* harmony import */ var _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/offset/expand */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js");
/* harmony import */ var _src_offset_none__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/offset/silhouette */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js");
/* harmony import */ var _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/offset/wiggle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js");
/* harmony import */ var _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/order/ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");
/* harmony import */ var _src_order_descending__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/order/descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js");
/* harmony import */ var _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/order/insideOut */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js");
/* harmony import */ var _src_order_none__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/order/reverse */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js");












































/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function asin(x) {
  return x >= 1 ? _math__WEBPACK_IMPORTED_MODULE_1__.halfPi : x <= -1 ? -_math__WEBPACK_IMPORTED_MODULE_1__.halfPi : Math.asin(x);
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        da = Math.abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_2__["default"])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math__WEBPACK_IMPORTED_MODULE_1__.tau - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
      context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
          rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var p0 = asin(rp / r0 * Math.sin(ap)),
            p1 = asin(rp / r1 * Math.sin(ap));
        if ((da0 -= p0 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Math.cos(a01),
          y01 = r1 * Math.sin(a01),
          x10 = r0 * Math.cos(a10),
          y10 = r0 * Math.sin(a10);

      // Apply rounded corners?
      if (rc > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var x11 = r1 * Math.cos(a11),
            y11 = r1 * Math.sin(a11),
            x00 = r0 * Math.cos(a00),
            y00 = r0 * Math.sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < _math__WEBPACK_IMPORTED_MODULE_1__.pi) {
          var oc = da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
              lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) || !(da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math__WEBPACK_IMPORTED_MODULE_1__.pi / 2;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x0 = _point__WEBPACK_IMPORTED_MODULE_3__.x,
      x1 = null,
      y0 = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      y1 = _point__WEBPACK_IMPORTED_MODULE_3__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line__WEBPACK_IMPORTED_MODULE_2__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Basis: () => (/* binding */ Basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Basis(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisOpen(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cardinal: () => (/* binding */ Cardinal),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalClosed: () => (/* binding */ CardinalClosed),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalOpen: () => (/* binding */ CardinalOpen),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal__WEBPACK_IMPORTED_MODULE_1__.Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_2__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new LinearClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   monotoneX: () => (/* binding */ monotoneX),
/* harmony export */   monotoneY: () => (/* binding */ monotoneY)
/* harmony export */ });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Natural(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   curveRadialLinear: () => (/* binding */ curveRadialLinear),
/* harmony export */   "default": () => (/* binding */ curveRadial)
/* harmony export */ });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");


var curveRadialLinear = curveRadial(_linear__WEBPACK_IMPORTED_MODULE_0__["default"]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   stepAfter: () => (/* binding */ stepAfter),
/* harmony export */   stepBefore: () => (/* binding */ stepBefore)
/* harmony export */ });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x = _point__WEBPACK_IMPORTED_MODULE_2__.x,
      y = _point__WEBPACK_IMPORTED_MODULE_2__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_3__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sum: () => (/* binding */ sum)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var sums = series.map(sum);
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending__WEBPACK_IMPORTED_MODULE_1__.sum),
      order = (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_2__["default"],
      sortValues = _descending__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      endAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(_math__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _radialLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var a = (0,_area__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return a;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   radialLine: () => (/* binding */ radialLine)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");



function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return radialLine((0,_line__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _offset_none__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _order_none__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var keys = (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([]),
      order = _order_none__WEBPACK_IMPORTED_MODULE_3__["default"],
      offset = _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"],
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? _order_none__WEBPACK_IMPORTED_MODULE_3__["default"] : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"] : _, stack) : offset;
  };

  return stack;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   symbols: () => (/* binding */ symbols)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _symbol_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_star__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye__WEBPACK_IMPORTED_MODULE_6__["default"]
];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var type = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"]),
      size = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_8__["default"])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / Math.sin(7 * _math__WEBPACK_IMPORTED_MODULE_0__.pi / 10),
    kx = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr,
    ky = -Math.cos(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var sqrt3 = Math.sqrt(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./node_modules/internmap/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/internmap/src/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternMap: () => (/* binding */ InternMap),
/* harmony export */   InternSet: () => (/* binding */ InternSet)
/* harmony export */ });
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (entries != null) for (const [key, value] of entries) this.set(key, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}

class InternSet extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (values != null) for (const value of values) this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
}

function intern_get({_intern, _key}, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}

function intern_delete({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}

function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}


/***/ }),

/***/ "./node_modules/jsonstat-toolkit/import.mjs":
/*!**************************************************!*\
  !*** ./node_modules/jsonstat-toolkit/import.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ r)
/* harmony export */ });
// jsonstat-toolkit v1.5.3 Copyright 2024 Xavier Badosa https://jsonstat.com
function t(i,r){var l,s,a,o,u=function(t,i,r){if(0===Object.entries(t).length)return null;var l,s=[];if(r&&!n(r.name)&&(r=null),"string"==typeof t&&(t=[t]),Array.isArray(t)||e(t)){if(t.length===i)return r&&-1===t.findIndex((function(t){return null==t}))?r.from(t):t;if(1===t.length){for(l=0;l<i;l++)s.push(t[0]);return s}}for(l=0;l<i;l++){var a=void 0===t[l]?null:t[l];s.push(a)}return s};if(this.length=0,this.id=[],null!=i)switch(this.class=i.class||"bundle",this.class){case"bundle":var h=[],f=0;if(this.error=null,this.length=0,null===i||"object"!=typeof i)return void(this.class=null);if(i.hasOwnProperty("error"))return void(this.error=i.error);if("dataset"===i.class||"collection"===i.class||"dimension"===i.class)return new t(i);for(s in i)f++,h.push(s);this.__tree__=i,this.length=f,this.id=h;break;case"dataset":i.hasOwnProperty("__tree__")?this.__tree__=l=i.__tree__:this.__tree__=l=i,this.label=l.label||null,this.note=l.note||null,this.link=l.link||null,this.href=l.href||null,this.updated=l.updated||null,this.source=l.source||null,this.extension=l.extension||null;var c,d=0,v=l.size||l.dimension&&l.dimension.size;if(this.size=v,this.value=l.hasOwnProperty("value")&&null!==l.value&&0!==l.value.length?l.value:{},Array.isArray(this.value)||e(this.value))d=this.value.length;else{var y=1;for(c=v.length;c--;)y*=v[c];d=y}if(this.value=u(this.value,d,r),this.status=l.hasOwnProperty("status")&&null!==l.status?u(l.status,d):null,l.hasOwnProperty("dimension")){var p=l.dimension,g=l.role||!l.version&&p.role||null,b=l.id||p.id,m=v.length,_=function(t){g.hasOwnProperty(t)||(g[t]=null)};if(!Array.isArray(b)||!Array.isArray(v)||b.length!=m)return;if(this.length=m,this.id=b,g&&(_("time"),_("geo"),_("metric"),_("classification")),g&&null===g.classification){var x=[],O=["time","geo","metric"],A=function(t,e){for(var n=e.length;n--;)if(t===e[n])return!0;return!1};for(c=0;c<3;c++){var w=g[O[c]];null!==w&&(x=x.concat(w))}for(g.classification=[],c=0;c<m;c++)A(b[c],x)||g.classification.push(b[c]);0===g.classification.length&&(g.classification=null)}this.role=g,this.n=d;for(var j=0,k=this.length;j<k;j++)if(p[b[j]].category.hasOwnProperty("index")){if(Array.isArray(p[b[j]].category.index)){var D={},P=p[b[j]].category.index;for(a=P.length,o=0;o<a;o++)D[P[o]]=o;p[b[j]].category.index=D}}else{var E=0;for(s in p[b[j]].category.index={},p[b[j]].category.label)p[b[j]].category.index[s]=E++}}else this.length=0;break;case"dimension":if(!i.hasOwnProperty("__tree__"))return new t({version:"2.0",class:"dataset",dimension:{d:i},id:["d"],size:[function(t){var e=void 0===t.index?t.label:t.index;return Array.isArray(e)?e.length:Object.keys(e).length}(i.category)],value:[null]}).Dimension(0);var z=[],S=(l=i.__tree__).category;if(!l.hasOwnProperty("category"))return;if(!S.hasOwnProperty("label"))for(s in S.label={},S.index)S.label[s]=s;for(s in S.index)z[S.index[s]]=s;this.__tree__=l,this.label=l.label||null,this.note=l.note||null,this.link=l.link||null,this.href=l.href||null,this.id=z,this.length=z.length,this.role=i.role,this.hierarchy=S.hasOwnProperty("child"),this.extension=l.extension||null;break;case"category":var I=i.child;this.id=I,this.length=null===I?0:I.length,this.index=i.index,this.label=i.label,this.note=i.note||null,this.unit=i.unit,this.coordinates=i.coord;break;case"collection":if(this.length=0,this.label=i.label||null,this.note=i.note||null,this.link=i.link||null,this.href=i.href||null,this.updated=i.updated||null,this.source=i.source||null,this.extension=i.extension||null,null!==this.link&&i.link.item){var C=i.link.item;if(this.length=Array.isArray(C)?C.length:0,this.length)for(o=0;o<this.length;o++)this.id[o]=C[o].href}}}function e(t){return"[object ArrayBuffer]"===Object.prototype.toString.call(t.buffer)}function n(t){return-1!==["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"].indexOf(t)}function i(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.json()}function r(e,n,r){var l="object"==typeof n?n:null;return"function"!=typeof r&&(r=null),r||"function"!=typeof n||(r=n),"object"==typeof e?new t(e,r):"version"===e?"1.5.3":fetch?fetch(e,l).then(i).then((function(e){return new t(e,r)})):void 0}t.prototype.Item=function(t){if(null===this||"collection"!==this.class||!this.length)return null;if("number"==typeof t)return t>this.length||t<0?null:this.link.item[t];var e,n=[];if("object"==typeof t){if(!t.class&&!t.follow)return null;t.class&&(e="dataset"===t.class&&"boolean"==typeof t.embedded?!0===t.embedded?function(t,e,i){var r=t.link.item[e];i.class===r.class&&r.id&&r.size&&r.dimension&&n.push(r)}:function(t,e,i){var r=t.link.item[e];i.class!==r.class||r.id&&r.size&&r.dimension||n.push(r)}:function(t,e,i){i.class===t.link.item[e].class&&n.push(t.link.item[e])})}else e=function(t,e){n.push(t.link.item[e])};for(var i=0;i<this.length;i++)e(this,i,t);return n},t.prototype.Dataset=function(e){if(null===this)return null;if("dataset"===this.class)return void 0!==e?this:[this];var n,i=[],r=0;if("collection"===this.class){var l=this.Item({class:"dataset",embedded:!0});if(void 0===e){for(n=l.length;r<n;r++)i.push(new t(l[r]));return i}if("number"==typeof e&&e>=0&&e<l.length)return new t(l[e]);if("string"==typeof e)for(n=l.length;r<n;r++)if(l[r].href===e)return new t(l[r]);return null}if("bundle"!==this.class)return null;if(void 0===e){for(n=this.id.length;r<n;r++)i.push(this.Dataset(this.id[r]));return i}if("number"==typeof e){var s=this.id[e];return void 0!==s?this.Dataset(s):null}var a=this.__tree__[e];return void 0===a?null:new t({class:"dataset",__tree__:a})},t.prototype.Dimension=function(e,n){n="boolean"!=typeof n||n;var i,r=[],l=this.id.length,s=function(t,e){if(null!==t)for(var n in t)for(var i=null!==t[n]?t[n].length:0;i--;)if(t[n][i]===e)return n;return null};if(null===this||"dataset"!==this.class)return null;if(void 0===e){for(i=0;i<l;i++)r.push(this.Dimension(this.id[i]));return r}if("number"==typeof e){var a=this.id[e];return void 0!==a?this.Dimension(a,n):null}var o=this.role;if("object"==typeof e){if(e.hasOwnProperty("role")){for(i=0;i<l;i++){var u=this.id[i];s(o,u)===e.role&&r.push(this.Dimension(u,n))}return void 0===r[0]?null:r}return null}var h=this.__tree__.dimension;if(void 0===h)return null;var f=h[e];return void 0===f?null:n?new t({class:"dimension",__tree__:f,role:s(o,e)}):function(t,e){var n=[];for(var i in t)n[t[i]]=e[i];return n}(f.category.index,f.category.label)},t.prototype.Category=function(e){if(null===this||"dimension"!==this.class)return null;if(void 0===e){for(var n=[],i=0,r=this.id.length;i<r;i++)n.push(this.Category(this.id[i]));return n}if("number"==typeof e){var l=this.id[e];return void 0!==l?this.Category(l):null}var s=this.__tree__.category;if(void 0===s)return null;var a=s.index[e];if(void 0===a)return null;var o=s.unit&&s.unit[e]||null,u=s.coordinates&&s.coordinates[e]||null,h=s.child&&s.child[e]||null,f=s.note&&s.note[e]||null;return new t({class:"category",index:a,label:s.label[e],note:f,child:h,unit:o,coord:u})},t.prototype.Dice=function(n,i,r){var l,s,a,o,u=function(t,e){return t.hasOwnProperty(e)&&!!t[e]};if(null===this||"dataset"!==this.class||null===this.value)return null;if("object"!=typeof n)return this;"object"!=typeof i?("boolean"==typeof i&&!0===i&&(l=!0),"boolean"==typeof r&&!0===r||(r=!1)):(l=u(i,"clone"),r=u(i,"drop"),s=u(i,"stringify"),a=u(i,"ovalue"),o=u(i,"ostatus"));var h,f=this.value,c=l?new t(JSON.parse(JSON.stringify(this))):this,d=c.status,v=[],y=[],p=function(t,e){var n,i,r,l=(n=t,i=e,r={},Array.isArray(n[i])?(n[i].forEach((function(t,e){null!==t&&(r[String(e)]=t)})),r):n[i]);delete t[e],t[e]=l};Array.isArray(n)&&(n=function(t){var e={};return t.forEach((function(t){e[t[0]]=t[1]})),e}(n)),null===n&&(n={});var g=Object.keys(n);return g.length>0&&(g.forEach((function(t){var e=n[t];Array.isArray(e)||(n[t]=[e]),0===n[t].length&&delete n[t]})),r&&(n=function(t){var e={};return Object.keys(t).forEach((function(n){e[n]=c.Dimension(n).id.filter((function(e){return-1===t[n].indexOf(e)}))})),e}(n)),c.toTable({type:"arrobj",content:"id",status:!0}).forEach((function(t,e){var i=[];g.forEach((function(e){var r=n[e],l=[];r.forEach((function(n){l.push(t[e]===n)})),i.push(-1!==l.indexOf(!0))})),-1===i.indexOf(!1)&&(v.push(t.value),y.push(t.status))})),g.forEach((function(t){var e=c.Dimension(t).id,i=0,r={};c.size[c.id.indexOf(t)]=n[t].length,e.forEach((function(e){-1!==n[t].indexOf(e)&&(r[e]=i,i++)})),c.__tree__.dimension[t].category.index=r})),c.n=v.length,c.value=c.__tree__.value=e(f)?function(t,e){return e.from(t)}(v,f.constructor):v,c.status=c.__tree__.status=null!==d?y:null),s?((h=c.__tree__).hasOwnProperty("id")||(h.version="2.0",h.hasOwnProperty("class")||(h.class="dataset"),h.id=h.dimension.id,h.size=h.dimension.size,delete h.dimension.id,delete h.dimension.size,h.dimension.hasOwnProperty("role")&&(h.role=h.dimension.role,delete h.dimension.role)),h.hasOwnProperty("status")&&-1!==["null","{}","[]"].indexOf(JSON.stringify(h.status))&&delete h.status,h.hasOwnProperty("role")&&(delete h.role.classification,["geo","time","metric"].forEach((function(t){null===h.role[t]&&delete h.role[t]}))),a&&p(h,"value"),o&&h.hasOwnProperty("status")&&p(h,"status"),JSON.stringify(h)):c},t.prototype.Slice=function(t){if(null===this||"dataset"!==this.class||0===Object.entries(this.value).length)return null;if(void 0===t)return this;if(!Array.isArray(t)){var e,n=[];for(e in t)n.push([e,t[e]]);t=n}return this.Dice(t.map((function(t){return[t[0],[t[1]]]})))},t.prototype.Data=function(t,e){var n,i,r=[],l=function(t){for(var e in t)if(t.hasOwnProperty(e))return e};if(null===this||"dataset"!==this.class||null===this.value)return null;if(void 0===t){for(i=this.value.length,n=0;n<i;n++)r.push(this.Data(n));return r}if("boolean"!=typeof e&&(e=!0),"number"==typeof t){var s=this.value[t];return void 0===s?null:e?{value:s,status:this.status?this.status[t]:null}:s}var a="object",o=this.__tree__,u=o.size||o.dimension&&o.dimension.size,h=u.length;if(Array.isArray(t)){if(!Array.isArray(t[0])){if(this.length!==t.length)return null;var f=1,c=0,d=[],v=[];for(n=0;n<h;n++)if(void 0!==t[n]){if("number"!=typeof t[n]||t[n]>=u[n])return null;c+=(f*=n>0?u[h-n]:1)*t[h-n-1]}else d.push(n),v.push(u[n]);if(d.length>1)return null;if(1===d.length){for(var y=0,p=v[0];y<p;y++){var g=[];for(n=0;n<h;n++)n!==d[0]?g.push(t[n]):g.push(y);r.push(this.Data(g,e))}return r}return e?{value:this.value[c],status:this.status?this.status[c]:null}:this.value[c]}a="array"}var b=function(t,e,n){var i,r=[],s={},a=t.dimension,o=t.id||a.id,u=t.size||a&&a.size;if("array"===n){for(i=e.length;i--;)s[e[i][0]]=e[i][1];e=s}for(var h=0,f=o.length;h<f;h++){var c=o[h],d=e[c];r.push("string"==typeof d?d:1===u[h]?l(a[c].category.index):null)}return r}(o,t,a),m=[],_=o.dimension,x=o.id||_.id;for(n=0,i=b.length;n<i;n++)m.push(_[x[n]].category.index[b[n]]);return this.Data(m,e)},t.prototype.toTable=function(t,e){if(null===this||"dataset"!==this.class||null===this.value)return null;1==arguments.length&&"function"==typeof t&&(e=t,t=null),"arrobj"!==(t=t||{field:"label",content:"label",vlabel:"Value",slabel:"Status",type:"array",status:!1,unit:!1,by:null,prefix:"",drop:[],meta:!1,comma:!1,bylabel:!1}).type&&"objarr"!==t.type||void 0!==t.field||(t.field="id");var i,r,l,s,a,o,u,h,f,c="id"===t.field,d=function(t){return(c?"value":t)||"Value"},v=function(t){return(c?"status":t)||"Status"},y=this.__tree__,p=!0===t.status;if("function"==typeof e){i=this.toTable(t);var g=[],b="array"!==t.type?0:1;for(a=(V="object"!==t.type?i.slice(b):i.rows.slice(0)).length,r=0;r<a;r++){var m=e.call(this,V[r],r);void 0!==m&&g.push(m)}return"object"===t.type?{cols:i.cols,rows:g}:("array"===t.type&&g.unshift(i[0]),g)}if("arrobj"===t.type||"objarr"===t.type){var _=[],x=y.role&&y.role.metric,O=function(){},A={},w=this,j=w.id,k=t.by&&-1!==j.indexOf(t.by)?t.by:null,D=!0===t.meta,P=void 0!==t.drop&&Array.isArray(t.drop)?t.drop:[],E=!0===t.comma,z=!0===t.bylabel,S=w.value.constructor,I=function(e){var i,r={},l=d(t.vlabel);if("objarr"===t.type&&(i=null===k&&n(S.name)?function(t){r[t]=t===l?S.from(e,(function(e){return e[t]})):e.map((function(e){return e[t]}))}:function(t){r[t]=e.map((function(e){return e[t]}))},Object.keys(e[0]).forEach(i),e=r),D){r={};return j.forEach((function(t){var e=w.Dimension(t);r[t]={label:e.label,role:e.role,categories:{id:e.id,label:w.Dimension(t,!1)}}})),{meta:{label:w.label,source:w.source,updated:w.updated,id:j,status:p,unit:t.unit,by:k,bylabel:z,drop:null!==k&&P.length>0?P:null,prefix:null!==k?G||"":null,comma:E,dimensions:r},data:e}}return e};k&&(t.field="id");var C=(i=this.toTable({field:t.field,vlabel:t.vlabel,slabel:t.slabel,content:t.content,status:p})).shift();if(null===k&&t.unit&&x){if("id"!==t.content)for(var T=x.length;T--;){var U=this.Dimension(x[T]);A[x[T]]={};for(var J=U.length;J--;)A[x[T]][U.Category(J).label]=U.id[J]}O=function(e,n){if(-1!==x.indexOf(e)){var i=y.dimension[e].category;i.unit?N.unit=i.unit["id"!==t.content?A[e][n]:n]:N.unit=null}},t.unit=!0}else t.unit=!1;for(a=i.length,r=0;r<a;r++){var N={};for(l=i[r].length;l--;)N[C[l]]=i[r][l],O(C[l],i[r][l]);_.push(N)}if(E&&_.forEach((function(t){null!==t.value&&(t.value=(""+t.value).replace(".",","))})),null!==k){var B,F={},V=[],q={},G=void 0!==t.prefix?t.prefix:"";P.forEach((function(t,e){(!w.Dimension(t)||w.Dimension(t).length>1)&&(P[e]="")}));var H=j.filter((function(t){return t!==k&&-1===P.indexOf(t)})),K=w.Dimension(k);for(var L in"id"!==t.content?z?B=function(t,e,n){t[e][G+n[k]]=n.value}:(K.Category().forEach((function(t,e){q[t.label]=K.id[e]})),B=function(t,e,n){t[e][G+q[n[k]]]=n.value}):B=function(t,e,n){t[e][G+n[k]]=n.value},_.forEach((function(t){var e=function(t,e){var n=[];return e.forEach((function(e){n.push(t[e])})),n.join("\t")}(t,H);void 0===F[e]&&(F[e]=function(t,e){var n={};return e.forEach((function(e){n[e]=t[e]})),n}(t,H)),B(F,e,t,k)})),F)V.push(F[L]);return p=!1,I(V)}return I(_)}if("object"===t.type){var M="number"==typeof this.value[0]||null===this.value[0]?"number":"string";o=function(t,e){var n=c&&t||e||t;it.push({id:t,label:n,type:"string"})},u=function(t,e,n){var i=d(t),r=v(e);n&&it.push({id:"status",label:r,type:"string"}),it.push({id:"value",label:i,type:M})},h=function(t){yt.push({v:t})},f=function(t){yt.push({v:t}),rt.push({c:yt})}}else o=function(t,e){var n=c&&t||e||t;it.push(n)},u=function(t,e,n){var i=d(t),r=v(e);n&&it.push(r),it.push(i),nt.push(it)},h=function(t){yt.push(t)},f=function(t){yt.push(t),nt.push(yt)};var Q=y.dimension,R=y.id||Q.id,W=y.size||Q.size,X=R.length;if(X!=W.length)return!1;var Y=[],Z=1,$=(T=1,[]),tt=[],et=[],nt=[],it=[],rt=[];for(r=0;r<X;r++){var lt=R[r];o(lt,Q[lt].label),Z*=W[r],T*=W[r];var st=[];for(l=0;l<W[r];l++)for(var at in Q[R[r]].category.index)if(Q[R[r]].category.index[at]===l){var ot="id"!==t.content&&Q[R[r]].category.label?Q[R[r]].category.label[at]:at;st.push(ot)}Y.push(st),$.push(T)}for(u(t.vlabel,t.slabel,p),a=Y.length,r=0;r<a;r++){for(var ut=[],ht=0,ft=Y[r].length;ht<ft;ht++)for(var ct=0;ct<Z/$[r];ct++)ut.push(Y[r][ht]);tt.push(ut)}for(a=tt.length,r=0;r<a;r++){var dt=[],vt=0;for(s=0;s<Z;s++)dt.push(tt[r][vt]),++vt===tt[r].length&&(vt=0);et.push(dt)}for(s=0;s<Z;s++){var yt=[];a=tt.length;for(var pt=0;pt<a;pt++)h(et[pt][s]);p&&h(this.status?this.status[s]:null),f(this.value[s])}return"object"===t.type?{cols:it,rows:rt}:nt},t.prototype.node=function(){return this.__tree__},t.prototype.toString=function(){return this.class};


/***/ }),

/***/ "./node_modules/simple-statistics/dist/simple-statistics.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/simple-statistics/dist/simple-statistics.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BayesianClassifier: () => (/* binding */ BayesianClassifier),
/* harmony export */   PerceptronModel: () => (/* binding */ PerceptronModel),
/* harmony export */   addToMean: () => (/* binding */ addToMean),
/* harmony export */   approxEqual: () => (/* binding */ approxEqual),
/* harmony export */   average: () => (/* binding */ mean),
/* harmony export */   averageSimple: () => (/* binding */ meanSimple),
/* harmony export */   bayesian: () => (/* binding */ BayesianClassifier),
/* harmony export */   bernoulliDistribution: () => (/* binding */ bernoulliDistribution),
/* harmony export */   binomialDistribution: () => (/* binding */ binomialDistribution),
/* harmony export */   bisect: () => (/* binding */ bisect),
/* harmony export */   chiSquaredDistributionTable: () => (/* binding */ chiSquaredDistributionTable),
/* harmony export */   chiSquaredGoodnessOfFit: () => (/* binding */ chiSquaredGoodnessOfFit),
/* harmony export */   chunk: () => (/* binding */ chunk),
/* harmony export */   ckmeans: () => (/* binding */ ckmeans),
/* harmony export */   coefficientOfVariation: () => (/* binding */ coefficientOfVariation),
/* harmony export */   combinations: () => (/* binding */ combinations),
/* harmony export */   combinationsReplacement: () => (/* binding */ combinationsReplacement),
/* harmony export */   combineMeans: () => (/* binding */ combineMeans),
/* harmony export */   combineVariances: () => (/* binding */ combineVariances),
/* harmony export */   cumulativeStdLogisticProbability: () => (/* binding */ cumulativeStdLogisticProbability),
/* harmony export */   cumulativeStdNormalProbability: () => (/* binding */ cumulativeStdNormalProbability),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   equalIntervalBreaks: () => (/* binding */ equalIntervalBreaks),
/* harmony export */   erf: () => (/* binding */ errorFunction),
/* harmony export */   errorFunction: () => (/* binding */ errorFunction),
/* harmony export */   extent: () => (/* binding */ extent),
/* harmony export */   extentSorted: () => (/* binding */ extentSorted),
/* harmony export */   factorial: () => (/* binding */ factorial),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   gammaln: () => (/* binding */ gammaln),
/* harmony export */   geometricMean: () => (/* binding */ geometricMean),
/* harmony export */   harmonicMean: () => (/* binding */ harmonicMean),
/* harmony export */   interquartileRange: () => (/* binding */ interquartileRange),
/* harmony export */   inverseErrorFunction: () => (/* binding */ inverseErrorFunction),
/* harmony export */   iqr: () => (/* binding */ interquartileRange),
/* harmony export */   jenks: () => (/* binding */ jenks),
/* harmony export */   kMeansCluster: () => (/* binding */ kMeansCluster),
/* harmony export */   kde: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   kernelDensityEstimation: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   linearRegression: () => (/* binding */ linearRegression),
/* harmony export */   linearRegressionLine: () => (/* binding */ linearRegressionLine),
/* harmony export */   logAverage: () => (/* binding */ logAverage),
/* harmony export */   logit: () => (/* binding */ logit),
/* harmony export */   mad: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   maxSorted: () => (/* binding */ maxSorted),
/* harmony export */   mean: () => (/* binding */ mean),
/* harmony export */   meanSimple: () => (/* binding */ meanSimple),
/* harmony export */   median: () => (/* binding */ median),
/* harmony export */   medianAbsoluteDeviation: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   medianSorted: () => (/* binding */ medianSorted),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   minSorted: () => (/* binding */ minSorted),
/* harmony export */   mode: () => (/* binding */ mode),
/* harmony export */   modeFast: () => (/* binding */ modeFast),
/* harmony export */   modeSorted: () => (/* binding */ modeSorted),
/* harmony export */   numericSort: () => (/* binding */ numericSort),
/* harmony export */   perceptron: () => (/* binding */ PerceptronModel),
/* harmony export */   permutationTest: () => (/* binding */ permutationTest),
/* harmony export */   permutationsHeap: () => (/* binding */ permutationsHeap),
/* harmony export */   poissonDistribution: () => (/* binding */ poissonDistribution),
/* harmony export */   probit: () => (/* binding */ probit),
/* harmony export */   product: () => (/* binding */ product),
/* harmony export */   quantile: () => (/* binding */ quantile),
/* harmony export */   quantileRank: () => (/* binding */ quantileRank),
/* harmony export */   quantileRankSorted: () => (/* binding */ quantileRankSorted),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted),
/* harmony export */   quickselect: () => (/* binding */ quickselect),
/* harmony export */   rSquared: () => (/* binding */ rSquared),
/* harmony export */   relativeError: () => (/* binding */ relativeError),
/* harmony export */   rms: () => (/* binding */ rootMeanSquare),
/* harmony export */   rootMeanSquare: () => (/* binding */ rootMeanSquare),
/* harmony export */   sample: () => (/* binding */ sample),
/* harmony export */   sampleCorrelation: () => (/* binding */ sampleCorrelation),
/* harmony export */   sampleCovariance: () => (/* binding */ sampleCovariance),
/* harmony export */   sampleKurtosis: () => (/* binding */ sampleKurtosis),
/* harmony export */   sampleRankCorrelation: () => (/* binding */ sampleRankCorrelation),
/* harmony export */   sampleSkewness: () => (/* binding */ sampleSkewness),
/* harmony export */   sampleStandardDeviation: () => (/* binding */ sampleStandardDeviation),
/* harmony export */   sampleVariance: () => (/* binding */ sampleVariance),
/* harmony export */   sampleWithReplacement: () => (/* binding */ sampleWithReplacement),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   shuffleInPlace: () => (/* binding */ shuffleInPlace),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   silhouette: () => (/* binding */ silhouette),
/* harmony export */   silhouetteMetric: () => (/* binding */ silhouetteMetric),
/* harmony export */   standardDeviation: () => (/* binding */ standardDeviation),
/* harmony export */   standardNormalTable: () => (/* binding */ standardNormalTable),
/* harmony export */   subtractFromMean: () => (/* binding */ subtractFromMean),
/* harmony export */   sum: () => (/* binding */ sum),
/* harmony export */   sumNthPowerDeviations: () => (/* binding */ sumNthPowerDeviations),
/* harmony export */   sumSimple: () => (/* binding */ sumSimple),
/* harmony export */   tTest: () => (/* binding */ tTest),
/* harmony export */   tTestTwoSample: () => (/* binding */ tTestTwoSample),
/* harmony export */   uniqueCountSorted: () => (/* binding */ uniqueCountSorted),
/* harmony export */   variance: () => (/* binding */ variance),
/* harmony export */   wilcoxonRankSum: () => (/* binding */ wilcoxonRankSum),
/* harmony export */   zScore: () => (/* binding */ zScore)
/* harmony export */ });
/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m;
    var b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0;
        var sumY = 0;
        var sumXX = 0;
        var sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point;
        var x;
        var y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    if (typeof sum !== "number") {
        return Number.NaN;
    }

    for (var i = 1; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    }
    if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0];
    // store the mode as we find new modes
    var value = Number.NaN;
    // store how many times we've seen the mode
    var maxSeen = 0;
    // how many times the current candidate for the mode
    // has been seen
    var seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n log(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // choose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample, randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0;
    var lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix[0].length - 1) {
        /* c8 ignore start */
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
        /* c8 ignore end */
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/*
 * Pull Breaks Values for Jenks
 *
 * the second part of the jenks recipe: take the calculated matrices
 * and derive an array of n breaks.
 *
 * @private
 */
function jenksBreaks(data, lowerClassLimits, nClasses) {
    var k = data.length;
    var kclass = [];
    var countNum = nClasses;

    // the calculation of classes will never include the upper
    // bound, so we need to explicitly set it
    kclass[nClasses] = data[data.length - 1];

    // the lowerClassLimits matrix is used as indices into itself
    // here: the `k` variable is reused in each iteration.
    while (countNum > 0) {
        kclass[countNum - 1] = data[lowerClassLimits[k][countNum] - 1];
        k = lowerClassLimits[k][countNum] - 1;
        countNum--;
    }

    return kclass;
}

/*
 * Compute Matrices for Jenks
 *
 * Compute the matrices required for Jenks breaks. These matrices
 * can be used for any classing of data with `classes <= nClasses`
 *
 * @private
 */
function jenksMatrices(data, nClasses) {
    // in the original implementation, these matrices are referred to
    // as `LC` and `OP`
    //
    // * lowerClassLimits (LC): optimal lower class limits
    // * varianceCombinations (OP): optimal variance combinations for all classes
    var lowerClassLimits = [];
    var varianceCombinations = [];
    // loop counters
    var i;
    var j;
    // the variance, as computed at each step in the calculation
    var variance = 0;

    // Initialize and fill each matrix with zeroes
    for (i = 0; i < data.length + 1; i++) {
        var tmp1 = [];
        var tmp2 = [];
        // despite these arrays having the same values, we need
        // to keep them separate so that changing one does not change
        // the other
        for (j = 0; j < nClasses + 1; j++) {
            tmp1.push(0);
            tmp2.push(0);
        }
        lowerClassLimits.push(tmp1);
        varianceCombinations.push(tmp2);
    }

    for (i = 1; i < nClasses + 1; i++) {
        lowerClassLimits[1][i] = 1;
        varianceCombinations[1][i] = 0;
        // in the original implementation, 9999999 is used but
        // since Javascript has `Infinity`, we use that.
        for (j = 2; j < data.length + 1; j++) {
            varianceCombinations[j][i] = Number.POSITIVE_INFINITY;
        }
    }

    for (var l = 2; l < data.length + 1; l++) {
        // `SZ` originally. this is the sum of the values seen thus
        // far when calculating variance.
        var sum = 0;
        // `ZSQ` originally. the sum of squares of values seen
        // thus far
        var sumSquares = 0;
        // `WT` originally. This is the number of
        var w = 0;
        // `IV` originally
        var i4 = 0;

        // in several instances, you could say `Math.pow(x, 2)`
        // instead of `x * x`, but this is slower in some browsers
        // introduces an unnecessary concept.
        for (var m = 1; m < l + 1; m++) {
            // `III` originally
            var lowerClassLimit = l - m + 1;
            var val = data[lowerClassLimit - 1];

            // here we're estimating variance for each potential classing
            // of the data, for each potential number of classes. `w`
            // is the number of data points considered so far.
            w++;

            // increase the current sum and sum-of-squares
            sum += val;
            sumSquares += val * val;

            // the variance at this point in the sequence is the difference
            // between the sum of squares and the total x 2, over the number
            // of samples.
            variance = sumSquares - (sum * sum) / w;

            i4 = lowerClassLimit - 1;

            if (i4 !== 0) {
                for (j = 2; j < nClasses + 1; j++) {
                    // if adding this element to an existing class
                    // will increase its variance beyond the limit, break
                    // the class at this point, setting the `lowerClassLimit`
                    // at this point.
                    if (
                        varianceCombinations[l][j] >=
                        variance + varianceCombinations[i4][j - 1]
                    ) {
                        lowerClassLimits[l][j] = lowerClassLimit;
                        varianceCombinations[l][j] =
                            variance + varianceCombinations[i4][j - 1];
                    }
                }
            }
        }

        lowerClassLimits[l][1] = 1;
        varianceCombinations[l][1] = variance;
    }

    // return the two matrices. for just providing breaks, only
    // `lowerClassLimits` is needed, but variances can be useful to
    // evaluate goodness of fit.
    return {
        lowerClassLimits: lowerClassLimits,
        varianceCombinations: varianceCombinations
    };
}

/**
 * The **[jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)**
 * is an algorithm commonly used in cartography and visualization to decide
 * upon groupings of data values that minimize variance within themselves
 * and maximize variation between themselves.
 *
 * For instance, cartographers often use jenks in order to choose which
 * values are assigned to which colors in a [choropleth](https://en.wikipedia.org/wiki/Choropleth_map)
 * map.
 *
 * @param {Array<number>} data input data, as an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * // split data into 3 break points
 * jenks([1, 2, 4, 5, 7, 9, 10, 20], 3) // = [1, 7, 20, 20]
 */
function jenks(data, nClasses) {
    if (nClasses > data.length) {
        return null;
    }

    // sort data in numerical order, since this is expected
    // by the matrices function
    data = data.slice().sort(function (a, b) {
        return a - b;
    });

    // get our basic matrices
    var matrices = jenksMatrices(data, nClasses);
    // we only need lower class limits here
    var lowerClassLimits = matrices.lowerClassLimits;

    // extract nClasses out of the computed matrices
    return jenksBreaks(data, lowerClassLimits, nClasses);
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_covariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * The [rank correlation](https://en.wikipedia.org/wiki/Rank_correlation) is
 * a measure of the strength of monotonic relationship between two arrays
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample rank correlation
 */
function sampleRankCorrelation(x, y) {
    var xIndexes = x
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });
    var yIndexes = y
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });

    // At this step, we have an array of indexes
    // that map from sorted numbers to their original indexes. We reverse
    // that so that it is an array of the sorted destination index.
    var xRanks = Array(xIndexes.length);
    var yRanks = Array(xIndexes.length);
    for (var i = 0; i < xIndexes.length; i++) {
        xRanks[xIndexes[i]] = i;
        yRanks[yIndexes[i]] = i;
    }

    return sampleCorrelation(xRanks, yRanks);
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] < 0) {
            throw new Error(
                "geometricMean requires only non-negative numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [log average](https://en.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Geometric_mean#Relationship_with_logarithms)
 * is an equivalent way of computing the geometric mean of an array suitable for large or small products.
 *
 * It's found by calculating the average logarithm of the elements and exponentiating.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 */
function logAverage(x) {
    if (x.length === 0) {
        throw new Error("logAverage requires at least one data point");
    }

    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (x[i] < 0) {
            throw new Error(
                "logAverage requires only non-negative numbers as input"
            );
        }
        value += Math.log(x[i]);
    }

    return Math.exp(value / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * The`coefficient of variation`_ is the ratio of the standard deviation to the mean.
 * .._`coefficient of variation`: https://en.wikipedia.org/wiki/Coefficient_of_variation
 *
 *
 * @param {Array} x input
 * @returns {number} coefficient of variation
 * @example
 * coefficientOfVariation([1, 2, 3, 4]).toFixed(3); // => 0.516
 * coefficientOfVariation([1, 2, 3, 4, 5]).toFixed(3); // => 0.527
 * coefficientOfVariation([-1, 0, 1, 2, 3, 4]).toFixed(3); // => 1.247
 */
function coefficientOfVariation(x) {
    return sampleStandardDeviation(x) / mean(x);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to reject](https://en.wikipedia.org/wiki/Exclusion_of_the_null_hypothesis)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * This function calculates the Wilcoxon rank sum statistic for the first sample
 * with respect to the second. The Wilcoxon rank sum test is a non-parametric
 * alternative to the t-test which is equivalent to the
 * [Mann-Whitney U test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).
 * The statistic is calculated by pooling all the observations together, ranking them,
 * and then summing the ranks associated with one of the samples. If this rank sum is
 * sufficiently large or small we reject the hypothesis that the two samples come
 * from the same distribution in favor of the alternative that one is shifted with
 * respect to the other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @returns {number} rank sum for sampleX
 *
 * @example
 * wilcoxonRankSum([1, 4, 8], [9, 12, 15]); // => 6
 */
function wilcoxonRankSum(sampleX, sampleY) {
    if (!sampleX.length || !sampleY.length) {
        throw new Error("Neither sample can be empty");
    }

    var pooledSamples = sampleX
        .map(function (x) { return ({ label: "x", value: x }); })
        .concat(sampleY.map(function (y) { return ({ label: "y", value: y }); }))
        .sort(function (a, b) { return a.value - b.value; });

    for (var rank = 0; rank < pooledSamples.length; rank++) {
        pooledSamples[rank].rank = rank;
    }

    var tiedRanks = [pooledSamples[0].rank];
    for (var i = 1; i < pooledSamples.length; i++) {
        if (pooledSamples[i].value === pooledSamples[i - 1].value) {
            tiedRanks.push(pooledSamples[i].rank);
            if (i === pooledSamples.length - 1) {
                replaceRanksInPlace(pooledSamples, tiedRanks);
            }
        } else if (tiedRanks.length > 1) {
            replaceRanksInPlace(pooledSamples, tiedRanks);
        } else {
            tiedRanks = [pooledSamples[i].rank];
        }
    }

    function replaceRanksInPlace(pooledSamples, tiedRanks) {
        var average = (tiedRanks[0] + tiedRanks[tiedRanks.length - 1]) / 2;
        for (var i = 0; i < tiedRanks.length; i++) {
            pooledSamples[tiedRanks[i]].rank = average;
        }
    }

    var rankSum = 0;

    for (var i$1 = 0; i$1 < pooledSamples.length; i$1++) {
        var sample = pooledSamples[i$1];
        if (sample.label === "x") {
            rankSum += sample.rank + 1;
        }
    }

    return rankSum;
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a naïve bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use `ε`, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return Number.NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
    14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
    0.46523628927048575665e-4, -0.98374475304879564677e-4,
    0.15808870322491248884e-3, -0.21026444172410488319e-3,
    0.2174396181152126432e-3, -0.16431810653676389022e-3,
    0.84418223983852743293e-4, -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Number.POSITIVE_INFINITY;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, `λ`.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the χ2 (Chi-Squared) Distribution**
 *
 * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    1: {
        0.995: 0,
        0.99: 0,
        0.975: 0,
        0.95: 0,
        0.9: 0.02,
        0.5: 0.45,
        0.1: 2.71,
        0.05: 3.84,
        0.025: 5.02,
        0.01: 6.63,
        0.005: 7.88
    },
    2: {
        0.995: 0.01,
        0.99: 0.02,
        0.975: 0.05,
        0.95: 0.1,
        0.9: 0.21,
        0.5: 1.39,
        0.1: 4.61,
        0.05: 5.99,
        0.025: 7.38,
        0.01: 9.21,
        0.005: 10.6
    },
    3: {
        0.995: 0.07,
        0.99: 0.11,
        0.975: 0.22,
        0.95: 0.35,
        0.9: 0.58,
        0.5: 2.37,
        0.1: 6.25,
        0.05: 7.81,
        0.025: 9.35,
        0.01: 11.34,
        0.005: 12.84
    },
    4: {
        0.995: 0.21,
        0.99: 0.3,
        0.975: 0.48,
        0.95: 0.71,
        0.9: 1.06,
        0.5: 3.36,
        0.1: 7.78,
        0.05: 9.49,
        0.025: 11.14,
        0.01: 13.28,
        0.005: 14.86
    },
    5: {
        0.995: 0.41,
        0.99: 0.55,
        0.975: 0.83,
        0.95: 1.15,
        0.9: 1.61,
        0.5: 4.35,
        0.1: 9.24,
        0.05: 11.07,
        0.025: 12.83,
        0.01: 15.09,
        0.005: 16.75
    },
    6: {
        0.995: 0.68,
        0.99: 0.87,
        0.975: 1.24,
        0.95: 1.64,
        0.9: 2.2,
        0.5: 5.35,
        0.1: 10.65,
        0.05: 12.59,
        0.025: 14.45,
        0.01: 16.81,
        0.005: 18.55
    },
    7: {
        0.995: 0.99,
        0.99: 1.25,
        0.975: 1.69,
        0.95: 2.17,
        0.9: 2.83,
        0.5: 6.35,
        0.1: 12.02,
        0.05: 14.07,
        0.025: 16.01,
        0.01: 18.48,
        0.005: 20.28
    },
    8: {
        0.995: 1.34,
        0.99: 1.65,
        0.975: 2.18,
        0.95: 2.73,
        0.9: 3.49,
        0.5: 7.34,
        0.1: 13.36,
        0.05: 15.51,
        0.025: 17.53,
        0.01: 20.09,
        0.005: 21.96
    },
    9: {
        0.995: 1.73,
        0.99: 2.09,
        0.975: 2.7,
        0.95: 3.33,
        0.9: 4.17,
        0.5: 8.34,
        0.1: 14.68,
        0.05: 16.92,
        0.025: 19.02,
        0.01: 21.67,
        0.005: 23.59
    },
    10: {
        0.995: 2.16,
        0.99: 2.56,
        0.975: 3.25,
        0.95: 3.94,
        0.9: 4.87,
        0.5: 9.34,
        0.1: 15.99,
        0.05: 18.31,
        0.025: 20.48,
        0.01: 23.21,
        0.005: 25.19
    },
    11: {
        0.995: 2.6,
        0.99: 3.05,
        0.975: 3.82,
        0.95: 4.57,
        0.9: 5.58,
        0.5: 10.34,
        0.1: 17.28,
        0.05: 19.68,
        0.025: 21.92,
        0.01: 24.72,
        0.005: 26.76
    },
    12: {
        0.995: 3.07,
        0.99: 3.57,
        0.975: 4.4,
        0.95: 5.23,
        0.9: 6.3,
        0.5: 11.34,
        0.1: 18.55,
        0.05: 21.03,
        0.025: 23.34,
        0.01: 26.22,
        0.005: 28.3
    },
    13: {
        0.995: 3.57,
        0.99: 4.11,
        0.975: 5.01,
        0.95: 5.89,
        0.9: 7.04,
        0.5: 12.34,
        0.1: 19.81,
        0.05: 22.36,
        0.025: 24.74,
        0.01: 27.69,
        0.005: 29.82
    },
    14: {
        0.995: 4.07,
        0.99: 4.66,
        0.975: 5.63,
        0.95: 6.57,
        0.9: 7.79,
        0.5: 13.34,
        0.1: 21.06,
        0.05: 23.68,
        0.025: 26.12,
        0.01: 29.14,
        0.005: 31.32
    },
    15: {
        0.995: 4.6,
        0.99: 5.23,
        0.975: 6.27,
        0.95: 7.26,
        0.9: 8.55,
        0.5: 14.34,
        0.1: 22.31,
        0.05: 25,
        0.025: 27.49,
        0.01: 30.58,
        0.005: 32.8
    },
    16: {
        0.995: 5.14,
        0.99: 5.81,
        0.975: 6.91,
        0.95: 7.96,
        0.9: 9.31,
        0.5: 15.34,
        0.1: 23.54,
        0.05: 26.3,
        0.025: 28.85,
        0.01: 32,
        0.005: 34.27
    },
    17: {
        0.995: 5.7,
        0.99: 6.41,
        0.975: 7.56,
        0.95: 8.67,
        0.9: 10.09,
        0.5: 16.34,
        0.1: 24.77,
        0.05: 27.59,
        0.025: 30.19,
        0.01: 33.41,
        0.005: 35.72
    },
    18: {
        0.995: 6.26,
        0.99: 7.01,
        0.975: 8.23,
        0.95: 9.39,
        0.9: 10.87,
        0.5: 17.34,
        0.1: 25.99,
        0.05: 28.87,
        0.025: 31.53,
        0.01: 34.81,
        0.005: 37.16
    },
    19: {
        0.995: 6.84,
        0.99: 7.63,
        0.975: 8.91,
        0.95: 10.12,
        0.9: 11.65,
        0.5: 18.34,
        0.1: 27.2,
        0.05: 30.14,
        0.025: 32.85,
        0.01: 36.19,
        0.005: 38.58
    },
    20: {
        0.995: 7.43,
        0.99: 8.26,
        0.975: 9.59,
        0.95: 10.85,
        0.9: 12.44,
        0.5: 19.34,
        0.1: 28.41,
        0.05: 31.41,
        0.025: 34.17,
        0.01: 37.57,
        0.005: 40
    },
    21: {
        0.995: 8.03,
        0.99: 8.9,
        0.975: 10.28,
        0.95: 11.59,
        0.9: 13.24,
        0.5: 20.34,
        0.1: 29.62,
        0.05: 32.67,
        0.025: 35.48,
        0.01: 38.93,
        0.005: 41.4
    },
    22: {
        0.995: 8.64,
        0.99: 9.54,
        0.975: 10.98,
        0.95: 12.34,
        0.9: 14.04,
        0.5: 21.34,
        0.1: 30.81,
        0.05: 33.92,
        0.025: 36.78,
        0.01: 40.29,
        0.005: 42.8
    },
    23: {
        0.995: 9.26,
        0.99: 10.2,
        0.975: 11.69,
        0.95: 13.09,
        0.9: 14.85,
        0.5: 22.34,
        0.1: 32.01,
        0.05: 35.17,
        0.025: 38.08,
        0.01: 41.64,
        0.005: 44.18
    },
    24: {
        0.995: 9.89,
        0.99: 10.86,
        0.975: 12.4,
        0.95: 13.85,
        0.9: 15.66,
        0.5: 23.34,
        0.1: 33.2,
        0.05: 36.42,
        0.025: 39.36,
        0.01: 42.98,
        0.005: 45.56
    },
    25: {
        0.995: 10.52,
        0.99: 11.52,
        0.975: 13.12,
        0.95: 14.61,
        0.9: 16.47,
        0.5: 24.34,
        0.1: 34.28,
        0.05: 37.65,
        0.025: 40.65,
        0.01: 44.31,
        0.005: 46.93
    },
    26: {
        0.995: 11.16,
        0.99: 12.2,
        0.975: 13.84,
        0.95: 15.38,
        0.9: 17.29,
        0.5: 25.34,
        0.1: 35.56,
        0.05: 38.89,
        0.025: 41.92,
        0.01: 45.64,
        0.005: 48.29
    },
    27: {
        0.995: 11.81,
        0.99: 12.88,
        0.975: 14.57,
        0.95: 16.15,
        0.9: 18.11,
        0.5: 26.34,
        0.1: 36.74,
        0.05: 40.11,
        0.025: 43.19,
        0.01: 46.96,
        0.005: 49.65
    },
    28: {
        0.995: 12.46,
        0.99: 13.57,
        0.975: 15.31,
        0.95: 16.93,
        0.9: 18.94,
        0.5: 27.34,
        0.1: 37.92,
        0.05: 41.34,
        0.025: 44.46,
        0.01: 48.28,
        0.005: 50.99
    },
    29: {
        0.995: 13.12,
        0.99: 14.26,
        0.975: 16.05,
        0.95: 17.71,
        0.9: 19.77,
        0.5: 28.34,
        0.1: 39.09,
        0.05: 42.56,
        0.025: 45.72,
        0.01: 49.59,
        0.005: 52.34
    },
    30: {
        0.995: 13.79,
        0.99: 14.95,
        0.975: 16.79,
        0.95: 18.49,
        0.9: 20.6,
        0.5: 29.34,
        0.1: 40.26,
        0.05: 43.77,
        0.025: 46.98,
        0.01: 50.89,
        0.005: 53.67
    },
    40: {
        0.995: 20.71,
        0.99: 22.16,
        0.975: 24.43,
        0.95: 26.51,
        0.9: 29.05,
        0.5: 39.34,
        0.1: 51.81,
        0.05: 55.76,
        0.025: 59.34,
        0.01: 63.69,
        0.005: 66.77
    },
    50: {
        0.995: 27.99,
        0.99: 29.71,
        0.975: 32.36,
        0.95: 34.76,
        0.9: 37.69,
        0.5: 49.33,
        0.1: 63.17,
        0.05: 67.5,
        0.025: 71.42,
        0.01: 76.15,
        0.005: 79.49
    },
    60: {
        0.995: 35.53,
        0.99: 37.48,
        0.975: 40.48,
        0.95: 43.19,
        0.9: 46.46,
        0.5: 59.33,
        0.1: 74.4,
        0.05: 79.08,
        0.025: 83.3,
        0.01: 88.38,
        0.005: 91.95
    },
    70: {
        0.995: 43.28,
        0.99: 45.44,
        0.975: 48.76,
        0.95: 51.74,
        0.9: 55.33,
        0.5: 69.33,
        0.1: 85.53,
        0.05: 90.53,
        0.025: 95.02,
        0.01: 100.42,
        0.005: 104.22
    },
    80: {
        0.995: 51.17,
        0.99: 53.54,
        0.975: 57.15,
        0.95: 60.39,
        0.9: 64.28,
        0.5: 79.33,
        0.1: 96.58,
        0.05: 101.88,
        0.025: 106.63,
        0.01: 112.33,
        0.005: 116.32
    },
    90: {
        0.995: 59.2,
        0.99: 61.75,
        0.975: 65.65,
        0.95: 69.13,
        0.9: 73.29,
        0.5: 89.33,
        0.1: 107.57,
        0.05: 113.14,
        0.025: 118.14,
        0.01: 124.12,
        0.005: 128.3
    },
    100: {
        0.995: 67.33,
        0.99: 70.06,
        0.975: 74.22,
        0.95: 77.93,
        0.9: 82.36,
        0.5: 99.33,
        0.1: 118.5,
        0.05: 124.34,
        0.025: 129.56,
        0.01: 135.81,
        0.005: 140.17
    }
};

/**
 * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the χ2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI$1;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z;
    var tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of Φ (phi), which are the values of
 * the [cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function)
 * of the normal distribution. It is used to find the probability that a
 * statistic is observed below, above, or between values on the standard
 * normal distribution, and by extension, any normal distribution.
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return Math.round((1 - standardNormalTable[index]) * 1e4) / 1e4;
    }
}

/**
 * **[Logistic Cumulative Distribution Function](https://en.wikipedia.org/wiki/Logistic_distribution)**
 *
 * @param {number} x
 * @returns {number} cumulative standard logistic probability
 */
function cumulativeStdLogisticProbability(x) {
    return 1 / (Math.exp(-x) + 1);
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of τ (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * The [Logit](https://en.wikipedia.org/wiki/Logit)
 * is the inverse of cumulativeStdLogisticProbability,
 * and is also known as the logistic quantile function.
 *
 * @param {number} p
 * @returns {number} logit
 */
function logit(p) {
    if (p <= 0 || p >= 1) {
        throw new Error("p must be strictly between zero and one");
    }
    return Math.log(p / (1 - p));
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @param {Function} [randomSource=Math.random] an optional entropy source
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k, randomSource) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'."
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData, randomSource);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            /* c8 ignore start */
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
            /* c8 ignore end */
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}

/**
 * Calculate Euclidean distance between two points.
 * @param {Array<number>} left First N-dimensional point.
 * @param {Array<number>} right Second N-dimensional point.
 * @returns {number} Distance.
 */
function euclideanDistance(left, right) {
    var sum = 0;
    for (var i = 0; i < left.length; i++) {
        var diff = left[i] - right[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

/**
 * @typedef {Object} kMeansReturn
 * @property {Array<number>} labels The labels.
 * @property {Array<Array<number>>} centroids The cluster centroids.
 */

/**
 * Perform k-means clustering.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points to be clustered.
 * @param {number} numCluster How many clusters to create.
 * @param {Function} randomSource An optional entropy source that generates uniform values in [0, 1).
 * @return {kMeansReturn} Labels (same length as data) and centroids (same length as numCluster).
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 *
 * @example
 * kMeansCluster([[0.0, 0.5], [1.0, 0.5]], 2); // => {labels: [0, 1], centroids: [[0.0, 0.5], [1.0 0.5]]}
 */
function kMeansCluster(points, numCluster, randomSource) {
    if ( randomSource === void 0 ) randomSource = Math.random;

    var oldCentroids = null;
    var newCentroids = sample(points, numCluster, randomSource);
    var labels = null;
    var change = Number.MAX_VALUE;
    while (change !== 0) {
        labels = labelPoints(points, newCentroids);
        oldCentroids = newCentroids;
        newCentroids = calculateCentroids(points, labels, numCluster);
        change = calculateChange(newCentroids, oldCentroids);
    }
    return {
        labels: labels,
        centroids: newCentroids
    };
}

/**
 * Label each point according to which centroid it is closest to.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<Array<number>>} centroids Current centroids.
 * @return {Array<number>} Group labels.
 */
function labelPoints(points, centroids) {
    return points.map(function (p) {
        var minDist = Number.MAX_VALUE;
        var label = -1;
        for (var i = 0; i < centroids.length; i++) {
            var dist = euclideanDistance(p, centroids[i]);
            if (dist < minDist) {
                minDist = dist;
                label = i;
            }
        }
        return label;
    });
}

/**
 * Calculate centroids for points given labels.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<number>} labels Which groups points belong to.
 * @param {number} numCluster Number of clusters being created.
 * @return {Array<Array<number>>} Centroid for each group.
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 */
function calculateCentroids(points, labels, numCluster) {
    // Initialize accumulators.
    var dimension = points[0].length;
    var centroids = makeMatrix(numCluster, dimension);
    var counts = Array(numCluster).fill(0);

    // Add points to centroids' accumulators and count points per centroid.
    var numPoints = points.length;
    for (var i = 0; i < numPoints; i++) {
        var point = points[i];
        var label = labels[i];
        var current = centroids[label];
        for (var j = 0; j < dimension; j++) {
            current[j] += point[j];
        }
        counts[label] += 1;
    }

    // Rescale centroids, checking for any that have no points.
    for (var i$1 = 0; i$1 < numCluster; i$1++) {
        if (counts[i$1] === 0) {
            throw new Error(("Centroid " + i$1 + " has no friends"));
        }
        var centroid = centroids[i$1];
        for (var j$1 = 0; j$1 < dimension; j$1++) {
            centroid[j$1] /= counts[i$1];
        }
    }

    return centroids;
}

/**
 * Calculate the difference between old centroids and new centroids.
 *
 * @private
 * @param {Array<Array<number>>} left One list of centroids.
 * @param {Array<Array<number>>} right Another list of centroids.
 * @return {number} Distance between centroids.
 */
function calculateChange(left, right) {
    var total = 0;
    for (var i = 0; i < left.length; i++) {
        total += euclideanDistance(left[i], right[i]);
    }
    return total;
}

/**
 * Calculate the [silhouette values](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for clustered data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<number>} The silhouette value for each point.
 *
 * @example
 * silhouette([[0.25], [0.75]], [0, 0]); // => [1.0, 1.0]
 */
function silhouette(points, labels) {
    if (points.length !== labels.length) {
        throw new Error("must have exactly as many labels as points");
    }
    var groupings = createGroups(labels);
    var distances = calculateAllDistances(points);
    var result = [];
    for (var i = 0; i < points.length; i++) {
        var s = 0;
        if (groupings[labels[i]].length > 1) {
            var a = meanDistanceFromPointToGroup(
                i,
                groupings[labels[i]],
                distances
            );
            var b = meanDistanceToNearestGroup(
                i,
                labels,
                groupings,
                distances
            );
            s = (b - a) / Math.max(a, b);
        }
        result.push(s);
    }
    return result;
}

/**
 * Create a lookup table mapping group IDs to point IDs.
 *
 * @private
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<Array<number>>} An array of length G, each of whose entries is an array
 * containing the indices of the points in that group.
 */
function createGroups(labels) {
    var numGroups = 1 + max(labels);
    var result = Array(numGroups);
    for (var i = 0; i < labels.length; i++) {
        var label = labels[i];
        if (result[label] === undefined) {
            result[label] = [];
        }
        result[label].push(i);
    }
    return result;
}

/**
 * Create a lookup table of all inter-point distances.
 *
 * @private
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @return {Array<Array<number>>} A symmetric square array of inter-point distances
 * (zero on the diagonal).
 */
function calculateAllDistances(points) {
    var numPoints = points.length;
    var result = makeMatrix(numPoints, numPoints);
    for (var i = 0; i < numPoints; i++) {
        for (var j = 0; j < i; j++) {
            result[i][j] = euclideanDistance(points[i], points[j]);
            result[j][i] = result[i][j];
        }
    }
    return result;
}

/**
 * Calculate the mean distance between this point and all the points in the
 * nearest group (as determined by which point in another group is closest).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} labels Labels of points.
 * @param {Array<Array<number>>} groupings An array whose entries are arrays
 * containing the indices of the points in that group.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the nearest
 * group.
 */
function meanDistanceToNearestGroup(which, labels, groupings, distances) {
    var label = labels[which];
    var result = Number.MAX_VALUE;
    for (var i = 0; i < groupings.length; i++) {
        if (i !== label) {
            var d = meanDistanceFromPointToGroup(
                which,
                groupings[i],
                distances
            );
            if (d < result) {
                result = d;
            }
        }
    }
    return result;
}

/**
 * Calculate the mean distance between a point and all the points in a group
 * (possibly its own).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} group The indices of all the points in the group in
 * question.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the
 * specified group.
 */
function meanDistanceFromPointToGroup(which, group, distances) {
    var total = 0;
    for (var i = 0; i < group.length; i++) {
        total += distances[which][group[i]];
    }
    return total / group.length;
}

/**
 * Calculate the [silhouette metric](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for a set of N-dimensional points arranged in groups. The metric is the largest
 * individual silhouette value for the data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {number} The silhouette metric for the groupings.
 *
 * @example
 * silhouetteMetric([[0.25], [0.75]], [0, 0]); // => 1.0
 */
function silhouetteMetric(points, labels) {
    var values = silhouette(points, labels);
    return max(values);
}

/**
 * Relative error.
 *
 * This is more difficult to calculate than it first appears [1,2].  The usual
 * formula for the relative error between an actual value A and an expected
 * value E is `|(A-E)/E|`, but:
 *
 * 1. If the expected value is 0, any other value has infinite relative error,
 *    which is counter-intuitive: if the expected voltage is 0, getting 1/10th
 *    of a volt doesn't feel like an infinitely large error.
 *
 * 2. This formula does not satisfy the mathematical definition of a metric [3].
 *    [4] solved this problem by defining the relative error as `|ln(|A/E|)|`,
 *    but that formula only works if all values are positive: for example, it
 *    reports the relative error of -10 and 10 as 0.
 *
 * Our implementation sticks with convention and returns:
 *
 * - 0 if the actual and expected values are both zero
 * - Infinity if the actual value is non-zero and the expected value is zero
 * - `|(A-E)/E|` in all other cases
 *
 * [1] https://math.stackexchange.com/questions/677852/how-to-calculate-relative-error-when-true-value-is-zero
 * [2] https://en.wikipedia.org/wiki/Relative_change_and_difference
 * [3] https://en.wikipedia.org/wiki/Metric_(mathematics)#Definition
 * [4] F.W.J. Olver: "A New Approach to Error Arithmetic." SIAM Journal on
 *     Numerical Analysis, 15(2), 1978, 10.1137/0715024.
 *
 * @param {number} actual The actual value.
 * @param {number} expected The expected value.
 * @return {number} The relative error.
 */
function relativeError(actual, expected) {
    // These lines are actually covered by tests, but it seems
    // like c8 has a bug that marks them as not covered.
    /* c8 ignore start */
    if (actual === 0 && expected === 0) {
        return 0;
    }
    /* c8 ignore end */
    return Math.abs((actual - expected) / expected);
}

/**
 * Approximate equality.
 *
 * @param {number} actual The value to be tested.
 * @param {number} expected The reference value.
 * @param {number} tolerance The acceptable relative difference.
 * @return {boolean} Whether numbers are within tolerance.
 */
function approxEqual(actual, expected, tolerance) {
    if ( tolerance === void 0 ) tolerance = epsilon;

    return relativeError(actual, expected) <= tolerance;
}


//# sourceMappingURL=simple-statistics.mjs.map


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   object: () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bbox: () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   feature: () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   merge: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mergeArcs: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   mesh: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   meshArcs: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   neighbors: () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   quantize: () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   transform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   untransform: () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "./node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "./node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mergeArcs: () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   meshArcs: () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "./node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"eurostat-map","version":"4.1.60","description":"Reusable library to quickly create and customise web maps showing Eurostat data directly retrieved from Eurostat database.","keywords":["eurostat","statistics","europe","SVG","NUTS","map","D3","cartography","thematic","mapping","eurostat-map","dataviz","data visualization"],"homepage":"https://github.com/eurostat/eurostat-map","author":"","license":"EUPL-1.2","repository":{"type":"git","url":"https://github.com/eurostat/eurostat-map.git"},"main":"build/eurostatmap.min.js","unpkg":"build/eurostatmap.min.js","files":["build"],"scripts":{"start":"webpack --config webpack/webpack.config.dev.js","server":"webpack-dev-server --open --watch","build-prod":"webpack --config webpack/webpack.config.prod.js","build-prod-debug":"webpack --config webpack/webpack.config.debug-size.js","format":"prettier --write .","test":"jest"},"dependencies":{"colorbrewer":"^1.3.0","d3":"^7.8.5","d3-geo-projection":"^3.0.0","d3-sankey":"^0.12.3","d3-svg-annotation":"^2.5.1","jsonstat-toolkit":"^1.0.8","simple-statistics":"^7.8.7","topojson-client":"^3.1.0"},"overrides":{"d3-color":"3.1.0"},"devDependencies":{"@babel/core":"^7.22.6","@babel/plugin-transform-runtime":"^7.22.6","@babel/preset-env":"^7.22.6","@babel/runtime":"^7.12.1","babel-loader":"^9.1.2","css-loader":"^7.1.2","prettier":"^3.4.1","style-loader":"^4.0.0","webpack":"^5.88.1","webpack-bundle-analyzer":"^4.10.2","webpack-cli":"^5.0.0","webpack-dev-server":"^4.15.1","webpack-livereload-plugin":"^3.0.2"}}');

/***/ }),

/***/ "./src/core/annotations.js":
/*!*********************************!*\
  !*** ./src/core/annotations.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendAnnotations: () => (/* binding */ appendAnnotations)
/* harmony export */ });
/* harmony import */ var d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-svg-annotation */ "./node_modules/d3-svg-annotation/indexRollupNext.js");


function appendAnnotations(map) {
    if (map.svg_) {
        const zoomGroup = map.svg_.select('#em-zoom-group-' + map.svgId_)
        //clear previous
        zoomGroup.selectAll('.em-annotation-group').remove()

        const annotationsConfig = map.annotations_

        if (annotationsConfig) {
            // Define a map that maps the type string to the corresponding annotation function
            const annotationTypeMap = {
                annotationLabel: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel,
                annotationCallout: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCallout,
                annotationCalloutRect: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutRect,
                annotationCalloutCircle: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutCircle,
                annotationXYThreshold: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationXYThreshold, // Add any other types you need
            }

            // Map annotations data to ensure each annotation has the proper function
            const annotationsWithTypes = annotationsConfig.annotations.map((d) => {
                // Replace the 'type' string with the corresponding annotation function
                const annotationType = annotationTypeMap[d.type] || d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel // Default to annotationLabel
                return { ...d, type: annotationType } // Update 'type' with the function reference
            })
            const makeAnnotations = (0,d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotation)().type(d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel).annotations(annotationsWithTypes).editMode(annotationsConfig.editMode)

            // append new
            zoomGroup.append('g').attr('class', 'em-annotation-group').call(makeAnnotations)
        }
    }
}


/***/ }),

/***/ "./src/core/cartograms.js":
/*!********************************!*\
  !*** ./src/core/cartograms.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildGridCartogramBase: () => (/* binding */ buildGridCartogramBase)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");



// draw grid cartogram geometries
const buildGridCartogramBase = function (out) {
    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(`#em-zoom-group-${out.svgId_}`)
    const gridGroup = zoomGroup.append('g').attr('id', 'em-grid-container')

    // Ensure margins exist with default values
    out.gridCartogramMargins_ = out.gridCartogramMargins_ || { top: 80, right: 80, bottom: 80, left: 80 }

    // Get grid layout
    const gridLayout = getGridLayout(out)
    const position = parseGridLayout(gridLayout)
    const gridData = getGridData(position, out)

    // Draw the appropriate grid
    if (out.gridCartogramShape_ === 'hexagon') {
        drawHexagonGrid(gridGroup, gridData, out)
    } else {
        drawSquareGrid(gridGroup, gridData, out)
    }

    // Center the grid
    centerGrid(gridGroup, out.width_, out.height_, out.gridCartogramMargins_)
}

/** Determines the grid layout based on settings */
const getGridLayout = (out) => {
    const squareGrid = `
        ,IS,  ,  ,NO,SE,FI,  ,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    const hexagonGrid = `
        ,IS,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,
        ,  ,  ,  ,NO,SE,FI,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    return out.gridCartogramPositions_ || (out.gridCartogramShape_ === 'hexagon' ? hexagonGrid : squareGrid)
}

/** Parses the grid layout and maps each ID to its position */
const parseGridLayout = (gridLayout) => {
    const positionById = new Map()
    ;(0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__.csvParseRows)(gridLayout.trim(), (row, j) => {
        row.forEach((id, i) => {
            if ((id = id.trim())) {
                positionById.set(id, [i, j])
            }
        })
    })
    return positionById
}

/** Converts parsed positions into structured grid data */
const getGridData = (position, out) => {
    return Array.from(position, ([id, [col, row]]) => {
        const feature = out.Geometries.geoJSONs.nutsrg.find((rg) => rg.properties.id == id)
        return {
            id,
            col,
            row,
            properties: {
                id: id,
                name: feature ? feature.properties.na : '',
            },
        }
    })
}

/** Draws a square grid */
const drawSquareGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const cellWidth = (out.width_ - margins.left - margins.right) / numCols - cellPadding
    const cellHeight = (out.height_ - margins.top - margins.bottom) / numRows - cellPadding
    const cellSize = Math.min(cellWidth, cellHeight)

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => `translate(${d.col * (cellSize + cellPadding) + margins.left}, ${d.row * (cellSize + cellPadding) + margins.top})`)
        .each(function (d) {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('rect').attr('width', cellSize).attr('height', cellSize).attr('class', 'em-grid-rect')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('x', cellSize / 2)
                .attr('y', cellSize / 2 + 5)
        })
}

/** Draws a hexagon grid */
const drawHexagonGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const baseHexRadius = Math.min(
        (out.width_ - margins.left - margins.right) / (numCols * 1.5),
        (out.height_ - margins.top - margins.bottom) / (numRows * Math.sqrt(3))
    )

    const hexRadius = baseHexRadius
    const hexHeight = Math.sqrt(3) * hexRadius

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => {
            const x = d.col * (1.5 * hexRadius + cellPadding) + margins.left
            const y = d.row * (hexHeight + cellPadding) + (d.col % 2 === 1 ? (hexHeight + cellPadding) / 2 : 0) + margins.top
            return `translate(${x}, ${y})`
        })
        .each(function (d) {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('path').attr('d', drawHexagon(hexRadius)).attr('class', 'em-grid-hexagon')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('y', 5)
        })
}

/** Generates the hexagon path */
const drawHexagon = (r) => {
    const angle = Math.PI / 3
    return (
        Array.from({ length: 6 }, (_, i) => {
            const x = r * Math.cos(angle * i)
            const y = r * Math.sin(angle * i)
            return `${i === 0 ? 'M' : 'L'}${x},${y}`
        }).join(' ') + ' Z'
    )
}

/** Centers the grid within the SVG */
const centerGrid = (gridGroup, svgWidth, svgHeight, margins) => {
    gridGroup.each(function () {
        const bbox = this.getBBox()
        const dx = (svgWidth - margins.left - margins.right - bbox.width) / 2 - bbox.x + margins.left
        const dy = (svgHeight - margins.top - margins.bottom - bbox.height) / 2 - bbox.y + margins.top
        gridGroup.attr('transform', `translate(${dx}, ${dy})`)
    })
}


/***/ }),

/***/ "./src/core/deprecated.js":
/*!********************************!*\
  !*** ./src/core/deprecated.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defineDeprecatedFunctions: () => (/* binding */ defineDeprecatedFunctions)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/core/utils.js");


/* prettier-ignore */
// to keep track of deprecated functions whilst keeping the current version clean.
// also passes any important parameters to the new functions (if they exist) and overwrites any CSS style rules.
// To be removed when completely phased out.

const defineDeprecatedFunctions = (out) => {
    // styles
    out.seaFillStyle = (v) => (console.warn('seaFillStyle() is now DEPRECATED, please use the .em-sea CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-sea','fill',v), out);
    out.cntrgFillStyle = (v) => (console.warn('cntrgFillStyle() is now DEPRECATED, please use the .em-cntrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-cntrg','fill',v), out);
    out.nutsrgFillStyle = (v) => (console.warn('nutsrgFillStyle() is now DEPRECATED, please use the .em-nutsrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-nutsrg','fill',v), out);
    out.nutsbnStroke = (v) => {
        console.warn('nutsbnStroke() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke',v['3'])
        }
        return out
    };
    out.nutsbnStrokeWidth = (v) => {
        console.warn('nutsbnStrokeWidth() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke-width',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke-width',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke-width',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke-width',v['3'])
        }
        return out
    };
    out.graticuleStroke = (v) => (console.warn('graticuleStroke() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke',v), out);
    out.graticuleStrokeWidth = (v) => (console.warn('graticuleStrokeWidth() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke-width',v), out);
    out.nutsrgSelFillSty = (v) => (console.warn('nutsrgSelFillSty() is now DEPRECATED, please use hoverColor() instead'), out.hoverColor_ = v, out);
    out.titleFontSize = (v) => (console.warn('map.titleFontSize() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','font-size',v), out);
    out.subtitleFontSize = (v) => (console.warn('map.subtitleFontSize() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-size',v), out);
    out.subtitleFontWeight = (v) => (console.warn('map.subtitleFontWeight() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-weight',v), out);
    out.titleFill = (v) => (console.warn('map.titleFill() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','fill',v), out);
    out.subtitleFill = (v) => (console.warn('map.subtitleFill() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','fill',v), out);
    out.cntbnStroke = (v) => {
        console.warn('cntbnStroke() is now DEPRECATED, please use the .em-cntbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v['co'])
        }
        return out
    };
    out.cntbnStrokeWidth = (v) => {
        console.warn('cntbnStrokeWidth() is now DEPRECATED, please use the .em-cntbn .em-worldbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke-width',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke-width',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke-width',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke-width',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v['co'])
        }
        return out
    };
    out.worldStroke = (v) => (console.warn('map.worldStroke() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke',v), out);
    out.worldStrokeWidth = (v) => (console.warn('map.worldStrokeWidth() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke-width',v), out);
    out.worldCoastStroke = (v) => (console.warn('map.worldCoastStroke() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v), out);
    out.worldCoastStrokeWidth = (v) => (console.warn('map.worldCoastStrokeWidth() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v), out);
    out.worldFillStyle = (v) => (console.warn('map.worldFillStyle() is now DEPRECATED. please use the .em-worldrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldrg','fill',v), out); 
    out.coastalMarginWidth = (v) => (console.warn('map.coastalMarginWidth() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke-width',v), out);  
    out.coastalMarginColor = (v) => (console.warn('map.coastalMarginColor() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke',v), out);
    out.fontFamily = (v) => (console.warn('map.fontFamily() is now DEPRECATED. please use the .em-map CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-map','font-family',v), out);
    out.botTxtFontSize = (v) => (console.warn('map.botTxtFontSize() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','font-size',v), out);
    out.botTxtFill = (v) => (console.warn('map.botTxtFill() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','fill',v), out);
    out.scalebarFontSize = (v) => (console.warn('map.scalebarFontSize() is now DEPRECATED. please use the .em-scalebar-label CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-scalebar-label','font-size',v), out);
    out.frameStroke = (v)=> (console.warn('map.frameStroke() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke',v), out);
    out.frameStrokeWidth = (v)=> (console.warn('map.frameStrokeWidth() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke-width',v), out);

   //other
    out.psClassifMethod = (v) => (console.warn('psClassifMethod() is now DEPRECATED. please use psClassificationMethod instead'),out.psClassificationMethod_ = v, out);
    out.geoCenter = (v) => (console.warn('map.geoCenter() is now deprecated. Please use map.position({x,y,z}) instead.'), out.position_.x = v[0], out.position_.y = v[1], out);
    out.pixelSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.pixSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.tooltipText = (v) => (console.warn('map.tooltipText() is now deprecated. Please use map.tooltip(config.textFunction) instead. See API reference for details.'), out.tooltip_.textFunction = v, out);
    out.classifMethod = (v) => (console.warn('map.classifMethod() is now DEPRECATED. please use map.classificationMethod() instead.'), out.classificationMethod_ = v,out);
    out.threshold = (v) => (console.warn('map.threshold() is now DEPRECATED. please use map.thresholds() instead.'), out.thresholds_ = v,out);
    out.psThreshold = (v) => (console.warn('map.psThreshold() is now DEPRECATED. please use map.psThresholds() instead.'), out.psThresholds_ = v,out);
    out.clnb = (v) => (console.warn('map.clnb() is now DEPRECATED. please use map.numberOfClasses() instead.'), out.numberOfClasses_ = v,out);
    out.nutsLvl = (v) => (console.warn('map.nutsLvl() is now DEPRECATED. please use map.nutsLevel() instead.'), out.nutsLevel_ = v,out);
    out.lg = (v) => (console.warn('map.lg() is now DEPRECATED. please use map.language() instead.'), out.language_ = v,out);
    out.bottomText = (v) => (console.warn('bottomText is now DEPRECATED. Please use the footnote() method and em-footnote CSS class instead.'),out.footnote_ = v,out);
    out.botTxtFontSize = (v) => (console.warn('botTxtFontSize is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtFill = (v) => (console.warn('botTxtFill is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtPadding = (v) => (console.warn('botTxtPadding is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtTooltipTxt = (v) => (console.warn('botTxtTooltipTxt is now DEPRECATED. Please use footnoteTooltipText() instead.'),out);
    out.tooltipShowFlags = (v) =>(console.warn('tooltipShowFlags is now DEPRECATED. Please use out.tooltip({showFlags}) instead.'),out.tooltip_.showFlags = v,out);
    out.colorFun = (v) =>(console.warn('colorFun is now DEPRECATED. Please use out.colorFunction() instead.'),out.colorFunction_ = v,out);
    out.filtersDefinitionFun = (v)=>(console.warn('filtersDefinitionFun is now DEPRECATED. Please use out.filtersDefinitionFunction() instead.'),out.filtersDefinitionFunction_ = v,out);
    
    //labelling
    out.labelling = (v) =>(console.warn('labelling is now DEPRECATED. Please use out.labels({}) configuration object instead. See documentation for details.'),out);
    out.labelsConfig = (v) =>(console.warn('labelsConfig is now DEPRECATED. Please use out.labels({config:yourConfig}) configuration object instead. See documentation for details.'),out.labels_ =Object.assign(out.labels_ || {}, { config: v }),out);
    out.statLabelsPositions = (v) =>(console.warn('statLabelsPositions is now DEPRECATED. Please use out.labels({statLabelsPositions:yourPositions}) instead. See documentation for details.'),out.labels_ = Object.assign(out.labels_ || {}, { statLabelsPositions: v }),out);
    out.labelsToShow = (v) =>(console.warn('labelsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadowsToShow = (v) =>(console.warn('labelShadowsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadow = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelShadowWidth = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelFilterFunction =(v) =>(console.warn('labelFilterFunction is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) instead. See documentation for details.'),out);
    out.labelFill = (v) => (console.warn('map.labelFill() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStroke = (v) => (console.warn('map.labelStroke() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStrokeWidth = (v) => (console.warn('map.labelStrokeWidth() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelOpacity = (v) => (console.warn('map.labelOpacity() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelValuesFontSize = (v) => (console.warn('map.labelValuesFontSize() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelShadowWidth = (v) => (console.warn('map.labelShadowWidth() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);
    out.labelShadowColor = (v) => (console.warn('map.labelShadowColor() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);

    out.countriesToShow = (v) => (console.warn('map.countriesToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
    out.bordersToShow = (v) => (console.warn('map.bordersToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
}


/***/ }),

/***/ "./src/core/geometries.js":
/*!********************************!*\
  !*** ./src/core/geometries.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Geometries: () => (/* binding */ Geometries)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _kosovo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kosovo */ "./src/core/kosovo.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/graticule.js");
// takes care of the map's geometries






// Geometries class wrapped as a function
const Geometries = function (map, withCenterPoints) {
    let out = {}

    // defaults
    out.defaultGeoData = undefined
    out.allNUTSGeoData = undefined
    out.geoJSONs = {
        mixed: { rg0: undefined, rg1: undefined, rg2: undefined, rg3: undefined },
        cntbn: undefined,
        cntrg: undefined,
        nutsbn: undefined,
        nutsrg: undefined,
        gra: undefined,
        worldrg: undefined,
        worldbn: undefined,
        kosovo: undefined,
    }

    // user defined geometries (layers)
    out.userGeometries = undefined

    // user defined statistical regions
    out.statisticalRegions = undefined

    //centroids for prop symbols etc
    out.centroidsData = undefined //raw
    out.centroidsFeatures = undefined //geojson features

    // get geojson features of all statistical regions
    out.getRegionFeatures = function () {
        if (map.geo_ == 'WORLD') {
            return out.geoJSONs.worldrg
        } else {
            if (map.nutsLevel_ === 'mixed') {
                return [out.geoJSONs.mixed.rg0, out.geoJSONs.mixed.rg1, out.geoJSONs.mixed.rg2, out.geoJSONs.mixed.rg3]
            } else {
                return out.geoJSONs.nutsrg.concat(out.geoJSONs.cntrg)
            }
        }
    }

    /**
     * Retrieves and parses 'default' geo data (for NUTS or World maps)
     */
    out.getDefaultGeoData = function (geo, filterGeometriesFunction, nutsLevel) {
        const promises = out.getDefaultGeoDataPromise()
        return Promise.all(promises)
            .then((results) => {
                if (filterGeometriesFunction) {
                    results = filterGeometriesFunction(results)
                }
                out.allNUTSGeoData = results
                out.defaultGeoData = results[0]

                if (withCenterPoints) {
                    out.centroidsData = nutsLevel === 'mixed' ? [results[4], results[5], results[6], results[7]] : results[1]
                }

                const isWorld = geo === 'WORLD'
                // Decode TopoJSON to GeoJSON
                if (isWorld) {
                    out.geoJSONs.worldrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_RG_20M_2020_4326).features
                    out.geoJSONs.worldbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_BN_20M_2020_4326).features
                    out.geoJSONs.kosovo = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.NUTS_BN_20M_2021_RS_XK_border).features
                    out.geoJSONs.graticule = [(0,d3_geo__WEBPACK_IMPORTED_MODULE_3__["default"])().step([30, 30])()]
                } else {
                    out.geoJSONs.graticule = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.gra).features
                    out.geoJSONs.nutsrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsrg).features
                    out.geoJSONs.nutsbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsbn).features
                    out.geoJSONs.cntrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntrg).features
                    out.geoJSONs.cntbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntbn).features
                }

                return results
            })
            .catch((err) => {
                return Promise.reject(err)
            })
    }

    /**
     * Returns an array of promises for Nuts2JSON topojson data.
     */
    out.getDefaultGeoDataPromise = function () {
        const nutsLevels = [0, 1, 2, 3]
        const promises = []

        const buildUrl = (base, year, geo, proj, scale, level, withCenter = false) => {
            let path = `${base}/${year}`

            // Include geo part if it's specified and not 'EUR' or 'WORLD'
            if (geo && geo !== 'EUR' && geo !== 'WORLD') path += `/${geo}`

            // Add projection
            path += `/${geo == 'WORLD' ? '4326' : proj}` // world geodata is always 4326, then reprojected

            // Add scale only if not using center points
            if (!withCenter && scale) path += `/${scale}`

            // Append the appropriate file name
            path += `/${withCenter ? 'nutspt_' : ''}${level}.json`

            return path
        }

        if (map.nutsLevel_ === 'mixed' && map.geo_ !== 'WORLD') {
            nutsLevels.forEach((lvl) => promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl))))
            if (withCenterPoints) {
                nutsLevels.forEach((lvl) =>
                    promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl, true)))
                )
            }
        } else if (map.geo_ === 'WORLD') {
            const worldMapTopojsonURL = window.location.hostname.includes('ec.europa.eu')
                ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/IMAGE/WORLD_4326.json'
                : 'https://raw.githubusercontent.com/eurostat/eurostat-map/master/src/assets/topojson/WORLD_4326.json'
            promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(worldMapTopojsonURL))
        } else {
            promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_)))
            if (withCenterPoints) {
                promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_, true)))
            }
        }

        return promises
    }
    /** Checks if all geo data is ready */
    out.isGeoReady = function () {
        if (!out.defaultGeoData && !out.userGeometries) return false

        let allReady = true

        ;(0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, null, (inset) => {
            if (!inset.Geometries.isGeoReady()) {
                allReady = false
            }
        })

        return allReady
    }

    out.setUserGeometries = function (geometries) {
        this.userGeometries = geometries

        // get regions that are linked to the statistics
        geometries.forEach((geometry) => {
            if (geometry.statisticalRegions) {
                this.statisticalRegions = geometry
            }
        })
    }

    out.addDefaultGeometriesToMap = function (container, drawGraticule, pathFunction, nutsLevel, nutsYear, geo, proj, scale) {
        if (this.geoJSONs.graticule && drawGraticule) {
            //draw graticule
            container
                .append('g')
                .attr('id', 'em-graticule')
                .attr('class', 'em-graticule')
                .selectAll('path')
                .data(this.geoJSONs.graticule)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw country regions
        if (this.geoJSONs.cntrg) {
            container
                .append('g')
                .attr('id', 'em-cntrg')
                .attr('class', 'em-cntrg')
                .selectAll('path')
                .data(this.geoJSONs.cntrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
                .attr('id', (cntrg) => {
                    // add ids for RS and EL so that we can choose not to add statistical data to them.
                    const id = cntrg.properties.id
                    if (id == 'RS' || id == 'EL') {
                        return 'em-cntrg-' + id
                    }
                })
        }

        //draw world map
        if (this.geoJSONs.worldrg) {
            container
                .append('g')
                .attr('id', 'em-worldrg')
                .attr('class', 'em-worldrg')
                .selectAll('path')
                .data(this.geoJSONs.worldrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw NUTS regions
        if (this.geoJSONs.nutsrg) {
            if (nutsLevel == 'mixed') {
                this.geoJSONs.mixed.rg0 = this.geoJSONs.nutsrg
                this.geoJSONs.mixed.rg1 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[1], out.allNUTSGeoData[1].objects.nutsrg).features
                this.geoJSONs.mixed.rg2 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[2], out.allNUTSGeoData[2].objects.nutsrg).features
                this.geoJSONs.mixed.rg3 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[3], out.allNUTSGeoData[3].objects.nutsrg).features

                //for mixed NUTS, we add every NUTS region across all levels and hide level 1,2,3 by default, only showing them when they have stat data
                // see updateClassification and updateStyle in map-choropleth.js for hiding/showing
                ;[this.geoJSONs.mixed.rg0, this.geoJSONs.mixed.rg1, this.geoJSONs.mixed.rg2, this.geoJSONs.mixed.rg3].forEach((r, i) => {
                    //append each nuts level to map
                    container
                        .append('g')
                        .attr('id', 'em-nutsrg')
                        .attr('class', `em-nutsrg em-nutsrg-${i}`)
                        .selectAll('path')
                        .data(r)
                        .enter()
                        .append('path')
                        .attr('d', pathFunction)
                        .attr('lvl', i) //to be able to distinguish nuts levels
                })

                //add kosovo
                if (geo == 'EUR' && (proj == '3035' || proj == '4326')) {
                    // add kosovo manually
                    addKosovoBorder(container, pathFunction, proj, scale, nutsYear)
                }
            } else {
                // when nutsLevel is not 'mixed'
                container
                    .append('g')
                    .attr('id', 'em-nutsrg')
                    .attr('class', 'em-nutsrg')
                    .selectAll('path')
                    .data(this.geoJSONs.nutsrg)
                    .enter()
                    .append('path')
                    .attr('d', pathFunction)
            }
        }

        //draw country boundaries
        if (this.geoJSONs.cntbn) {
            container
                .append('g')
                .attr('id', 'em-cntbn')
                .attr('class', 'em-cntbn')
                .selectAll('path')
                .data(this.geoJSONs.cntbn)
                .enter()
                .append('path')
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .attr('d', pathFunction)
                .attr('id', (bn) => 'em-bn-' + bn.properties.id)
                .attr('class', function (bn) {
                    let classList = []

                    if (bn.properties.eu === 'T') classList.push('em-bn-eu')
                    if (bn.properties.efta === 'T') classList.push('em-bn-efta')
                    if (bn.properties.cc === 'T') classList.push('em-bn-cc')
                    if (bn.properties.oth === 'T') classList.push('em-bn-oth')
                    if (bn.properties.co === 'T') classList.push('em-bn-co')

                    return classList.join(' ') // Use join with a space to create a valid class string
                })
        }

        //draw NUTS boundaries
        if (this.geoJSONs.nutsbn && nutsLevel !== 'mixed') {
            this.geoJSONs.nutsbn.sort(function (bn1, bn2) {
                return bn2.properties.lvl - bn1.properties.lvl
            })
            container
                .append('g')
                .attr('id', 'em-nutsbn')
                .attr('class', 'em-nutsbn')
                .selectAll('path')
                .data(this.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    let props = bn.properties
                    //KOSOVO
                    if (props.id > 100000) {
                        return 'em-kosovo-bn'
                    }
                    if (props.co === 'T') return 'em-bn-co'
                    const cl = ['em-bn-' + props.lvl]
                    //if (bn.oth === "T") cl.push("bn-oth");
                    return cl.join(' ')
                })
        }

        //draw world boundaries
        if (this.geoJSONs.worldbn) {
            container
                .append('g')
                .attr('id', 'em-worldbn')
                .attr('class', 'em-worldbn')
                .selectAll('path')
                .data(this.geoJSONs.worldbn)
                .enter()
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    if (bn.properties.POL_STAT > 0) {
                        //disputed
                        return 'em-bn-d'
                    }
                    return bn.properties.COAS_FLAG === 'T' ? 'em-bn-co' : 'em-worldbn'
                })
            //.attr("id", (bn) => bn.properties.CNTR_BN_ID)
        }

        if (this.geoJSONs.kosovo) {
            //add kosovo to world maps
            container
                .append('g')
                .attr('id', 'em-kosovo-bn')
                .attr('class', 'em-kosovo-bn')
                .selectAll('path')
                .data(this.geoJSONs.kosovo)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }
    }

    function addKosovoBorder(container, pathFunction, proj, scale, nutsYear) {
        let kosovoFeature = _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear] ? _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear][proj][scale] : _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[2024][proj][scale]
        let kosovoBn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(kosovoFeature, 'nutsbn_1').features
        container
            .append('g')
            .attr('id', 'em-kosovo-bn')
            .attr('class', 'em-kosovo-bn em-bn-cc')
            .selectAll('path')
            .data(kosovoBn)
            .enter()
            .append('path')
            .attr('d', pathFunction)
    }

    /**
     * @description Adds user-defined geometries to the map
     * E.g.
     * map.geometries([
     *  { id: 'regions', features: geoJSON.features, class: (feature) => 'region' },
     *  { id: 'borders', features: bordersData, class: (feature) => 'border' }
     * ])
     * @param geometries array of objects, each containing an array of geoJSON features
     * @param container d3 selection of the parent that we append the geometries to
     * @param pathFunction d3 path function
     */
    out.addUserGeometriesToMap = function (geometries, container, pathFunction) {
        geometries.forEach((geometry) => {
            let group = container
                .append('g')
                .attr('id', geometry.statisticalRegions ? 'em-user-regions' : '')
                .attr('class', geometry.class ? geometry.class : '')

            let elements = group.selectAll('path').data(geometry.features).enter().append('path').attr('d', pathFunction)

            // Allow custom call chain modifications through onEach
            if (typeof geometry.onEach === 'function') {
                geometry.onEach(elements)
            }
        })
    }

    return out
}


/***/ }),

/***/ "./src/core/insets.js":
/*!****************************!*\
  !*** ./src/core/insets.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildInsets: () => (/* binding */ buildInsets),
/* harmony export */   removeInsets: () => (/* binding */ removeInsets)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");



/**
 * Build inset maps for a map template
 */
const buildInsets = function (out, withCenterPoints) {
    if (!out.insetBoxPosition_) {
        out.insetBoxPosition_ = [out.width_ - out.insetBoxWidth_ - 2 * out.insetBoxPadding_, 2 * out.insetBoxPadding_]
    }

    // add container to drawing group
    // Cannot read properties of undefined (reading 'svgId')
    let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId_)
    let drawingGroup = svg.select('#em-drawing-' + out.svgId_)
    const ing = drawingGroup
        .append('g')
        .attr('id', 'em-insets-group')
        .attr('class', 'em-insets')
        .attr('transform', 'translate(' + out.insetBoxPosition_[0] + ',' + out.insetBoxPosition_[1] + ')')

    if (out.insets_ === 'default') {
        //if needed, use default inset config
        out.insets_ = defaultInsetConfig(out.insetBoxWidth_, out.insetBoxPadding_)
    }

    // append each inset to map
    for (let i = 0; i < out.insets_.length; i++) {
        const config = out.insets_[i]
        config.svgId = config.svgId || 'inset' + config.geo + Math.random().toString(36).substring(7)

        //get svg element.
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + config.svgId)
        if (svg.size() == 0) {
            // Create it as an embeded SVG if it does not exist
            const x = config.x == undefined ? out.insetBoxPadding_ : config.x
            const y = config.y == undefined ? out.insetBoxPadding_ + i * (out.insetBoxPadding_ + out.insetBoxWidth_) : config.y
            const ggeo = ing
                .append('g')
                .attr('id', 'em-inset-' + config.svgId)
                .attr('class', 'em-inset')
                .attr('transform', 'translate(' + x + ',' + y + ')')
            ggeo.append('svg').attr('id', config.svgId)
        }

        // build inset
        // GISCO-2676 - PT azores inset has 2 insets with the same Geo, so second was overriding first:
        if (out.insetTemplates_[config.geo]) {
            //if inset already exists in map with same geo, then push both to an array
            let inset = buildInset(config, out, withCenterPoints)
            inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = [out.insetTemplates_[config.geo], inset]
        } else {
            let inset = buildInset(config, out, withCenterPoints)
            let drawnInset = inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = drawnInset
        }
    }

    return out
}

/** Build template for inset, based on main one */
const buildInset = function (config, out, withCenterPoints) {
    //TODO find a better way to do that

    //copy map
    //for(let key__ in map) {
    //mt[key__] = map[key__];
    //}

    const mt = (0,_map_template__WEBPACK_IMPORTED_MODULE_0__.mapTemplate)(config, withCenterPoints)

    //define default values for inset configs
    config = config || {}
    config.proj = config.proj || _defaultCRS[config.geo]
    config.scale = config.scale || out.insetScale_
    config.footnote = config.footnote || ''
    config.showSourceLink = config.showSourceLink || false
    config.zoomExtent = config.zoomExtent || out.insetZoomExtent_
    config.width = config.width || out.insetBoxWidth_
    config.height = config.height || out.insetBoxWidth_
    config.insets = config.insets || []
    config.insetTemplates = config.insetTemplates || {}
    config.callback = config.callback || undefined

    //copy main map attributes
    ;[
        'nutsLevel_',
        'nutsYear_',
        'hoverColor_',
        //'nutsbnStroke_', // DEPRECATED
        // 'nutsbnStrokeWidth_', // DEPRECATED
        'cntrgFillStyle_', // DEPRECATED
        'cntbnStroke_', // DEPRECATED
        'cntbnStrokeWidth_', // DEPRECATED
        'seaFillStyle_', // DEPRECATED
        'drawCoastalMargin_',
        'coastalMarginColor_', // DEPRECATED
        'coastalMarginWidth_', // DEPRECATED
        'coastalMarginStdDev_',
        'graticuleStroke_', // DEPRECATED
        'graticuleStrokeWidth_', // DEPRECATED
        'lg_',
        'projectionFunction_',
        'filterGeometriesFunction_',
        'processCentroids_',
    ].forEach(function (att) {
        mt[att] = out[att]
    })

    //copy stat map attributes/methods
    ;['stat', 'statData', 'legend', 'legendObj', 'noDataText', 'language', 'transitionDuration', 'tooltip_', 'classToText_'].forEach(function (att) {
        mt[att] = out[att]
    })

    //apply config values for inset
    for (let key in config) mt[key + '_'] = config[key]

    mt.isInset = true // flag for inset-specific settings e.g. CSS class for titles
    return mt
}

/**
 * Remove insets maps from the DOM
 */
const removeInsets = function (out) {
    if (out.insetTemplates_) {
        for (let template in out.insetTemplates_) {
            let id = out.insetTemplates_[template].svgId_
            let existing = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + id)
            // if (existing) existing.remove()
            if (existing) existing.html('') // empty them, but dont remove them.
        }
        out.insetTemplates_ = {} //  GISCO-2676
    }
}

/**
 * Default inset setting.
 * @param {*} s The width of the inset box
 * @param {*} p The padding
 */
const defaultInsetConfig = function (s, p) {
    const out = [
        { geo: 'IC', x: 0, y: 0, width: s, height: 0.3 * s },
        { geo: 'CARIB', x: 0, y: 0.3 * s + p, width: 0.5 * s, height: s },
        { geo: 'GF', x: 0.5 * s, y: 0.3 * s + p, width: 0.5 * s, height: 0.75 * s },
        {
            geo: 'YT',
            x: 0.5 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'RE',
            x: 0.75 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT20',
            x: 0,
            y: 1.3 * s + 2 * p,
            width: 0.75 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT30',
            x: 0.75 * s,
            y: 1.3 * s + 2 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        { geo: 'MT', x: 0, y: 1.55 * s + 3 * p, width: 0.25 * s, height: 0.25 * s },
        {
            geo: 'LI',
            x: 0.25 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_SV',
            x: 0.5 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_JM',
            x: 0.75 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        /*{geo:"IC", x:0, y:0}, {geo:"RE", x:dd, y:0}, {geo:"YT", x:2*dd, y:0},
		{geo:"GP", x:0, y:dd}, {geo:"MQ", x:dd, y:dd}, {geo:"GF",scale:"10M", x:2*dd, y:dd},
		{geo:"PT20", x:0, y:2*dd}, {geo:"PT30", x:dd, y:2*dd}, {geo:"MT", x:2*dd, y:2*dd},
		{geo:"LI",scale:"01M", x:0, y:3*dd}, {geo:"SJ_SV", x:dd, y:3*dd}, {geo:"SJ_JM",scale:"01M", x:2*dd, y:3*dd},*/
        //{geo:"CARIB", x:0, y:330}, {geo:"IS", x:dd, y:330}
    ]
    //hide graticule for insets
    for (let i = 0; i < out.length; i++) out[i].drawGraticule = false
    return out
}

/** Default CRS for each geo area */
const _defaultCRS = {
    EUR: '3035',
    IC: '32628',
    GP: '32620',
    MQ: '32620',
    GF: '32622',
    RE: '32740',
    YT: '32738',
    MT: '3035',
    PT20: '32626',
    PT30: '32628',
    LI: '3035',
    IS: '3035',
    SJ_SV: '3035',
    SJ_JM: '3035',
    CARIB: '32620',
    WORLD: '54030',
}


/***/ }),

/***/ "./src/core/kosovo.js":
/*!****************************!*\
  !*** ./src/core/kosovo.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   kosovoBnFeatures: () => (/* binding */ kosovoBnFeatures)
/* harmony export */ });
// mixed nuts dont draw nutsbn so we add them manually
const kosovoBnFeatures = {
  2021:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[3061,1303],[-152,-59],[-32,-66],[-65,72],[-96,7],[-16,59],[-64,19],[-56,-39],[-120,39],[-184,-19],[-16,26],[32,52],[-16,72],[24,40],[8,183]],[[2885,0],[-8,46],[-65,85],[-40,-7],[-40,40],[0,111],[80,13],[25,46],[72,13],[40,98],[-56,118],[144,196],[-24,79],[88,59],[-24,98],[-8,20],[24,39],[8,52],[48,72],[-88,125]],[[825,2638],[-112,-98],[-72,-7],[-88,-118],[-176,-39],[56,-91],[88,-33],[24,-53],[56,-39],[24,-91],[-56,-46],[24,-105],[-56,-92],[-104,0],[-48,-104],[-16,-40],[-57,7],[-40,-53],[-16,-78],[113,-118],[-97,-65],[-88,-99],[-80,20],[-80,-39],[-24,-13]],[[1098,2304],[-193,66],[24,39],[-16,39],[65,13],[0,33],[-65,79],[-88,65]],[[2308,1689],[-153,-20],[-64,59],[-40,7],[-96,-27],[-104,138],[-8,92],[-32,78],[-64,26],[-32,-59],[-24,0],[-56,86],[-40,137],[-25,65],[-56,0],[-56,46],[-64,-72],[-120,53],[-88,-40],[-88,46]]],"transform":{"scale":[37.761044752777565,38.54734205626113],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[962,0],[-29,75],[48,131],[21,35],[11,38],[32,117],[-24,44]],[[1021,440],[-64,-29],[-70,36],[-120,2],[3,121]],[[770,570],[-126,16],[-40,91],[-45,4],[-51,93],[-142,4]],[[275,891],[-131,-99],[30,-36],[24,-31],[-6,-86],[-98,-86],[13,-64],[-27,-38],[-80,-31]],[[366,778],[-37,22],[-54,91]]],"transform":{"scale":[113.2099448513097,114.12782081303801],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[536,0],[-24,45],[15,30],[45,92],[-1,44],[-2,37]],[[569,248],[-130,9],[-10,64]],[[429,321],[-64,10],[-78,94],[-83,13]],[[153,502],[-73,-51],[26,-84],[-48,-53],[-3,-52],[-55,-25]],[[204,438],[-51,64]]],"transform":{"scale":[203.12309601494124,202.56551463031246],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[310,138],[-36,-2],[-40,42]],[[234,178],[-123,65]],[[84,278],[-84,-147]],[[111,243],[-27,35]],[[292,0],[18,138]]],"transform":{"scale":[372.84281730215633,364.87611898580536],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1900,1275],[-30,27],[-27,-13],[-34,23],[-87,6],[25,59],[1,70],[20,34],[24,167]],[[1792,1648],[-116,1],[-62,77],[-89,-8],[-60,148],[7,86],[-4,15],[-13,60],[-45,28],[-33,-48],[-26,4],[-31,142],[-11,53],[5,43],[-19,44],[-39,8],[-40,49],[-52,-59],[-93,71],[-38,-6],[-16,-26]],[[945,2388],[-54,27],[-20,28],[-22,-3],[-17,22],[-25,1],[-10,10],[4,17],[27,14],[-15,29],[1,16],[68,1],[-8,16],[-5,30],[-14,29],[-27,42],[-25,22],[-30,41]],[[773,2730],[-89,-69],[-64,-4],[-82,-92],[-133,-15],[27,-93],[64,-43],[16,-50],[38,-44],[9,-75],[-48,-51],[5,-41],[6,-50],[-52,-84],[-78,14],[-35,-66],[-33,-61],[-45,11],[-35,-42],[-18,-72],[33,-71],[48,-55]],[[1017,2330],[-72,58]],[[307,1677],[-36,-12],[-25,-21],[-26,-10],[-76,-90],[-17,4],[-30,31],[-52,-14],[-26,-23],[-19,1]],[[2319,1185],[-116,-32],[-39,-52],[-42,70],[-68,23],[-12,58],[-43,23],[-42,-23],[-57,23]],[[2044,0],[-4,43],[-38,82],[-34,9],[-24,43],[13,97],[61,4],[32,41],[49,0],[37,82],[-26,118],[130,167],[-8,73],[74,46],[-2,18],[-9,92],[24,35],[7,49],[48,52],[-55,134]]],"transform":{"scale":[0.0006038339283908974,0.00036983475567765975],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '10M':{"type":"Topology","arcs":[[[659,439],[-54,17],[17,111]],[[622,567],[-93,31],[-25,92],[-36,11],[-29,97],[-23,1],[-63,3]],[[328,822],[-33,74],[-27,44]],[[268,940],[-72,-44],[-38,-31],[27,-86],[-14,-65],[-81,-78],[16,-58]],[[353,802],[-25,20]],[[106,578],[-41,-19],[-65,-28]],[[805,408],[-54,-21],[-92,52]],[[709,0],[-22,72],[0,17],[40,36],[18,67],[53,101],[16,64],[-9,51]]],"transform":{"scale":[0.001740521547911524,0.0010740945563829907],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '20M':{"type":"Topology","arcs":[[[380,252],[-21,26],[0,48]],[[359,326],[-49,17],[-56,107],[-51,11]],[[189,472],[-34,68]],[[155,540],[-66,-39],[18,-66],[-54,-68],[8,-35]],[[61,332],[-21,-13],[-10,-12],[-13,5],[-17,-7]],[[464,234],[-84,18]],[[409,0],[-14,46],[61,110],[8,78]]],"transform":{"scale":[0.003018276831896498,0.0018697201537037245],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '60M':{"type":"Topology","arcs":[[[235,156],[-13,46]],[[222,202],[-96,84]],[[117,293],[-21,42]],[[96,335],[-58,-129]],[[126,286],[-9,7]],[[38,206],[-38,-17]],[[287,145],[-52,11]],[[253,0],[34,145]]],"transform":{"scale":[0.004879722822299564,0.0030138772626866006],"translate":[20.352928393000074,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}}
    }
  },
  2024:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[728,1508],[-48,12],[-22,18],[-15,-5],[-16,13],[-22,-4],[-10,8],[0,13],[21,13],[-16,17],[0,13],[58,9],[-5,8],[-10,22],[-16,17],[-27,25],[-21,13],[-32,26]],[[1912,0],[-6,30],[-42,51],[-32,0],[-21,30],[0,69],[53,8],[21,35],[43,4],[26,60],[-37,81],[96,129],[-16,51],[58,43],[0,9],[-21,64],[16,26],[5,34],[32,43],[-58,85]],[[250,942],[-27,-13],[-21,-17],[-21,-8],[-59,-73],[-16,0],[-26,17],[-43,-13],[-21,-21],[-16,0]],[[1657,861],[-27,13],[-21,-13],[-32,13],[-74,-9],[16,47],[-6,47],[11,26],[5,120]],[[1529,1105],[-100,-17],[-64,47],[-75,-17],[-63,94],[-6,60],[-5,13],[-16,38],[-42,13],[-22,-38],[-21,0],[-42,94],[-16,34],[0,30],[-21,30],[-32,0],[-38,30],[-42,-47],[-85,39],[-32,-9],[-10,-21]],[[547,1726],[-69,-60],[-53,-13],[-59,-73],[-111,-25],[32,-60],[58,-22],[16,-34],[37,-26],[16,-51],[-37,-39],[5,-30],[11,-34],[-37,-64],[-64,4],[-26,-51],[-22,-47],[-42,4],[-21,-34],[-11,-52],[37,-47],[43,-30]],[[797,1478],[-69,30]],[[2029,852],[-96,-38],[-32,-39],[-42,43],[-59,4],[-16,39],[-42,13],[-32,-22],[-53,9]]],"transform":{"scale":[56.97629608361119,58.91534666536319],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[242,508],[-33,47],[-27,27]],[[637,0],[-25,46],[-2,12],[30,29],[7,47],[34,75],[7,45],[-12,33]],[[83,318],[-32,-18],[-51,-26]],[[552,290],[-46,5],[3,78]],[[509,373],[-79,8],[-30,59],[-30,3],[-34,62],[-19,-1],[-52,-6]],[[182,582],[-55,-39],[-28,-25],[30,-56],[-5,-45],[-59,-62],[18,-37]],[[265,498],[-23,10]],[[676,287],[-43,-21],[-81,24]]],"transform":{"scale":[171.07449827433382,174.72145763645509],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[50,191],[-17,-11],[-8,-10],[-11,1],[-14,-6]],[[305,224],[-44,6],[-58,68],[-44,2]],[[109,350],[-52,-36],[21,-45],[-38,-54],[10,-24]],[[159,300],[-14,6]],[[145,306],[-36,44]],[[381,0],[-17,31],[41,85],[-1,57]],[[404,173],[-74,2]],[[330,175],[-20,15],[-5,34]]],"transform":{"scale":[286.13294356075795,290.536823841191],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[258,111],[-47,1]],[[32,123],[-32,-17]],[[211,112],[-16,32]],[[195,144],[-94,49]],[[70,225],[-38,-102]],[[101,193],[-8,4]],[[93,197],[-23,28]],[[243,0],[15,111]]],"transform":{"scale":[447.98943164212585,451.9461704196305],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1543,0],[-4,32],[-28,65],[-24,5],[-19,33],[10,70],[47,5],[23,33],[38,0],[28,59],[-19,92],[94,124],[-5,54],[56,37],[0,11],[-9,70],[19,27],[4,38],[38,38],[-42,102]],[[1750,895],[-85,-27],[-32,-37],[-29,54],[-56,16],[-5,43],[-32,16],[-33,-16],[-43,16]],[[1435,960],[-23,22],[-19,-11],[-28,16],[-66,5],[19,44],[0,54],[14,26],[19,125]],[[230,1262],[-24,-5],[-23,-16],[-19,-11],[-56,-65],[-14,0],[-24,27],[-37,-11],[-19,-21],[-14,5]],[[1351,1241],[-84,0],[-47,59],[-71,-6],[-42,114],[5,64],[-5,11],[-9,43],[-33,22],[-24,-38],[-23,6],[-23,108],[-5,37],[0,33],[-14,32],[-28,5],[-29,38],[-42,-43],[-70,54],[-28,-5],[-10,-22]],[[582,2055],[-66,-49],[-47,-5],[-61,-70],[-103,-11],[19,-70],[51,-32],[10,-38],[28,-32],[9,-54],[-37,-44],[4,-26],[5,-38],[-37,-65],[-61,11],[-29,-49],[-23,-48],[-33,11],[-28,-33],[-14,-54],[28,-54],[33,-43]],[[769,1753],[-56,48]],[[713,1801],[-42,17],[-14,21],[-19,0],[-9,16],[-19,0],[-10,6],[5,16],[19,11],[-9,21],[0,11],[51,0],[-5,11],[-4,22],[-10,26],[-23,27],[-19,22],[-23,27]]],"transform":{"scale":[0.0007994261320208862,0.0004913384355349169],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[539,0],[-17,52],[0,13],[30,27],[13,48],[41,74],[13,47],[-8,38]],[[611,299],[-41,-16],[-69,37]],[[501,320],[-41,13],[12,81]],[[80,421],[-31,-12],[-49,-20]],[[472,414],[-71,24],[-18,66],[-28,7],[-21,72],[-18,0],[-47,2]],[[203,686],[-54,-32],[-29,-22],[21,-63],[-12,-47],[-60,-57],[11,-44]],[[269,585],[-20,16]],[[249,601],[-25,53],[-21,32]]],"transform":{"scale":[0.002290098349828638,0.0014718665962452685],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[337,0],[-12,36],[51,84],[6,62]],[[382,182],[-69,13]],[[313,195],[-17,20],[-1,37]],[[50,256],[-17,-10],[-8,-8],[-11,3],[-14,-5]],[[295,252],[-40,13],[-46,82],[-41,9]],[[127,417],[-54,-30],[15,-51],[-44,-53],[6,-27]],[[168,356],[-12,10]],[[156,366],[-29,51]]],"transform":{"scale":[0.0036618323062750017,0.0024213440887871805],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[220,0],[29,116]],[[249,116],[-45,8]],[[204,124],[-12,37]],[[192,161],[-83,66]],[[109,227],[-8,6]],[[33,163],[-33,-12]],[[83,266],[-50,-103]],[[101,233],[-18,33]]],"transform":{"scale":[0.005617750767056427,0.003795866485053587],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}}
    }
  }
}

/***/ }),

/***/ "./src/core/labels.js":
/*!****************************!*\
  !*** ./src/core/labels.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULTLABELS: () => (/* binding */ DEFAULTLABELS),
/* harmony export */   addLabelsToMap: () => (/* binding */ addLabelsToMap),
/* harmony export */   statLabelsTextFunction: () => (/* binding */ statLabelsTextFunction),
/* harmony export */   updateLabels: () => (/* binding */ updateLabels),
/* harmony export */   updateValuesLabels: () => (/* binding */ updateValuesLabels)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");



// handles all map labels e.g. stat values, or labels specified in map.labels({labels:[text:'myLabel', x:123, y: 123]})

/**
 * @function addLabelsToMap
 * @param map eurostatmap map instance
 * @param zg zoomgroup (d3 selection of zoomable elements)
 * @description appends text labels to the map. Labels can be countries, country codes, ocean names or statistical values
 */
const addLabelsToMap = function (map, zg) {
    // set defaults
    if (!map.labels_.config) map.labels_.config = DEFAULTLABELS
    if (!map.labels_.statLabelsPositions) map.labels_.statLabelsPositions = DEFAULTSTATLABELPOSITIONS

    // clear existing or append new container
    let existing = zg.select('#em-labels')
    let labelsContainer = existing.empty() ? zg.append('g').attr('id', 'em-labels') : existing

    //for statistical values on maps without centroids, we need to add centroids initially, then add text to them later once the stat data is loaded
    if (map.labels_?.values && map._mapType !== 'ps') appendStatLabelCentroidsToMap(map, labelsContainer)

    // get labels array
    let labelsArray = map.labels_?.labels || DEFAULTLABELS[`${map.geo}_${map.proj_}.cc`]

    // append other labels to map
    if (labelsArray) {
        //common styles between all label shadows
        const shadowg = labelsContainer.append('g').attr('class', 'em-label-shadows').attr('text-anchor', 'middle')

        //common styles between all labels
        const labelg = labelsContainer.append('g').attr('class', 'em-labels').attr('text-anchor', 'middle')

        //SHADOWS
        if (map.labels_?.shadows) {
            let shadows = shadowg
                .selectAll('text')
                .data(labelsArray)
                .enter()
                .append('text')
                .attr('id', (d) => 'em-label-shadow-' + d.text.replace(/\s+/g, '-'))
                .attr('class', (d) => 'em-label-shadow em-label-shadow-' + d.class)
                .attr('x', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[0]
                })
                .attr('y', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[1]
                })
                .attr('dy', -7) // set y position of bottom of text
                .attr('transform', (d) => {
                    if (d.rotate) {
                        let pos = map._projection([d.x, d.y])
                        let x = pos[0]
                        let y = pos[1]
                        return `translate(${x},${y}) rotate(${d.rotate})`
                    } else {
                        return 'rotate(0)'
                    }
                })
                .text(function (d) {
                    return d.text
                }) // define the text to display
        }

        //LABEL texts
        labelg
            .selectAll('text')
            .data(labelsArray)
            .enter()
            .append('text')
            .attr('id', (d) => 'em-label-' + d.text.replace(/\s+/g, '-'))
            .attr('class', (d) => 'em-label em-label-' + d.class)
            //position label
            .attr('x', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[0]
            })
            .attr('y', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[1]
            })
            .attr('dy', -7) // set y position of bottom of text
            //transform labels which have a "rotate" property in the labels config. For rotated labels, their X,Y must also be set in the transform.
            // note: dont apply to country code labels
            .attr('transform', (d) => {
                if (d.rotate) {
                    let pos = map._projection([d.x, d.y])
                    let x = pos[0]
                    let y = pos[1]
                    return `translate(${x},${y}) rotate(${d.rotate})`
                } else {
                    return 'rotate(0)'
                }
            })
            .text(function (d) {
                return d.text
            }) // define the text to display
    }
}

/**
 * @function updateLabels
 * @description update existing map labels
 */
const updateLabels = function (map) {
    if (map.svg_) {
        // Clear previous labels
        let prevLabels = map.svg_.selectAll('#em-labels > *')
        if (prevLabels) prevLabels.remove()

        // Main map
        if (map.labels_) {
            const masterConfig = map.labels_
            let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
            addLabelsToMap(map, zg)
            if (masterConfig.values && map.updateValuesLabels) {
                map.updateValuesLabels(map)
            }

            // Define the callback to apply to each inset
            const applyLabelsCallback = (map) => {
                if (masterConfig) {
                    let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
                    if (map.labels_) addLabelsToMap(map, zg)
                    if (masterConfig.values && map.updateValuesLabels) {
                        map.updateValuesLabels(map)
                    }
                }
            }

            // Apply labels to all insets using the executeForAllInsets function
            if (map.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_0__.executeForAllInsets)(map.insetTemplates_, map.svgId_, applyLabelsCallback)
            }
        }
    }
}

/**
 * @description update the statistical values labels on the map
 * @param {Object} map eurostat-map map instance
 * @return {map} out
 * NOTE: THIS FUNCTION IS NOT CALLED FOR PROPORTIONAL SYMBOL MAPS
 */
const updateValuesLabels = function (map) {
    if (!map) {
        console.warn('No map specified')
        return
    }

    //clear previous labels
    let prevLabels = map.svg_.selectAll('g.em-stat-label > *')
    prevLabels.remove()
    let prevShadows = map.svg_.selectAll('g.em-stat-label-shadow > *')
    prevShadows.remove()
    let statLabels = map.svg_.selectAll('g.em-stat-label')

    // filter stat-label elements to only show those with data
    const filterFunction = map.labels_?.statLabelsFilterFunction ? map.labels_?.statLabelsFilterFunction : defaultStatLabelFilter
    const statData = map.statData()
    statLabels
        .filter((rg) => filterFunction(rg, map))
        // .append('text')
        .each(function (d) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this)
            const labelText = statLabelsTextFunction(d, statData) // Use 'd' directly for the label text

            // Append rectangle behind label
            if (map.labels_.backgrounds) appendRect(labelText, sel)

            // Append text after the rectangle
            sel.append('text').text(labelText).attr('class', 'em-stat-label-text')
        })

    // Function to append a rectangle behind the label
    function appendRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    //add shadows to labels
    if (map.labels_?.shadows) {
        map.svg_
            .selectAll('g.em-stat-label-shadow')
            .filter((rg) => filterFunction(rg, map))
            .append('text')
            .text((d) => statLabelsTextFunction(d, statData)) // Use 'd' directly for the label text)
    }
    return map
}

/**
 * @description text function for statistical labelling
 * @param {Object} d d3 selection json data element
 * @return {string}
 */
const statLabelsTextFunction = (d, statData) => {
    if (statData && statData?.get) {
        const sv = statData.get(d.properties.id)
        if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
            return ''
        } else {
            if (sv.value !== ':') {
                return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.spaceAsThousandSeparator)(sv.value)
            }
        }
    }
}

/**
 * @description function for filtering statistical labels
 * @param {Object} d d3 selection json data element
 * @return {boolean}
 */
const defaultStatLabelFilter = (region, map) => {
    const s = map.statData()
    const sv = s.get(region.properties.id)
    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
        return false
    } else {
        return true
    }
}

const appendStatLabelCentroidsToMap = function (map, labelsContainer) {
    //values label shadows parent <g>
    const gsls = labelsContainer.append('g').attr('class', 'em-stat-labels-shadows').attr('text-anchor', 'middle')

    // values labels parent <g>
    const statLabelsGroup = labelsContainer.append('g').attr('class', 'em-stat-labels').attr('text-anchor', 'middle')

    // our features array
    let statLabelRegions = []

    // deafult geometries
    if (map.Geometries.geoJSONs.nutsrg) {
        //allow for stat label positioning by adding a g element here, then adding the values in the mapType updateValuesLabels function
        if (map.nutsLevel_ == 'mixed') {
            statLabelRegions = map.Geometries.geoJSONs.mixed.rg0.concat(
                map.Geometries.geoJSONs.mixed.rg1,
                map.Geometries.geoJSONs.mixed.rg2,
                map.Geometries.geoJSONs.mixed.rg3,
                map.Geometries.geoJSONs.cntrg // NEW: allow labels for cntrg
            )
        } else {
            statLabelRegions = map.Geometries.geoJSONs.nutsrg.concat(map.Geometries.geoJSONs.cntrg)
        }
    } else if (map.Geometries.userGeometries) {
        // user defined geometries
        statLabelRegions = map.Geometries.statisticalRegions.features
    }

    //TODO: dont add labels for regions that are not visible? what about panning and zooming though. Only really an issue for mixed NUTS.

    // stats labels
    const filteredRegions = statLabelRegions.filter((d, i, self) => i === self.findIndex((t) => t.properties.id === d.properties.id))
    statLabelsGroup
        .selectAll('g')
        .data(filteredRegions)
        .enter()
        .append('g')
        .attr('transform', function (d) {
            // use predefined label positioning
            if (map.labels_.statLabelsPositions[d.properties.id]) {
                const position = map.labels_.statLabelsPositions[d.properties.id]
                let pos = map._projection([position.x, position.y])
                let x = pos[0].toFixed(3)
                let y = pos[1].toFixed(3)
                return `translate(${x},${y})`
            } else {
                let centroid = map._pathFunction.centroid(d)

                if (map.labels_.processValueLabelCentroids) {
                    centroid = map.labels_.processValueLabelCentroids(d, centroid)
                }
                // otherwise we calculate centroids
                return 'translate(' + centroid + ')'
            }
        })
        .attr('class', 'em-stat-label')

    // stat labels shadows
    if (map.labels_?.shadows) {
        gsls.selectAll('g')
            .data(statLabelRegions)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                // use predefined label positioning
                if (map.labels_.statLabelsPositions[d.properties.id]) {
                    let pos = map._projection([
                        map.labels_.statLabelsPositions[d.properties.id].x,
                        map.labels_.statLabelsPositions[d.properties.id].y,
                    ])
                    let x = pos[0].toFixed(3)
                    let y = pos[1].toFixed(3)
                    return `translate(${x},${y})`
                } else {
                    let centroid = map._pathFunction.centroid(d)

                    if (map.labels_.processValueLabelCentroids) {
                        centroid = map.labels_.processValueLabelCentroids(d, centroid)
                    }
                    // otherwise we calculate centroids
                    return 'translate(' + centroid + ')'
                }
            })

            .attr('class', 'em-stat-label-shadow')
    }
}

/**
 * Default labels for country / geographical names.
 * Using centroids would clash with proportional symbols, and are generally not ideal placements, so labels are positioned independently
 * Labels are provided for all supported languages: "en","fr" and "de" (defined using map.language())
 */
const DEFAULTLABELS = {
    EUR_3035: {
        cc: [
            { text: 'AL', x: 5150000, y: 2060000, class: 'cc', size: 7 },
            { text: 'AT', x: 4670000, y: 2690000, class: 'cc', size: 18 },
            { text: 'BE', x: 3930000, y: 3010000, class: 'cc', size: 17 },
            { text: 'BG', x: 5567000, y: 2250000, class: 'cc', size: 22 },
            { text: 'HR', x: 4840000, y: 2480000, class: 'cc', size: 10 },
            { text: 'CY', x: 6426000, y: 1480000, class: 'cc', size: 10 },
            { text: 'CZ', x: 4707000, y: 2920000, class: 'cc', size: 18 },
            { text: 'DK', x: 4316000, y: 3621000, class: 'cc', size: 20 },
            { text: 'EE', x: 5220000, y: 3990000, class: 'cc', size: 12 },
            { text: 'FI', x: 5150000, y: 4424000, class: 'cc', size: 20 },
            { text: 'FR', x: 3767740, y: 2662817, class: 'cc', size: 22 },
            { text: 'DE', x: 4347284, y: 3093276, class: 'cc', size: 22 },
            { text: 'EL', x: 5370000, y: 1750000, class: 'cc', size: 22 },
            { text: 'HU', x: 5020000, y: 2630000, class: 'cc', size: 17 },
            { text: 'IS', x: 3040000, y: 4833000, class: 'cc', size: 10 },
            { text: 'IE', x: 3136000, y: 3394000, class: 'cc', size: 17 },
            { text: 'IT', x: 4469967, y: 2181963, class: 'cc', size: 22 },
            { text: 'LV', x: 5290000, y: 3800000, class: 'cc', size: 12 },
            { text: 'LT', x: 5190000, y: 3630000, class: 'cc', size: 12 },
            { text: 'LU', x: 4120000, y: 2940000, class: 'cc', size: 12 },
            { text: 'MT', x: 4731000, y: 1300000, class: 'cc', size: 10 },
            { text: 'ME', x: 5073000, y: 2185000, class: 'cc', size: 7 },
            { text: 'GE', x: 6942680, y: 2660000, class: 'cc' },
            { text: 'UA', x: 5890000, y: 3050000, class: 'cc' },
            { text: 'BA', x: 4949262, y: 2338688, class: 'cc' },
            { text: 'MD', x: 5740000, y: 2790000, class: 'cc' },

            { text: 'MK', x: 5300000, y: 2080000, class: 'cc', size: 10 },
            { text: 'NL', x: 4020000, y: 3208000, class: 'cc', size: 17 },
            { text: 'NO', x: 4300000, y: 4147000, class: 'cc', size: 20 },
            { text: 'PL', x: 4964000, y: 3200000, class: 'cc', size: 22 },
            { text: 'PT', x: 2770000, y: 1990000, class: 'cc', size: 18 },
            { text: 'RO', x: 5451000, y: 2600000, class: 'cc', size: 22 },
            { text: 'RS', x: 5200000, y: 2350000, class: 'cc', size: 10 },
            { text: 'SK', x: 5040000, y: 2860000, class: 'cc', size: 12 },
            { text: 'SI', x: 4675000, y: 2500000, class: 'cc', size: 10 },
            { text: 'ES', x: 3160096, y: 1900000, class: 'cc', size: 22 },
            { text: 'SE', x: 4630000, y: 4000000, class: 'cc', size: 20 },
            { text: 'CH', x: 4170000, y: 2600000, class: 'cc', size: 16 },
            { text: 'TR', x: 6510000, y: 2100000, class: 'cc', size: 22 },
            { text: 'UK', x: 3558000, y: 3250000, class: 'cc', size: 17 },
        ],
        en: [
            { text: 'MEDITERRANEAN SEA', x: 3980000, y: 1600000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTIC OCEAN', x: 2820000, y: 2540000, class: 'seas', size: 12, letterSpacing: 2 },
            { text: 'NORTH SEA', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'BALTIC SEA', x: 4900000, y: 3730000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGIAN SEA', x: 3850000, y: 4800000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'BLACK SEA', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 4 },
            { text: 'ALBANIA', cc: 'AL', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUSTRIA', cc: 'AT', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIUM', cc: 'BE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIA', cc: 'BG', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIA', cc: 'HR', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CYPRUS', cc: 'CY', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'CZECHIA', cc: 'CZ', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DENMARK', cc: 'DK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIA', cc: 'EE', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINLAND', cc: 'FI', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', cc: 'FR', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'GERMANY', cc: 'DE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GREECE', cc: 'EL', x: 5470000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HUNGARY', cc: 'HU', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ICELAND', cc: 'IS', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRELAND', cc: 'IE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALY', cc: 'IT', x: 4469967, y: 2181963, class: 'countries', size: 12 },
            { text: 'LATVIA', cc: 'LV', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITHUANIA', cc: 'LT', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', cc: 'LU', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', cc: 'MT', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', cc: 'ME', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'N. MACEDONIA', cc: 'MK', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NETHERLANDS', cc: 'NL', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWAY', cc: 'NO', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLAND', cc: 'PL', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', cc: 'PT', x: 2830000, y: 1990000, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROMANIA', cc: 'RO', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIA', cc: 'RS', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAKIA', cc: 'SK', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVENIA', cc: 'SI', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPAIN', cc: 'ES', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SWEDEN', cc: 'SE', x: 4630000, y: 4100000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SWITZERLAND', cc: 'CH', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURKEY', cc: 'TR', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'U.K.', cc: 'UK', x: 3558000, y: 3250000, class: 'countries', size: 12 },
        ],
        fr: [
            { text: 'MER MÉDITERRANÉE', x: 5472000, y: 1242000, class: 'seas', size: 12 },
            { text: 'OCÈAN ATLANTIQUE', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'MER DU NORD', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'MER BALTIQUE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'MER DE NORVÈGE', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'MER NOIRE', x: 6265000, y: 2472000, class: 'seas', size: 12 },
            { text: 'ALBANIE', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUTRICHE', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIQUE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIE', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIE', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CHYPRE', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TCHÉQUIE', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DANEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIE', x: 5220000, y: 3990000, class: 'countries', size: 10 },
            { text: 'FINLANDE', x: 5125000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'ALLEMAGNE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GRÈCE', x: 5420000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HONGRIE', x: 5020000, y: 2654000, class: 'countries', size: 10 },
            { text: 'ISLANDE', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLANDE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIE', x: 4500000, y: 2181963, class: 'countries', size: 12 },
            { text: 'LETTONIE', x: 5290000, y: 3776000, class: 'countries', size: 10 },
            { text: 'LITUANIE', x: 5190000, y: 3630000, class: 'countries', size: 10 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTE', x: 4731000, y: 1335000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'MAC. DU NORD', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'PAYS-BAS', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORVEGE', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLOGNE', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROUMANIE', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIE', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAQUIE', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVÉNIE', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -35 },
            { text: 'ESPAGNE', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SUÈDE', x: 4700000, y: 4401000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SUISSE', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURQUIE', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'ROYAUME-UNI', x: 3558000, y: 3250000, class: 'countries', size: 10 },
        ],
        de: [
            { text: 'MITTELMEER', x: 5472000, y: 1200000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTISCHER OZEAN', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'NORDSEE', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'OSTSEE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGISCHE MEER', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'SCHWARZE MEER', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'ALBANIEN', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'ÖSTERREICH', x: 4650000, y: 2629000, class: 'countries', size: 7 },
            { text: 'BELGIEN', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIEN', x: 5567000, y: 2256000, class: 'countries', size: 10 },
            { text: 'KROATIEN', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'ZYPERN', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TSCHECHIEN', x: 4707000, y: 2885000, class: 'countries', size: 7 },
            { text: 'DÄNEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTLAND', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINNLAND', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANKREICH', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'DEUTSCHLAND', x: 4347284, y: 3093276, class: 'countries', size: 10 },
            { text: 'GRIECHENLAND', x: 5550000, y: 1500000, class: 'countries', size: 10 },
            { text: 'UNGARN', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ISLAND', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLAND', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIEN', x: 4469967, y: 2181963, class: 'countries', size: 12, rotate: 35 },
            { text: 'LETTLAND', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITAUEN', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'NORDMAZEDONIEN', x: 5350000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NIEDERLANDE', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWEGEN', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLEN', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'RUMÄNIEN', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIEN', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOWAKEI', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOWENIEN', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPANIEN', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SCHWEDEN', x: 4670000, y: 4180000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SCHWEIZ', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TRUTHAHN', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'VEREINIGTES', x: 3550000, y: 3520000, class: 'countries', size: 10 },
            { text: 'KÖNIGREICH', x: 3550000, y: 3420000, class: 'countries', size: 10 },
        ],
    },
    IC_32628: {
        cc: [{ text: 'ES', x: 420468, y: 3180647, class: 'cc', size: 12 }],
        en: [{ text: 'Canary Islands', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        fr: [{ text: 'Les îles Canaries', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        de: [{ text: 'Kanarische Inseln', x: 410000, y: 3180647, class: 'countries', size: 12 }],
    },
    GP_32620: {
        cc: [{ text: 'FR', x: 667000, y: 1740000, class: 'cc', size: 12 }],
        en: [{ text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 12 }],
    },
    MQ_32620: {
        cc: [{ text: 'FR', x: 716521, y: 1621322, class: 'cc', size: 12 }],
        en: [{ text: 'Martinique', x: 716521, y: 1621322, class: 'countries', size: 12 }],
    },
    GF_32622: {
        cc: [{ text: 'FR', x: 266852, y: 444074, class: 'cc', size: 12 }],
        en: [{ text: 'Guyane', x: 266852, y: 444074, class: 'countries', size: 12 }],
        de: [{ text: 'Guayana', x: 266852, y: 444074, class: 'countries', size: 12 }],
    },
    RE_32740: {
        cc: [{ text: 'FR', x: 348011, y: 7680000, class: 'cc', size: 10 }],
        en: [{ text: 'Réunion', x: 348011, y: 7680000, class: 'countries', size: 10 }],
    },
    YT_32738: {
        cc: [{ text: 'FR', x: 516549, y: 8593920, class: 'cc', size: 10 }],
        en: [{ text: 'Mayotte', x: 516549, y: 8593920, class: 'countries', size: 10 }],
    },
    MT_3035: {
        cc: [{ text: 'MT', x: 4719755, y: 1410701, class: 'cc', size: 10 }],
        en: [{ text: 'Malta', x: 4719755, y: 1410701, class: 'countries', size: 10 }],
    },
    PT20_32626: {
        cc: [{ text: 'PT', x: 397418, y: 4320000, class: 'cc', size: 10 }],
        en: [{ text: 'Azores', x: 397418, y: 4320000, class: 'countries', size: 10 }],
        fr: [{ text: 'Açores', x: 397418, y: 4271471, class: 'countries', size: 10 }],
        de: [{ text: 'Azoren', x: 397418, y: 4271471, class: 'countries', size: 10 }],
    },
    PT30_32628: {
        cc: [{ text: 'PT', x: 333586, y: 3624000, class: 'cc', size: 10, rotate: 30 }],
        en: [{ text: 'Madeira', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
        fr: [{ text: 'Madère', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
    },
    LI_3035: {
        cc: [{ text: 'LI', x: 4287060, y: 2660000, class: 'cc', size: 12 }],
        en: [{ text: 'Liechtenstein', x: 4287060, y: 2679000, class: 'countries', size: 7 }],
    },
    IS_3035: {
        cc: [{ text: 'IS', x: 3011804, y: 4960000, class: 'cc', size: 12 }],
        en: [{ text: 'Iceland', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        fr: [{ text: 'Islande', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        de: [{ text: 'Island', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
    },
    SJ_SV_3035: {
        cc: [{ text: 'NO', x: 4570000, y: 6260000, class: 'cc', size: 10 }],
        en: [{ text: 'Svalbard', x: 4570000, y: 6260000, class: 'countries', size: 10 }],
        de: [{ text: 'Spitzbergen', x: 4570000, y: 6260000, class: 'countries', size: 7 }],
    },
    SJ_JM_3035: {
        cc: [{ text: 'NO', x: 3647762, y: 5420300, class: 'cc', size: 10 }],
        en: [{ text: 'Jan Mayen', x: 3647762, y: 5420300, class: 'countries', size: 7 }],
    },
    CARIB_32620: {
        cc: [
            { text: 'FR', x: 700000, y: 1810000, class: 'cc', size: 10 },
            { text: 'FR', x: 640000, y: 1590000, class: 'cc', size: 10 },
            { text: 'FR', x: 540000, y: 1962000, class: 'cc', size: 7 },
        ],
        en: [
            { text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 10 },
            { text: 'Martinique', x: 570000, y: 1590000, class: 'countries', size: 10 },
            { text: 'Saint Martin', x: 597000, y: 1962000, class: 'countries', size: 7 },
        ],
    },
    // note: WORLD x/y are in EPSG:4326 then reprojected by d3 to EPSG:54030
    WORLD_54030: {
        en: [
            { text: 'NORTH ATLANTIC', x: -45, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH ATLANTIC', x: -15, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH PACIFIC', x: -126, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'NORTH', x: -136, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'PACIFIC', x: -134, y: 20, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'INDIAN OCEAN', x: 80, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTHERN OCEAN', x: -5, y: -67, class: 'seas', size: 10, letterSpacing: 6 },
        ],
    },
}

const DEFAULTSTATLABELPOSITIONS = {
    AL: { x: 5150000, y: 2000000 },
    AT: { x: 4670000, y: 2740000 },
    BE: { x: 3930000, y: 3060000 },
    BG: { x: 5567000, y: 2300000 },
    HR: { x: 4657718, y: 2400243 },
    CY: { x: 6426000, y: 1570000 },
    CH: { x: 4170000, y: 2600000 },
    CZ: { x: 4707000, y: 2950000 },
    DK: { x: 4316000, y: 3621000 },
    EE: { x: 5220000, y: 4050000 },
    FI: { x: 5150000, y: 4424000 },
    FR: { x: 3767740, y: 2662817 },
    DE: { x: 4347284, y: 3093276 },
    EL: { x: 5370000, y: 1750000 },
    HU: { x: 5020000, y: 2670000 },
    IS: { x: 3040000, y: 4833000 },
    IE: { x: 3136000, y: 3394000 },
    IT: { x: 4500000, y: 2181963 },
    LV: { x: 5290000, y: 3840000 },
    LT: { x: 5190000, y: 3670000 },
    LU: { x: 4120000, y: 2940000 },
    MT: { x: 4880000, y: 1480000 },
    GE: { x: 6912680, y: 2696554 },
    UA: { x: 5865507, y: 3130158 },
    BA: { x: 4959262, y: 2368688 },
    MD: { x: 5736016, y: 2835957 },
    ME: { x: 5073000, y: 2230000 },
    MK: { x: 5300000, y: 2130000 },
    NL: { x: 4020000, y: 3208000 },
    NO: { x: 4300000, y: 4147000 },
    PL: { x: 4964000, y: 3200000 },
    PT: { x: 2760000, y: 1990000 },
    RO: { x: 5451000, y: 2600000 },
    RS: { x: 5200000, y: 2370000 },
    SK: { x: 5040000, y: 2890000 },
    SI: { x: 4660000, y: 2550000 },
    ES: { x: 3200000, y: 2000000 },
    SE: { x: 4630000, y: 4000000 },
    TR: { x: 6510000, y: 2100000 },
    UK: { x: 3558000, y: 3250000 },
    RU: { x: 6842086, y: 3230517 },
}


/***/ }),

/***/ "./src/core/map-template.js":
/*!**********************************!*\
  !*** ./src/core/map-template.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapTemplate: () => (/* binding */ mapTemplate)
/* harmony export */ });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/src/robinson.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _annotations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotations */ "./src/core/annotations.js");
/* harmony import */ var _labels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels */ "./src/core/labels.js");
/* harmony import */ var _deprecated__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deprecated */ "./src/core/deprecated.js");
/* harmony import */ var _geometries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geometries */ "./src/core/geometries.js");
/* harmony import */ var _insets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./insets */ "./src/core/insets.js");
/* harmony import */ var _stamps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stamps */ "./src/core/stamps.js");
/* harmony import */ var _cartograms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cartograms */ "./src/core/cartograms.js");














// set default d3 locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_9__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * The map template: only the geometrical part.
 * To be used as a base map for a statistical map.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const mapTemplate = function (config, withCenterPoints, mapType) {
    //build map template object
    const out = {}
    out._mapType = mapType

    // expose imported function to other modules
    out.updateValuesLabels = _labels__WEBPACK_IMPORTED_MODULE_3__.updateValuesLabels

    //map
    out.svgId_ = 'map'
    out.svg_ = undefined
    out.width_ = Math.min(795, window.innerWidth)
    out.height_ = 0
    out.containerId_ = undefined

    //geographical focus
    out.gridCartogram_ = false // draw geometries as grid cells
    out.gridCartogramShape_ = 'square' // square or hexagon
    out.gridCartogramMargins_ = { top: 80, right: 50, bottom: 80, left: 150 }
    out.gridCartogramCellPadding_ = 4
    out.gridCartogramPositions_ = undefined //user defined cartograms
    out.nutsLevel_ = 3 // 0,1,2,3, or 'mixed'
    out.nutsYear_ = 2024
    out.geo_ = 'EUR'
    out.proj_ = '3035'
    out.projectionFunction_ = undefined // e.g. d3.geoRobinson()
    out.filterGeometriesFunction_ = undefined // user defined filter function
    out.scale_ = '20M' //TODO choose automatically, depending on pixelSize ?
    out.zoomExtent_ = undefined
    out.maxBounds_ = { xMin: -Infinity, yMin: -Infinity, xMax: Infinity, yMax: Infinity }
    out.geometries_ = undefined // [{id:String, data:geojson, class:function}] user-defined geometries
    out.processCentroids_ = undefined // runs over symbol centroids
    out.position_ = { x: undefined, y: undefined, z: undefined } // map view

    //map title
    out.title_ = ''
    out.titlePosition_ = undefined

    //map subtitle
    out.subtitle_ = ''
    out.subtitlePosition_ = undefined

    //scalebar
    out.showScalebar_ = false
    out.scalebarPosition_ = []
    out.scalebarUnits_ = ' km' //label
    out.scalebarTextOffset_ = [0, 12]
    out.scalebarMaxWidth_ = 150 //px
    out.scalebarHeight_ = 90 //px
    out.scalebarStrokeWidth_ = 1 //px
    out.scalebarSegmentHeight_ = 6
    out.scalebarTickHeight_ = 8

    // stamp annotation
    out.stamp_ = undefined //e.g {x,y,text,size}

    //tooltip
    out.tooltip_ = {
        fontSize: '14px',
        transitionDuration: 200,
        xOffset: 0,
        yOffset: 0,
        textFunction: null,
        showFlags: false,
    } //  See tooltip.js for more details

    // region mouseover color
    out.hoverColor_ = 'red'

    //coastal margin
    out.drawCoastalMargin_ = false
    out.coastalMarginStdDev_ = 3

    //graticule
    out.drawGraticule_ = false

    //background map toggle (e.g. for dorling)
    out.backgroundMap_ = true

    //labelling
    // see docs\reference.md#labelling
    out.labels_ = undefined

    //annotations
    out.annotations_ = undefined
    out.annotationsAdded = false //simple flag to know when annotations have already been added

    //hatching
    out.patternFill_ = undefined // e.g. {pattern:'hatching',regionIds:['DE','FR']}

    //dataset source link
    out.showSourceLink_ = true

    //default copyright and disclaimer text
    out.footnote_ = 'Administrative boundaries: \u00A9EuroGeographics \u00A9UN-FAO \u00A9INSTAT \u00A9Turkstat' //"(C)EuroGeographics (C)UN-FAO (C)Turkstat";
    out.footnoteTooltipText_ =
        'The designations employed and the presentation of material on this map do not imply the expression of any opinion whatsoever on the part of the European Union concerning the legal status of any country, territory, city or area or of its authorities, or concerning the delimitation of its frontiers or boundaries. Kosovo*: This designation is without prejudice to positions on status, and is in line with UNSCR 1244/1999 and the ICJ Opinion on the Kosovo declaration of independence.'

    out.nuts2jsonBaseURL_ = window.location.hostname.includes('ec.europa.eu')
        ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/pub/nuts2json/v2'
        : 'https://raw.githubusercontent.com/eurostat/Nuts2json/master/pub/v2'

    //style for no data regions
    out.noDataFillStyle_ = '#bcbcbc'

    /**
     * Insets.
     * The map template has a recursive structure.
     */

    //insets to show, as a list of map template configs. Ex.: [{geo:"MT"},{geo:"LI"},{geo:"PT20"}]
    out.insets_ = []
    //inset templates - each inset is a map-template instance.
    out.insetTemplates_ = {}

    out.insetBoxPosition_ = undefined
    out.insetBoxPadding_ = 5
    out.insetBoxWidth_ = 210
    //out.insetZoomExtent_ = [1, 3];
    out.insetZoomExtent_ = null //zoom disabled as default
    out.insetScale_ = '03M'

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    for (const att in out) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    }

    // warn existing users of functions that have been banished to the shadow realm.
    (0,_deprecated__WEBPACK_IMPORTED_MODULE_4__.defineDeprecatedFunctions)(out)

    // convert geo to uppercase
    out.geo = function (v) {
        if (!arguments.length) return out.geo_
        out.geo_ = v.toUpperCase()
        return out
    }

    //special ones which affect also the insets
    ;['tooltip_', 'nuts2jsonBaseURL_', 'processCentroids_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]

            if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
                //override default properties
                for (const p in v) {
                    out[att][p] = v[p]
                }
            } else {
                out[att] = v
            }

            //recursive call to inset components
            if (out.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(
                    out.insetTemplates_,
                    out.svgId_,
                    (inset, value) => {
                        const fnName = att.substring(0, att.length - 1)
                        inset[fnName](value)
                    },
                    v
                )
            }
            return out
        }
    })

    //title getter and setter
    out.title = function (v) {
        if (!arguments.length) return out.title_
        out.title_ = v
        if (out.svg())
            out.svg()
                .select('#title' + out.geo())
                .text(v)
        return out
    }

    //subtitle getter and setter
    out.subtitle = function (v) {
        if (!arguments.length) return out.subtitle_
        out.subtitle_ = v
        if (out.svg())
            out.svg()
                .select('#subtitle' + out.geo())
                .text(v)
        return out
    }

    //insets getter/setter
    out.insets = function () {
        if (!arguments.length) return out.insets_
        if (arguments.length == 1 && arguments[0] === 'default') out.insets_ = 'default'
        else if (arguments.length == 1 && arguments[0] === false) out.insets_ = false
        else if (arguments.length == 1 && Array.isArray(arguments[0])) out.insets_ = arguments[0]
        else out.insets_ = arguments
        return out
    }

    // dynamic draw graticule
    out.drawGraticule = function (v) {
        if (!arguments.length) return out.drawGraticule_
        out.drawGraticule_ = v

        //update graticule
        let graticule = out.svg_ ? out.svg().select('#em-graticule') : null
        let zg = out.svg_ ? out.svg_.select('#em-zoom-group-' + out.svgId_) : null

        // if existing and argument is false
        if (graticule) {
            if (graticule._groups[0][0] && v == false) {
                //remove graticule
                graticule.remove()

                // if map already created and argument is true
            } else if (out.Geometries.geoJSONs.graticule && out._pathFunction && zg && v == true) {
                //remove existing graticule
                graticule.remove()
                // add new graticule
                zg.append('g')
                    .attr('id', 'em-graticule')
                    .selectAll('path')
                    .data(out.Geometries.geoJSONs.graticule)
                    .enter()
                    .append('path')
                    .attr('d', out._pathFunction)
                    .attr('class', 'em-graticule')

                out.svg()
                    .select('#em-graticule')
                    .each(function () {
                        // move graticule behind land mass
                        out.geo_ == 'WORLD'
                            ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                            : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                    })
            }
        }
        return out
    }

    //coastal margin override
    out.drawCoastalMargin = function (v) {
        if (!arguments.length) return out.drawCoastalMargin_
        out.drawCoastalMargin_ = v

        //update existing
        if (out.svg_) {
            let margin = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#em-coast-margin')
            let filter = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-coastal-blur')
            let zg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-zoom-group-' + out.svgId_) || null
            if (margin._groups[0][0] && v == false) {
                // remove existing
                margin.remove()
            } else if (v == true && out._pathFunction && zg) {
                //remove existing graticule
                margin.remove()
                filter.remove()
                //add filter
                out.svg_
                    .append('filter')
                    .attr('id', 'em-coastal-blur')
                    .attr('x', '-200%')
                    .attr('y', '-200%')
                    .attr('width', '400%')
                    .attr('height', '400%')
                    .append('feGaussianBlur')
                    .attr('in', 'SourceGraphic')
                    .attr('stdDeviation', out.coastalMarginStdDev_)

                //draw for main map - geometries are still in memory so no rebuild needed
                const drawNewCoastalMargin = (map) => {
                    // zoom group might not be inside main map (out.svg_)
                    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-zoom-group-' + map.svgId_)
                    //draw new coastal margin
                    const cg = zoomGroup.append('g').attr('id', 'em-coast-margin')

                    //countries bn
                    if (map._geom.cntbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-cnt')
                            .selectAll('path')
                            .data(map._geom.cntbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //nuts bn
                    if (map._geom.nutsbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.nutsbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //world bn
                    if (map._geom.worldbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.worldbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.COAS_FLAG === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                }

                //draw for insets - requires geometries so we have to rebuild base template
                if (out.insetTemplates_ && out.drawCoastalMargin_) {
                    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, drawNewCoastalMargin)
                    drawNewCoastalMargin(out)
                }

                // move margin to back (in front of sea)
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#em-coast-margin').each(function () {
                    out.geo_ == 'WORLD'
                        ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                        : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                })
            }
        }
        return out
    }

    //annotations override (update after first call)
    out.annotations = function (v) {
        //get
        if (!arguments.length) return out.annotations_
        //set
        out.annotations_ = v
        //update
        ;(0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
        return out
    }

    //stamps override (update after first call)
    out.stamp = function (v) {
        //get
        if (!arguments.length) return out.stamp_
        //set
        out.stamp_ = v
        //update
        ;(0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        return out
    }

    //labels override (update after first call)
    out.labels = function (v) {
        //get
        if (!arguments.length) return out.labels_
        //set
        out.labels_ = v
        //update
        ;(0,_labels__WEBPACK_IMPORTED_MODULE_3__.updateLabels)(out)
        return out
    }

    // initiate Geometries class
    out.Geometries = (0,_geometries__WEBPACK_IMPORTED_MODULE_5__.Geometries)(out, withCenterPoints)

    /**
     * Requests geographic data and then builds the map template
     */
    out.updateGeoMapTemplate = function (callback) {
        // Erase previous data
        out.Geometries.defaultGeoData = null
        out.Geometries.allNUTSGeoData = null
        out.Geometries.centroidsData = null

        if (out.geometries_) {
            out.Geometries.setUserGeometries(out.geometries_)
            // use custom user-defined geometries
            out.buildMapTemplate()

            // Execute callback if defined
            if (callback) callback()
        } else {
            // use default
            out.Geometries.getDefaultGeoData(out.geo_, out.filterGeometriesFunction_, out.nutsLevel_).then(() => {
                out.buildMapTemplate()

                // Execute callback if defined
                if (callback) callback()
            })
        }

        // Use executeForAllInsets for recursive inset updates
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, (inset) => {
            inset.updateGeoMapTemplate(callback)
        })

        return out
    }

    /**
     * Build a map object, including container, frame, map svg, insets and d3 zoom
     */
    out.buildMapTemplateBase = function () {
        //get svg element. Create it if it does not exists
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#' + out.svgId())
        if (svg.size() == 0) {
            svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('body').append('svg').attr('id', out.svgId())
        }
        svg.attr('class', 'em-map')
        out.svg_ = svg

        //set container for cases where container contains various maps
        if (!out.containerId_) out.containerId_ = out.svgId_
        //tooltip needs to know container to prevent overflow
        if (!out.tooltip_.containerId) {
            out.tooltip_.containerId = out.containerId_
        }

        //clear SVG (to avoid building multiple svgs on top of each other during multiple build() calls)
        (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#' + out.svgId() + ' > *').remove()

        //set SVG dimensions
        if (out.geo_.toUpperCase() == 'WORLD') {
            //if no height was specified, use 45% of the width.
            if (!out.height()) out.height(0.55 * out.width())
            svg.attr('width', out.width()).attr('height', out.height())

            //WORLD geo only accepts proj 54030 (robinson) at the moment
            out.proj_ = 54030
        }
        //if no height was specified, use 85% of the width.
        if (!out.height()) out.height(0.85 * out.width())
        svg.attr('width', out.width()).attr('height', out.height())

        // each map template needs a clipPath to avoid overflow. See GISCO-2707
        svg.append('defs')
            .attr('class', 'em-defs')
            .append('clipPath')
            .attr('id', out.svgId_ + '-clip-path')
            .append('path')
            .attr('d', (0,_utils__WEBPACK_IMPORTED_MODULE_1__.convertRectanglesToPaths)(0, 0, out.width_, out.height_))

        if (out.drawCoastalMargin_) {
            //define filter for coastal margin
            svg.append('filter')
                .attr('id', 'em-coastal-blur')
                .attr('x', '-200%')
                .attr('y', '-200%')
                .attr('width', '400%')
                .attr('height', '400%')
                .append('feGaussianBlur')
                .attr('in', 'SourceGraphic')
                .attr('stdDeviation', out.coastalMarginStdDev_)
        }

        //create drawing group, as first child
        const dg = svg
            .insert('g', ':first-child')
            .attr('id', 'em-drawing-' + out.svgId_)
            .attr('class', 'em-drawing-group')
            .attr('clip-path', 'url(#' + out.svgId_ + '-clip-path' + ')')

        //create main zoom group
        const zg = dg
            .append('g')
            .attr('id', 'em-zoom-group-' + out.svgId_)
            .attr('class', 'em-zoom-group') //out.geo changed to out.svgId in order to be unique

        // build insets
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.removeInsets)(out) //remove existing
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.buildInsets)(out, withCenterPoints) //build new

        //draw frame
        dg.append('rect')
            .attr('id', 'em-frame-' + out.geo_)
            .attr('class', 'em-frame')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', out.width_)
            .attr('height', out.height_)

        if (out.stamp_) {
            (0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        }

        return out
    }

    /**
     * Buid an empty map template, based on the geometries only.
     */
    out.buildMapTemplate = function () {
        //prepare drawing group
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //remove all children
        zoomGroup.selectAll('*').remove()

        // separate logic for cartograms
        if (out.gridCartogram_ == true) {
            (0,_cartograms__WEBPACK_IMPORTED_MODULE_8__.buildGridCartogramBase)(out)
            out.footnote_ = false //dont need copyright
        } else {
            // default geographic logic

            // position
            if (!out.position_.x || !out.position_.y) {
                defineDefaultPosition()
            }
            out.position_.z = out.position_.z || getDefaultZ()

            // d3 projection/path functions
            defineProjection()
            definePathFunction()

            // d3 zoom
            if (out.zoomExtent()) {
                defineMapZoom()
            }

            if (out.backgroundMap_) {
                drawBackgroundMap(out)
            }
        }

        //prepare group for proportional symbols, with centroids
        if (withCenterPoints) {
            addCentroidsToMap(out)
        }

        // add geographical labels to map
        if (out.labels_) {
            (0,_labels__WEBPACK_IMPORTED_MODULE_3__.addLabelsToMap)(out, zoomGroup)
        }

        //annotations
        if (out.annotations_) {
            (0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
            out.annotationsAdded = true
        }

        //title
        if (out.title()) {
            //define default position
            let cssClass = out.isInset ? 'em-inset-title' : 'em-title'
            if (!out.titlePosition()) out.titlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssClass) + (out.isInset ? 0 : 10)])
            //draw title
            out.svg()
                .append('text')
                .attr('id', 'title' + out.geo_)
                .attr('class', cssClass)
                .attr('x', out.titlePosition()[0])
                .attr('y', out.titlePosition()[1])
                .html(out.title())
        }

        //subtitle
        if (out.subtitle()) {
            let cssSubtitleClass = out.isInset ? 'em-inset-subtitle' : 'em-subtitle'
            let cssTitleClass = out.isInset ? 'em-inset-title' : 'em-title'
            //define default position
            if (!out.subtitlePosition()) out.subtitlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssTitleClass) + (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssSubtitleClass) + 15])
            //draw subtitle
            out.svg()
                .append('text')
                .attr('id', 'subtitle' + out.geo_)
                .attr('class', cssSubtitleClass)
                .attr('x', out.subtitlePosition()[0])
                .attr('y', out.subtitlePosition()[1])
                .html(out.subtitle())
        }

        //bottom text
        if (out.footnote_) {
            addFootnote()
        }

        //source dataset URL
        if (out.showSourceLink_) {
            let stat
            if (withCenterPoints) {
                stat = out.stat('size')
            } else {
                stat = out.stat()
            }
            if (stat) {
                if (stat.eurostatDatasetCode) {
                    //dataset link
                    let code = stat.eurostatDatasetCode
                    let url = `https://ec.europa.eu/eurostat/databrowser/view/${code}/default/table?lang=en`
                    let link = out
                        .svg()
                        .append('a')
                        .attr('class', 'em-source-dataset-link')
                        .attr('href', url)
                        .attr('target', '_blank')
                        .append('text')
                        .attr('class', 'em-source-dataset-link-text')
                        .attr('x', out.width_)
                        .attr('y', out.height_)
                        .text('EUROSTAT')
                        .attr('text-anchor', 'end')

                    //pretext "Source:"
                    let linkW = link.node().getComputedTextLength()
                    out.svg()
                        .append('text')
                        .attr('class', 'em-source-pretext')
                        .attr('x', out.width_ - linkW - 2)
                        .attr('y', out.height_)
                        .text('Source:')
                        .attr('text-anchor', 'end')
                }
            }
        }

        // scalebar
        if (out.showScalebar_) {
            if (out.scalebarPosition_.length !== 2) {
                out.scalebarPosition_[0] = 15
                out.scalebarPosition_[1] = out.height_ - 50
            }
            addScalebarToMap()
        }

        return out
    }

    const drawBackgroundMap = function (out) {
        //draw background map
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw sea
        zoomGroup
            .append('rect')
            .attr('id', 'sea')
            .attr('class', 'em-sea')
            .attr('x', -5 * out.width_)
            .attr('y', -5 * out.height_)
            .attr('width', 11 * out.width_)
            .attr('height', 11 * out.height_)

        //sphere for world map
        if (out.geo_ == 'WORLD') {
            zoomGroup.append('path').datum({ type: 'Sphere' }).attr('id', 'sphere').attr('d', out._pathFunction).attr('class', 'em-graticule')
        }

        // coastal margin
        if (out.drawCoastalMargin_) {
            addCoastalMarginToMap()
        }

        // draw polygons and borders
        if (out.geometries_) {
            out.Geometries.addUserGeometriesToMap(out.geometries_, zoomGroup, out._pathFunction)
        } else {
            out.Geometries.addDefaultGeometriesToMap(
                zoomGroup,
                out.drawGraticule_,
                out._pathFunction,
                out.nutsLevel_,
                out.nutsYear_,
                out.geo_,
                out.proj_,
                out.scale_
            )
        }
    }

    const defineDefaultPosition = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            out.position_.x = out.position_.x || defaultPosition.geoCenter[0]
            out.position_.y = out.position_.y || defaultPosition.geoCenter[1]
        } else if (out.Geometries.defaultGeoData?.bbox) {
            // default to center of geoData bbox
            out.position_.x = out.position_.x || 0.5 * (out.Geometries.defaultGeoData.bbox[0] + out.Geometries.defaultGeoData.bbox[2])
            out.position_.y = out.position_.y || 0.5 * (out.Geometries.defaultGeoData.bbox[1] + out.Geometries.defaultGeoData.bbox[3])
        } else {
            //TODO: auto-define user=defined geometries geoCenter
            // out.position_.x = Geometries.userGeometries
            // out.position_.y = Geometries.userGeometries
        }

        // optional: set from URL
        setViewFromURL()
    }

    const getDefaultZ = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            return (defaultPosition.pixelSize * 800) / out.width_
        } else if (out.Geometries.defaultGeoData?.bbox) {
            return Math.min(
                (out.Geometries.defaultGeoData.bbox[2] - out.Geometries.defaultGeoData.bbox[0]) / out.width_,
                (out.Geometries.defaultGeoData.bbox[3] - out.Geometries.defaultGeoData.bbox[1]) / out.height_
            )
        } else {
            return 100
        }
    }

    const defineProjection = function () {
        // Define projection based on the geographical context

        if (out.geo_ === 'WORLD') {
            // Use Robinson projection for the world with optional custom projection function
            out._projection =
                out.projectionFunction_ ||
                (0,d3_geo_projection__WEBPACK_IMPORTED_MODULE_12__["default"])()
                    .translate([out.width_ / 2, out.height_ / 2])
                    .scale((out.width_ - 20) / (2 * Math.PI))
        } else {
            // For non-WORLD geo, use custom or default identity projection with calculated bounding box
            out._projection =
                out.projectionFunction_ || (0,d3_geo__WEBPACK_IMPORTED_MODULE_13__["default"])().reflectY(true).fitSize([out.width_, out.height_], (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getBBOXAsGeoJSON)(getCurrentBbox()))
        }
    }

    // Helper function to calculate current view as bbox
    const getCurrentBbox = function () {
        const halfWidth = 0.5 * out.position_.z * out.width_
        const halfHeight = 0.5 * out.position_.z * out.height_
        const bbox = [out.position_.x - halfWidth, out.position_.y - halfHeight, out.position_.x + halfWidth, out.position_.y + halfHeight]
        return bbox
    }

    const definePathFunction = function () {
        out._pathFunction = (0,d3_geo__WEBPACK_IMPORTED_MODULE_14__["default"])().projection(out._projection)
    }

    const defineMapZoom = function () {
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#' + out.svgId())
        let previousT = d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity
        const xoo = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()
            .scaleExtent(out.zoomExtent())
            .on('zoom', function (e) {
                const t = e.transform
                if (t.k !== previousT.k) {
                    zoomHandler(e, previousT)
                } else {
                    panHandler(e)
                }

                // apply default transform to map
                const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
                zoomGroup.attr('transform', t)
                previousT = t
            })

        svg.call(xoo)
    }

    // Zoom handler function
    const zoomHandler = function (event, previousT) {
        const transform = event.transform
        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k

        // Use the projection to get the projected center in EPSG:3035
        const [projectedX, projectedY] = out._projection.invert([centerX, centerY])

        // set new position
        out.position_.x = projectedX
        out.position_.y = projectedY
        out.position_.z = getMetresPerPixel(transform.k / previousT.k)

        // adjust stroke dynamically according to zoom
        scaleStrokeWidths(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.values) scaleLabelTexts(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.backgrounds) scaleLabelBackgrounds(transform)
    }

    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelBackgrounds = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('.em-label-background')
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            // Get the original width, height, x, and y from data attributes or current attributes
            const originalWidth = parseFloat(element.attr('data-width')) || parseFloat(element.attr('width'))
            const originalHeight = parseFloat(element.attr('data-height')) || parseFloat(element.attr('height'))
            const originalX = parseFloat(element.attr('data-x')) || parseFloat(element.attr('x'))
            const originalY = parseFloat(element.attr('data-y')) || parseFloat(element.attr('y'))

            // Only process elements that have valid width, height, x, and y
            if (originalWidth > 0 && originalHeight > 0 && !isNaN(originalX) && !isNaN(originalY)) {
                // Store the original width, height, x, and y for the first time if not already stored
                if (!element.attr('data-width')) {
                    element.attr('data-width', originalWidth)
                    element.attr('data-height', originalHeight)
                    element.attr('data-x', originalX)
                    element.attr('data-y', originalY)
                }

                // Calculate the target width, height, x, and y based on zoom factor (inverse scaling)
                const targetWidth = originalWidth * (1 / zoomFactor) // Inverse scaling
                const targetHeight = originalHeight * (1 / zoomFactor) // Inverse scaling
                const targetX = originalX * (1 / zoomFactor) // Adjust x position
                const targetY = originalY * (1 / zoomFactor) // Adjust y position

                // Add the style change to a batch array
                updates.push({ element, targetWidth, targetHeight, targetX, targetY })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetWidth, targetHeight, targetX, targetY }) => {
            element.attr('width', targetWidth).attr('height', targetHeight).attr('x', targetX).attr('y', targetY)
        })
    }
    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelTexts = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const labels = zoomGroup.select('#em-labels')
        const elements = labels.selectAll('*') // Select all labels
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get font-size from inline or computed style
            const inlineFontSize = element.attr('font-size')
            const cssFontSize = computedStyle.fontSize
            const fontSize = inlineFontSize || cssFontSize

            // Only process elements that have a font size defined
            if (fontSize && parseFloat(fontSize) > 0) {
                const originalFontSize = parseFloat(element.attr('data-fs')) || parseFloat(inlineFontSize) || parseFloat(cssFontSize)

                // Store the original font size for the first time
                if (!element.attr('data-fs')) {
                    element.attr('data-fs', originalFontSize)
                }

                // Calculate the target font size based on zoom factor
                const targetFontSize = originalFontSize / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetFontSize })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetFontSize }) => {
            element.style.setProperty('font-size', `${targetFontSize}px`, 'important')
        })
    }

    /**
     * @description adjusts all stroke-widths dynamically according to zoom
     * @param {*} transform
     */
    const scaleStrokeWidths = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('*') // Select all elements in the zoom group
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get stroke-width from inline or computed style
            const inlineStrokeWidth = element.attr('stroke-width')
            const cssStrokeWidth = computedStyle.strokeWidth
            const strokeWidth = inlineStrokeWidth || cssStrokeWidth

            // Only process elements that have a stroke width defined
            if (strokeWidth && parseFloat(strokeWidth) > 0) {
                const originalStrokeWidth = parseFloat(element.attr('data-sw')) || parseFloat(inlineStrokeWidth) || parseFloat(cssStrokeWidth)

                // Store the original stroke width for the first time
                if (!element.attr('data-sw')) {
                    element.attr('data-sw', originalStrokeWidth)
                }

                // Calculate the target stroke width
                const targetStrokeWidth = originalStrokeWidth / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetStrokeWidth })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetStrokeWidth }) => {
            element.style.setProperty('stroke-width', `${targetStrokeWidth}px`, 'important')
        })
    }

    /**
     * @description get the current view's metres per pixel, based on a zoomFactor
     * @param {number} zoomFactor this zoom / previous zoom
     * @return {number}
     */
    const getMetresPerPixel = function (zoomFactor) {
        // Get current bounding box width in meters
        const bbox = getCurrentBbox()
        const bboxWidth = bbox[2] - bbox[0] // BBOX width in meters

        // Calculate meters per pixel
        const metersPerPixel = bboxWidth / (out.width_ * zoomFactor)

        return metersPerPixel
    }

    // Pan handler function
    const panHandler = function (event, previousT) {
        const transform = event.transform

        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k
        let [geoX, geoY] = out._projection.invert([centerX, centerY])

        // Clamp geoX and geoY to max bounds and adjust the event transform
        if (out.maxBounds_.xMin !== undefined && geoX < out.maxBounds_.xMin) {
            geoX = out.maxBounds_.xMin
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMin !== undefined && geoY < out.maxBounds_.yMin) {
            geoY = out.maxBounds_.yMin
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }
        if (out.maxBounds_.xMax !== undefined && geoX > out.maxBounds_.xMax) {
            geoX = out.maxBounds_.xMax
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMax !== undefined && geoY > out.maxBounds_.yMax) {
            geoY = out.maxBounds_.yMax
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }

        // set new position
        out.position_.x = geoX
        out.position_.y = geoY
    }

    /** Get x,y,z elements from URL and assign them to the view. */
    const setViewFromURL = function () {
        const x = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('x'),
            y = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('y'),
            z = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('z')
        if (x != null && x != undefined && !isNaN(+x)) out.position_.x = +x
        if (y != null && y != undefined && !isNaN(+y)) out.position_.y = +y
        if (z != null && z != undefined && !isNaN(+z)) out.position_.z = +z
    }

    const addFootnote = function () {
        out.svg()
            .append('text')
            .attr('id', 'em-footnote')
            .attr('class', 'em-footnote')
            .attr('x', 0)
            .attr('y', out.height_)
            .html(out.footnote_)
            .on('mouseover', function () {
                out._tooltip.mw___ = out._tooltip.style('max-width')
                out._tooltip.style('max-width', '400px')
                if (out.footnoteTooltipText_) out._tooltip.mouseover(out.footnoteTooltipText_)
            })
            .on('mousemove', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mouseout(e)
                out._tooltip.style('max-width', out._tooltip.mw___)
            })
    }

    const addCoastalMarginToMap = function () {
        const zg = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw coastal margin
        const cg = zg.append('g').attr('id', 'em-coast-margin').attr('class', 'em-coast-margin')

        //countries bn
        if (out.Geometries.geoJSONs.cntbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-cnt')
                .attr('class', 'em-coast-margin-cnt')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.cntbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //nuts bn
        if (out.Geometries.geoJSONs.nutsbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-nuts')
                .attr('class', 'em-coast-margin-nuts')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //world bn
        if (out.Geometries.geoJSONs.worldbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-world')
                .attr('class', 'em-coast-margin-world')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.worldbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.COAS_FLAG === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }
    }

    const addCentroidsToMap = function (map) {
        let centroidFeatures

        if (!map.Geometries.centroidsData) {
            // if centroids data is absent (e.g. for world maps) then calculate manually
            if (map.geo_ == 'WORLD') {
                centroidFeatures = []
                map.Geometries.geoJSONs.worldrg.forEach((feature) => {
                    let newFeature = { ...feature }
                    // exception for France (because guyane)
                    if (feature.properties.id == 'FR') {
                        newFeature.geometry = {
                            coordinates: [2.2, 46.2],
                            type: 'Point',
                        }
                    } else {
                        newFeature.geometry = {
                            coordinates: (0,d3_geo__WEBPACK_IMPORTED_MODULE_15__["default"])(feature),
                            type: 'Point',
                        }
                    }
                    centroidFeatures.push(newFeature)
                })
            }
        } else {
            if (map.nutsLevel_ == 'mixed') {
                centroidFeatures = [
                    ...map.Geometries.centroidsData[0].features,
                    ...map.Geometries.centroidsData[1].features,
                    ...map.Geometries.centroidsData[2].features,
                    ...map.Geometries.centroidsData[3].features,
                ]
            } else {
                centroidFeatures = map.Geometries.centroidsData.features
            }
        }

        if (map.processCentroids_) centroidFeatures = map.processCentroids_(centroidFeatures)

        // calculate screen coordinates and save centroids to map
        map.Geometries.centroidFeatures = centroidFeatures.map((d) => {
            let coords = map._projection(d.geometry.coordinates)
            d.properties.centroid = coords
            return d
        })

        // em-prop-symbols is the g element containing all proportional symbols for the map
        const zg = map.svg().select('#em-zoom-group-' + map.svgId_)
        const gcp = zg.append('g').attr('id', 'em-prop-symbols')

        // add centroid elements
        // then symbols are drawn/appended to these containers in the map-type js file
        const symbolContainers = gcp
            .selectAll('g')
            .data(map.Geometries.centroidFeatures)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                return 'translate(' + d.properties.centroid[0].toFixed(3) + ',' + d.properties.centroid[1].toFixed(3) + ')'
            })
            .attr('class', 'em-centroid') // OUR SYMBOL CONTAINER
            .attr('id', (d) => 'ps' + d.properties.id)
    }

    /**
     * @function addScalebarToMap
     * @description appends an SVG scalebar to the map. Uses pixelSize to calculate units in km
     */
    const addScalebarToMap = function () {
        // Julien's nice scalebars
        const marginLeft = 5
        const maxLengthPix = out.scalebarMaxWidth_
        const textOffsetX = out.scalebarTextOffset_[0]
        const textOffsetY = out.scalebarTextOffset_[1]
        const pixelSizeM = out.position_.z
        const maxLengthM = maxLengthPix * pixelSizeM
        const niceLengthM = niceScaleBarLength(maxLengthM)
        const niceLengthPixel = niceLengthM[0] / pixelSizeM
        const scaleBarStartDigit = niceLengthM[1]
        const subdivisionNbs = {
            1: 4,
            2: 2,
            5: 5,
        }

        const scalebarGroup = out
            .svg()
            .append('g')
            .attr('class', 'em-scalebar')
            .attr('transform', `translate(${out.scalebarPosition_[0]},${out.scalebarPosition_[1]})`)
            .attr('width', maxLengthPix + 20)
            .attr('height', out.scalebarHeight_)

        // top line full width
        // scalebarGroup
        //     .append('line')
        //     .attr('class', 'em-scalebar-line')
        //     .attr('x1', marginLeft)
        //     .attr('y1', 1)
        //     .attr('x2', niceLengthPixel + marginLeft)
        //     .attr('y2', 1)

        //bottom line full width
        // scalebarGroup
        //     .append('line')
        //     .attr('class', 'em-scalebar-line')
        //     .attr('x1', marginLeft)
        //     .attr('y1', out.scalebarSegmentHeight_)
        //     .attr('x2', niceLengthPixel + marginLeft)
        //     .attr('y2', out.scalebarSegmentHeight_)

        //first tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', marginLeft)
            .attr('y1', 1)
            .attr('x2', marginLeft)
            .attr('y2', out.scalebarTickHeight_)

        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text('0')

        //middle ticks
        const subdivisionNb = subdivisionNbs[scaleBarStartDigit]
        const divisionWidth = niceLengthPixel / subdivisionNb
        const divisionMinWidth = 15
        const midlineY = out.scalebarSegmentHeight_ / 2 + 1
        if (divisionWidth >= divisionMinWidth) {
            for (let i = 1; i < subdivisionNb; i++) {
                scalebarGroup
                    .append('line')
                    .attr('class', 'em-scalebar-line')
                    .attr('x1', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y1', 1)
                    .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y2', out.scalebarTickHeight_)
                scalebarGroup
                    .append('text')
                    .attr('class', 'em-scalebar-label')
                    .attr('x', marginLeft + textOffsetX + i * divisionWidth)
                    .attr('y', out.scalebarTickHeight_ + textOffsetY)
                    .text(getScalebarLabel((niceLengthM[0] / subdivisionNb) * i))

                if (i == 1) {
                    scalebarGroup
                        .append('line')
                        .attr('class', 'em-scalebar-line em-scalebar-midline')
                        .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                        .attr('y1', midlineY)
                        .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                        .attr('y2', midlineY)
                } else {
                    let x1 = marginLeft + out.scalebarStrokeWidth_ / 2 + (i - 1) * divisionWidth
                    if (x1 > 0) {
                        scalebarGroup
                            .append('line')
                            .attr('class', 'em-scalebar-line em-scalebar-midline')
                            .attr('x1', x1)
                            .attr('y1', midlineY)
                            .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                            .attr('y2', midlineY)
                    }
                }
            }

            // Draw final midline segment (last segment)
            if (divisionWidth >= divisionMinWidth) {
                scalebarGroup
                    .append('line')
                    .attr('class', 'em-scalebar-line em-scalebar-midline')
                    .attr('x1', marginLeft + (subdivisionNb - 1) * divisionWidth)
                    .attr('y1', midlineY)
                    .attr('x2', marginLeft + subdivisionNb * divisionWidth)
                    .attr('y2', midlineY)
            }
        } else {
            // single full-length horizontal mid-line
            scalebarGroup
                .append('line')
                .attr('class', 'em-scalebar-line em-scalebar-midline')
                .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                .attr('y1', midlineY)
                .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + divisionWidth * subdivisionNb)
                .attr('y2', midlineY)
        }

        //last tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', niceLengthPixel + marginLeft)
            .attr('y1', 1)
            .attr('x2', niceLengthPixel + marginLeft)
            .attr('y2', out.scalebarTickHeight_)
        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', niceLengthPixel + marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text(getScalebarLabel(niceLengthM[0]) + out.scalebarUnits_)
    }

    const niceScaleBarLength = function (scaleBarLength) {
        //compute the 'nice' power of ten
        const pow10 = Math.pow(10, Math.floor(Math.log(scaleBarLength) / Math.log(10)))

        //check if 5 times this value fits
        if (5 * pow10 <= scaleBarLength) return [5 * pow10, 5]

        //check if 2 times this value fits
        if (2 * pow10 <= scaleBarLength) return [2 * pow10, 2]

        //returns the power of ten
        return [pow10, 1]
    }

    const getScalebarLabel = function (valueM) {
        if (valueM < 0.01) return valueM * 1000 + 'mm'
        if (valueM < 1) return valueM * 100 + 'cm'
        if (valueM < 1000) return valueM * 1 + 'm'
        return valueM / 1000
    }

    return out
}

/** Default geocenter positions and pixelSize (for default width = 800px) for territories and projections. */
const _defaultPosition = {
    EUR_3035: { geoCenter: [4790000, 3420000], pixelSize: 6400 },
    IC_32628: { geoCenter: [443468, 3145647], pixelSize: 1000 },
    GP_32620: { geoCenter: [669498, 1784552], pixelSize: 130 },
    MQ_32620: { geoCenter: [716521, 1621322], pixelSize: 130 },
    GF_32622: { geoCenter: [266852, 444074], pixelSize: 500 },
    RE_32740: { geoCenter: [348011, 7661627], pixelSize: 130 },
    YT_32738: { geoCenter: [516549, 8583920], pixelSize: 70 },
    MT_3035: { geoCenter: [4719755, 1441701], pixelSize: 70 },
    PT20_32626: { geoCenter: [397418, 4271471], pixelSize: 1500 },
    PT30_32628: { geoCenter: [333586, 3622706], pixelSize: 150 },
    LI_3035: { geoCenter: [4287060, 2672000], pixelSize: 40 },
    IS_3035: { geoCenter: [3011804, 4960000], pixelSize: 700 },
    SJ_SV_3035: { geoCenter: [4570000, 6160156], pixelSize: 800 },
    SJ_JM_3035: { geoCenter: [3647762, 5408300], pixelSize: 100 },
    CARIB_32620: { geoCenter: [636345, 1669439], pixelSize: 500 },
    WORLD_54030: { geoCenter: [14, 17], pixelSize: 9000 },
}


/***/ }),

/***/ "./src/core/pattern-fill.js":
/*!**********************************!*\
  !*** ./src/core/pattern-fill.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyPatternFill: () => (/* binding */ applyPatternFill)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");



function applyPatternFill(map, configs = []) {
    if (!Array.isArray(configs)) {
        console.warn('patternFill expects an array of configs')
        return
    }

    let defs = map.svg().select('defs')
    if (defs.empty()) {
        defs = map.svg().append('defs')
    }

    // Prepare: map each regionId to an array of patternIds
    const regionToPatternIds = {}

    configs.forEach((config) => {
        const { pattern = 'hatching', regionIds = [], color = '#000', strokeWidth = 1, customPattern } = config

        let patternId

        if (customPattern) {
            const idMatch = customPattern.match(/id=['"]([^'"]+)['"]/)
            if (idMatch) {
                patternId = idMatch[1]

                if (map.svg().select(`#${patternId}`).empty()) {
                    defs.node().insertAdjacentHTML('beforeend', customPattern)
                }
            } else {
                console.warn('customPattern must include an id attribute.')
                return
            }
        } else {
            const colorKey = color.replace('#', '').toLowerCase()
            patternId = `${pattern}-${colorKey}-sw${strokeWidth}`
            definePattern(map, patternId, pattern, color, strokeWidth)
        }

        config.patternId = patternId

        regionIds.forEach((regionId) => {
            if (!regionToPatternIds[regionId]) {
                regionToPatternIds[regionId] = []
            }
            regionToPatternIds[regionId].push(patternId)
        })
    })

    // Apply all patterns for each region (stacking them)
    map.svg()
        .selectAll((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getRegionsSelector)(map))
        .each(function (d) {
            const id = d?.properties?.id
            const patternIds = regionToPatternIds[id]

            if (patternIds && patternIds.length) {
                const original = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this)

                patternIds.forEach((patternId) => {
                    const clone = original.node().cloneNode(true)

                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(clone)
                        .attr('fill', `url(#${patternId})`)
                        .attr('pointer-events', 'none')
                        .attr('class', (original.attr('class') || '') + ' pattern-fill-overlay')

                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parentNode).append(() => clone)
                })
            }
        })
}

function definePattern(map, patternId, patternName, color, strokeWidth) {
    const defs = map.svg().select('defs')

    if (
        map
            .svg()
            .select(`#${CSS.escape(patternId)}`)
            .empty()
    ) {
        const pattern = defs.append('pattern').attr('id', patternId).attr('patternUnits', 'userSpaceOnUse').attr('width', 8).attr('height', 8)

        if (patternName === 'hatching') {
            pattern.append('path').attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2').attr('stroke', color).attr('stroke-width', strokeWidth)
        } else if (patternName === 'crosshatch') {
            pattern.append('path').attr('d', 'M0,0 l8,8 M8,0 l-8,8').attr('stroke', color).attr('stroke-width', strokeWidth)
        } else if (patternName === 'dots') {
            pattern.append('circle').attr('cx', 4).attr('cy', 4).attr('r', strokeWidth).attr('fill', color)
        } else {
            console.warn(`Unknown pattern "${patternName}", defaulting to hatching.`)
            pattern.append('path').attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2').attr('stroke', color).attr('stroke-width', strokeWidth)
        }
    }
}


/***/ }),

/***/ "./src/core/stamps.js":
/*!****************************!*\
  !*** ./src/core/stamps.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendStamp: () => (/* binding */ appendStamp)
/* harmony export */ });
const appendStamp = (stampConfig, map) => {
    if (map.svg_) {
        const existing = map.svg_.select('#em-stamp')
        existing.remove()

        if (stampConfig) {
            const container = map.svg_.append('g').attr('id', 'em-stamp')

            // Set defaults
            if (!stampConfig.size) stampConfig.size = 60
            if (!stampConfig.x) stampConfig.x = 230
            if (!stampConfig.y) stampConfig.y = 100
            if (!stampConfig.textColor) stampConfig.textColor = '#000'
            if (!stampConfig.stampColor) stampConfig.stampColor = '#000'
            if (!stampConfig.strokeWidth) stampConfig.strokeWidth = 1
            if (!stampConfig.lineHeight) stampConfig.lineHeight = 15

            // Draw the circle
            container
                .append('circle')
                .attr('r', stampConfig.size)
                .attr('cx', stampConfig.x)
                .attr('cy', stampConfig.y)
                .attr('id', 'em-stamp-circle')
                .attr('fill', 'none')
                .attr('stroke', stampConfig.stampColor)
                .attr('stroke-width', stampConfig.strokeWidth)

            // Handle text
            const text = stampConfig.text
            const targetWidth = Math.sqrt(measureWidth(text.trim()) * stampConfig.lineHeight)
            const lines = getLines(getWords(text.trim()), targetWidth)
            const textRadius = getTextRadius(lines, stampConfig.lineHeight)

            // Append inside circle
            container
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('fill', stampConfig.textColor)
                .attr('id', 'em-stamp-text')
                .attr('transform', `translate(${stampConfig.x},${stampConfig.y}) scale(${stampConfig.size / textRadius})`)
                .selectAll('tspan')
                .data(lines)
                .enter()
                .append('tspan')
                .attr('x', 0)
                .attr('y', (d, i) => (i - lines.length / 2 + 0.8) * stampConfig.lineHeight)
                .text((d) => d.text.replaceAll('~', ' ').replaceAll('¶', '')) // Removes ¶ (line breaker) and ~ (non breaking space)
        }
    }
}

// Splitting by both spaces and pilcrows
const getWords = (text) => {
    return text
        .split(/(?<=¶)|\s+/g)
        .map((word) => word.trim())
        .filter((word) => word.length > 0)
}

// Computes text width
const measureWidth = (text) => {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text')

    textElement.textContent = text
    svg.appendChild(textElement)
    document.body.appendChild(svg)

    const width = textElement.getComputedTextLength()
    document.body.removeChild(svg)

    return width + 10
}

// Compute text radius
const getTextRadius = (lines, lineHeight) => {
    let radius = 0
    for (let i = 0, n = lines.length; i < n; ++i) {
        const dy = (Math.abs(i - n / 2 + 0.5) + 0.5) * lineHeight
        const dx = lines[i].width / 2
        radius = Math.max(radius, Math.sqrt(dx ** 2 + dy ** 2))
    }
    return radius
}

// Handles forced line breaks
const getLines = (words, targetWidth) => {
    let lines = []
    let line = { width: 0, text: '' }

    for (let i = 0, n = words.length; i < n; ++i) {
        if (words[i] === '¶') {
            // Push current line (if it has text)
            if (line.text) lines.push(line)
            // Start a new empty line
            line = { width: 0, text: '' }
            continue
        }

        let lineText1 = (line.text ? line.text + ' ' : '') + words[i]
        let lineWidth1 = measureWidth(lineText1)

        if ((line.width + lineWidth1) / 2 < targetWidth) {
            line.width = lineWidth1
            line.text = lineText1
        } else {
            lines.push(line)
            line = { width: measureWidth(words[i]), text: words[i] }
        }
    }

    if (line.text) lines.push(line) // Push last line if it exists

    return lines
}


/***/ }),

/***/ "./src/core/stat-data.js":
/*!*******************************!*\
  !*** ./src/core/stat-data.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   statData: () => (/* binding */ statData)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonstat-toolkit */ "./node_modules/jsonstat-toolkit/import.mjs");





/**
 * A statistical dataset, to be used for a statistical map.
 *
 * @param {*} config
 */
const statData = function (config) {
    //build stat data object
    const out = {}

    out.__data = undefined //for debugging

    //out.maxNumberOfDecimalsInDataset = undefined

    /**
     * The statistical values, indexed by NUTS id.
     * Each stat value is an object {value,status}.
     */
    out._data_ = undefined

    /**
     * Return the stat value {value,status} from a nuts id.
     * If no argument is specified, returns the entire index.
     * @param {*} nutsId
     */
    out.get = (nutsId) => {
        if (!nutsId) {
            return out._data_
        } else {
            if (out._data_) {
                return out._data_[nutsId]
            } else {
                return undefined
            }
        }
    }

    /**
     * Return the stat value from a nuts id.
     * @param {*} nutsId
     */
    out.getValue = (nutsId) => {
        const s = out.get(nutsId)
        return s ? s.value : undefined
    }

    /**
     * Set a stat value from a nuts id.
     *
     * @param {String} nutsId
     * @param {Object || String || Number} stat The new statistical data. The format can be either {value:34.324,status:"e"} or a the value only.
     */
    out.set = (nutsId, stat) => {
        out._data_ = out._data_ || {}
        const s = out._data_[nutsId]

        if (s) {
            if (stat.value) {
                s.value = stat.value
                s.status = stat.status
            } else {
                // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
                s.value = stat
                //s.value = isNaN(+stat) ? stat : +stat
            }
        } else {
            // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
            out._data_[nutsId] = stat.value ? stat : { value: stat }
            //out._data_[nutsId] = stat.value ? stat : { value: isNaN(+stat) ? stat : +stat}
        }
        return out
    }

    /**
     * Set statistical data, already indexed by nutsId.
     *
     * @param {Object} data Something like: { "PT":0.2, "LU":0.6, ...}, or with status: { "PT": {value:0.2, status:"e"}, "LU":0.6, ...}
     */
    out.setData = (data) => {
        out.__data = data // for debugging
        out._data_ = {} // overwrite existing data
        Object.keys(data).forEach((nutsId) => out.set(nutsId, data[nutsId]))
        return out
    }

    //eg for sparklines
    out.setManualMultiDate = function (dataObject) {
        out._data_ = out._data_ || {}

        for (const regionId in dataObject) {
            const dateValueMap = dataObject[regionId]
            out._data_[regionId] = {}

            for (const date in dateValueMap) {
                const value = dateValueMap[date]
                out._data_[regionId][date] = { value: value }
            }
        }

        return out
    }

    /** Return all stat values as an array. This can be used to classify the values. */
    out.getArray = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || s)
        }
    }

    /** Return stat unique values. This can be used for categorical maps. */
    out.getUniqueValues = function () {
        return Object.values(out._data_)
            .map((s) => s.value)
            .filter((item, i, ar) => ar.indexOf(item) === i)
    }

    /** Get min value. */
    out.getMin = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.min(acc, v))
        }
    }
    /** Get max value. */
    out.getMax = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.max(acc, v))
        }
    }

    /** Check if the stat data is ready. */
    out.isReady = function () {
        return out._data_ != undefined
    }

    /** Some metadata */
    out.metadata = undefined

    //a text for the statitics unit of measure, to be shown in the tooltip
    out.unitText_ = undefined

    /**
     * Retrieve stat data from remote data sources.
     *
     * @param {*} nutsLevel
     * @param {*} callback
     */
    out.retrieveFromRemote = function (nutsLevel, lang, callback) {
        if (out.eurostatDatasetCode_) updateEurobase(nutsLevel, lang, callback)
        else if (out.csvURL_) updateCSV(callback)
        return out
    }

    //TODO decompose into Eurobase/jsonstat and CSV types ?

    /**
     * Eurobase/jsonstat data source
     * See https://ec.europa.eu/eurostat/web/json-and-unicode-web-services/getting-started/rest-request
     */

    /** The Eurobase dataset code */
    out.eurostatDatasetCode_ = undefined
    /** The Eurobase code */
    out.filters_ = { lastTimePeriod: 1 }
    /** The precision (number of decimal places) */
    out.precision_ = 2

    /**
     * Return promise for Eurobase/jsonstat data.
     */
    const getEurobasePromise = function (nutsLevel, lang) {
        //set precision //DEPRECATED 16/11/2021 https://ec.europa.eu/eurostat/online-help/public/en/NAVIGATION_WDDSTranslator_migration_en/#DECOMMISSION
        //out.filters_["precision"] = out.precision_;
        //select only required geo groups, depending on the specified nuts level
        if (!out.filters_.geo) {
            out.filters_['geoLevel'] = nutsLevel + '' === '0' ? 'country' : 'nuts' + nutsLevel
        }

        //force filtering of euro-geo-aggregates
        //out.filters_["filterNonGeo"] = 1; //DEPRECATED 16/11/2021

        //retrieve stat data from Eurostat API
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getEstatDataURL)(out.eurostatDatasetCode_, out.filters_, lang))
    }

    //for eurobase statistical data to retrieve from Eurostat API
    const updateEurobase = function (nutsLevel, lang, callback) {
        //erase previous data
        out._data_ = null

        getEurobasePromise(nutsLevel, lang).then(function (data___) {
            //decode stat data
            const jsd = (0,jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__["default"])(data___)

            //store jsonstat metadata
            out.metadata = {
                label: jsd.label,
                href: jsd.href,
                source: jsd.source,
                updated: jsd.updated,
                extension: jsd.extension,
            }
            out.metadata.time = jsd.Dimension('time').id[0]

            //index
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.jsonstatToIndex)(jsd)
            //TODO: use maybe https://github.com/badosa/JSON-stat/blob/master/utils/fromtable.md to build directly an index ?

            if (callback) callback()
        })
    }

    /**
     * Return the time stamp of the jsonstat dataset.
     */
    out.getTime = function () {
        const t = out.filters_.time
        if (t) return t
        if (!out._data_) return
        return out.metadata.time
    }

    /**
     * CSV data source
     */

    /** The CSV file URL */
    out.csvURL_ = undefined
    /** The CSV column with the NUTS ids */
    out.geoCol_ = 'geo'
    /** The CSV column with the statistical values */
    out.valueCol_ = 'value'

    /**
     * Return promise for CSV data.
     */
    const getCSVPromise = function (nutsLevel) {
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_3__.csv)(out.csvURL_)
    }

    //for statistical data to retrieve from CSV file
    const updateCSV = function (callback) {
        //erase previous data
        out._data_ = null

        //retrieve csv data
        getCSVPromise().then(function (data___) {
            //decode stat data
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.csvToIndex)(data___, out.geoCol_, out.valueCol_)

            //store some metadata
            out.metadata = { href: out.csvURL_ }

            if (callback) callback()
        })
    }

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['unitText_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config) for (let key in config) out[key + '_'] = config[key]

    return out
}


/***/ }),

/***/ "./src/core/stat-map.js":
/*!******************************!*\
  !*** ./src/core/stat-map.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getURLParameters: () => (/* binding */ getURLParameters),
/* harmony export */   statMap: () => (/* binding */ statMap)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");
/* harmony import */ var _stat_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat-data */ "./src/core/stat-data.js");
/* harmony import */ var _legend_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../legend/legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tooltip/tooltip */ "./src/tooltip/tooltip.js");







/**
 * An abstract statistical map: A map template with statistical data, without any particular styling rule.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const statMap = function (config, withCenterPoints, mapType) {
    //build stat map from map template
    const out = _map_template__WEBPACK_IMPORTED_MODULE_1__.mapTemplate(config, withCenterPoints, mapType)

    //statistical data

    //the statistical data configuration.
    //A map can have several stat datasets. This is a dictionary of all stat configuration
    out.stat_ = { default: undefined }
    out.stat = function (k, v) {
        //no argument: getter - return the default stat
        if (!arguments.length) return out.stat_['default']
        //two arguments: setter - set the config k with value v
        if (arguments.length == 2) {
            out.stat_[k] = v
            return out
        }
        //one string argument: getter - return the config k
        if (typeof k === 'string' || k instanceof String) return out.stat_[k]
        //one non-string argument: setter - set the entire dictionnary
        out.stat_ = k.default ? k : { default: k }
        return out
    }

    //the statistical data, retrieved from the config information. As a dictionary.
    out.statData_ = {
        default: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        color: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        size: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v1: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v2: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //bivariate
        v3: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //trivariate
    }
    out.statData = function (k, v) {
        if (!arguments.length) return out.statData_['default']

        // lazy create if not exist
        if (arguments.length === 1) {
            if (!out.statData_[k]) out.statData_[k] = _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData()
            return out.statData_[k]
        }

        // setter
        out.statData_[k] = v
        return out
    }

    //test for no data case
    out.noDataText_ = 'No data available'
    //langage (currently used only for eurostat data API)
    out.language_ = 'en'
    //transition time for rendering
    out.transitionDuration_ = 500
    //specific tooltip text function
    out.tooltip_.textFunction = undefined
    //for maps using special fill patterns, this is the function to define them in the SVG image - See functions: getFillPatternLegend and getFillPatternDefinitionFun
    out.filtersDefinitionFunction_ = undefined
    //a callback function to execute after the map build is complete.
    out.callback_ = undefined

    //legend configuration
    out.legend_ = undefined
    //legend object
    out.legendObj_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['legend_', 'legendObj_', 'noDataText_', 'language_', 'transitionDuration_', 'tooltipText_', 'filtersDefinitionFunction_', 'callback_'].forEach(
        function (att) {
            out[att.substring(0, att.length - 1)] = function (v) {
                if (!arguments.length) return out[att]
                out[att] = v
                return out
            }
        }
    )

    //override attribute values with config values
    if (config) for (let key in config) if (out[key] && config[key] != undefined) out[key](config[key])

    // override legend for updating after build
    out.legend = function (v) {
        if (!arguments.length) return out.legend_

        // clear existing legend
        if (v == false) {
            const legend = out.legendObj()
            if (legend) {
                const legendSvg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#' + legend.svgId)
                if (legendSvg.size() > 0) {
                    legendSvg.selectAll('*').remove()
                }
            }
            out.legend_ = v
            return out
        }
        //set new legend config
        out.legend_ = v
        //update if existing legend
        if (out.legendObj_) out.updateLegend()
        return out
    }

    out.updateLegend = function (v) {
        if (out.legendObj_) out.legendObj().update()
        return out
    }

    /**
     * Build the map.
     * This method should be called once, preferably after the map attributes have been set to some initial values.
     */
    out.build = function () {
        if (out.projectionFunction_) out.proj('4326') //when using custom d3 projection function always request NUTS2JSON in WGS84

        //build map template base
        out.buildMapTemplateBase()

        //add additional filters for fill patterns for example
        if (out.filtersDefinitionFunction_) {
            out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        }

        //legend element
        if (out.legend()) {
            out.buildLegend()
        }

        //define tooltip
        //prepare map tooltip
        if (out.tooltip_) {
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip(out.tooltip_)
        } else {
            //no config specified, use default
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip()
        }

        //launch geo data retrieval
        out.updateGeoData()

        //launch stat data retrieval
        out.updateStatData()

        return out
    }

    out.buildLegend = function () {
        //create legend object
        out.legendObj(out.getLegendConstructor()(out, out.legend()))
        const legend = out.legendObj()

        //get legend svg. If it does not exist, create it embeded within the map
        let legendSvg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#' + legend.svgId)
        if (legendSvg.size() == 0) {
            //get legend position
            const x = legend.x == undefined ? out.width() - 100 - legend.boxPadding : legend.x
            const y = legend.y == undefined ? legend.boxPadding : legend.y

            //build legend SVG in a new group
            out.svg()
                .append('g')
                .attr('id', legend.svgId)
                .attr('class', 'em-legend')
                .attr('transform', 'translate(' + x + ',' + y + ')')
        }

        legend.build()
    }

    /** Check if all stat datasets have been loaded. */
    const isStatDataReady = function () {
        for (const key in out.statData_) {
            const hasConfig = !!out.stat_[key]
            const hasManualData = !!(out.statData_[key] && out.statData_[key].get())

            if (!hasConfig && !hasManualData) continue
            if (!out.statData_[key].isReady()) return false
        }
        return true
    }

    /**
     * Launch map geo data retrieval, and make/update the map once received.
     * This method should be called after attributes related to the map geometries have changed, to retrieve this new data and refresh the map.
     */
    out.updateGeoData = function () {
        out.updateGeoMapTemplate(() => {
            //if stat datasets have not been loaded, wait again
            if (!isStatDataReady()) return

            //proceed with map construction
            out.updateStatValues()
            //execute callback function
            if (out.callback()) out.callback()(out)
        })

        return out
    }

    /**
     * Launch map geo stat datasets retrieval, and make/update the map once received.
     * This method should be called after specifications on the stat data sources attached to the map have changed, to retrieve this new data and refresh the map.
     */
    out.updateStatData = function () {
        for (let statKey in out.stat_) {
            const config = out.stat(statKey)
            const manualData = out.statData(statKey).get?.()

            // Skip if neither stat config nor manual data
            if (!config && !manualData) continue

            // If there's a config, build the statData object (or replace existing)
            if (config) {
                const statData = _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(config)
                out.statData(statKey, statData)

                // Launch remote retrieval
                let nl = out.nutsLevel_
                if (nl === 'mixed') nl = 0

                statData.retrieveFromRemote(nl, out.language(), () => {
                    if (!out.Geometries.isGeoReady()) return
                    if (!isStatDataReady()) return

                    out.updateStatValues()
                    if (out.callback()) out.callback()(out)
                })
            }
        }

        return out
    }

    /**
     * Make/update the map with new stat data.
     * This method should be called after stat data attached to the map have changed, to refresh the map.
     * If the stat data sources have changed, call *updateStatData* instead.
     */
    out.updateStatValues = function () {
        //update classification and styles
        out.updateClassification()
        out.updateStyle()

        //update legend, if any
        if (out.legend_ && out.legendObj()) out.legendObj().update()

        return out
    }

    /**
     * Abstract method.
     * Make/update the map after classification attributes have been changed.
     * For example, if the number of classes, or the classification method has changed, call this method to update the map.
     */
    out.updateClassification = function () {
        console.log('Map updateClassification function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Make/update the map after styling attributes have been changed.
     * For example, if the style (color?) for one legend element has changed, call this method to update the map.
     */
    out.updateStyle = function () {
        console.log('Map updateStyle function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Function which return the legend constructor function for the map.
     */
    out.getLegendConstructor = function () {
        console.log('Map getLegendConstructor function not implemented')
        return _legend_legend__WEBPACK_IMPORTED_MODULE_3__.legend
    }

    /**
     * Retrieve the time stamp of the map, even if not specified in the dimension initially.
     * This applies only for stat data retrieved from Eurostat API.
     * This method is useful for example when the data retrieved is the freshest, and one wants to know what this date is, for example to display it in the map title.
     */
    out.getTime = function () {
        return out.statData('default').getTime()
    }

    /**
     * Set some map attributes based on the following URL parameters:
     * "w":width, "h":height, "x":xGeoCenter, "y":yGeoCenter, "z":pixGeoSize, "s":scale, "lvl":nuts level, "time":time,
     * "proj":CRS, "geo":geo territory, "ny":nuts version, "language":langage, "numberOfClasses":class number
     */
    out.setFromURL = function () {
        const opts = getURLParameters()
        if (opts.w) out.width(opts.w)
        if (opts.h) out.height(opts.h)
        if (opts.x && opts.y) out.geoCenter([opts.x, opts.y])
        if (opts.z) out.pixelSize(opts.z)
        if (opts.s) out.scale(opts.s)
        if (opts.lvl) out.nutsLevel(opts.lvl)
        if (opts.time) {
            out.filters_.time = opts.time
            delete out.filters_.lastTimePeriod
        }
        if (opts.proj) out.proj(opts.proj)
        if (opts.geo) out.geo(opts.geo)
        if (opts.ny) out.nutsYear(opts.ny)
        if (opts.language) out.language(opts.language)
        if (opts.numberOfClasses) out.numberOfClasses(+opts.numberOfClasses)
        return out
    }

    /**
     * @function exportMapToSVG
     * @description Exports the current map with styling to SVG and downloads it
     *
     */
    out.exportMapToSVG = function () {
        // Clone the original SVG node to avoid modifying the DOM
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Add XML namespaces if not already present
        if (!svgNodeClone.hasAttribute('xmlns')) {
            svgNodeClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
        }
        if (!svgNodeClone.hasAttribute('xmlns:xlink')) {
            svgNodeClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
        }

        // Temporarily append the clone to the document to compute styles
        document.body.appendChild(svgNodeClone)

        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Remove the cloned SVG from the document after applying styles
        document.body.removeChild(svgNodeClone)

        const svgUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getDownloadURL)(svgNodeClone)

        // Create a download link and trigger download
        const downloadLink = document.createElement('a')
        downloadLink.href = svgUrl
        downloadLink.download = 'eurostatmap.svg'
        document.body.appendChild(downloadLink)
        downloadLink.click()
        document.body.removeChild(downloadLink)

        return out
    }

    /**
     * @function exportMapToPNG
     * @description Exports the current map with styling to PNG and downloads it
     *
     */
    out.exportMapToPNG = function (width, height) {
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Step 1: Serialize the SVG node to a string
        const serializer = new XMLSerializer()
        const svgString = serializer.serializeToString(svgNodeClone)

        // Step 2: Create a Blob from the serialized SVG
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' })

        // Step 3: Create a URL for the Blob
        const url = URL.createObjectURL(svgBlob)

        // Get the width and height attributes from the SVG
        width = width || svgNodeClone.getAttribute('width')
        height = height || svgNodeClone.getAttribute('height')

        if (!width || !height) {
            throw new Error('SVG width or height attributes are missing or invalid.')
        }

        // Step 4: Create an Image element and load the Blob URL
        const img = new Image()
        img.onload = function () {
            // Step 5: Draw the image on a canvas
            const canvas = document.createElement('canvas')
            canvas.width = parseFloat(width) // Set canvas width from SVG's width attribute
            canvas.height = parseFloat(height) // Set canvas height from SVG's height attribute

            const context = canvas.getContext('2d')
            context.drawImage(img, 0, 0, canvas.width, canvas.height)

            // Step 6: Convert the canvas to a PNG blob
            canvas.toBlob(function (pngBlob) {
                // Step 7: Download the PNG file
                const pngUrl = URL.createObjectURL(pngBlob)
                const downloadLink = document.createElement('a')
                downloadLink.href = pngUrl
                downloadLink.download = 'eurostat-map.png'
                document.body.appendChild(downloadLink)
                downloadLink.click()
                document.body.removeChild(downloadLink)

                // Clean up URLs
                URL.revokeObjectURL(url)
                URL.revokeObjectURL(pngUrl)
            }, 'image/png')
        }

        // Set the image source to the Blob URL
        img.src = url
        return out
    }

    return out
}

/**
 * Retrieve some URL parameters, which could be then reused as map definition parameters.
 * This allow a quick map customisation by simply adding and changing some URL parameters.
 * See map method: setFromURL(...)
 */
const getURLParameters = function () {
    const ps = {}
    const p = ['w', 'h', 'x', 'y', 'z', 's', 'lvl', 'time', 'proj', 'geo', 'ny', 'language', 'sl', 'numberOfClasses']
    for (let i = 0; i < p.length; i++) ps[p[i]] = getURLParameterByName(p[i])
    return ps
}


/***/ }),

/***/ "./src/core/utils.js":
/*!***************************!*\
  !*** ./src/core/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyInlineStylesFromCSS: () => (/* binding */ applyInlineStylesFromCSS),
/* harmony export */   convertRectanglesToPaths: () => (/* binding */ convertRectanglesToPaths),
/* harmony export */   csvToIndex: () => (/* binding */ csvToIndex),
/* harmony export */   executeForAllInsets: () => (/* binding */ executeForAllInsets),
/* harmony export */   flags: () => (/* binding */ flags),
/* harmony export */   getBBOXAsGeoJSON: () => (/* binding */ getBBOXAsGeoJSON),
/* harmony export */   getCSSPropertyFromClass: () => (/* binding */ getCSSPropertyFromClass),
/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),
/* harmony export */   getEstatDataURL: () => (/* binding */ getEstatDataURL),
/* harmony export */   getEstatRestDataURLBase: () => (/* binding */ getEstatRestDataURLBase),
/* harmony export */   getFontSizeFromClass: () => (/* binding */ getFontSizeFromClass),
/* harmony export */   getLegendRegionsSelector: () => (/* binding */ getLegendRegionsSelector),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   getRegionsSelector: () => (/* binding */ getRegionsSelector),
/* harmony export */   getTextColorForBackground: () => (/* binding */ getTextColorForBackground),
/* harmony export */   getURLParameterByName: () => (/* binding */ getURLParameterByName),
/* harmony export */   hexToRgb: () => (/* binding */ hexToRgb),
/* harmony export */   jsonstatToIndex: () => (/* binding */ jsonstatToIndex),
/* harmony export */   lowerCaseAllWordsExceptFirstLetters: () => (/* binding */ lowerCaseAllWordsExceptFirstLetters),
/* harmony export */   multiplyBlendMultipleHex: () => (/* binding */ multiplyBlendMultipleHex),
/* harmony export */   rasterize: () => (/* binding */ rasterize),
/* harmony export */   serialize: () => (/* binding */ serialize),
/* harmony export */   spaceAsThousandSeparator: () => (/* binding */ spaceAsThousandSeparator),
/* harmony export */   updateCSSRule: () => (/* binding */ updateCSSRule),
/* harmony export */   upperCaseFirstLetter: () => (/* binding */ upperCaseFirstLetter)
/* harmony export */ });
// e.g. to be used with deprecated .style() functions. They will now update CSS classes.
function updateCSSRule(selector, property, value) {
    // Validate the selector
    if (!selector.startsWith('.') && !selector.startsWith('#')) {
        throw new Error('Invalid selector: Must start with "." for classes or "#" for IDs.')
    }

    // Check if the rule already exists in any stylesheet
    const styleSheets = Array.from(document.styleSheets)
    for (const styleSheet of styleSheets) {
        try {
            const rules = styleSheet.cssRules || styleSheet.rules
            for (const rule of rules) {
                if (rule.selectorText === selector) {
                    // Update the property if the rule exists
                    rule.style[property] = value
                    return
                }
            }
        } catch (e) {
            // Some stylesheets (e.g., cross-origin) may not be accessible
            console.warn(`Could not access rules in stylesheet:`, e)
        }
    }

    // If the rule doesn't exist, create a new stylesheet and add it
    let customSheet = document.getElementById('custom-styles')
    if (!customSheet) {
        customSheet = document.createElement('style')
        customSheet.id = 'custom-styles'
        document.head.appendChild(customSheet)
    }

    // Add the new rule to the custom stylesheet
    try {
        customSheet.sheet.insertRule(`${selector} { ${property}: ${value}; }`, customSheet.sheet.cssRules.length)
    } catch (e) {
        console.error(`Failed to insert rule: ${selector} { ${property}: ${value}; }`, e)
    }
}

const getFontSizeFromClass = function (className) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'
    tempElement.style.fontSize = 'initial'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed font-size property and parse it to a number
    const fontSize = parseFloat(window.getComputedStyle(tempElement).fontSize)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return fontSize || 0
}

const getCSSPropertyFromClass = function (className, propertyName) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed value of the specified property
    const propertyValue = window.getComputedStyle(tempElement).getPropertyValue(propertyName)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return propertyValue || null
}

// Helper function to get all CSS rules defined in the document
function getAllCSSRules() {
    let cssRules = []
    for (let sheet of document.styleSheets) {
        try {
            // Some stylesheets may not be accessible due to CORS, so we catch any errors
            for (let rule of sheet.cssRules) {
                cssRules.push(rule)
            }
        } catch (e) {
            console.warn('Unable to access stylesheet:', sheet.href, e)
        }
    }
    return cssRules
}

// Helper function to get explicitly defined styles from CSS for an element
function getStylesFromCSS(element) {
    let matchedRules = []
    const cssRules = getAllCSSRules()

    cssRules.forEach((rule) => {
        if (element.matches(rule.selectorText)) {
            matchedRules.push(rule.style)
        }
    })

    // Create an object of the explicitly set styles
    let explicitStyles = {}
    matchedRules.forEach((style) => {
        for (let i = 0; i < style.length; i++) {
            const property = style[i]
            explicitStyles[property] = style.getPropertyValue(property)
        }
    })

    return explicitStyles
}

// Helper function to apply inline styles explicitly set in CSS. Useful for exporting SVGs with CSS styles.
const applyInlineStylesFromCSS = (svgElement) => {
    const allElements = svgElement.querySelectorAll('*')

    allElements.forEach((element) => {
        const cssStyles = getStylesFromCSS(element)

        // Apply each explicitly defined CSS style as an inline style
        Object.keys(cssStyles).forEach((property) => {
            const value = cssStyles[property]

            // Check if the property already has an inline style
            const existingInlineStyle = element.style.getPropertyValue(property)

            if (!existingInlineStyle && value) {
                // If no existing inline style, set the new style
                element.style.setProperty(property, value)
            }
        })
    })
}

/**
 * Return a GeoJSON feature representing a bounding box, with multipoint geometry.
 * This bounding box is an array like the one in topojson bbox element.
 * [xmin,ymin,xmax,ymax]
 * This is useful for to call d3.fitSize([w, h], getTopoJSONExtentAsGeoJSON(topo.bbox)))
 *
 * @param {*} bb The bounding box [xmin,ymin,xmax,ymax]. For topojson data, just give the topojson.bbox element.
 */
const getBBOXAsGeoJSON = function (bb) {
    return {
        type: 'Feature',
        geometry: {
            type: 'MultiPoint',
            coordinates: [
                [bb[0], bb[1]],
                [bb[2], bb[3]],
            ],
        },
    }
}

// indexing

/**
 * Index JSONStat stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} jsData The JSONStat data to index
 */
const jsonstatToIndex = function (jsData) {
    const ind = {}
    const geos = jsData.Dimension('geo').id
    for (let i = 0; i < geos.length; i++) ind[geos[i]] = jsData.Data(i)
    return ind
}

/**
 * Index CSV stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} csvData The CSV data to index
 * @param {*} geoCol The name of the geo column in the CSV data
 * @param {*} valueCol The name of the statistical value column in the CSV file.
 */
const csvToIndex = function (csvData, geoCol, valueCol) {
    const ind = {}
    for (let i = 0; i < csvData.length; i++) {
        const d = csvData[i]
        const v = d[valueCol]
        if (!v) {
            ind[d[geoCol]] = { value: ':', status: '' }
        } else {
            ind[d[geoCol]] = { value: isNaN(+v) ? v : +v, status: '' }
        }
    }
    return ind
}

/**
 * @description returns string with space as thousand separator
 * @function spaceAsThousandSeparator
 * @param {number} number
 */
const spaceAsThousandSeparator = function (number) {
    return number.toLocaleString('en').replace(/,/gi, ' ')
}

//REST API
const getEstatRestDataURLBase = 'https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/'

/**
 * Build URL to fetch data from eurobase REST API.
 * @param {string} datasetCode The Eurobase dataset code
 * @param {object=} filters The filter parameters as for example: {key:value,key:[value1,value2,value3]}
 * @param {number=} lang
 * @param {number=} format
 * @param {number=} version
 */
const getEstatDataURL = function (datasetCode, filters, lang, format) {
    lang = lang || 'en'
    format = format || 'json'
    var url = []
    url.push(getEstatRestDataURLBase, datasetCode, '?', 'format=', format, '&lang=', lang)
    if (filters)
        for (var param in filters) {
            var o = filters[param]
            if (Array.isArray(o)) for (var i = 0; i < o.length; i++) url.push('&', param, '=', o[i])
            else url.push('&', param, '=', o)
        }
    return url.join('')
}

/**
 * @param {string} name
 * @returns {string}
 */
const getURLParameterByName = function (name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

//flags
const flags = {
    b: 'break in time series',
    c: 'confidential',
    d: 'definition differs, see metadata',
    e: 'estimated',
    f: 'forecast',
    n: 'not significant',
    p: 'provisional',
    r: 'revised',
    s: 'Eurostat estimate',
    u: 'low reliability',
    z: 'not applicable',
}

/**
 * @description Executes a function for all inset maps. Some insets might be external SVGs which is why this function was created.
 * @param {*} insets map.insets
 * @param {*} mainSvgId the ID of the map's svg
 * @param {*} callback the function to execute for each inset
 * @param {*} [parameter=null] the parameter to pass to the callback
 * @param {*} [parameter2=null] the parameter to pass to the callback
 */
const executeForAllInsets = function (insets, mainSvgId, callback, parameter = null, parameter2 = null) {
    for (const geo in insets) {
        const insetGroup = insets[geo]

        if (Array.isArray(insetGroup)) {
            insetGroup.forEach((inset) => {
                // Handle nested arrays for multiple insets with the same geo
                if (Array.isArray(inset)) {
                    inset.forEach((nestedInset) => {
                        if (nestedInset.svgId_ !== mainSvgId) {
                            callback(nestedInset, parameter, parameter2)
                        }
                    })
                } else {
                    if (inset.svgId_ !== mainSvgId) {
                        callback(inset, parameter, parameter2)
                    }
                }
            })
        } else {
            // Apply callback to unique inset
            if (insetGroup.svgId_ !== mainSvgId) {
                callback(insetGroup, parameter, parameter2)
            }
        }
    }
}

const upperCaseFirstLetter = (string) => `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`

const lowerCaseAllWordsExceptFirstLetters = (string) =>
    string.replaceAll(/\S*/g, (word) => `${word.slice(0, 1)}${word.slice(1).toLowerCase()}`)

function getDownloadURL(svgNode) {
    // Create XML header to ensure the SVG is recognized properly
    const xmlHeader = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'

    // create blob
    const svgContent = xmlHeader + svgNode.outerHTML
    const svgBlob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' })
    const svgUrl = URL.createObjectURL(svgBlob)
    return svgUrl
}

// Rasterize function with additional error handling
function serialize(svg) {
    const xmlns = 'http://www.w3.org/2000/xmlns/'
    const xlinkns = 'http://www.w3.org/1999/xlink'
    const svgns = 'http://www.w3.org/2000/svg'
    const fragment = window.location.href + '#'
    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false)
    while (walker.nextNode()) {
        for (const attr of walker.currentNode.attributes) {
            if (attr.value.includes(fragment)) {
                attr.value = attr.value.replace(fragment, '#')
            }
        }
    }
    svg.setAttributeNS(xmlns, 'xmlns', svgns)
    svg.setAttributeNS(xmlns, 'xmlns:xlink', xlinkns)
    const serializer = new window.XMLSerializer()
    const string = serializer.serializeToString(svg)
    return new Blob([string], { type: 'image/svg+xml' })
}

// adapted from https://observablehq.com/@mbostock/saving-sv
//svg to canvas blob promise
function rasterize(svg) {
    let resolve, reject
    const promise = new Promise((y, n) => ((resolve = y), (reject = n)))
    const image = new Image()
    image.onerror = reject
    image.onload = () => {
        const rect = svg.getBoundingClientRect()
        const canvas = document.createElement('canvas')
        canvas.width = rect.width
        canvas.height = rect.height
        const context = canvas.getContext('2d')
        context.drawImage(image, 0, 0, rect.width, rect.height)
        context.canvas.toBlob(resolve)
    }
    image.src = URL.createObjectURL(serialize(svg))
    return promise
}

/**
 * Get a URL parameter by name.
 *
 * @param {string} name
 * @returns {string | null}
 */
function getParameterByName(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    let regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

const hexToRgb = (hex) => {
    hex = hex.replace('#', '')
    if (hex.length === 3) {
        hex = hex
            .split('')
            .map((h) => h + h)
            .join('')
    }
    const int = parseInt(hex, 16)
    return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
}

//blends two colors using 'multiply' blending mode. Returns the blended color as an RGB string
const multiplyBlendMultipleHex = (colors) => {
    // Convert hex color to RGB
    const hexToRgb = (hex) => {
        hex = hex.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((h) => h + h)
                .join('')
        }
        const int = parseInt(hex, 16)
        return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
    }

    // Convert RGB to hex
    const rgbToHex = ([r, g, b]) => `#${[r, g, b].map((c) => c.toString(16).padStart(2, '0')).join('')}`

    // Convert all hex colors to RGB arrays
    const rgbColors = colors.map(hexToRgb)

    // Initialize the result with the first color
    let blended = [...rgbColors[0]]

    // Sequentially multiply each color with the result
    for (let i = 1; i < rgbColors.length; i++) {
        blended = blended.map((v, idx) => Math.round((v / 255) * (rgbColors[i][idx] / 255) * 255))
    }

    // Return the blended color as a hex code
    return rgbToHex(blended)
}

// convert rect attributes into an SVG path string
// used for workaround whereby clipPaths which use rect elements do not work in adobe illustrator
const convertRectanglesToPaths = function (x, y, width, height) {
    var x = parseFloat(x, 10)
    var y = parseFloat(y, 10)
    var width = parseFloat(width, 10)
    var height = parseFloat(height, 10)

    if (x < 0 || y < 0 || width < 0 || height < 0) {
        return ''
    }

    return 'M' + x + ',' + y + 'L' + (x + width) + ',' + y + ' ' + (x + width) + ',' + (y + height) + ' ' + x + ',' + (y + height) + 'z'
}

const getTextColorForBackground = function (backgroundColor) {
    let r, g, b

    // Create a temporary element to handle named colors
    if (!backgroundColor.startsWith('rgb') && !backgroundColor.startsWith('#')) {
        const tempDiv = document.createElement('div')
        tempDiv.style.color = backgroundColor
        document.body.appendChild(tempDiv)
        const computedColor = window.getComputedStyle(tempDiv).color
        document.body.removeChild(tempDiv)
        backgroundColor = computedColor // Convert named color to RGB
    }

    // Handle hex colors like '#FFFFFF' or '#FFF'
    if (backgroundColor.startsWith('#')) {
        let hex = backgroundColor.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((c) => c + c)
                .join('')
        }
        r = parseInt(hex.substring(0, 2), 16)
        g = parseInt(hex.substring(2, 4), 16)
        b = parseInt(hex.substring(4, 6), 16)
    }
    // Handle RGB colors like 'rgb(255,255,255)'
    else {
        const rgb = backgroundColor.match(/\d+/g)
        r = parseInt(rgb[0])
        g = parseInt(rgb[1])
        b = parseInt(rgb[2])
    }

    // Calculate luminance
    const luminance = 0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255)

    // Return black for light backgrounds, white for dark backgrounds
    return luminance > 0.5 ? 'black' : 'white'
}

// get css selector. Different maps have different selectors for their regions.
const getRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions path'
    if (map.gridCartogram_) return '#em-grid-container .em-grid-cell'
    if (map.geo_ === 'WORLD') return '#em-worldrg path'
    return '#em-nutsrg path:not(#em-cntrg-RS):not(#em-cntrg-EL), #em-cntrg path:not(#em-cntrg-RS):not(#em-cntrg-EL)'
}

// get css selector for legend mouse hover. Different maps have different selectors for their regions
const getLegendRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions'
    if (map.gridCartogram_) return '#em-grid-container'
    if (map.geo_ === 'WORLD') return '#em-worldrg'
    return '#em-nutsrg, #em-cntrg'
}


/***/ }),

/***/ "./src/css/index.css":
/*!***************************!*\
  !*** ./src/css/index.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./index.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/eurostat-map.js":
/*!*****************************!*\
  !*** ./src/eurostat-map.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* binding */ getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* binding */ getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maptypes/map-choropleth */ "./src/maptypes/map-choropleth.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maptypes/map-categorical */ "./src/maptypes/map-categorical.js");
/* harmony import */ var _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./maptypes/map-choropleth-bivariate */ "./src/maptypes/map-choropleth-bivariate.js");
/* harmony import */ var _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./maptypes/map-choropleth-trivariate */ "./src/maptypes/map-choropleth-trivariate.js");
/* harmony import */ var _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maptypes/map-stripe-composition */ "./src/maptypes/map-stripe-composition.js");
/* harmony import */ var _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./maptypes/map-piecharts */ "./src/maptypes/map-piecharts.js");
/* harmony import */ var _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./maptypes/map-sparklines */ "./src/maptypes/map-sparklines.js");
/* harmony import */ var _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./maptypes/map-flow */ "./src/maptypes/map-flow.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _core_labels__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/labels */ "./src/core/labels.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../package.json */ "./package.json");












/**
 * Function returning a eurostat-map object.
 *
 * @param {*} type The type of map ('ch' for choropleth, etc.)
 * @param {*} config The configuration object. Ex.: { title: "Map title", geoCenter: [233,654], ...}
 */
const map = function (type, config) {
    //choropleth map
    if (type == 'choropleth' || type == 'ch') return _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__.map(config)
    //categorical map
    if (type == 'categorical' || type == 'ct') return _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__.map(config)
    //proportionnal symbols map
    if (type == 'proportionalSymbol' || type == 'ps') return _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.map(config)
    //bivariate choropleth
    if (type == 'bivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__.map(config)
    //trivariate choropleth
    if (type == 'trivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__.map(config)
    //stripes composition
    if (type == 'stripeComposition' || type == 'scomp') return _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__.map(config)
    //proportional pie charts
    if (type == 'pieChart' || type == 'pie') return _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__.map(config)
    //sparkline maps
    if (type == 'sparkline' || type == 'spark' || type == 'sparklines') return _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__.map(config)
    //flow maps
    if (type == 'flow' || type == 'flowmap') return _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__.map(config)

    //add new map types here
    //if(type == "XX") return mapXX.map(config);

    console.log('Unexpected map type: ' + type)
    return _core_stat_map__WEBPACK_IMPORTED_MODULE_9__.statMap(config, true, type)
}

/**
 * Return a function which builds fill patterns style.
 * The returned function has for arguments the SVG element where to use the fill pattern, and the number of classes.
 *
 * @param {*} opts Various parameters on the fill pattern.
 * @returns {function}
 */
const getFillPatternDefinitionFunction = function (opts) {
    opts = opts || {}
    opts.shape = opts.shape || 'circle'
    const ps = opts.patternSize || 5
    const smin = opts.minSize || 1
    const smax = opts.maxSize || 5.5
    opts.bckColor = opts.bckColor || 'white'
    opts.symbColor = opts.symbColor || 'black'
    return function (svg, numberOfClasses) {
        //clear previous
        svg.selectAll('.em-fill-pattern').remove()
        for (let i = 0; i < numberOfClasses; i++) {
            const si = smin + ((smax - smin) * i) / (numberOfClasses - 1)
            const patt = svg
                .append('pattern')
                .attr('class', 'em-fill-pattern')
                .attr('id', 'pattern_' + i)
                .attr('x', '0')
                .attr('y', '0')
                .attr('width', ps)
                .attr('height', ps)
                .attr('patternUnits', 'userSpaceOnUse')
            patt.append('rect').attr('x', 0).attr('y', 0).attr('width', ps).attr('height', ps).style('stroke', 'none').style('fill', opts.bckColor)
            if (opts.shape == 'square')
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', si)
                    .attr('height', si)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
            else
                patt.append('circle')
                    .attr('cx', ps * 0.5)
                    .attr('cy', ps * 0.5)
                    .attr('r', si * 0.5)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
        }
    }
}

const getDefaultLabels = function () {
    return _core_labels__WEBPACK_IMPORTED_MODULE_10__.DEFAULTLABELS
}

;
const version = _package_json__WEBPACK_IMPORTED_MODULE_11__.version


/***/ }),

/***/ "./src/legend/legend-categorical.js":
/*!******************************************!*\
  !*** ./src/legend/legend-categorical.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");





/**
 * A legend for categorical maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 13
    //the height of the legend box elements
    out.shapeHeight = 15
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'
    // allow the user to define the order of the legend elements manually as an array
    out.order = undefined

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node() && out.map.classifier_) {
            const map = out.map
            const container = out.lgg

            //draw legend background box
            out.makeBackgroundBox()

            //draw title
            if (out.title) {
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + out.titleFontSize)
                    .text(out.title)
            }

            //get category codes
            const domain = map.classToFillStyle() ? Object.keys(map.classToFillStyle()) : map.classifier_.domain()
            const ecls = out.order ? out.order : domain

            //draw legend elements for classes: rectangle + label
            for (let i = 0; i < ecls.length; i++) {
                //the class
                const ecl_ = ecls[i]
                const ecl = map.classifier_(ecl_)
                const fillColor = map.classToFillStyle_[ecl_]

                //the vertical position of the legend element
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', fillColor)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, ecl)
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, ecl)
                        }
                    })

                //label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(map.classToText() ? map.classToText()[ecl_] : ecl_)
            }

            //'no data' legend box
            if (out.noData) {
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + ecls.length * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', map.noDataFillStyle_)
                    .on('mouseover', function () {
                        highlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, 'nd')
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, 'nd')
                        }
                    })

                //'no data' label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(out.noDataText)
            }

            // Append pattern fill legend items BELOW the main legend
            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-bivariate.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-choropleth-bivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth-bivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //size
    out.squareSize = 100

    //orientation
    out.rotation = 0

    //labels
    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'

    //get the font size of the texts
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')

    //breaks
    out.breaks1 = undefined
    out.breaks2 = undefined
    out.showBreaks = false // if set to true and breaks1 and breaks2 are undefined then breaks are automatically defined
    out.tickLength = 5 // length of the ticks

    //axis
    out.yAxisLabelsOffset = { x: 0, y: 0 }
    out.xAxisLabelsOffset = { x: 0, y: 0 }

    //axis titles
    out.yAxisTitleOffset = { x: 0, y: 0 }
    out.xAxisTitleOffset = { x: 0, y: 0 }

    //show no data
    out.noData = true
    //show no data
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25

    //no data text label
    out.noDataText = 'No data'

    //override padding
    out.boxPadding = out.labelFontSize

    //add extra distance between legend and no data item
    out.noDataYOffset = 30

    //arrows
    out.axisArrows = true // if set to true, arrows are drawn at the end of the axes
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10 // padding between arrow and axis label

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        // Horizontal shift to move everything right (adjust this value as needed)
        out._horizontalOffset = out.axisTitleFontSize + out.arrowPadding // Adjust this value to move the whole legend to the right

        // Remove previous content
        out.lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Draw title
        if (out.title) {
            out.lgg
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', xc + out._horizontalOffset)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        // The vertical position of the legend element
        out._y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0)

        // Square group with horizontal offset
        addSquares()

        // set breaks if user hasnt defined them but has enabled them
        if (!out.breaks1 && !out.breaks2 && out.showBreaks) {
            // Get quantiles for the first variable (X axis) and truncate to one decimal place
            out.breaks1 = map.classifier1_.quantiles().map((value) => parseFloat(value.toFixed(0)))

            // Get quantiles for the second variable (Y axis) and truncate to one decimal place
            out.breaks2 = map.classifier2_.quantiles().map((value) => parseFloat(value.toFixed(0)))
        }

        // Draw breaks labels 1 (X axis)
        addBreakLabels()

        out._xAxisArrowY = 0
        out._yAxisArrowX = 0
        if (out.axisArrows) {
            addAxisArrows()
        }

        addAxisTitles()

        // Arrow defs
        out.lgg
            .append('defs')
            .append('marker')
            .attr('viewBox', `0 0 ${out.arrowWidth} ${out.arrowHeight}`)
            .attr('id', 'arrowhead')
            .attr('refX', 0)
            .attr('refY', 5)
            .attr('markerWidth', out.arrowWidth)
            .attr('markerHeight', out.arrowHeight)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 5 5 L 0 10')
            .attr('marker-units', 'strokeWidth')

        // 'No data' legend box
        if (out.noData) {
            addNoDataElement()
        }

        // Set legend box dimensions
        out.setBoxDimension()
    }

    function addNoDataElement() {
        const noDataYOffset =
            out.rotation === 0 ? out.noDataYOffset + out.squareSize / out.map.numberOfClasses_ + out.arrowHeight / 2 : out.noDataYOffset

        let noDataY =
            out.rotation === 0 ? out._y + out.squareSize + noDataYOffset : out._y + 1.4142 * out.squareSize + out.boxPadding * 2 + noDataYOffset

        out.lgg
            .append('rect')
            .attr('class', 'em-bivariate-nodata')
            .attr('x', out.boxPadding + out.noDataShapeWidth / 2)
            .attr('y', noDataY + (out.rotation == 0 ? 0 : -10))
            .attr('width', out.noDataShapeWidth)
            .attr('height', out.noDataShapeHeight)
            .style('fill', out.map.noDataFillStyle())
            .on('mouseover', function () {
                const regions = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])('#em-nutsrg')
                const sel = regions.selectAll("[nd='nd']")
                sel.style('fill', 'red')
            })
            .on('mouseout', function () {
                const nRg = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])('#em-nutsrg')
                const sel = nRg.selectAll("[nd='nd']")
                sel.style('fill', function () {
                    return (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')
                })
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', out.map.noDataFillStyle())
            })
        out.lgg
            .append('text')
            .attr('class', 'em-bivariate-nodata-label')
            .attr('x', out.boxPadding + out.noDataShapeWidth + (out.noDataShapeWidth / 2 + 5))
            .attr('y', noDataY + out.noDataShapeHeight * 0.5 + 1 + (out.rotation == 0 ? 0 : -10))
            .text(out.noDataText)
    }

    function addSquares() {
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()
        const sz = out.squareSize / numberOfClasses
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        const square = lgg
            .append('g')
            .attr('class', 'bivariate-squares-chart')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // Draw rectangles
        for (let i = 0; i < numberOfClasses; i++) {
            for (let j = 0; j < numberOfClasses; j++) {
                const ecl1 = numberOfClasses - i - 1
                const ecl2 = numberOfClasses - j - 1
                const fill = out.map.classToFillStyle()(ecl1, ecl2)

                square
                    .append('rect')
                    .attr('class', 'em-bivariate-square')
                    .attr('x', initialX + (numberOfClasses - 1 - i) * sz)
                    .attr('y', j * sz)
                    .attr('width', sz)
                    .attr('height', sz)
                    .style('fill', fill)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl1, ecl2)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl1, ecl2)
                        }
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).raise() // raise legend square to avoid stroke issue
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl1, ecl2)
                        }
                    })
            }
        }

        // Frame
        square
            .append('rect')
            .attr('class', 'em-bivariate-frame')
            .attr('x', initialX)
            .attr('y', 0)
            .attr('width', out.squareSize)
            .attr('height', out.squareSize)
            .attr('stroke-width', 0.7)
    }

    function addBreakLabels() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0
        const numberOfClasses = out.map.numberOfClasses()
        const sz = out.squareSize / numberOfClasses

        // group with horizontal offset
        const breakLabels = out.lgg
            .append('g')
            .attr('class', 'bivariate-break-labels')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )
        if (out.breaks1) {
            for (let i = 0; i < out.breaks1.length; i++) {
                const x = initialX + sz * (i + 1)
                const y = out.squareSize + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label')

                breakLabels
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.xAxisLabelsOffset.x )
                    .attr('y', y + out.xAxisLabelsOffset.y )
                    .text(out.breaks1[i])

                breakLabels
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x)
                    .attr('x2', x)
                    .attr('y1', out.squareSize)
                    .attr('y2', out.squareSize + out.tickLength)
            }
        }

        // Draw breaks labels 2 (Y axis)
        if (out.breaks2) {
            for (let i = 0; i < out.breaks2.length; i++) {
                const x = initialX
                const y = sz * (i + 2) - sz

                breakLabels
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.yAxisLabelsOffset.x)
                    .attr('y', y - out.yAxisLabelsOffset.y - (out.tickLength + 2))
                    .text([...out.breaks2].reverse()[i])
                    .attr('text-anchor', 'middle')
                    .attr('transform', `rotate(-90, ${x}, ${y})`)

                breakLabels
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x)
                    .attr('x2', x - out.tickLength)
                    .attr('y1', y)
                    .attr('y2', y)
            }
        }
    }

    function addAxisTitles() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        const axisTitles = out.lgg
            .append('g')
            .attr('class', 'bivariate-axis-titles')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // X axis title
        let xAxisTitleY = out.squareSize + out.xAxisLabelsOffset.y + (out.axisArrows ? out.arrowPadding + out.arrowHeight : 7)
        let xAxisTitleX = initialX
        if (out.showBreaks || (out.breaks1 && out.breaks2)) xAxisTitleY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') // move over for tick labels
        if (out.xAxisTitleOffset) xAxisTitleY += out.xAxisTitleOffset.y
        if (out.xAxisTitleOffset) xAxisTitleX += out.xAxisTitleOffset.x
        axisTitles
            .append('text')
            .attr('class', 'em-bivariate-axis-title em-bivariate-axis-title-x')
            .attr('x', xAxisTitleX)
            .attr('y', xAxisTitleY)
            .text(out.label1)
            .attr('dominant-baseline', 'hanging')
            .attr('alignment-baseline', 'hanging')

        // Y axis title
        let yAxisTitleY = (out.axisArrows ? out._yAxisArrowX - out.arrowPadding : 7) + (out.rotation == -45 ? -4 : -10) // adjust for rotation
        if (out.showBreaks || (out.breaks1 && out.breaks2)) xAxisTitleY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') // move over for tick labels
        let yAxisTitleX = -out.squareSize
        //manual offsets
        if (out.yAxisTitleOffset) yAxisTitleY += out.yAxisTitleOffset.y
        if (out.yAxisTitleOffset) yAxisTitleX += out.yAxisTitleOffset.x
        axisTitles
            .append('text')
            .attr('class', 'em-bivariate-axis-title em-bivariate-axis-title-y')
            .attr('x', yAxisTitleX)
            .attr('y', yAxisTitleY)
            .text(out.label2)
            .style('transform', out.rotation < 0 ? `translate(${out.axisArrows ? -51 : -15}px, 95px) rotate(90deg)` : 'rotate(-90deg)')
    }

    function addAxisArrows() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        // group with horizontal offset
        const axisArrows = out.lgg
            .append('g')
            .attr('class', 'bivariate-axis-arrows')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // Append X axis arrow
        out._xAxisArrowY = out.squareSize + out.tickLength + out.arrowPadding
        if (out.showBreaks || (out.breaks1 && out.breaks2)) out._xAxisArrowY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') / 1.5 // move over for tick labels

        axisArrows
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__["default"])()([
                    [initialX, out._xAxisArrowY],
                    [initialX + out.squareSize, out._xAxisArrowY],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')

        // Append Y axis arrow
        out._yAxisArrowX = -out.tickLength - out.arrowPadding
        if (out.showBreaks || (out.breaks1 && out.breaks2)) out._yAxisArrowX -= out.labelFontSize / 2 // move over for tick labels

        axisArrows
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__["default"])()([
                    [out._yAxisArrowX, out.squareSize],
                    [out._yAxisArrowX, 0],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-trivariate.js":
/*!****************************************************!*\
  !*** ./src/legend/legend-choropleth-trivariate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");




/**
 * A legend for choropleth-trivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    // Default settings
    out.width = 230
    out.height = 230

    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'
    out.label3 = 'Variable 3' // Add a label for the third variable
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')
    out.showBreaks = false
    out.noData = true
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25
    out.noDataText = 'No data'
    out.boxPadding = 60 // depends on variable 1 label length really
    out.noDataYOffset = 20
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10

    if (config) for (let key in config) out[key] = config[key]

    /**
     * Override the update method to handle trivariate legends
     */
    out.update = function () {
        out.updateConfig()
        out.updateContainer()
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()

        // Remove previous content
        lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Apply padding to the main <g> group
        const paddedGroup = lgg.append('g').attr('transform', `translate(${out.boxPadding}, ${out.boxPadding})`)

        // Draw title
        if (out.title) {
            paddedGroup
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Start at 0 within the padded group
                .attr('y', out.titleFontSize) // Vertical positioning
                .text(out.title)
        }

        // Draw the trivariate Venn diagram
        const labels = [out.label1, out.label2, out.label3]
        const colors = [out.map.color1_, out.map.color2_, out.map.color3_]

        drawTrivariateVennDiagram(paddedGroup, colors, labels)

        // Handle trivariate (Venn Diagram) or bivariate (grid) legend
        // if (numberOfClasses === 7) {
        //     drawTrivariateVennDiagram(lgg, out)
        // } else {
        //     drawTrivariateTernaryPlot(lgg, out, numberOfClasses)
        // }
    }

    return out
}

function drawTrivariateVennDiagram(container, colors, labels) {
    //specs for Circle 1
    const xCenter1 = 50
    const yCenter1 = 50
    const circleRad = 30

    //draw Circle 1
    // const circle1 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter1 + ',' + yCenter1 + ')')

    //add'l specs for Circle 2
    const offsetFactor = 1.2
    const offset = offsetFactor * circleRad
    const xCenter2 = xCenter1 + offset
    const yCenter2 = yCenter1 //creating new var for clarity

    //draw Circle 2
    // const circle2 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter2 + ',' + yCenter2 + ')')

    //add'l specs for Circle 3
    const xCenter3 = xCenter1 + offset / 2
    const yCenter3 = yCenter1 + (Math.sqrt(3) * offset) / 2

    //draw Circle 3
    // const circle3 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter3 + ',' + yCenter3 + ')')

    //compute first points of intersection
    const triHeight = Math.sqrt(circleRad ** 2 - (offset / 2) ** 2)
    //outer intersection of Circles 1 and 2
    const xIsect1 = xCenter3
    const yIsect1 = yCenter1 - triHeight
    //inner intersection of Circles 1 and 2
    const xIsect4 = xCenter3
    const yIsect4 = yCenter1 + triHeight

    //treat "triHeight" as the hypoteneuse of a 30.60.90 triangle.
    //this tells us the shift from the midpoint of a leg of the triangle
    //to the point of intersection
    const xDelta = (triHeight * Math.sqrt(3)) / 2
    const yDelta = triHeight / 2

    const xMidpointC1C3 = (xCenter1 + xCenter3) / 2
    const xMidpointC2C3 = (xCenter2 + xCenter3) / 2
    const yMidpointBoth = (yCenter1 + yCenter3) / 2

    //find the rest of the points of intersection
    const xIsect2 = xMidpointC1C3 - xDelta
    const yIsect2 = yMidpointBoth + yDelta
    const xIsect3 = xMidpointC2C3 + xDelta
    const yIsect3 = yMidpointBoth + yDelta

    const xIsect5 = xMidpointC1C3 + xDelta
    const yIsect5 = yMidpointBoth - yDelta
    const xIsect6 = xMidpointC2C3 - xDelta
    const yIsect6 = yMidpointBoth - yDelta

    const xPoints = [xIsect1, xIsect2, xIsect3, xIsect4, xIsect5, xIsect6]
    const yPoints = [yIsect1, yIsect2, yIsect3, yIsect4, yIsect5, yIsect6]

    const makeIronShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const makeSunShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 0 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 1 1 ${x1} ${y1}`
        return path
    }

    const makeRoundedTri = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 1 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const ironPoints = [
        [1, 5, 6],
        [3, 4, 5],
        [2, 6, 4],
    ]
    const sunPoints = [
        [3, 5, 1],
        [2, 4, 3],
        [1, 6, 2],
    ]
    const roundedTriPoints = [[5, 4, 6]]

    // main circles (raw colors)
    sunPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeSunShapes(ptCycle)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', colors[index]).attr('opacity', 1)
    })

    // first intersects (combination of 2 colors)
    ironPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeIronShapes(ptCycle)

        let color
        if (index == 0) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[2], colors[0]]) // pink + cyan
        } else if (index == 1) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[0]]) // cyan + yellow
        } else if (index == 2) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[2]]) // pink + yellow
        }

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    // nucleus (combination of all 3 colors)
    roundedTriPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeRoundedTri(ptCycle)
        const color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)(colors)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    container
        .selectAll('path.segment')
        .on('mouseover', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 0.8).duration(500)
        })
        .on('mouseout', function () {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 1).duration(500)
        })

    // label intersects
    const yOffset = container
        .append('text')
        .text(labels[0])
        .attr('x', xCenter1 - circleRad - 3)
        .attr('y', xCenter1)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'end')
    container
        .append('text')
        .text(labels[1])
        .attr('x', xCenter2 + circleRad + 3)
        .attr('y', yCenter2)
        .attr('class', 'venn-label')
    container
        .append('text')
        .text(labels[2])
        .attr('x', xCenter3)
        .attr('y', yCenter3 + circleRad + 15)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'middle')
}

/**
 * Draws a trivariate legend as a Venn Diagram
 */
function drawTrivariateVennDiagram2(svg, containerWidth, containerHeight, labels, colors) {
    const radius = containerWidth / 5 // Radius of each circle
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    const offset = radius / 1.5

    // Define circle positions
    const circles = [
        { id: 'circle1', cx: centerX - offset, cy: centerY, label: labels[0], color: colors[0] },
        { id: 'circle2', cx: centerX + offset, cy: centerY, label: labels[1], color: colors[1] },
        { id: 'circle3', cx: centerX, cy: centerY + offset * 1.5, label: labels[2], color: colors[2] },
    ]

    // Draw circles
    circles.forEach(({ id, cx, cy, label, color }, index) => {
        svg.append('circle').attr('id', id).attr('cx', cx).attr('cy', cy).attr('r', radius).style('fill', color).style('opacity', 1)

        // Add labels with specific positioning
        const labelX =
            index === 0
                ? cx - radius - 10 // Left of the first circle
                : index === 1
                  ? cx + radius + 10 // Right of the second circle
                  : cx // Below the third circle

        const labelY = index < 2 ? cy : cy + radius + 20 // Same y for first two circles, below for the third

        svg.append('text')
            .attr('x', labelX)
            .attr('y', labelY)
            .attr('text-anchor', index < 2 ? (index === 0 ? 'end' : 'start') : 'middle') // Adjust alignment
            .attr('class', 'venn-label')
            .text(label)
            .style('font-size', '12px')
    })
}

/**
 * Draws a trivariate legend as a ternary plot
 */
function drawTrivariateTernaryPlot(lgg, out, numberOfClasses) {
    const size = out.squareSize // Size of the legend area
    const padding = 20 // Padding around the plot
    const radius = 5 // Radius of each class point
    const triangleHeight = (Math.sqrt(3) / 2) * size

    const ternaryGroup = lgg
        .append('g')
        .attr('class', 'trivariate-ternary-plot')
        .attr('transform', `translate(${out.boxPadding + size / 2}, ${out.boxPadding + triangleHeight / 2})`)

    // Draw the triangle
    const vertices = [
        { x: 0, y: -triangleHeight / 2 }, // Top vertex (Variable 1)
        { x: -size / 2, y: triangleHeight / 2 }, // Bottom-left vertex (Variable 2)
        { x: size / 2, y: triangleHeight / 2 }, // Bottom-right vertex (Variable 3)
    ]

    ternaryGroup
        .append('polygon')
        .attr('points', vertices.map((d) => `${d.x},${d.y}`).join(' '))
        .attr('fill', 'none')
        .attr('stroke', 'black')

    // Label the vertices
    const labels = [out.label1, out.label2, out.label3]
    vertices.forEach((vertex, i) => {
        ternaryGroup
            .append('text')
            .attr('x', vertex.x)
            .attr('y', vertex.y - (i === 0 ? 10 : -20)) // Offset labels
            .attr('class', 'ternary-label')
            .attr('text-anchor', 'middle')
            .text(labels[i])
    })

    // Plot the points inside the ternary plot
    for (let i = 0; i < numberOfClasses; i++) {
        for (let j = 0; j < numberOfClasses - i; j++) {
            const k = numberOfClasses - i - j - 1 // Ensure sum of i + j + k = numberOfClasses - 1
            const x = ((j - k) * size) / (2 * (numberOfClasses - 1)) // Horizontal position
            const y = (i * -triangleHeight) / (numberOfClasses - 1) // Vertical position

            const fill = out.map.classToFillStyle()(i, j, k)

            ternaryGroup
                .append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', radius)
                .attr('fill', fill)
                .on('mouseover', function () {
                    highlightRegions(out.map, i, j, k)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, i, j, k)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, i, j, k)
                    }
                })
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___'))
        })
    }
}


/***/ }),

/***/ "./src/legend/legend-choropleth.js":
/*!*****************************************!*\
  !*** ./src/legend/legend-choropleth.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/band.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");









/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object (inherit)
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    out.labelType = 'thresholds' // thresholds || ranges
    //the order of the legend elements. Set to false to invert.
    out.ascending = true
    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the separation line length
    out.sepLineLength = out.shapeWidth
    //tick line length in pixels
    out.tickLength = 4
    //the number of decimal for the legend labels
    out.decimals = 0
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 3
    //labelFormatter function
    out.labelFormatter = null
    // manually define labels
    out.labels = null

    // Histogram config as nested object
    out.histogram = null

    //diverging line
    out.pointOfDivergenceLabel = undefined
    out.pointOfDivergence = undefined
    out.pointOfDivergencePadding = 7
    out.divergingLineLength = undefined
    out.divergingArrowLength = undefined

    //show no data
    out.noData = true
    //no data text label
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) {
        for (let key in config) {
            if (key === 'histogram' && typeof config[key] === 'object') {
                out.histogram = {
                    orientation: 'horizontal',
                    showCounts: false,
                    showPercentages: false,
                    labelRotation: 0,
                    labelFormat: undefined,
                    ...config.histogram,
                }
            } else {
                out[key] = config[key]
            }
        }
    }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const map = out.map
            const container = out.lgg

            // Draw legend background box and title if provided
            out.makeBackgroundBox()
            if (out.title) {
                let cssFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title')
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + cssFontSize)
                    .text(out.title)
            }

            //exit early if no classifier
            if (!map.classToFillStyle()) return

            //set default point of divergence if applicable
            if (out.pointOfDivergenceLabel && !out.pointOfDivergence) out.pointOfDivergence = map.numberOfClasses_ / 2

            if (out.histogram) {
                createHistogramLegend()
            } else {
                if (out.labelType === 'ranges') createRangesLegend()
                else createThresholdsLegend()
            }

            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height

            // Append pattern fill legend items BELOW the main legend
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            // Set legend box dimensions
            out.setBoxDimension()
        }
    }

    function getThresholds() {
        const map = out.map
        const thresholds =
            map.thresholds_.length > 1
                ? map.thresholds_
                : Array.from({ length: map.numberOfClasses_ })
                      .map((_, index) => {
                          return map.classifier().invertExtent(index)[out.ascending ? 0 : 1]
                      })
                      .slice(1) // Remove the first entry and return the rest as an array
        return thresholds
    }

    function getColors() {
        const map = out.map
        return map.colors_
            ? map.colors_
            : Array.from({ length: map.numberOfClasses_ }).map((_, index) => {
                  return map.classToFillStyle()(index, map.numberOfClasses_)
              })
    }

    function getData() {
        const map = out.map
        return Object.values(map.statData()._data_).map((item) => item.value)
    }

    function createThresholdsLegend() {
        const m = out.map
        const lgg = out.lgg
        // Label formatter
        const formatLabel = out.labelFormatter || (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(`.${out.decimals}f`)
        let baseY = out.boxPadding
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding
        for (let i = 0; i < m.numberOfClasses_; i++) {
            const y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? m.numberOfClasses() - i - 1 : i
            const fillColor = m.classToFillStyle()(ecl, m.numberOfClasses_)

            // Append rectangle for each class
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append tick line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.boxPadding + out.sepLineLength)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength + out.tickLength)
                    .attr('y2', y)
            }

            // Append label
            if (i < m.numberOfClasses() - 1) {
                // mark label so we can move it in drawDivergingLine
                const label = lgg
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                    .attr('y', y + out.shapeHeight)
                    //.attr('dominant-baseline', 'middle')
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(out.labels ? out.labels[i] : formatLabel(m.classifier().invertExtent(ecl)[out.ascending ? 0 : 1]))

                // mark label so we can move it in drawDivergingLine
                if (out.pointOfDivergenceLabel && i == out.pointOfDivergence - 1) label.attr('class', 'em-legend-label em-legend-label-divergence')
            }
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const y = baseY + m.numberOfClasses() * out.shapeHeight + out.boxPadding
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dy', '0.35em')
                .text(out.noDataText)
        }
    }

    function createRangesLegend() {
        const map = out.map
        const container = out.lgg
        const thresholds = getThresholds()
        const defaultLabeller = (label, i) => {
            if (i === 0) return `> ${thresholds[thresholds.length - 1]}` //top
            if (i === thresholds.length) return `< ${thresholds[0]}` //bottom
            return `${thresholds[thresholds.length - i - 1]} - < ${thresholds[thresholds.length - i]}  ` //in-between
        }
        const labelFormatter = out.labelFormatter || defaultLabeller

        let baseY = out.boxPadding
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding

        // for each class
        for (let i = 0; i < map.numberOfClasses_; i++) {
            let y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? map.numberOfClasses() - i - 1 : i
            const fillColor = map.classToFillStyle()(ecl, map.numberOfClasses_)
            const itemContainer = container.append('g').attr('class', 'em-legend-item')

            // shift legend items down after point of divergence if applicable
            if (out.pointOfDivergenceLabel && i >= out.pointOfDivergence) y += out.pointOfDivergencePadding

            // Append rectangle
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).raise()
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append labels
            itemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                .attr('y', y + out.shapeHeight / 2)
                .attr('dy', '0.35em')
                .text(out.labels ? out.labels[i] : labelFormatter(map.classifier().invertExtent(ecl)[out.ascending ? 0 : 1], i))
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const noDataItemContainer = container.append('g').attr('class', 'em-legend-item')
            let y = baseY + map.numberOfClasses() * out.shapeHeight + out.boxPadding
            //if (out.pointOfDivergence) y += out.pointOfDivergencePadding // shift legend items down after point of divergence
            noDataItemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).raise()
                    highlightRegions(map, 'nd')
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(map)
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, unhighlightRegions)
                    }
                })

            noDataItemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dy', '0.35em')
                .text(out.noDataText)
        }
    }

    function drawDivergingLine(y) {
        const container = out.lgg.append('g').attr('class', 'em-legend-divergence-container')
        const markerHeight = 6
        const x = out.boxPadding
        if (out.labelType == 'ranges') y = y + out.pointOfDivergencePadding / 2 // move to the middle of the space between legend item
        let maxLabelLength = out.lgg
            .selectAll('.em-legend-label')
            .nodes()
            .reduce((max, node) => Math.max(max, node.getBBox().width), 0)
        const lineLength = out.divergingLineLength || maxLabelLength + out.boxPadding + out.shapeWidth + 10 // + padding

        // Draw the horizontal divergence line
        container
            .append('line')
            .attr('x1', x)
            .attr('y1', y)
            .attr('x2', x + lineLength)
            .attr('y2', y)
            .attr('class', 'em-legend-diverging-line')

        // divergence line with up and down arrows
        const labels = out.pointOfDivergenceLabel.split('|')
        if (labels.length > 1) {
            const directionLineLength = out.divergingArrowLength || 30
            const directionLineX = x + lineLength
            // Add arrowhead marker definition
            const defs = container.append('defs')
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('markerWidth', markerHeight)
                .attr('markerHeight', markerHeight)
                .attr('refX', 0)
                .attr('refY', markerHeight / 2)
                .attr('orient', 'auto')
                .append('polygon')
                .attr('points', `0 0, ${markerHeight} ${markerHeight / 2}, 0 ${markerHeight}`)
                .attr('fill', 'black')

            // Upward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y - directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Downward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y + directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Labels for upward and downward lines
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y - directionLineLength + 10)
                .attr('dy', '0.35em')
                .text(labels[0])

            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y + directionLineLength - 10)
                .attr('dy', '0.35em')
                .text(labels[1])
        } else {
            // just the single label
            container
                .append('text')
                .attr('class', 'em-legend-diverging-label em-legend-label')
                .attr('x', x + lineLength + 5)
                .attr('y', y)
                .attr('dy', '0.35em')
                .text(out.pointOfDivergenceLabel)
        }

        //move threshold label out of the way of the line
        if (out.labelType == 'thresholds') {
            if (labels.length > 1) {
                // move it to end of line
                out.lgg.selectAll('.em-legend-label-divergence').attr('x', x + lineLength + 10)
                // Append tick line
                // container
                //     .append('line')
                //     .attr('class', 'em-legend-tick')
                //     .attr('x1', x + lineLength)
                //     .attr('y1', y)
                //     .attr('x2', x + lineLength + 5)
                //     .attr('y2', y)
            } else {
                //remove it so it doesnt clash with pointOfDivergenceLabel
                out.lgg.selectAll('.em-legend-label-divergence').remove()
            }
        }
    }

    function createHistogramLegend() {
        const thresholds = getThresholds()
        const colors = getColors()
        const data = getData()
        const orientation = out.histogram.orientation || 'horizontal'
        const showCounts = out.histogram.showCounts
        const showPercentages = out.histogram.showPercentages
        const labelRotation = out.histogram.labelRotation || 0
        const labelFormat = out.histogram.labelFormat
        const labelFormatter = out.histogram.labelFormatter

        let counts = new Array(map.numberOfClasses_).fill(0)
        data.forEach((value) => {
            const classIndex = map.classifier()(value)
            if (typeof classIndex === 'number' && classIndex >= 0 && classIndex < counts.length) {
                counts[classIndex]++
            }
        })

        const reversedCounts = counts.slice().reverse()
        const total = counts.reduce((sum, d) => sum + d, 0)
        const reversedPercentages = reversedCounts.map((d) => (total > 0 ? (d / total) * 100 : 0))

        const lgg = out.lgg
        const baseY = out.boxPadding + (out.title ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 38 : 30)
        const svgWidth = 300
        const svgHeight = 300
        const barGroup = lgg.append('g').attr('class', 'em-legend-histogram').attr('transform', `translate(0, ${baseY})`)

        if (orientation === 'vertical') {
            drawVerticalHistogram(barGroup)
        } else {
            drawHorizontalHistogram(barGroup)
        }

        function drawVerticalHistogram(barGroup) {
            const margin = { top: 20, right: 60, bottom: 40, left: 150 }
            const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__["default"])()
                .domain(reversedCounts.map((_, i) => i))
                .range([margin.top, svgHeight - margin.bottom])
                .padding(0.1)
            const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])()
                .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(reversedCounts)])
                .nice()
                .range([margin.left, svgWidth - margin.right])

            // Bars
            barGroup
                .selectAll('rect')
                .data(reversedCounts)
                .join('rect')
                .attr('class', 'em-legend-histogram-bar')
                .attr('y', (_, i) => yScale(i))
                .attr('x', margin.left)
                .attr('height', yScale.bandwidth())
                .attr('width', (d) => xScale(d) - margin.left)
                .attr('fill', (_, i) => colors[colors.length - i - 1])
                .attr('ecl', (_, i) => i)
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)

            // Bar labels
            if (showCounts || showPercentages) {
                barGroup
                    .selectAll('text.em-histogram-label')
                    .data(reversedCounts)
                    .join('text')
                    .attr('class', 'em-legend-label em-histogram-label')
                    .attr('x', (d) => xScale(d) + 5)
                    .attr('y', (_, i) => yScale(i) + yScale.bandwidth() / 2)
                    .attr('alignment-baseline', 'middle')
                    .text((_, i) => {
                        if (typeof labelFormatter === 'function') {
                            return labelFormatter(reversedPercentages[i], reversedCounts[i], i)
                        }
                        return showPercentages ? `${reversedPercentages[i].toFixed(1)}%` : reversedCounts[i]
                    })
            }

            // Axis
            barGroup
                .append('g')
                .attr('id', 'em-legend-histogram-y-axis')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(
                    (0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisLeft)(yScale)
                        .tickSizeOuter(0)
                        .tickSize(0)
                        .tickFormat((_, i) => formatTickLabel(i))
                )
        }

        function drawHorizontalHistogram(barGroup) {
            const margin = { top: 20, right: 60, bottom: 40, left: 10 }
            const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__["default"])()
                .domain(reversedCounts.map((_, i) => i))
                .range([margin.left, svgWidth - margin.right])
                .padding(0.1)

            const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])()
                .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(reversedCounts)])
                .nice()
                .range([svgHeight - margin.bottom, margin.top])

            // Bars
            barGroup
                .selectAll('rect')
                .data(reversedCounts)
                .join('rect')
                .attr('class', 'em-legend-histogram-bar')
                .attr('x', (_, i) => xScale(i))
                .attr('y', (d) => yScale(d))
                .attr('width', xScale.bandwidth())
                .attr('height', (d) => svgHeight - margin.bottom - yScale(d))
                .attr('fill', (_, i) => colors[colors.length - i - 1])
                .attr('ecl', (_, i) => i)
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)

            // Bar labels (centered)
            if (showCounts || showPercentages) {
                barGroup
                    .selectAll('text.em-histogram-label')
                    .data(reversedCounts)
                    .join('text')
                    .attr('class', 'em-legend-label em-histogram-label')
                    .attr('x', (_, i) => xScale(i) + xScale.bandwidth() / 2)
                    .attr('y', (d) => yScale(d) - 5)
                    .attr('text-anchor', 'middle')
                    .text((_, i) => {
                        if (typeof labelFormatter === 'function') {
                            return labelFormatter(reversedPercentages[i], reversedCounts[i], i)
                        }
                        return showPercentages ? `${reversedPercentages[i].toFixed(1)}%` : reversedCounts[i]
                    })
            }

            // Axis (only for labelType === 'thresholds')
            const axisGroup = barGroup
                .append('g')
                .attr('id', 'em-legend-histogram-x-axis')
                .attr('transform', `translate(0, ${svgHeight - margin.bottom})`)

            if (out.labelType === 'thresholds') {
                const positions = []

                for (let i = 0; i < thresholds.length; i++) {
                    const bandIndex = thresholds.length - i - 1
                    const x = xScale(bandIndex)
                    if (x !== undefined) positions.push(x + xScale.bandwidth())
                }

                const boundaryScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])().domain([0, svgWidth]).range([0, svgWidth])

                axisGroup.call(
                    (0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisBottom)(boundaryScale)
                        .tickValues(positions)
                        .tickFormat((_, i) => (labelFormat ? labelFormat(thresholds[i], i) : thresholds[i]))
                        .tickSize(0)
                        .tickSizeOuter(0)
                )
            } else {
                axisGroup.call((0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisBottom)(xScale).tickSizeOuter(0).tickSize(0))
            }

            axisGroup
                .selectAll('text')
                .attr('class', 'em-legend-label em-tick-label')
                .attr('text-anchor', 'end')
                .attr('transform', `rotate(-${labelRotation})`)
        }

        function formatTickLabel(i) {
            if (out.labelType === 'thresholds') {
                const breakIndex = thresholds.length - i - 1
                return thresholds[breakIndex] ?? ''
            } else {
                if (i === 0) return `> ${thresholds[thresholds.length - 1]}`
                if (i === thresholds.length) return `< ${thresholds[0]}`
                return `${thresholds[thresholds.length - i - 1]} - < ${thresholds[thresholds.length - i]}`
            }
        }

        function handleMouseOver(_, i) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).style('stroke', 'black')
            const ecl = sel.attr('ecl')
            const reversedIndex = colors.length - 1 - parseInt(ecl, 10)
            highlightRegions(map, reversedIndex)
            if (map.insetTemplates_) {
                (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, highlightRegions, ecl)
            }
        }

        function handleMouseOut(_, i) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).style('stroke', 'none')
            unhighlightRegions(map)
            if (map.insetTemplates_) {
                (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, unhighlightRegions)
            }
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill___'))
        })
    }

    //deprecated
    out.labelDecNb = (v) => (console.warn('labelDecNb is now DEPRECATED. Please use decimals instead.'), out)

    return out
}


/***/ }),

/***/ "./src/legend/legend-flow.js":
/*!***********************************!*\
  !*** ./src/legend/legend-flow.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");





//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const lgg = out.lgg

        // update legend parameters if necessary
        if (m.legend_)
            for (let key in m.legend_) {
                if (key == 'colorLegend' || key == 'sizeLegend') {
                    for (let p in out[key]) {
                        //override each property in size and color legend m.legend_
                        if (m.legend_[key][p] !== undefined) {
                            out[key][p] = m.legend_[key][p]
                        }
                    }
                } else {
                    out[key] = m.legend_[key]
                }
            }

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        buildFlowLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different flow symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildFlowLegend(m) {}

    return out
}


/***/ }),

/***/ "./src/legend/legend-pattern-fill.js":
/*!*******************************************!*\
  !*** ./src/legend/legend-pattern-fill.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendPatternFillLegend: () => (/* binding */ appendPatternFillLegend)
/* harmony export */ });
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



function appendPatternFillLegend(map, container, options = {}) {
    const {
        shapeWidth = 25,
        shapeHeight = 20,
        labelOffset = 3,
        boxPadding = 5,
        offsetY = 0, // << new
    } = options

    if (!map.patternFill_) return

    map.patternFill_.forEach((cfg, index) => {
        if (!cfg.legendLabel) return // skip if no label

        const y = offsetY + index * (shapeHeight + boxPadding)

        const item = container.append('g').attr('class', 'em-legend-item pattern-fill-legend')

        const patternColor = cfg.color || '#000' // fallback to black if no color provided
        const isWhitePattern = patternColor.toLowerCase() === '#fff' || patternColor.toLowerCase() === 'white'

        // Add background if pattern is white
        if (isWhitePattern) {
            item.append('rect').attr('x', boxPadding).attr('y', y).attr('width', shapeWidth).attr('height', shapeHeight).attr('fill', '#ddd') // light gray background
        }

        // Add pattern overlay
        item.append('rect')
            .attr('x', boxPadding)
            .attr('y', y)
            .attr('width', shapeWidth)
            .attr('height', shapeHeight)
            .attr('fill', `url(#${cfg.patternId || cfg.pattern})`)

        // Add label
        item.append('text')
            .attr('class', 'em-legend-label')
            .attr('x', boxPadding + shapeWidth + labelOffset)
            .attr('y', y + shapeHeight / 2)
            .attr('dominant-baseline', 'middle')
            .attr('dy', '0.35em') // ~vertical centering
            .text(cfg.legendLabel)
    })
}


/***/ }),

/***/ "./src/legend/legend-piecharts.js":
/*!****************************************!*\
  !*** ./src/legend/legend-piecharts.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");






/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //spacing between color & size legends (if applicable)
    out.legendSpacing = 15

    //size legend config (legend illustrating the values of different pie sizes)
    out.sizeLegend = {
        title: null,
        titlePadding: 30, //padding between title and body
        values: null,
    }

    //colour legend config (legend illustrating the values of different pie colours)
    out.colorLegend = {
        title: null,
        labelOffset: 5, //the distance between the legend box elements to the corresponding text label
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 5, //the distance between consecutive legend box elements
        noData: true, //show no data
        noDataText: 'No data', //no data label text
    }

    out._sizeLegendHeight = 0

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const map = out.map
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        // legend for sizes
        if (map.sizeClassifier_) {
            buildSizeLegend()
        }

        // legend for ps color values
        buildColorLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different pie chart sizes
     *
     * @param {*} m map
     * @param {*} lgg parent legend object from core/legend.js
     * @param {*} config size legend config object (sizeLegend object specified as property of legend() config object)
     */
    function buildSizeLegend() {
        const map = out.map
        const config = out.sizeLegend
        const container = out.lgg.append('g').attr('class', 'em-pie-size-legend')

        const domain = map.sizeClassifier_.domain()

        // Assign default circle radii if none specified by user
        if (!config.values) {
            config.values = [Math.floor(domain[1]), Math.floor(domain[0])]
        }

        // Calculate the maximum circle size to be displayed in the legend
        let maxSize = map.sizeClassifier_((0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(config.values))

        // Add the title to the container if available
        if (!config.title && out.title) config.title = out.title // Allow root legend title
        let titleHeight = 0 // This will be adjusted based on whether the title exists
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Position the title at the left edge
                .attr('y', out.boxPadding + out.titleFontSize) // Title at top, within padding
                .text(config.title)

            // Adjust title height (using the title font size as a proxy)
            titleHeight = out.titleFontSize + out.boxPadding + config.titlePadding
        }

        // Now position the circles **below** the title
        let y = titleHeight + out.boxPadding + maxSize * 2 // Position circles after title height

        // Append the legend circles
        const legendItems = container
            .selectAll('g')
            .data(config.values)
            .join('g')
            .attr('class', 'em-pie-size-legend-item')
            .attr('transform', `translate(${maxSize + out.boxPadding}, ${y})`) // Dynamically move the circles down

        // Append circles to each group
        legendItems
            .append('circle')
            .attr('class', 'em-pie-size-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -map.sizeClassifier_(d)) // Position circles based on their size
            .attr('r', map.sizeClassifier_) // Radius is calculated from size classifier

        // Append labels to each group
        legendItems
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('y', (d) => -2 * map.sizeClassifier_(d) - out.labelFontSize - 2) // Position labels relative to circles
            .attr('x', 30) // Set the x-position for the labels
            .attr('dy', '1.2em')
            .attr('xml:space', 'preserve')
            .text((d) => d.toLocaleString('en').replace(/,/gi, ' ')) // Format the label text

        // Add lines pointing to the top of the corresponding circle
        legendItems
            .append('line')
            .attr('class', 'em-pie-size-legend-line')
            .attr('x1', 2)
            .attr('x2', 30)
            .attr('y1', (d) => -2 * map.sizeClassifier_(d)) // Position lines relative to circles
            .attr('y2', (d) => -2 * map.sizeClassifier_(d)) // Same position for the y2 to make a horizontal line

        // Save the height value for positioning the color legend (if needed)
        out._sizeLegendHeight = y
        return out
    }

    /**
     * Builds a legend illustrating the statistical values of the pie charts' different colours
     *
     */
    function buildColorLegend() {
        const map = out.map
        const config = out.colorLegend
        //container
        const container = out.lgg.append('g').attr('class', 'em-pie-color-legend')

        //draw title
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out._sizeLegendHeight + out.legendSpacing + out.boxPadding + out.titleFontSize)
                .text(config.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = map.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)
            //the color
            const col = map.catColors()[code] || 'lightgray'

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, code)
                    }
                })

            //label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .attr('dominant-baseline', 'middle')
                .text(map.catLabels()[code] || code)

            i++
        }

        //'no data' legend box
        if (config.noData) {
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', map.noDataFillStyle())
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                    }
                })

            //'no data' label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .text(config.noDataText)
        }
    }

    // Highlight selected segments on mouseover
    function highlightRegions(map, code) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Set all segments to white
        allSegments.style('fill', 'white')

        // Highlight only the selected segments by restoring their original color
        const selectedSegments = allSegments.filter("path[code='" + code + "']")
        selectedSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected segments
        })
    }

    // Reset all segments to their original colors on mouseout
    function unhighlightRegions(map) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Restore each segments's original color from the fill___ attribute
        allSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-proportional-symbols.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-proportional-symbols.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");









//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_3__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    out.ascending = false //the order of the legend elements. Set to false to invert.
    out.legendSpacing = 35 //spacing between color & size legends (if applicable)
    out.labelFontSize = 12 //the font size of the legend labels

    out.noDataShapeWidth = 25
    out.noDataShapeHeight = 20

    //size legend config (legend illustrating the values of different symbol sizes)
    out.sizeLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 5, //padding between title and legend body
        values: undefined, //manually define raw data values
        cellNb: 3, //number of elements in the legend
        shapePadding: 5, //the y distance between consecutive legend shape elements
        shapeOffset: { x: 0, y: 0 },
        shapeFill: 'white',
        shapeStroke: null,
        labelOffset: { x: 10, y: 0 }, //the distance between the legend box elements to the corresponding text label
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined,
        _totalBarsHeight: 0,
        _totalD3SymbolsHeight: 0,
        noData: false, // show no data legend item
        noDataText: 'No data', //no data text label
    }

    // color legend config (legend illustrating the data-driven colour classes)
    out.colorLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 10, //padding between title and legend body
        marginTop: 30, // margin top (distance between color and size legend)
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 1, //the distance between consecutive legend shape elements in the color legend
        labelOffset: { x: 5, y: 0 }, //distance (x) between label text and its corresponding shape element
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined, // user-defined d3 format function
        labelType: 'thresholds', // type of labels to show: thresholds or ranges
        labels: null, // user-defined labels for each class
        noData: true, //show no data
        noDataText: 'No data', //no data text label
        sepLineLength: 24, // //the separation line length
        sepLineStroke: 'black', //the separation line color
        sepLineStrokeWidth: 1, //the separation line width
        tickLength: 5, // threshold ticks length in px
    }

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const m = out.map
            const lgg = out.lgg

            //remove previous content
            lgg.selectAll('*').remove()

            //draw legend background box
            out.makeBackgroundBox()

            // reset height counters
            out.sizeLegend._totalBarsHeight = 0
            out.sizeLegend._totalD3SymbolsHeight = 0

            // legend for size
            out._sizeLegendNode = lgg.append('g').attr('class', 'size-legend-container')
            if (m.classifierSize_) {
                buildSizeLegend(m, out.sizeLegend)
            }
            // legend for ps color values
            out._colorLegendNode = lgg.append('g').attr('class', 'color-legend-container')

            // position it below size legend
            if (out._sizeLegendNode) {
                out._colorLegendNode.attr('transform', `translate(0,${out._sizeLegendNode.node().getBBox().height})`)
            }

            if (m.classifierColor_ && out.colorLegend) {
                buildColorLegend(m, out.colorLegend)
            }

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    /**
     * Builds a legend which illustrates the statistical values of different symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildSizeLegend(m) {
        if (!m.psCustomSVG_ && m.psShape_ == 'circle') {
            buildCircleLegend(m, out.sizeLegend)
            if (out.sizeLegend.noData) {
                let y = out._sizeLegendNode.node().getBBox().height + 25
                let x = out.boxPadding
                let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)
                buildNoDataLegend(container, out.sizeLegend.noDataText)
            }
            return
        } else if (m.psShape_ == 'spike') {
            buildSpikeLegend(m, out.sizeLegend)
            return
        }

        //define format for labels
        let labelFormatter = out.sizeLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        //draw title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let domain = m.classifierSize_.domain()
        let maxVal = domain[1] //maximum value of dataset (used for first or last symbol by default)

        // if user defines values for legend manually
        if (out.sizeLegend.values) {
            out.sizeLegend.cellNb = out.sizeLegend.values.length
        }

        //draw legend elements for classes: symbol + label

        // for custom paths
        m.customSymbols = { nodeHeights: 0 } // save some custom settings for buildCustomSVGItem

        for (let i = 1; i < out.sizeLegend.cellNb + 1; i++) {
            //define class number
            const c = out.ascending ? out.sizeLegend.cellNb - i + 1 : i
            //define raw value
            let val = out.sizeLegend.values ? out.sizeLegend.values[c - 1] : maxVal / c
            //calculate shape size
            let symbolSize = m.classifierSize_(val)

            if (m.psShape_ == 'bar') {
                buildBarsItem(map, val, symbolSize, i, labelFormatter)
            } else if (m.psShape_ == 'custom' || m.psCustomSVG_) {
                buildCustomSVGItem(map, val, symbolSize, i, labelFormatter)
            } else {
                buildD3SymbolItem(map, val, symbolSize, i, labelFormatter)
            }
        }

        if (out.sizeLegend.noData) {
            let y = out._sizeLegendNode.node().getBBox().height
            if (out.colorLegend) {
                y += out.colorLegend.shapeHeight + 5
            }
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    function buildSpikeLegend(map, sizeLegendConfig) {
        const spike = (length, width = map.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`

        let maxSize = map.classifierSize_(map.classifierSize_.domain()[1])

        // Determine values for the legend
        let legendValues = out.sizeLegend.values || map.classifierSize_.ticks(4).slice(1) // Use user-defined values or default ticks

        const fontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-label') // Adjust font size
        const labelSpacing = fontSize - 2 // Ensure labels are just below the spikes

        const legend = out._sizeLegendNode
            .append('g')
            .attr('id', 'em-spike-legend')
            .attr('transform', `translate(${out.boxPadding + 5},0)`)
            .attr('fill', 'black')
            .attr('text-anchor', 'middle')
            .style('font-size', `${fontSize}px`)
            .selectAll()
            .data(legendValues) // Now uses user-defined values if provided
            .join('g')
            .attr('transform', (d, i) => `translate(${40 * i + out.boxPadding},${maxSize + 5})`) // Increase spacing

        // Append spikes
        legend
            .append('path')
            .attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)
            .attr('d', (d) => spike(map.classifierSize_(d))) // Correctly maps values to spike size

        // Append labels directly below each spike
        legend
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', labelSpacing) // Ensure text is right below spikes
            .text((d) => map.classifierSize_.tickFormat(4, 's')(d))

        // 🔹 Add "No Data" item with more spacing
        if (out.sizeLegend.noData) {
            let lastLabelY = maxSize + labelSpacing + fontSize + 5 // Adjust position below the labels
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${lastLabelY})`)
            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    //'no data' legend box
    function buildNoDataLegend(container, noDataText) {
        let m = out.map

        //append symbol & style
        container
            .append('rect')
            .attr('class', 'em-legend-rect')
            .style('fill', m.noDataFillStyle())
            .attr('width', out.colorLegend ? out.colorLegend.shapeWidth : out.noDataShapeWidth)
            .attr('height', out.colorLegend ? out.colorLegend.shapeHeight : out.noDataShapeHeight)
            .on('mouseover', function () {
                highlightRegions(out.map, 'nd')
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                }
            })
            .on('mouseout', function () {
                unhighlightRegions(out.map)
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                }
            })

        //'no data' label
        container
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', out.colorLegend ? out.colorLegend.shapeWidth + out.colorLegend.labelOffset.x : out.noDataShapeWidth + 5)
            .attr('y', out.colorLegend ? out.colorLegend.shapeHeight / 2 : out.noDataShapeHeight / 2)
            .text(noDataText)
    }

    function highlightRegions(map, ecl) {
        // TODO: change this to estat logic of making all other classes transparent?
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', map.hoverColor())
        sel.attr('fill___', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).style('fill')
        })
    }

    function unhighlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill___')
        })
    }

    /**
     * @description builds a size legend item for proportional D3 shapes (e.g. square, triangle, star)
     * @param {*} m map instance
     * @param {number} symbolSize the size of the symbol item
     */
    function buildD3SymbolItem(m, value, symbolSize, index, labelFormatter) {
        let symbolHeight = out.map.psShape_ == 'triangle' || out.map.psShape_ == 'diamond' ? symbolSize : symbolSize / 2
        if (out.sizeLegend._totalD3SymbolsHeight == 0) out.sizeLegend._totalD3SymbolsHeight += symbolHeight + out.boxPadding //add first item height to y
        let maxSize = m.classifierSize_(m.classifierSize_.domain()[1])
        // x and y position of item in legend
        let x = maxSize
        let y =
            (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) +
            out.sizeLegend._totalD3SymbolsHeight +
            (out.sizeLegend.shapePadding * index - 1)

        out.sizeLegend._totalD3SymbolsHeight += symbolSize

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw D3 symbol
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()
        itemContainer
            .append('g')
            // .attr('transform', `translate(${x},${y})`)
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = maxSize / 2 + out.sizeLegend.labelOffset.x + out.boxPadding

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', 0)
            .text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} value
     * @param {*} symbolSize
     * @param {*} index
     * @param {*} labelFormatter
     */
    function buildCustomSVGItem(m, value, symbolSize, index, labelFormatter) {
        let x = out.boxPadding //set X offset
        let y

        //first item
        if (!m.customSymbols.prevSymb) {
            y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20
            m.customSymbols.initialTranslateY = y
            m.customSymbols.prevScale = symbolSize
        }

        //following items
        if (m.customSymbols.prevSymb) {
            let prevNode = m.customSymbols.prevSymb.node()
            let bbox = prevNode.getBBox()
            m.customSymbols.nodeHeights = m.customSymbols.nodeHeights + bbox.height * m.customSymbols.prevScale
            y = m.customSymbols.initialTranslateY + m.customSymbols.nodeHeights + out.sizeLegend.shapePadding * (index - 1)
            m.customSymbols.prevScale = symbolSize
        }

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw standard symbol
        m.customSymbols.prevSymb = itemContainer
            .append('g')
            .attr('class', 'em-size-legend-symbol')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('g')
            .html(out.map.psCustomSVG_)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = x + m.classifierSize_(m.classifierSize_.domain()[0]) + out.sizeLegend.labelOffset.x
        let labelY = out.sizeLegend.shapeOffset.y / 2 + 1 //y + out.sizeLegend.labelOffset.y

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', labelY)
            .text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} symbolSize
     */
    function buildBarsItem(m, value, symbolSize, index, labelFormatter) {
        // for vertical bars we dont use a dynamic X offset because all bars have the same width
        let x = out.boxPadding
        //we also dont need the y offset
        let y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + out.sizeLegend._totalBarsHeight + 10

        out.sizeLegend._totalBarsHeight += symbolSize + 10

        //set shape size and define 'd' attribute
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw bar symbol
        itemContainer
            .append('g')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })
        //label position
        let labelX = x + out.map.psBarWidth_ + out.sizeLegend.labelOffset.x
        let labelY = symbolSize / 2 + out.sizeLegend.labelOffset.y

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', labelY)
            .text(labelFormatter(value))
    }

    /**
     * @description builds a nested circle legend for proportional circles
     * @param {*} m map
     */
    function buildCircleLegend(m) {
        //assign default circle radiuses if none specified by user
        let domain = m.classifierSize_.domain()
        if (!out.sizeLegend.values) {
            // default legend values
            out._sizeLegendValues = [Math.floor(domain[1]), Math.floor(domain[1] / 2), Math.floor(domain[0])]
        } else {
            // user defined legend values
            out._sizeLegendValues = out.sizeLegend.values
        }

        //draw title
        if (!out.sizeLegend.title && out.title) out.sizeLegend.title = out.title //if unspecified, set size legend title as root legend title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let maxRadius = m.classifierSize_((0,d3_array__WEBPACK_IMPORTED_MODULE_5__["default"])(out._sizeLegendValues)) //maximum circle radius to be shown in legend
        let x = out.boxPadding + maxRadius
        let y = out.boxPadding + maxRadius * 2 + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20

        let itemContainer = out._sizeLegendNode
            .append('g')
            .attr('transform', `translate(${x},${y})`)
            .attr('class', 'circle-legend')
            .attr('text-anchor', 'right')
            .style('fill', 'black')
            .selectAll('g')
            .data(out._sizeLegendValues.filter((d) => m.classifierSize_(d))) // Filter data before binding
            .join('g')
            .attr('class', 'em-legend-item')

        //circles
        itemContainer
            .append('circle')
            .attr('class', 'em-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -m.classifierSize_(d))
            .attr('r', m.classifierSize_)

        //labels
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('y', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x', maxRadius + 5)
            .text((d) => {
                return d.toLocaleString('en').replace(/,/gi, ' ')
            })
        //line pointing to top of corresponding circle:
        itemContainer
            .append('line')
            .style('stroke-dasharray', 2)
            .style('stroke', 'grey')
            .attr('x1', 2)
            .attr('y1', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x2', maxRadius + 5)
            .attr('y2', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })

        return out
    }

    /**
     * Builds a legend illustrating the statistical values of different symbol colours
     *
     * @param {*} m map
     */
    function buildColorLegend(m) {
        if (out.colorLegend.labelType === 'ranges') {
            buildColorRangesLegend(m)
        } else {
            buildColorThresholdsLegend(m)
        }
    }

    function getColorThresholds() {
        const map = out.map
        const thresholds =
            map.psThresholds_.length > 1
                ? map.psThresholds_
                : Array.from({ length: map.psClasses_ })
                      .map((_, index) => {
                          return map.classifierColor_.invertExtent(index)[out.ascending ? 0 : 1]
                      })
                      .slice(1) // Remove the first entry and return the rest as an array
        return thresholds
    }

    function buildColorRangesLegend(m) {
        const f = out.colorLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        const thresholds = getColorThresholds()
        const numberOfClasses = m.psClasses_

        //title
        if (out.colorLegend.title) {
            out._colorLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.titleFontSize + out.colorLegend.marginTop)
                .text(out.colorLegend.title)
        }

        const x = out.boxPadding

        for (let i = 0; i < numberOfClasses; i++) {
            let y =
                out.titleFontSize +
                out.colorLegend.titlePadding +
                out.colorLegend.marginTop +
                i * (out.colorLegend.shapeHeight + out.colorLegend.shapePadding)

            const ecl = out.ascending ? i : numberOfClasses - i - 1

            const itemContainer = out._colorLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-legend-item')

            // Rectangle
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .style('fill', m.psClassToFillStyle()(ecl, numberOfClasses))
                .attr('width', out.colorLegend.shapeWidth)
                .attr('height', out.colorLegend.shapeHeight)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            // Label
            itemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('dy', '0.35em') // ~vertical centering
                .attr('x', out.colorLegend.shapeWidth + out.colorLegend.labelOffset.x)
                .attr('y', out.colorLegend.shapeHeight / 2)
                .text(() => {
                    if (out.colorLegend.labels) return out.colorLegend.labels[i] // user-defined labels
                    if (i === 0) return `> ${f(thresholds[thresholds.length - 1])}`
                    if (i === thresholds.length) return `< ${f(thresholds[0])}`
                    return `${f(thresholds[thresholds.length - i - 1])} - < ${f(thresholds[thresholds.length - i])}`
                })
        }

        // Optionally add no-data
        if (out.colorLegend.noData) {
            let y = out.titleFontSize + out.colorLegend.marginTop + numberOfClasses * out.colorLegend.shapeHeight + 20 // add 20 to separate it from the rest
            let container = out._colorLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.colorLegend.noDataText)
        }
    }

    function buildColorThresholdsLegend(m) {
        //define format for labels
        const labelFormatter = out.colorLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator

        //title
        if (out.colorLegend.title) {
            out._colorLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.titleFontSize + out.colorLegend.marginTop)
                .text(out.colorLegend.title)
        }

        // x position of color legend cells
        let x = out.boxPadding

        //draw legend elements for classes: rectangle + label
        let numberOfClasses = m.psClasses_

        for (let i = 0; i < numberOfClasses; i++) {
            //the vertical position of the legend element
            let y = out.titleFontSize + out.colorLegend.titlePadding + out.colorLegend.marginTop + i * out.colorLegend.shapeHeight // account for title + margin

            //the class number, depending on order
            const ecl = out.ascending ? i : numberOfClasses - i - 1

            let itemContainer = out._colorLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-legend-item')

            //append symbol & style
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .style('fill', m.psClassToFillStyle()(ecl, numberOfClasses))
                .attr('width', out.colorLegend.shapeWidth)
                .attr('height', out.colorLegend.shapeHeight)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            //separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', 0 + out.colorLegend.sepLineLength)
                    .attr('y2', 0)
            }

            // Append tick line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.colorLegend.shapeWidth)
                    .attr('y1', 0)
                    .attr('x2', out.colorLegend.sepLineLength + out.colorLegend.tickLength)
                    .attr('y2', 0)
            }

            //label
            if (i < numberOfClasses - 1) {
                itemContainer
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('dy', '0.35em') // ~vertical centering
                    .attr('x', out.colorLegend.sepLineLength + out.colorLegend.tickLength + out.colorLegend.labelOffset.x)
                    .attr('y', out.colorLegend.shapeHeight)
                    .text(
                        out.colorLegend.labels
                            ? out.colorLegend.labels[i]
                            : labelFormatter(m.classifierColor_.invertExtent(out.ascending ? ecl + 1 : ecl - 1)[out.ascending ? 0 : 1])
                    )
            }
        }

        //'no data' legend box
        if (out.colorLegend.noData) {
            let y = out.titleFontSize + out.colorLegend.marginTop + numberOfClasses * out.colorLegend.shapeHeight + 20 // add 20 to separate it from the rest
            let container = out._colorLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.colorLegend.noDataText)
        }
    }

    /**
     * @description returns the d3.symbol object chosen by the user
     * @return {d3.shape || SVG}
     */
    function getShape() {
        let shape
        if (out.map.psCustomSVG_) {
            shape = out.map.psCustomSVG_
        } else if (out.map.psCustomShape_) {
            shape = out.map.psCustomShape_
        } else if (out.map.psShape_ == 'bar') {
            //for rectangles, we use a custom d3 symbol
            let drawRectangle = (context, size) => {
                let height = Math.sqrt(size)
                context.moveTo(0, 0)
                context.lineTo(0, height)
                context.lineTo(out.map.psBarWidth_, height)
                context.lineTo(out.map.psBarWidth_, 0)
                context.lineTo(0, 0)
                context.closePath()
            }
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().type({ draw: drawRectangle })
        } else {
            let symbolType = _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary[out.map.psShape_] || _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary['circle']
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().type(symbolType)
        }
        return shape
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Set all symbols to white
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.childNodes[0])
            symbol.style('fill', 'white')
        })

        // Highlight only the selected regions by restoring their original color
        const selectedSymbols = allSymbols.filter("[ecl='" + ecl + "']")
        selectedSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-stripe-composition.js":
/*!*************************************************!*\
  !*** ./src/legend/legend-stripe-composition.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const svgMap = m.svg()
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        //draw title
        if (out.title) {
            lgg.append('text')
                .attr('class', 'em-legnd-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = m.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //the color
            const col = m.catColors()[code] || 'lightgray'

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this)
                    sel.raise()
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            //label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(m.catLabels()[code] || code)
                .on('mouseover', function () {
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const col = m.catColors()[code] || 'lightgray'
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', col)
                })

            i++
        }

        //'no data' legend box
        if (out.noData) {
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', m.noDataFillStyle())
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.noDataFillStyle())
                })

            //'no data' label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(out.noDataText)
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                })
        }

        //set legend box dimensions
        out.setBoxDimension()
    }

    function highlightRegions(map, code) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Save original colors if not already stored
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            if (!el.attr('data-original-fill')) {
                el.attr('data-original-fill', el.style('fill'));
            }
            el.style('fill', 'white'); // Set all regions to white
        });
    
        // Highlight only the selected regions by restoring their original color
        const selectedRegions = map.svg_.selectAll("pattern").selectAll("rect[code='" + code + "']");
        selectedRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            el.style('fill', el.attr('data-original-fill')); // Restore original fill
        });
    }
    
    function unhighlightRegions(map) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Restore each region's original color from the stored attribute
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            const originalFill = el.attr('data-original-fill');
            if (originalFill) {
                el.style('fill', originalFill);
            }
        });
    }
    
    return out
}


/***/ }),

/***/ "./src/legend/legend.js":
/*!******************************!*\
  !*** ./src/legend/legend.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



/**
 * A eurostat-map legend. This is an abstract method.
 */
const legend = function (map) {
    //build legend object
    const out = {}

    //link map to legend
    out.map = map

    //the SVG where to make the legend
    out.svgId = 'legend_' + Math.round(10e15 * Math.random())
    out.svg = undefined
    out.lgg = undefined

    //the legend element position, in case it is embeded within the map SVG
    out.x = undefined
    out.y = undefined

    //the legend box
    out.boxPadding = 7
    out.boxOpacity = 0.7

    //legend title
    out.title = ''
    // we now use CSS instead of inline styles
    out.titleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-title')
    // we now use CSS instead of inline styles
    out.labelFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-label')

    /** Build legend. */
    out.build = function () {
        //set SVG element and add main drawing group
        out.svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId)
        // clear previous legend(s)
        out.svg.selectAll('#em-legend-' + out.svgId).remove()
        // append new legend group
        out.lgg = out.svg
            .append('g')
            .attr('id', 'em-legend-' + out.svgId)
            .attr('class', 'em-legend')
    }

    /**
     * Update the legend element.
     * This is an abstract method to be defined for each specific legend.
     */
    out.update = function () {
        console.log('Legend update function not implemented')
        return out
    }

    out.updateContainer = function () {
        const map = out.map
        const container = out.lgg
        // Remove previous content
        container.selectAll('*').remove()

        //check if provided external svgId has changed
        const legendSVG = out.svg
        if (legendSVG.attr('id') !== map.legend_.svgId) {
            out.build() // sets new svg and lgg
        }
    }

    out.updateConfig = function () {
        const map = out.map
        // Update legend parameters if necessary
        if (map.legend_) {
            deepMergeExistingKeys(out, map.legend_)
        }

        //ps
        // // update legend parameters if necessary
        // if (m.legend_)
        //     for (let key in m.legend_) {
        //         if (key == 'colorLegend' || key == 'sizeLegend') {
        //             for (let p in out[key]) {
        //                 //override each property in size and color legend m.legend_
        //                 if (m.legend_[key][p] !== undefined) {
        //                     out[key][p] = m.legend_[key][p]
        //                 }
        //             }
        //         } else {
        //             out[key] = m.legend_[key]
        //         }
        //     }
    }

    //It performs a shallow copy — nested objects will be copied by reference, not duplicated.
    //It modifies the target object (out) in place.
    //Useful for merging objects or extending existing ones.
    function deepMergeExistingKeys(target, source, options = {}, seen = new WeakSet(), depth = 0) {
        const MAX_DEPTH = options.maxDepth || 100

        if (seen.has(target)) return target
        seen.add(target)

        if (depth > MAX_DEPTH) {
            console.warn(`Max recursion depth (${MAX_DEPTH}) reached.`)
            return target
        }

        for (const key in source) {
            if (source.hasOwnProperty(key) && target.hasOwnProperty(key)) {
                const sourceVal = source[key]
                const targetVal = target[key]

                // Handle functions: overwrite directly
                if (typeof sourceVal === 'function') {
                    target[key] = sourceVal

                    // Handle nested plain objects
                } else if (isPlainObject(sourceVal) && isPlainObject(targetVal)) {
                    deepMergeExistingKeys(targetVal, sourceVal, options, seen, depth + 1)

                    // Handle arrays: overwrite (or merge if option set)
                } else if (Array.isArray(sourceVal) && Array.isArray(targetVal)) {
                    target[key] = options.mergeArrays ? [...new Set([...targetVal, ...sourceVal])] : [...sourceVal]

                    // Handle Dates
                } else if (sourceVal instanceof Date) {
                    target[key] = new Date(sourceVal.getTime())

                    // Handle RegExp
                } else if (sourceVal instanceof RegExp) {
                    target[key] = new RegExp(sourceVal)

                    // Handle Map and Set
                } else if (sourceVal instanceof Map) {
                    target[key] = new Map(sourceVal)
                } else if (sourceVal instanceof Set) {
                    target[key] = new Set(sourceVal)

                    // Overwrite primitives and other types
                } else {
                    target[key] = sourceVal
                }
            }
        }

        return target
    }

    // Helper to check for plain objects
    function isPlainObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]'
    }

    /** Draw legend background box */
    out.makeBackgroundBox = function () {
        out.lgg.append('rect').attr('id', 'legendBR').attr('class', 'em-legend-background').style('opacity', out.boxOpacity)
    }

    /** Set legend box dimensions, ensuring it has suitable dimensions to fit to all legend graphic elements */
    out.setBoxDimension = function () {
        if (out.lgg.node()) {
            //get legend elements bounding box
            const bb = out.lgg.node().getBBox({ stroke: true })
            //apply to legend box dimensions
            const p = out.boxPadding
            out.svg
                .select('#legendBR')
                .attr('x', bb.x - p)
                .attr('y', bb.y - p)
                .attr('width', bb.width + 2 * p)
                .attr('height', bb.height + 2 * p)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-categorical.js":
/*!*****************************************!*\
  !*** ./src/maptypes/map-categorical.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-categorical */ "./src/legend/legend-categorical.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");








/**
 * Returns a categorical map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'ct')

    /** Fill style for each category/class. Ex.: { urb: "#fdb462", int: "#ffffb3", rur: "#ccebc5" } */
    out.classToFillStyle_ = undefined
    /** Text label for each category/class. Ex.: { "urb": "Urban", "int": "Intermediate", "rur": "Rural" } */
    out.classToText_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunCat

    //the classifier: a function which returns a class number from a stat value.
    out.classifier_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['classToFillStyle_', 'classToText_', 'noDataFillStyle_', 'tooltipText_', 'classifier_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['classToFillStyle', 'classToText', 'noDataFillStyle', 'tooltipText', 'classifier'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //get domain (unique values)
        const domain = out.statData().getUniqueValues()

        //get range [0,1,2,3,...,domain.length-1]
        const range = [...Array(domain.length).keys()]

        //make classifier
        //only use user-define classes
        const ctfs = out.classToFillStyle_ ? out.classToFillStyle() : undefined
        if (ctfs) {
            const categories = Object.keys(ctfs)
            out.classifier(
                (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])()
                    .domain(categories) // Only classify known categories
                    .range(categories.map((_, i) => i)) // Assign numerical classes
            )
        } else {
            // Use all unique values if no user-defined classes exist
            out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])().domain(domain).range(range))
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const sv = out.statData().get(rg.properties.id)
                if (!sv) return

                const v = sv.value
                if (v === ':') return 'nd' // No data

                const value = isNaN(v) ? v : +v // Convert numbers, keep strings as is

                // 🔹 Ensure only known values are classified
                const classifierDomain = out.classifier().domain()
                if (!classifierDomain.includes(value)) return // Skip unknown values

                return out.classifier()(value)
            })
        }

        let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        classifyRegions(map.svg().selectAll(selector))

        // Handle mixed NUTS level, separating NUTS level 0
        if (map.nutsLevel_ === 'mixed') {
            const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
            classifyRegions(nuts0Regions)
        }
    }

    //@override
    out.updateStyle = function () {
        //if no color specified, use some default colors
        if (!out.classToFillStyle()) {
            const ctfs = {}
            const dom = out.classifier().domain()
            for (let i = 0; i < dom.length; i++) ctfs[dom[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__["default"][i % 12]
            out.classToFillStyle(ctfs)
        }

        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)
        return out
    }

    function applyStyleToMap(map) {
        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__.applyPatternFill)(map, out.patternFill_)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .style('display', function (rg) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')
                return ecl || lvl === '0' ? 'block' : 'none'
            })
            .style('stroke', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const stroke = sel.style('stroke')
                return ecl && lvl !== '0' ? stroke || '#777' : null
            })
            .style('stroke-width', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const strokeWidth = sel.style('stroke-width')
                return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle_[out.classifier().domain()[ecl]]
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_[out.classifier().domain()[ecl]]
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle_[out.classifier().domain()[ecl]]
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        // Set up mouse events
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunCat = function (rg, map) {
    const buf = []
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + '</div>')
    }
    //get stat value
    const sv = map.statData().get(rg.properties.id)
    //case when no data available
    if (!sv || (sv.value != 0 && !sv.value)) {
        buf.push(map.noDataText_)
        return buf.join('')
    }
    const val = sv.value
    if (map.classToText_) {
        const lbl = map.classToText_[val]
        //display label and value
        buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${lbl ? lbl : val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
        return buf.join('')
    }
    //display just value
    buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-bivariate.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-choropleth-bivariate.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-bivariate */ "./src/legend/legend-choropleth-bivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a bivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chbi')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#73ae80'
    out.color2_ = '#6c83b5'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined

    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunBiv

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        const setupClassifiers = () => {
            let stat1 = out.statData('v1').getArray()
            let stat2 = out.statData('v2').getArray()

            const range = [...Array(out.numberOfClasses()).keys()]
            if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
            if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))

            //define bivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleBivariate(out.numberOfClasses(), out.startColor(), out.color1(), out.color2(), out.endColor())
                out.classToFillStyle(scale)
            }
        }

        const classifyRegions = (regions) => {
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    if (rg.properties.id.length == 4) console.log(rg)
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('nd', function (rg) {
                    const sv1 = out.statData('v1').get(rg.properties.id)
                    const sv2 = out.statData('v2').get(rg.properties.id)
                    if (!sv1 || !sv2) return
                    let v = sv1.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    v = sv2.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return ''
                })
        }

        // Initialize classifier
        setupClassifiers()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    if (!ecl1 && !ecl2) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    let color = out.classToFillStyle()(+ecl1, +ecl2)
                    return color
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        // Set up mouse events
                        addMouseEventsToRegions(map, regions)

                        // update font color for grid cartograms (contrast)
                        if (out.gridCartogram_) {
                            map.svg()
                                .selectAll('.em-grid-text')
                                .each(function () {
                                    const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.parentNode).style('fill')
                                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                                })
                        }
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                const ecl1 = sel.attr('ecl1')
                const ecl2 = sel.attr('ecl2')
                const lvl = sel.attr('lvl')

                // Determine display visibilitys
                const isVisible = ecl1 || ecl2 || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if ((ecl1 || ecl2) && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.style('fill', map.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const scaleBivariate = function (numberOfClasses, startColor, color1, color2, endColor) {
    //color ramps, by row
    const cs = []
    //interpolate from first and last columns
    const rampS1 = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(startColor, color1)
    const ramp2E = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(color2, endColor)
    for (let i = 0; i < numberOfClasses; i++) {
        const t = i / (numberOfClasses - 1)
        const colFun = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(rampS1(t), ramp2E(t))
        const row = []
        for (let j = 0; j < numberOfClasses; j++) row.push(colFun(j / (numberOfClasses - 1)))
        cs.push(row)
    }
    //TODO compute other matrix based on rows, and average both?

    return function (ecl1, ecl2) {
        return cs[ecl1][ecl2]
    }
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunBiv = function (rg, map) {
    const buf = []
    //region name
    const regionName = rg.properties.na || rg.properties.name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
        ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-trivariate.js":
/*!***************************************************!*\
  !*** ./src/maptypes/map-choropleth-trivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-trivariate */ "./src/legend/legend-choropleth-trivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a trivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chtri')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#09F8FF'
    out.color2_ = '#F5D300'
    out.color3_ = '#FF1493'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined
    out.classifier3_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunctionTrivariate

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'color3_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
        'classifier3_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'color3', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        let stat1 = out.statData('v1').getArray()
        let stat2 = out.statData('v2').getArray()
        let stat3 = out.statData('v3').getArray()

        const range = [...Array(7).keys()]
        if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
        if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))
        if (!out.classifier3_) out.classifier3((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat3).range(range))

        //assign class to nuts regions, based on their value
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        if (map.svg_) {
            let regions = map.svg().selectAll(selector)
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('ecl3', function (rg) {
                    const sv = out.statData('v3').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier3_(+v)
                })
                .attr('regionClass', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')

                    if (ecl1 === 'nd' || ecl2 === 'nd' || ecl3 === 'nd') return 'nd' // Handle 'no data'

                    // Combine the classifier results into a single class (1-7)
                    if (ecl1 && !ecl2 && !ecl3) return 1 // only variable 1 present
                    if (!ecl1 && ecl2 && !ecl3) return 2 // only variable 2 present
                    if (!ecl1 && !ecl2 && ecl3) return 3 // only variable 3 present
                    if (ecl1 && ecl2 && !ecl3) return 4 // variables 1 & 2 present
                    if (ecl1 && !ecl2 && ecl3) return 5 // variables 1 & 3 present
                    if (!ecl1 && ecl2 && ecl3) return 6 // variables 2 & 3 present
                    if (ecl1 && ecl2 && ecl3) return 7 // all present
                })
            // .attr('nd', function (rg) {
            //     const sv1 = out.statData('v1').get(rg.properties.id) || out.statData().get(rg.properties.id)
            //     const sv2 = out.statData('v2').get(rg.properties.id)
            //     if (!sv1 || !sv2) return
            //     let v = sv1.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     v = sv2.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     return ''
            // })

            //when mixing NUTS, level 0 is separated from the rest (class nutsrg0)
            if (map.nutsLevel_ == 'mixed') {
                map.svg()
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v1').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }

            //define trivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleTrivariate(out.color1(), out.color2(), out.color3())
                out.classToFillStyle(scale)
            }

            //when mixing NUTS, level 0 is separated from the rest (using class nutsrg0)
            if (out.nutsLevel_ == 'mixed') {
                map.svg_
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }
        }
    }

    const scaleTrivariate = function (color1, color2, color3) {
        // Blending primary colors and their overlaps
        const overlapColors = [
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2]), // Class 4 (Overlap of color1 and color2)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color2, color3]), // Class 5 (Overlap of color2 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color3]), // Class 6 (Overlap of color1 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2, color3]), // Class 7 (Overlap of all three)
        ]

        // Class-to-color mapping
        const classColors = [
            color1, // Class 1 (First color)
            color2, // Class 2 (Second color)
            color3, // Class 3 (Third color)
            overlapColors[0], // Class 4 (Overlap of color1 and color2)
            overlapColors[1], // Class 5 (Overlap of color2 and color3)
            overlapColors[2], // Class 6 (Overlap of color1 and color3)
            overlapColors[3], // Class 7 (Overlap of all three)
        ]

        // Return function to get color based on region's class (1 to 7)
        return function (classIndex) {
            if (classIndex >= 1 && classIndex <= 7) {
                return classColors[classIndex - 1]
            } else {
                return null // Return null or a default color if the classIndex is out of range
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl3 === 'nd') return out.noDataFillStyle() || 'gray'

                    if (!ecl1 && !ecl2 && !ecl3) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.

                    let regionClass = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('regionClass')
                    let color = out.classToFillStyle_(regionClass)
                    return color

                    //return getCSSPropertyFromClass('em-nutsrg', 'fill')
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        regions
                            .on('mouseover', function (e, rg) {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                sel.style('fill', map.hoverColor_)
                                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                            })
                            .on('mousemove', function (e, rg) {
                                if (out._tooltip) out._tooltip.mousemove(e)
                            })
                            .on('mouseout', function () {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                let newFill = sel.attr('fill___')
                                if (newFill) {
                                    sel.style('fill', sel.attr('fill___'))
                                    if (out._tooltip) out._tooltip.mouseout()
                                }
                            })
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const styleMixedNUTS = function (map) {
    map.svg()
        .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
        .style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const ecl = sel.attr('ecl')
            const lvl = sel.attr('lvl')
            const countryId = rg.properties.id.slice(0, 2)
            return ecl || lvl === '0' ? 'block' : 'none'
        })
        .style('stroke', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const stroke = sel.style('stroke')
            return ecl && lvl !== '0' ? stroke || '#777' : null
        })
        .style('stroke-width', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const strokeWidth = sel.style('stroke-width')
            return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
        })
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunctionTrivariate = function (rg, map) {
    const buf = []
    //region name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()
    //stat 3 value
    const sv3 = map.statData('v3').get(rg.properties.id)
    const unit3 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        Variable 1: ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 2: ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 3: ${sv3 && sv3.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv3.value) : ''} ${unit3 && sv3 && sv3.value ? unit3 : ''}
        ${!sv3 || (sv3.value != 0 && !sv3.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-choropleth.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   getFillPatternLegend: () => (/* binding */ getFillPatternLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var simple_statistics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! simple-statistics */ "./node_modules/simple-statistics/dist/simple-statistics.mjs");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");












/**
 * Returns a chroropleth map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'ch')

    //the number of classes
    out.numberOfClasses_ = 7
    //the classification method
    out.classificationMethod_ = 'quantile' // or: equinter, threshold
    //the threshold, when the classification method is 'threshold'
    out.thresholds_ = [0]
    //colors to use for classes
    out.colors_ = null
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //the color function [0,1] -> color
    let eurostatMultihue = ['#FFEB99', '#D1E9B0', '#8DD6B9', '#58C1C0', '#3792B6', '#134891', '#1d2b6f']
    out.colorFunction_ = (t) => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["default"], eurostatMultihue)(Math.min(Math.max(0, t), 1)) // default
    //a function returning the color from the class i
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier_ = undefined
    // set tooltip function
    out.tooltip_.textFunction = choroplethTooltipFunction

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'classificationMethod_',
        'thresholds_',
        'makeClassifNice_',
        'colorFunction_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier_',
        'colors_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override of some special getters/setters
    out.colorFunction = function (v) {
        if (!arguments.length) {
            return out.colorFunction_
        }
        out.colorFunction_ = v
        // update class style function
        if (out.filtersDefinitionFunction_) {
            // if dot density
            out.classToFillStyle(getFillPatternLegend())
        } else {
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }
        return out
    }
    out.threshold = function (v) {
        if (!arguments.length) return out.thresholds_
        out.thresholds_ = v
        out.numberOfClasses(v.length + 1)
        return out
    }
    out.filtersDefinitionFunction = function (v) {
        if (!arguments.length) return out.filtersDefinitionFunction_
        out.filtersDefinitionFunction_ = v
        if (out.svg()) out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        return out
    }

    //override attribute values with config values
    if (config)
        [
            'numberOfClasses',
            'classificationMethod',
            'threshold',
            'makeClassifNice',
            'colorFunction',
            'classToFillStyle',
            'noDataFillStyle',
            'colors_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        // Helper function to generate a range [0, 1, 2, ..., nb-1]
        const generateRange = (nb) => [...Array(nb).keys()]

        // Configure classifier based on the selected classification method
        const setupClassifier = () => {
            const dataArray = out.statData().getArray()
            const range = generateRange(out.numberOfClasses_)

            switch (out.classificationMethod_) {
                case 'quantile': {
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])().domain(dataArray).range(range))
                    break
                }
                case 'equal-interval':
                case 'equinter': {
                    out.classifier(
                        (0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])()
                            .domain([(0,d3_array__WEBPACK_IMPORTED_MODULE_9__["default"])(dataArray), (0,d3_array__WEBPACK_IMPORTED_MODULE_10__["default"])(dataArray)])
                            .range(range)
                    )
                    if (out.makeClassifNice_) out.classifier().nice()
                    break
                }
                case 'threshold': {
                    out.numberOfClasses(out.thresholds_.length + 1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_11__["default"])().domain(out.thresholds_).range(generateRange(out.numberOfClasses_)))
                    break
                }
                case 'jenks': {
                    const jenksBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_3__.jenks)(dataArray, out.numberOfClasses_) // Calculate breaks for Jenks
                    const domain = jenksBreaks.slice(1, -1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_11__["default"])().domain(domain).range(range)) // Use Jenks breaks in scale
                    break
                }
                case 'ckmeans': {
                    // Calculate ckmeans breaks, extracting the maximum value from each cluster
                    const ckmeansBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_3__.ckmeans)(dataArray, out.numberOfClasses_).map((cluster) => cluster.pop())

                    // Set the domain for scaleThreshold excluding the last value, as it serves as the upper bound
                    const domain = ckmeansBreaks.slice(0, -1)

                    // Use the ckmeans breaks in the scaleThreshold and set the classifier
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_11__["default"])().domain(domain).range(range))
                    break
                }
            }
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const regionData = out.statData().get(rg.properties.id)
                if (!regionData) return // Lack of data is handled explicitly
                const value = regionData.value
                if (value === ':' || value === null) return 'nd'
                return value != null ? +out.classifier_(value) : undefined
            })
        }

        // Initialize classifier
        setupClassifier()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        // Define function to get a class' color
        if (out.filtersDefinitionFunction_) {
            // Dot density style
            out.classToFillStyle(getFillPatternLegend())
        } else {
            // Color legend style
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }

        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_4__.applyPatternFill)(map, out.patternFill_)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')

                // Determine display visibility
                const isVisible = ecl || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if (ecl && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle()(ecl, out.numberOfClasses_)
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_(ecl, out.numberOfClasses_)
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle()(ecl, out.numberOfClasses_)
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFunction, colorArray) {
    colorFunction = colorFunction || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_13__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFunction(ecl / (numberOfClasses - 1))
    }
}

/**
 * Build a fill pattern legend object { nd:"white", 0:"url(#pattern_0)", 1:"url(#pattern_1)", ... }
 */
const getFillPatternLegend = function () {
    return function (ecl) {
        return 'url(#pattern_' + ecl + ')'
    }
}

const choroplethTooltipFunction = function (region, map) {
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na || region.properties.name
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    // Retrieve region's data value and unit
    const statData = map.statData()
    const sv = statData.get(regionId)
    const unit = statData.unitText() || ''

    // No data case
    if (!sv || (sv.value !== 0 && !sv.value) || sv.value === ':') {
        buf.push(`
            <div class="estat-vis-tooltip-text no-data">
                <table class="nuts-table">
                    <tbody>
                        <tr><td>${map.noDataText_}</td></tr>
                    </tbody>
                </table>
            </div>
        `)
        return buf.join('')
    }

    // Data display
    buf.push(`
        <div class="estat-vis-tooltip-text">
            <table class="nuts-table">
                <tbody>
                    <tr><td>${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv.value)} ${unit}</td></tr>
                </tbody>
            </table>
        </div>
    `)

    // Optional status flag
    const statusFlag = sv.status
    if (statusFlag && map.tooltip_.showFlags) {
        const flagText = map.tooltip_.showFlags === 'short' ? statusFlag : flags[statusFlag] || statusFlag
        buf.push(` <span class="status-flag">${flagText}</span>`)
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-flow.js":
/*!**********************************!*\
  !*** ./src/maptypes/map-flow.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/link.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-flow */ "./src/legend/legend-flow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
// Import required D3 modules
// import { sankey, sankeyLinkHorizontal } from 'd3-sankey'









/**
 * Returns a flow map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'flow')
    out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])()
    out.labelOffsetX = 15
    out.labelOffsetY = 5
    out.labelFormatter = (d) => (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)('.2s')(d)
    out.tooltip_.textFunction = flowMapTooltipFunction
    out.flowColor_ = '#72bb6f'
    out.flowOverlayColors_ = ['#bbd7ee', '#c7e3c6'] // exporter, importers

    /**
     * flowmap-specific setters/getters
     */
    ;['flowGraph_', 'flowColor_', 'flowOverlayColors_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //@override
    out.updateStyle = function () {
        // type: "Feature"
        // properties: Object {id: "ES", na: "España"}
        // geometry: Object {type: "MultiPolygon", coordinates: Array(7)}
        // source: "FR"
        // target: "ES"
        // value: 45422327.56

        // update stroke width function
        const data = out.flowGraph_.links
        out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])()
            .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_5__["default"])(data, (d) => d.value)])
            .range([2, 10])

        createFlowMapSVG(out.flowGraph_)
    }

    //@override
    out.updateClassification = function () {}

    //@override
    out.getLegendConstructor = function () {
        //TODO: define legend
        return _legend_legend_flow__WEBPACK_IMPORTED_MODULE_1__.legend
    }
    /**
     * Function to create a map with Sankey diagram and other elements
     * @param {Object} graph - Configuration options and data for the map
     * exampleGraph = {
                nodes: [
                    { id: 'FR', x: 681.1851800759263, y: 230.31124763648583 },
                    { id: 'DE', x: 824.5437782154489, y: 123.70302649032199 },
                ],
                links: [
                    { source: 'FR', target: 'DE', value: 82018369.72 },
                ],
            }
     */
    function createFlowMapSVG(graph) {
        const svg = out.svg_

        // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
        addCoordinatesToGraph(graph)

        var { nodes, links } = sankey(graph)

        // Define marker and gradient IDs
        const defs = svg.append('defs')
        const arrowId = generateUniqueId('arrow')
        const arrowOutlineId = generateUniqueId('arrow-outline')
        const gradientIds = links.map(() => generateUniqueId('gradient'))

        // Add arrow markers
        addArrowMarker(defs, arrowId, out.flowColor_)
        addArrowMarker(defs, arrowOutlineId, '#ffffff')

        // Add flow gradients
        addFlowGradients(defs, gradientIds, links)

        // Define our container SVG
        const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])('#em-zoom-group-' + out.svgId_)
        const sankeyContainer = zoomGroup.append('g').attr('class', 'em-flow-container')

        // Add geographical layers
        addOverlayPolygons(sankeyContainer, graph)

        // Add Sankey flows
        addSankeyFlows(sankeyContainer, links, arrowId, arrowOutlineId, gradientIds)

        // Add additional nodes (fill gaps)
        addFillGaps(sankeyContainer, nodes)

        // Add labels to nodes
        if (out.labels_) addLabels(sankeyContainer, nodes)

        return svg.node()
    }

    /**
     * Adds geographical layers (regions, POI overlay, borders)
     * @param {Object} svg - D3 selection of SVG container
     */
    function addOverlayPolygons(svg, graph) {
        const importerIds = []
        const exporterIds = []
        const features = out.Geometries.getRegionFeatures()
        if (features) {
            graph.nodes.forEach((node) => {
                const overlay = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (overlay) {
                    let isImporter = graph.links.some((link) => link.source == node.id)
                    if (isImporter) {
                        importerIds.push(node.id)
                    } else {
                        exporterIds.push(node.id)
                    }
                } else {
                    console.error('could not find geometry for', node.id)
                }
            })

            //update existing region fills
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
            const allRegions = out.svg_.selectAll(selector)

            allRegions.each(function () {
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).style('fill', (region) => {
                    if (importerIds.includes(region.properties.id)) return out.flowOverlayColors_[0]
                    if (exporterIds.includes(region.properties.id)) return out.flowOverlayColors_[1]
                })
            })
        }
    }

    // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
    function addCoordinatesToGraph(graph) {
        graph.nodes.forEach((node) => {
            if (!node.x && !node.y && out.Geometries.centroidFeatures) {
                const centroid = out.Geometries.centroidFeatures.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (centroid) {
                    const screenCoords = out._projection([centroid.geometry.coordinates[0], centroid.geometry.coordinates[1]])
                    node.x = screenCoords[0]
                    node.y = screenCoords[1]
                } else {
                    console.error('could not find coordinates for', node.id)
                }
            } else {
                // no centroids data, calculate on the fly
                const features = out.Geometries.getRegionFeatures()
                const feature = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })
                const centroid = feature.properties.centroid || out._pathFunction.centroid(feature)
                const screenCoords = out._projection([centroid[0], centroid[1]])
                node.x = screenCoords[0]
                node.y = screenCoords[1]
            }
        })
        console.log(graph)
    }

    /**
     * Generates a unique DOM ID
     * @param {string} prefix - Prefix for the ID
     * @returns {string} Unique ID
     */
    function generateUniqueId(prefix) {
        return `${prefix}-${Math.random().toString(36).substr(2, 9)}`
    }

    /**
     * Adds an arrow marker to the defs section
     * @param {Object} defs - D3 selection of defs
     * @param {string} id - Marker ID
     * @param {string} color - Fill color of the marker
     */
    function addArrowMarker(defs, id, color) {
        defs.append('marker')
            .attr('id', id)
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', color)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')

        // add a copy for mouseover with hovered color
        defs.append('marker')
            .attr('id', id + 'mouseover')
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', out.hoverColor_)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')
    }

    /**
     * Adds linear gradient definitions for flow links
     * @param {Object} defs - D3 selection of defs
     * @param {Array} gradientIds - Array of gradient IDs
     * @param {Array} links - Sankey links data
     */
    function addFlowGradients(defs, gradientIds, links) {
        defs.selectAll('linearGradient')
            .data(links)
            .join('linearGradient')
            .attr('id', (_, i) => gradientIds[i])
            .attr('gradientUnits', 'userSpaceOnUse')
            .attr('x1', (d) => d.source.x1)
            .attr('x2', (d) => d.target.x0)
            .attr('y1', (d) => d.y0)
            .attr('y2', (d) => d.y1)
            .call((g) => g.append('stop').attr('offset', '5%').attr('stop-color', out.flowOverlayColors_[0]))
            .call((g) => g.append('stop').attr('offset', '50%').attr('stop-color', out.flowColor_))
    }

    /**
     * Adds Sankey flows (links with markers and gradients)
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} links - Sankey links data
     * @param {string} arrowId - Arrow marker ID
     * @param {string} arrowOutlineId - Arrow outline marker ID
     * @param {Array} gradientIds - Gradient IDs
     */
    function addSankeyFlows(svg, links, arrowId, arrowOutlineId, gradientIds) {
        const flowsGroup = svg.append('g').attr('class', 'em-flows-group')

        links.forEach((link, i) => {
            // Outline path
            flowsGroup
                .append('path')
                .attr('d', sankeyLinkHorizontal()(link))
                .attr('fill', 'none')
                .attr('stroke', '#ffffff')
                .attr('class', 'em-flow-link-outline')
                .attr('stroke-width', link.width + 1.5)
                .attr('marker-end', `url(#${arrowOutlineId})`)

            // Main path
            flowsGroup
                .append('path')
                .attr('d', sankeyLinkHorizontal()(link))
                .attr('fill', 'none')
                .attr('class', 'em-flow-link')
                .attr('stroke', `url(#${gradientIds[i]})`)
                .attr('stroke-width', link.width)
                .attr('marker-end', `url(#${arrowId})`)
                // add hover effect
                .on('mouseover', function (e) {
                    const hoveredColor = out.hoverColor_

                    // Change the stroke color
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', hoveredColor)

                    // Update the marker-end dynamically
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId + 'mouseover'})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(link, out))
                })
                .on('mousemove', function (e) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    // Revert the stroke color
                    (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', `url(#${gradientIds[i]})`)

                    // Revert the marker-end to the original
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    /**
     * Adds rectangles to fill gaps left by Sankey links
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} nodes - Sankey nodes data
     */
    function addFillGaps(svg, nodes) {
        svg.append('g')
            .attr('class', 'em-flow-fill-in-gaps')
            .selectAll('rect')
            .data(nodes)
            .join('rect')
            .filter((d) => d.depth && d.height)
            .attr('x', (d) => d.x0 - 0.5)
            .attr('y', (d) => d.y0)
            .attr('width', 1)
            .attr('height', (d) => d.y1 - d.y0)
            .attr('fill', out.flowColor_)
    }

    /**
     * Add labels for data points.
     * @param {Object} svg - D3 selection of the SVG element.
     */
    function addLabels(svg, nodes) {
        // Filter the nodes
        const filteredNodes = nodes.filter((node) => node.targetLinks && node.sourceLinks.length === 0)
        const container = svg.append('g').attr('class', 'em-flow-labels')

        // Add halo effect
        if (out.labels_?.shadows) {
            const labelsShadowGroup = container.append('g').attr('class', 'em-flow-label-shadow')
            labelsShadowGroup
                .selectAll('text')
                .data(filteredNodes)
                .join('text')
                .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
                .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? d.x + out.labelOffsetX : d.x - out.labelOffsetX))
                .attr('y', (d) => d.y + out.labelOffsetY)
                .text((d) => out.labelFormatter(d.value))
        }

        // Add labels
        const labelsGroup = container.append('g').attr('class', 'em-flow-label')
        //add background
        // Add background rectangles and text
        const labelElements = labelsGroup
            .selectAll('g') // Use a group for each label to combine rect and text
            .data(filteredNodes)
            .join('g') // Append a group for each label
            .attr('transform', (d) => `translate(${d.x}, ${d.y})`) // Position group at the node

        // Add text first to calculate its size
        labelElements
            .append('text')
            .attr('class', 'em-label-text')
            .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
            .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? out.labelOffsetX : -out.labelOffsetX))
            .attr('y', out.labelOffsetY)
            .text((d) => out.labelFormatter(d.value))

        // Add background rectangles after text is rendered

        if (out.labels_.backgrounds) {
            labelElements.each(function () {
                const textElement = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).select('text')
                const bbox = textElement.node().getBBox() // Get bounding box of the text

                const paddingX = 5 // Horizontal padding
                const paddingY = 2 // Vertical padding

                // Add rectangle centered behind the text
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                    .insert('rect', 'text') // Insert rect before text in DOM
                    .attr('class', 'em-label-background')
                    .attr('x', bbox.x - paddingX)
                    .attr('y', bbox.y - paddingY)
                    .attr('width', bbox.width + 2 * paddingX)
                    .attr('height', bbox.height + 2 * paddingY)
            })
        }
    }

    // Function to append a rectangle behind the label
    function appendLabelRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    // From this point on all code is related with spatial sankey. Adopted from this notebook: https://observablehq.com/@bayre/deconstructed-sankey-diagram
    // See https://observablehq.com/@joewdavies/flow-map-of-europe
    function clone({ nodes, links }) {
        return { nodes: nodes.map((d) => Object.assign({}, d)), links: links.map((d) => Object.assign({}, d)) }
    }

    function sankey({ nodes, links }) {
        const graph = clone({ nodes, links })
        computeNodeLinks(graph)
        computeNodeValues(graph)
        computeNodeDepths(graph)
        computeNodeHeights(graph)
        computeNodeBreadths(graph)
        computeLinkBreadths(graph)
        return graph
    }

    function computeNodeLinks({ nodes, links }) {
        for (const [i, node] of nodes.entries()) {
            node.index = i
            node.sourceLinks = []
            node.targetLinks = []
        }
        const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]))
        for (const [i, link] of links.entries()) {
            link.index = i
            let { source, target } = link
            if (typeof source !== 'object') source = link.source = find(nodeById, source)
            if (typeof target !== 'object') target = link.target = find(nodeById, target)
            source.sourceLinks.push(link)
            target.targetLinks.push(link)
        }
        // if (linkSort != null) {
        //     for (const { sourceLinks, targetLinks } of nodes) {
        //         sourceLinks.sort(linkSort)
        //         targetLinks.sort(linkSort)
        //     }
        // }
    }

    function find(nodeById, id) {
        const node = nodeById.get(id)
        if (!node) throw new Error('missing: ' + id)
        return node
    }

    function computeNodeDepths({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.depth = x
                for (const { target } of node.sourceLinks) {
                    next.add(target)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    function computeNodeHeights({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.height = x
                for (const { source } of node.targetLinks) {
                    next.add(source)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    // vertically stacks links with the same origin. Causes issues on world maps
    // function computeLinkBreadths({ nodes }) {
    //     for (const node of nodes) {
    //         let y0 = node.y0;  // Initial y0 position
    //         let y1 = y0;
    //         for (const link of node.sourceLinks) {
    //             link.y0 = y0 + link.width / 2;  // Adjusting y0 dynamically
    //             y0 += link.width;  // Moving y0 down for the next link
    //         }
    //         for (const link of node.targetLinks) {
    //             link.y1 = y1 + link.width / 2;
    //             y1 += link.width;
    //         }
    //     }
    // }

    function computeLinkBreadths({ nodes }) {
        for (const node of nodes) {
            if (node.sourceLinks.length > 1) {
                // If multiple links originate from the same source, set them to the same y0
                const fixedY0 = node.y // Use the node's y position
                node.sourceLinks.forEach((link) => {
                    link.y0 = fixedY0 // Force all links to use the same y0
                })
            } else {
                // Default behavior for other nodes
                let y0 = node.y0
                let y1 = y0
                for (const link of node.sourceLinks) {
                    link.y0 = y0 + link.width / 2
                    y0 += link.width
                }
                for (const link of node.targetLinks) {
                    link.y1 = y1 + link.width / 2
                    y1 += link.width
                }
            }
        }
    }

    function horizontalSource(d) {
        return [d.source.x1, d.y0]
    }

    function horizontalTarget(d) {
        return [d.target.x0, d.y1]
    }

    function computeNodeValues({ nodes }) {
        for (const node of nodes) {
            node.value = Math.max(
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.sourceLinks, (d) => d.value),
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.targetLinks, (d) => d.value)
            )
        }
    }

    function reorderLinks(nodes) {
        for (const { sourceLinks, targetLinks } of nodes) {
            sourceLinks.sort(ascendingTargetY)
            targetLinks.sort(ascendingSourceY)
        }
    }

    const ascendingTargetY = (a, b) => a.target.y - b.target.y
    const ascendingSourceY = (a, b) => a.source.y - b.source.y

    function computeNodeBreadths({ nodes }) {
        for (const node of nodes) {
            const height = out.strokeWidthScale(node.value)
            node.x0 = node.x1 = node.x
            node.y0 = node.y - height / 2
            node.y1 = node.y0 + height
            for (const link of node.sourceLinks) {
                link.width = out.strokeWidthScale(link.value)
            }
        }
        reorderLinks(nodes)
    }

    const id = (d) => d.id // used in sankey import

    const sankeyLinkHorizontal = function () {
        return (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__.linkHorizontal)().source(horizontalSource).target(horizontalTarget)
    }

    return out
}

const flowMapTooltipFunction = function (link, map) {
    const buf = []

    // Header with region name and ID
    const title = `${link.source.id} > ${link.target.id}`
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${title}</b>
        </div>
    `)

    // Value
    buf.push(`<div class='estat-vis-tooltip-text'>
        ${link.target.value}
        </div>`)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-piecharts.js":
/*!***************************************!*\
  !*** ./src/maptypes/map-piecharts.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-piecharts */ "./src/legend/legend-piecharts.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");









/**
 * Returns a proportional pie chart map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'pie')

    // pie charts
    out.pieMinRadius_ = 5
    out.pieMaxRadius_ = 15
    out.pieChartInnerRadius_ = 0
    out.pieStrokeFill_ = 'white'
    out.pieStrokeWidth_ = 0.3

    //tooltip pie chart
    out.tooltipPieRadius_ = 40
    out.tooltipPieInnerRadius_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    // 'other' section of the pie chart for when 'out.totalCode_' is defined with statPie()
    out.pieOtherColor_ = '#FFCC80'
    out.pieOtherText_ = 'Other'

    //show piecharts only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    out.sizeClassifier_ = null //d3 scale for scaling pie sizes
    out.statPie_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieMaxRadius_',
        'pieMinRadius_',
        'pieChartInnerRadius_',
        'pieOtherColor_',
        'pieOtherText_',
        'pieStrokeFill_',
        'pieStrokeWidth_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieMaxRadius',
            'pieMinRadius',
            'pieChartInnerRadius',
            'pieOtherColor',
            'pieOtherText',
            'pieStrokeFill',
            'pieStrokeWidth',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /** The codes of the categories to consider for the composition. */
    out.statCodes_ = undefined
    /** The code of the "total" category in the eurostat database */
    out.totalCode__ = undefined

    /**
     * A function to define a pie chart map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension (defined in eurostat REST API) of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     * @param {string} tCode Optional: The category code of the total (used to calculate total & "other" values if codes array dont represent all possible categories)
     */
    out.statPie = function (stat, dim, codes, labels, colors, tCode) {
        //add one dataset (stat) config for each category (code)
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) {
                sc_[key] = stat[key]
            }
            sc_.filters = {}
            for (let key in stat.filters) {
                sc_.filters[key] = stat.filters[key]
            }
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set out.statCodes_
        out.statCodes_ = codes

        //set out.totalCode_
        if (tCode) {
            out.totalCode_ = tCode
            stat.filters[dim] = tCode
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(tCode, sc_)

            //when total code is used, an 'other' section is added to the pie
            out.catColors_['other'] = out.pieOtherColor_
            out.catLabels_['other'] = out.pieOtherText_
        }

        return out
    }

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //if not provided, get list of stat codes from the map stat data
        if (!out.statCodes_) {
            //get list of stat codes.
            out.statCodes_ = Object.keys(out.statData_)
            //remove "default", if present
            const index = out.statCodes_.indexOf('default')
            if (index > -1) out.statCodes_.splice(index, 1)
        }

        //define size scaling function
        let domain = getDatasetMaxMin()
        if (!isNaN(domain[0])) {
            out.sizeClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__.sqrt)().domain(domain).range([out.pieMinRadius_, out.pieMaxRadius_])
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors_) {
            out.catColors({})
            for (let i = 0; i < out.statCodes_.length; i++) out.catColors_[out.statCodes_[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of sharing regions with pies
        let regionFeatures = []
        if (out.svg_) {
            let s = out.svg_.selectAll('#em-prop-symbols')
            if (s) {
                let sym = s.selectAll('g.em-centroid')
                sym.append('g')
                    .attr('class', 'em-pie')
                    .attr('id', (rg) => {
                        regionFeatures.push(rg)
                        return 'pie_' + rg.properties.id
                    })

                // set region hover function
                const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
                let regions = out.svg().selectAll(selector)
                regions
                    .on('mouseover', function (e, rg) {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                        sel.style('fill', out.hoverColor_)
                        if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                    })
                    .on('mousemove', function (e, rg) {
                        if (out._tooltip) out._tooltip.mousemove(e)
                    })
                    .on('mouseout', function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                        let newFill = sel.attr('fill___')
                        if (newFill) {
                            sel.style('fill', sel.attr('fill___'))
                            if (out._tooltip) out._tooltip.mouseout()
                        }
                    })

                addPieChartsToMap(regionFeatures)
            }
        }
        return out
    }

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < out.statCodes_.length; i++) {
            //retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        // when out.totalCode_ is specified, use it as the sum instead of the sum of the specified categories.
        if (out.totalCode_) {
            let s = out.statData(out.totalCode_).get(id)
            if (s) {
                sum = s.value
            } else {
                sum == 0
            }
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < out.statCodes_.length; i++) {
            comp[out.statCodes_[i]] /= sum
        }

        //add "other" category when out.totalCode_ is used
        if (out.totalCode_) {
            let totalPerc = 0
            for (let key in comp) {
                totalPerc = totalPerc + comp[key]
            }
            comp['other'] = 1 - totalPerc
        }

        return comp
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum total of all dimensions combined for each region. Used to define the domain of the pie size scaling function.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        let totals = []
        let sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            let id = rg.properties.id
            let total = getRegionTotal(id)
            if (total) {
                totals.push(total)
            }
        })

        let minmax = (0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])(totals)
        return minmax
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionTotal = function (id) {
        let sum = 0
        let s
        if (out.totalCode_) {
            //when total is a stat code
            s = out.statData(out.totalCode_).get(id)
            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) {
                    sum = undefined
                }
            } else {
                sum = s.value
            }
        } else {
            //get stat value for each category. Compute the sum.
            for (let i = 0; i < out.statCodes_.length; i++) {
                //retrieve code and stat value
                const sc = out.statCodes_[i]
                s = out.statData(sc).get(id)
                //case when some data is missing
                if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                    if (out.showOnlyWhenComplete()) return undefined
                    else continue
                }
                sum += s.value
            }
        }

        //case when no data
        if (sum == 0) return undefined
        return sum
    }

    function addPieChartsToMap(regionFeatures) {
        regionFeatures.forEach((region) => {
            const regionId = region.properties.id
            //prepare data for pie chart
            const data = []
            const comp = getComposition(regionId)
            for (const key in comp) data.push({ code: key, value: comp[key] })

            //case of regions with no data
            if (!data || data.length == 0) {
                return
            }

            //create svg for pie chart
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let nodes = out.svg().selectAll('#pie_' + regionId)

            // define radius
            const r = out.sizeClassifier_(getRegionTotal(regionId))
            const ir = out.pieChartInnerRadius_

            //make pie chart. See https://observablehq.com/@d3/pie-chart
            const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
                .sort(null)
                .value((d) => d.value)
            nodes
                .append('g')
                .attr('stroke', out.pieStrokeFill_)
                .attr('stroke-width', out.pieStrokeWidth_ + 'px')
                .attr('class', 'piechart')
                .selectAll('path')
                .data(pie_(data))
                .join('path')
                .style('fill', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('fill___', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('code', (d) => d.data.code) //for mouseover legend highlighting function
                .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])().innerRadius(ir).outerRadius(r))
                .on('mouseover', function (e, rg) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    // Apply a thick stroke width to the parent element
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', '1px').style('stroke', 'black') // Set stroke
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(region, out))
                })
                .on('mousemove', function (e, rg) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    // Reset stroke
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', out.pieStrokeWidth_).style('stroke', out.pieStrokeFill_) // Set stroke
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        if (rg.properties.id) {
            //name and code
            tp.append('div')
                .attr('class', 'estat-vis-tooltip-bar')
                .html(rg.properties.na + ' (' + rg.properties.id + ')')
        } else {
            //region name
            tp.append('div').attr('class', 'estat-vis-tooltip-bar').html(rg.properties.na)
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        // set the dimensions and margins of the graph
        let width = 150
        let height = 150
        let margin = 25

        // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
        const radius = Math.min(width, height) / 2 - margin

        //width = tp.node().getBoundingClientRect().width
        const container = tp.append('div').attr('class', 'em-tooltip-piechart-container')
        const svg = container
            .append('svg')
            .attr('class', 'em-tooltip-piechart-svg')
            .attr('viewbox', `0, 0, ${width}, ${height}`)
            .attr('width', width)
            .attr('height', height - margin / 2)
            .append('g')
            .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
            .sort(null)
            .value((d) => d.value)

        const innerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(0) // This is the size of the donut hole
            .outerRadius(radius * 0.8)

        // Another arc that won't be drawn. Just for labels positioning
        const outerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(radius * 0.9)
            .outerRadius(radius * 0.9)

        const pieData = pie_(data)
        svg.selectAll('allSlices')
            .data(pieData)
            .enter()
            .append('path')
            .attr('d', innerArc)
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('stroke', 'white')
            .style('stroke-width', '1px')
            .style('opacity', 0.7)

        // Add the polylines between chart and labels:
        svg.selectAll('allPolylines')
            .data(pieData)
            .enter()
            .append('polyline')
            .attr('stroke', 'black')
            .style('fill', 'none')
            .attr('stroke-width', 1)
            .attr('points', function (d) {
                if (d.data.value > 0.02) {
                    const posA = innerArc.centroid(d) // line insertion in the slice
                    const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                    const posC = outerArc.centroid(d) // Label position = almost the same as posB
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                    posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1) // multiply by 1 or -1 to put it on the right or on the left
                    return [posA, posB, posC]
                }
            })

        // Add the labels:
        svg.selectAll('allLabels')
            .data(pieData)
            .enter()
            .append('text')
            .text(function (d) {
                if (d.data.value > 0.02) {
                    let n = (d.data.value * 100).toFixed()
                    if (!isNaN(n)) return n + '%'
                }
            })
            .attr('transform', function (d) {
                var pos = outerArc.centroid(d)
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1)
                return 'translate(' + pos + ')'
            })
            .style('text-anchor', function (d) {
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                return midangle < Math.PI ? 'start' : 'end'
            })
            .style('font-size', '12px')

        // add region values to tooltip
        let breakdownDiv = tp.append('div').attr('class', 'em-tooltip-piechart-breakdown')

        // show value for each category
        for (let i = 0; i < out.statCodes_.length; i++) {
            // retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(rg.properties.id)

            // check if s and s.value are valid (handle null, undefined, or 0)
            if (s && s.value !== undefined && s.value !== null) {
                let string = `<strong>${out.catLabels_[sc]}</strong>: ${s.value.toFixed()}<br>`
                breakdownDiv.html(breakdownDiv.html() + string) // safely update the HTML
            }
        }

        // write total (handle null, undefined, or 0 values for total)
        let total = getRegionTotal(rg.properties.id)
        if (total !== undefined && total !== null) {
            breakdownDiv.html(breakdownDiv.html() + `<strong>Total</strong>: ${total.toFixed()}<br>`)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-proportional-symbols.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-proportional-symbols.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   symbolsLibrary: () => (/* binding */ symbolsLibrary)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-proportional-symbols */ "./src/legend/legend-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");










/**
 * Returns a proportional symbol map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'ps')

    //shape
    out.psShape_ = 'circle' // accepted values: circle, bar, square, star, diamond, wye, cross
    out.psCustomShape_ // see http://using-d3js.com/05_10_symbols.html#h_66iIQ5sJIT
    out.psCustomSVG_ // see http://bl.ocks.org/jessihamel/9648495
    out.psSpikeWidth_ = 7 // 'spike' shape widths
    out.psOffset_ = { x: 0, y: 0 }

    //size
    out.psMaxSize_ = 30 // max symbol size
    out.psMinSize_ = 5 // min symbol size
    out.psBarWidth_ = 10 //for vertical bars
    out.psMaxValue_ = undefined // allow the user to manually define the domain of the sizing scale. E.g. if the user wants to use the same scale across different maps.
    out.psMinValue_ = undefined
    out.psSizeScale_ = undefined // 'sqrt' or 'linear'

    //colour
    out.psFill_ = '#2d50a0' //same fill for all symbols when no visual variable (setData()) for 'color' is specified
    out.psFillOpacity_ = 1
    out.psStroke_ = '#ffffff'
    out.psStrokeWidth_ = 0.2
    out.psClasses_ = 5 // number of classes to use for colouring
    out.psColors_ = null //colours to use for threshold colouring
    out.psColorFun_ = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"]
    out.psClassToFillStyle_ = undefined //a function returning the color from the class i

    //the threshold, when the classification method is 'threshold'
    out.psThresholds_ = [0]
    //the classification method
    out.psClassificationMethod_ = 'quantile' // or: equinter, threshold
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //
    //the classifier: a function which return the symbol size/color from the stat value.
    out.classifierSize_ = undefined
    out.classifierColor_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunPs

    //dorling cartogram
    out.dorling_ = false
    out.dorlingStrength_ = { x: 1, y: 1 }
    out.dorlingIterations_ = 1
    out.psCodeLabels_ = false // show country codes in symbols

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'psMaxSize_',
        'psMinSize_',
        'psMaxValue_',
        'psMinValue_',
        'psFill_',
        'psFillOpacity_',
        'psStroke_',
        'psStrokeWidth_',
        'classifierSize_',
        'classifierColor_',
        'psShape_',
        'psCustomShape_',
        'psBarWidth_',
        'psClassToFillStyle_',
        'psColorFun_',
        'psSizeScale_',
        'noDataFillStyle_',
        'psThresholds_',
        'psColors_',
        'psCustomSVG_',
        'psOffset_',
        'psClassificationMethod_',
        'psClasses_',
        'dorling_',
        'dorlingStrength_',
        'psSpikeWidth_',
        'psCodeLabels_',
        'dorlingIterations_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'psMaxSize',
            'psMinSize',
            'psFill',
            'psFillOpacity',
            'psStroke',
            'psStrokeWidth',
            'classifierSize',
            'classifierColor',
            'psShape',
            'psCustomShape',
            'psBarWidth',
            'psClassToFillStyle',
            'psColorFun',
            'noDataFillStyle',
            'psThreshold',
            'psColors',
            'psCustomSVG',
            'psOffset',
            'psClassificationMethod',
            'psClasses',
            'dorlingIterations_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //override of some special getters/setters
    out.psColorFun = function (v) {
        if (!arguments.length) return out.psColorFun_
        out.psColorFun_ = v
        out.psClassToFillStyle_ = getColorLegend(out.psColorFun_, out.psColors_)
        return out
    }
    out.psThresholds = function (v) {
        if (!arguments.length) return out.psThresholds_
        out.psThresholds_ = v
        out.psClasses(v.length + 1)
        return out
    }

    //@override
    out.updateClassification = function () {
        //define classifiers for sizing and colouring (out.classifierSize_ & out.classifierColor_)
        defineClassifiers()

        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    /**
     * @description assigns a color to each symbol, based on their statistical value
     * @param {*} map
     */
    function applyClassificationToMap(map) {
        if (map.svg_) {
            if (out.classifierColor_) {
                //assign color class to each symbol, based on their value
                // at this point, the symbol path hasnt been appended. Only the parent g element (.em-centroid)
                const colorData = map.statData('color')
                map.svg_.selectAll('.em-centroid').attr('ecl', function (rg) {
                    const sv = colorData.get(rg.properties.id)
                    if (!sv) {
                        return 'nd'
                    }
                    const v = sv.value
                    if ((v !== 0 && !v) || v == ':') {
                        return 'nd'
                    }
                    let c = +out.classifierColor_(+v)
                    return c
                })
            }
        }
    }

    /**
     * @description defines classifier functions (out.classifierColor and out.classifierSize) for both symbol size and color
     */
    function defineClassifiers() {
        // set default scale
        if (!out.psSizeScale_) {
            if (out.psShape_ == 'spike') {
                out.psSizeScale_ = 'linear'
            } else {
                out.psSizeScale_ = 'sqrt'
            }
        }

        //simply return the array [0,1,2,3,...,nb-1]
        const getA = function (nb) {
            return [...Array(nb).keys()]
        }

        // use size dataset
        let rawData = out.statData('size').getArray() || out.statData().getArray()
        let data = rawData.filter((d) => typeof d === 'number' && !isNaN(d) && isFinite(d))
        let [minVal, maxVal] = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__["default"])(data)
        let min = out.psMinValue_ ?? minVal
        let max = out.psMaxValue_ ?? maxVal
        let sizeDomain = data ? [min, max] : [out.statData().getMin(), out.statData().getMax()]

        let scale = out.psSizeScale_ == 'sqrt' ? d3_scale__WEBPACK_IMPORTED_MODULE_5__.sqrt : d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"]
        out.classifierSize(scale().domain(sizeDomain).range([out.psMinSize_, out.psMaxSize_]))

        // colour
        if (out.statData('color').getArray()) {
            //use suitable classification type for colouring
            if (out.psClassificationMethod_ === 'quantile') {
                //https://github.com/d3/d3-scale#quantile-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])().domain(domain).range(range))
            } else if (out.psClassificationMethod_ === 'equinter') {
                //https://github.com/d3/d3-scale#quantize-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor(
                    (0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])()
                        .domain([min(domain), max(domain)])
                        .range(range)
                )
                if (out.makeClassifNice_) out.classifierColor().nice()
            } else if (out.psClassificationMethod_ === 'threshold') {
                //https://github.com/d3/d3-scale#threshold-scales
                out.psClasses(out.psThresholds().length + 1)
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_9__["default"])().domain(out.psThresholds()).range(range))
            }
        }
    }

    /**
     * Applies proportional symbol styling to a map object
     *
     * @param {*} map
     * @returns
     */
    function applyStyleToMap(map) {
        //see https://bl.ocks.org/mbostock/4342045 and https://bost.ocks.org/mike/bubble-map/
        //define style per class
        if (!out.psClassToFillStyle()) out.psClassToFillStyle(getColorLegend(out.psColorFun_, out.psColors_))

        // if size dataset not defined then use default
        let sizeData = map.statData('size').getArray() ? map.statData('size') : map.statData()

        if (map.svg_) {
            //clear previous centroids
            let prevSymbols = map.svg_.selectAll(':not(#em-insets-group) g.em-centroid > *')
            prevSymbols.remove()

            // 'small' centroids on top of big ones
            updateSymbolsDrawOrder(map)

            // append symbols to centroids
            let symb
            if (out.psCustomSVG_) {
                symb = appendCustomSymbolsToMap(map, sizeData)
            } else if (out.psShape_ == 'bar') {
                symb = appendBarsToMap(map, sizeData)
            } else if (out.psShape_ == 'circle') {
                symb = appendCirclesToMap(map, sizeData)
            } else if (out.psShape_ == 'spike') {
                symb = appendSpikesToMap(map, sizeData)
            } else {
                // circle, cross, star, triangle, diamond, square, wye or custom
                symb = appendD3SymbolsToMap(map, sizeData)
            }

            // dorling cartogram
            if (out.dorling_) {
                applyDorlingForce(map, sizeData)
            } else {
                if (out.simulation) stopSimulation()
            }

            appendLabelsToSymbols(map, sizeData)

            // set style of symbols
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)

            if (map.geo_ !== 'WORLD') {
                if (map.nutsLevel_ == 'mixed') {
                    addSymbolsToMixedNUTS(map, sizeData, regions)
                }

                // apply 'nd' class to no data for legend item hover
                regions.attr('ecl', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                        // NO INPUT
                        return 'nd'
                    } else if ((sv && sv.value) || (sv && sv.value == 0)) {
                        if (sv.value == ':') {
                            // DATA NOT AVAILABLE
                            return 'nd'
                        }
                    }
                })
            }

            setSymbolStyles(symb)

            addMouseEvents(map)

            // Update labels for statistical values if required
            if (out.labels_?.values) {
                out.updateValuesLabels(map)
            }
        }
        return map
    }

    const appendLabelsToSymbols = function (map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')
        //country code labels
        if (out.psCodeLabels_) {
            const countryCodeLabel = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-code-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value === ':' ? '' : d.properties.id // Hide text if value is ':'
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    // size adjustment factor depends on symbol type, and whether stat values are also added to the circles
                    let factor = out.labels_?.values && sizeData.get(d.properties.id)?.value ? 0.8 : 0.9
                    if (out.psShape_ === 'square') factor = factor - 0.4
                    return `${radius * factor}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.labels_?.values && sizeData.get(d.properties.id)?.value ? '-0.3em' : '0'))
        }

        //stat labels
        if (out.labels_?.values) {
            const statLabels = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-stat-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    if (datum?.value) return datum.value
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    return `${radius * 0.4}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.psCodeLabels_ ? '0.6em' : '0'))
        }
    }

    const addMouseEvents = function (map) {
        let symbols = map.svg().selectAll('g.em-centroid')
        symbols
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])(this.childNodes[0])
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])(this.childNodes[0])
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', newFill)
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    /**
     * @description sets color/stroke/opacity styles of all symbols
     * @param {d3.selection} symb symbols d3 selection
     */
    function setSymbolStyles(symb) {
        symb.style('fill-opacity', out.psFillOpacity())
            .style('stroke', out.psStroke())
            .style('stroke-width', out.psStrokeWidth())
            .style('fill', function () {
                if (out.classifierColor_) {
                    //for ps, ecl attribute belongs to the parent g.em-centroid node created in map-template
                    const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])(this.parentNode).attr('ecl')
                    if (!ecl || ecl === 'nd') return out.noDataFillStyle_ || 'gray'
                    let color = out.psClassToFillStyle_(ecl, out.psClasses_)
                    return color
                } else {
                    return out.psFill_
                }
            })
            .attr('fill___', function () {
                let fill = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])(this).style('fill')
                return fill // save for legend mouseover
            })
    }

    /**
     * @description Updates the draw order of the symbols according to their data values
     * @param {*} map map instance
     */
    function updateSymbolsDrawOrder(map) {
        const gcp = map.svg_.select('#em-prop-symbols')
        const sizeData = map.statData('size')?.getArray?.() ? map.statData('size') : map.statData()

        // 1. Filter and sort features with data
        if (map.Geometries.centroidFeatures) {
            const sorted = map.Geometries.centroidFeatures
                .filter((f) => {
                    const v = sizeData.get?.(f.properties.id)?.value
                    return v != null && v !== ':'
                })
                .sort((a, b) => {
                    return sizeData.get(b.properties.id).value - sizeData.get(a.properties.id).value
                })

            // 2. Clear and rebind
            gcp.selectAll('g.em-centroid').remove()

            gcp.selectAll('g.em-centroid')
                .data(sorted, (d) => d.properties.id)
                .enter()
                .append('g')
                .attr('class', 'em-centroid')
                .attr('id', (d) => 'ps' + d.properties.id)
                .attr('transform', (d) => `translate(${d.properties.centroid[0].toFixed(3)},${d.properties.centroid[1].toFixed(3)})`)

            // 3. add the ecl attribute back to the newly created g elements
            applyClassificationToMap(map) //
        }
    }

    function appendSpikesToMap(map, sizeData) {
        //The spike function creates a triangular path of the given length (height) with a base width of 7 pixels.
        const spike = (length, width = out.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        // Append circles to each symbol container
        const spikes = symbolContainers
            .append('path')
            .attr('d', (d) => {
                const datum = sizeData.get(d.properties.id)
                const value = datum ? out.classifierSize_(datum.value) : 0
                let path = spike(value)
                return path
            })
            .style('fill', (d) => d.color || 'steelblue') // Adjust color as needed
            //.attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)

        return spikes
    }

    /**
     * @description Appends <circle> elements for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData statistical data for size e.g. map.statData('size')
     * @return {void}
     */
    function appendCirclesToMap(map, sizeData) {
        // Append circles to each symbol container
        const circles = map
            .svg()
            .selectAll('g.em-centroid')
            .filter((d) => {
                const datum = sizeData.get(d.properties.id)
                return datum && datum.value !== ':' && datum.value != null
            })
            .append('circle')
            .attr('r', function (d) {
                const datum = sizeData.get(d.properties.id)
                const radius = out.classifierSize_(datum.value)
                if (radius < 0) console.error('Negative radius for circle:', d.properties.id)
                if (isNaN(radius)) console.error('NaN radius for circle:', d.properties.id)
                return radius
            })

        return circles
    }

    function applyDorlingForce(map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        if (out.simulation) {
            stopSimulation()
        }

        // Initialize the force simulation
        console.log('new dorling simulation')
        out.simulation = (0,d3_force__WEBPACK_IMPORTED_MODULE_11__["default"])(map.Geometries.centroidFeatures)
            .force(
                'x',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_12__["default"])((d) => d.properties.centroid[0]).strength(out.dorlingStrength_.x) // Stronger pull to original x
            )
            .force(
                'y',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_13__["default"])((d) => d.properties.centroid[1]).strength(out.dorlingStrength_.y) // Stronger pull to original y
            )
            .force(
                'collide',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_14__["default"])((d) => {
                    const datum = sizeData.get(d.properties.id)
                    let size = datum ? out.classifierSize_(datum.value) : 0

                    if (out.psShape_ === 'square') {
                        return (size / 2) * Math.SQRT2 // Adjust for diagonal size
                    }

                    return size // Default for circles
                }).iterations(out.dorlingIterations_) // More iterations to improve collision handling
            )
            //.alphaTarget(0.3) // Helps keep centroids anchored
            .on('tick', () => {
                // Update elements with the new positions and radii
                symbolContainers.attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')')
            })

        //out.simulation.alpha(1).restart() // Ensures simulation starts with full strength
    }

    function stopSimulation() {
        out.simulation.stop() // Stops the internal tick loop
        out.simulation.on('tick', null) // Remove tick event listener
        out.simulation.on('end', null) // Remove end event listener
        out.simulation = null // Remove reference
    }

    /**
     * @description Appends <path> elements containing symbols for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendD3SymbolsToMap(map, sizeData) {
        return map
            .svg()
            .selectAll('g.em-centroid')
            .append('path')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .attr('d', (rg) => {
                //calculate size
                if (!sizeData) return
                const sv = sizeData.get(rg.properties.id)
                if (sv != 0 && !sv) return
                let size = out.classifierSize_(+sv.value) || 0

                //apply size to shape
                if (out.psCustomShape_) {
                    return out.psCustomShape_.size(size * size)()
                } else {
                    const symbolType = symbolsLibrary[out.psShape_] || symbolsLibrary['circle']
                    return (0,d3_shape__WEBPACK_IMPORTED_MODULE_15__["default"])()
                        .type(symbolType)
                        .size(size * size)()
                }
            })
    }

    /**
     * @description Appends <rect> elements containing bars for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendBarsToMap(map, sizeData) {
        return (
            map
                .svg()
                .select('#em-prop-symbols')
                .selectAll('g.em-centroid')
                .append('rect')
                .filter((rg) => {
                    const sv = sizeData.get(rg.properties.id)
                    if (sv && sv.value !== ':') return rg
                })
                .attr('width', out.psBarWidth_)
                //for vertical bars we scale the height attribute using the classifier
                .attr('height', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || !sv.value) {
                        return 0
                    }
                    let v = out.classifierSize_(+sv.value)
                    return v
                })
                .attr('transform', function () {
                    let bRect = this.getBoundingClientRect()
                    return `translate(${-this.getAttribute('width') / 2}` + `, -${this.getAttribute('height')})`
                })
            // to use transitions we need to refactor the drawing functions to promises e.g. appendBarsToMap().then(()=>{})
            //this is because .attr('fill___', function () {select(this).style('fill')}) doesnt work unless you execute it after the transition ends.
            // e.g.
            // .transition()
            // .duration(out.transitionDuration())
            // .style('fill', function (rg) {})
            // .end()
            // .then()
        )
    }

    /**
     * @description Appends custom SVG symbols for each region in the map
     * @param {*} map
     * @param {*} sizeData
     * @return {*}
     */
    function appendCustomSymbolsToMap(map, sizeData) {
        return map
            .svg()
            .select('#em-prop-symbols')
            .selectAll('g.em-centroid')
            .append('g')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .html(out.psCustomSVG_)
            .attr('transform', (rg) => {
                //calculate size
                const sv = sizeData.get(rg.properties.id)
                let size = out.classifierSize_(+sv.value)
                if (size) {
                    return `translate(${out.psOffset_.x * size},${out.psOffset_.y * size}) scale(${size})`
                }
            })
    }

    /**
     * @description adds proportional symbols to each regions in a map with mixed NUTS levels (IMAGE)
     * @param {*} map
     * @param {*} sizeData
     * @param {*} regions
     * @return {*}
     */
    function addSymbolsToMixedNUTS(map, sizeData, regions) {
        // toggle display of mixed NUTS levels
        regions.style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sv = sizeData.get(rg.properties.id)
            if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                // no symbol for no data
                return 'none'
            } else if (map.geo_ == 'WORLD') {
                return 'block'
            }
        })

        // nuts border stroke
        regions
            .style('stroke', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])(this)
                const lvl = sel.attr('lvl')
                const stroke = sel.style('stroke')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else {
                    if (lvl !== '0') {
                        return stroke || '#777'
                    }
                }
            })

            // nuts border stroke width
            .style('stroke-width', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])(this)
                const lvl = sel.attr('lvl')
                const strokeWidth = sel.style('stroke-width')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else if (out.geo_ == 'WORLD') {
                    if (lvl !== '0') {
                        return strokeWidth || '#777'
                    }
                }
            })
    }

    //@override
    out.updateStyle = function () {
        // apply to main map
        applyStyleToMap(out)

        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            for (const geo in out.insetTemplates_) {
                if (Array.isArray(out.insetTemplates_[geo])) {
                    for (var i = 0; i < out.insetTemplates_[geo].length; i++) {
                        // insets with same geo that do not share the same parent inset
                        if (Array.isArray(out.insetTemplates_[geo][i])) {
                            // this is the case when there are more than 2 different insets with the same geo. E.g. 3 insets for PT20
                            for (var c = 0; c < out.insetTemplates_[geo][i].length; c++) {
                                if (out.insetTemplates_[geo][i][c].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i][c])
                            }
                        } else {
                            if (out.insetTemplates_[geo][i].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i])
                        }
                    }
                } else {
                    // unique inset geo_
                    if (out.insetTemplates_[geo].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo])
                }
            }
        }

        return out
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun, colorArray) {
    colorFun = colorFun || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}

/**
 * @description give a d3 symbol from a shape name
 */
const symbolsLibrary = {
    cross: d3_shape__WEBPACK_IMPORTED_MODULE_16__["default"],
    square: d3_shape__WEBPACK_IMPORTED_MODULE_17__["default"],
    diamond: d3_shape__WEBPACK_IMPORTED_MODULE_18__["default"],
    triangle: d3_shape__WEBPACK_IMPORTED_MODULE_19__["default"],
    star: d3_shape__WEBPACK_IMPORTED_MODULE_20__["default"],
    wye: d3_shape__WEBPACK_IMPORTED_MODULE_21__["default"],
    circle: d3_shape__WEBPACK_IMPORTED_MODULE_22__["default"],
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunPs = function (region, map) {
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    //stat 1 value
    const v1 = map.statData('size').getArray() ? map.statData('size') : map.statData()
    const sv1 = v1.get(region.properties.id)
    if (!sv1 || (sv1.value != 0 && !sv1.value)) buf.push(map.noDataText_)
    else {
        //unit 1
        const unit1 = v1.unitText()
        buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value)} ${unit1 ? unit1 : ' '}</div>`)
    }

    //stat 2 value
    if (map.statData('color').getArray()) {
        const sv2 = map.statData('color').get(region.properties.id)
        if (!sv2 || (sv2.value != 0 && !sv2.value)) buf.push(map.noDataText_)
        else {
            //stat 2
            const unit2 = map.statData('color').unitText()
            buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value)} ${unit2 ? unit2 : ' '}</div>`)
        }
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-sparklines.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-sparklines.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/create.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_stat_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/stat-data */ "./src/core/stat-data.js");









/**
 * Returns a sparkline map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'spark')

    out.sparkLineColor_ = 'black'
    out.sparkAreaColor_ = '#41afaa'
    out.sparkLineWidth_ = 30
    out.sparkLineHeight_ = 20
    out.sparkLineStrokeWidth_ = 0.4
    out.sparkLineOpacity_ = 0.6
    out.sparkType_ = 'line'
    out.sparkLineCircleRadius_ = 0
    out.sparkTooltipChart_ = {
        width: 100,
        height: 50,
        margin: { left: 60, right: 40, top: 40, bottom: 40 },
        circleRadius: 1.5,
    }

    //show sparklines only when data for all dates is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false
    out.sparkLineChartFunction_ = undefined

    out.statSpark_ = null
    out.sparkHeightClassifier_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'sparkLineColor_',
        'showOnlyWhenComplete_',
        'sparkType_',
        'sparkLineWidth_',
        'sparkLineHeight_',
        'sparkLineStrokeWidth_',
        'sparkLineOpacity_',
        'sparkLineCircleRadius_',
        'sparkLineAreaColor_',
        'sparkTooltipChart_',
        'sparkLineChartFunction_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'sparkLineColor',
            'showOnlyWhenComplete',
            'sparkType',
            'sparkLineWidth',
            'sparkLineHeight',
            'sparkLineStrokeWidth',
            'sparkLineOpacity',
            'sparkLineCircleRadius_',
            'sparkLineAreaColor',
            'sparkTooltipChart_',
            'sparkLineChartFunction_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    // Allow users manually add sparkline data
    out.sparklineData_ = undefined
    out.sparklineData = function (dataObject) {
        const dates = Object.keys(dataObject[Object.keys(dataObject)[0]])
        out._statDates = dates

        dates.forEach((date) => {
            const statData = _core_stat_data__WEBPACK_IMPORTED_MODULE_3__.statData()
            const perDateValues = {}

            for (const regionId in dataObject) {
                const regionValues = dataObject[regionId]
                perDateValues[regionId] = regionValues[date]
            }

            statData.setData(perDateValues)
            out.statData(date, statData)
        })

        return out
    }

    /**
     * A function to define a sparkline map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {Array} dates The dates of the composition (time parameter)
     * @param {Array} labels Optional: The labels for the dates
     */
    out.statSpark = function (stat, dates, labels) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < dates.length; i++) {
            //category code
            const date = dates[i]
            stat.filters.time = date
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(date, sc_)

            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[date] = labels[i]
            }
        }

        //set statCodes
        out._statDates = dates

        return out
    }

    /** The codes of the categories to consider for the composition. */
    out._statDates = undefined

    /**
     * Function to compute composition for region id, for each date.
     * Return an object with, for each date, its statistical value for the region
     * @param {*} id
     * @returns [{date,value}]
     */
    const getComposition = function (id) {
        let comp = [],
            sum = 0

        // Get stat value for each category and compute the sum.
        for (let i = 0; i < out._statDates.length; i++) {
            // Retrieve code and stat value
            const date = out._statDates[i]
            const s = out.statData(date).get(id)

            // Case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp.push({ date: date, value: s.value })
            sum += s.value
        }

        // Case when no data
        if (sum == 0) return undefined

        // Calculate year-on-year percentage change
        for (let i = 1; i < comp.length; i++) {
            const previousValue = comp[i - 1].value
            const currentValue = comp[i].value

            // Calculate percentage change from previous value
            comp[i].percentageChange = previousValue === 0 ? 0.001 : ((currentValue - previousValue) / previousValue) * 100
        }

        // The first data point doesn't have a previous value to compare with
        //comp[0].percentageChange = 0.001 // or you can leave it undefined or null, depending on how you want to handle it

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!out._statDates) {
            //get list of stat codes.
            out._statDates = Object.keys(out.statData_)
            //remove "default", if present
            const index = out._statDates.indexOf('default')
            if (index > -1) out._statDates.splice(index, 1)
        }

        // define size scaling function
        // Define the domain correctly for the log scale
        out.domain = getDatasetMaxMin() // Avoid 0 for log scale

        // for area charts
        out.widthClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__.sqrt)().domain(out.domain).range([0, out.sparkLineWidth_])
        out.heightClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__.sqrt)().domain(out.domain).range([0, out.sparkLineHeight_])

        return out
    }

    //@override
    out.updateStyle = function () {
        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of getting IDs
        let nutsIds = []
        let s = out.svg().selectAll('#em-prop-symbols')
        let sym = s.selectAll('g.em-centroid').attr('id', (rg) => {
            nutsIds.push(rg.properties.id)
            return 'spark_' + rg.properties.id
        })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    sel.attr('fill___', sel.style('fill'))
                    sel.style('fill', out.hoverColor_)
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                }
            })
            .on('mousemove', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                }
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        addSparkLinesToMap(nutsIds)
        return out
    }

    function addSparkLinesToMap(ids) {
        ids.forEach((nutsid) => {
            //create svg for sparkline
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let node = out.svg().select('#spark_' + nutsid)
            let data = getComposition(nutsid)

            if (data) {
                createSparkLineChart(node, data, out.sparkLineWidth_, out.sparkLineHeight_)
            }
        })
    }

    function createSparkLineChart(node, data, width, height, isForTooltip = false) {
        // call custom user function to draw the sparkline
        if (out.sparkLineChartFunction_ && out.sparkLineChartFunction_ !== createSparkLineChart) {
            return out.sparkLineChartFunction_(node, data, width, height, isForTooltip)
        }

        const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])()
            .domain([0, out._statDates.length - 1])
            .range([0.5, width - 0.5])

        const minValue = (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(data.map((d) => d.value)) || 0
        const maxValue = (0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(data.map((d) => d.value)) || 1

        const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])().domain([minValue, maxValue]).range([height, 0])

        const scaledData = data.map((d, i) => ({
            ...d,
            scaledXValue: xScale(i),
            scaledYValue: yScale(d.value),
        }))

        const zeroY = yScale(0)

        if (isForTooltip) {
            // X-axis at bottom
            node.append('g')
                .attr('class', 'axis-x')
                .attr('transform', `translate(0, ${height})`)
                .call(
                    (0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisBottom)(xScale)
                        .ticks(out._statDates.length)
                        .tickFormat((d, i) => out._statDates[i])
                )
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-65)')

            // Y-axis with raw value labels
            node.append('g').attr('class', 'axis-y').call((0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisLeft)(yScale).ticks(5))

            // Horizontal zero reference line → only if min < 0 and max > 0
            if (minValue < 0 && maxValue > 0) {
                node.append('line')
                    .attr('x1', 0)
                    .attr('x2', width)
                    .attr('y1', zeroY)
                    .attr('y2', zeroY)
                    .attr('stroke', 'gray')
                    .attr('stroke-dasharray', '2,2')
                    .attr('stroke-width', 1)
            }
        }

        const lineGenerator = (0,d3_shape__WEBPACK_IMPORTED_MODULE_10__["default"])()
            .x((d) => d.scaledXValue)
            .y((d) => d.scaledYValue)

        if (out.sparkType_ === 'area') {
            node.append('path')
                .datum(scaledData)
                .attr('fill', typeof out.sparkAreaColor_ === 'function' ? (d, i) => out.sparkAreaColor_(d, i) : out.sparkAreaColor_)
                .attr('stroke', 'none')
                .attr('opacity', out.sparkLineOpacity_)
                .attr('fill-opacity', 0.3)
                .attr(
                    'd',
                    (0,d3_shape__WEBPACK_IMPORTED_MODULE_11__["default"])()
                        .x((d) => d.scaledXValue)
                        .y0(zeroY)
                        .y1((d) => d.scaledYValue)
                )
        }

        node.append('path')
            .datum(scaledData)
            .attr('fill', 'none')
            .attr('opacity', out.sparkLineOpacity_)
            .attr('stroke', typeof out.sparkLineColor_ === 'function' ? (d, i) => out.sparkLineColor_(d, i) : out.sparkLineColor_)
            .attr(
                'stroke-width',
                typeof out.sparkLineStrokeWidth_ === 'function' ? (d, i) => out.sparkLineStrokeWidth_(d, i) : out.sparkLineStrokeWidth_ + 'px'
            )
            .attr('d', lineGenerator)

        node.selectAll('circle')
            .data(scaledData)
            .enter()
            .append('circle')
            .attr('cx', (d) => d.scaledXValue)
            .attr('cy', (d) => d.scaledYValue)
            .attr('r', out.sparkLineCircleRadius_)
            .attr('fill', 'red')
            .attr('stroke', 'none')
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (region, map) {
        const buf = []

        const regionName = region.properties.na
        const regionId = region.properties.id
        buf.push(`
                <div class="estat-vis-tooltip-bar">
                    <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
                </div>
            `)

        const chartHeight = out.sparkTooltipChart_.height
        const chartWidth = out.sparkTooltipChart_.width
        const margin = out.sparkTooltipChart_.margin
        const data = getComposition(region.properties.id)

        if (data) {
            // Total SVG size (including margins)
            const totalWidth = chartWidth + margin.left + margin.right
            const totalHeight = chartHeight + margin.top + margin.bottom

            // Create detached div
            const container = (0,d3_selection__WEBPACK_IMPORTED_MODULE_12__["default"])('div').attr('class', 'em-tooltip-chart-container')

            // Create SVG with full size
            const svg = container.append('svg').attr('class', 'em-tooltip-chart-svg').attr('width', totalWidth).attr('height', totalHeight)

            // Inner group where chart is drawn
            const g = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`)

            // Call sparkline drawing on the inner area only
            createSparkLineChart(g, data, chartWidth, chartHeight, true)

            // Add result to tooltip buffer
            buf.push(container.node().outerHTML)
        }

        return buf.join('')
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum values of all dates for each region. Used to define the domain of the sparkline Y axis.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        const maxs = []
        const sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            const id = rg.properties.id
            const regionMax = getRegionMax(id)
            if (regionMax !== undefined) {
                maxs.push(regionMax)
            }
        })

        if (maxs.length === 0) {
            return [0, 1] // fallback if no data found
        }

        return (0,d3_array__WEBPACK_IMPORTED_MODULE_13__["default"])(maxs)
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionMax = function (id) {
        let max = 0

        // get stat value for each date and find the max
        for (let i = 0; i < out._statDates.length; i++) {
            const date = out._statDates[i]
            const statData = out.statData(date)

            if (!statData || typeof statData.get !== 'function') continue

            const s = statData.get(id)
            if (!s || (s.value !== 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                continue
            }

            if (s.value > max) max = s.value
        }

        if (max === 0) return undefined
        return max
    }

    //@override
    out.getLegendConstructor = function () {
        //TODO define legend
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun) {
    colorFun = colorFun || interpolateYlOrRd
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}


/***/ }),

/***/ "./src/maptypes/map-stripe-composition.js":
/*!************************************************!*\
  !*** ./src/maptypes/map-stripe-composition.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-stripe-composition */ "./src/legend/legend-stripe-composition.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



//schemeSet3 schemeDark2 schemePastel1 schemeTableau10



/**
 * Return a stripe composition map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'scomp')

    //width of the stripes serie
    out.stripeWidth_ = 50
    //orientation - vertical by default
    out.stripeOrientation_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    //show stripes only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    //tooltip pie chart
    out.pieChartRadius_ = 40
    out.pieChartInnerRadius_ = 15

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'stripeWidth_',
        'stripeOrientation_',
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieChartRadius_',
        'pieChartInnerRadius_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'stripeWidth',
            'stripeOrientation',
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieChartRadius',
            'pieChartInnerRadius',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /**
     * A function to define a stripe map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     */
    out.statComp = function (stat, dim, codes, labels, colors) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set statCodes
        statCodes = codes

        return out
    }

    /** The codes of the categories to consider for the composition. */
    let statCodes = undefined

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < statCodes.length; i++) {
            //retrieve code and stat value
            const sc = statCodes[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < statCodes.length; i++) comp[statCodes[i]] /= sum

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!statCodes) {
            //get list of stat codes.
            statCodes = Object.keys(out.statData_)
            //remove "default", if present
            const index = statCodes.indexOf('default')
            if (index > -1) statCodes.splice(index, 1)
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors()) {
            out.catColors({})
            for (let i = 0; i < statCodes.length; i++) out.catColors()[statCodes[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign texture to the regions
        out.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out))
            .style('fill', function (d) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const id = d.properties.id

                //compute composition
                const composition = getComposition(id)

                //case when no or missing data
                if (!composition) return out.noDataFillStyle() || 'gray'

                //make stripe pattern
                const patt = out
                    .svg()
                    .append('pattern')
                    .attr('id', 'pattern_' + id)
                    .attr('x', '0')
                    .attr('y', '0')
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .attr('patternUnits', 'userSpaceOnUse')
                //use orientation, if specified
                if (out.stripeOrientation()) patt.attr('patternTransform', 'rotate(' + out.stripeOrientation() + ')')

                //background
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .style('stroke', 'none')
                    .style('fill', 'lightgray')

                //make stripes, one per category
                let x = 0
                for (let code in composition) {
                    //get stripe size
                    let dx = composition[code]
                    if (!dx) continue
                    dx *= out.stripeWidth()

                    //get stripe color
                    const col = out.catColors()[code] || 'lightgray'

                    //add stripe to pattern: a thin rectangle
                    patt.append('rect')
                        .attr('x', x)
                        .attr('y', 0)
                        .attr('height', 1)
                        .style('stroke', 'none')
                        .attr('code', code)
                        .style('fill', col)
                        //transition along x
                        .transition()
                        .duration(out.transitionDuration())
                        .attr('width', dx)
                    x += dx
                }

                //return pattern reference
                return 'url(#pattern_' + id + ')'
            })
            .attr('nd', function (d) {
                return !getComposition(d.properties.id) ? 'nd' : ''
            })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        return out
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        //write region name
        const regionName = rg.properties.na || rg.properties.name
        if (rg.properties.id) {
            //name and code
            tp.append('div').html('<b>' + regionName + '</b> (' + rg.properties.id + ') <br>')
        } else {
            //region name
            tp.append('div').html('<b>' + regionName + '</b><br>')
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        const r = out.pieChartRadius(),
            ir = out.pieChartInnerRadius()
        const svg = tp
            .append('svg')
            .attr('viewBox', [-r, -r, 2 * r, 2 * r])
            .attr('width', 2 * r)

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_5__["default"])()
            .sort(null)
            .value((d) => d.value)
        svg.append('g')
            .attr('stroke', 'darkgray')
            .selectAll('path')
            .data(pie_(data))
            .join('path')
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().innerRadius(ir).outerRadius(r))
    }

    return out
}


/***/ }),

/***/ "./src/tooltip/tooltip.js":
/*!********************************!*\
  !*** ./src/tooltip/tooltip.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tooltip: () => (/* binding */ tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * @param {*} config
 * @returns
 */
const tooltip = function (config) {
    config = config || {}
    config.containerId = config.containerId || 'map'
    config.div = config.div || 'tooltip_eurostat'
    config.maxWidth = config.maxWidth || '200px'
    config.fontSize = config.fontSize || '14px'
    config.background = config.background || 'white'
    config.padding = config.padding || '0px'
    config.border = config.border || '0px'
    config.borderRadius = config.borderRadius || '0px'
    config.boxShadow = config.boxShadow || '0px 0px 0px grey'

    config.transitionDuration = config.transitionDuration || 0
    config.xOffset = config.xOffset || 30
    config.yOffset = config.yOffset || 20

    let tooltip

    function my() {
        tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + config.div)
        if (tooltip.empty()) tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('body').append('div').attr('id', config.div)

        tooltip.attr('class', 'tooltip-eurostat')
    }

    my.mouseover = function (html) {
        if (html) tooltip.html(html)
        let x = event.pageX
        let y = event.pageY
        my.ensureTooltipOnScreen(x, y)
    }

    my.mousemove = function (event) {
        let x = event.pageX
        let y = event.pageY
        this.ensureTooltipOnScreen(x, y)
    }

    my.mouseout = function () {
        tooltip.style('opacity', 0)
    }

    my.style = function (k, v) {
        if (arguments.length == 1) return tooltip.style(k)
        tooltip.style(k, v)
        return my
    }

    my.attr = function (k, v) {
        if (arguments.length == 1) return tooltip.attr(k)
        tooltip.attr(k, v)
        return my
    }

    /**
     * @function ensureTooltipOnScreen
     * @description Prevents the tooltip from overflowing off screen
     */
    my.ensureTooltipOnScreen = function (eventX, eventY) {
        tooltip.style('opacity', 1)
        let node = tooltip.node()

        node.style.left = eventX + config.xOffset + 'px'
        node.style.top = eventY - config.yOffset + 'px'

        let parent = document.getElementById(config.containerId)
        let rect = parent.getBoundingClientRect() // get the bounding rectangle
        let parentWidth = rect.width
        let parentHeight = rect.height

        //too far right
        //taking into account off screen space but shouldnt be
        if (node.offsetLeft > rect.left + parentWidth - node.clientWidth) {
            let left = eventX - node.clientWidth - config.xOffset
            node.style.left = left + 'px'
            // check if mouse covers tooltip
            if (node.offsetLeft + node.clientWidth > eventX) {
                //move tooltip left so it doesnt cover mouse
                let left2 = eventX - node.clientWidth - config.xOffset
                node.style.left = left2 + 'px'
            }
            // node.style.top = node.offsetTop + config.yOffset + "px";
        }

        //too far down
        if (node.offsetTop + node.clientHeight > rect.top + parentHeight) {
            node.style.top = node.offsetTop - node.clientHeight + 'px'
        }
    }

    my()
    return my
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.map),
/* harmony export */   version: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.version)
/* harmony export */ });
/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/index.css */ "./src/css/index.css");
/* harmony import */ var _eurostat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eurostat-map */ "./src/eurostat-map.js");


//export { statData } from "./core/stat-data.js";

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXVyb3N0YXRtYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQzZHO0FBQ2pCO0FBQzVGLDhCQUE4QixtRkFBMkIsQ0FBQyw0RkFBcUM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixPQUFPLDBGQUEwRixhQUFhLFFBQVEsVUFBVSxPQUFPLFFBQVEsVUFBVSxPQUFPLFlBQVksTUFBTSxVQUFVLE1BQU0sWUFBWSxZQUFZLE9BQU8sWUFBWSxtQkFBbUIsWUFBWSxhQUFhLE9BQU8sWUFBWSxNQUFNLFVBQVUsWUFBWSxPQUFPLFlBQVksV0FBVyxVQUFVLE9BQU8sWUFBWSxNQUFNLFVBQVUsT0FBTyxVQUFVLEtBQUssVUFBVSxZQUFZLFNBQVMsWUFBWSxjQUFjLFVBQVUsTUFBTSxZQUFZLE9BQU8sa0pBQWtKLHNCQUFzQixLQUFLLHlFQUF5RSx3QkFBd0IsS0FBSyxvREFBb0QscUJBQXFCLEtBQUssb1BBQW9QLDBCQUEwQixLQUFLLHFTQUFxUyw4QkFBOEIsK0JBQStCLEtBQUssZ0RBQWdELHFCQUFxQiw0QkFBNEIsS0FBSyw2SkFBNkosd0JBQXdCLEtBQUssK0NBQStDLHNCQUFzQixLQUFLLHVDQUF1QyxxQkFBcUIsMkJBQTJCLEtBQUssbUxBQW1MLG1CQUFtQixLQUFLLDRIQUE0SCx3QkFBd0IsTUFBTSx5QkFBeUI7QUFDcHlFO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0R3ZDO0FBQzZHO0FBQ2pCO0FBQzVGLDhCQUE4QixtRkFBMkIsQ0FBQyw0RkFBcUM7QUFDL0Y7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU8sMEZBQTBGLFlBQVksZ0RBQWdELGlDQUFpQyxPQUFPLHVCQUF1QjtBQUM1TjtBQUNBLGlFQUFlLHVCQUF1QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1Z2QztBQUM2RztBQUNqQjtBQUNVO0FBQ0k7QUFDRDtBQUNBO0FBQ0s7QUFDUDtBQUNDO0FBQ3hHLDhCQUE4QixtRkFBMkIsQ0FBQyw0RkFBcUM7QUFDL0YsMEJBQTBCLG9GQUFpQztBQUMzRCwwQkFBMEIsd0ZBQWlDO0FBQzNELDBCQUEwQix1RkFBaUM7QUFDM0QsMEJBQTBCLHVGQUFpQztBQUMzRCwwQkFBMEIsNEZBQWlDO0FBQzNELDBCQUEwQixxRkFBaUM7QUFDM0QsMEJBQTBCLHNGQUFpQztBQUMzRDtBQUNBO0FBQ0EsT0FBTyxrRUFBa0U7QUFDekU7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCdkM7QUFDNkc7QUFDakI7QUFDNUYsOEJBQThCLG1GQUEyQixDQUFDLDRGQUFxQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxRkFBcUYsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLFVBQVUsWUFBWSxXQUFXLE1BQU0sS0FBSyxVQUFVLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsc0NBQXNDLDRCQUE0QiwrQkFBK0Isa0RBQWtELG1DQUFtQyxLQUFLLG1CQUFtQix3QkFBd0IsS0FBSywwQkFBMEIsc0JBQXNCLDZCQUE2QixLQUFLLHNCQUFzQix3QkFBd0IsMEJBQTBCLHNCQUFzQixLQUFLLG9CQUFvQixtQkFBbUIsd0JBQXdCLDBCQUEwQixzQkFBc0IsMEJBQTBCLEtBQUssMkJBQTJCLG1CQUFtQix3QkFBd0IsMEJBQTBCLHNCQUFzQixLQUFLLGtCQUFrQix3QkFBd0Isd0JBQXdCLDRCQUE0QixLQUFLLHlCQUF5Qix3QkFBd0Isc0JBQXNCLDBCQUEwQixLQUFLLHlCQUF5Qix3QkFBd0Isd0JBQXdCLDRCQUE0QixLQUFLLGdDQUFnQyx3QkFBd0Isc0JBQXNCLDBCQUEwQixLQUFLLG9CQUFvQix1QkFBdUIsc0JBQXNCLHdCQUF3Qiw0QkFBNEIsNEJBQTRCLEtBQUssMkJBQTJCLHVCQUF1Qiw0QkFBNEIsc0JBQXNCLDBCQUEwQixLQUFLLHlCQUF5Qiw0QkFBNEIsK0JBQStCLGtEQUFrRCxtQ0FBbUMsS0FBSyxvQkFBb0Isd0JBQXdCLG9CQUFvQiwwQkFBMEIsS0FBSywyQkFBMkIsd0JBQXdCLDBCQUEwQixzQkFBc0IsS0FBSyx1QkFBdUI7QUFDcGhGO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RnZDO0FBQzZHO0FBQ2pCO0FBQzVGLDhCQUE4QixtRkFBMkIsQ0FBQyw0RkFBcUM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUZBQXFGLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFlBQVksV0FBVyxNQUFNLE1BQU0sVUFBVSxVQUFVLE9BQU8sTUFBTSxVQUFVLFVBQVUsTUFBTSxLQUFLLFlBQVksV0FBVyxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssVUFBVSxpREFBaUQsb0JBQW9CLHFCQUFxQixjQUFjLGNBQWMsNkJBQTZCLEtBQUssc0JBQXNCLHdCQUF3QixxQkFBcUIsb0JBQW9CLGlDQUFpQyxLQUFLLHNCQUFzQix3QkFBd0Isb0JBQW9CLEtBQUssMEJBQTBCLHNCQUFzQix3QkFBd0IsS0FBSyxxQkFBcUIsd0JBQXdCLHdCQUF3QixLQUFLLHlCQUF5QixtQkFBbUIsc0JBQXNCLEtBQUssMEJBQTBCLHNCQUFzQiwwQkFBMEIsd0JBQXdCLEtBQUssOEJBQThCLHdCQUF3QixLQUFLLGdDQUFnQyx3QkFBd0Isa0NBQWtDLEtBQUssd0JBQXdCLHNCQUFzQix3QkFBd0IsS0FBSyw4QkFBOEIsNEJBQTRCLHdCQUF3QixLQUFLLDhDQUE4Qyx3QkFBd0Isc0JBQXNCLEtBQUssOERBQThELHdCQUF3QixvQkFBb0IsS0FBSyxrQ0FBa0MsNEJBQTRCLHFCQUFxQixLQUFLLG1DQUFtQyxzQkFBc0IsS0FBSyxrQ0FBa0Msd0JBQXdCLEtBQUssdUJBQXVCO0FBQzNnRTtBQUNBLGlFQUFlLHVCQUF1QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEZ2QztBQUM2RztBQUNqQjtBQUM1Riw4QkFBOEIsbUZBQTJCLENBQUMsNEZBQXFDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlGQUF5RixNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxVQUFVLE1BQU0sWUFBWSxPQUFPLFlBQVksTUFBTSxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxPQUFPLFlBQVksT0FBTyxVQUFVLFVBQVUsT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssVUFBVSxPQUFPLE1BQU0sVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFNLFdBQVcsa0RBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGFBQWEsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZO0FBQ3JEOztBQUVBO0FBQ0EsYUFBYSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxvREFBb0Q7QUFDM0c7O0FBRUE7QUFDQTtBQUNBLFlBQVksMkJBQTJCLEVBQUUsZUFBZSxJQUFJLGVBQWUsSUFBSSxlQUFlLEVBQUUscUJBQXFCLEVBQUUsR0FBRztBQUMxSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQU0sV0FBVyxrREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQixFQUFFLGVBQWUsSUFBSSxxQkFBcUIsS0FBSyxxQkFBcUIsR0FBRyxxQkFBcUIsRUFBRSxHQUFHO0FBQzFJO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzWUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVDJDO0FBQ087QUFDUDs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBRyxPQUFPLHFEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQU0sV0FBVyxrREFBTSxDQUFDLDRDQUFLO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQU87QUFDeEM7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFPO0FBQ3ZCO0FBQ0E7O0FBRUEsc0RBQU0sV0FBVyxrREFBTSxDQUFDLDRDQUFLO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDMUhNO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0RQLFlBQVk7O0FBRVo7QUFDQSw4Q0FBOEMsS0FBSyxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUZBQW1GLE9BQU87QUFDMUY7QUFDQSxnREFBZ0QsT0FBTztBQUN2RCxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25GWTtBQUNvQjs7QUFFeEQsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQSxrQkFBa0Isd0RBQU0sNEJBQTRCLG1EQUFPLEVBQUUsMERBQWlCO0FBQzlFO0FBQ0EscUNBQXFDLG1EQUFPLEVBQUUsMERBQWlCO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esa0JBQWtCLHdEQUFNO0FBQ3hCO0FBQ0EsK0JBQStCLG1EQUFPLEVBQUUsMERBQWlCO0FBQ3pELDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNPLG9CQUFvQjtBQUNwQiwyQkFBMkI7O0FBRTNCO0FBQ1A7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaMkI7O0FBRTNCLFVBQVUsbURBQUc7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1ZQLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsR0FBRyxnQkFBZ0I7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbksyQjs7QUFFM0IsVUFBVSxtREFBRzs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVnFEO0FBQ3hCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFJO0FBQ2Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFZTtBQUNmO0FBQ0EsZUFBZSxrREFBUztBQUN4QixTQUFTLG9EQUFJO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7O0FBRU8sbUJBQW1CLDRDQUFRO0FBQzNCLG1CQUFtQiw0Q0FBUTs7Ozs7Ozs7Ozs7Ozs7O0FDckJsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1BxQztBQUNBO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsd0RBQVE7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQyxhQUFhLHVEQUFRO0FBQ3JCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQU07QUFDbkMsNkJBQTZCLHNEQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSx3REFBUTtBQUM5RTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNuR0EsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0pBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEIsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1JxQztBQUNOO0FBQ0o7O0FBRXBCO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBSztBQUNyQixjQUFjLHVEQUFRO0FBQ3RCLGVBQWUsbURBQUc7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSnFDOztBQUVyQyw2QkFBZSxvQ0FBUztBQUN4QixpQkFBaUIsd0RBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx3REFBUTs7QUFFM0M7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RSx3REFBUTtBQUNoRjs7QUFFQTtBQUNBLGlFQUFpRSx3REFBUTtBQUN6RTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeENxQzs7QUFFckMsNkJBQWUsb0NBQVM7QUFDeEIsaUJBQWlCLHdEQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsd0RBQVE7O0FBRTNDO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0Usd0RBQVE7QUFDaEY7O0FBRUE7QUFDQSxpRUFBaUUsd0RBQVE7QUFDekU7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEN1Qzs7QUFFdkM7QUFDTztBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFYztBQUNmLFdBQVcsc0RBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQnNEOztBQUV0RCw2QkFBZSxvQ0FBUztBQUN4QixhQUFhLHFFQUFrQjtBQUMvQjs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0dBQWdHO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNuQkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOc0Q7O0FBRS9DOztBQUVQLDZCQUFlLG9DQUFTO0FBQ3hCLFVBQVUscUVBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUVBQWtCLGdDQUFnQztBQUM5Rjs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZzRDs7QUFFdEQsNkJBQWUsb0NBQVM7QUFDeEIsVUFBVSxxRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsdURBQXVEOztBQUVoRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQSw2QkFBZSxvQ0FBUztBQUN4QixrREFBa0QsT0FBTztBQUN6RDtBQUNBLDZCQUE2QjtBQUM3QixzQ0FBc0MsUUFBUTtBQUM5QyxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWK0M7QUFDTTtBQUNOOztBQUUvQyxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLE9BQU8seURBQWE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQWE7QUFDOUIsT0FBTyx5REFBYTtBQUNwQixPQUFPLDREQUFnQjtBQUN2QjtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNsQkYsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGcUM7QUFDTTtBQUNNO0FBQ0U7QUFDVjtBQUNFO0FBQ1U7QUFDaEI7O0FBRXJDO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEIsZ0ZBQWdGLG9EQUFRLEdBQUcsMkRBQVc7QUFDdEc7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9EQUFRLEdBQUcsOERBQWM7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLCtEQUFlOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1REFBVzs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdURBQVc7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiwwREFBVTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELGdFQUFjOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsdUVBQXVFO0FBQ3ZFLHNJQUFzSTtBQUN0SSxzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQywrREFBZTtBQUNsRCxnREFBZ0Qsd0RBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSnFDOztBQUVyQyw2QkFBZSxvQ0FBUztBQUN4QixzQkFBc0Isd0RBQVE7QUFDOUI7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKcUM7O0FBRXJDLDZCQUFlLG9DQUFTO0FBQ3hCLHlEQUF5RCx3REFBUSxxQkFBcUIsd0RBQVE7QUFDOUY7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKcUM7O0FBRXJDLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0EscUJBQXFCLHdEQUFRLFFBQVEsd0RBQVE7QUFDN0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTEE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSc0Q7O0FBRS9DO0FBQ1AsVUFBVSwrQ0FBSyw4QkFBOEIsOENBQUk7QUFDakQ7O0FBRU87QUFDUCwwREFBMEQsNkNBQUc7QUFDN0QsbUJBQW1CLDZDQUFHLG1CQUFtQiw2Q0FBRyxVQUFVLDZDQUFHO0FBQ3pEOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUCxVQUFVLDhDQUFJO0FBQ2Q7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQytFO0FBQzFDO0FBQ29DO0FBQzdCOztBQUU1QztBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsNkNBQUc7QUFDckIsa0JBQWtCLDZDQUFHO0FBQ3JCO0FBQ0E7QUFDQSw4QkFBOEIseUNBQUc7QUFDakM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDZEQUE2RCx5Q0FBRztBQUNoRTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0QsWUFBWSx3REFBUywwQkFBMEIsNkNBQUcsa0JBQWtCLDZDQUFHO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx3REFBUztBQUNuQixFQUFFLHdFQUF5QjtBQUMzQixlQUFlLDhDQUFJO0FBQ25CLCtDQUErQyx5Q0FBRyxHQUFHLDZDQUFPLElBQUkseUNBQUc7QUFDbkU7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUIsZUFBZSx3REFBUTtBQUN2QixlQUFlLHdEQUFRO0FBQ3ZCLGtCQUFrQix3REFBUTtBQUMxQjtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EsWUFBWSw2Q0FBTyxVQUFVLDZDQUFPO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsNkNBQU87QUFDbkQsK0NBQStDLDZDQUFPO0FBQ3REO0FBQ0EsYUFBYSwyREFBYSxTQUFTLDZDQUFPLFVBQVUsNkNBQU87QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLHdEQUFRO0FBQzlFOztBQUVBO0FBQ0Esc0VBQXNFLHdEQUFRO0FBQzlFOztBQUVBO0FBQ0EseUVBQXlFLHdEQUFRO0FBQ2pGOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkU4QjtBQUNzQzs7QUFFcEUsaUVBQWUscURBQUk7QUFDbkIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxJQUFJLHdDQUFFLEdBQUcsNENBQU07QUFDZixDQUFDLEVBQUM7O0FBRUY7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLHdDQUFFLElBQUksd0NBQUU7QUFDeEMsa0JBQWtCLDZDQUFHO0FBQ3JCLFVBQVUsNkNBQUcsU0FBUyx3Q0FBRSxJQUFJLDZDQUFPLElBQUk7QUFDdkMsNkRBQTZELDRDQUFNLElBQUksNENBQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQ0FBcUMsd0NBQUUsSUFBSTtBQUNuRCxZQUFZLDZDQUFHLG9CQUFvQiw2Q0FBTyxxQkFBcUIsNkNBQU8sRUFBRTtBQUN4RSxZQUFZLDZDQUFHLG9CQUFvQiw2Q0FBTyxxQkFBcUIsNkNBQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFHO0FBQzdCLFNBQVMsNkNBQUcsc0JBQXNCLDZDQUFPO0FBQ3pDLFFBQVEsOENBQUksRUFBRSw2Q0FBRyxvQkFBb0IsNkNBQUcsVUFBVSw2Q0FBRztBQUNyRCxZQUFZLDZDQUFHLG9CQUFvQiw2Q0FBRyxVQUFVLDZDQUFHO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQU07QUFDNUIsa0JBQWtCLHdDQUFFO0FBQ3BCO0FBQ0EsaUJBQWlCLHdDQUFFO0FBQ25CLGlCQUFpQix3Q0FBRTtBQUNuQixpQkFBaUIsd0NBQUU7QUFDbkI7QUFDQSxrQkFBa0Isd0NBQUU7QUFDcEIsa0JBQWtCLHdDQUFFO0FBQ3BCLGtCQUFrQix3Q0FBRTtBQUNwQixJQUFJLFNBQVMsNkNBQUcsb0JBQW9CLDZDQUFPO0FBQzNDLG1DQUFtQyx3Q0FBRSxJQUFJLHdDQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzNGOEI7O0FBRTlCLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLGdEQUFJO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QndIO0FBQzlFO0FBQ3NCO0FBQ3RCO0FBQ1o7O0FBRTlCLDZCQUFlLG9DQUFTO0FBQ3hCLFdBQVcsNkNBQUc7QUFDZCxrQkFBa0IsNkNBQU87QUFDekI7QUFDQSxzQkFBc0IsNkNBQUcsT0FBTyw2Q0FBTyxFQUFFOztBQUV6QztBQUNBLElBQUksd0RBQVk7QUFDaEI7O0FBRUE7QUFDQSxXQUFXLDZDQUFHLFdBQVcsNkNBQUc7QUFDNUI7O0FBRUE7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHdDQUFFLElBQUksd0NBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFVLG9CQUFvQiwwREFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0RBQVM7QUFDdEIsYUFBYSx3REFBUzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2REFBYztBQUMzQixlQUFlLDJEQUFZO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFjO0FBQzlCLFlBQVksNkRBQWM7QUFDMUIsWUFBWSw2REFBYztBQUMxQixJQUFJLGtFQUFtQjs7QUFFdkI7QUFDQTtBQUNBLFlBQVksMkRBQVk7QUFDeEIsYUFBYSwyREFBWTtBQUN6QiwyQkFBMkIsMkRBQVk7O0FBRXZDOztBQUVBLFlBQVksOENBQUk7QUFDaEIsWUFBWSw2REFBYztBQUMxQixJQUFJLGtFQUFtQjtBQUN2QixRQUFRLHdEQUFTOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsNkNBQUcsU0FBUyx3Q0FBRSxJQUFJLDZDQUFPO0FBQ3pDLG9DQUFvQyw2Q0FBTzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUFHLG1CQUFtQiw2Q0FBTztBQUNuRTtBQUNBLGtCQUFrQix3Q0FBRTtBQUNwQixlQUFlLDZEQUFjO0FBQzdCLE1BQU0sa0VBQW1CO0FBQ3pCLGlCQUFpQix3REFBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3Q0FBRTtBQUNyQztBQUNBLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLFNBQVMscURBQUksZ0VBQWdFLHdDQUFFLFdBQVcsd0NBQUU7QUFDNUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaExxQztBQUNBO0FBQ007QUFDUztBQUNyQjs7QUFFL0IsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQixzREFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFLO0FBQ3hCLDBCQUEwQiwrREFBZTtBQUN6QztBQUNBO0FBQ0EsVUFBVSxzREFBVTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0Q0FBTSxHQUFHLDZDQUFPLEdBQUcsNENBQU07QUFDN0Qsb0NBQW9DLDRDQUFNLEdBQUcsNkNBQU8sR0FBRyw0Q0FBTTtBQUM3RDs7Ozs7Ozs7Ozs7Ozs7O0FDbElBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFEd0M7QUFDSDtBQUNKO0FBQ0k7QUFDTjs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw2Q0FBRyxjQUFjLDZDQUFPO0FBQ25DLFVBQVUsNkNBQUcsY0FBYyw2Q0FBTztBQUNsQyxVQUFVLDZDQUFHLGNBQWMsNkNBQU87QUFDbEMsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzREFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRCxtSEFBbUgsT0FBTztBQUMxSDtBQUNBLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvREFBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkswQztBQUNQOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVEsMERBQVU7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUFPO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLE9BQU87QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdEdBLDZCQUFlLG9DQUFTOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1hBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNKQSxpRUFBZSxNQUFNLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbkNlOzs7Ozs7Ozs7Ozs7Ozs7O0FDQWU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdEQUFJO0FBQ2pCLFdBQVcsZ0RBQUk7QUFDZixnQkFBZ0IsZ0RBQUk7QUFDcEIsY0FBYyxnREFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQzNCVzs7QUFFdkMsNkJBQWUsb0NBQVM7QUFDeEIsU0FBUyw2Q0FBRyxnQkFBZ0IsNkNBQU8sSUFBSSw2Q0FBRyxnQkFBZ0IsNkNBQU87QUFDakU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0orQjtBQUNxRDtBQUNzQjs7QUFFMUc7QUFDQSxNQUFNLDZDQUFHLGNBQWMsd0NBQUU7QUFDekI7QUFDQTtBQUNBLFdBQVcsOENBQUksZUFBZSw2Q0FBRyxhQUFhLHdDQUFFLElBQUkseUNBQUcsR0FBRyx3Q0FBRTtBQUM1RDs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSw2Q0FBRztBQUNsQixnQkFBZ0IsNkNBQUcsV0FBVyw2Q0FBRztBQUNqQztBQUNBOztBQUVBLGdCQUFnQiwyQ0FBSzs7QUFFckIsMEJBQTBCLDRDQUFNLEdBQUcsNkNBQU87QUFDMUMsaUNBQWlDLDRDQUFNLEdBQUcsNkNBQU87O0FBRWpELHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0NBQVM7QUFDeEMsa0JBQWtCLDZDQUFHO0FBQ3JCLGtCQUFrQiw2Q0FBRzs7QUFFckIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLGlDQUFpQywrQ0FBUztBQUMxQyxvQkFBb0IsNkNBQUc7QUFDdkIsb0JBQW9CLDZDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBRTtBQUN0Qzs7QUFFQSxjQUFjLCtDQUFLLFlBQVksNkNBQUcsb0NBQW9DLDZDQUFHO0FBQ3pFLDZDQUE2Qyx5Q0FBRzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZEQUFjLENBQUMsd0RBQVMsVUFBVSx3REFBUztBQUM3RCxRQUFRLHdFQUF5QjtBQUNqQywyQkFBMkIsNkRBQWM7QUFDekMsUUFBUSx3RUFBeUI7QUFDakMsNERBQTRELDhDQUFJO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNkNBQU8sWUFBWSw2Q0FBTyxXQUFXLDhDQUFRO0FBQ2hFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVFa0Q7QUFDTDs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNEQUFTLDJCQUEyQix1REFBWTtBQUNsRCxZQUFZLHVEQUFZO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Q3VEO0FBQ1o7QUFDTTtBQUNiO0FBQ0U7QUFDc0I7QUFDZjtBQUNEO0FBQ3FCO0FBQzVCOztBQUVyQyx1QkFBdUIsMERBQVc7QUFDbEM7QUFDQSwwQkFBMEIsNkNBQU8sTUFBTSw2Q0FBTztBQUM5QztBQUNBLENBQUM7O0FBRUQ7QUFDQSxTQUFTLDBEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBRztBQUNwQixpQkFBaUIsNkNBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZix3Q0FBd0MsaUJBQWlCO0FBQ3pEOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2REFBZ0I7QUFDOUMsd0NBQXdDLG9EQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyw2Q0FBTyxhQUFhLDZDQUFPO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQU8sYUFBYSw2Q0FBTztBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QywyREFBVSxhQUFhLDZDQUFPLG1CQUFtQiw2REFBZ0Isc0JBQXNCLDZDQUFPO0FBQzVJOztBQUVBO0FBQ0EsaUZBQWlGLG9EQUFRLElBQUksOERBQWE7QUFDMUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCw2Q0FBTyxxQkFBcUIsNkNBQU8sMEJBQTBCLDZDQUFPLFFBQVEsNkNBQU87QUFDeEk7O0FBRUE7QUFDQSwwREFBMEQsNkNBQU8sMEJBQTBCLDZDQUFPLDJDQUEyQyw2Q0FBTyxtQ0FBbUMsNkNBQU8sYUFBYSw2Q0FBTyxlQUFlLDZDQUFPO0FBQ3hPOztBQUVBO0FBQ0EsaURBQWlELDZDQUFPLHdCQUF3Qiw2Q0FBTztBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELHdEQUFRLCtDQUErQyw4Q0FBSTtBQUM1Rzs7QUFFQTtBQUNBLFdBQVcsa0RBQVM7QUFDcEI7O0FBRUE7QUFDQSxXQUFXLGdEQUFPO0FBQ2xCOztBQUVBO0FBQ0EsV0FBVyxpREFBUTtBQUNuQjs7QUFFQTtBQUNBLFdBQVcsa0RBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBYTtBQUMxQix1QkFBdUIsdURBQU87QUFDOUIsNkJBQTZCLHVEQUFPO0FBQ3BDLHNCQUFzQix3REFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEwwQztBQUMrQjtBQUM3Qjs7QUFFNUM7QUFDQSxxQkFBcUIsNkNBQUcsTUFBTSw2Q0FBTyxHQUFHOztBQUV4Qyw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsU0FBUywwREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBSTtBQUNsQixpQkFBaUIsOENBQUk7QUFDckIsb0JBQW9CLDZDQUFHLENBQUMsNkNBQUcsV0FBVyw2Q0FBTyxJQUFJLDZDQUFHLHNCQUFzQiw2Q0FBTyw2QkFBNkIsK0NBQUs7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZDQUFHO0FBQ2hCLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUIsdUNBQXVDO0FBQy9GLCtCQUErQixxQkFBcUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsd0RBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JHbUM7QUFDNkM7O0FBRWhGO0FBQ0EsVUFBVSw2Q0FBRyxXQUFXLHdDQUFFLGlDQUFpQyx5Q0FBRyxJQUFJLHlDQUFHO0FBQ3JFOztBQUVBOztBQUVPO0FBQ1AseUJBQXlCLHlDQUFHLDhCQUE4Qix1REFBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLHdDQUFFLFlBQVkseUNBQUcsYUFBYSx3Q0FBRSxZQUFZLHlDQUFHO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw2Q0FBRztBQUN2QixvQkFBb0IsNkNBQUc7QUFDdkIsc0JBQXNCLDZDQUFHO0FBQ3pCLHNCQUFzQiw2Q0FBRzs7QUFFekI7QUFDQSxpQkFBaUIsNkNBQUc7QUFDcEIsWUFBWSw2Q0FBRztBQUNmLFlBQVksNkNBQUc7QUFDZixZQUFZLDZDQUFHO0FBQ2Y7QUFDQTtBQUNBLE1BQU0sK0NBQUs7QUFDWCxNQUFNLDhDQUFJO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw2Q0FBRztBQUNwQixZQUFZLDZDQUFHO0FBQ2YsWUFBWSw2Q0FBRztBQUNmLFlBQVksNkNBQUc7QUFDZjtBQUNBO0FBQ0EsTUFBTSwrQ0FBSztBQUNYLE1BQU0sOENBQUk7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEIscUNBQXFDLDZDQUFPLGNBQWMsNkNBQU8sa0NBQWtDLDZDQUFPOztBQUUxRztBQUNBLDBDQUEwQyw2Q0FBTyxtQkFBbUIsNkNBQU87QUFDM0UsNkJBQTZCLDZDQUFPLG9CQUFvQiw2Q0FBTztBQUMvRDs7QUFFQTtBQUNBLGlEQUFpRCw2Q0FBTyxtQkFBbUIsNkNBQU87QUFDbEYsNkJBQTZCLDZDQUFPLG9CQUFvQiw2Q0FBTztBQUMvRDs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRCx1QkFBdUIsdUJBQXVCO0FBQzlDLDBCQUEwQiwwQkFBMEI7QUFDcEQsd0JBQXdCLHdCQUF3QjtBQUNoRCw2QkFBNkIsNkJBQTZCO0FBQzFELDJCQUEyQjtBQUMzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9EbUQ7QUFDb0M7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1AsVUFBVSw2Q0FBRyxLQUFLLDZDQUFHLGFBQWEsd0NBQUU7QUFDcEMsV0FBVywrQ0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBTSxJQUFJLDRDQUFNO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDRDQUFNO0FBQ3JCO0FBQ0EsVUFBVSw2Q0FBRyxLQUFLLDZDQUFHO0FBQ3JCLFdBQVcsNkNBQUcsSUFBSSwrQ0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFHO0FBQ2xCO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBRyxLQUFLLDZDQUFHO0FBQ3ZCLGFBQWEsK0NBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBRztBQUNsQixrQ0FBa0MsNENBQU0sSUFBSSw0Q0FBTSx3RUFBd0UsNkNBQU87QUFDakksUUFBUSxPQUFPLDZDQUFHLFVBQVUsOENBQVE7QUFDcEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsYUFBYSw2Q0FBRztBQUNoQjtBQUNBO0FBQ0EsVUFBVSw2Q0FBTztBQUNqQjtBQUNBOztBQUVBLDZCQUFlLHNDQUFXO0FBQzFCLFNBQVMsa0RBQVU7QUFDbkI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hGK0I7QUFDbUU7QUFDckU7QUFDSTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSxVQUFVLGdEQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksNkNBQU8sU0FBUyw2Q0FBTztBQUNuQyxlQUFlLDZDQUFHO0FBQ2xCLGtDQUFrQyw2Q0FBRyxtQkFBbUIsNkNBQUcsVUFBVSw2Q0FBRztBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DLGVBQWUsNkNBQUc7QUFDbEIsZ0JBQWdCLDZDQUFHO0FBQ25CLGdCQUFnQiw2Q0FBRztBQUNuQixPQUFPLDZDQUFHO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DLGVBQWUsNkNBQUc7QUFDbEIsbUJBQW1CLDZDQUFHO0FBQ3RCLG1CQUFtQiw2Q0FBRztBQUN0QixVQUFVLDZDQUFHO0FBQ2IsVUFBVSwrQ0FBSyxDQUFDLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DO0FBQ0EsZUFBZSw2Q0FBRztBQUNsQixnQkFBZ0IsNkNBQUc7QUFDbkIsZ0JBQWdCLDZDQUFHO0FBQ25CLE9BQU8sNkNBQUc7QUFDVjtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DLGVBQWUsNkNBQUc7QUFDbEIsbUJBQW1CLDZDQUFHO0FBQ3RCLG1CQUFtQiw2Q0FBRztBQUN0QixVQUFVLDZDQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBSztBQUNmLFVBQVUsOENBQUk7QUFDZCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkNBQUs7QUFDaEIsV0FBVywyQ0FBSztBQUNoQixXQUFXLDJDQUFLO0FBQ2hCLEVBQUUsc0RBQU07O0FBRVI7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBSzs7QUFFZjtBQUNBLFVBQVUsOENBQVE7QUFDbEI7QUFDQTtBQUNBLGFBQWEsNkNBQU87QUFDcEIsUUFBUSwrQ0FBSztBQUNiO0FBQ0EsWUFBWSw4Q0FBUTtBQUNwQjs7QUFFQSxVQUFVLCtDQUFLLFNBQVMsNkNBQU8sRUFBRSw4Q0FBSSxVQUFVLDZDQUFPO0FBQ3REOzs7Ozs7Ozs7Ozs7Ozs7O0FDOUk4Qjs7QUFFOUIsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWEsZ0RBQUk7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN2QkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUR3QztBQUNIO0FBQ0o7QUFDSTtBQUNOOztBQUUvQjs7QUFFQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDZDQUFHLGNBQWMsNkNBQU87QUFDbkMsVUFBVSw2Q0FBRyxjQUFjLDZDQUFPO0FBQ2xDLFVBQVUsNkNBQUcsY0FBYyw2Q0FBTztBQUNsQyxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pELG1IQUFtSCxPQUFPO0FBQzFIO0FBQ0EsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9EQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2SzBDO0FBQ1A7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSwwREFBVTtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQU87QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RytCO0FBQ2M7O0FBRTdDO0FBQ0EsVUFBVSxvREFBSyxVQUFVLDZDQUFPO0FBQ2hDLHVCQUF1QiwyQkFBMkIsZ0JBQWdCO0FBQ2xFOztBQUVBO0FBQ0EsVUFBVSxvREFBSyxVQUFVLDZDQUFPO0FBQ2hDLHVCQUF1QiwyQkFBMkIsZ0JBQWdCO0FBQ2xFOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLFdBQVcsb0RBQUssQ0FBQyw4Q0FBSTtBQUNyQixnQkFBZ0Isb0RBQUssQ0FBQyw4Q0FBSTtBQUMxQixnQkFBZ0Isb0RBQUssQ0FBQyw4Q0FBSSw2Q0FBNkMsT0FBTyw2Q0FBRyxXQUFXLDZDQUFPLEdBQUc7QUFDdEcsZ0JBQWdCLG9EQUFLLENBQUMsOENBQUksNkNBQTZDLE9BQU8sNkNBQUcsV0FBVyw2Q0FBTyxHQUFHO0FBQ3RHOztBQUVBO0FBQ0EsK0NBQStDLFFBQVEsZ0RBQWdEO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsNkNBQU8sY0FBYyw2Q0FBTztBQUM3RCxpQ0FBaUMsNkNBQU8sY0FBYyw2Q0FBTztBQUM3RDs7QUFFTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQSxpRUFBZSxNQUFNLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbkNlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBZ0I7QUFDQTtBQUNEOztBQUU5QixrQkFBa0IsMkNBQUs7QUFDdkIsc0JBQXNCLDJDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnREFBSTtBQUNiLGFBQWEsZ0RBQUk7QUFDakIsV0FBVyxnREFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1FQUFtRSxnREFBSTtBQUN2RSxnQkFBZ0IsNkNBQUc7QUFDbkIsc0JBQXNCLDJDQUFLO0FBQzNCLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0JBQWtCLDJDQUFLO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFVBQVUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pESTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0RBQUk7QUFDakIsV0FBVyxnREFBSTtBQUNmLGdCQUFnQixnREFBSTtBQUNwQixjQUFjLGdEQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsWUFBWSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0JJOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLDhDQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBSTs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGNBQWMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuR0M7QUFDRDs7QUFFZjtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlDQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVLGdEQUFJO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUNzQztBQUNKO0FBQ0Q7QUFDSTtBQUNJO0FBQ0Y7QUFDQTtBQUNGOztBQUVyQyw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFNO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxzREFBTSwwQkFBMEIsZ0RBQVE7QUFDNUMsV0FBVyxnREFBUTtBQUNuQjs7QUFFQTtBQUNBLElBQUksc0RBQU0sMEJBQTBCLG1EQUFXO0FBQy9DLFdBQVcsbURBQVc7QUFDdEI7O0FBRUE7QUFDQSxJQUFJLHNEQUFNLDBCQUEwQixrREFBVTtBQUM5QyxXQUFXLGtEQUFVO0FBQ3JCOztBQUVBO0FBQ0EsSUFBSSxzREFBTSwwQkFBMEIsb0RBQVk7QUFDaEQsV0FBVyxvREFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELG9EQUFRO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxrREFBVSxnQkFBZ0IsbURBQVc7QUFDMUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0E7QUFDQSw4Q0FBOEMsa0RBQVU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRStCO0FBQ0M7QUFDRjs7QUFFOUIsb0JBQW9CLDJDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGdEQUFJO0FBQ2I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCLGdEQUFJO0FBQzdCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBSztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBSTtBQUNwQjtBQUNBOztBQUVBLGlFQUFlLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7Ozs7O0FDNUM1QjtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxHQUFHLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxHQUFHLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsR0FBRyxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw0QkFBNEIsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLFVBQVUsT0FBTyxHQUFHLEVBQUUsR0FBRyxHQUFHLFVBQVUsTUFBTTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDckZ1Qzs7QUFFdkMsNkJBQWUsb0NBQVM7QUFDeEIsU0FBUyw2Q0FBRyxnQkFBZ0IsNkNBQU8sSUFBSSw2Q0FBRyxnQkFBZ0IsNkNBQU87QUFDakU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSmtEO0FBQ0w7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzREFBUywyQkFBMkIsdURBQVk7QUFDbEQsWUFBWSx1REFBWTtBQUN4QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUNpRDtBQUNYO0FBQ007QUFDcUI7QUFDWDs7QUFFdEQsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsaUJBQWlCLG9EQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLG9EQUFRLElBQUksOERBQWE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw2Q0FBTyxPQUFPLDZDQUFHLGNBQWMsNkNBQUcsNEJBQTRCLDZDQUFPO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFTO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXLGdEQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLGlEQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLGtEQUFTO0FBQ3BCOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BELHVCQUF1Qix1QkFBdUI7QUFDOUMsMEJBQTBCLDBCQUEwQjtBQUNwRCx3QkFBd0Isd0JBQXdCO0FBQ2hELDZCQUE2Qiw2QkFBNkI7QUFDMUQsMkJBQTJCO0FBQzNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QitCO0FBQzZCOztBQUU1RCw2QkFBZSxvQ0FBUztBQUN4QixVQUFVLDhEQUFhLE1BQU0sdURBQVc7QUFDeEM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUSxZQUFZLHFEQUFLO0FBQ3ZDLFNBQVMsUUFBUTs7QUFFakI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQmlDOztBQUVqQyw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQUs7QUFDaEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWnFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtGQUFrRix3REFBUTtBQUMxRjs7QUFFTztBQUNQO0FBQ0EsMENBQTBDLHdEQUFRO0FBQ2xEO0FBQ0E7O0FBRWU7QUFDZjtBQUNBLDRCQUE0Qix3REFBUTtBQUNwQzs7Ozs7Ozs7Ozs7Ozs7O0FDNUJBLGlFQUFlLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7Ozs7O0FDQTVCLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTHlDO0FBQ1Y7O0FBRWhCO0FBQ2YsVUFBVSxxREFBSyxVQUFVLG9EQUFRLG1CQUFtQixvREFBUTtBQUM1RCxVQUFVLHFEQUFLO0FBQ2YsVUFBVSxxREFBSztBQUNmLGdCQUFnQixxREFBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNmQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDYitCOztBQUUvQiw2QkFBZSxvQ0FBUztBQUN4QixZQUFZO0FBQ1osWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEscURBQUs7QUFDbEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdEI0Qzs7QUFFN0I7QUFDZixnRUFBZ0UsaURBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1Z5QztBQUNWO0FBQ1k7QUFDRDs7QUFFMUMsaUVBQWU7QUFDZixjQUFjLGdEQUFLOztBQUVuQjtBQUNBLDJCQUEyQiw2Q0FBUSxtQkFBbUIsNkNBQVE7QUFDOUQ7QUFDQTtBQUNBLGtCQUFrQixxREFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQyxJQUFJLEVBQUM7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixjQUFjLDZDQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHlCQUF5QixpREFBSztBQUM5QiwrQkFBK0IsdURBQVc7Ozs7Ozs7Ozs7Ozs7OztBQ3REakQsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEI7QUFDNUI7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBLGNBQWMsU0FBUyxzREFBTSxTQUFTO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBLFNBQVM7QUFDVDs7Ozs7Ozs7Ozs7Ozs7OztBQy9EQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCa0M7QUFDWTs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSxzREFBTSxTQUFTLEdBQUcsYUFBYSxzREFBTSxTQUFTO0FBQ3pFLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7QUFDakUsY0FBYyxzREFBc0Qsc0RBQU0sT0FBTztBQUNqRixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHFEQUFxRCxzREFBTSxPQUFPO0FBQ2hGLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLHNEQUFNLFNBQVMsR0FBRyxhQUFhLHNEQUFNLFNBQVM7QUFDekUsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sbURBQW1ELCtDQUFRO0FBQzNELG1EQUFtRCwrQ0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RGY7O0FBRW5EOztBQUVBO0FBQ087QUFDUDtBQUNBLHdCQUF3QixtREFBUSxHQUFHLHlEQUFTO0FBQzVDOztBQUVPO0FBQ1AsNEJBQTRCLG1EQUFRO0FBQ3BDO0FBQ0E7QUFDQSxpRUFBaUUsbURBQVE7QUFDekU7QUFDQSxTQUFTLHlEQUFTO0FBQ2xCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQitCO0FBQ0o7QUFDYTtBQUNYO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDdUI7O0FBRTVELDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0Esd0NBQXdDLHdEQUFRO0FBQ2hELDBCQUEwQixrREFBTTtBQUNoQywrQkFBK0Isb0RBQUssZUFBZSwrQ0FBRyxJQUFJLGtEQUFNO0FBQ2hFLHFCQUFxQixnREFBSyxHQUFHLCtDQUFHO0FBQ2hDLDRCQUE0QixnREFBSTtBQUNoQyxRQUFRLDhEQUFhLE1BQU0sdURBQVc7QUFDdEMsMkJBQTJCLG1EQUFZO0FBQ3ZDLDBGQUEwRixrREFBTTtBQUNoRyxRQUFRLGtEQUFNO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLG1CQUFtQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCLEdBQUcseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxHQUFHLGNBQWM7QUFDbkQ7QUFDQTtBQUNBLG9CQUFvQixJQUFJLEdBQUcsSUFBSSxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxFQUFFOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxjQUFjO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYyxHQUFHLGNBQWM7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWUsR0FBRyxlQUFlO0FBQ3pEOztBQUVBLHNCQUFzQixFQUFFLEdBQUcsRUFBRSxPQUFPLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxFQUFFOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixHQUFHLEdBQUcsR0FBRztBQUMvQjs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEdBQUcsR0FBRyxHQUFHO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUUsR0FBRyxFQUFFLE9BQU8sR0FBRyxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsT0FBTyxHQUFHLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDakg7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixFQUFFLEdBQUcsRUFBRSxLQUFLLFlBQVksR0FBRyxHQUFHLEdBQUcsZ0NBQWdDLEdBQUcsZ0NBQWdDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxPQUFPLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JELElBQUk7QUFDSjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbkZBLDZCQUFlLG9DQUFTO0FBQ3hCLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzFDQSw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNOQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0o2Qjs7QUFFN0IsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGdEQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdEQUFJO0FBQ2hCLFlBQVksZ0RBQUk7QUFDaEIsWUFBWSxnREFBSTtBQUNoQixZQUFZLGdEQUFJO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3JFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ055RDtBQUNyQjtBQUNGO0FBQ0k7QUFDSjtBQUNtQztBQUNuQztBQUNBO0FBQ0U7QUFDVTtBQUNOO0FBQ0E7O0FBRXpCO0FBQ2Ysc0NBQXNDLDJDQUFRLGtCQUFrQiwyQ0FBUTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLCtDQUErQztBQUMvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWSxnREFBZ0Q7QUFDNUQ7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHNDQUFzQyxxREFBcUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsK0NBQVE7QUFDeEIsbUJBQW1CLDJDQUFXO0FBQzlCLGtCQUFrQixpREFBVTtBQUM1QixpQkFBaUIsZ0RBQVM7QUFDMUIsbUJBQW1CLGtEQUFXO0FBQzlCLGlCQUFpQixnREFBUztBQUMxQixtQkFBbUIsa0RBQVc7QUFDOUIsc0JBQXNCLGlEQUFjO0FBQ3BDLGlCQUFpQixnREFBUztBQUMxQixpQkFBaUIsZ0RBQVM7QUFDMUIsa0JBQWtCLGtEQUFVO0FBQzVCLHVCQUF1Qix1REFBZTtBQUN0QyxjQUFjLDZDQUFNO0FBQ3BCLGNBQWMsNkNBQU07Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RXBCLDZCQUFlLG9DQUFTO0FBQ3hCLDJGQUEyRjs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUCxtQ0FBbUMsT0FBTztBQUMxQztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3REEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDRkEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ042Qjs7QUFFN0IsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQSwyQkFBMkIsZ0RBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdEQUFJO0FBQzlDLDBDQUEwQyxnREFBSTtBQUM5QywwQ0FBMEMsZ0RBQUk7QUFDOUMsMENBQTBDLGdEQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDZjZCOztBQUU3Qiw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBLGlDQUFpQyxnREFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnREFBSTtBQUM5QywwQ0FBMEMsZ0RBQUk7QUFDOUMsMENBQTBDLGdEQUFJO0FBQzlDLDBDQUEwQyxnREFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDcEJPO0FBQ1A7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDTk87QUFDUDtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOa0M7O0FBRWxDLGlFQUFlLHNEQUFNLDRFQUE0RSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDRmhFOztBQUVsQyxpRUFBZSxzREFBTSxnRUFBZ0UsRUFBQzs7Ozs7Ozs7Ozs7Ozs7O0FDRnRGLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDSm1EOztBQUVuRCxpRUFBZSxVQUFVLHdEQUFtQiwyQkFBMkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRnRDO0FBQ0o7O0FBRXZCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtEQUFNOztBQUVaLGlFQUFlLG9EQUFJLFFBQVEsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYk07QUFDSjs7QUFFdkI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0RBQU07O0FBRVosaUVBQWUsb0RBQUksUUFBUSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYmU7QUFDUDtBQUNEOztBQUVwQjtBQUNmLGNBQWMsdURBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQVEsc0JBQXNCLDBCQUEwQjtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLCtDQUFTO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDcEdlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pnQztBQUNvRTtBQUMvRDtBQUNKOztBQUVqQzs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixRQUFRLHdEQUFRO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvREFBTTtBQUNsQjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RixzREFBaUI7QUFDekc7O0FBRUE7QUFDQSxzREFBc0Qsa0RBQU07QUFDNUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELHNEQUFnQjtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVITztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCOEM7QUFDRztBQUNiO0FBQ0s7O0FBRWxDO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFdBQVcsb0RBQUs7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMERBQVU7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdURBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZTtBQUNmLGNBQWMsMERBQVU7O0FBRXhCO0FBQ0EsV0FBVyxvREFBSTtBQUNmOztBQUVBLEVBQUUsK0NBQVM7O0FBRVg7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDckVlO0FBQ2Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRm1DO0FBQ0M7O0FBRTdCOztBQUVRO0FBQ2Ysa0JBQWtCLCtDQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsK0NBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUUsK0NBQVM7O0FBRVg7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Q3NDO0FBQ3NCO0FBQ3hCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCx3QkFBd0Isb0RBQVEsRUFBRSxvREFBUTtBQUMxQzs7QUFFQTtBQUNBLHNDQUFzQyxvREFBUSxFQUFFLG9EQUFRO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxREFBUztBQUNsQjs7QUFFZTtBQUNmLHFCQUFxQiwyREFBVzs7QUFFaEM7QUFDQSxXQUFXLG9EQUFJO0FBQ2Y7O0FBRUEsRUFBRSwrQ0FBUzs7QUFFWDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pEd0U7QUFDcEM7O0FBRXJCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdEQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Qsb0RBQU07QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUywrQ0FBUztBQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeERnQztBQUNNO0FBQ0Y7O0FBRXJCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLG9EQUFNO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsK0NBQVMsT0FBTyxxREFBUztBQUNsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RGdDO0FBQ0k7O0FBRXJCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsb0RBQU07QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsK0NBQVM7QUFDbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDa0M7QUFDK0U7O0FBRWxHO0FBQ2YsYUFBYSxrREFBUTtBQUNyQjtBQUNBLGNBQWMscURBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFEQUFlO0FBQzNFLGFBQWEsdURBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFEQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFEQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaURBQU07QUFDZjs7Ozs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ2U7QUFDZjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNSQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKbUM7QUFDRjs7QUFFakMsNkJBQWUsb0NBQVM7QUFDeEIsU0FBUyxzREFBTSxDQUFDLHVEQUFPO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0x1QztBQUNEOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBSyw4Q0FBOEMsaURBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QixpQkFBaUIseURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWeUM7O0FBRXpDLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTLHNEQUFVLDJCQUEyQixPQUFPLHNEQUFVLHVCQUF1QixRQUFRO0FBQzlGOzs7Ozs7Ozs7Ozs7Ozs7O0FDTk87O0FBRVAsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDUnlDOztBQUUzQyw2QkFBZSxvQ0FBUztBQUN4QixVQUFVLDJEQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkJxRDs7QUFFckQsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQSxZQUFZLDBEQUFTO0FBQ3JCLFlBQVksMERBQVMsZUFBZSxxREFBSTtBQUN4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOK0I7QUFDc0I7O0FBRXJELDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0EsWUFBWSwwREFBUztBQUNyQixZQUFZLDBEQUFTLEVBQUUscURBQUssYUFBYSxxREFBSTtBQUM3Qzs7Ozs7Ozs7Ozs7Ozs7OztBQ1BvQzs7QUFFcEMsNkJBQWUsb0NBQVM7QUFDeEIsbURBQW1ELHVEQUFPO0FBQzFEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEIsaUJBQWlCLHlEQUFTOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeERBLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pxQztBQUNBO0FBQ0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixnREFBUztBQUM5QjtBQUNBOztBQUVBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixnREFBUztBQUM5QjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyx3REFBUTs7QUFFbkQsdUdBQXVHLE9BQU87QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZ0RBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7Ozs7Ozs7Ozs7Ozs7OztBQy9IQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0p1Qzs7QUFFdkM7QUFDQSxlQUFlLHNEQUFXO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2pDQSw2QkFBZSxvQ0FBUzs7QUFFeEIsNERBQTRELE9BQU87QUFDbkUsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1RBLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZpQztBQUNJOztBQUVyQyw2QkFBZSxzQ0FBVztBQUMxQixhQUFhLGdEQUFTLGlDQUFpQyxrREFBTTtBQUM3RDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFzRDtBQUN2Rix3Q0FBd0MsZ0RBQWdEO0FBQ3hGLHNDQUFzQyw4Q0FBOEM7QUFDcEYseUNBQXlDO0FBQ3pDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCaUM7QUFDSTs7QUFFckMsNkJBQWUsc0NBQVc7QUFDMUIsYUFBYSxnREFBUyxnQ0FBZ0Msa0RBQU07QUFDNUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTHFDO0FBQ0Q7O0FBRXBDLDZCQUFlLG9DQUFTO0FBQ3hCLDJDQUEyQyx1REFBTzs7QUFFbEQsc0ZBQXNGLE9BQU87QUFDN0YsNkZBQTZGLE9BQU87QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdEQUFTO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCMkM7QUFDTTtBQUNJO0FBQ007QUFDaEI7QUFDSjtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDTTtBQUNGO0FBQ047QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ047QUFDWTtBQUNBOztBQUV4Qzs7QUFFQTtBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtEQUFnQjtBQUMxQixhQUFhLHFEQUFtQjtBQUNoQyxlQUFlLHVEQUFxQjtBQUNwQyxrQkFBa0IsMERBQXdCO0FBQzFDLFVBQVUsa0RBQWdCO0FBQzFCLFFBQVEsZ0RBQWM7QUFDdEIsU0FBUyxpREFBZTtBQUN4QixRQUFRLGdEQUFjO0FBQ3RCLFFBQVEsZ0RBQWM7QUFDdEIsU0FBUyxpREFBZTtBQUN4QjtBQUNBLFNBQVMsa0RBQWU7QUFDeEIsUUFBUSxpREFBYztBQUN0QixRQUFRLGlEQUFjO0FBQ3RCLFNBQVMsa0RBQWU7QUFDeEIsUUFBUSxpREFBYztBQUN0QixRQUFRLGlEQUFjO0FBQ3RCLFNBQVMsa0RBQWU7QUFDeEIsUUFBUSxpREFBYztBQUN0QixRQUFRLGlEQUFjO0FBQ3RCLFNBQVMsa0RBQWU7QUFDeEIsWUFBWSxxREFBa0I7QUFDOUIsV0FBVyxvREFBaUI7QUFDNUIsUUFBUSxpREFBYztBQUN0QixRQUFRLGlEQUFjO0FBQ3RCLFNBQVMsa0RBQWU7QUFDeEIsU0FBUyxrREFBZTtBQUN4QixVQUFVLG1EQUFnQjtBQUMxQixVQUFVLG1EQUFnQjtBQUMxQixVQUFVLG1EQUFnQjtBQUMxQixTQUFTLGtEQUFlO0FBQ3hCLFNBQVMsa0RBQWU7QUFDeEIsTUFBTSwrQ0FBWTtBQUNsQixZQUFZLHFEQUFrQjtBQUM5QixxQkFBcUIscURBQWtCO0FBQ3ZDOztBQUVBLGlFQUFlLFNBQVMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Rlc7QUFDRTs7QUFFdEM7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCLG1EQUFtRCx1REFBTztBQUMxRCx1RkFBdUYsd0RBQVE7QUFDL0Y7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7O0FDYkEsNkJBQWUsdUNBQVk7QUFDM0IsNERBQTRELE9BQU87QUFDbkUsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ05BLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ05xQzs7QUFFckMsNkJBQWUsb0NBQVM7QUFDeEI7O0FBRUEsK0pBQStKLE9BQU87QUFDdEsseUhBQXlILE9BQU87QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFFBQVE7QUFDakI7QUFDQTs7QUFFQSxhQUFhLGdEQUFTO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7QUNsQkEsNkJBQWUsc0NBQVc7O0FBRTFCLDREQUE0RCxPQUFPO0FBQ25FLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNsRUEsNkJBQWUsc0NBQVc7O0FBRTFCLDZEQUE2RCxRQUFRO0FBQ3JFLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQcUM7QUFDQzs7QUFFdEMsNkJBQWUsb0NBQVM7QUFDeEIsNkNBQTZDLHdEQUFROztBQUVyRCxzRkFBc0YsT0FBTztBQUM3RixnSEFBZ0gsT0FBTztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxnREFBUztBQUN0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJxQztBQUNMO0FBQ1k7O0FBRTVDO0FBQ0E7QUFDQSxXQUFXLHFEQUFLO0FBQ2hCO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQSxnQkFBZ0IsMkRBQVc7O0FBRTNCLDBGQUEwRixPQUFPO0FBQ2pHLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdEQUFTO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7O0FDeEIyQzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQSx3REFBd0QseURBQVk7QUFDcEU7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQjJDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBLDZEQUE2RCx5REFBWTtBQUN6RTs7Ozs7Ozs7Ozs7Ozs7O0FDakJBLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKcUM7O0FBRXJDLDZCQUFlLG9DQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1RkFBdUYsT0FBTztBQUM5Rix5R0FBeUcsT0FBTztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxnREFBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0Z1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxTQUFTLHNEQUFXO0FBQ3BCOzs7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN4QkE7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDUkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0pBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pxQztBQUNnRTtBQUNsRTs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBSSxDQUFDLDZDQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLHdEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtEQUFROztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDRDQUFNO0FBQ3ZELCtDQUErQyw0Q0FBTTtBQUNyRCxhQUFhLDZDQUFHO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDZDQUFPOztBQUV0QjtBQUNBLGtCQUFrQix5Q0FBRyxHQUFHLDZDQUFPO0FBQy9CLDBCQUEwQiw2Q0FBRyxXQUFXLDZDQUFHO0FBQzNDO0FBQ0EsZUFBZSw2Q0FBTztBQUN0Qiw0QkFBNEIsNkNBQUcsV0FBVyw2Q0FBRztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZDQUFPLHNEQUFzRCw4Q0FBSTtBQUN0RixlQUFlLDZDQUFHLENBQUMsNkNBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDZDQUFPO0FBQ3RCLGlCQUFpQiw4Q0FBSSxXQUFXLDZDQUFHO0FBQ25DLGlCQUFpQiw4Q0FBSSxXQUFXLDZDQUFHO0FBQ25DLDhCQUE4Qiw2Q0FBTztBQUNyQztBQUNBLDhCQUE4Qiw2Q0FBTztBQUNyQztBQUNBOztBQUVBLHFCQUFxQiw2Q0FBRztBQUN4QixxQkFBcUIsNkNBQUc7QUFDeEIscUJBQXFCLDZDQUFHO0FBQ3hCLHFCQUFxQiw2Q0FBRzs7QUFFeEI7QUFDQSxlQUFlLDZDQUFPO0FBQ3RCLHVCQUF1Qiw2Q0FBRztBQUMxQix1QkFBdUIsNkNBQUc7QUFDMUIsdUJBQXVCLDZDQUFHO0FBQzFCLHVCQUF1Qiw2Q0FBRztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBRyxDQUFDLDhDQUFJLHdCQUF3Qiw4Q0FBSSxzQkFBc0IsOENBQUk7QUFDdkYscUJBQXFCLDhDQUFJO0FBQ3pCLGtCQUFrQiw2Q0FBRztBQUNyQixrQkFBa0IsNkNBQUc7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDZDQUFPOztBQUV6QjtBQUNBLHFCQUFxQiw2Q0FBTztBQUM1QjtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFELCtDQUFLLGtCQUFrQiwrQ0FBSzs7QUFFakY7QUFDQTtBQUNBLHlDQUF5QywrQ0FBSyxrQkFBa0IsK0NBQUs7QUFDckUsZ0NBQWdDLCtDQUFLLGtDQUFrQywrQ0FBSztBQUM1RSx5Q0FBeUMsK0NBQUssa0JBQWtCLCtDQUFLO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFPLGFBQWEsNkNBQU87O0FBRTVDO0FBQ0EscUJBQXFCLDZDQUFPO0FBQzVCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQsK0NBQUssa0JBQWtCLCtDQUFLOztBQUVqRjtBQUNBO0FBQ0EseUNBQXlDLCtDQUFLLGtCQUFrQiwrQ0FBSztBQUNyRSxnQ0FBZ0MsK0NBQUssa0NBQWtDLCtDQUFLO0FBQzVFLHlDQUF5QywrQ0FBSyxrQkFBa0IsK0NBQUs7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEZBQTBGLHdDQUFFO0FBQzVGLFlBQVksNkNBQUcsU0FBUyw2Q0FBRztBQUMzQjs7QUFFQTtBQUNBLDJFQUEyRSx3REFBUTtBQUNuRjs7QUFFQTtBQUNBLDJFQUEyRSx3REFBUTtBQUNuRjs7QUFFQTtBQUNBLDRFQUE0RSx3REFBUTtBQUNwRjs7QUFFQTtBQUNBLDRGQUE0Rix3REFBUTtBQUNwRzs7QUFFQTtBQUNBLDBFQUEwRSx3REFBUTtBQUNsRjs7QUFFQTtBQUNBLHdFQUF3RSx3REFBUTtBQUNoRjs7QUFFQTtBQUNBLHdFQUF3RSx3REFBUTtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM1ErQjtBQUNNO0FBQ087QUFDZjtBQUNNO0FBQ2lCOztBQUVwRCw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBLGdCQUFnQix3REFBUTtBQUN4QjtBQUNBLGNBQWMsd0RBQVc7QUFDekI7QUFDQSxhQUFhLGtEQUFROztBQUVyQiw0REFBNEQsd0NBQU0sR0FBRyx3REFBUTtBQUM3RSw0REFBNEQsd0RBQVEsTUFBTSx3REFBUTtBQUNsRiw0REFBNEQsd0NBQU0sR0FBRyx3REFBUTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG9EQUFJO0FBQ2Y7O0FBRUE7QUFDQSxrRUFBa0Usd0RBQVE7QUFDMUU7O0FBRUE7QUFDQSxrRUFBa0Usd0RBQVE7QUFDMUU7O0FBRUE7QUFDQSxxRkFBcUYsd0RBQVE7QUFDN0Y7O0FBRUE7QUFDQSxrRUFBa0Usd0RBQVE7QUFDMUU7O0FBRUE7QUFDQSxrRUFBa0Usd0RBQVE7QUFDMUU7O0FBRUE7QUFDQSxxRkFBcUYsd0RBQVE7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSx3REFBUTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvR087O0FBRVAsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7Ozs7Ozs7Ozs7Ozs7O0FDTkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0o0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUJBQWlCLDJEQUFXO0FBQzVCLGlCQUFpQiwyREFBVztBQUM1QixpQkFBaUIsMkRBQVc7QUFDNUIsaUJBQWlCLDJEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0VBQXNFO0FBQ3JHLCtCQUErQjtBQUMvQiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzlCQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNGQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0YrQjtBQUNNO0FBQ087QUFDVDtBQUNpQjs7QUFFcEQsNkJBQWUsb0NBQVM7QUFDeEIsZ0JBQWdCLHdEQUFRO0FBQ3hCO0FBQ0EsY0FBYyx3REFBVztBQUN6QjtBQUNBLGFBQWEsa0RBQVE7O0FBRXJCLHdEQUF3RCx3Q0FBTSxHQUFHLHdEQUFRO0FBQ3pFLHdEQUF3RCx3Q0FBTSxHQUFHLHdEQUFROztBQUV6RTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFLO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSx3REFBUTtBQUN6RTs7QUFFQTtBQUNBLGlFQUFpRSx3REFBUTtBQUN6RTs7QUFFQTtBQUNBLHVFQUF1RSx3REFBUTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekRpQztBQUNJO0FBQ29CO0FBQ3RCO0FBQ2lCOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsd0NBQU07QUFDaEIsVUFBVSx3Q0FBTTtBQUNoQjtBQUNBO0FBQ0EsYUFBYSxrREFBUTs7QUFFckI7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSx3REFBUTtBQUN6RTs7QUFFQTtBQUNBLGlFQUFpRSx3REFBUTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQLGNBQWMsaURBQUs7QUFDbkI7O0FBRU87QUFDUCxjQUFjLGlEQUFLO0FBQ25COztBQUVPO0FBQ1AsaUJBQWlCLHNEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25CNkI7O0FBRXRCO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2REFBNkQsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIseUNBQUk7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEIrQjtBQUNNO0FBQ0k7QUFDSjtBQUNQOztBQUU5Qiw2QkFBZSxzQ0FBVztBQUMxQixjQUFjLG9EQUFRO0FBQ3RCLG1CQUFtQixzREFBVTtBQUM3QjtBQUNBLG1CQUFtQix3REFBUTtBQUMzQixpQkFBaUIsd0RBQVEsQ0FBQyx5Q0FBRztBQUM3QixpQkFBaUIsd0RBQVE7O0FBRXpCO0FBQ0E7QUFDQSxvQkFBb0IscURBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlDQUFHLFlBQVkseUNBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Qsc0NBQXNDO0FBQzlGLHVEQUF1RCxnQ0FBZ0M7O0FBRXZGO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsd0RBQVE7QUFDN0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSx3REFBUTtBQUNsRjs7QUFFQTtBQUNBLHdFQUF3RSx3REFBUTtBQUNoRjs7QUFFQTtBQUNBLHdFQUF3RSx3REFBUTtBQUNoRjs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0VPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ05BLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRnFDO0FBQ0Y7QUFDUztBQUNKO0FBQ0Y7QUFDSTtBQUNFO0FBQ1I7QUFDSTtBQUNFO0FBQ047QUFDUTtBQUNFO0FBQ1o7QUFDSTs7QUFFdEM7QUFDTztBQUNQLEVBQUUseURBQU07QUFDUixFQUFFLHdEQUFLO0FBQ1AsRUFBRSwwREFBTztBQUNULEVBQUUseURBQU07QUFDUixFQUFFLHVEQUFJO0FBQ04sRUFBRSwyREFBUTtBQUNWLEVBQUUsc0RBQUc7QUFDTDs7QUFFQTtBQUNPO0FBQ1AsRUFBRSx5REFBTTtBQUNSLEVBQUUsdURBQUk7QUFDTixFQUFFLHdEQUFLO0FBQ1AsRUFBRSw0REFBUztBQUNYLEVBQUUsNERBQVE7QUFDVixFQUFFLDJEQUFPO0FBQ1QsRUFBRSw0REFBUTtBQUNWOztBQUVlO0FBQ2Y7QUFDQSxhQUFhLG1EQUFROztBQUVyQiw2Q0FBNkMseURBQVEsU0FBUyx5REFBTTtBQUNwRSw2Q0FBNkMseURBQVE7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSx5REFBUTtBQUM1RTs7QUFFQTtBQUNBLG9FQUFvRSx5REFBUTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFcUM7O0FBRXJDLGNBQWMsOENBQUk7O0FBRWxCLGlFQUFlO0FBQ2Y7QUFDQSxjQUFjLDhDQUFJLFFBQVEsNkNBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDaEJ1Qzs7QUFFekMsaUVBQWU7QUFDZjtBQUNBLGNBQWMsOENBQUksUUFBUSx3Q0FBRTtBQUM1QjtBQUNBLDRCQUE0Qix5Q0FBRztBQUMvQjtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1I4Qjs7QUFFaEMsaUVBQWU7QUFDZjtBQUNBLGNBQWMsOENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ25COEI7O0FBRWhDLGNBQWMsOENBQUk7QUFDbEI7O0FBRUEsaUVBQWU7QUFDZjtBQUNBLGNBQWMsOENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmOEI7O0FBRWhDLGlFQUFlO0FBQ2Y7QUFDQSxjQUFjLDhDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1htQzs7QUFFckMsaUVBQWU7QUFDZjtBQUNBLGNBQWMsOENBQUksUUFBUSw2Q0FBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDVjhCOztBQUVoQyxpRUFBZTtBQUNmO0FBQ0EsY0FBYyw4Q0FBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSOEI7O0FBRWhDLGlFQUFlO0FBQ2Y7QUFDQSxjQUFjLDhDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1hpRDs7QUFFbkQ7QUFDQSxXQUFXLDZDQUFHLENBQUMsd0NBQUUsU0FBUyw2Q0FBRyxLQUFLLHdDQUFFO0FBQ3BDLFdBQVcsNkNBQUcsQ0FBQyx5Q0FBRztBQUNsQixZQUFZLDZDQUFHLENBQUMseUNBQUc7O0FBRW5CLGlFQUFlO0FBQ2Y7QUFDQSxjQUFjLDhDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsZ0JBQWdCLHlDQUFHO0FBQ25CLGdCQUFnQiw2Q0FBRztBQUNuQixnQkFBZ0IsNkNBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCbUM7O0FBRXJDLGlFQUFlO0FBQ2Y7QUFDQSxjQUFjLDhDQUFJLFFBQVEsNkNBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1Y4Qjs7QUFFaEMsY0FBYyw4Q0FBSTs7QUFFbEIsaUVBQWU7QUFDZjtBQUNBLGVBQWUsOENBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1o4Qjs7QUFFaEMsY0FBYyw4Q0FBSTs7QUFFbEIsaUVBQWU7QUFDZjtBQUNBLGNBQWMsOENBQUk7QUFDbEI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2Q4Qjs7QUFFaEM7QUFDQSxVQUFVLDhDQUFJO0FBQ2QsY0FBYyw4Q0FBSTtBQUNsQjs7QUFFQSxpRUFBZTtBQUNmO0FBQ0EsY0FBYyw4Q0FBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QjJDO0FBQ2Q7QUFDb0M7QUFDNUI7O0FBRXZDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUFRRDtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7O0FBRTlEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOFgsaUVBQWUsS0FBSyxFQUFDO0FBQ25aOzs7Ozs7Ozs7Ozs7Ozs7O0FDdG1FbUQ7Ozs7Ozs7Ozs7Ozs7OztBQ0FuRCxZQUFZOztBQUVaO0FBQ0EsOENBQThDLEtBQUssT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCLElBQUksRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBbUI7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFtQjtBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBbUI7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFtQjtBQUMzQztB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Q0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQXdCO0FBQ007QUFDOUIsV0FBVyxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9OVVRTLmNzcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvYW5ub3RhdGlvbnMuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9pbmRleC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL2xhYmVscy5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL2xlZ2VuZC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL21hcC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL3Rvb2x0aXAuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy93b3JsZC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9mc3VtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9ncmVhdGVzdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tYXhJbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWluSW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcGVybXV0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1aWNrc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9yYW5nZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc29ydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc3VtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aWNrcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1heGlzL3NyYy9heGlzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWF4aXMvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvc3JjL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL25vZHJhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvY3N2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvZHN2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvdHN2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2N1YmljLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZldGNoL3NyYy9kc3YuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL2pzb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL3RleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2NvbGxpZGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9qaWdnbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2xjZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvc2ltdWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMveS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9leHBvbmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdERlY2ltYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRHcm91cC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdE51bWVyYWxzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0UHJlZml4QXV0by5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFJvdW5kZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRTcGVjaWZpZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUcmltLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2xvY2FsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvbkZpeGVkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uUHJlZml4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uUm91bmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9mc3VtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2FydGVzaWFuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2FudGltZXJpZGlhbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvbGluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3Jlam9pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jb21wb3NlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvbm9vcC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2JvdW5kcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wb2ludEVxdWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BvbHlnb25Db250YWlucy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2ZpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vcmVzYW1wbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvc3RyZWFtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvcm9iaW5zb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jZW50cm9pZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvYnVmZmVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9yZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3Jlam9pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2dyYXRpY3VsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2FyZWEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2JvdW5kcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvY2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9tZWFzdXJlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wb2ludEVxdWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9maXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvc3RyZWFtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2xhYi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvb2JqZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy96b29tLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2FkZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvY292ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2RhdGEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZmluZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZHRyZWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcm9vdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvc2l6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvdmlzaXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0QWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9jYXRlZ29yaWNhbC9TZXQzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlLWNocm9tYXRpYy9zcmMvY2F0ZWdvcmljYWwvY2F0ZWdvcnkxMC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL2NvbG9ycy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL3JhbXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9zZXF1ZW50aWFsLW11bHRpL09yUmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9zZXF1ZW50aWFsLW11bHRpL1lsR25CdS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYmFuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnRpbnVvdXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luaXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9vcmRpbmFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aWNrRm9ybWF0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tYXRjaGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbmFtZXNwYWNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3RBbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2FsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Nsb25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2RhdGEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZWFjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbnRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9leGl0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9odG1sLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9qb2luLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2xvd2VyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL21lcmdlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb3JkZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmFpc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmVtb3ZlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RBbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2l6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zb3J0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi90ZXh0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3RvckFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NvdXJjZUV2ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvd2luZG93LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FyZWEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FycmF5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYnVtcC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbGluZWFyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbGluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbGluay5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcGllLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcG9pbnRSYWRpYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2FzdGVyaXNrLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY3Jvc3MuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9kaWFtb25kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvZGlhbW9uZDIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9wbHVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlMi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3N0YXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC90aW1lcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3RyaWFuZ2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL2luZGV4Um9sbHVwTmV4dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2RyYWcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2V2ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1wYXRoL3NyYy9wYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2xvY2FsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL21hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbW91c2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbmFtZXNwYWNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vam9pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbG93ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL21lcmdlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2RlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2Rlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29yZGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmFpc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RBbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvdG91Y2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvdG91Y2hlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJjLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJlYS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FycmF5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNPcGVuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYnVuZGxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2FyZGluYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbENsb3NlZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsT3Blbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb20uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbU9wZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9tb25vdG9uZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL25hdHVyYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9yYWRpYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9zdGVwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbGluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9ub29wLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb2Zmc2V0L2V4cGFuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC9ub25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb2Zmc2V0L3NpbGhvdWV0dGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvd2lnZ2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvYXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL2luc2lkZU91dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL25vbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9yZXZlcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcGllLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9yYWRpYWxBcmVhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcmFkaWFsTGluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N0YWNrLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jcm9zcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9kaWFtb25kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3NxdWFyZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zdGFyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3RyaWFuZ2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3d5ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZW91dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvc2VsZWN0aW9uL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9hdHRyVHdlZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9kZWxheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2VWYXJ5aW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL21lcmdlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zY2hlZHVsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0VHdlZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdHdlZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9pbnRlcm5tYXAvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2pzb25zdGF0LXRvb2xraXQvaW1wb3J0Lm1qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmJveC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2ZlYXR1cmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9tZXNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbmVpZ2hib3JzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9yZXZlcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvc3RpdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdW50cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS9hbm5vdGF0aW9ucy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2NhcnRvZ3JhbXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS9kZXByZWNhdGVkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvZ2VvbWV0cmllcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2luc2V0cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2tvc292by5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2xhYmVscy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL21hcC10ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3BhdHRlcm4tZmlsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3N0YW1wcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3N0YXQtZGF0YS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3N0YXQtbWFwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL2luZGV4LmNzcz9mN2VhIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2V1cm9zdGF0LW1hcC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLWNhdGVnb3JpY2FsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aC1iaXZhcmlhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLXRyaXZhcmlhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtZmxvdy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLXBhdHRlcm4tZmlsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLXBpZWNoYXJ0cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLXByb3BvcnRpb25hbC1zeW1ib2xzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtc3RyaXBlLWNvbXBvc2l0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWNhdGVnb3JpY2FsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLWJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9tYXB0eXBlcy9tYXAtY2hvcm9wbGV0aC10cml2YXJpYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1mbG93LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1waWVjaGFydHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXByb3BvcnRpb25hbC1zeW1ib2xzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1zcGFya2xpbmVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1zdHJpcGUtY29tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvdG9vbHRpcC90b29sdGlwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL25vbmNlIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImV1cm9zdGF0bWFwXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImV1cm9zdGF0bWFwXCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuICIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAvKiBTVFlMSU5HIE9GIE5VVFMgUkVHSU9OUyBBTkQgQk9VTkRBUklFUyAqL1xyXG4vKiBEZWZhdWx0IHJlZ2lvbiBmaWxsICovXHJcbi5lbS1jbnRyZyxcclxuLmVtLW51dHNyZyxcclxuLmVtLWdyaWQtY2VsbCB7XHJcbiAgICBmaWxsOiAjZTFlMWUxO1xyXG59XHJcblxyXG4uZW0tbnV0c3JnLFxyXG4uZW0tY250cmcsXHJcbi5lbS1ncmlkLWNlbGwsXHJcbiNlbS11c2VyLXJlZ2lvbnMge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcblxyXG4vKiAgYm91bmRhcmllcyBzdHJva2Utd2lkdGggKi9cclxuLmVtLWJuLTAge1xyXG4gICAgc3Ryb2tlOiBub25lO1xyXG59XHJcbi5lbS1ibi0xLFxyXG4uZW0tYm4tMixcclxuLmVtLWJuLTMsXHJcbi8qIHdoZW4gdXNpbmcgTUlYRUQgTlVUUyBsZXZlbHMsIHdlIGFkZCBzdHJva2UgdG8gdGhlIHJlZ2lvbnMsIHRoZW4gc2hvdy9oaWRlIHRob3NlIHRoYXQgaGF2ZS9kb250IGhhdmUgZGF0YSAqL1xyXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcclxuLmVtLW51dHNyZyBbbHZsPScyJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMSddLFxyXG4uZW0tYm4tY28ge1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjI7XHJcbn1cclxuXHJcbi8qIGFsbCBib3VkbmFyaWVzIGFuZCByZWdpb25zIGxpbmVjYXAvbGluZWpvaW4gKi9cclxuI2VtLW51dHNibixcclxuLmVtLWNudGJuLFxyXG4uZW0tYm4tMCxcclxuLmVtLWJuLTEsXHJcbi5lbS1ibi0yLFxyXG4uZW0tYm4tMyxcclxuLmVtLWtvc292by1ibixcclxuLmVtLWJuLWNvLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcclxuLmVtLW51dHNyZyBbbHZsPScyJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMSddLFxyXG4uZW0tY250cmcsXHJcbi5lbS1udXRzcmcsXHJcbi5lbS1ncmlkLWNlbGwge1xyXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxufVxyXG5cclxuLyogbmF0aW9uYWwgYm91bmRhcmllcyAqL1xyXG4uZW0tY250Ym4ge1xyXG4gICAgc3Ryb2tlOiAjMDAwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjZweDtcclxufVxyXG5cclxuLyogTlVUUyBib3VuZGFyaWVzIHN0cm9rZSBjb2xvciAqL1xyXG4uZW0tYm4tMSxcclxuLmVtLWJuLTIsXHJcbi5lbS1ibi0zLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcclxuLmVtLW51dHNyZyBbbHZsPScyJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMSddIHtcclxuICAgIHN0cm9rZTogIzY5Njk2OTtcclxufVxyXG5cclxuLyogY29hc3RhbCBib3VuZGFyaWVzICovXHJcbi5lbS1ibi1jbyB7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcblxyXG4vKiBrb3Nvdm8gKi9cclxuLmVtLWtvc292by1ibiB7XHJcbiAgICBzdHJva2U6ICMwMDA7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuMTU7XHJcbn1cclxuXHJcblxyXG5cclxuLyogZG9udCBmaWxsIGNlcnRhaW4gZWxlbWVudHMgKi9cclxuLmVtLWZyYW1lLFxyXG4uZW0tZ3JhdGljdWxlLFxyXG4uZW0tY250Ym4sXHJcbi5lbS1ibi0wLFxyXG4uZW0tYm4tMSxcclxuLmVtLWJuLTIsXHJcbi5lbS1ibi0zLFxyXG4uZW0ta29zb3ZvLWJuLFxyXG4uZW0tYm4tY28ge1xyXG4gICAgZmlsbDogbm9uZTtcclxufVxyXG5cclxuLyogdGFyZ2V0IG5vbiBjYy9ldS9lZnRhIGJvcmRlcnMgKi9cclxuLyogLmVtLWJuLW90aDpub3QoLmVtLWJuLWNvKTpub3QoLmVtLWJuLWNjKTpub3QoLmVtLWJuLWV1KTpub3QoLmVtLWJuLWVmdGEpIHtcclxuICAgIHN0cm9rZS13aWR0aDogMDtcclxufSAqL1xyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvTlVUUy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsMkNBQTJDO0FBQzNDLHdCQUF3QjtBQUN4Qjs7O0lBR0ksYUFBYTtBQUNqQjs7QUFFQTs7OztJQUlJLGVBQWU7QUFDbkI7O0FBRUEsNkJBQTZCO0FBQzdCO0lBQ0ksWUFBWTtBQUNoQjtBQUNBOzs7Ozs7OztJQVFJLGlCQUFpQjtBQUNyQjs7QUFFQSxnREFBZ0Q7QUFDaEQ7Ozs7Ozs7Ozs7Ozs7O0lBY0kscUJBQXFCO0lBQ3JCLHNCQUFzQjtBQUMxQjs7QUFFQSx3QkFBd0I7QUFDeEI7SUFDSSxZQUFZO0lBQ1osbUJBQW1CO0FBQ3ZCOztBQUVBLGlDQUFpQztBQUNqQzs7Ozs7O0lBTUksZUFBZTtBQUNuQjs7QUFFQSx1QkFBdUI7QUFDdkI7SUFDSSxhQUFhO0FBQ2pCOztBQUVBLFdBQVc7QUFDWDtJQUNJLFlBQVk7SUFDWixrQkFBa0I7QUFDdEI7Ozs7QUFJQSwrQkFBK0I7QUFDL0I7Ozs7Ozs7OztJQVNJLFVBQVU7QUFDZDs7QUFFQSxrQ0FBa0M7QUFDbEM7O0dBRUdcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogU1RZTElORyBPRiBOVVRTIFJFR0lPTlMgQU5EIEJPVU5EQVJJRVMgKi9cXHJcXG4vKiBEZWZhdWx0IHJlZ2lvbiBmaWxsICovXFxyXFxuLmVtLWNudHJnLFxcclxcbi5lbS1udXRzcmcsXFxyXFxuLmVtLWdyaWQtY2VsbCB7XFxyXFxuICAgIGZpbGw6ICNlMWUxZTE7XFxyXFxufVxcclxcblxcclxcbi5lbS1udXRzcmcsXFxyXFxuLmVtLWNudHJnLFxcclxcbi5lbS1ncmlkLWNlbGwsXFxyXFxuI2VtLXVzZXItcmVnaW9ucyB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLyogIGJvdW5kYXJpZXMgc3Ryb2tlLXdpZHRoICovXFxyXFxuLmVtLWJuLTAge1xcclxcbiAgICBzdHJva2U6IG5vbmU7XFxyXFxufVxcclxcbi5lbS1ibi0xLFxcclxcbi5lbS1ibi0yLFxcclxcbi5lbS1ibi0zLFxcclxcbi8qIHdoZW4gdXNpbmcgTUlYRUQgTlVUUyBsZXZlbHMsIHdlIGFkZCBzdHJva2UgdG8gdGhlIHJlZ2lvbnMsIHRoZW4gc2hvdy9oaWRlIHRob3NlIHRoYXQgaGF2ZS9kb250IGhhdmUgZGF0YSAqL1xcclxcbi5lbS1udXRzcmcgW2x2bD0nMyddLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMiddLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMSddLFxcclxcbi5lbS1ibi1jbyB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4yO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBhbGwgYm91ZG5hcmllcyBhbmQgcmVnaW9ucyBsaW5lY2FwL2xpbmVqb2luICovXFxyXFxuI2VtLW51dHNibixcXHJcXG4uZW0tY250Ym4sXFxyXFxuLmVtLWJuLTAsXFxyXFxuLmVtLWJuLTEsXFxyXFxuLmVtLWJuLTIsXFxyXFxuLmVtLWJuLTMsXFxyXFxuLmVtLWtvc292by1ibixcXHJcXG4uZW0tYm4tY28sXFxyXFxuLmVtLW51dHNyZyBbbHZsPSczJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScyJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScxJ10sXFxyXFxuLmVtLWNudHJnLFxcclxcbi5lbS1udXRzcmcsXFxyXFxuLmVtLWdyaWQtY2VsbCB7XFxyXFxuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG59XFxyXFxuXFxyXFxuLyogbmF0aW9uYWwgYm91bmRhcmllcyAqL1xcclxcbi5lbS1jbnRibiB7XFxyXFxuICAgIHN0cm9rZTogIzAwMDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjZweDtcXHJcXG59XFxyXFxuXFxyXFxuLyogTlVUUyBib3VuZGFyaWVzIHN0cm9rZSBjb2xvciAqL1xcclxcbi5lbS1ibi0xLFxcclxcbi5lbS1ibi0yLFxcclxcbi5lbS1ibi0zLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMyddLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMiddLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMSddIHtcXHJcXG4gICAgc3Ryb2tlOiAjNjk2OTY5O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBjb2FzdGFsIGJvdW5kYXJpZXMgKi9cXHJcXG4uZW0tYm4tY28ge1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBrb3Nvdm8gKi9cXHJcXG4uZW0ta29zb3ZvLWJuIHtcXHJcXG4gICAgc3Ryb2tlOiAjMDAwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuMTU7XFxyXFxufVxcclxcblxcclxcblxcclxcblxcclxcbi8qIGRvbnQgZmlsbCBjZXJ0YWluIGVsZW1lbnRzICovXFxyXFxuLmVtLWZyYW1lLFxcclxcbi5lbS1ncmF0aWN1bGUsXFxyXFxuLmVtLWNudGJuLFxcclxcbi5lbS1ibi0wLFxcclxcbi5lbS1ibi0xLFxcclxcbi5lbS1ibi0yLFxcclxcbi5lbS1ibi0zLFxcclxcbi5lbS1rb3Nvdm8tYm4sXFxyXFxuLmVtLWJuLWNvIHtcXHJcXG4gICAgZmlsbDogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLyogdGFyZ2V0IG5vbiBjYy9ldS9lZnRhIGJvcmRlcnMgKi9cXHJcXG4vKiAuZW0tYm4tb3RoOm5vdCguZW0tYm4tY28pOm5vdCguZW0tYm4tY2MpOm5vdCguZW0tYm4tZXUpOm5vdCguZW0tYm4tZWZ0YSkge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDA7XFxyXFxufSAqL1xcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLmVtLWFubm90YXRpb24tZ3JvdXAge1xyXG4gICAgLyogcG9pbnRlci1ldmVudHM6IG5vbmU7ICovXHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL2Fubm90YXRpb25zLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLDBCQUEwQjtBQUM5QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZW0tYW5ub3RhdGlvbi1ncm91cCB7XFxyXFxuICAgIC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFwLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3Rvb2x0aXAuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8yX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVnZW5kLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfM19fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xhYmVscy5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzRfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9hbm5vdGF0aW9ucy5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzVfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9OVVRTLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNl9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3dvcmxkLmNzc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzFfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzJfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzNfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzRfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzVfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzZfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBcclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYCNlbS1sYWJlbHMge1xyXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbiAgICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcclxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBjZW50cmFsO1xyXG59XHJcblxyXG4uZW0tbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG59XHJcbi5lbS1sYWJlbC1iYWNrZ3JvdW5kIHtcclxuICAgIGZpbGw6ICNmZmZmZmY7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG4uZW0tbGFiZWwtc2hhZG93IHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZS13aWR0aDogMnB4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG4uZW0tc3RhdC1sYWJlbCB7XHJcbiAgICBvcGFjaXR5OiAxO1xyXG4gICAgZm9udC1zaXplOiAxM3B4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XHJcbiAgICBmaWxsOiAjMzEzMTMxO1xyXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbn1cclxuLmVtLXN0YXQtbGFiZWwtc2hhZG93IHtcclxuICAgIG9wYWNpdHk6IDE7XHJcbiAgICBmb250LXNpemU6IDEzcHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDRweDtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbn1cclxuLmVtLWxhYmVsLWNjIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZTogIzUwNTA1MDtcclxuICAgIHN0cm9rZS13aWR0aDogMC41cHg7XHJcbn1cclxuLmVtLWxhYmVsLXNoYWRvdy1jYyB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XHJcbn1cclxuLmVtLWxhYmVsLWNvdW50cmllcyB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICBzdHJva2U6ICM1MDUwNTA7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuNXB4O1xyXG59XHJcbi5lbS1sYWJlbC1zaGFkb3ctY291bnRyaWVzIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcclxufVxyXG4uZW0tbGFiZWwtc2VhcyB7XHJcbiAgICBmb250LXNpemU6IDlweDtcclxuICAgIGZpbGw6ICMwMDMzOTk7XHJcbiAgICBzdHJva2U6ICMwMDMzOTk7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuMnB4O1xyXG4gICAgbGV0dGVyLXNwYWNpbmc6IDNweDtcclxufVxyXG4uZW0tbGFiZWwtc2hhZG93LXNlYXMge1xyXG4gICAgZm9udC1zaXplOiA5cHg7XHJcbiAgICBsZXR0ZXItc3BhY2luZzogM3B4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xyXG59XHJcblxyXG4uZW0tZmxvdy1sYWJlbHMge1xyXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbiAgICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcclxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBjZW50cmFsO1xyXG59XHJcbi5lbS1mbG93LWxhYmVsIHtcclxuICAgIGZvbnQtc2l6ZTogMTNweDtcclxuICAgIGZpbGw6IGJsYWNrO1xyXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbn1cclxuLmVtLWZsb3ctbGFiZWwtc2hhZG93IHtcclxuICAgIGZvbnQtc2l6ZTogMTNweDtcclxuICAgIHN0cm9rZS13aWR0aDogNHB4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvbGFiZWxzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLG1CQUFtQjtJQUNuQixzQkFBc0I7SUFDdEIseUNBQXlDO0lBQ3pDLDBCQUEwQjtBQUM5Qjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGFBQWE7SUFDYixvQkFBb0I7QUFDeEI7QUFDQTtJQUNJLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsYUFBYTtBQUNqQjtBQUNBO0lBQ0ksVUFBVTtJQUNWLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsYUFBYTtJQUNiLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksVUFBVTtJQUNWLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsYUFBYTtBQUNqQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGVBQWU7SUFDZixtQkFBbUI7QUFDdkI7QUFDQTtJQUNJLGVBQWU7SUFDZixhQUFhO0lBQ2IsaUJBQWlCO0FBQ3JCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsZUFBZTtJQUNmLG1CQUFtQjtBQUN2QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGFBQWE7SUFDYixpQkFBaUI7QUFDckI7QUFDQTtJQUNJLGNBQWM7SUFDZCxhQUFhO0lBQ2IsZUFBZTtJQUNmLG1CQUFtQjtJQUNuQixtQkFBbUI7QUFDdkI7QUFDQTtJQUNJLGNBQWM7SUFDZCxtQkFBbUI7SUFDbkIsYUFBYTtJQUNiLGlCQUFpQjtBQUNyQjs7QUFFQTtJQUNJLG1CQUFtQjtJQUNuQixzQkFBc0I7SUFDdEIseUNBQXlDO0lBQ3pDLDBCQUEwQjtBQUM5QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLFdBQVc7SUFDWCxpQkFBaUI7QUFDckI7QUFDQTtJQUNJLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsYUFBYTtBQUNqQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIjZW0tbGFiZWxzIHtcXHJcXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxyXFxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBjZW50cmFsO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tbGFiZWwge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1iYWNrZ3JvdW5kIHtcXHJcXG4gICAgZmlsbDogI2ZmZmZmZjtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zaGFkb3cge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMnB4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbn1cXHJcXG4uZW0tc3RhdC1sYWJlbCB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XFxyXFxuICAgIGZpbGw6ICMzMTMxMzE7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbn1cXHJcXG4uZW0tc3RhdC1sYWJlbC1zaGFkb3cge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgICBmb250LXNpemU6IDEzcHg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogNHB4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtY2Mge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxuICAgIHN0cm9rZTogIzUwNTA1MDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjVweDtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLXNoYWRvdy1jYyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1jb3VudHJpZXMge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxuICAgIHN0cm9rZTogIzUwNTA1MDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjVweDtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLXNoYWRvdy1jb3VudHJpZXMge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtc2VhcyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogOXB4O1xcclxcbiAgICBmaWxsOiAjMDAzMzk5O1xcclxcbiAgICBzdHJva2U6ICMwMDMzOTk7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4ycHg7XFxyXFxuICAgIGxldHRlci1zcGFjaW5nOiAzcHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zaGFkb3ctc2VhcyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogOXB4O1xcclxcbiAgICBsZXR0ZXItc3BhY2luZzogM3B4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWZsb3ctbGFiZWxzIHtcXHJcXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxyXFxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBjZW50cmFsO1xcclxcbn1cXHJcXG4uZW0tZmxvdy1sYWJlbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXHJcXG4gICAgZmlsbDogYmxhY2s7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbn1cXHJcXG4uZW0tZmxvdy1sYWJlbC1zaGFkb3cge1xcclxcbiAgICBmb250LXNpemU6IDEzcHg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogNHB4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC5lbS1sZWdlbmQtYmFja2dyb3VuZCB7XHJcbiAgICBmaWxsOiB3aGl0ZTtcclxuICAgIG9wYWNpdHk6IDAuNztcclxuICAgIHJ4OiAwO1xyXG4gICAgcnk6IDA7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG4uZW0tbGVnZW5kLWxhYmVsIHtcclxuICAgIGZvbnQtc2l6ZTogMTVweDtcclxuICAgIHN0cm9rZTogbm9uZTtcclxuICAgIGZpbGw6IGJsYWNrO1xyXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IHVuc2V0O1xyXG59XHJcbi5lbS1sZWdlbmQtdGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbn1cclxuLmVtLWxlZ2VuZC1zZXBhcmF0b3Ige1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxuICAgIHN0cm9rZS13aWR0aDogMTtcclxufVxyXG4uZW0tbGVnZW5kLXRpY2sge1xyXG4gICAgc3Ryb2tlOiAjZDhkOGQ4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtZnJhbWUge1xyXG4gICAgZmlsbDogbm9uZTtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS1ub2RhdGEge1xyXG4gICAgc3Ryb2tlOiBibGFjaztcclxuICAgIHN0cm9rZS13aWR0aDogMC41O1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtYXhpcy10aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS1ub2RhdGEtbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiAxNHB4O1xyXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcclxufVxyXG4uZW0tYml2YXJpYXRlLXRpY2sge1xyXG4gICAgc3Ryb2tlOiBibGFjaztcclxuICAgIHN0cm9rZS13aWR0aDogMTtcclxufVxyXG4uZW0tYml2YXJpYXRlLXRpY2stbGFiZWwge1xyXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxufVxyXG4uZW0tYml2YXJpYXRlLXNxdWFyZSxcclxuLmVtLWxlZ2VuZC1yZWN0IHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbn1cclxuXHJcbi5lbS1iaXZhcmlhdGUtc3F1YXJlOmhvdmVyLFxyXG4uZW0tbGVnZW5kLXJlY3Q6aG92ZXIge1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAyO1xyXG4gICAgc3Ryb2tlOiByZWQ7XHJcbn1cclxuXHJcbi5lbS1waWUtc2l6ZS1sZWdlbmQtbGluZSB7XHJcbiAgICBzdHJva2UtZGFzaGFycmF5OiAyO1xyXG4gICAgc3Ryb2tlOiBncmV5O1xyXG59XHJcblxyXG4uZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lIHtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbn1cclxuXHJcbi5lbS1sZWdlbmQtaGlzdG9ncmFtLWJhciB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL2xlZ2VuZC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxXQUFXO0lBQ1gsWUFBWTtJQUNaLEtBQUs7SUFDTCxLQUFLO0lBQ0wsb0JBQW9CO0FBQ3hCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsWUFBWTtJQUNaLFdBQVc7SUFDWCx3QkFBd0I7QUFDNUI7QUFDQTtJQUNJLGVBQWU7SUFDZixXQUFXO0FBQ2Y7QUFDQTtJQUNJLGFBQWE7SUFDYixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsZUFBZTtBQUNuQjtBQUNBO0lBQ0ksVUFBVTtJQUNWLGFBQWE7QUFDakI7QUFDQTtJQUNJLGFBQWE7SUFDYixpQkFBaUI7SUFDakIsZUFBZTtBQUNuQjtBQUNBO0lBQ0ksZUFBZTtBQUNuQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLHlCQUF5QjtBQUM3QjtBQUNBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7QUFDQTtJQUNJLG1CQUFtQjtJQUNuQixlQUFlO0FBQ25CO0FBQ0E7O0lBRUksZUFBZTtJQUNmLGFBQWE7QUFDakI7O0FBRUE7O0lBRUksZUFBZTtJQUNmLFdBQVc7QUFDZjs7QUFFQTtJQUNJLG1CQUFtQjtJQUNuQixZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksYUFBYTtBQUNqQjs7QUFFQTtJQUNJLGVBQWU7QUFDbkJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmVtLWxlZ2VuZC1iYWNrZ3JvdW5kIHtcXHJcXG4gICAgZmlsbDogd2hpdGU7XFxyXFxuICAgIG9wYWNpdHk6IDAuNztcXHJcXG4gICAgcng6IDA7XFxyXFxuICAgIHJ5OiAwO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuLmVtLWxlZ2VuZC1sYWJlbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXHJcXG4gICAgc3Ryb2tlOiBub25lO1xcclxcbiAgICBmaWxsOiBibGFjaztcXHJcXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IHVuc2V0O1xcclxcbn1cXHJcXG4uZW0tbGVnZW5kLXRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcclxcbiAgICBmaWxsOiBibGFjaztcXHJcXG59XFxyXFxuLmVtLWxlZ2VuZC1zZXBhcmF0b3Ige1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDE7XFxyXFxufVxcclxcbi5lbS1sZWdlbmQtdGljayB7XFxyXFxuICAgIHN0cm9rZTogI2Q4ZDhkODtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLWZyYW1lIHtcXHJcXG4gICAgZmlsbDogbm9uZTtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS1ub2RhdGEge1xcclxcbiAgICBzdHJva2U6IGJsYWNrO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuNTtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDE1cHg7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtbm9kYXRhLWxhYmVsIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcclxcbiAgICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLXRpY2sge1xcclxcbiAgICBzdHJva2U6IGJsYWNrO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDE7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtdGljay1sYWJlbCB7XFxyXFxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS1zcXVhcmUsXFxyXFxuLmVtLWxlZ2VuZC1yZWN0IHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tYml2YXJpYXRlLXNxdWFyZTpob3ZlcixcXHJcXG4uZW0tbGVnZW5kLXJlY3Q6aG92ZXIge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDI7XFxyXFxuICAgIHN0cm9rZTogcmVkO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tcGllLXNpemUtbGVnZW5kLWxpbmUge1xcclxcbiAgICBzdHJva2UtZGFzaGFycmF5OiAyO1xcclxcbiAgICBzdHJva2U6IGdyZXk7XFxyXFxufVxcclxcblxcclxcbi5lbS1sZWdlbmQtZGl2ZXJnaW5nLWxpbmUge1xcclxcbiAgICBzdHJva2U6IGJsYWNrO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tbGVnZW5kLWhpc3RvZ3JhbS1iYXIge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLyogR2VuZXJhbCB0ZXh0IHNldHRpbmdzICovXHJcbnRleHQge1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuXHJcbmEgdGV4dCB7XHJcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xyXG59XHJcblxyXG4vKiBNYWluIG1hcCAqL1xyXG4uZW0tbWFwLFxyXG4uZW0tbGVnZW5kIHtcclxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xyXG59XHJcblxyXG4vKiBDb2FzdGFsIG1hcmdpbiAqL1xyXG4jZW0tY29hc3QtbWFyZ2luIHtcclxuICAgIGZpbHRlcjogdXJsKCNlbS1jb2FzdGFsLWJsdXIpO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcclxuICAgIGZpbGw6IG5vbmU7XHJcbiAgICBzdHJva2Utd2lkdGg6IDU7XHJcbiAgICBzdHJva2U6IHJnYigxNjEsIDE5OCwgMjM3KTtcclxufVxyXG5cclxuLyogVGl0bGUgYW5kIHN1YnRpdGxlIHN0eWxpbmcgKi9cclxuLmVtLXRpdGxlLFxyXG4uZW0taW5zZXQtdGl0bGUge1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbiAgICBzdHJva2U6IG5vbmU7XHJcbn1cclxuXHJcbi5lbS10aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDIxcHg7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxufVxyXG5cclxuLmVtLWluc2V0LXRpdGxlIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxufVxyXG5cclxuLmVtLXN1YnRpdGxlLFxyXG4uZW0taW5zZXQtc3VidGl0bGUge1xyXG4gICAgZmlsbDogIzg0ODI4MDtcclxuICAgIHN0cm9rZTogbm9uZTtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbiAgICBwYWludC1vcmRlcjogc3Ryb2tlO1xyXG59XHJcblxyXG4uZW0tc3VidGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxOHB4O1xyXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcclxufVxyXG5cclxuLmVtLWluc2V0LXN1YnRpdGxlIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxufVxyXG5cclxuLmVtLXNvdXJjZS1wcmV0ZXh0IHtcclxuICAgIGZvbnQtc2l6ZTogMTFweDtcclxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01cHgsIC01cHgpO1xyXG59XHJcbi5lbS1zb3VyY2UtZGF0YXNldC1saW5rIHtcclxuICAgIGZvbnQtc2l6ZTogMTFweDtcclxuICAgIGZpbGw6ICMwZTQ3Y2I7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcclxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01cHgsIC01cHgpO1xyXG59XHJcbi5lbS1zb3VyY2UtZGF0YXNldC1saW5rOmhvdmVyIHtcclxuICAgIGZpbGw6ICMwODJiN2E7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcclxufVxyXG5cclxuLmVtLWZyYW1lIHtcclxuICAgIHN0cm9rZS13aWR0aDogMDtcclxuICAgIHN0cm9rZTogZ3JleTtcclxufVxyXG5cclxuLmVtLWluc2V0cyAuZW0tZnJhbWUge1xyXG4gICAgLyogdGhpcyB3aWxsIGdpdmUgYSBmcmFtZSB0byBpbnNldCBtYXBzICovXHJcbiAgICBzdHJva2U6IGdyZXk7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuM3B4ICFpbXBvcnRhbnQ7XHJcbn1cclxuXHJcbi5lbS1zZWEge1xyXG4gICAgZmlsbDogd2hpdGU7XHJcbiAgICAvKiBwb2ludGVyLWV2ZW50czogbm9uZTsgKi9cclxufVxyXG4uZW0tc2NhbGViYXItbGluZSB7XHJcbiAgICBzdHJva2U6IGJsYWNrO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjhweDtcclxufVxyXG4uZW0tc2NhbGViYXItbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiA5cHg7XHJcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xyXG59XHJcblxyXG4vKiBCb3R0b20gdGV4dCBhbmQgc3ltYm9sIHN0eWxpbmcgKi9cclxuLmVtLWZvb3Rub3RlIHtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XHJcbiAgICBmb250LXNpemU6IDExcHg7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg1cHgsIC01cHgpO1xyXG59XHJcbi5lbS1mb290bm90ZSBhIHtcclxuICAgIGZpbGw6ICMwZTQ3Y2I7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcclxufVxyXG4uZW0tZm9vdG5vdGUgYTpob3ZlciB7XHJcbiAgICBmaWxsOiAjMGEzMjhlO1xyXG59XHJcblxyXG4uZW0tY2VudHJvaWQge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcblxyXG4vKiBHcmF0aWN1bGUgc3R5bGluZyAqL1xyXG4uZW0tZ3JhdGljdWxlIHtcclxuICAgIHN0cm9rZTogbGlnaHRncmF5O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xyXG59XHJcblxyXG4uZW0tZmxvdy1saW5rIHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG4uZW0tZmxvdy1saW5rLW91dGxpbmUge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcbi5lbS1mbG93LWxhYmVscyB7XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDFweDtcclxuICAgIGZpbGw6IGJsYWNrO1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuLmVtLWZsb3ctbGFiZWxzLWhhbG8ge1xyXG4gICAgZm9udC1zaXplOiAxNXB4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XHJcbiAgICBmaWxsOiB3aGl0ZTtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG59XHJcblxyXG4uZW0tZ3JpZC1yZWN0LFxyXG4uZW0tZ3JpZC1oZXhhZ29uIHtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL21hcC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsMEJBQTBCO0FBQzFCO0lBQ0ksb0JBQW9CO0FBQ3hCOztBQUVBO0lBQ0ksbUJBQW1CO0FBQ3ZCOztBQUVBLGFBQWE7QUFDYjs7SUFFSSx5Q0FBeUM7QUFDN0M7O0FBRUEsbUJBQW1CO0FBQ25CO0lBQ0ksNkJBQTZCO0lBQzdCLHNCQUFzQjtJQUN0QixxQkFBcUI7SUFDckIsVUFBVTtJQUNWLGVBQWU7SUFDZiwwQkFBMEI7QUFDOUI7O0FBRUEsK0JBQStCO0FBQy9COztJQUVJLFdBQVc7SUFDWCxZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtBQUNyQjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7O0FBRUE7O0lBRUksYUFBYTtJQUNiLFlBQVk7SUFDWixzQkFBc0I7SUFDdEIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksZUFBZTtJQUNmLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsZ0NBQWdDO0FBQ3BDO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsYUFBYTtJQUNiLGVBQWU7SUFDZiwwQkFBMEI7SUFDMUIsZ0NBQWdDO0FBQ3BDO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsZUFBZTtJQUNmLDBCQUEwQjtBQUM5Qjs7QUFFQTtJQUNJLGVBQWU7SUFDZixZQUFZO0FBQ2hCOztBQUVBO0lBQ0kseUNBQXlDO0lBQ3pDLFlBQVk7SUFDWiw4QkFBOEI7QUFDbEM7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsMEJBQTBCO0FBQzlCO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0FBQ3ZCO0FBQ0E7SUFDSSxjQUFjO0lBQ2QsbUJBQW1CO0FBQ3ZCOztBQUVBLG1DQUFtQztBQUNuQztJQUNJLG1CQUFtQjtJQUNuQixlQUFlO0lBQ2YsZUFBZTtJQUNmLCtCQUErQjtBQUNuQztBQUNBO0lBQ0ksYUFBYTtJQUNiLDBCQUEwQjtBQUM5QjtBQUNBO0lBQ0ksYUFBYTtBQUNqQjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7O0FBRUEsc0JBQXNCO0FBQ3RCO0lBQ0ksaUJBQWlCO0lBQ2pCLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxlQUFlO0FBQ25CO0FBQ0E7SUFDSSxlQUFlO0FBQ25CO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLFdBQVc7SUFDWCxvQkFBb0I7QUFDeEI7QUFDQTtJQUNJLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsV0FBVztJQUNYLG9CQUFvQjtBQUN4Qjs7QUFFQTs7SUFFSSxhQUFhO0FBQ2pCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qIEdlbmVyYWwgdGV4dCBzZXR0aW5ncyAqL1xcclxcbnRleHQge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuYSB0ZXh0IHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXHJcXG59XFxyXFxuXFxyXFxuLyogTWFpbiBtYXAgKi9cXHJcXG4uZW0tbWFwLFxcclxcbi5lbS1sZWdlbmQge1xcclxcbiAgICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXFxyXFxuLyogQ29hc3RhbCBtYXJnaW4gKi9cXHJcXG4jZW0tY29hc3QtbWFyZ2luIHtcXHJcXG4gICAgZmlsdGVyOiB1cmwoI2VtLWNvYXN0YWwtYmx1cik7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcXHJcXG4gICAgZmlsbDogbm9uZTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiA1O1xcclxcbiAgICBzdHJva2U6IHJnYigxNjEsIDE5OCwgMjM3KTtcXHJcXG59XFxyXFxuXFxyXFxuLyogVGl0bGUgYW5kIHN1YnRpdGxlIHN0eWxpbmcgKi9cXHJcXG4uZW0tdGl0bGUsXFxyXFxuLmVtLWluc2V0LXRpdGxlIHtcXHJcXG4gICAgZmlsbDogYmxhY2s7XFxyXFxuICAgIHN0cm9rZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAyMXB4O1xcclxcbiAgICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWluc2V0LXRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tc3VidGl0bGUsXFxyXFxuLmVtLWluc2V0LXN1YnRpdGxlIHtcXHJcXG4gICAgZmlsbDogIzg0ODI4MDtcXHJcXG4gICAgc3Ryb2tlOiBub25lO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbiAgICBwYWludC1vcmRlcjogc3Ryb2tlO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tc3VidGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDE4cHg7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XFxyXFxufVxcclxcblxcclxcbi5lbS1pbnNldC1zdWJ0aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXNvdXJjZS1wcmV0ZXh0IHtcXHJcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNXB4LCAtNXB4KTtcXHJcXG59XFxyXFxuLmVtLXNvdXJjZS1kYXRhc2V0LWxpbmsge1xcclxcbiAgICBmb250LXNpemU6IDExcHg7XFxyXFxuICAgIGZpbGw6ICMwZTQ3Y2I7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01cHgsIC01cHgpO1xcclxcbn1cXHJcXG4uZW0tc291cmNlLWRhdGFzZXQtbGluazpob3ZlciB7XFxyXFxuICAgIGZpbGw6ICMwODJiN2E7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxyXFxufVxcclxcblxcclxcbi5lbS1mcmFtZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMDtcXHJcXG4gICAgc3Ryb2tlOiBncmV5O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0taW5zZXRzIC5lbS1mcmFtZSB7XFxyXFxuICAgIC8qIHRoaXMgd2lsbCBnaXZlIGEgZnJhbWUgdG8gaW5zZXQgbWFwcyAqL1xcclxcbiAgICBzdHJva2U6IGdyZXk7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4zcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXNlYSB7XFxyXFxuICAgIGZpbGw6IHdoaXRlO1xcclxcbiAgICAvKiBwb2ludGVyLWV2ZW50czogbm9uZTsgKi9cXHJcXG59XFxyXFxuLmVtLXNjYWxlYmFyLWxpbmUge1xcclxcbiAgICBzdHJva2U6IGJsYWNrO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuOHB4O1xcclxcbn1cXHJcXG4uZW0tc2NhbGViYXItbGFiZWwge1xcclxcbiAgICBmb250LXNpemU6IDlweDtcXHJcXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcXHJcXG59XFxyXFxuXFxyXFxuLyogQm90dG9tIHRleHQgYW5kIHN5bWJvbCBzdHlsaW5nICovXFxyXFxuLmVtLWZvb3Rub3RlIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXHJcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcclxcbiAgICBmb250LXNpemU6IDExcHg7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDVweCwgLTVweCk7XFxyXFxufVxcclxcbi5lbS1mb290bm90ZSBhIHtcXHJcXG4gICAgZmlsbDogIzBlNDdjYjtcXHJcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxyXFxufVxcclxcbi5lbS1mb290bm90ZSBhOmhvdmVyIHtcXHJcXG4gICAgZmlsbDogIzBhMzI4ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWNlbnRyb2lkIHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBHcmF0aWN1bGUgc3R5bGluZyAqL1xcclxcbi5lbS1ncmF0aWN1bGUge1xcclxcbiAgICBzdHJva2U6IGxpZ2h0Z3JheTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tZmxvdy1saW5rIHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uZW0tZmxvdy1saW5rLW91dGxpbmUge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcbi5lbS1mbG93LWxhYmVscyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxcHg7XFxyXFxuICAgIGZpbGw6IGJsYWNrO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGFiZWxzLWhhbG8ge1xcclxcbiAgICBmb250LXNpemU6IDE1cHg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMnB4O1xcclxcbiAgICBmaWxsOiB3aGl0ZTtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5lbS1ncmlkLXJlY3QsXFxyXFxuLmVtLWdyaWQtaGV4YWdvbiB7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLmVzdGF0LXZpcy10b29sdGlwLXRleHQge1xyXG4gICAgYmFja2dyb3VuZDogI2ZmZmZmZjtcclxuICAgIGNvbG9yOiAjMTcxYTIyO1xyXG4gICAgcGFkZGluZzogNHB4O1xyXG4gICAgZm9udC1zaXplOiAxNnB4O1xyXG59XHJcbi5lc3RhdC12aXMtdG9vbHRpcC1iYXIge1xyXG4gICAgYmFja2dyb3VuZDogIzUxNTU2MDtcclxuICAgIGNvbG9yOiAjZmZmZmZmO1xyXG4gICAgcGFkZGluZzogNnB4O1xyXG4gICAgZm9udC1zaXplOiAxNnB4O1xyXG59XHJcbi50b29sdGlwLWV1cm9zdGF0IHtcclxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbDtcclxuICAgIG1heC13aWR0aDogMjUwcHg7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgICBwYWRkaW5nOiAwcHg7XHJcbiAgICBib3JkZXI6IDBweDtcclxuICAgIGJvcmRlci1yYWRpdXM6IDBweDtcclxuICAgIGJveC1zaGFkb3c6IDBweCA0cHggNnB4IHJnYmEoMCwgMCwgMCwgMC4xKSwgMHB4IDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbiAgICBvcGFjaXR5OiAwO1xyXG4gICAgei1pbmRleDogOTk5OTk5OTk7XHJcbn1cclxuLmVtLXRvb2x0aXAtcGllY2hhcnQtYnJlYWtkb3duIHtcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbiAgICBmb250LXNpemU6IDE0cHg7XHJcbn1cclxuLmVtLXRvb2x0aXAtcGllY2hhcnQtY29udGFpbmVyIHtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxufVxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvdG9vbHRpcC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxtQkFBbUI7SUFDbkIsY0FBYztJQUNkLFlBQVk7SUFDWixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxtQkFBbUI7SUFDbkIsY0FBYztJQUNkLFlBQVk7SUFDWixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxrQkFBa0I7SUFDbEIsZ0JBQWdCO0lBQ2hCLGdCQUFnQjtJQUNoQixpQkFBaUI7SUFDakIsWUFBWTtJQUNaLFdBQVc7SUFDWCxrQkFBa0I7SUFDbEIsMkVBQTJFO0lBQzNFLGtCQUFrQjtJQUNsQix5Q0FBeUM7SUFDekMsb0JBQW9CO0lBQ3BCLFVBQVU7SUFDVixpQkFBaUI7QUFDckI7QUFDQTtJQUNJLGFBQWE7SUFDYixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxrQkFBa0I7QUFDdEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmVzdGF0LXZpcy10b29sdGlwLXRleHQge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xcclxcbiAgICBjb2xvcjogIzE3MWEyMjtcXHJcXG4gICAgcGFkZGluZzogNHB4O1xcclxcbiAgICBmb250LXNpemU6IDE2cHg7XFxyXFxufVxcclxcbi5lc3RhdC12aXMtdG9vbHRpcC1iYXIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjNTE1NTYwO1xcclxcbiAgICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gICAgcGFkZGluZzogNnB4O1xcclxcbiAgICBmb250LXNpemU6IDE2cHg7XFxyXFxufVxcclxcbi50b29sdGlwLWV1cm9zdGF0IHtcXHJcXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsO1xcclxcbiAgICBtYXgtd2lkdGg6IDI1MHB4O1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXHJcXG4gICAgcGFkZGluZzogMHB4O1xcclxcbiAgICBib3JkZXI6IDBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xcclxcbiAgICBib3gtc2hhZG93OiAwcHggNHB4IDZweCByZ2JhKDAsIDAsIDAsIDAuMSksIDBweCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB6LWluZGV4OiA5OTk5OTk5OTtcXHJcXG59XFxyXFxuLmVtLXRvb2x0aXAtcGllY2hhcnQtYnJlYWtkb3duIHtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcclxcbn1cXHJcXG4uZW0tdG9vbHRpcC1waWVjaGFydC1jb250YWluZXIge1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgI2dfd29ybGRibixcclxuLmVtLXdvcmxkcmcsXHJcbi5lbS13b3JsZGJuIHtcclxuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbn1cclxuXHJcbi5lbS13b3JsZGJuIHtcclxuICAgIHN0cm9rZTogIzAwMDtcclxuICAgIHN0cm9rZS13aWR0aDogMC4zcHg7XHJcbn1cclxuXHJcbi5lbS13b3JsZGJuIHtcclxuICAgIGZpbGw6IG5vbmU7XHJcbn1cclxuXHJcbi5lbS13b3JsZHJnIHtcclxuICAgIGZpbGw6ICNlZmVmZWY7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuXHJcbi5lbS1ibi1kIHtcclxuICAgIC8qIGRpc3B1dGVkICovXHJcbiAgICBzdHJva2U6ICMwMDA7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuMTtcclxuICAgIGZpbGw6IG5vbmU7XHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL3dvcmxkLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7O0lBR0kscUJBQXFCO0lBQ3JCLHNCQUFzQjtBQUMxQjs7QUFFQTtJQUNJLFlBQVk7SUFDWixtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSSxVQUFVO0FBQ2Q7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsZUFBZTtBQUNuQjs7QUFFQTtJQUNJLGFBQWE7SUFDYixZQUFZO0lBQ1osaUJBQWlCO0lBQ2pCLFVBQVU7QUFDZFwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIjZ193b3JsZGJuLFxcclxcbi5lbS13b3JsZHJnLFxcclxcbi5lbS13b3JsZGJuIHtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0td29ybGRibiB7XFxyXFxuICAgIHN0cm9rZTogIzAwMDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjNweDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXdvcmxkYm4ge1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0td29ybGRyZyB7XFxyXFxuICAgIGZpbGw6ICNlZmVmZWY7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWJuLWQge1xcclxcbiAgICAvKiBkaXNwdXRlZCAqL1xcclxcbiAgICBzdHJva2U6ICMwMDA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4xO1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID09IG51bGwgfHwgYiA9PSBudWxsID8gTmFOIDogYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuaW1wb3J0IGJpc2VjdG9yIGZyb20gXCIuL2Jpc2VjdG9yLmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG5jb25zdCBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuZXhwb3J0IGNvbnN0IGJpc2VjdFJpZ2h0ID0gYXNjZW5kaW5nQmlzZWN0LnJpZ2h0O1xuZXhwb3J0IGNvbnN0IGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcbmV4cG9ydCBjb25zdCBiaXNlY3RDZW50ZXIgPSBiaXNlY3RvcihudW1iZXIpLmNlbnRlcjtcbmV4cG9ydCBkZWZhdWx0IGJpc2VjdFJpZ2h0O1xuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmlzZWN0b3IoZikge1xuICBsZXQgY29tcGFyZTEsIGNvbXBhcmUyLCBkZWx0YTtcblxuICAvLyBJZiBhbiBhY2Nlc3NvciBpcyBzcGVjaWZpZWQsIHByb21vdGUgaXQgdG8gYSBjb21wYXJhdG9yLiBJbiB0aGlzIGNhc2Ugd2VcbiAgLy8gY2FuIHRlc3Qgd2hldGhlciB0aGUgc2VhcmNoIHZhbHVlIGlzIChzZWxmLSkgY29tcGFyYWJsZS4gV2UgY2Fu4oCZdCBkbyB0aGlzXG4gIC8vIGZvciBhIGNvbXBhcmF0b3IgKGV4Y2VwdCBmb3Igc3BlY2lmaWMsIGtub3duIGNvbXBhcmF0b3JzKSBiZWNhdXNlIHdlIGNhbuKAmXRcbiAgLy8gdGVsbCBpZiB0aGUgY29tcGFyYXRvciBpcyBzeW1tZXRyaWMsIGFuZCBhbiBhc3ltbWV0cmljIGNvbXBhcmF0b3IgY2Fu4oCZdCBiZVxuICAvLyB1c2VkIHRvIHRlc3Qgd2hldGhlciBhIHNpbmdsZSB2YWx1ZSBpcyBjb21wYXJhYmxlLlxuICBpZiAoZi5sZW5ndGggIT09IDIpIHtcbiAgICBjb21wYXJlMSA9IGFzY2VuZGluZztcbiAgICBjb21wYXJlMiA9IChkLCB4KSA9PiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgZGVsdGEgPSAoZCwgeCkgPT4gZihkKSAtIHg7XG4gIH0gZWxzZSB7XG4gICAgY29tcGFyZTEgPSBmID09PSBhc2NlbmRpbmcgfHwgZiA9PT0gZGVzY2VuZGluZyA/IGYgOiB6ZXJvO1xuICAgIGNvbXBhcmUyID0gZjtcbiAgICBkZWx0YSA9IGY7XG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvID0gMCwgaGkgPSBhLmxlbmd0aCkge1xuICAgIGlmIChsbyA8IGhpKSB7XG4gICAgICBpZiAoY29tcGFyZTEoeCwgeCkgIT09IDApIHJldHVybiBoaTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH0gd2hpbGUgKGxvIDwgaGkpO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiByaWdodChhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBpZiAobG8gPCBoaSkge1xuICAgICAgaWYgKGNvbXBhcmUxKHgsIHgpICE9PSAwKSByZXR1cm4gaGk7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPD0gMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGhpID0gbWlkO1xuICAgICAgfSB3aGlsZSAobG8gPCBoaSk7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRlcihhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTtcbiAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgY2VudGVyLCByaWdodH07XG59XG5cbmZ1bmN0aW9uIHplcm8oKSB7XG4gIHJldHVybiAwO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID09IG51bGwgfHwgYiA9PSBudWxsID8gTmFOXG4gICAgOiBiIDwgYSA/IC0xXG4gICAgOiBiID4gYSA/IDFcbiAgICA6IGIgPj0gYSA/IDBcbiAgICA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbbWluLCBtYXhdO1xufVxuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvYTc0ZWVhMjM4ZjViYWJhMTU3OTdlMmU4YjU3MGQxNTNiYzg2OTBhNy9Nb2R1bGVzL21hdGhtb2R1bGUuYyNMMTQyM1xuZXhwb3J0IGNsYXNzIEFkZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGFydGlhbHMgPSBuZXcgRmxvYXQ2NEFycmF5KDMyKTtcbiAgICB0aGlzLl9uID0gMDtcbiAgfVxuICBhZGQoeCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wYXJ0aWFscztcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9uICYmIGogPCAzMjsgaisrKSB7XG4gICAgICBjb25zdCB5ID0gcFtqXSxcbiAgICAgICAgaGkgPSB4ICsgeSxcbiAgICAgICAgbG8gPSBNYXRoLmFicyh4KSA8IE1hdGguYWJzKHkpID8geCAtIChoaSAtIHkpIDogeSAtIChoaSAtIHgpO1xuICAgICAgaWYgKGxvKSBwW2krK10gPSBsbztcbiAgICAgIHggPSBoaTtcbiAgICB9XG4gICAgcFtpXSA9IHg7XG4gICAgdGhpcy5fbiA9IGkgKyAxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhbHVlT2YoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX3BhcnRpYWxzO1xuICAgIGxldCBuID0gdGhpcy5fbiwgeCwgeSwgbG8sIGhpID0gMDtcbiAgICBpZiAobiA+IDApIHtcbiAgICAgIGhpID0gcFstLW5dO1xuICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgIHggPSBoaTtcbiAgICAgICAgeSA9IHBbLS1uXTtcbiAgICAgICAgaGkgPSB4ICsgeTtcbiAgICAgICAgbG8gPSB5IC0gKGhpIC0geCk7XG4gICAgICAgIGlmIChsbykgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobiA+IDAgJiYgKChsbyA8IDAgJiYgcFtuIC0gMV0gPCAwKSB8fCAobG8gPiAwICYmIHBbbiAtIDFdID4gMCkpKSB7XG4gICAgICAgIHkgPSBsbyAqIDI7XG4gICAgICAgIHggPSBoaSArIHk7XG4gICAgICAgIGlmICh5ID09IHggLSBoaSkgaGkgPSB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZzdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGNvbnN0IGFkZGVyID0gbmV3IEFkZGVyKCk7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZSkge1xuICAgICAgICBhZGRlci5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSB7XG4gICAgICAgIGFkZGVyLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiArYWRkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmY3Vtc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBjb25zdCBhZGRlciA9IG5ldyBBZGRlcigpO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgcmV0dXJuIEZsb2F0NjRBcnJheS5mcm9tKHZhbHVlcywgdmFsdWVvZiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHYgPT4gYWRkZXIuYWRkKCt2IHx8IDApXG4gICAgICA6IHYgPT4gYWRkZXIuYWRkKCt2YWx1ZW9mKHYsICsraW5kZXgsIHZhbHVlcykgfHwgMClcbiAgKTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyZWF0ZXN0KHZhbHVlcywgY29tcGFyZSA9IGFzY2VuZGluZykge1xuICBsZXQgbWF4O1xuICBsZXQgZGVmaW5lZCA9IGZhbHNlO1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgbWF4VmFsdWU7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb21wYXJlKGVsZW1lbnQpO1xuICAgICAgaWYgKGRlZmluZWRcbiAgICAgICAgICA/IGFzY2VuZGluZyh2YWx1ZSwgbWF4VmFsdWUpID4gMFxuICAgICAgICAgIDogYXNjZW5kaW5nKHZhbHVlLCB2YWx1ZSkgPT09IDApIHtcbiAgICAgICAgbWF4ID0gZWxlbWVudDtcbiAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoZGVmaW5lZFxuICAgICAgICAgID8gY29tcGFyZSh2YWx1ZSwgbWF4KSA+IDBcbiAgICAgICAgICA6IGNvbXBhcmUodmFsdWUsIHZhbHVlKSA9PT0gMCkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtYXg7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXhJbmRleCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1heDtcbiAgbGV0IG1heEluZGV4ID0gLTE7XG4gIGxldCBpbmRleCA9IC0xO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZSwgbWF4SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZSwgbWF4SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufVxuIiwiZnVuY3Rpb24qIGZsYXR0ZW4oYXJyYXlzKSB7XG4gIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgeWllbGQqIGFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlKGFycmF5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShmbGF0dGVuKGFycmF5cykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluSW5kZXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGxldCBtaW5JbmRleCA9IC0xO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWUsIG1pbkluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWUsIG1pbkluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5JbmRleDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG51bWJlcih4KSB7XG4gIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogbnVtYmVycyh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGVybXV0ZShzb3VyY2UsIGtleXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oa2V5cywga2V5ID0+IHNvdXJjZVtrZXldKTtcbn1cbiIsImltcG9ydCBtYXggZnJvbSBcIi4vbWF4LmpzXCI7XG5pbXBvcnQgbWF4SW5kZXggZnJvbSBcIi4vbWF4SW5kZXguanNcIjtcbmltcG9ydCBtaW4gZnJvbSBcIi4vbWluLmpzXCI7XG5pbXBvcnQgbWluSW5kZXggZnJvbSBcIi4vbWluSW5kZXguanNcIjtcbmltcG9ydCBxdWlja3NlbGVjdCBmcm9tIFwiLi9xdWlja3NlbGVjdC5qc1wiO1xuaW1wb3J0IG51bWJlciwge251bWJlcnN9IGZyb20gXCIuL251bWJlci5qc1wiO1xuaW1wb3J0IHthc2NlbmRpbmdEZWZpbmVkfSBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgZ3JlYXRlc3QgZnJvbSBcIi4vZ3JlYXRlc3QuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSk7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSB8fCBpc05hTihwID0gK3ApKSByZXR1cm47XG4gIGlmIChwIDw9IDAgfHwgbiA8IDIpIHJldHVybiBtaW4odmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuIG1heCh2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9IG1heChxdWlja3NlbGVjdCh2YWx1ZXMsIGkwKS5zdWJhcnJheSgwLCBpMCArIDEpKSxcbiAgICAgIHZhbHVlMSA9IG1pbih2YWx1ZXMuc3ViYXJyYXkoaTAgKyAxKSk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQodmFsdWVzLCBwLCB2YWx1ZW9mID0gbnVtYmVyKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSB8fCBpc05hTihwID0gK3ApKSByZXR1cm47XG4gIGlmIChwIDw9IDAgfHwgbiA8IDIpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbMF0sIDAsIHZhbHVlcyk7XG4gIGlmIChwID49IDEpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbbiAtIDFdLCBuIC0gMSwgdmFsdWVzKTtcbiAgdmFyIG4sXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXG4gICAgICBpMCA9IE1hdGguZmxvb3IoaSksXG4gICAgICB2YWx1ZTAgPSArdmFsdWVvZih2YWx1ZXNbaTBdLCBpMCwgdmFsdWVzKSxcbiAgICAgIHZhbHVlMSA9ICt2YWx1ZW9mKHZhbHVlc1tpMCArIDFdLCBpMCArIDEsIHZhbHVlcyk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpbGVJbmRleCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKGlzTmFOKHAgPSArcCkpIHJldHVybjtcbiAgbnVtYmVycyA9IEZsb2F0NjRBcnJheS5mcm9tKHZhbHVlcywgKF8sIGkpID0+IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpO1xuICBpZiAocCA8PSAwKSByZXR1cm4gbWluSW5kZXgobnVtYmVycyk7XG4gIGlmIChwID49IDEpIHJldHVybiBtYXhJbmRleChudW1iZXJzKTtcbiAgdmFyIG51bWJlcnMsXG4gICAgICBpbmRleCA9IFVpbnQzMkFycmF5LmZyb20odmFsdWVzLCAoXywgaSkgPT4gaSksXG4gICAgICBqID0gbnVtYmVycy5sZW5ndGggLSAxLFxuICAgICAgaSA9IE1hdGguZmxvb3IoaiAqIHApO1xuICBxdWlja3NlbGVjdChpbmRleCwgaSwgMCwgaiwgKGksIGopID0+IGFzY2VuZGluZ0RlZmluZWQobnVtYmVyc1tpXSwgbnVtYmVyc1tqXSkpO1xuICBpID0gZ3JlYXRlc3QoaW5kZXguc3ViYXJyYXkoMCwgaSArIDEpLCAoaSkgPT4gbnVtYmVyc1tpXSk7XG4gIHJldHVybiBpID49IDAgPyBpIDogLTE7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZ0RlZmluZWQsIGNvbXBhcmVEZWZpbmVkfSBmcm9tIFwiLi9zb3J0LmpzXCI7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3F1aWNrc2VsZWN0XG4vLyBJU0MgbGljZW5zZSwgQ29weXJpZ2h0IDIwMTggVmxhZGltaXIgQWdhZm9ua2luLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyYXksIGssIGxlZnQgPSAwLCByaWdodCA9IEluZmluaXR5LCBjb21wYXJlKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBsZWZ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBsZWZ0KSk7XG4gIHJpZ2h0ID0gTWF0aC5mbG9vcihNYXRoLm1pbihhcnJheS5sZW5ndGggLSAxLCByaWdodCkpO1xuXG4gIGlmICghKGxlZnQgPD0gayAmJiBrIDw9IHJpZ2h0KSkgcmV0dXJuIGFycmF5O1xuXG4gIGNvbXBhcmUgPSBjb21wYXJlID09PSB1bmRlZmluZWQgPyBhc2NlbmRpbmdEZWZpbmVkIDogY29tcGFyZURlZmluZWQoY29tcGFyZSk7XG5cbiAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICBxdWlja3NlbGVjdChhcnJheSwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBhcnJheVtrXTtcbiAgICBsZXQgaSA9IGxlZnQ7XG4gICAgbGV0IGogPSByaWdodDtcblxuICAgIHN3YXAoYXJyYXksIGxlZnQsIGspO1xuICAgIGlmIChjb21wYXJlKGFycmF5W3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFycmF5LCBsZWZ0LCByaWdodCk7XG5cbiAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgIHN3YXAoYXJyYXksIGksIGopLCArK2ksIC0tajtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2ldLCB0KSA8IDApICsraTtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2pdLCB0KSA+IDApIC0tajtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFyZShhcnJheVtsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyYXksIGxlZnQsIGopO1xuICAgIGVsc2UgKytqLCBzd2FwKGFycmF5LCBqLCByaWdodCk7XG5cbiAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gc3dhcChhcnJheSwgaSwgaikge1xuICBjb25zdCB0ID0gYXJyYXlbaV07XG4gIGFycmF5W2ldID0gYXJyYXlbal07XG4gIGFycmF5W2pdID0gdDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIHN0YXJ0ID0gK3N0YXJ0LCBzdG9wID0gK3N0b3AsIHN0ZXAgPSAobiA9IGFyZ3VtZW50cy5sZW5ndGgpIDwgMiA/IChzdG9wID0gc3RhcnQsIHN0YXJ0ID0gMCwgMSkgOiBuIDwgMyA/IDEgOiArc3RlcDtcblxuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKSB8IDAsXG4gICAgICByYW5nZSA9IG5ldyBBcnJheShuKTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIHJhbmdlW2ldID0gc3RhcnQgKyBpICogc3RlcDtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgcGVybXV0ZSBmcm9tIFwiLi9wZXJtdXRlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvcnQodmFsdWVzLCAuLi5GKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbHVlcyBpcyBub3QgaXRlcmFibGVcIik7XG4gIHZhbHVlcyA9IEFycmF5LmZyb20odmFsdWVzKTtcbiAgbGV0IFtmXSA9IEY7XG4gIGlmICgoZiAmJiBmLmxlbmd0aCAhPT0gMikgfHwgRi5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgaW5kZXggPSBVaW50MzJBcnJheS5mcm9tKHZhbHVlcywgKGQsIGkpID0+IGkpO1xuICAgIGlmIChGLmxlbmd0aCA+IDEpIHtcbiAgICAgIEYgPSBGLm1hcChmID0+IHZhbHVlcy5tYXAoZikpO1xuICAgICAgaW5kZXguc29ydCgoaSwgaikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgRikge1xuICAgICAgICAgIGNvbnN0IGMgPSBhc2NlbmRpbmdEZWZpbmVkKGZbaV0sIGZbal0pO1xuICAgICAgICAgIGlmIChjKSByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSB2YWx1ZXMubWFwKGYpO1xuICAgICAgaW5kZXguc29ydCgoaSwgaikgPT4gYXNjZW5kaW5nRGVmaW5lZChmW2ldLCBmW2pdKSk7XG4gICAgfVxuICAgIHJldHVybiBwZXJtdXRlKHZhbHVlcywgaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWx1ZXMuc29ydChjb21wYXJlRGVmaW5lZChmKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlRGVmaW5lZChjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIGlmIChjb21wYXJlID09PSBhc2NlbmRpbmcpIHJldHVybiBhc2NlbmRpbmdEZWZpbmVkO1xuICBpZiAodHlwZW9mIGNvbXBhcmUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbXBhcmUgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gIHJldHVybiAoYSwgYikgPT4ge1xuICAgIGNvbnN0IHggPSBjb21wYXJlKGEsIGIpO1xuICAgIGlmICh4IHx8IHggPT09IDApIHJldHVybiB4O1xuICAgIHJldHVybiAoY29tcGFyZShiLCBiKSA9PT0gMCkgLSAoY29tcGFyZShhLCBhKSA9PT0gMCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2NlbmRpbmdEZWZpbmVkKGEsIGIpIHtcbiAgcmV0dXJuIChhID09IG51bGwgfHwgIShhID49IGEpKSAtIChiID09IG51bGwgfHwgIShiID49IGIpKSB8fCAoYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDApO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgc3VtID0gMDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkge1xuICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG4iLCJjb25zdCBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZnVuY3Rpb24gdGlja1NwZWMoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIGNvbnN0IHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHN0ZXApKSxcbiAgICAgIGVycm9yID0gc3RlcCAvIE1hdGgucG93KDEwLCBwb3dlciksXG4gICAgICBmYWN0b3IgPSBlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDE7XG4gIGxldCBpMSwgaTIsIGluYztcbiAgaWYgKHBvd2VyIDwgMCkge1xuICAgIGluYyA9IE1hdGgucG93KDEwLCAtcG93ZXIpIC8gZmFjdG9yO1xuICAgIGkxID0gTWF0aC5yb3VuZChzdGFydCAqIGluYyk7XG4gICAgaTIgPSBNYXRoLnJvdW5kKHN0b3AgKiBpbmMpO1xuICAgIGlmIChpMSAvIGluYyA8IHN0YXJ0KSArK2kxO1xuICAgIGlmIChpMiAvIGluYyA+IHN0b3ApIC0taTI7XG4gICAgaW5jID0gLWluYztcbiAgfSBlbHNlIHtcbiAgICBpbmMgPSBNYXRoLnBvdygxMCwgcG93ZXIpICogZmFjdG9yO1xuICAgIGkxID0gTWF0aC5yb3VuZChzdGFydCAvIGluYyk7XG4gICAgaTIgPSBNYXRoLnJvdW5kKHN0b3AgLyBpbmMpO1xuICAgIGlmIChpMSAqIGluYyA8IHN0YXJ0KSArK2kxO1xuICAgIGlmIChpMiAqIGluYyA+IHN0b3ApIC0taTI7XG4gIH1cbiAgaWYgKGkyIDwgaTEgJiYgMC41IDw9IGNvdW50ICYmIGNvdW50IDwgMikgcmV0dXJuIHRpY2tTcGVjKHN0YXJ0LCBzdG9wLCBjb3VudCAqIDIpO1xuICByZXR1cm4gW2kxLCBpMiwgaW5jXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGlja3Moc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHN0b3AgPSArc3RvcCwgc3RhcnQgPSArc3RhcnQsIGNvdW50ID0gK2NvdW50O1xuICBpZiAoIShjb3VudCA+IDApKSByZXR1cm4gW107XG4gIGlmIChzdGFydCA9PT0gc3RvcCkgcmV0dXJuIFtzdGFydF07XG4gIGNvbnN0IHJldmVyc2UgPSBzdG9wIDwgc3RhcnQsIFtpMSwgaTIsIGluY10gPSByZXZlcnNlID8gdGlja1NwZWMoc3RvcCwgc3RhcnQsIGNvdW50KSA6IHRpY2tTcGVjKHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gIGlmICghKGkyID49IGkxKSkgcmV0dXJuIFtdO1xuICBjb25zdCBuID0gaTIgLSBpMSArIDEsIHRpY2tzID0gbmV3IEFycmF5KG4pO1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmIChpbmMgPCAwKSBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgdGlja3NbaV0gPSAoaTIgLSBpKSAvIC1pbmM7XG4gICAgZWxzZSBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgdGlja3NbaV0gPSAoaTIgLSBpKSAqIGluYztcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5jIDwgMCkgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRpY2tzW2ldID0gKGkxICsgaSkgLyAtaW5jO1xuICAgIGVsc2UgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRpY2tzW2ldID0gKGkxICsgaSkgKiBpbmM7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIHJldHVybiB0aWNrU3BlYyhzdGFydCwgc3RvcCwgY291bnQpWzJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHN0b3AgPSArc3RvcCwgc3RhcnQgPSArc3RhcnQsIGNvdW50ID0gK2NvdW50O1xuICBjb25zdCByZXZlcnNlID0gc3RvcCA8IHN0YXJ0LCBpbmMgPSByZXZlcnNlID8gdGlja0luY3JlbWVudChzdG9wLCBzdGFydCwgY291bnQpIDogdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICByZXR1cm4gKHJldmVyc2UgPyAtMSA6IDEpICogKGluYyA8IDAgPyAxIC8gLWluYyA6IGluYyk7XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxudmFyIHRvcCA9IDEsXG4gICAgcmlnaHQgPSAyLFxuICAgIGJvdHRvbSA9IDMsXG4gICAgbGVmdCA9IDQsXG4gICAgZXBzaWxvbiA9IDFlLTY7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVgoeCkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsMClcIjtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlWSh5KSB7XG4gIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgeSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBudW1iZXIoc2NhbGUpIHtcbiAgcmV0dXJuIGQgPT4gK3NjYWxlKGQpO1xufVxuXG5mdW5jdGlvbiBjZW50ZXIoc2NhbGUsIG9mZnNldCkge1xuICBvZmZzZXQgPSBNYXRoLm1heCgwLCBzY2FsZS5iYW5kd2lkdGgoKSAtIG9mZnNldCAqIDIpIC8gMjtcbiAgaWYgKHNjYWxlLnJvdW5kKCkpIG9mZnNldCA9IE1hdGgucm91bmQob2Zmc2V0KTtcbiAgcmV0dXJuIGQgPT4gK3NjYWxlKGQpICsgb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBlbnRlcmluZygpIHtcbiAgcmV0dXJuICF0aGlzLl9fYXhpcztcbn1cblxuZnVuY3Rpb24gYXhpcyhvcmllbnQsIHNjYWxlKSB7XG4gIHZhciB0aWNrQXJndW1lbnRzID0gW10sXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXQgPSBudWxsLFxuICAgICAgdGlja1NpemVJbm5lciA9IDYsXG4gICAgICB0aWNrU2l6ZU91dGVyID0gNixcbiAgICAgIHRpY2tQYWRkaW5nID0gMyxcbiAgICAgIG9mZnNldCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxID8gMCA6IDAuNSxcbiAgICAgIGsgPSBvcmllbnQgPT09IHRvcCB8fCBvcmllbnQgPT09IGxlZnQgPyAtMSA6IDEsXG4gICAgICB4ID0gb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PT0gcmlnaHQgPyBcInhcIiA6IFwieVwiLFxuICAgICAgdHJhbnNmb3JtID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBib3R0b20gPyB0cmFuc2xhdGVYIDogdHJhbnNsYXRlWTtcblxuICBmdW5jdGlvbiBheGlzKGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWVzID0gdGlja1ZhbHVlcyA9PSBudWxsID8gKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpIDogdGlja1ZhbHVlcyxcbiAgICAgICAgZm9ybWF0ID0gdGlja0Zvcm1hdCA9PSBudWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IGlkZW50aXR5KSA6IHRpY2tGb3JtYXQsXG4gICAgICAgIHNwYWNpbmcgPSBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCAwKSArIHRpY2tQYWRkaW5nLFxuICAgICAgICByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICAgIHJhbmdlMCA9ICtyYW5nZVswXSArIG9mZnNldCxcbiAgICAgICAgcmFuZ2UxID0gK3JhbmdlW3JhbmdlLmxlbmd0aCAtIDFdICsgb2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbiA9IChzY2FsZS5iYW5kd2lkdGggPyBjZW50ZXIgOiBudW1iZXIpKHNjYWxlLmNvcHkoKSwgb2Zmc2V0KSxcbiAgICAgICAgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dCxcbiAgICAgICAgcGF0aCA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoW251bGxdKSxcbiAgICAgICAgdGljayA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHZhbHVlcywgc2NhbGUpLm9yZGVyKCksXG4gICAgICAgIHRpY2tFeGl0ID0gdGljay5leGl0KCksXG4gICAgICAgIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIiksXG4gICAgICAgIGxpbmUgPSB0aWNrLnNlbGVjdChcImxpbmVcIiksXG4gICAgICAgIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XG5cbiAgICBwYXRoID0gcGF0aC5tZXJnZShwYXRoLmVudGVyKCkuaW5zZXJ0KFwicGF0aFwiLCBcIi50aWNrXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJjdXJyZW50Q29sb3JcIikpO1xuXG4gICAgdGljayA9IHRpY2subWVyZ2UodGlja0VudGVyKTtcblxuICAgIGxpbmUgPSBsaW5lLm1lcmdlKHRpY2tFbnRlci5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpXG4gICAgICAgIC5hdHRyKHggKyBcIjJcIiwgayAqIHRpY2tTaXplSW5uZXIpKTtcblxuICAgIHRleHQgPSB0ZXh0Lm1lcmdlKHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcImN1cnJlbnRDb2xvclwiKVxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBvcmllbnQgPT09IHRvcCA/IFwiMGVtXCIgOiBvcmllbnQgPT09IGJvdHRvbSA/IFwiMC43MWVtXCIgOiBcIjAuMzJlbVwiKSk7XG5cbiAgICBpZiAoY29udGV4dCAhPT0gc2VsZWN0aW9uKSB7XG4gICAgICBwYXRoID0gcGF0aC50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgdGljayA9IHRpY2sudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICB0ZXh0ID0gdGV4dC50cmFuc2l0aW9uKGNvbnRleHQpO1xuXG4gICAgICB0aWNrRXhpdCA9IHRpY2tFeGl0LnRyYW5zaXRpb24oY29udGV4dClcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBpc0Zpbml0ZShkID0gcG9zaXRpb24oZCkpID8gdHJhbnNmb3JtKGQgKyBvZmZzZXQpIDogdGhpcy5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7IH0pO1xuXG4gICAgICB0aWNrRW50ZXJcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHZhciBwID0gdGhpcy5wYXJlbnROb2RlLl9fYXhpczsgcmV0dXJuIHRyYW5zZm9ybSgocCAmJiBpc0Zpbml0ZShwID0gcChkKSkgPyBwIDogcG9zaXRpb24oZCkpICsgb2Zmc2V0KTsgfSk7XG4gICAgfVxuXG4gICAgdGlja0V4aXQucmVtb3ZlKCk7XG5cbiAgICBwYXRoXG4gICAgICAgIC5hdHRyKFwiZFwiLCBvcmllbnQgPT09IGxlZnQgfHwgb3JpZW50ID09PSByaWdodFxuICAgICAgICAgICAgPyAodGlja1NpemVPdXRlciA/IFwiTVwiICsgayAqIHRpY2tTaXplT3V0ZXIgKyBcIixcIiArIHJhbmdlMCArIFwiSFwiICsgb2Zmc2V0ICsgXCJWXCIgKyByYW5nZTEgKyBcIkhcIiArIGsgKiB0aWNrU2l6ZU91dGVyIDogXCJNXCIgKyBvZmZzZXQgKyBcIixcIiArIHJhbmdlMCArIFwiVlwiICsgcmFuZ2UxKVxuICAgICAgICAgICAgOiAodGlja1NpemVPdXRlciA/IFwiTVwiICsgcmFuZ2UwICsgXCIsXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiVlwiICsgb2Zmc2V0ICsgXCJIXCIgKyByYW5nZTEgKyBcIlZcIiArIGsgKiB0aWNrU2l6ZU91dGVyIDogXCJNXCIgKyByYW5nZTAgKyBcIixcIiArIG9mZnNldCArIFwiSFwiICsgcmFuZ2UxKSk7XG5cbiAgICB0aWNrXG4gICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiB0cmFuc2Zvcm0ocG9zaXRpb24oZCkgKyBvZmZzZXQpOyB9KTtcblxuICAgIGxpbmVcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcik7XG5cbiAgICB0ZXh0XG4gICAgICAgIC5hdHRyKHgsIGsgKiBzcGFjaW5nKVxuICAgICAgICAudGV4dChmb3JtYXQpO1xuXG4gICAgc2VsZWN0aW9uLmZpbHRlcihlbnRlcmluZylcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLCAxMClcbiAgICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLCBcInNhbnMtc2VyaWZcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBvcmllbnQgPT09IHJpZ2h0ID8gXCJzdGFydFwiIDogb3JpZW50ID09PSBsZWZ0ID8gXCJlbmRcIiA6IFwibWlkZGxlXCIpO1xuXG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLl9fYXhpcyA9IHBvc2l0aW9uOyB9KTtcbiAgfVxuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUgPSBfLCBheGlzKSA6IHNjYWxlO1xuICB9O1xuXG4gIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlja0FyZ3VtZW50cyA9IEFycmF5LmZyb20oYXJndW1lbnRzKSwgYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tBcmd1bWVudHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0FyZ3VtZW50cyA9IF8gPT0gbnVsbCA/IFtdIDogQXJyYXkuZnJvbShfKSwgYXhpcykgOiB0aWNrQXJndW1lbnRzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tWYWx1ZXMgPSBfID09IG51bGwgPyBudWxsIDogQXJyYXkuZnJvbShfKSwgYXhpcykgOiB0aWNrVmFsdWVzICYmIHRpY2tWYWx1ZXMuc2xpY2UoKTtcbiAgfTtcblxuICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0Zvcm1hdCA9IF8sIGF4aXMpIDogdGlja0Zvcm1hdDtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSB0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVJbm5lcjtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVJbm5lciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZU91dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplT3V0ZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZU91dGVyO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1BhZGRpbmcgPSArXywgYXhpcykgOiB0aWNrUGFkZGluZztcbiAgfTtcblxuICBheGlzLm9mZnNldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvZmZzZXQgPSArXywgYXhpcykgOiBvZmZzZXQ7XG4gIH07XG5cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzVG9wKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKHRvcCwgc2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXhpc1JpZ2h0KHNjYWxlKSB7XG4gIHJldHVybiBheGlzKHJpZ2h0LCBzY2FsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzQm90dG9tKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGJvdHRvbSwgc2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXhpc0xlZnQoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXMobGVmdCwgc2NhbGUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG5leHBvcnQgdmFyIGRhcmtlciA9IDAuNztcbmV4cG9ydCB2YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXG4gICAgcmVOID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4ID0gL14jKFswLTlhLWZdezMsOH0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChgXnJnYlxcXFwoJHtyZUl9LCR7cmVJfSwke3JlSX1cXFxcKSRgKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKGBecmdiXFxcXCgke3JlUH0sJHtyZVB9LCR7cmVQfVxcXFwpJGApLFxuICAgIHJlUmdiYUludGVnZXIgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHtyZUl9LCR7cmVJfSwke3JlSX0sJHtyZU59XFxcXCkkYCksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5yZ2JhXFxcXCgke3JlUH0sJHtyZVB9LCR7cmVQfSwke3JlTn1cXFxcKSRgKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKGBeaHNsXFxcXCgke3JlTn0sJHtyZVB9LCR7cmVQfVxcXFwpJGApLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKGBeaHNsYVxcXFwoJHtyZU59LCR7cmVQfSwke3JlUH0sJHtyZU59XFxcXCkkYCk7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGNvcHkoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGNvbG9yX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBjb2xvcl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhleDg6IGNvbG9yX2Zvcm1hdEhleDgsXG4gIGZvcm1hdEhzbDogY29sb3JfZm9ybWF0SHNsLFxuICBmb3JtYXRSZ2I6IGNvbG9yX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IGNvbG9yX2Zvcm1hdFJnYlxufSk7XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleDgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleDgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SHNsKCkge1xuICByZXR1cm4gaHNsQ29udmVydCh0aGlzKS5mb3JtYXRIc2woKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0UmdiKCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRSZ2IoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtLCBsO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4LmV4ZWMoZm9ybWF0KSkgPyAobCA9IG1bMV0ubGVuZ3RoLCBtID0gcGFyc2VJbnQobVsxXSwgMTYpLCBsID09PSA2ID8gcmdibihtKSAvLyAjZmYwMDAwXG4gICAgICA6IGwgPT09IDMgPyBuZXcgUmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpIC8vICNmMDBcbiAgICAgIDogbCA9PT0gOCA/IHJnYmEobSA+PiAyNCAmIDB4ZmYsIG0gPj4gMTYgJiAweGZmLCBtID4+IDggJiAweGZmLCAobSAmIDB4ZmYpIC8gMHhmZikgLy8gI2ZmMDAwMDAwXG4gICAgICA6IGwgPT09IDQgPyByZ2JhKChtID4+IDEyICYgMHhmKSB8IChtID4+IDggJiAweGYwKSwgKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKCgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZikpIC8gMHhmZikgLy8gI2YwMDBcbiAgICAgIDogbnVsbCkgLy8gaW52YWxpZCBoZXhcbiAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcbiAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgMSkgLy8gcmdiKDEwMCUsIDAlLCAwJSlcbiAgICAgIDogKG0gPSByZVJnYmFJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pIC8vIHJnYmEoMjU1LCAwLCAwLCAxKVxuICAgICAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcbiAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgMSkgLy8gaHNsKDEyMCwgNTAlLCA1MCUpXG4gICAgICA6IChtID0gcmVIc2xhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCBtWzRdKSAvLyBoc2xhKDEyMCwgNTAlLCA1MCUsIDEpXG4gICAgICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICA6IGZvcm1hdCA9PT0gXCJ0cmFuc3BhcmVudFwiID8gbmV3IFJnYihOYU4sIE5hTiwgTmFOLCAwKVxuICAgICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiByZ2JuKG4pIHtcbiAgcmV0dXJuIG5ldyBSZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmLCAxKTtcbn1cblxuZnVuY3Rpb24gcmdiYShyLCBnLCBiLCBhKSB7XG4gIGlmIChhIDw9IDApIHIgPSBnID0gYiA9IE5hTjtcbiAgcmV0dXJuIG5ldyBSZ2IociwgZywgYiwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5yID0gK3I7XG4gIHRoaXMuZyA9ICtnO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShSZ2IsIHJnYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNsYW1wKCkge1xuICAgIHJldHVybiBuZXcgUmdiKGNsYW1waSh0aGlzLnIpLCBjbGFtcGkodGhpcy5nKSwgY2xhbXBpKHRoaXMuYiksIGNsYW1wYSh0aGlzLm9wYWNpdHkpKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuICgtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5nICYmIHRoaXMuZyA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogcmdiX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiByZ2JfZm9ybWF0SGV4LFxuICBmb3JtYXRIZXg4OiByZ2JfZm9ybWF0SGV4OCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gYCMke2hleCh0aGlzLnIpfSR7aGV4KHRoaXMuZyl9JHtoZXgodGhpcy5iKX1gO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4OCgpIHtcbiAgcmV0dXJuIGAjJHtoZXgodGhpcy5yKX0ke2hleCh0aGlzLmcpfSR7aGV4KHRoaXMuYil9JHtoZXgoKGlzTmFOKHRoaXMub3BhY2l0eSkgPyAxIDogdGhpcy5vcGFjaXR5KSAqIDI1NSl9YDtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdFJnYigpIHtcbiAgY29uc3QgYSA9IGNsYW1wYSh0aGlzLm9wYWNpdHkpO1xuICByZXR1cm4gYCR7YSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwifSR7Y2xhbXBpKHRoaXMucil9LCAke2NsYW1waSh0aGlzLmcpfSwgJHtjbGFtcGkodGhpcy5iKX0ke2EgPT09IDEgPyBcIilcIiA6IGAsICR7YX0pYH1gO1xufVxuXG5mdW5jdGlvbiBjbGFtcGEob3BhY2l0eSkge1xuICByZXR1cm4gaXNOYU4ob3BhY2l0eSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgb3BhY2l0eSkpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGkodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xufVxuXG5mdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgdmFsdWUgPSBjbGFtcGkodmFsdWUpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBjbGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IEhzbChjbGFtcGgodGhpcy5oKSwgY2xhbXB0KHRoaXMucyksIGNsYW1wdCh0aGlzLmwpLCBjbGFtcGEodGhpcy5vcGFjaXR5KSk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBmb3JtYXRIc2woKSB7XG4gICAgY29uc3QgYSA9IGNsYW1wYSh0aGlzLm9wYWNpdHkpO1xuICAgIHJldHVybiBgJHthID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCJ9JHtjbGFtcGgodGhpcy5oKX0sICR7Y2xhbXB0KHRoaXMucykgKiAxMDB9JSwgJHtjbGFtcHQodGhpcy5sKSAqIDEwMH0lJHthID09PSAxID8gXCIpXCIgOiBgLCAke2F9KWB9YDtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiBjbGFtcGgodmFsdWUpIHtcbiAgdmFsdWUgPSAodmFsdWUgfHwgMCkgJSAzNjA7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyB2YWx1ZSArIDM2MCA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjbGFtcHQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbHVlIHx8IDApKTtcbn1cblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG4gIHJldHVybiBwcm90b3R5cGU7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcbmltcG9ydCB7Q29sb3IsIHJnYkNvbnZlcnQsIFJnYn0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmltcG9ydCB7ZGVncmVlcywgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG4vLyBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL2xhYi1hbmQtcmdiXG5jb25zdCBLID0gMTgsXG4gICAgWG4gPSAwLjk2NDIyLFxuICAgIFluID0gMSxcbiAgICBabiA9IDAuODI1MjEsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIGhjbDJsYWIobyk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSByZ2IybHJnYihvLnIpLFxuICAgICAgZyA9IHJnYjJscmdiKG8uZyksXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIyMjUwNDUgKiByICsgMC43MTY4Nzg2ICogZyArIDAuMDYwNjE2OSAqIGIpIC8gWW4pLCB4LCB6O1xuICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB4ID0geiA9IHk7IGVsc2Uge1xuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xuICAgIHogPSB4eXoybGFiKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZyArIDAuNzE0MTczMyAqIGIpIC8gWm4pO1xuICB9XG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXkobCwgb3BhY2l0eSkge1xuICByZXR1cm4gbmV3IExhYihsLCAwLCAwLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwIDwgby5sICYmIG8ubCA8IDEwMCA/IDAgOiBOYU4sIG8ubCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBNYXRoLmF0YW4yKG8uYiwgby5hKSAqIGRlZ3JlZXM7XG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmZ1bmN0aW9uIGhjbDJsYWIobykge1xuICBpZiAoaXNOYU4oby5oKSkgcmV0dXJuIG5ldyBMYWIoby5sLCAwLCAwLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IG8uaCAqIHJhZGlhbnM7XG4gIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHJldHVybiBoY2wybGFiKHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG4iLCJleHBvcnQgY29uc3QgcmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgY29uc3QgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogKCkgPT4ge319O1xuXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykgfHwgL1tcXHMuXS8udGVzdCh0KSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsImltcG9ydCB7c2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9ldmVudCwge25vbnBhc3NpdmVjYXB0dXJlfSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHllc2RyYWcodmlldywgbm9jbGljaykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIGlmIChub2NsaWNrKSB7XG4gICAgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG4iLCIvLyBUaGVzZSBhcmUgdHlwaWNhbGx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBub2V2ZW50IHRvIGVuc3VyZSB0aGF0IHdlIGNhblxuLy8gcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50LlxuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmUgPSB7cGFzc2l2ZTogZmFsc2V9O1xuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmVjYXB0dXJlID0ge2NhcHR1cmU6IHRydWUsIHBhc3NpdmU6IGZhbHNlfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiaW1wb3J0IGRzdiBmcm9tIFwiLi9kc3YuanNcIjtcblxudmFyIGNzdiA9IGRzdihcIixcIik7XG5cbmV4cG9ydCB2YXIgY3N2UGFyc2UgPSBjc3YucGFyc2U7XG5leHBvcnQgdmFyIGNzdlBhcnNlUm93cyA9IGNzdi5wYXJzZVJvd3M7XG5leHBvcnQgdmFyIGNzdkZvcm1hdCA9IGNzdi5mb3JtYXQ7XG5leHBvcnQgdmFyIGNzdkZvcm1hdEJvZHkgPSBjc3YuZm9ybWF0Qm9keTtcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Um93cyA9IGNzdi5mb3JtYXRSb3dzO1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRSb3cgPSBjc3YuZm9ybWF0Um93O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRWYWx1ZSA9IGNzdi5mb3JtYXRWYWx1ZTtcbiIsInZhciBFT0wgPSB7fSxcbiAgICBFT0YgPSB7fSxcbiAgICBRVU9URSA9IDM0LFxuICAgIE5FV0xJTkUgPSAxMCxcbiAgICBSRVRVUk4gPSAxMztcblxuZnVuY3Rpb24gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpIHtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgY29sdW1ucy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXSB8fCBcXFwiXFxcIlwiO1xuICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbn1cblxuZnVuY3Rpb24gY3VzdG9tQ29udmVydGVyKGNvbHVtbnMsIGYpIHtcbiAgdmFyIG9iamVjdCA9IG9iamVjdENvbnZlcnRlcihjb2x1bW5zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgIHJldHVybiBmKG9iamVjdChyb3cpLCBpLCBjb2x1bW5zKTtcbiAgfTtcbn1cblxuLy8gQ29tcHV0ZSB1bmlxdWUgY29sdW1ucyBpbiBvcmRlciBvZiBkaXNjb3ZlcnkuXG5mdW5jdGlvbiBpbmZlckNvbHVtbnMocm93cykge1xuICB2YXIgY29sdW1uU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGNvbHVtbnMgPSBbXTtcblxuICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgZm9yICh2YXIgY29sdW1uIGluIHJvdykge1xuICAgICAgaWYgKCEoY29sdW1uIGluIGNvbHVtblNldCkpIHtcbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtblNldFtjb2x1bW5dID0gY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb2x1bW5zO1xufVxuXG5mdW5jdGlvbiBwYWQodmFsdWUsIHdpZHRoKSB7XG4gIHZhciBzID0gdmFsdWUgKyBcIlwiLCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbigwKSArIHMgOiBzO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRZZWFyKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgPCAwID8gXCItXCIgKyBwYWQoLXllYXIsIDYpXG4gICAgOiB5ZWFyID4gOTk5OSA/IFwiK1wiICsgcGFkKHllYXIsIDYpXG4gICAgOiBwYWQoeWVhciwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCksXG4gICAgICBtaW51dGVzID0gZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICBzZWNvbmRzID0gZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBcIkludmFsaWQgRGF0ZVwiXG4gICAgICA6IGZvcm1hdFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0KSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gICAgICArIChtaWxsaXNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCIuXCIgKyBwYWQobWlsbGlzZWNvbmRzLCAzKSArIFwiWlwiXG4gICAgICA6IHNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCJaXCJcbiAgICAgIDogbWludXRlcyB8fCBob3VycyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCJaXCJcbiAgICAgIDogXCJcIik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSxcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgIGNvbHVtbnMgPSByb3csIGNvbnZlcnQgPSBmID8gY3VzdG9tQ29udmVydGVyKHJvdywgZikgOiBvYmplY3RDb252ZXJ0ZXIocm93KTtcbiAgICB9KTtcbiAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICB0LCAvLyBjdXJyZW50IHRva2VuXG4gICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cblxuICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTikgLS1OO1xuXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICBpZiAoZW9mKSByZXR1cm4gRU9GO1xuICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG5cbiAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgIHZhciBpLCBqID0gSSwgYztcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKTtcbiAgICAgICAgaWYgKChpID0gSSkgPj0gTikgZW9mID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkgLSAxKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lLlxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICB2YXIgcm93ID0gW107XG4gICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikgcm93LnB1c2godCksIHQgPSB0b2tlbigpO1xuICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3dzKHJvd3MpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIlxuICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGZvcm1hdERhdGUodmFsdWUpXG4gICAgICAgIDogcmVGb3JtYXQudGVzdCh2YWx1ZSArPSBcIlwiKSA/IFwiXFxcIlwiICsgdmFsdWUucmVwbGFjZSgvXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiXG4gICAgICAgIDogdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRCb2R5OiBmb3JtYXRCb2R5LFxuICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3MsXG4gICAgZm9ybWF0Um93OiBmb3JtYXRSb3csXG4gICAgZm9ybWF0VmFsdWU6IGZvcm1hdFZhbHVlXG4gIH07XG59XG4iLCJpbXBvcnQgZHN2IGZyb20gXCIuL2Rzdi5qc1wiO1xuXG52YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG5leHBvcnQgdmFyIHRzdlBhcnNlID0gdHN2LnBhcnNlO1xuZXhwb3J0IHZhciB0c3ZQYXJzZVJvd3MgPSB0c3YucGFyc2VSb3dzO1xuZXhwb3J0IHZhciB0c3ZGb3JtYXQgPSB0c3YuZm9ybWF0O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRCb2R5ID0gdHN2LmZvcm1hdEJvZHk7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFJvd3MgPSB0c3YuZm9ybWF0Um93cztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Um93ID0gdHN2LmZvcm1hdFJvdztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0VmFsdWUgPSB0c3YuZm9ybWF0VmFsdWU7XG4iLCJleHBvcnQgZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbn1cbiIsImltcG9ydCB7Y3N2UGFyc2UsIGRzdkZvcm1hdCwgdHN2UGFyc2V9IGZyb20gXCJkMy1kc3ZcIjtcbmltcG9ydCB0ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcblxuZnVuY3Rpb24gZHN2UGFyc2UocGFyc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpbml0LCByb3cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgaW5pdCA9PT0gXCJmdW5jdGlvblwiKSByb3cgPSBpbml0LCBpbml0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcGFyc2UocmVzcG9uc2UsIHJvdyk7XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRzdihkZWxpbWl0ZXIsIGlucHV0LCBpbml0LCByb3cpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgdmFyIGZvcm1hdCA9IGRzdkZvcm1hdChkZWxpbWl0ZXIpO1xuICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHJldHVybiBmb3JtYXQucGFyc2UocmVzcG9uc2UsIHJvdyk7XG4gIH0pO1xufVxuXG5leHBvcnQgdmFyIGNzdiA9IGRzdlBhcnNlKGNzdlBhcnNlKTtcbmV4cG9ydCB2YXIgdHN2ID0gZHN2UGFyc2UodHN2UGFyc2UpO1xuIiwiZnVuY3Rpb24gcmVzcG9uc2VKc29uKHJlc3BvbnNlKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDUpIHJldHVybjtcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlSnNvbik7XG59XG4iLCJmdW5jdGlvbiByZXNwb25zZVRleHQocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBmZXRjaChpbnB1dCwgaW5pdCkudGhlbihyZXNwb25zZVRleHQpO1xufVxuIiwiaW1wb3J0IHtxdWFkdHJlZX0gZnJvbSBcImQzLXF1YWR0cmVlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBqaWdnbGUgZnJvbSBcIi4vamlnZ2xlLmpzXCI7XG5cbmZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZC54ICsgZC52eDtcbn1cblxuZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnkgKyBkLnZ5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgcmFkaWksXG4gICAgICByYW5kb20sXG4gICAgICBzdHJlbmd0aCA9IDEsXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudChyYWRpdXMgPT0gbnVsbCA/IDEgOiArcmFkaXVzKTtcblxuICBmdW5jdGlvbiBmb3JjZSgpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgeGksXG4gICAgICAgIHlpLFxuICAgICAgICByaSxcbiAgICAgICAgcmkyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIHRyZWUgPSBxdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihwcmVwYXJlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICByaSA9IHJhZGlpW25vZGUuaW5kZXhdLCByaTIgPSByaSAqIHJpO1xuICAgICAgICB4aSA9IG5vZGUueCArIG5vZGUudng7XG4gICAgICAgIHlpID0gbm9kZS55ICsgbm9kZS52eTtcbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIHZhciBkYXRhID0gcXVhZC5kYXRhLCByaiA9IHF1YWQuciwgciA9IHJpICsgcmo7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pbmRleCA+IG5vZGUuaW5kZXgpIHtcbiAgICAgICAgICB2YXIgeCA9IHhpIC0gZGF0YS54IC0gZGF0YS52eCxcbiAgICAgICAgICAgICAgeSA9IHlpIC0gZGF0YS55IC0gZGF0YS52eSxcbiAgICAgICAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgICAgaWYgKGwgPCByICogcikge1xuICAgICAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUocmFuZG9tKSwgbCArPSB4ICogeDtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geSAqIHk7XG4gICAgICAgICAgICBsID0gKHIgLSAobCA9IE1hdGguc3FydChsKSkpIC8gbCAqIHN0cmVuZ3RoO1xuICAgICAgICAgICAgbm9kZS52eCArPSAoeCAqPSBsKSAqIChyID0gKHJqICo9IHJqKSAvIChyaTIgKyByaikpO1xuICAgICAgICAgICAgbm9kZS52eSArPSAoeSAqPSBsKSAqIHI7XG4gICAgICAgICAgICBkYXRhLnZ4IC09IHggKiAociA9IDEgLSByKTtcbiAgICAgICAgICAgIGRhdGEudnkgLT0geSAqIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4MCA+IHhpICsgciB8fCB4MSA8IHhpIC0gciB8fCB5MCA+IHlpICsgciB8fCB5MSA8IHlpIC0gcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlKHF1YWQpIHtcbiAgICBpZiAocXVhZC5kYXRhKSByZXR1cm4gcXVhZC5yID0gcmFkaWlbcXVhZC5kYXRhLmluZGV4XTtcbiAgICBmb3IgKHZhciBpID0gcXVhZC5yID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKHF1YWRbaV0gJiYgcXVhZFtpXS5yID4gcXVhZC5yKSB7XG4gICAgICAgIHF1YWQuciA9IHF1YWRbaV0ucjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICByYWRpaSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHJhZGlpW25vZGUuaW5kZXhdID0gK3JhZGl1cyhub2RlLCBpLCBub2Rlcyk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oX25vZGVzLCBfcmFuZG9tKSB7XG4gICAgbm9kZXMgPSBfbm9kZXM7XG4gICAgcmFuZG9tID0gX3JhbmRvbTtcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHJhZGl1cztcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmRvbSkge1xuICByZXR1cm4gKHJhbmRvbSgpIC0gMC41KSAqIDFlLTY7XG59XG4iLCIvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvciNQYXJhbWV0ZXJzX2luX2NvbW1vbl91c2VcbmNvbnN0IGEgPSAxNjY0NTI1O1xuY29uc3QgYyA9IDEwMTM5MDQyMjM7XG5jb25zdCBtID0gNDI5NDk2NzI5NjsgLy8gMl4zMlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgbGV0IHMgPSAxO1xuICByZXR1cm4gKCkgPT4gKHMgPSAoYSAqIHMgKyBjKSAlIG0pIC8gbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lcn0gZnJvbSBcImQzLXRpbWVyXCI7XG5pbXBvcnQgbGNnIGZyb20gXCIuL2xjZy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLng7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueTtcbn1cblxudmFyIGluaXRpYWxSYWRpdXMgPSAxMCxcbiAgICBpbml0aWFsQW5nbGUgPSBNYXRoLlBJICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2Rlcykge1xuICB2YXIgc2ltdWxhdGlvbixcbiAgICAgIGFscGhhID0gMSxcbiAgICAgIGFscGhhTWluID0gMC4wMDEsXG4gICAgICBhbHBoYURlY2F5ID0gMSAtIE1hdGgucG93KGFscGhhTWluLCAxIC8gMzAwKSxcbiAgICAgIGFscGhhVGFyZ2V0ID0gMCxcbiAgICAgIHZlbG9jaXR5RGVjYXkgPSAwLjYsXG4gICAgICBmb3JjZXMgPSBuZXcgTWFwKCksXG4gICAgICBzdGVwcGVyID0gdGltZXIoc3RlcCksXG4gICAgICBldmVudCA9IGRpc3BhdGNoKFwidGlja1wiLCBcImVuZFwiKSxcbiAgICAgIHJhbmRvbSA9IGxjZygpO1xuXG4gIGlmIChub2RlcyA9PSBudWxsKSBub2RlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgdGljaygpO1xuICAgIGV2ZW50LmNhbGwoXCJ0aWNrXCIsIHNpbXVsYXRpb24pO1xuICAgIGlmIChhbHBoYSA8IGFscGhhTWluKSB7XG4gICAgICBzdGVwcGVyLnN0b3AoKTtcbiAgICAgIGV2ZW50LmNhbGwoXCJlbmRcIiwgc2ltdWxhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGljayhpdGVyYXRpb25zKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG5cbiAgICBpZiAoaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkKSBpdGVyYXRpb25zID0gMTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICBhbHBoYSArPSAoYWxwaGFUYXJnZXQgLSBhbHBoYSkgKiBhbHBoYURlY2F5O1xuXG4gICAgICBmb3JjZXMuZm9yRWFjaChmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBmb3JjZShhbHBoYSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmZ4ID09IG51bGwpIG5vZGUueCArPSBub2RlLnZ4ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS54ID0gbm9kZS5meCwgbm9kZS52eCA9IDA7XG4gICAgICAgIGlmIChub2RlLmZ5ID09IG51bGwpIG5vZGUueSArPSBub2RlLnZ5ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS55ID0gbm9kZS5meSwgbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbXVsYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZXMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS5pbmRleCA9IGk7XG4gICAgICBpZiAobm9kZS5meCAhPSBudWxsKSBub2RlLnggPSBub2RlLmZ4O1xuICAgICAgaWYgKG5vZGUuZnkgIT0gbnVsbCkgbm9kZS55ID0gbm9kZS5meTtcbiAgICAgIGlmIChpc05hTihub2RlLngpIHx8IGlzTmFOKG5vZGUueSkpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGluaXRpYWxSYWRpdXMgKiBNYXRoLnNxcnQoMC41ICsgaSksIGFuZ2xlID0gaSAqIGluaXRpYWxBbmdsZTtcbiAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYU4obm9kZS52eCkgfHwgaXNOYU4obm9kZS52eSkpIHtcbiAgICAgICAgbm9kZS52eCA9IG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVGb3JjZShmb3JjZSkge1xuICAgIGlmIChmb3JjZS5pbml0aWFsaXplKSBmb3JjZS5pbml0aWFsaXplKG5vZGVzLCByYW5kb20pO1xuICAgIHJldHVybiBmb3JjZTtcbiAgfVxuXG4gIGluaXRpYWxpemVOb2RlcygpO1xuXG4gIHJldHVybiBzaW11bGF0aW9uID0ge1xuICAgIHRpY2s6IHRpY2ssXG5cbiAgICByZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnJlc3RhcnQoc3RlcCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIuc3RvcCgpLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBub2RlczogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZXMgPSBfLCBpbml0aWFsaXplTm9kZXMoKSwgZm9yY2VzLmZvckVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiBub2RlcztcbiAgICB9LFxuXG4gICAgYWxwaGE6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGE7XG4gICAgfSxcblxuICAgIGFscGhhTWluOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYU1pbiA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhTWluO1xuICAgIH0sXG5cbiAgICBhbHBoYURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYURlY2F5ID0gK18sIHNpbXVsYXRpb24pIDogK2FscGhhRGVjYXk7XG4gICAgfSxcblxuICAgIGFscGhhVGFyZ2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYVRhcmdldCA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhVGFyZ2V0O1xuICAgIH0sXG5cbiAgICB2ZWxvY2l0eURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2ZWxvY2l0eURlY2F5ID0gMSAtIF8sIHNpbXVsYXRpb24pIDogMSAtIHZlbG9jaXR5RGVjYXk7XG4gICAgfSxcblxuICAgIHJhbmRvbVNvdXJjZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZG9tID0gXywgZm9yY2VzLmZvckVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiByYW5kb207XG4gICAgfSxcblxuICAgIGZvcmNlOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoKF8gPT0gbnVsbCA/IGZvcmNlcy5kZWxldGUobmFtZSkgOiBmb3JjZXMuc2V0KG5hbWUsIGluaXRpYWxpemVGb3JjZShfKSkpLCBzaW11bGF0aW9uKSA6IGZvcmNlcy5nZXQobmFtZSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgZHgsXG4gICAgICAgICAgZHksXG4gICAgICAgICAgZDIsXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBjbG9zZXN0O1xuXG4gICAgICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICAgICAgZWxzZSByYWRpdXMgKj0gcmFkaXVzO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgZHggPSB4IC0gbm9kZS54O1xuICAgICAgICBkeSA9IHkgLSBub2RlLnk7XG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMiA8IHJhZGl1cykgY2xvc2VzdCA9IG5vZGUsIHJhZGl1cyA9IGQyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IChldmVudC5vbihuYW1lLCBfKSwgc2ltdWxhdGlvbikgOiBldmVudC5vbihuYW1lKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB4ejtcblxuICBpZiAodHlwZW9mIHggIT09IFwiZnVuY3Rpb25cIikgeCA9IGNvbnN0YW50KHggPT0gbnVsbCA/IDAgOiAreCk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ4ICs9ICh4eltpXSAtIG5vZGUueCkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeHogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeHpbaV0gPSAreChub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih5KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHl6O1xuXG4gIGlmICh0eXBlb2YgeSAhPT0gXCJmdW5jdGlvblwiKSB5ID0gY29uc3RhbnQoeSA9PSBudWxsID8gMCA6ICt5KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnkgKz0gKHl6W2ldIC0gbm9kZS55KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB5eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih5eltpXSA9ICt5KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGZvcm1hdExvY2FsZSBmcm9tIFwiLi9sb2NhbGUuanNcIjtcblxudmFyIGxvY2FsZTtcbmV4cG9ydCB2YXIgZm9ybWF0O1xuZXhwb3J0IHZhciBmb3JtYXRQcmVmaXg7XG5cbmRlZmF1bHRMb2NhbGUoe1xuICB0aG91c2FuZHM6IFwiLFwiLFxuICBncm91cGluZzogWzNdLFxuICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG4gIHJldHVybiBsb2NhbGU7XG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbFBhcnRzKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBNYXRoLmFicyh4ID0gTWF0aC5yb3VuZCh4KSkgPj0gMWUyMVxuICAgICAgPyB4LnRvTG9jYWxlU3RyaW5nKFwiZW5cIikucmVwbGFjZSgvLC9nLCBcIlwiKVxuICAgICAgOiB4LnRvU3RyaW5nKDEwKTtcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4vLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbFBhcnRzKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKSB7XG4gIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgcmV0dXJuIFtcbiAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICt4LnNsaWNlKGkgKyAxKVxuICBdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgIHQgPSBbXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG51bWVyYWxzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bMC05XS9nLCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gbnVtZXJhbHNbK2ldO1xuICAgIH0pO1xuICB9O1xufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IHZhciBwcmVmaXhFeHBvbmVudDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbFBhcnRzKHgsIE1hdGgubWF4KDAsIHAgKyBpIC0gMSkpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xufVxuIiwiLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt+XVt0eXBlXVxudmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLSggXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC5cXGQrKT8ofik/KFthLXolXSk/JC9pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcbiAgdmFyIG1hdGNoO1xuICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcih7XG4gICAgZmlsbDogbWF0Y2hbMV0sXG4gICAgYWxpZ246IG1hdGNoWzJdLFxuICAgIHNpZ246IG1hdGNoWzNdLFxuICAgIHN5bWJvbDogbWF0Y2hbNF0sXG4gICAgemVybzogbWF0Y2hbNV0sXG4gICAgd2lkdGg6IG1hdGNoWzZdLFxuICAgIGNvbW1hOiBtYXRjaFs3XSxcbiAgICBwcmVjaXNpb246IG1hdGNoWzhdICYmIG1hdGNoWzhdLnNsaWNlKDEpLFxuICAgIHRyaW06IG1hdGNoWzldLFxuICAgIHR5cGU6IG1hdGNoWzEwXVxuICB9KTtcbn1cblxuZm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZSA9IEZvcm1hdFNwZWNpZmllci5wcm90b3R5cGU7IC8vIGluc3RhbmNlb2ZcblxuZXhwb3J0IGZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgdGhpcy5maWxsID0gc3BlY2lmaWVyLmZpbGwgPT09IHVuZGVmaW5lZCA/IFwiIFwiIDogc3BlY2lmaWVyLmZpbGwgKyBcIlwiO1xuICB0aGlzLmFsaWduID0gc3BlY2lmaWVyLmFsaWduID09PSB1bmRlZmluZWQgPyBcIj5cIiA6IHNwZWNpZmllci5hbGlnbiArIFwiXCI7XG4gIHRoaXMuc2lnbiA9IHNwZWNpZmllci5zaWduID09PSB1bmRlZmluZWQgPyBcIi1cIiA6IHNwZWNpZmllci5zaWduICsgXCJcIjtcbiAgdGhpcy5zeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnN5bWJvbCArIFwiXCI7XG4gIHRoaXMuemVybyA9ICEhc3BlY2lmaWVyLnplcm87XG4gIHRoaXMud2lkdGggPSBzcGVjaWZpZXIud2lkdGggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIud2lkdGg7XG4gIHRoaXMuY29tbWEgPSAhIXNwZWNpZmllci5jb21tYTtcbiAgdGhpcy5wcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLnByZWNpc2lvbjtcbiAgdGhpcy50cmltID0gISFzcGVjaWZpZXIudHJpbTtcbiAgdGhpcy50eXBlID0gc3BlY2lmaWVyLnR5cGUgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIudHlwZSArIFwiXCI7XG59XG5cbkZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgKyB0aGlzLmFsaWduXG4gICAgICArIHRoaXMuc2lnblxuICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICsgKHRoaXMudHJpbSA/IFwiflwiIDogXCJcIilcbiAgICAgICsgdGhpcy50eXBlO1xufTtcbiIsIi8vIFRyaW1zIGluc2lnbmlmaWNhbnQgemVyb3MsIGUuZy4sIHJlcGxhY2VzIDEuMjAwMGsgd2l0aCAxLjJrLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocykge1xuICBvdXQ6IGZvciAodmFyIG4gPSBzLmxlbmd0aCwgaSA9IDEsIGkwID0gLTEsIGkxOyBpIDwgbjsgKytpKSB7XG4gICAgc3dpdGNoIChzW2ldKSB7XG4gICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICBjYXNlIFwiMFwiOiBpZiAoaTAgPT09IDApIGkwID0gaTsgaTEgPSBpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGlmICghK3NbaV0pIGJyZWFrIG91dDsgaWYgKGkwID4gMCkgaTAgPSAwOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkwID4gMCA/IHMuc2xpY2UoMCwgaTApICsgcy5zbGljZShpMSArIDEpIDogcztcbn1cbiIsImltcG9ydCBmb3JtYXREZWNpbWFsIGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcbmltcG9ydCBmb3JtYXRQcmVmaXhBdXRvIGZyb20gXCIuL2Zvcm1hdFByZWZpeEF1dG8uanNcIjtcbmltcG9ydCBmb3JtYXRSb3VuZGVkIGZyb20gXCIuL2Zvcm1hdFJvdW5kZWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBcIiVcIjogKHgsIHApID0+ICh4ICogMTAwKS50b0ZpeGVkKHApLFxuICBcImJcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMiksXG4gIFwiY1wiOiAoeCkgPT4geCArIFwiXCIsXG4gIFwiZFwiOiBmb3JtYXREZWNpbWFsLFxuICBcImVcIjogKHgsIHApID0+IHgudG9FeHBvbmVudGlhbChwKSxcbiAgXCJmXCI6ICh4LCBwKSA9PiB4LnRvRml4ZWQocCksXG4gIFwiZ1wiOiAoeCwgcCkgPT4geC50b1ByZWNpc2lvbihwKSxcbiAgXCJvXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDgpLFxuICBcInBcIjogKHgsIHApID0+IGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCksXG4gIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgXCJYXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLFxuICBcInhcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuaW1wb3J0IGZvcm1hdEdyb3VwIGZyb20gXCIuL2Zvcm1hdEdyb3VwLmpzXCI7XG5pbXBvcnQgZm9ybWF0TnVtZXJhbHMgZnJvbSBcIi4vZm9ybWF0TnVtZXJhbHMuanNcIjtcbmltcG9ydCBmb3JtYXRTcGVjaWZpZXIgZnJvbSBcIi4vZm9ybWF0U3BlY2lmaWVyLmpzXCI7XG5pbXBvcnQgZm9ybWF0VHJpbSBmcm9tIFwiLi9mb3JtYXRUcmltLmpzXCI7XG5pbXBvcnQgZm9ybWF0VHlwZXMgZnJvbSBcIi4vZm9ybWF0VHlwZXMuanNcIjtcbmltcG9ydCB7cHJlZml4RXhwb25lbnR9IGZyb20gXCIuL2Zvcm1hdFByZWZpeEF1dG8uanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG52YXIgbWFwID0gQXJyYXkucHJvdG90eXBlLm1hcCxcbiAgICBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGxvY2FsZSkge1xuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgPT09IHVuZGVmaW5lZCB8fCBsb2NhbGUudGhvdXNhbmRzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdEdyb3VwKG1hcC5jYWxsKGxvY2FsZS5ncm91cGluZywgTnVtYmVyKSwgbG9jYWxlLnRob3VzYW5kcyArIFwiXCIpLFxuICAgICAgY3VycmVuY3lQcmVmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMF0gKyBcIlwiLFxuICAgICAgY3VycmVuY3lTdWZmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMV0gKyBcIlwiLFxuICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsID09PSB1bmRlZmluZWQgPyBcIi5cIiA6IGxvY2FsZS5kZWNpbWFsICsgXCJcIixcbiAgICAgIG51bWVyYWxzID0gbG9jYWxlLm51bWVyYWxzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdE51bWVyYWxzKG1hcC5jYWxsKGxvY2FsZS5udW1lcmFscywgU3RyaW5nKSksXG4gICAgICBwZXJjZW50ID0gbG9jYWxlLnBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IFwiJVwiIDogbG9jYWxlLnBlcmNlbnQgKyBcIlwiLFxuICAgICAgbWludXMgPSBsb2NhbGUubWludXMgPT09IHVuZGVmaW5lZCA/IFwi4oiSXCIgOiBsb2NhbGUubWludXMgKyBcIlwiLFxuICAgICAgbmFuID0gbG9jYWxlLm5hbiA9PT0gdW5kZWZpbmVkID8gXCJOYU5cIiA6IGxvY2FsZS5uYW4gKyBcIlwiO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIpIHtcbiAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICB0cmltID0gc3BlY2lmaWVyLnRyaW0sXG4gICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIFRoZSBcIlwiIHR5cGUsIGFuZCBhbnkgaW52YWxpZCB0eXBlLCBpcyBhbiBhbGlhcyBmb3IgXCIuMTJ+Z1wiLlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgJiYgKHByZWNpc2lvbiA9IDEyKSwgdHJpbSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVByZWZpeCA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5U3VmZml4IDogL1slcF0vLnRlc3QodHlwZSkgPyBwZXJjZW50IDogXCJcIjtcblxuICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICBtYXliZVN1ZmZpeCA9IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IDZcbiAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgdmFsdWVTdWZmaXggPSBzdWZmaXgsXG4gICAgICAgICAgaSwgbiwgYztcblxuICAgICAgaWYgKHR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzaWduLiAtMCBpcyBub3QgbGVzcyB0aGFuIDAsIGJ1dCAxIC8gLTAgaXMhXG4gICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gdmFsdWUgPCAwIHx8IDEgLyB2YWx1ZSA8IDA7XG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICB2YWx1ZSA9IGlzTmFOKHZhbHVlKSA/IG5hbiA6IGZvcm1hdFR5cGUoTWF0aC5hYnModmFsdWUpLCBwcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIFRyaW0gaW5zaWduaWZpY2FudCB6ZXJvcy5cbiAgICAgICAgaWYgKHRyaW0pIHZhbHVlID0gZm9ybWF0VHJpbSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gSWYgYSBuZWdhdGl2ZSB2YWx1ZSByb3VuZHMgdG8gemVybyBhZnRlciBmb3JtYXR0aW5nLCBhbmQgbm8gZXhwbGljaXQgcG9zaXRpdmUgc2lnbiBpcyByZXF1ZXN0ZWQsIGhpZGUgdGhlIHNpZ24uXG4gICAgICAgIGlmICh2YWx1ZU5lZ2F0aXZlICYmICt2YWx1ZSA9PT0gMCAmJiBzaWduICE9PSBcIitcIikgdmFsdWVOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IG1pbnVzKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArIHZhbHVlU3VmZml4ICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI9XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJeXCI6IHZhbHVlID0gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHZhbHVlID0gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudW1lcmFscyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3BlY2lmaWVyICsgXCJcIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgdmFyIGYgPSBuZXdGb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzLFxuICAgICAgICBrID0gTWF0aC5wb3coMTAsIC1lKSxcbiAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmKGsgKiB2YWx1ZSkgKyBwcmVmaXg7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBuZXdGb3JtYXQsXG4gICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgfTtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGVwLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXAsIG1heCkge1xuICBzdGVwID0gTWF0aC5hYnMoc3RlcCksIG1heCA9IE1hdGguYWJzKG1heCkgLSBzdGVwO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQobWF4KSAtIGV4cG9uZW50KHN0ZXApKSArIDE7XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uL2NweXRob24vYmxvYi9hNzRlZWEyMzhmNWJhYmExNTc5N2UyZThiNTcwZDE1M2JjODY5MGE3L01vZHVsZXMvbWF0aG1vZHVsZS5jI0wxNDIzXG5leHBvcnQgY2xhc3MgQWRkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJ0aWFscyA9IG5ldyBGbG9hdDY0QXJyYXkoMzIpO1xuICAgIHRoaXMuX24gPSAwO1xuICB9XG4gIGFkZCh4KSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX3BhcnRpYWxzO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX24gJiYgaiA8IDMyOyBqKyspIHtcbiAgICAgIGNvbnN0IHkgPSBwW2pdLFxuICAgICAgICBoaSA9IHggKyB5LFxuICAgICAgICBsbyA9IE1hdGguYWJzKHgpIDwgTWF0aC5hYnMoeSkgPyB4IC0gKGhpIC0geSkgOiB5IC0gKGhpIC0geCk7XG4gICAgICBpZiAobG8pIHBbaSsrXSA9IGxvO1xuICAgICAgeCA9IGhpO1xuICAgIH1cbiAgICBwW2ldID0geDtcbiAgICB0aGlzLl9uID0gaSArIDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IG4gPSB0aGlzLl9uLCB4LCB5LCBsbywgaGkgPSAwO1xuICAgIGlmIChuID4gMCkge1xuICAgICAgaGkgPSBwWy0tbl07XG4gICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgeCA9IGhpO1xuICAgICAgICB5ID0gcFstLW5dO1xuICAgICAgICBoaSA9IHggKyB5O1xuICAgICAgICBsbyA9IHkgLSAoaGkgLSB4KTtcbiAgICAgICAgaWYgKGxvKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuID4gMCAmJiAoKGxvIDwgMCAmJiBwW24gLSAxXSA8IDApIHx8IChsbyA+IDAgJiYgcFtuIC0gMV0gPiAwKSkpIHtcbiAgICAgICAgeSA9IGxvICogMjtcbiAgICAgICAgeCA9IGhpICsgeTtcbiAgICAgICAgaWYgKHkgPT0geCAtIGhpKSBoaSA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgYWRkZXIgPSBuZXcgQWRkZXIoKTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlKSB7XG4gICAgICAgIGFkZGVyLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpIHtcbiAgICAgICAgYWRkZXIuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICthZGRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZjdW1zdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGNvbnN0IGFkZGVyID0gbmV3IEFkZGVyKCk7XG4gIGxldCBpbmRleCA9IC0xO1xuICByZXR1cm4gRmxvYXQ2NEFycmF5LmZyb20odmFsdWVzLCB2YWx1ZW9mID09PSB1bmRlZmluZWRcbiAgICAgID8gdiA9PiBhZGRlci5hZGQoK3YgfHwgMClcbiAgICAgIDogdiA9PiBhZGRlci5hZGQoK3ZhbHVlb2YodiwgKytpbmRleCwgdmFsdWVzKSB8fCAwKVxuICApO1xufVxuIiwiZnVuY3Rpb24qIGZsYXR0ZW4oYXJyYXlzKSB7XG4gIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgeWllbGQqIGFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlKGFycmF5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShmbGF0dGVuKGFycmF5cykpO1xufVxuIiwiaW1wb3J0IHthc2luLCBhdGFuMiwgY29zLCBzaW4sIHNxcnR9IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgcmV0dXJuIFthdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGFzaW4oY2FydGVzaWFuWzJdKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gIHZhciBsYW1iZGEgPSBzcGhlcmljYWxbMF0sIHBoaSA9IHNwaGVyaWNhbFsxXSwgY29zUGhpID0gY29zKHBoaSk7XG4gIHJldHVybiBbY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICByZXR1cm4gW2FbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1dO1xufVxuXG4vLyBUT0RPIHJldHVybiBhXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuQWRkSW5QbGFjZShhLCBiKSB7XG4gIGFbMF0gKz0gYlswXSwgYVsxXSArPSBiWzFdLCBhWzJdICs9IGJbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgcmV0dXJuIFt2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gZFxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xuICB2YXIgbCA9IHNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgZFswXSAvPSBsLCBkWzFdIC89IGwsIGRbMl0gLz0gbDtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlLCBzcGhlcmljYWx9IGZyb20gXCIuL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQge2Fjb3MsIGNvcywgZGVncmVlcywgZXBzaWxvbiwgcmFkaWFucywgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcbmltcG9ydCB7cm90YXRlUmFkaWFuc30gZnJvbSBcIi4vcm90YXRpb24uanNcIjtcblxuLy8gR2VuZXJhdGVzIGEgY2lyY2xlIGNlbnRlcmVkIGF0IFswwrAsIDDCsF0sIHdpdGggYSBnaXZlbiByYWRpdXMgYW5kIHByZWNpc2lvbi5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIHQwLCB0MSkge1xuICBpZiAoIWRlbHRhKSByZXR1cm47XG4gIHZhciBjb3NSYWRpdXMgPSBjb3MocmFkaXVzKSxcbiAgICAgIHNpblJhZGl1cyA9IHNpbihyYWRpdXMpLFxuICAgICAgc3RlcCA9IGRpcmVjdGlvbiAqIGRlbHRhO1xuICBpZiAodDAgPT0gbnVsbCkge1xuICAgIHQwID0gcmFkaXVzICsgZGlyZWN0aW9uICogdGF1O1xuICAgIHQxID0gcmFkaXVzIC0gc3RlcCAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdDAgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MCk7XG4gICAgdDEgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MSk7XG4gICAgaWYgKGRpcmVjdGlvbiA+IDAgPyB0MCA8IHQxIDogdDAgPiB0MSkgdDAgKz0gZGlyZWN0aW9uICogdGF1O1xuICB9XG4gIGZvciAodmFyIHBvaW50LCB0ID0gdDA7IGRpcmVjdGlvbiA+IDAgPyB0ID4gdDEgOiB0IDwgdDE7IHQgLT0gc3RlcCkge1xuICAgIHBvaW50ID0gc3BoZXJpY2FsKFtjb3NSYWRpdXMsIC1zaW5SYWRpdXMgKiBjb3ModCksIC1zaW5SYWRpdXMgKiBzaW4odCldKTtcbiAgICBzdHJlYW0ucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBzaWduZWQgYW5nbGUgb2YgYSBjYXJ0ZXNpYW4gcG9pbnQgcmVsYXRpdmUgdG8gW2Nvc1JhZGl1cywgMCwgMF0uXG5mdW5jdGlvbiBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCBwb2ludCkge1xuICBwb2ludCA9IGNhcnRlc2lhbihwb2ludCksIHBvaW50WzBdIC09IGNvc1JhZGl1cztcbiAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShwb2ludCk7XG4gIHZhciByYWRpdXMgPSBhY29zKC1wb2ludFsxXSk7XG4gIHJldHVybiAoKC1wb2ludFsyXSA8IDAgPyAtcmFkaXVzIDogcmFkaXVzKSArIHRhdSAtIGVwc2lsb24pICUgdGF1O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNlbnRlciA9IGNvbnN0YW50KFswLCAwXSksXG4gICAgICByYWRpdXMgPSBjb25zdGFudCg5MCksXG4gICAgICBwcmVjaXNpb24gPSBjb25zdGFudCg2KSxcbiAgICAgIHJpbmcsXG4gICAgICByb3RhdGUsXG4gICAgICBzdHJlYW0gPSB7cG9pbnQ6IHBvaW50fTtcblxuICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgcmluZy5wdXNoKHggPSByb3RhdGUoeCwgeSkpO1xuICAgIHhbMF0gKj0gZGVncmVlcywgeFsxXSAqPSBkZWdyZWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgIHZhciBjID0gY2VudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIgPSByYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnMsXG4gICAgICAgIHAgPSBwcmVjaXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnM7XG4gICAgcmluZyA9IFtdO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoLWNbMF0gKiByYWRpYW5zLCAtY1sxXSAqIHJhZGlhbnMsIDApLmludmVydDtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByLCBwLCAxKTtcbiAgICBjID0ge3R5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogW3JpbmddfTtcbiAgICByaW5nID0gcm90YXRlID0gbnVsbDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGNpcmNsZS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbK19bMF0sICtfWzFdXSksIGNpcmNsZSkgOiBjZW50ZXI7XG4gIH07XG5cbiAgY2lyY2xlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHJhZGl1cztcbiAgfTtcblxuICBjaXJjbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNpc2lvbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcHJlY2lzaW9uO1xuICB9O1xuXG4gIHJldHVybiBjaXJjbGU7XG59XG4iLCJpbXBvcnQgY2xpcCBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHthYnMsIGF0YW4sIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBwaSwgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGlwKFxuICBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXG4gIGNsaXBBbnRpbWVyaWRpYW5MaW5lLFxuICBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsXG4gIFstcGksIC1oYWxmUGldXG4pO1xuXG4vLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzOiAwIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBubyBpbnRlcnNlY3Rpb25zOyAyIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBzaG91bGQgYmUgcmVqb2luZWQuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuTGluZShzdHJlYW0pIHtcbiAgdmFyIGxhbWJkYTAgPSBOYU4sXG4gICAgICBwaGkwID0gTmFOLFxuICAgICAgc2lnbjAgPSBOYU4sXG4gICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuXG4gIHJldHVybiB7XG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIGNsZWFuID0gMTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGExLCBwaGkxKSB7XG4gICAgICB2YXIgc2lnbjEgPSBsYW1iZGExID4gMCA/IHBpIDogLXBpLFxuICAgICAgICAgIGRlbHRhID0gYWJzKGxhbWJkYTEgLSBsYW1iZGEwKTtcbiAgICAgIGlmIChhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uKSB7IC8vIGxpbmUgY3Jvc3NlcyBhIHBvbGVcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAsIHBoaTAgPSAocGhpMCArIHBoaTEpIC8gMiA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMSwgcGhpMCk7XG4gICAgICAgIGNsZWFuID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbjAgIT09IHNpZ24xICYmIGRlbHRhID49IHBpKSB7IC8vIGxpbmUgY3Jvc3NlcyBhbnRpbWVyaWRpYW5cbiAgICAgICAgaWYgKGFicyhsYW1iZGEwIC0gc2lnbjApIDwgZXBzaWxvbikgbGFtYmRhMCAtPSBzaWduMCAqIGVwc2lsb247IC8vIGhhbmRsZSBkZWdlbmVyYWNpZXNcbiAgICAgICAgaWYgKGFicyhsYW1iZGExIC0gc2lnbjEpIDwgZXBzaWxvbikgbGFtYmRhMSAtPSBzaWduMSAqIGVwc2lsb247XG4gICAgICAgIHBoaTAgPSBjbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KGxhbWJkYTAsIHBoaTAsIGxhbWJkYTEsIHBoaTEpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgIGNsZWFuID0gMDtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwID0gbGFtYmRhMSwgcGhpMCA9IHBoaTEpO1xuICAgICAgc2lnbjAgPSBzaWduMTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIGxhbWJkYTAgPSBwaGkwID0gTmFOO1xuICAgIH0sXG4gICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDIgLSBjbGVhbjsgLy8gaWYgaW50ZXJzZWN0aW9ucywgcmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KGxhbWJkYTAsIHBoaTAsIGxhbWJkYTEsIHBoaTEpIHtcbiAgdmFyIGNvc1BoaTAsXG4gICAgICBjb3NQaGkxLFxuICAgICAgc2luTGFtYmRhMExhbWJkYTEgPSBzaW4obGFtYmRhMCAtIGxhbWJkYTEpO1xuICByZXR1cm4gYWJzKHNpbkxhbWJkYTBMYW1iZGExKSA+IGVwc2lsb25cbiAgICAgID8gYXRhbigoc2luKHBoaTApICogKGNvc1BoaTEgPSBjb3MocGhpMSkpICogc2luKGxhbWJkYTEpXG4gICAgICAgICAgLSBzaW4ocGhpMSkgKiAoY29zUGhpMCA9IGNvcyhwaGkwKSkgKiBzaW4obGFtYmRhMCkpXG4gICAgICAgICAgLyAoY29zUGhpMCAqIGNvc1BoaTEgKiBzaW5MYW1iZGEwTGFtYmRhMSkpXG4gICAgICA6IChwaGkwICsgcGhpMSkgLyAyO1xufVxuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gIHZhciBwaGk7XG4gIGlmIChmcm9tID09IG51bGwpIHtcbiAgICBwaGkgPSBkaXJlY3Rpb24gKiBoYWxmUGk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCAwKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCAwKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCBwaGkpO1xuICB9IGVsc2UgaWYgKGFicyhmcm9tWzBdIC0gdG9bMF0pID4gZXBzaWxvbikge1xuICAgIHZhciBsYW1iZGEgPSBmcm9tWzBdIDwgdG9bMF0gPyBwaSA6IC1waTtcbiAgICBwaGkgPSBkaXJlY3Rpb24gKiBsYW1iZGEgLyAyO1xuICAgIHN0cmVhbS5wb2ludCgtbGFtYmRhLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gIH1cbn1cbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZXMgPSBbXSxcbiAgICAgIGxpbmU7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHksIG0pIHtcbiAgICAgIGxpbmUucHVzaChbeCwgeSwgbV0pO1xuICAgIH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgcmVqb2luOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgfSxcbiAgICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxpbmVzO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuQWRkSW5QbGFjZSwgY2FydGVzaWFuQ3Jvc3MsIGNhcnRlc2lhbkRvdCwgY2FydGVzaWFuU2NhbGUsIHNwaGVyaWNhbH0gZnJvbSBcIi4uL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IHtjaXJjbGVTdHJlYW19IGZyb20gXCIuLi9jaXJjbGUuanNcIjtcbmltcG9ydCB7YWJzLCBjb3MsIGVwc2lsb24sIHBpLCByYWRpYW5zLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHBvaW50RXF1YWwgZnJvbSBcIi4uL3BvaW50RXF1YWwuanNcIjtcbmltcG9ydCBjbGlwIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhZGl1cykge1xuICB2YXIgY3IgPSBjb3MocmFkaXVzKSxcbiAgICAgIGRlbHRhID0gNiAqIHJhZGlhbnMsXG4gICAgICBzbWFsbFJhZGl1cyA9IGNyID4gMCxcbiAgICAgIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gZXBzaWxvbjsgLy8gVE9ETyBvcHRpbWlzZSBmb3IgdGhpcyBjb21tb24gY2FzZVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgZnJvbSwgdG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaWJsZShsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBjb3MobGFtYmRhKSAqIGNvcyhwaGkpID4gY3I7XG4gIH1cblxuICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzIHVzZWQgZm9yIHBvbHlnb25cbiAgLy8gY2xpcHBpbmc6IDAgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm9cbiAgLy8gaW50ZXJzZWN0aW9ucyAyIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gIC8vIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoc3RyZWFtKSB7XG4gICAgdmFyIHBvaW50MCwgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgYzAsIC8vIGNvZGUgZm9yIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwLCAvLyB2aXNpYmlsaXR5IG9mIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwMCwgLy8gdmlzaWJpbGl0eSBvZiBmaXJzdCBwb2ludFxuICAgICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICBjbGVhbiA9IDE7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwb2ludDEgPSBbbGFtYmRhLCBwaGldLFxuICAgICAgICAgICAgcG9pbnQyLFxuICAgICAgICAgICAgdiA9IHZpc2libGUobGFtYmRhLCBwaGkpLFxuICAgICAgICAgICAgYyA9IHNtYWxsUmFkaXVzXG4gICAgICAgICAgICAgID8gdiA/IDAgOiBjb2RlKGxhbWJkYSwgcGhpKVxuICAgICAgICAgICAgICA6IHYgPyBjb2RlKGxhbWJkYSArIChsYW1iZGEgPCAwID8gcGkgOiAtcGkpLCBwaGkpIDogMDtcbiAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICBpZiAoIXBvaW50MiB8fCBwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBwb2ludEVxdWFsKHBvaW50MSwgcG9pbnQyKSlcbiAgICAgICAgICAgIHBvaW50MVsyXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAvLyBvdXRzaWRlIGdvaW5nIGluXG4gICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDApO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zaWRlIGdvaW5nIG91dFxuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSwgMik7XG4gICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludDAgPSBwb2ludDI7XG4gICAgICAgIH0gZWxzZSBpZiAobm90SGVtaXNwaGVyZSAmJiBwb2ludDAgJiYgc21hbGxSYWRpdXMgXiB2KSB7XG4gICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvZGVzIGZvciB0d28gcG9pbnRzIGFyZSBkaWZmZXJlbnQsIG9yIGFyZSBib3RoIHplcm8sXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIHRoaXMgc2VnbWVudCBpbnRlcnNlY3RzIHdpdGggdGhlIHNtYWxsIGNpcmNsZS5cbiAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgIGlmIChzbWFsbFJhZGl1cykge1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdLCAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgJiYgKCFwb2ludDAgfHwgIXBvaW50RXF1YWwocG9pbnQwLCBwb2ludDEpKSkge1xuICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnQwID0gcG9pbnQxLCB2MCA9IHYsIGMwID0gYztcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHYwKSBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBwb2ludDAgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIC8vIFJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBpZiB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gYW5kIGxhc3QgcG9pbnRzIHdlcmUgdmlzaWJsZS5cbiAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuIHwgKCh2MDAgJiYgdjApIDw8IDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBJbnRlcnNlY3RzIHRoZSBncmVhdCBjaXJjbGUgYmV0d2VlbiBhIGFuZCBiIHdpdGggdGhlIGNsaXAgY2lyY2xlLlxuICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgdHdvKSB7XG4gICAgdmFyIHBhID0gY2FydGVzaWFuKGEpLFxuICAgICAgICBwYiA9IGNhcnRlc2lhbihiKTtcblxuICAgIC8vIFdlIGhhdmUgdHdvIHBsYW5lcywgbjEucCA9IGQxIGFuZCBuMi5wID0gZDIuXG4gICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gbGluZSBwKHQpID0gYzEgbjEgKyBjMiBuMiArIHQgKG4xIOKoryBuMikuXG4gICAgdmFyIG4xID0gWzEsIDAsIDBdLCAvLyBub3JtYWxcbiAgICAgICAgbjIgPSBjYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLFxuICAgICAgICBuMm4yID0gY2FydGVzaWFuRG90KG4yLCBuMiksXG4gICAgICAgIG4xbjIgPSBuMlswXSwgLy8gY2FydGVzaWFuRG90KG4xLCBuMiksXG4gICAgICAgIGRldGVybWluYW50ID0gbjJuMiAtIG4xbjIgKiBuMW4yO1xuXG4gICAgLy8gVHdvIHBvbGFyIHBvaW50cy5cbiAgICBpZiAoIWRldGVybWluYW50KSByZXR1cm4gIXR3byAmJiBhO1xuXG4gICAgdmFyIGMxID0gIGNyICogbjJuMiAvIGRldGVybWluYW50LFxuICAgICAgICBjMiA9IC1jciAqIG4xbjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgbjF4bjIgPSBjYXJ0ZXNpYW5Dcm9zcyhuMSwgbjIpLFxuICAgICAgICBBID0gY2FydGVzaWFuU2NhbGUobjEsIGMxKSxcbiAgICAgICAgQiA9IGNhcnRlc2lhblNjYWxlKG4yLCBjMik7XG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShBLCBCKTtcblxuICAgIC8vIFNvbHZlIHxwKHQpfF4yID0gMS5cbiAgICB2YXIgdSA9IG4xeG4yLFxuICAgICAgICB3ID0gY2FydGVzaWFuRG90KEEsIHUpLFxuICAgICAgICB1dSA9IGNhcnRlc2lhbkRvdCh1LCB1KSxcbiAgICAgICAgdDIgPSB3ICogdyAtIHV1ICogKGNhcnRlc2lhbkRvdChBLCBBKSAtIDEpO1xuXG4gICAgaWYgKHQyIDwgMCkgcmV0dXJuO1xuXG4gICAgdmFyIHQgPSBzcXJ0KHQyKSxcbiAgICAgICAgcSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocSwgQSk7XG4gICAgcSA9IHNwaGVyaWNhbChxKTtcblxuICAgIGlmICghdHdvKSByZXR1cm4gcTtcblxuICAgIC8vIFR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAgIHZhciBsYW1iZGEwID0gYVswXSxcbiAgICAgICAgbGFtYmRhMSA9IGJbMF0sXG4gICAgICAgIHBoaTAgPSBhWzFdLFxuICAgICAgICBwaGkxID0gYlsxXSxcbiAgICAgICAgejtcblxuICAgIGlmIChsYW1iZGExIDwgbGFtYmRhMCkgeiA9IGxhbWJkYTAsIGxhbWJkYTAgPSBsYW1iZGExLCBsYW1iZGExID0gejtcblxuICAgIHZhciBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICBwb2xhciA9IGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24sXG4gICAgICAgIG1lcmlkaWFuID0gcG9sYXIgfHwgZGVsdGEgPCBlcHNpbG9uO1xuXG4gICAgaWYgKCFwb2xhciAmJiBwaGkxIDwgcGhpMCkgeiA9IHBoaTAsIHBoaTAgPSBwaGkxLCBwaGkxID0gejtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGZpcnN0IHBvaW50IGlzIGJldHdlZW4gYSBhbmQgYi5cbiAgICBpZiAobWVyaWRpYW5cbiAgICAgICAgPyBwb2xhclxuICAgICAgICAgID8gcGhpMCArIHBoaTEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIGxhbWJkYTApIDwgZXBzaWxvbiA/IHBoaTAgOiBwaGkxKVxuICAgICAgICAgIDogcGhpMCA8PSBxWzFdICYmIHFbMV0gPD0gcGhpMVxuICAgICAgICA6IGRlbHRhID4gcGkgXiAobGFtYmRhMCA8PSBxWzBdICYmIHFbMF0gPD0gbGFtYmRhMSkpIHtcbiAgICAgIHZhciBxMSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyArIHQpIC8gdXUpO1xuICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShxMSwgQSk7XG4gICAgICByZXR1cm4gW3EsIHNwaGVyaWNhbChxMSldO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhIDQtYml0IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgcG9pbnQgcmVsYXRpdmUgdG9cbiAgLy8gdGhlIHNtYWxsIGNpcmNsZSdzIGJvdW5kaW5nIGJveC5cbiAgZnVuY3Rpb24gY29kZShsYW1iZGEsIHBoaSkge1xuICAgIHZhciByID0gc21hbGxSYWRpdXMgPyByYWRpdXMgOiBwaSAtIHJhZGl1cyxcbiAgICAgICAgY29kZSA9IDA7XG4gICAgaWYgKGxhbWJkYSA8IC1yKSBjb2RlIHw9IDE7IC8vIGxlZnRcbiAgICBlbHNlIGlmIChsYW1iZGEgPiByKSBjb2RlIHw9IDI7IC8vIHJpZ2h0XG4gICAgaWYgKHBoaSA8IC1yKSBjb2RlIHw9IDQ7IC8vIGJlbG93XG4gICAgZWxzZSBpZiAocGhpID4gcikgY29kZSB8PSA4OyAvLyBhYm92ZVxuICAgIHJldHVybiBjb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFswLCAtcmFkaXVzXSA6IFstcGksIHJhZGl1cyAtIHBpXSk7XG59XG4iLCJpbXBvcnQgY2xpcEJ1ZmZlciBmcm9tIFwiLi9idWZmZXIuanNcIjtcbmltcG9ydCBjbGlwUmVqb2luIGZyb20gXCIuL3Jlam9pbi5qc1wiO1xuaW1wb3J0IHtlcHNpbG9uLCBoYWxmUGl9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgcG9seWdvbkNvbnRhaW5zIGZyb20gXCIuLi9wb2x5Z29uQ29udGFpbnMuanNcIjtcbmltcG9ydCB7bWVyZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwb2ludFZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc3RhcnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNpbmspIHtcbiAgICB2YXIgbGluZSA9IGNsaXBMaW5lKHNpbmspLFxuICAgICAgICByaW5nQnVmZmVyID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICByaW5nU2luayA9IGNsaXBMaW5lKHJpbmdCdWZmZXIpLFxuICAgICAgICBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcmluZztcblxuICAgIHZhciBjbGlwID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50UmluZztcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgIGNsaXAubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgIHBvbHlnb24gPSBbXTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc2VnbWVudHMgPSBtZXJnZShzZWdtZW50cyk7XG4gICAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25Db250YWlucyhwb2x5Z29uLCBzdGFydCk7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzaW5rKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydEluc2lkZSkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uRW5kKCksIHBvbHlnb25TdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICB9LFxuICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICBzaW5rLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIGlmIChwb2ludFZpc2libGUobGFtYmRhLCBwaGkpKSBzaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludExpbmUobGFtYmRhLCBwaGkpIHtcbiAgICAgIGxpbmUucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICBsaW5lLmxpbmVTdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICBsaW5lLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludFJpbmcobGFtYmRhLCBwaGkpIHtcbiAgICAgIHJpbmcucHVzaChbbGFtYmRhLCBwaGldKTtcbiAgICAgIHJpbmdTaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICByaW5nU2luay5saW5lU3RhcnQoKTtcbiAgICAgIHJpbmcgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgcmluZ1NpbmsubGluZUVuZCgpO1xuXG4gICAgICB2YXIgY2xlYW4gPSByaW5nU2luay5jbGVhbigpLFxuICAgICAgICAgIHJpbmdTZWdtZW50cyA9IHJpbmdCdWZmZXIucmVzdWx0KCksXG4gICAgICAgICAgaSwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGgsIG0sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBwb2ludDtcblxuICAgICAgcmluZy5wb3AoKTtcbiAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICAgIHJpbmcgPSBudWxsO1xuXG4gICAgICBpZiAoIW4pIHJldHVybjtcblxuICAgICAgLy8gTm8gaW50ZXJzZWN0aW9ucy5cbiAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgc2VnbWVudCA9IHJpbmdTZWdtZW50c1swXTtcbiAgICAgICAgaWYgKChtID0gc2VnbWVudC5sZW5ndGggLSAxKSA+IDApIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzaW5rLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWpvaW4gY29ubmVjdGVkIHNlZ21lbnRzLlxuICAgICAgLy8gVE9ETyByZXVzZSByaW5nQnVmZmVyLnJlam9pbigpP1xuICAgICAgaWYgKG4gPiAxICYmIGNsZWFuICYgMikgcmluZ1NlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLnBvcCgpLmNvbmNhdChyaW5nU2VnbWVudHMuc2hpZnQoKSkpO1xuXG4gICAgICBzZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5maWx0ZXIodmFsaWRTZWdtZW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG59XG5cbi8vIEludGVyc2VjdGlvbnMgYXJlIHNvcnRlZCBhbG9uZyB0aGUgY2xpcCBlZGdlLiBGb3IgYm90aCBhbnRpbWVyaWRpYW4gY3V0dGluZ1xuLy8gYW5kIGNpcmNsZSBjbGlwcGluZywgdGhlIHNhbWUgY29tcGFyaXNvbiBpcyB1c2VkLlxuZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gIHJldHVybiAoKGEgPSBhLngpWzBdIDwgMCA/IGFbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYVsxXSlcbiAgICAgICAtICgoYiA9IGIueClbMF0gPCAwID8gYlsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBiWzFdKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBkeCA9IGJ4IC0gYXgsXG4gICAgICBkeSA9IGJ5IC0gYXksXG4gICAgICByO1xuXG4gIHIgPSB4MCAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geDEgLSBheDtcbiAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgciA9IHkwIC0gYXk7XG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB5MSAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICBpZiAodDAgPiAwKSBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xuICBpZiAodDEgPCAxKSBiWzBdID0gYXggKyB0MSAqIGR4LCBiWzFdID0gYXkgKyB0MSAqIGR5O1xuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7YWJzLCBlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IGNsaXBCdWZmZXIgZnJvbSBcIi4vYnVmZmVyLmpzXCI7XG5pbXBvcnQgY2xpcExpbmUgZnJvbSBcIi4vbGluZS5qc1wiO1xuaW1wb3J0IGNsaXBSZWpvaW4gZnJvbSBcIi4vcmVqb2luLmpzXCI7XG5pbXBvcnQge21lcmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcblxudmFyIGNsaXBNYXggPSAxZTksIGNsaXBNaW4gPSAtY2xpcE1heDtcblxuLy8gVE9ETyBVc2UgZDMtcG9seWdvbuKAmXMgcG9seWdvbkNvbnRhaW5zIGhlcmUgZm9yIHRoZSByaW5nIGNoZWNrP1xuLy8gVE9ETyBFbGltaW5hdGUgZHVwbGljYXRlIGJ1ZmZlcmluZyBpbiBjbGlwQnVmZmVyIGFuZCBwb2x5Z29uLnB1c2g/XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpIHtcblxuICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcbiAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSlcbiAgICAgICAgfHwgY29tcGFyZVBvaW50KGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBkbyBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xuICAgICAgICA6IGFicyhwWzBdIC0geDEpIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMVxuICAgICAgICA6IGFicyhwWzFdIC0geTApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMFxuICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XG4gICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLFxuICAgICAgICBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxuICAgICAgICA6IGNhID09PSAwID8gYlsxXSAtIGFbMV1cbiAgICAgICAgOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdXG4gICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxuICAgICAgICA6IGJbMF0gLSBhWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sXG4gICAgICAgIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHJpbmcsXG4gICAgICAgIHhfXywgeV9fLCB2X18sIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGZpcnN0LFxuICAgICAgICBjbGVhbjtcblxuICAgIHZhciBjbGlwU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBwb2x5Z29uU3RhcnQsXG4gICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGlmICh2aXNpYmxlKHgsIHkpKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBmb3IgKHZhciByaW5nID0gcG9seWdvbltpXSwgaiA9IDEsIG0gPSByaW5nLmxlbmd0aCwgcG9pbnQgPSByaW5nWzBdLCBhMCwgYTEsIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07IGogPCBtOyArK2opIHtcbiAgICAgICAgICBhMCA9IGIwLCBhMSA9IGIxLCBwb2ludCA9IHJpbmdbal0sIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07XG4gICAgICAgICAgaWYgKGExIDw9IHkxKSB7IGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSkgKyt3aW5kaW5nOyB9XG4gICAgICAgICAgZWxzZSB7IGlmIChiMSA8PSB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPCAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpIC0td2luZGluZzsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kaW5nO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBnZW9tZXRyeSB3aXRoaW4gYSBwb2x5Z29uIGFuZCB0aGVuIGNsaXAgaXQgZW4gbWFzc2UuXG4gICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgYWN0aXZlU3RyZWFtID0gYnVmZmVyU3RyZWFtLCBzZWdtZW50cyA9IFtdLCBwb2x5Z29uID0gW10sIGNsZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkluc2lkZSgpLFxuICAgICAgICAgIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsXG4gICAgICAgICAgdmlzaWJsZSA9IChzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKSkubGVuZ3RoO1xuICAgICAgaWYgKGNsZWFuSW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBpZiAoY2xlYW5JbnNpZGUpIHtcbiAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc3RyZWFtKTtcbiAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgICBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sIHNlZ21lbnRzID0gcG9seWdvbiA9IHJpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBpZiAocG9seWdvbikgcG9seWdvbi5wdXNoKHJpbmcgPSBbXSk7XG4gICAgICBmaXJzdCA9IHRydWU7XG4gICAgICB2XyA9IGZhbHNlO1xuICAgICAgeF8gPSB5XyA9IE5hTjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIHJhdGhlciB0aGFuIHNwZWNpYWwtY2FzZSBwb2x5Z29ucywgc2ltcGx5IGhhbmRsZSB0aGVtIHNlcGFyYXRlbHkuXG4gICAgLy8gSWRlYWxseSwgY29pbmNpZGVudCBpbnRlcnNlY3Rpb24gcG9pbnRzIHNob3VsZCBiZSBqaXR0ZXJlZCB0byBhdm9pZFxuICAgIC8vIGNsaXBwaW5nIGlzc3Vlcy5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XG4gICAgICAgIGlmICh2X18gJiYgdl8pIGJ1ZmZlclN0cmVhbS5yZWpvaW4oKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChidWZmZXJTdHJlYW0ucmVzdWx0KCkpO1xuICAgICAgfVxuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgaWYgKHZfKSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgdiA9IHZpc2libGUoeCwgeSk7XG4gICAgICBpZiAocG9seWdvbikgcmluZy5wdXNoKFt4LCB5XSk7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAmJiB2XykgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYSA9IFt4XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHhfKSksIHlfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeV8pKV0sXG4gICAgICAgICAgICAgIGIgPSBbeCA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHgpKSwgeSA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHkpKV07XG4gICAgICAgICAgaWYgKGNsaXBMaW5lKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSkge1xuICAgICAgICAgICAgaWYgKCF2Xykge1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChiWzBdLCBiWzFdKTtcbiAgICAgICAgICAgIGlmICghdikgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeF8gPSB4LCB5XyA9IHksIHZfID0gdjtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcFN0cmVhbTtcbiAgfTtcbn1cbiIsImltcG9ydCBwb2ludEVxdWFsIGZyb20gXCIuLi9wb2ludEVxdWFsLmpzXCI7XG5pbXBvcnQge2Vwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIEludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgdGhpcy54ID0gcG9pbnQ7XG4gIHRoaXMueiA9IHBvaW50cztcbiAgdGhpcy5vID0gb3RoZXI7IC8vIGFub3RoZXIgaW50ZXJzZWN0aW9uXG4gIHRoaXMuZSA9IGVudHJ5OyAvLyBpcyBhbiBlbnRyeT9cbiAgdGhpcy52ID0gZmFsc2U7IC8vIHZpc2l0ZWRcbiAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDsgLy8gbmV4dCAmIHByZXZpb3VzXG59XG5cbi8vIEEgZ2VuZXJhbGl6ZWQgcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG06IGdpdmVuIGEgcG9seWdvbiB0aGF0IGhhcyBiZWVuIGN1dFxuLy8gaW50byBpdHMgdmlzaWJsZSBsaW5lIHNlZ21lbnRzLCBhbmQgcmVqb2lucyB0aGUgc2VnbWVudHMgYnkgaW50ZXJwb2xhdGluZ1xuLy8gYWxvbmcgdGhlIGNsaXAgZWRnZS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSkge1xuICB2YXIgc3ViamVjdCA9IFtdLFxuICAgICAgY2xpcCA9IFtdLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dLCB4O1xuXG4gICAgaWYgKHBvaW50RXF1YWwocDAsIHAxKSkge1xuICAgICAgaWYgKCFwMFsyXSAmJiAhcDFbMl0pIHtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIGRlZ2VuZXJhdGUgY2FzZXMgYnkgbW92aW5nIHRoZSBwb2ludFxuICAgICAgcDFbMF0gKz0gMiAqIGVwc2lsb247XG4gICAgfVxuXG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIG51bGwsIHgsIGZhbHNlKSk7XG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBudWxsLCB4LCB0cnVlKSk7XG4gIH0pO1xuXG4gIGlmICghc3ViamVjdC5sZW5ndGgpIHJldHVybjtcblxuICBjbGlwLnNvcnQoY29tcGFyZUludGVyc2VjdGlvbik7XG4gIGxpbmsoc3ViamVjdCk7XG4gIGxpbmsoY2xpcCk7XG5cbiAgZm9yIChpID0gMCwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY2xpcFtpXS5lID0gc3RhcnRJbnNpZGUgPSAhc3RhcnRJbnNpZGU7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLFxuICAgICAgcG9pbnRzLFxuICAgICAgcG9pbnQ7XG5cbiAgd2hpbGUgKDEpIHtcbiAgICAvLyBGaW5kIGZpcnN0IHVudmlzaXRlZCBpbnRlcnNlY3Rpb24uXG4gICAgdmFyIGN1cnJlbnQgPSBzdGFydCxcbiAgICAgICAgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoY3VycmVudC52KSBpZiAoKGN1cnJlbnQgPSBjdXJyZW50Lm4pID09PSBzdGFydCkgcmV0dXJuO1xuICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgZG8ge1xuICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xuICAgICAgICAgIGZvciAoaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubztcbiAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgfSB3aGlsZSAoIWN1cnJlbnQudik7XG4gICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsaW5rKGFycmF5KSB7XG4gIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBhID0gYXJyYXlbMF0sXG4gICAgICBiO1xuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEubiA9IGIgPSBhcnJheVtpXTtcbiAgICBiLnAgPSBhO1xuICAgIGEgPSBiO1xuICB9XG4gIGEubiA9IGIgPSBhcnJheVswXTtcbiAgYi5wID0gYTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcblxuICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gIH1cblxuICBpZiAoYS5pbnZlcnQgJiYgYi5pbnZlcnQpIGNvbXBvc2UuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XG4gIH07XG5cbiAgcmV0dXJuIGNvbXBvc2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4geDtcbiIsImV4cG9ydCB2YXIgZXBzaWxvbiA9IDFlLTY7XG5leHBvcnQgdmFyIGVwc2lsb24yID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG5leHBvcnQgdmFyIHRhdSA9IHBpICogMjtcblxuZXhwb3J0IHZhciBkZWdyZWVzID0gMTgwIC8gcGk7XG5leHBvcnQgdmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxuZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbmV4cG9ydCB2YXIgZXhwID0gTWF0aC5leHA7XG5leHBvcnQgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbmV4cG9ydCB2YXIgaHlwb3QgPSBNYXRoLmh5cG90O1xuZXhwb3J0IHZhciBsb2cgPSBNYXRoLmxvZztcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuZXhwb3J0IHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuZXhwb3J0IHZhciB0YW4gPSBNYXRoLnRhbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhdmVyc2luKHgpIHtcbiAgcmV0dXJuICh4ID0gc2luKHggLyAyKSkgKiB4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG52YXIgeDAgPSBJbmZpbml0eSxcbiAgICB5MCA9IHgwLFxuICAgIHgxID0gLXgwLFxuICAgIHkxID0geDE7XG5cbnZhciBib3VuZHNTdHJlYW0gPSB7XG4gIHBvaW50OiBib3VuZHNQb2ludCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gIHBvbHlnb25FbmQ6IG5vb3AsXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvdW5kcyA9IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIHgxID0geTEgPSAtKHkwID0geDAgPSBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufTtcblxuZnVuY3Rpb24gYm91bmRzUG9pbnQoeCwgeSkge1xuICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gIGlmICh4ID4geDEpIHgxID0geDtcbiAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICBpZiAoeSA+IHkxKSB5MSA9IHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJvdW5kc1N0cmVhbTtcbiIsImltcG9ydCB7YWJzLCBlcHNpbG9ufSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCBlcHNpbG9uICYmIGFicyhhWzFdIC0gYlsxXSkgPCBlcHNpbG9uO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuQ3Jvc3MsIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2V9IGZyb20gXCIuL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIGVwc2lsb24yLCBoYWxmUGksIHBpLCBxdWFydGVyUGksIHNpZ24sIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGxvbmdpdHVkZShwb2ludCkge1xuICBpZiAoYWJzKHBvaW50WzBdKSA8PSBwaSlcbiAgICByZXR1cm4gcG9pbnRbMF07XG4gIGVsc2VcbiAgICByZXR1cm4gc2lnbihwb2ludFswXSkgKiAoKGFicyhwb2ludFswXSkgKyBwaSkgJSB0YXUgLSBwaSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBvbHlnb24sIHBvaW50KSB7XG4gIHZhciBsYW1iZGEgPSBsb25naXR1ZGUocG9pbnQpLFxuICAgICAgcGhpID0gcG9pbnRbMV0sXG4gICAgICBzaW5QaGkgPSBzaW4ocGhpKSxcbiAgICAgIG5vcm1hbCA9IFtzaW4obGFtYmRhKSwgLWNvcyhsYW1iZGEpLCAwXSxcbiAgICAgIGFuZ2xlID0gMCxcbiAgICAgIHdpbmRpbmcgPSAwO1xuXG4gIHZhciBzdW0gPSBuZXcgQWRkZXIoKTtcblxuICBpZiAoc2luUGhpID09PSAxKSBwaGkgPSBoYWxmUGkgKyBlcHNpbG9uO1xuICBlbHNlIGlmIChzaW5QaGkgPT09IC0xKSBwaGkgPSAtaGFsZlBpIC0gZXBzaWxvbjtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEobSA9IChyaW5nID0gcG9seWdvbltpXSkubGVuZ3RoKSkgY29udGludWU7XG4gICAgdmFyIHJpbmcsXG4gICAgICAgIG0sXG4gICAgICAgIHBvaW50MCA9IHJpbmdbbSAtIDFdLFxuICAgICAgICBsYW1iZGEwID0gbG9uZ2l0dWRlKHBvaW50MCksXG4gICAgICAgIHBoaTAgPSBwb2ludDBbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICBzaW5QaGkwID0gc2luKHBoaTApLFxuICAgICAgICBjb3NQaGkwID0gY29zKHBoaTApO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2osIGxhbWJkYTAgPSBsYW1iZGExLCBzaW5QaGkwID0gc2luUGhpMSwgY29zUGhpMCA9IGNvc1BoaTEsIHBvaW50MCA9IHBvaW50MSkge1xuICAgICAgdmFyIHBvaW50MSA9IHJpbmdbal0sXG4gICAgICAgICAgbGFtYmRhMSA9IGxvbmdpdHVkZShwb2ludDEpLFxuICAgICAgICAgIHBoaTEgPSBwb2ludDFbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICAgIHNpblBoaTEgPSBzaW4ocGhpMSksXG4gICAgICAgICAgY29zUGhpMSA9IGNvcyhwaGkxKSxcbiAgICAgICAgICBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICAgIHNpZ24gPSBkZWx0YSA+PSAwID8gMSA6IC0xLFxuICAgICAgICAgIGFic0RlbHRhID0gc2lnbiAqIGRlbHRhLFxuICAgICAgICAgIGFudGltZXJpZGlhbiA9IGFic0RlbHRhID4gcGksXG4gICAgICAgICAgayA9IHNpblBoaTAgKiBzaW5QaGkxO1xuXG4gICAgICBzdW0uYWRkKGF0YW4yKGsgKiBzaWduICogc2luKGFic0RlbHRhKSwgY29zUGhpMCAqIGNvc1BoaTEgKyBrICogY29zKGFic0RlbHRhKSkpO1xuICAgICAgYW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZGVsdGEgKyBzaWduICogdGF1IDogZGVsdGE7XG5cbiAgICAgIC8vIEFyZSB0aGUgbG9uZ2l0dWRlcyBlaXRoZXIgc2lkZSBvZiB0aGUgcG9pbnTigJlzIG1lcmlkaWFuIChsYW1iZGEpLFxuICAgICAgLy8gYW5kIGFyZSB0aGUgbGF0aXR1ZGVzIHNtYWxsZXIgdGhhbiB0aGUgcGFyYWxsZWwgKHBoaSk/XG4gICAgICBpZiAoYW50aW1lcmlkaWFuIF4gbGFtYmRhMCA+PSBsYW1iZGEgXiBsYW1iZGExID49IGxhbWJkYSkge1xuICAgICAgICB2YXIgYXJjID0gY2FydGVzaWFuQ3Jvc3MoY2FydGVzaWFuKHBvaW50MCksIGNhcnRlc2lhbihwb2ludDEpKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShhcmMpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3Mobm9ybWFsLCBhcmMpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGludGVyc2VjdGlvbik7XG4gICAgICAgIHZhciBwaGlBcmMgPSAoYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IC0xIDogMSkgKiBhc2luKGludGVyc2VjdGlvblsyXSk7XG4gICAgICAgIGlmIChwaGkgPiBwaGlBcmMgfHwgcGhpID09PSBwaGlBcmMgJiYgKGFyY1swXSB8fCBhcmNbMV0pKSB7XG4gICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QsIGRldGVybWluZSB3aGV0aGVyIHRoZSBTb3V0aCBwb2xlIGlzIGluc2lkZSBvciBvdXRzaWRlOlxuICAvL1xuICAvLyBJdCBpcyBpbnNpZGUgaWY6XG4gIC8vICogdGhlIHBvbHlnb24gd2luZHMgYXJvdW5kIGl0IGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbi5cbiAgLy8gKiB0aGUgcG9seWdvbiBkb2VzIG5vdCAoY3VtdWxhdGl2ZWx5KSB3aW5kIGFyb3VuZCBpdCwgYnV0IGhhcyBhIG5lZ2F0aXZlXG4gIC8vICAgKGNvdW50ZXItY2xvY2t3aXNlKSBhcmVhLlxuICAvL1xuICAvLyBTZWNvbmQsIGNvdW50IHRoZSAoc2lnbmVkKSBudW1iZXIgb2YgdGltZXMgYSBzZWdtZW50IGNyb3NzZXMgYSBsYW1iZGFcbiAgLy8gZnJvbSB0aGUgcG9pbnQgdG8gdGhlIFNvdXRoIHBvbGUuICBJZiBpdCBpcyB6ZXJvLCB0aGVuIHRoZSBwb2ludCBpcyB0aGVcbiAgLy8gc2FtZSBzaWRlIGFzIHRoZSBTb3V0aCBwb2xlLlxuXG4gIHJldHVybiAoYW5nbGUgPCAtZXBzaWxvbiB8fCBhbmdsZSA8IGVwc2lsb24gJiYgc3VtIDwgLWVwc2lsb24yKSBeICh3aW5kaW5nICYgMSk7XG59XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgZ2VvU3RyZWFtfSBmcm9tIFwiLi4vc3RyZWFtLmpzXCI7XG5pbXBvcnQgYm91bmRzU3RyZWFtIGZyb20gXCIuLi9wYXRoL2JvdW5kcy5qc1wiO1xuXG5mdW5jdGlvbiBmaXQocHJvamVjdGlvbiwgZml0Qm91bmRzLCBvYmplY3QpIHtcbiAgdmFyIGNsaXAgPSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgJiYgcHJvamVjdGlvbi5jbGlwRXh0ZW50KCk7XG4gIHByb2plY3Rpb24uc2NhbGUoMTUwKS50cmFuc2xhdGUoWzAsIDBdKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KG51bGwpO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uLnN0cmVhbShib3VuZHNTdHJlYW0pKTtcbiAgZml0Qm91bmRzKGJvdW5kc1N0cmVhbS5yZXN1bHQoKSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sXG4gICAgICAgIGggPSBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0sXG4gICAgICAgIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLFxuICAgICAgICB4ID0gK2V4dGVudFswXVswXSArICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgW1swLCAwXSwgc2l6ZV0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gK3dpZHRoLFxuICAgICAgICBrID0gdyAvIChiWzFdWzBdIC0gYlswXVswXSksXG4gICAgICAgIHggPSAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSAtayAqIGJbMF1bMV07XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgaCA9ICtoZWlnaHQsXG4gICAgICAgIGsgPSBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSxcbiAgICAgICAgeCA9IC1rICogYlswXVswXSxcbiAgICAgICAgeSA9IChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuIiwiaW1wb3J0IGNsaXBBbnRpbWVyaWRpYW4gZnJvbSBcIi4uL2NsaXAvYW50aW1lcmlkaWFuLmpzXCI7XG5pbXBvcnQgY2xpcENpcmNsZSBmcm9tIFwiLi4vY2xpcC9jaXJjbGUuanNcIjtcbmltcG9ydCBjbGlwUmVjdGFuZ2xlIGZyb20gXCIuLi9jbGlwL3JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4uL2NvbXBvc2UuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7Y29zLCBkZWdyZWVzLCByYWRpYW5zLCBzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge3JvdGF0ZVJhZGlhbnN9IGZyb20gXCIuLi9yb3RhdGlvbi5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IHtmaXRFeHRlbnQsIGZpdFNpemUsIGZpdFdpZHRoLCBmaXRIZWlnaHR9IGZyb20gXCIuL2ZpdC5qc1wiO1xuaW1wb3J0IHJlc2FtcGxlIGZyb20gXCIuL3Jlc2FtcGxlLmpzXCI7XG5cbnZhciB0cmFuc2Zvcm1SYWRpYW5zID0gdHJhbnNmb3JtZXIoe1xuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiByYWRpYW5zLCB5ICogcmFkaWFucyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciByID0gcm90YXRlKHgsIHkpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvaW50KHJbMF0sIHJbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSwgc3gsIHN5KSB7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5KSB7XG4gICAgeCAqPSBzeDsgeSAqPSBzeTtcbiAgICByZXR1cm4gW2R4ICsgayAqIHgsIGR5IC0gayAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsoeCAtIGR4KSAvIGsgKiBzeCwgKGR5IC0geSkgLyBrICogc3ldO1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCBkeCwgZHksIHN4LCBzeSwgYWxwaGEpIHtcbiAgaWYgKCFhbHBoYSkgcmV0dXJuIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSwgc3gsIHN5KTtcbiAgdmFyIGNvc0FscGhhID0gY29zKGFscGhhKSxcbiAgICAgIHNpbkFscGhhID0gc2luKGFscGhhKSxcbiAgICAgIGEgPSBjb3NBbHBoYSAqIGssXG4gICAgICBiID0gc2luQWxwaGEgKiBrLFxuICAgICAgYWkgPSBjb3NBbHBoYSAvIGssXG4gICAgICBiaSA9IHNpbkFscGhhIC8gayxcbiAgICAgIGNpID0gKHNpbkFscGhhICogZHkgLSBjb3NBbHBoYSAqIGR4KSAvIGssXG4gICAgICBmaSA9IChzaW5BbHBoYSAqIGR4ICsgY29zQWxwaGEgKiBkeSkgLyBrO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHggKj0gc3g7IHkgKj0gc3k7XG4gICAgcmV0dXJuIFthICogeCAtIGIgKiB5ICsgZHgsIGR5IC0gYiAqIHggLSBhICogeV07XG4gIH1cbiAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gW3N4ICogKGFpICogeCAtIGJpICogeSArIGNpKSwgc3kgKiAoZmkgLSBiaSAqIHggLSBhaSAqIHkpXTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gIHJldHVybiBwcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHsgcmV0dXJuIHByb2plY3Q7IH0pKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpIHtcbiAgdmFyIHByb2plY3QsXG4gICAgICBrID0gMTUwLCAvLyBzY2FsZVxuICAgICAgeCA9IDQ4MCwgeSA9IDI1MCwgLy8gdHJhbnNsYXRlXG4gICAgICBsYW1iZGEgPSAwLCBwaGkgPSAwLCAvLyBjZW50ZXJcbiAgICAgIGRlbHRhTGFtYmRhID0gMCwgZGVsdGFQaGkgPSAwLCBkZWx0YUdhbW1hID0gMCwgcm90YXRlLCAvLyBwcmUtcm90YXRlXG4gICAgICBhbHBoYSA9IDAsIC8vIHBvc3Qtcm90YXRlIGFuZ2xlXG4gICAgICBzeCA9IDEsIC8vIHJlZmxlY3RYXG4gICAgICBzeSA9IDEsIC8vIHJlZmxlY3RYXG4gICAgICB0aGV0YSA9IG51bGwsIHByZWNsaXAgPSBjbGlwQW50aW1lcmlkaWFuLCAvLyBwcmUtY2xpcCBhbmdsZVxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCBwb3N0Y2xpcCA9IGlkZW50aXR5LCAvLyBwb3N0LWNsaXAgZXh0ZW50XG4gICAgICBkZWx0YTIgPSAwLjUsIC8vIHByZWNpc2lvblxuICAgICAgcHJvamVjdFJlc2FtcGxlLFxuICAgICAgcHJvamVjdFRyYW5zZm9ybSxcbiAgICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0sXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gcHJvamVjdFJvdGF0ZVRyYW5zZm9ybShwb2ludFswXSAqIHJhZGlhbnMsIHBvaW50WzFdICogcmFkaWFucyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZlcnQocG9pbnQpIHtcbiAgICBwb2ludCA9IHByb2plY3RSb3RhdGVUcmFuc2Zvcm0uaW52ZXJ0KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMsIHBvaW50WzFdICogZGVncmVlc107XG4gIH1cblxuICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnModHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkocHJlY2xpcChwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKSkpKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9IF8sIHRoZXRhID0gdW5kZWZpbmVkLCByZXNldCgpKSA6IHByZWNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gK18gPyBjbGlwQ2lyY2xlKHRoZXRhID0gXyAqIHJhZGlhbnMpIDogKHRoZXRhID0gbnVsbCwgY2xpcEFudGltZXJpZGlhbiksIHJlc2V0KCkpIDogdGhldGEgKiBkZWdyZWVzO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVjZW50ZXIoKSkgOiBrO1xuICB9O1xuXG4gIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArX1swXSwgeSA9ICtfWzFdLCByZWNlbnRlcigpKSA6IFt4LCB5XTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgcGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogW2xhbWJkYSAqIGRlZ3JlZXMsIHBoaSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlbHRhTGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhUGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhR2FtbWEgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogcmFkaWFucyA6IDAsIHJlY2VudGVyKCkpIDogW2RlbHRhTGFtYmRhICogZGVncmVlcywgZGVsdGFQaGkgKiBkZWdyZWVzLCBkZWx0YUdhbW1hICogZGVncmVlc107XG4gIH07XG5cbiAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9IF8gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IGFscGhhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJlZmxlY3RYID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN4ID0gXyA/IC0xIDogMSwgcmVjZW50ZXIoKSkgOiBzeCA8IDA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yZWZsZWN0WSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeSA9IF8gPyAtMSA6IDEsIHJlY2VudGVyKCkpIDogc3kgPCAwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMiA9IF8gKiBfKSwgcmVzZXQoKSkgOiBzcXJ0KGRlbHRhMik7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlY2VudGVyKCkge1xuICAgIHZhciBjZW50ZXIgPSBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCAwLCAwLCBzeCwgc3ksIGFscGhhKS5hcHBseShudWxsLCBwcm9qZWN0KGxhbWJkYSwgcGhpKSksXG4gICAgICAgIHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIHggLSBjZW50ZXJbMF0sIHkgLSBjZW50ZXJbMV0sIHN4LCBzeSwgYWxwaGEpO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKTtcbiAgICBwcm9qZWN0VHJhbnNmb3JtID0gY29tcG9zZShwcm9qZWN0LCB0cmFuc2Zvcm0pO1xuICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0gPSBjb21wb3NlKHJvdGF0ZSwgcHJvamVjdFRyYW5zZm9ybSk7XG4gICAgcHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyKTtcbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICByZXR1cm4gcmVjZW50ZXIoKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFufSBmcm9tIFwiLi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgcmFkaWFucywgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcblxudmFyIG1heERlcHRoID0gMTYsIC8vIG1heGltdW0gZGVwdGggb2Ygc3ViZGl2aXNpb25cbiAgICBjb3NNaW5EaXN0YW5jZSA9IGNvcygzMCAqIHJhZGlhbnMpOyAvLyBjb3MobWluaW11bSBhbmd1bGFyIGRpc3RhbmNlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcm9qZWN0LCBkZWx0YTIpIHtcbiAgcmV0dXJuICtkZWx0YTIgPyByZXNhbXBsZShwcm9qZWN0LCBkZWx0YTIpIDogcmVzYW1wbGVOb25lKHByb2plY3QpO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZU5vbmUocHJvamVjdCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikge1xuXG4gIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgdmFyIGR4ID0geDEgLSB4MCxcbiAgICAgICAgZHkgPSB5MSAtIHkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChkMiA+IDQgKiBkZWx0YTIgJiYgZGVwdGgtLSkge1xuICAgICAgdmFyIGEgPSBhMCArIGExLFxuICAgICAgICAgIGIgPSBiMCArIGIxLFxuICAgICAgICAgIGMgPSBjMCArIGMxLFxuICAgICAgICAgIG0gPSBzcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksXG4gICAgICAgICAgcGhpMiA9IGFzaW4oYyAvPSBtKSxcbiAgICAgICAgICBsYW1iZGEyID0gYWJzKGFicyhjKSAtIDEpIDwgZXBzaWxvbiB8fCBhYnMobGFtYmRhMCAtIGxhbWJkYTEpIDwgZXBzaWxvbiA/IChsYW1iZGEwICsgbGFtYmRhMSkgLyAyIDogYXRhbjIoYiwgYSksXG4gICAgICAgICAgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksXG4gICAgICAgICAgeDIgPSBwWzBdLFxuICAgICAgICAgIHkyID0gcFsxXSxcbiAgICAgICAgICBkeDIgPSB4MiAtIHgwLFxuICAgICAgICAgIGR5MiA9IHkyIC0geTAsXG4gICAgICAgICAgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxuICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHsgLy8gYW5ndWxhciBkaXN0YW5jZVxuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCBsYW1iZGEyLCBhLCBiLCBjLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGxhbWJkYTAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgbGFtYmRhMCwgeDAsIHkwLCBhMCwgYjAsIGMwOyAvLyBwcmV2aW91cyBwb2ludFxuXG4gICAgdmFyIHJlc2FtcGxlU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25TdGFydCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7IH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIHgwID0gTmFOO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgbGFtYmRhMCA9IGxhbWJkYSwgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZVBvaW50KGxhbWJkYTAwID0gbGFtYmRhLCBwaGkpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICBsaW5lRW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4vY29tcG9zZS5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGRlZ3JlZXMsIHBpLCByYWRpYW5zLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiByb3RhdGlvbklkZW50aXR5KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbYWJzKGxhbWJkYSkgPiBwaSA/IGxhbWJkYSArIE1hdGgucm91bmQoLWxhbWJkYSAvIHRhdSkgKiB0YXUgOiBsYW1iZGEsIHBoaV07XG59XG5cbnJvdGF0aW9uSWRlbnRpdHkuaW52ZXJ0ID0gcm90YXRpb25JZGVudGl0eTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHJldHVybiAoZGVsdGFMYW1iZGEgJT0gdGF1KSA/IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gY29tcG9zZShyb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSksIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpKVxuICAgIDogcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpKVxuICAgIDogKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKVxuICAgIDogcm90YXRpb25JZGVudGl0eSk7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICByZXR1cm4gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gbGFtYmRhICs9IGRlbHRhTGFtYmRhLCBbbGFtYmRhID4gcGkgPyBsYW1iZGEgLSB0YXUgOiBsYW1iZGEgPCAtcGkgPyBsYW1iZGEgKyB0YXUgOiBsYW1iZGEsIHBoaV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHZhciByb3RhdGlvbiA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSk7XG4gIHJvdGF0aW9uLmludmVydCA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYSgtZGVsdGFMYW1iZGEpO1xuICByZXR1cm4gcm90YXRpb247XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgdmFyIGNvc0RlbHRhUGhpID0gY29zKGRlbHRhUGhpKSxcbiAgICAgIHNpbkRlbHRhUGhpID0gc2luKGRlbHRhUGhpKSxcbiAgICAgIGNvc0RlbHRhR2FtbWEgPSBjb3MoZGVsdGFHYW1tYSksXG4gICAgICBzaW5EZWx0YUdhbW1hID0gc2luKGRlbHRhR2FtbWEpO1xuXG4gIGZ1bmN0aW9uIHJvdGF0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgICB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgICBrID0geiAqIGNvc0RlbHRhUGhpICsgeCAqIHNpbkRlbHRhUGhpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSAtIGsgKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgLSB6ICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFHYW1tYSArIHkgKiBzaW5EZWx0YUdhbW1hKVxuICAgIF07XG4gIH1cblxuICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YUdhbW1hIC0geSAqIHNpbkRlbHRhR2FtbWE7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hICsgeiAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSArIGsgKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YVBoaSAtIHggKiBzaW5EZWx0YVBoaSlcbiAgICBdO1xuICB9O1xuXG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocm90YXRlKSB7XG4gIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMocm90YXRlWzBdICogcmFkaWFucywgcm90YXRlWzFdICogcmFkaWFucywgcm90YXRlLmxlbmd0aCA+IDIgPyByb3RhdGVbMl0gKiByYWRpYW5zIDogMCk7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlKGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUuaW52ZXJ0KGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59XG4iLCJmdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XG4gIGlmIChnZW9tZXRyeSAmJiBzdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICBzdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn1cblxudmFyIHN0cmVhbU9iamVjdFR5cGUgPSB7XG4gIEZlYXR1cmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9LFxuICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn07XG5cbnZhciBzdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW0uc3BoZXJlKCk7XG4gIH0sXG4gIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSwgMCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAwKTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtKTtcbiAgfSxcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0pO1xuICB9LFxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHN0cmVhbSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICBzdHJlYW0ubGluZUVuZCgpO1xufVxuXG5mdW5jdGlvbiBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBzdHJlYW0pIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAxKTtcbiAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgaWYgKG9iamVjdCAmJiBzdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgIHN0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QsIHN0cmVhbSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IHRyYW5zZm9ybWVyKG1ldGhvZHMpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW07XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICBzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkge31cblxuVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7IH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVFbmQoKTsgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cbn07XG4iLCJleHBvcnQgdmFyIGFicyA9IE1hdGguYWJzO1xuZXhwb3J0IHZhciBhdGFuID0gTWF0aC5hdGFuO1xuZXhwb3J0IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5leHBvcnQgdmFyIGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IHZhciBleHAgPSBNYXRoLmV4cDtcbmV4cG9ydCB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuZXhwb3J0IHZhciBsb2cgPSBNYXRoLmxvZztcbmV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciBwb3cgPSBNYXRoLnBvdztcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuZXhwb3J0IHZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuZXhwb3J0IHZhciBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCB2YXIgdGFuID0gTWF0aC50YW47XG5cbmV4cG9ydCB2YXIgZXBzaWxvbiA9IDFlLTY7XG5leHBvcnQgdmFyIGVwc2lsb24yID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG5leHBvcnQgdmFyIHNxcnQxXzIgPSBNYXRoLlNRUlQxXzI7XG5leHBvcnQgdmFyIHNxcnQyID0gc3FydCgyKTtcbmV4cG9ydCB2YXIgc3FydFBpID0gc3FydChwaSk7XG5leHBvcnQgdmFyIHRhdSA9IHBpICogMjtcbmV4cG9ydCB2YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xuZXhwb3J0IHZhciByYWRpYW5zID0gcGkgLyAxODA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5jaSh4KSB7XG4gIHJldHVybiB4ID8geCAvIE1hdGguc2luKHgpIDogMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoeCkge1xuICByZXR1cm4geCA+IDAgPyBNYXRoLnNxcnQoeCkgOiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHggPSBleHAoMiAqIHgpO1xuICByZXR1cm4gKHggLSAxKSAvICh4ICsgMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuIChleHAoeCkgLSBleHAoLXgpKSAvIDI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuIChleHAoeCkgKyBleHAoLXgpKSAvIDI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnNpbmgoeCkge1xuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJjb3NoKHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEpKTtcbn1cbiIsImltcG9ydCB7Z2VvUHJvamVjdGlvbiBhcyBwcm9qZWN0aW9ufSBmcm9tIFwiZDMtZ2VvXCI7XG5pbXBvcnQge2FicywgZGVncmVlcywgZXBzaWxvbjIsIGZsb29yLCBoYWxmUGksIG1heCwgbWluLCBwaSwgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG52YXIgSyA9IFtcbiAgWzAuOTk4NiwgLTAuMDYyXSxcbiAgWzEuMDAwMCwgMC4wMDAwXSxcbiAgWzAuOTk4NiwgMC4wNjIwXSxcbiAgWzAuOTk1NCwgMC4xMjQwXSxcbiAgWzAuOTkwMCwgMC4xODYwXSxcbiAgWzAuOTgyMiwgMC4yNDgwXSxcbiAgWzAuOTczMCwgMC4zMTAwXSxcbiAgWzAuOTYwMCwgMC4zNzIwXSxcbiAgWzAuOTQyNywgMC40MzQwXSxcbiAgWzAuOTIxNiwgMC40OTU4XSxcbiAgWzAuODk2MiwgMC41NTcxXSxcbiAgWzAuODY3OSwgMC42MTc2XSxcbiAgWzAuODM1MCwgMC42NzY5XSxcbiAgWzAuNzk4NiwgMC43MzQ2XSxcbiAgWzAuNzU5NywgMC43OTAzXSxcbiAgWzAuNzE4NiwgMC44NDM1XSxcbiAgWzAuNjczMiwgMC44OTM2XSxcbiAgWzAuNjIxMywgMC45Mzk0XSxcbiAgWzAuNTcyMiwgMC45NzYxXSxcbiAgWzAuNTMyMiwgMS4wMDAwXVxuXTtcblxuSy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgZFsxXSAqPSAxLjAxNDQ7XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJvYmluc29uUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHZhciBpID0gbWluKDE4LCBhYnMocGhpKSAqIDM2IC8gcGkpLFxuICAgICAgaTAgPSBmbG9vcihpKSxcbiAgICAgIGRpID0gaSAtIGkwLFxuICAgICAgYXggPSAoayA9IEtbaTBdKVswXSxcbiAgICAgIGF5ID0ga1sxXSxcbiAgICAgIGJ4ID0gKGsgPSBLWysraTBdKVswXSxcbiAgICAgIGJ5ID0ga1sxXSxcbiAgICAgIGN4ID0gKGsgPSBLW21pbigxOSwgKytpMCldKVswXSxcbiAgICAgIGN5ID0ga1sxXSxcbiAgICAgIGs7XG4gIHJldHVybiBbXG4gICAgbGFtYmRhICogKGJ4ICsgZGkgKiAoY3ggLSBheCkgLyAyICsgZGkgKiBkaSAqIChjeCAtIDIgKiBieCArIGF4KSAvIDIpLFxuICAgIChwaGkgPiAwID8gaGFsZlBpIDogLWhhbGZQaSkgKiAoYnkgKyBkaSAqIChjeSAtIGF5KSAvIDIgKyBkaSAqIGRpICogKGN5IC0gMiAqIGJ5ICsgYXkpIC8gMilcbiAgXTtcbn1cblxucm9iaW5zb25SYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgeXkgPSB5IC8gaGFsZlBpLFxuICAgICAgcGhpID0geXkgKiA5MCxcbiAgICAgIGkgPSBtaW4oMTgsIGFicyhwaGkgLyA1KSksXG4gICAgICBpMCA9IG1heCgwLCBmbG9vcihpKSk7XG4gIGRvIHtcbiAgICB2YXIgYXkgPSBLW2kwXVsxXSxcbiAgICAgICAgYnkgPSBLW2kwICsgMV1bMV0sXG4gICAgICAgIGN5ID0gS1ttaW4oMTksIGkwICsgMildWzFdLFxuICAgICAgICB1ID0gY3kgLSBheSxcbiAgICAgICAgdiA9IGN5IC0gMiAqIGJ5ICsgYXksXG4gICAgICAgIHQgPSAyICogKGFicyh5eSkgLSBieSkgLyB1LFxuICAgICAgICBjID0gdiAvIHUsXG4gICAgICAgIGRpID0gdCAqICgxIC0gYyAqIHQgKiAoMSAtIDIgKiBjICogdCkpO1xuICAgIGlmIChkaSA+PSAwIHx8IGkwID09PSAxKSB7XG4gICAgICBwaGkgPSAoeSA+PSAwID8gNSA6IC01KSAqIChkaSArIGkpO1xuICAgICAgdmFyIGogPSA1MCwgZGVsdGE7XG4gICAgICBkbyB7XG4gICAgICAgIGkgPSBtaW4oMTgsIGFicyhwaGkpIC8gNSk7XG4gICAgICAgIGkwID0gZmxvb3IoaSk7XG4gICAgICAgIGRpID0gaSAtIGkwO1xuICAgICAgICBheSA9IEtbaTBdWzFdO1xuICAgICAgICBieSA9IEtbaTAgKyAxXVsxXTtcbiAgICAgICAgY3kgPSBLW21pbigxOSwgaTAgKyAyKV1bMV07XG4gICAgICAgIHBoaSAtPSAoZGVsdGEgPSAoeSA+PSAwID8gaGFsZlBpIDogLWhhbGZQaSkgKiAoYnkgKyBkaSAqIChjeSAtIGF5KSAvIDIgKyBkaSAqIGRpICogKGN5IC0gMiAqIGJ5ICsgYXkpIC8gMikgLSB5KSAqIGRlZ3JlZXM7XG4gICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbjIgJiYgLS1qID4gMCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKC0taTAgPj0gMCk7XG4gIHZhciBheCA9IEtbaTBdWzBdLFxuICAgICAgYnggPSBLW2kwICsgMV1bMF0sXG4gICAgICBjeCA9IEtbbWluKDE5LCBpMCArIDIpXVswXTtcbiAgcmV0dXJuIFtcbiAgICB4IC8gKGJ4ICsgZGkgKiAoY3ggLSBheCkgLyAyICsgZGkgKiBkaSAqIChjeCAtIDIgKiBieCArIGF4KSAvIDIpLFxuICAgIHBoaSAqIHJhZGlhbnNcbiAgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihyb2JpbnNvblJhdylcbiAgICAgIC5zY2FsZSgxNTIuNjMpO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2FzaW4sIGF0YW4yLCBjb3MsIGRlZ3JlZXMsIGVwc2lsb24sIGVwc2lsb24yLCBoeXBvdCwgcmFkaWFucywgc2luLCBzcXJ0fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi9ub29wLmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuL3N0cmVhbS5qc1wiO1xuXG52YXIgVzAsIFcxLFxuICAgIFgwLCBZMCwgWjAsXG4gICAgWDEsIFkxLCBaMSxcbiAgICBYMiwgWTIsIFoyLFxuICAgIGxhbWJkYTAwLCBwaGkwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICB4MCwgeTAsIHowOyAvLyBwcmV2aW91cyBwb2ludFxuXG52YXIgY2VudHJvaWRTdHJlYW0gPSB7XG4gIHNwaGVyZTogbm9vcCxcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9XG59O1xuXG4vLyBBcml0aG1ldGljIG1lYW4gb2YgQ2FydGVzaWFuIHZlY3RvcnMuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKGNvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgsIHksIHopIHtcbiAgKytXMDtcbiAgWDAgKz0gKHggLSBYMCkgLyBXMDtcbiAgWTAgKz0gKHkgLSBZMCkgLyBXMDtcbiAgWjAgKz0gKHogLSBaMCkgLyBXMDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludDtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICB3ID0gYXRhbjIoc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuLy8gU2VlIEouIEUuIEJyb2NrLCBUaGUgSW5lcnRpYSBUZW5zb3IgZm9yIGEgU3BoZXJpY2FsIFRyaWFuZ2xlLFxuLy8gSi4gQXBwbGllZCBNZWNoYW5pY3MgNDIsIDIzOSAoMTk3NSkuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEwMCA9IGxhbWJkYSwgcGhpMDAgPSBwaGk7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludDtcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICB6MCA9IHNpbihwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSxcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSxcbiAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgIGN4ID0geTAgKiB6IC0gejAgKiB5LFxuICAgICAgY3kgPSB6MCAqIHggLSB4MCAqIHosXG4gICAgICBjeiA9IHgwICogeSAtIHkwICogeCxcbiAgICAgIG0gPSBoeXBvdChjeCwgY3ksIGN6KSxcbiAgICAgIHcgPSBhc2luKG0pLCAvLyBsaW5lIHdlaWdodCA9IGFuZ2xlXG4gICAgICB2ID0gbSAmJiAtdyAvIG07IC8vIGFyZWEgd2VpZ2h0IG11bHRpcGxpZXJcbiAgWDIuYWRkKHYgKiBjeCk7XG4gIFkyLmFkZCh2ICogY3kpO1xuICBaMi5hZGQodiAqIGN6KTtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0KSB7XG4gIFcwID0gVzEgPVxuICBYMCA9IFkwID0gWjAgPVxuICBYMSA9IFkxID0gWjEgPSAwO1xuICBYMiA9IG5ldyBBZGRlcigpO1xuICBZMiA9IG5ldyBBZGRlcigpO1xuICBaMiA9IG5ldyBBZGRlcigpO1xuICBzdHJlYW0ob2JqZWN0LCBjZW50cm9pZFN0cmVhbSk7XG5cbiAgdmFyIHggPSArWDIsXG4gICAgICB5ID0gK1kyLFxuICAgICAgeiA9ICtaMixcbiAgICAgIG0gPSBoeXBvdCh4LCB5LCB6KTtcblxuICAvLyBJZiB0aGUgYXJlYS13ZWlnaHRlZCBjY2VudHJvaWQgaXMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbGVuZ3RoLXdlaWdodGVkIGNjZW50cm9pZC5cbiAgaWYgKG0gPCBlcHNpbG9uMikge1xuICAgIHggPSBYMSwgeSA9IFkxLCB6ID0gWjE7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXG4gICAgaWYgKFcxIDwgZXBzaWxvbikgeCA9IFgwLCB5ID0gWTAsIHogPSBaMDtcbiAgICBtID0gaHlwb3QoeCwgeSwgeik7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgc3RpbGwgaGFzIGFuIHVuZGVmaW5lZCBjY2VudHJvaWQsIHRoZW4gcmV0dXJuLlxuICAgIGlmIChtIDwgZXBzaWxvbjIpIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG5cbiAgcmV0dXJuIFthdGFuMih5LCB4KSAqIGRlZ3JlZXMsIGFzaW4oeiAvIG0pICogZGVncmVlc107XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmVzID0gW10sXG4gICAgICBsaW5lO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5LCBtKSB7XG4gICAgICBsaW5lLnB1c2goW3gsIHksIG1dKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBub29wLFxuICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsaW5lcztcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBsaW5lID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIHQwID0gMCxcbiAgICAgIHQxID0gMSxcbiAgICAgIGR4ID0gYnggLSBheCxcbiAgICAgIGR5ID0gYnkgLSBheSxcbiAgICAgIHI7XG5cbiAgciA9IHgwIC0gYXg7XG4gIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB4MSAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICByID0geTAgLSBheTtcbiAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHkxIC0gYXk7XG4gIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIGlmICh0MCA+IDApIGFbMF0gPSBheCArIHQwICogZHgsIGFbMV0gPSBheSArIHQwICogZHk7XG4gIGlmICh0MSA8IDEpIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgY2xpcEJ1ZmZlciBmcm9tIFwiLi9idWZmZXIuanNcIjtcbmltcG9ydCBjbGlwTGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQgY2xpcFJlam9pbiBmcm9tIFwiLi9yZWpvaW4uanNcIjtcbmltcG9ydCB7bWVyZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuXG52YXIgY2xpcE1heCA9IDFlOSwgY2xpcE1pbiA9IC1jbGlwTWF4O1xuXG4vLyBUT0RPIFVzZSBkMy1wb2x5Z29u4oCZcyBwb2x5Z29uQ29udGFpbnMgaGVyZSBmb3IgdGhlIHJpbmcgY2hlY2s/XG4vLyBUT0RPIEVsaW1pbmF0ZSBkdXBsaWNhdGUgYnVmZmVyaW5nIGluIGNsaXBCdWZmZXIgYW5kIHBvbHlnb24ucHVzaD9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xpcFJlY3RhbmdsZSh4MCwgeTAsIHgxLCB5MSkge1xuXG4gIGZ1bmN0aW9uIHZpc2libGUoeCwgeSkge1xuICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgaWYgKGZyb20gPT0gbnVsbFxuICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxuICAgICAgICB8fCBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIGRvIHN0cmVhbS5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzXG4gICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxXG4gICAgICAgIDogYWJzKHBbMV0gLSB5MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXG4gICAgICAgIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyOyAvLyBhYnMocFsxXSAtIHkxKSA8IGVwc2lsb25cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlUG9pbnQoYS54LCBiLngpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVBvaW50KGEsIGIpIHtcbiAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksXG4gICAgICAgIGNiID0gY29ybmVyKGIsIDEpO1xuICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiXG4gICAgICAgIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXVxuICAgICAgICA6IGNhID09PSAxID8gYVswXSAtIGJbMF1cbiAgICAgICAgOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdXG4gICAgICAgIDogYlswXSAtIGFbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSxcbiAgICAgICAgYnVmZmVyU3RyZWFtID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgcmluZyxcbiAgICAgICAgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgeF8sIHlfLCB2XywgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgZmlyc3QsXG4gICAgICAgIGNsZWFuO1xuXG4gICAgdmFyIGNsaXBTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcbiAgICAgIHBvbHlnb25FbmQ6IHBvbHlnb25FbmRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgaWYgKHZpc2libGUoeCwgeSkpIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uSW5zaWRlKCkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xuICAgICAgICAgIGEwID0gYjAsIGExID0gYjEsIHBvaW50ID0gcmluZ1tqXSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTtcbiAgICAgICAgICBpZiAoYTEgPD0geTEpIHsgaWYgKGIxID4geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpID4gKGIxIC0gYTEpICogKHgwIC0gYTApKSArK3dpbmRpbmc7IH1cbiAgICAgICAgICBlbHNlIHsgaWYgKGIxIDw9IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA8IChiMSAtIGExKSAqICh4MCAtIGEwKSkgLS13aW5kaW5nOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpbmRpbmc7XG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIGdlb21ldHJ5IHdpdGhpbiBhIHBvbHlnb24gYW5kIHRoZW4gY2xpcCBpdCBlbiBtYXNzZS5cbiAgICBmdW5jdGlvbiBwb2x5Z29uU3RhcnQoKSB7XG4gICAgICBhY3RpdmVTdHJlYW0gPSBidWZmZXJTdHJlYW0sIHNlZ21lbnRzID0gW10sIHBvbHlnb24gPSBbXSwgY2xlYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25FbmQoKSB7XG4gICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uSW5zaWRlKCksXG4gICAgICAgICAgY2xlYW5JbnNpZGUgPSBjbGVhbiAmJiBzdGFydEluc2lkZSxcbiAgICAgICAgICB2aXNpYmxlID0gKHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICBpZiAoY2xlYW5JbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xuICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHZfID0gZmFsc2U7XG4gICAgICB4XyA9IHlfID0gTmFOO1xuICAgIH1cblxuICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cbiAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgLy8gY2xpcHBpbmcgaXNzdWVzLlxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICB9XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBpZiAodl8pIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goW3gsIHldKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICYmIHZfKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSxcbiAgICAgICAgICAgICAgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICBpZiAoY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpKSB7XG4gICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgaWYgKCF2KSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3RyZWFtO1xuICB9O1xufVxuIiwiaW1wb3J0IHBvaW50RXF1YWwgZnJvbSBcIi4uL3BvaW50RXF1YWwuanNcIjtcbmltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICB0aGlzLnggPSBwb2ludDtcbiAgdGhpcy56ID0gcG9pbnRzO1xuICB0aGlzLm8gPSBvdGhlcjsgLy8gYW5vdGhlciBpbnRlcnNlY3Rpb25cbiAgdGhpcy5lID0gZW50cnk7IC8vIGlzIGFuIGVudHJ5P1xuICB0aGlzLnYgPSBmYWxzZTsgLy8gdmlzaXRlZFxuICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsOyAvLyBuZXh0ICYgcHJldmlvdXNcbn1cblxuLy8gQSBnZW5lcmFsaXplZCBwb2x5Z29uIGNsaXBwaW5nIGFsZ29yaXRobTogZ2l2ZW4gYSBwb2x5Z29uIHRoYXQgaGFzIGJlZW4gY3V0XG4vLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4vLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gIHZhciBzdWJqZWN0ID0gW10sXG4gICAgICBjbGlwID0gW10sXG4gICAgICBpLFxuICAgICAgbjtcblxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl0sIHg7XG5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBpZiAoIXAwWzJdICYmICFwMVsyXSkge1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgZGVnZW5lcmF0ZSBjYXNlcyBieSBtb3ZpbmcgdGhlIHBvaW50XG4gICAgICBwMVswXSArPSAyICogZXBzaWxvbjtcbiAgICB9XG5cbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMCwgbnVsbCwgeCwgZmFsc2UpKTtcbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIG51bGwsIHgsIHRydWUpKTtcbiAgfSk7XG5cbiAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcbiAgbGluayhzdWJqZWN0KTtcbiAgbGluayhjbGlwKTtcblxuICBmb3IgKGkgPSAwLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjbGlwW2ldLmUgPSBzdGFydEluc2lkZSA9ICFzdGFydEluc2lkZTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHN1YmplY3RbMF0sXG4gICAgICBwb2ludHMsXG4gICAgICBwb2ludDtcblxuICB3aGlsZSAoMSkge1xuICAgIC8vIEZpbmQgZmlyc3QgdW52aXNpdGVkIGludGVyc2VjdGlvbi5cbiAgICB2YXIgY3VycmVudCA9IHN0YXJ0LFxuICAgICAgICBpc1N1YmplY3QgPSB0cnVlO1xuICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgZm9yIChpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICBzdHJlYW0ubGluZUVuZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbmsoYXJyYXkpIHtcbiAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgdmFyIG4sXG4gICAgICBpID0gMCxcbiAgICAgIGEgPSBhcnJheVswXSxcbiAgICAgIGI7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgIGIucCA9IGE7XG4gICAgYSA9IGI7XG4gIH1cbiAgYS5uID0gYiA9IGFycmF5WzBdO1xuICBiLnAgPSBhO1xufVxuIiwiaW1wb3J0IHtyYW5nZX0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2FicywgY2VpbCwgZXBzaWxvbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgdmFyIHkgPSByYW5nZSh5MCwgeTEgLSBlcHNpbG9uLCBkeSkuY29uY2F0KHkxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHkubWFwKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVkoeDAsIHgxLCBkeCkge1xuICB2YXIgeCA9IHJhbmdlKHgwLCB4MSAtIGVwc2lsb24sIGR4KS5jb25jYXQoeDEpO1xuICByZXR1cm4gZnVuY3Rpb24oeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICB2YXIgeDEsIHgwLCBYMSwgWDAsXG4gICAgICB5MSwgeTAsIFkxLCBZMCxcbiAgICAgIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLFxuICAgICAgeCwgeSwgWCwgWSxcbiAgICAgIHByZWNpc2lvbiA9IDIuNTtcblxuICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKX07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICByZXR1cm4gcmFuZ2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxuICAgICAgICAuY29uY2F0KHJhbmdlKGNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpXG4gICAgICAgIC5jb25jYXQocmFuZ2UoY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb247IH0pLm1hcCh4KSlcbiAgICAgICAgLmNvbmNhdChyYW5nZShjZWlsKHkwIC8gZHkpICogZHksIHkxLCBkeSkuZmlsdGVyKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIGFicyh5ICUgRFkpID4gZXBzaWxvbjsgfSkubWFwKHkpKTtcbiAgfVxuXG4gIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbihjb29yZGluYXRlcykgeyByZXR1cm4ge3R5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXN9OyB9KTtcbiAgfTtcblxuICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgIFgoWDApLmNvbmNhdChcbiAgICAgICAgWShZMSkuc2xpY2UoMSksXG4gICAgICAgIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSxcbiAgICAgICAgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKVxuICAgICAgXVxuICAgIH07XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1ham9yKF8pLmV4dGVudE1pbm9yKF8pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW1gwLCBZMF0sIFtYMSwgWTFdXTtcbiAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgIGlmIChZMCA+IFkxKSBfID0gWTAsIFkwID0gWTEsIFkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgaWYgKHgwID4geDEpIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xuICAgIGlmICh5MCA+IHkxKSBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNYWpvcihfKS5zdGVwTWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbRFgsIERZXTtcbiAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgcHJlY2lzaW9uID0gK187XG4gICAgeCA9IGdyYXRpY3VsZVgoeTAsIHkxLCA5MCk7XG4gICAgeSA9IGdyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgIFggPSBncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xuICAgIFkgPSBncmF0aWN1bGVZKFgwLCBYMSwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIHJldHVybiBncmF0aWN1bGVcbiAgICAgIC5leHRlbnRNYWpvcihbWy0xODAsIC05MCArIGVwc2lsb25dLCBbMTgwLCA5MCAtIGVwc2lsb25dXSlcbiAgICAgIC5leHRlbnRNaW5vcihbWy0xODAsIC04MCAtIGVwc2lsb25dLCBbMTgwLCA4MCArIGVwc2lsb25dXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF0aWN1bGUxMCgpIHtcbiAgcmV0dXJuIGdyYXRpY3VsZSgpKCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+IHg7XG4iLCJleHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuZXhwb3J0IHZhciB0YXUgPSBwaSAqIDI7XG5cbmV4cG9ydCB2YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xuZXhwb3J0IHZhciByYWRpYW5zID0gcGkgLyAxODA7XG5cbmV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG5leHBvcnQgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCB2YXIgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5leHBvcnQgdmFyIGV4cCA9IE1hdGguZXhwO1xuZXhwb3J0IHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5leHBvcnQgdmFyIGh5cG90ID0gTWF0aC5oeXBvdDtcbmV4cG9ydCB2YXIgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgdmFyIHBvdyA9IE1hdGgucG93O1xuZXhwb3J0IHZhciBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbmV4cG9ydCB2YXIgc3FydCA9IE1hdGguc3FydDtcbmV4cG9ydCB2YXIgdGFuID0gTWF0aC50YW47XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXZlcnNpbih4KSB7XG4gIHJldHVybiAoeCA9IHNpbih4IC8gMikpICogeDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Fic30gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciBhcmVhU3VtID0gbmV3IEFkZGVyKCksXG4gICAgYXJlYVJpbmdTdW0gPSBuZXcgQWRkZXIoKSxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwLFxuICAgIHkwO1xuXG52YXIgYXJlYVN0cmVhbSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCA9IGFyZWFSaW5nU3RhcnQ7XG4gICAgYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVN0cmVhbS5wb2ludCA9IG5vb3A7XG4gICAgYXJlYVN1bS5hZGQoYWJzKGFyZWFSaW5nU3VtKSk7XG4gICAgYXJlYVJpbmdTdW0gPSBuZXcgQWRkZXIoKTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYSA9IGFyZWFTdW0gLyAyO1xuICAgIGFyZWFTdW0gPSBuZXcgQWRkZXIoKTtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlYVJpbmdTdGFydCgpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnRGaXJzdCh4LCB5KSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnQ7XG4gIHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQoeCwgeSkge1xuICBhcmVhUmluZ1N1bS5hZGQoeTAgKiB4IC0geDAgKiB5KTtcbiAgeDAgPSB4LCB5MCA9IHk7XG59XG5cbmZ1bmN0aW9uIGFyZWFSaW5nRW5kKCkge1xuICBhcmVhUG9pbnQoeDAwLCB5MDApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcmVhU3RyZWFtO1xuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIHgwID0gSW5maW5pdHksXG4gICAgeTAgPSB4MCxcbiAgICB4MSA9IC14MCxcbiAgICB5MSA9IHgxO1xuXG52YXIgYm91bmRzU3RyZWFtID0ge1xuICBwb2ludDogYm91bmRzUG9pbnQsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBub29wLFxuICBwb2x5Z29uRW5kOiBub29wLFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib3VuZHMgPSBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB4MSA9IHkxID0gLSh5MCA9IHgwID0gSW5maW5pdHkpO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJvdW5kc1BvaW50KHgsIHkpIHtcbiAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gIGlmICh5IDwgeTApIHkwID0geTtcbiAgaWYgKHkgPiB5MSkgeTEgPSB5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBib3VuZHNTdHJlYW07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbi8vIFRPRE8gRW5mb3JjZSBwb3NpdGl2ZSBhcmVhIGZvciBleHRlcmlvciwgbmVnYXRpdmUgYXJlYSBmb3IgaW50ZXJpb3I/XG5cbnZhciBYMCA9IDAsXG4gICAgWTAgPSAwLFxuICAgIFowID0gMCxcbiAgICBYMSA9IDAsXG4gICAgWTEgPSAwLFxuICAgIFoxID0gMCxcbiAgICBYMiA9IDAsXG4gICAgWTIgPSAwLFxuICAgIFoyID0gMCxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwLFxuICAgIHkwO1xuXG52YXIgY2VudHJvaWRTdHJlYW0gPSB7XG4gIHBvaW50OiBjZW50cm9pZFBvaW50LFxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkTGluZVN0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZExpbmVFbmQ7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNlbnRyb2lkID0gWjIgPyBbWDIgLyBaMiwgWTIgLyBaMl1cbiAgICAgICAgOiBaMSA/IFtYMSAvIFoxLCBZMSAvIFoxXVxuICAgICAgICA6IFowID8gW1gwIC8gWjAsIFkwIC8gWjBdXG4gICAgICAgIDogW05hTiwgTmFOXTtcbiAgICBYMCA9IFkwID0gWjAgPVxuICAgIFgxID0gWTEgPSBaMSA9XG4gICAgWDIgPSBZMiA9IFoyID0gMDtcbiAgICByZXR1cm4gY2VudHJvaWQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQoeCwgeSkge1xuICBYMCArPSB4O1xuICBZMCArPSB5O1xuICArK1owO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RMaW5lO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RMaW5lKHgsIHkpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50TGluZTtcbiAgY2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRMaW5lKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwLCBkeSA9IHkgLSB5MCwgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICBZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICBaMSArPSB6O1xuICBjZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kKCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdFJpbmc7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCgpIHtcbiAgY2VudHJvaWRQb2ludFJpbmcoeDAwLCB5MDApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RSaW5nKHgsIHkpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50UmluZztcbiAgY2VudHJvaWRQb2ludCh4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRSaW5nKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwLFxuICAgICAgZHkgPSB5IC0geTAsXG4gICAgICB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgWjEgKz0gejtcblxuICB6ID0geTAgKiB4IC0geDAgKiB5O1xuICBYMiArPSB6ICogKHgwICsgeCk7XG4gIFkyICs9IHogKiAoeTAgKyB5KTtcbiAgWjIgKz0geiAqIDM7XG4gIGNlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjZW50cm9pZFN0cmVhbTtcbiIsImltcG9ydCB7dGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGF0aENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUGF0aENvbnRleHQucHJvdG90eXBlID0ge1xuICBfcmFkaXVzOiA0LjUsXG4gIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXM7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4ICsgdGhpcy5fcmFkaXVzLCB5KTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5hcmMoeCwgeSwgdGhpcy5fcmFkaXVzLCAwLCB0YXUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc3VsdDogbm9vcFxufTtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCBzdHJlYW0gZnJvbSBcIi4uL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHBhdGhBcmVhIGZyb20gXCIuL2FyZWEuanNcIjtcbmltcG9ydCBwYXRoQm91bmRzIGZyb20gXCIuL2JvdW5kcy5qc1wiO1xuaW1wb3J0IHBhdGhDZW50cm9pZCBmcm9tIFwiLi9jZW50cm9pZC5qc1wiO1xuaW1wb3J0IFBhdGhDb250ZXh0IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmltcG9ydCBwYXRoTWVhc3VyZSBmcm9tIFwiLi9tZWFzdXJlLmpzXCI7XG5pbXBvcnQgUGF0aFN0cmluZyBmcm9tIFwiLi9zdHJpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocHJvamVjdGlvbiwgY29udGV4dCkge1xuICBsZXQgZGlnaXRzID0gMyxcbiAgICAgIHBvaW50UmFkaXVzID0gNC41LFxuICAgICAgcHJvamVjdGlvblN0cmVhbSxcbiAgICAgIGNvbnRleHRTdHJlYW07XG5cbiAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjb250ZXh0U3RyZWFtKSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0U3RyZWFtLnJlc3VsdCgpO1xuICB9XG5cbiAgcGF0aC5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQXJlYSkpO1xuICAgIHJldHVybiBwYXRoQXJlYS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLm1lYXN1cmUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhNZWFzdXJlKSk7XG4gICAgcmV0dXJuIHBhdGhNZWFzdXJlLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGguYm91bmRzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQm91bmRzKSk7XG4gICAgcmV0dXJuIHBhdGhCb3VuZHMucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aENlbnRyb2lkKSk7XG4gICAgcmV0dXJuIHBhdGhDZW50cm9pZC5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLnByb2plY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICBwcm9qZWN0aW9uU3RyZWFtID0gXyA9PSBudWxsID8gKHByb2plY3Rpb24gPSBudWxsLCBpZGVudGl0eSkgOiAocHJvamVjdGlvbiA9IF8pLnN0cmVhbTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcbiAgICBjb250ZXh0U3RyZWFtID0gXyA9PSBudWxsID8gKGNvbnRleHQgPSBudWxsLCBuZXcgUGF0aFN0cmluZyhkaWdpdHMpKSA6IG5ldyBQYXRoQ29udGV4dChjb250ZXh0ID0gXyk7XG4gICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBwYXRoLmRpZ2l0cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkaWdpdHM7XG4gICAgaWYgKF8gPT0gbnVsbCkgZGlnaXRzID0gbnVsbDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGQgPSBNYXRoLmZsb29yKF8pO1xuICAgICAgaWYgKCEoZCA+PSAwKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgZGlnaXRzOiAke199YCk7XG4gICAgICBkaWdpdHMgPSBkO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkgY29udGV4dFN0cmVhbSA9IG5ldyBQYXRoU3RyaW5nKGRpZ2l0cyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihwcm9qZWN0aW9uKS5kaWdpdHMoZGlnaXRzKS5jb250ZXh0KGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG52YXIgbGVuZ3RoU3VtID0gbmV3IEFkZGVyKCksXG4gICAgbGVuZ3RoUmluZyxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwLFxuICAgIHkwO1xuXG52YXIgbGVuZ3RoU3RyZWFtID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAobGVuZ3RoUmluZykgbGVuZ3RoUG9pbnQoeDAwLCB5MDApO1xuICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IG5vb3A7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoUmluZyA9IHRydWU7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSBudWxsO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtO1xuICAgIGxlbmd0aFN1bSA9IG5ldyBBZGRlcigpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50Rmlyc3QoeCwgeSkge1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludDtcbiAgeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHk7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50KHgsIHkpIHtcbiAgeDAgLT0geCwgeTAgLT0geTtcbiAgbGVuZ3RoU3VtLmFkZChzcXJ0KHgwICogeDAgKyB5MCAqIHkwKSk7XG4gIHgwID0geCwgeTAgPSB5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBsZW5ndGhTdHJlYW07XG4iLCIvLyBTaW1wbGUgY2FjaGluZyBmb3IgY29uc3RhbnQtcmFkaXVzIHBvaW50cy5cbmxldCBjYWNoZURpZ2l0cywgY2FjaGVBcHBlbmQsIGNhY2hlUmFkaXVzLCBjYWNoZUNpcmNsZTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aFN0cmluZyB7XG4gIGNvbnN0cnVjdG9yKGRpZ2l0cykge1xuICAgIHRoaXMuX2FwcGVuZCA9IGRpZ2l0cyA9PSBudWxsID8gYXBwZW5kIDogYXBwZW5kUm91bmQoZGlnaXRzKTtcbiAgICB0aGlzLl9yYWRpdXMgPSA0LjU7XG4gICAgdGhpcy5fID0gXCJcIjtcbiAgfVxuICBwb2ludFJhZGl1cyhfKSB7XG4gICAgdGhpcy5fcmFkaXVzID0gK187XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9seWdvblN0YXJ0KCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9XG4gIHBvbHlnb25FbmQoKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfVxuICBsaW5lU3RhcnQoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9XG4gIGxpbmVFbmQoKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuXyArPSBcIlpcIjtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfVxuICBwb2ludCh4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX2FwcGVuZGBNJHt4fSwke3l9YDtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9hcHBlbmRgTCR7eH0sJHt5fWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLl9hcHBlbmRgTSR7eH0sJHt5fWA7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpdXMgIT09IGNhY2hlUmFkaXVzIHx8IHRoaXMuX2FwcGVuZCAhPT0gY2FjaGVBcHBlbmQpIHtcbiAgICAgICAgICBjb25zdCByID0gdGhpcy5fcmFkaXVzO1xuICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLl87XG4gICAgICAgICAgdGhpcy5fID0gXCJcIjsgLy8gc3Rhc2ggdGhlIG9sZCBzdHJpbmcgc28gd2UgY2FuIGNhY2hlIHRoZSBjaXJjbGUgcGF0aCBmcmFnbWVudFxuICAgICAgICAgIHRoaXMuX2FwcGVuZGBtMCwke3J9YSR7cn0sJHtyfSAwIDEsMSAwLCR7LTIgKiByfWEke3J9LCR7cn0gMCAxLDEgMCwkezIgKiByfXpgO1xuICAgICAgICAgIGNhY2hlUmFkaXVzID0gcjtcbiAgICAgICAgICBjYWNoZUFwcGVuZCA9IHRoaXMuX2FwcGVuZDtcbiAgICAgICAgICBjYWNoZUNpcmNsZSA9IHRoaXMuXztcbiAgICAgICAgICB0aGlzLl8gPSBzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuXyArPSBjYWNoZUNpcmNsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc3VsdCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl87XG4gICAgdGhpcy5fID0gXCJcIjtcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwZW5kKHN0cmluZ3MpIHtcbiAgbGV0IGkgPSAxO1xuICB0aGlzLl8gKz0gc3RyaW5nc1swXTtcbiAgZm9yIChjb25zdCBqID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICB0aGlzLl8gKz0gYXJndW1lbnRzW2ldICsgc3RyaW5nc1tpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBlbmRSb3VuZChkaWdpdHMpIHtcbiAgY29uc3QgZCA9IE1hdGguZmxvb3IoZGlnaXRzKTtcbiAgaWYgKCEoZCA+PSAwKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgZGlnaXRzOiAke2RpZ2l0c31gKTtcbiAgaWYgKGQgPiAxNSkgcmV0dXJuIGFwcGVuZDtcbiAgaWYgKGQgIT09IGNhY2hlRGlnaXRzKSB7XG4gICAgY29uc3QgayA9IDEwICoqIGQ7XG4gICAgY2FjaGVEaWdpdHMgPSBkO1xuICAgIGNhY2hlQXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKHN0cmluZ3MpIHtcbiAgICAgIGxldCBpID0gMTtcbiAgICAgIHRoaXMuXyArPSBzdHJpbmdzWzBdO1xuICAgICAgZm9yIChjb25zdCBqID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgdGhpcy5fICs9IE1hdGgucm91bmQoYXJndW1lbnRzW2ldICogaykgLyBrICsgc3RyaW5nc1tpXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjYWNoZUFwcGVuZDtcbn1cbiIsImltcG9ydCB7YWJzLCBlcHNpbG9ufSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCBlcHNpbG9uICYmIGFicyhhWzFdIC0gYlsxXSkgPCBlcHNpbG9uO1xufVxuIiwiaW1wb3J0IHtkZWZhdWx0IGFzIGdlb1N0cmVhbX0gZnJvbSBcIi4uL3N0cmVhbS5qc1wiO1xuaW1wb3J0IGJvdW5kc1N0cmVhbSBmcm9tIFwiLi4vcGF0aC9ib3VuZHMuanNcIjtcblxuZnVuY3Rpb24gZml0KHByb2plY3Rpb24sIGZpdEJvdW5kcywgb2JqZWN0KSB7XG4gIHZhciBjbGlwID0gcHJvamVjdGlvbi5jbGlwRXh0ZW50ICYmIHByb2plY3Rpb24uY2xpcEV4dGVudCgpO1xuICBwcm9qZWN0aW9uLnNjYWxlKDE1MCkudHJhbnNsYXRlKFswLCAwXSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChudWxsKTtcbiAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvbi5zdHJlYW0oYm91bmRzU3RyZWFtKSk7XG4gIGZpdEJvdW5kcyhib3VuZHNTdHJlYW0ucmVzdWx0KCkpO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoY2xpcCk7XG4gIHJldHVybiBwcm9qZWN0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdLFxuICAgICAgICBoID0gZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdLFxuICAgICAgICBrID0gTWF0aC5taW4odyAvIChiWzFdWzBdIC0gYlswXVswXSksIGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pKSxcbiAgICAgICAgeCA9ICtleHRlbnRbMF1bMF0gKyAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSArZXh0ZW50WzBdWzFdICsgKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xuICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIFtbMCwgMF0sIHNpemVdLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9ICt3aWR0aCxcbiAgICAgICAgayA9IHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLFxuICAgICAgICB4ID0gKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gLWsgKiBiWzBdWzFdO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIGggPSAraGVpZ2h0LFxuICAgICAgICBrID0gaCAvIChiWzFdWzFdIC0gYlswXVsxXSksXG4gICAgICAgIHggPSAtayAqIGJbMF1bMF0sXG4gICAgICAgIHkgPSAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cbiIsImltcG9ydCBjbGlwUmVjdGFuZ2xlIGZyb20gXCIuLi9jbGlwL3JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IHtmaXRFeHRlbnQsIGZpdFNpemUsIGZpdFdpZHRoLCBmaXRIZWlnaHR9IGZyb20gXCIuL2ZpdC5qc1wiO1xuaW1wb3J0IHtjb3MsIGRlZ3JlZXMsIHJhZGlhbnMsIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBrID0gMSwgdHggPSAwLCB0eSA9IDAsIHN4ID0gMSwgc3kgPSAxLCAvLyBzY2FsZSwgdHJhbnNsYXRlIGFuZCByZWZsZWN0XG4gICAgICBhbHBoYSA9IDAsIGNhLCBzYSwgLy8gYW5nbGVcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgLy8gY2xpcCBleHRlbnRcbiAgICAgIGt4ID0gMSwga3kgPSAxLFxuICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtZXIoe1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIHZhciBwID0gcHJvamVjdGlvbihbeCwgeV0pXG4gICAgICAgICAgdGhpcy5zdHJlYW0ucG9pbnQocFswXSwgcFsxXSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcG9zdGNsaXAgPSBpZGVudGl0eSxcbiAgICAgIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW07XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAga3ggPSBrICogc3g7XG4gICAga3kgPSBrICogc3k7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBwcm9qZWN0aW9uIChwKSB7XG4gICAgdmFyIHggPSBwWzBdICoga3gsIHkgPSBwWzFdICoga3k7XG4gICAgaWYgKGFscGhhKSB7XG4gICAgICB2YXIgdCA9IHkgKiBjYSAtIHggKiBzYTtcbiAgICAgIHggPSB4ICogY2EgKyB5ICogc2E7XG4gICAgICB5ID0gdDtcbiAgICB9ICAgIFxuICAgIHJldHVybiBbeCArIHR4LCB5ICsgdHldO1xuICB9XG4gIHByb2plY3Rpb24uaW52ZXJ0ID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciB4ID0gcFswXSAtIHR4LCB5ID0gcFsxXSAtIHR5O1xuICAgIGlmIChhbHBoYSkge1xuICAgICAgdmFyIHQgPSB5ICogY2EgKyB4ICogc2E7XG4gICAgICB4ID0geCAqIGNhIC0geSAqIHNhO1xuICAgICAgeSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBbeCAvIGt4LCB5IC8ga3ldO1xuICB9O1xuICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpO1xuICB9O1xuICBwcm9qZWN0aW9uLnBvc3RjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICB9O1xuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG4gIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoayA9ICtfLCByZXNldCgpKSA6IGs7XG4gIH07XG4gIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR4ID0gK19bMF0sIHR5ID0gK19bMV0sIHJlc2V0KCkpIDogW3R4LCB0eV07XG4gIH1cbiAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9IF8gJSAzNjAgKiByYWRpYW5zLCBzYSA9IHNpbihhbHBoYSksIGNhID0gY29zKGFscGhhKSwgcmVzZXQoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gIH07XG4gIHByb2plY3Rpb24ucmVmbGVjdFggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ggPSBfID8gLTEgOiAxLCByZXNldCgpKSA6IHN4IDwgMDtcbiAgfTtcbiAgcHJvamVjdGlvbi5yZWZsZWN0WSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeSA9IF8gPyAtMSA6IDEsIHJlc2V0KCkpIDogc3kgPCAwO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCk7XG4gIH07XG4gIHByb2plY3Rpb24uZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCk7XG4gIH07XG4gIHByb2plY3Rpb24uZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCk7XG4gIH07XG5cbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG4iLCJmdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XG4gIGlmIChnZW9tZXRyeSAmJiBzdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICBzdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn1cblxudmFyIHN0cmVhbU9iamVjdFR5cGUgPSB7XG4gIEZlYXR1cmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9LFxuICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn07XG5cbnZhciBzdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW0uc3BoZXJlKCk7XG4gIH0sXG4gIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSwgMCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAwKTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtKTtcbiAgfSxcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0pO1xuICB9LFxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHN0cmVhbSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICBzdHJlYW0ubGluZUVuZCgpO1xufVxuXG5mdW5jdGlvbiBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBzdHJlYW0pIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAxKTtcbiAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgaWYgKG9iamVjdCAmJiBzdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgIHN0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QsIHN0cmVhbSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IHRyYW5zZm9ybWVyKG1ldGhvZHMpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW07XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICBzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkge31cblxuVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7IH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVFbmQoKTsgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cbn07XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIChpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXkgOiBnZW5lcmljQXJyYXkpKGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJpY0FycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYSksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxuICAgICAgICB2MSA9IHZhbHVlc1tpXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbaSArIDFdLFxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxuICAgICAgICB2MyA9IGkgPCBuIC0gMSA/IHZhbHVlc1tpICsgMl0gOiAyICogdjIgLSB2MTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jhc2lzfSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIHQgKiBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XG4gIHJldHVybiBhID0gTWF0aC5wb3coYSwgeSksIGIgPSBNYXRoLnBvdyhiLCB5KSAtIGEsIHkgPSAxIC8geSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhhICsgdCAqIGIsIHkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVlKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICogKDEgLSB0KSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cbiIsImltcG9ydCB7bGFiIGFzIGNvbG9yTGFifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIoc3RhcnQsIGVuZCkge1xuICB2YXIgbCA9IGNvbG9yKChzdGFydCA9IGNvbG9yTGFiKHN0YXJ0KSkubCwgKGVuZCA9IGNvbG9yTGFiKGVuZCkpLmwpLFxuICAgICAgYSA9IGNvbG9yKHN0YXJ0LmEsIGVuZC5hKSxcbiAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgIHN0YXJ0LmEgPSBhKHQpO1xuICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICBpZiAoIWIpIGIgPSBbXTtcbiAgdmFyIG4gPSBhID8gTWF0aC5taW4oYi5sZW5ndGgsIGEubGVuZ3RoKSA6IDAsXG4gICAgICBjID0gYi5zbGljZSgpLFxuICAgICAgaTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjW2ldID0gYVtpXSAqICgxIC0gdCkgKyBiW2ldICogdDtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoeCkge1xuICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmICEoeCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cbiIsImltcG9ydCB2YWx1ZSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0ge30sXG4gICAgICBjID0ge30sXG4gICAgICBrO1xuXG4gIGlmIChhID09PSBudWxsIHx8IHR5cGVvZiBhICE9PSBcIm9iamVjdFwiKSBhID0ge307XG4gIGlmIChiID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKSBiID0ge307XG5cbiAgZm9yIChrIGluIGIpIHtcbiAgICBpZiAoayBpbiBhKSB7XG4gICAgICBpW2tdID0gdmFsdWUoYVtrXSwgYltrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNba10gPSBiW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuIiwiaW1wb3J0IHtkZWZhdWx0IGFzIHZhbHVlfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHZhbHVlcyA9IGludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSA9IHZhbHVlO1xuICB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMSwgdiA9IHZhbHVlc1swXSwgSSA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBJW2ldID0gaW50ZXJwb2xhdGUodiwgdiA9IHZhbHVlc1srK2ldKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKj0gbikpKTtcbiAgICByZXR1cm4gSVtpXSh0IC0gaSk7XG4gIH07XG59XG4iLCJpbXBvcnQge3JnYiBhcyBjb2xvclJnYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgYmFzaXMgZnJvbSBcIi4vYmFzaXMuanNcIjtcbmltcG9ydCBiYXNpc0Nsb3NlZCBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuaW1wb3J0IG5vZ2FtbWEsIHtnYW1tYX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcbiAgdmFyIGNvbG9yID0gZ2FtbWEoeSk7XG5cbiAgZnVuY3Rpb24gcmdiKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGNvbG9yKChzdGFydCA9IGNvbG9yUmdiKHN0YXJ0KSkuciwgKGVuZCA9IGNvbG9yUmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3Ioc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYjtcbn0pKDEpO1xuXG5mdW5jdGlvbiByZ2JTcGxpbmUoc3BsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICB2YXIgbiA9IGNvbG9ycy5sZW5ndGgsXG4gICAgICAgIHIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGksIGNvbG9yO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbG9yID0gY29sb3JSZ2IoY29sb3JzW2ldKTtcbiAgICAgIHJbaV0gPSBjb2xvci5yIHx8IDA7XG4gICAgICBnW2ldID0gY29sb3IuZyB8fCAwO1xuICAgICAgYltpXSA9IGNvbG9yLmIgfHwgMDtcbiAgICB9XG4gICAgciA9IHNwbGluZShyKTtcbiAgICBnID0gc3BsaW5lKGcpO1xuICAgIGIgPSBzcGxpbmUoYik7XG4gICAgY29sb3Iub3BhY2l0eSA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbG9yLnIgPSByKHQpO1xuICAgICAgY29sb3IuZyA9IGcodCk7XG4gICAgICBjb2xvci5iID0gYih0KTtcbiAgICAgIHJldHVybiBjb2xvciArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyk7XG5leHBvcnQgdmFyIHJnYkJhc2lzQ2xvc2VkID0gcmdiU3BsaW5lKGJhc2lzQ2xvc2VkKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqICgxIC0gdCkgKyBiICogdCk7XG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLFxuICAgIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYmkgPSByZUEubGFzdEluZGV4ID0gcmVCLmxhc3RJbmRleCA9IDAsIC8vIHNjYW4gaW5kZXggZm9yIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcbiAgICAgIGJtLCAvLyBjdXJyZW50IG1hdGNoIGluIGJcbiAgICAgIGJzLCAvLyBzdHJpbmcgcHJlY2VkaW5nIGN1cnJlbnQgbnVtYmVyIGluIGIsIGlmIGFueVxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXG4gICAgICBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuXG4gIC8vIENvZXJjZSBpbnB1dHMgdG8gc3RyaW5ncy5cbiAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG5cbiAgLy8gSW50ZXJwb2xhdGUgcGFpcnMgb2YgbnVtYmVycyBpbiBhICYgYi5cbiAgd2hpbGUgKChhbSA9IHJlQS5leGVjKGEpKVxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7IC8vIGEgc3RyaW5nIHByZWNlZGVzIHRoZSBuZXh0IG51bWJlciBpbiBiXG4gICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBibTtcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgIHEucHVzaCh7aTogaSwgeDogbnVtYmVyKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufVxuIiwidmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgc2NhbGVYLCBzY2FsZVksIHNrZXdYO1xuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XG4gIGlmIChza2V3WCA9IGEgKiBjICsgYiAqIGQpIGMgLT0gYSAqIHNrZXdYLCBkIC09IGIgKiBza2V3WDtcbiAgaWYgKHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSkgYyAvPSBzY2FsZVksIGQgLz0gc2NhbGVZLCBza2V3WCAvPSBzY2FsZVk7XG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRlWDogZSxcbiAgICB0cmFuc2xhdGVZOiBmLFxuICAgIHJvdGF0ZTogTWF0aC5hdGFuMihiLCBhKSAqIGRlZ3JlZXMsXG4gICAgc2tld1g6IE1hdGguYXRhbihza2V3WCkgKiBkZWdyZWVzLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXIuanNcIjtcbmltcG9ydCB7cGFyc2VDc3MsIHBhcnNlU3ZnfSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZUNzcywgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuIiwiaW1wb3J0IGRlY29tcG9zZSwge2lkZW50aXR5fSBmcm9tIFwiLi9kZWNvbXBvc2UuanNcIjtcblxudmFyIHN2Z05vZGU7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDc3ModmFsdWUpIHtcbiAgY29uc3QgbSA9IG5ldyAodHlwZW9mIERPTU1hdHJpeCA9PT0gXCJmdW5jdGlvblwiID8gRE9NTWF0cml4IDogV2ViS2l0Q1NTTWF0cml4KSh2YWx1ZSArIFwiXCIpO1xuICByZXR1cm4gbS5pc0lkZW50aXR5ID8gaWRlbnRpdHkgOiBkZWNvbXBvc2UobS5hLCBtLmIsIG0uYywgbS5kLCBtLmUsIG0uZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gZGVjb21wb3NlKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgcmdiIGZyb20gXCIuL3JnYi5qc1wiO1xuaW1wb3J0IHtnZW5lcmljQXJyYXl9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgZGF0ZSBmcm9tIFwiLi9kYXRlLmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuaW1wb3J0IG9iamVjdCBmcm9tIFwiLi9vYmplY3QuanNcIjtcbmltcG9ydCBzdHJpbmcgZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIHQgPSB0eXBlb2YgYiwgYztcbiAgcmV0dXJuIGIgPT0gbnVsbCB8fCB0ID09PSBcImJvb2xlYW5cIiA/IGNvbnN0YW50KGIpXG4gICAgICA6ICh0ID09PSBcIm51bWJlclwiID8gbnVtYmVyXG4gICAgICA6IHQgPT09IFwic3RyaW5nXCIgPyAoKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIHJnYikgOiBzdHJpbmcpXG4gICAgICA6IGIgaW5zdGFuY2VvZiBjb2xvciA/IHJnYlxuICAgICAgOiBiIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVcbiAgICAgIDogaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5XG4gICAgICA6IEFycmF5LmlzQXJyYXkoYikgPyBnZW5lcmljQXJyYXlcbiAgICAgIDogdHlwZW9mIGIudmFsdWVPZiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiLnRvU3RyaW5nICE9PSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4oYikgPyBvYmplY3RcbiAgICAgIDogbnVtYmVyKShhLCBiKTtcbn1cbiIsInZhciBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gem9vbVJobyhyaG8sIHJobzIsIHJobzQpIHtcblxuICAvLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4gIC8vIHAxID0gW3V4MSwgdXkxLCB3MV1cbiAgZnVuY3Rpb24gem9vbShwMCwgcDEpIHtcbiAgICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLFxuICAgICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgICBkeSA9IHV5MSAtIHV5MCxcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgICAgaSxcbiAgICAgICAgUztcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICAgIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHQgKiBkeCxcbiAgICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpLmR1cmF0aW9uID0gUyAqIDEwMDAgKiByaG8gLyBNYXRoLlNRUlQyO1xuXG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICB6b29tLnJobyA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgXzEgPSBNYXRoLm1heCgxZS0zLCArXyksIF8yID0gXzEgKiBfMSwgXzQgPSBfMiAqIF8yO1xuICAgIHJldHVybiB6b29tUmhvKF8xLCBfMiwgXzQpO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufSkoTWF0aC5TUVJUMiwgMiwgNCk7XG4iLCJjb25zdCBwaSA9IE1hdGguUEksXG4gICAgdGF1ID0gMiAqIHBpLFxuICAgIGVwc2lsb24gPSAxZS02LFxuICAgIHRhdUVwc2lsb24gPSB0YXUgLSBlcHNpbG9uO1xuXG5mdW5jdGlvbiBhcHBlbmQoc3RyaW5ncykge1xuICB0aGlzLl8gKz0gc3RyaW5nc1swXTtcbiAgZm9yIChsZXQgaSA9IDEsIG4gPSBzdHJpbmdzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHRoaXMuXyArPSBhcmd1bWVudHNbaV0gKyBzdHJpbmdzW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFJvdW5kKGRpZ2l0cykge1xuICBsZXQgZCA9IE1hdGguZmxvb3IoZGlnaXRzKTtcbiAgaWYgKCEoZCA+PSAwKSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpZ2l0czogJHtkaWdpdHN9YCk7XG4gIGlmIChkID4gMTUpIHJldHVybiBhcHBlbmQ7XG4gIGNvbnN0IGsgPSAxMCAqKiBkO1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5ncykge1xuICAgIHRoaXMuXyArPSBzdHJpbmdzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxLCBuID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHRoaXMuXyArPSBNYXRoLnJvdW5kKGFyZ3VtZW50c1tpXSAqIGspIC8gayArIHN0cmluZ3NbaV07XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKGRpZ2l0cykge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICAgIHRoaXMuXyA9IFwiXCI7XG4gICAgdGhpcy5fYXBwZW5kID0gZGlnaXRzID09IG51bGwgPyBhcHBlbmQgOiBhcHBlbmRSb3VuZChkaWdpdHMpO1xuICB9XG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fYXBwZW5kYFpgO1xuICAgIH1cbiAgfVxuICBsaW5lVG8oeCwgeSkge1xuICAgIHRoaXMuX2FwcGVuZGBMJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBxdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuX2FwcGVuZGBRJHsreDF9LCR7K3kxfSwke3RoaXMuX3gxID0gK3h9LCR7dGhpcy5feTEgPSAreX1gO1xuICB9XG4gIGJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgQyR7K3gxfSwkeyt5MX0sJHsreDJ9LCR7K3kyfSwke3RoaXMuX3gxID0gK3h9LCR7dGhpcy5feTEgPSAreX1gO1xuICB9XG4gIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBuZWdhdGl2ZSByYWRpdXM6ICR7cn1gKTtcblxuICAgIGxldCB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gxID0geDF9LCR7dGhpcy5feTEgPSB5MX1gO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDAseTApPyBEbyBub3RoaW5nLlxuICAgIGVsc2UgaWYgKCEobDAxXzIgPiBlcHNpbG9uKSk7XG5cbiAgICAvLyBPciwgYXJlICh4MCx5MCksICh4MSx5MSkgYW5kICh4Mix5MikgY29sbGluZWFyP1xuICAgIC8vIEVxdWl2YWxlbnRseSwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgyLHkyKT9cbiAgICAvLyBPciwgaXMgdGhlIHJhZGl1cyB6ZXJvPyBMaW5lIHRvICh4MSx5MSkuXG4gICAgZWxzZSBpZiAoIShNYXRoLmFicyh5MDEgKiB4MjEgLSB5MjEgKiB4MDEpID4gZXBzaWxvbikgfHwgIXIpIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBMJHt0aGlzLl94MSA9IHgxfSwke3RoaXMuX3kxID0geTF9YDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgbGV0IHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl9hcHBlbmRgTCR7eDEgKyB0MDEgKiB4MDF9LCR7eTEgKyB0MDEgKiB5MDF9YDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYXBwZW5kYEEke3J9LCR7cn0sMCwwLCR7Kyh5MDEgKiB4MjAgPiB4MDEgKiB5MjApfSwke3RoaXMuX3gxID0geDEgKyB0MjEgKiB4MjF9LCR7dGhpcy5feTEgPSB5MSArIHQyMSAqIHkyMX1gO1xuICAgIH1cbiAgfVxuICBhcmMoeCwgeSwgciwgYTAsIGExLCBjY3cpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyLCBjY3cgPSAhIWNjdztcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBuZWdhdGl2ZSByYWRpdXM6ICR7cn1gKTtcblxuICAgIGxldCBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgwLHkwKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBNJHt4MH0sJHt5MH1gO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fYXBwZW5kYEwke3gwfSwke3kwfWA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgZW1wdHk/IFdl4oCZcmUgZG9uZS5cbiAgICBpZiAoIXIpIHJldHVybjtcblxuICAgIC8vIERvZXMgdGhlIGFuZ2xlIGdvIHRoZSB3cm9uZyB3YXk/IEZsaXAgdGhlIGRpcmVjdGlvbi5cbiAgICBpZiAoZGEgPCAwKSBkYSA9IGRhICUgdGF1ICsgdGF1O1xuXG4gICAgLy8gSXMgdGhpcyBhIGNvbXBsZXRlIGNpcmNsZT8gRHJhdyB0d28gYXJjcyB0byBjb21wbGV0ZSB0aGUgY2lyY2xlLlxuICAgIGlmIChkYSA+IHRhdUVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsMSwke2N3fSwke3ggLSBkeH0sJHt5IC0gZHl9QSR7cn0sJHtyfSwwLDEsJHtjd30sJHt0aGlzLl94MSA9IHgwfSwke3RoaXMuX3kxID0geTB9YDtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fYXBwZW5kYEEke3J9LCR7cn0sMCwkeysoZGEgPj0gcGkpfSwke2N3fSwke3RoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSl9LCR7dGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKX1gO1xuICAgIH1cbiAgfVxuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl9hcHBlbmRgTSR7dGhpcy5feDAgPSB0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kwID0gdGhpcy5feTEgPSAreX1oJHt3ID0gK3d9diR7K2h9aCR7LXd9WmA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG4vLyBBbGxvdyBpbnN0YW5jZW9mIGQzLnBhdGhcbnBhdGgucHJvdG90eXBlID0gUGF0aC5wcm90b3R5cGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoUm91bmQoZGlnaXRzID0gMykge1xuICByZXR1cm4gbmV3IFBhdGgoK2RpZ2l0cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGNvbnN0IHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpLFxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCk7XG4gIHJldHVybiBhZGQodGhpcy5jb3Zlcih4LCB5KSwgeCwgeSwgZCk7XG59XG5cbmZ1bmN0aW9uIGFkZCh0cmVlLCB4LCB5LCBkKSB7XG4gIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIHRyZWU7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdHJlZS5fcm9vdCxcbiAgICAgIGxlYWYgPSB7ZGF0YTogZH0sXG4gICAgICB4MCA9IHRyZWUuX3gwLFxuICAgICAgeTAgPSB0cmVlLl95MCxcbiAgICAgIHgxID0gdHJlZS5feDEsXG4gICAgICB5MSA9IHRyZWUuX3kxLFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHhwLFxuICAgICAgeXAsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gRmluZCB0aGUgZXhpc3RpbmcgbGVhZiBmb3IgdGhlIG5ldyBwb2ludCwgb3IgYWRkIGl0LlxuICB3aGlsZSAobm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbiAgfVxuXG4gIC8vIElzIHRoZSBuZXcgcG9pbnQgaXMgZXhhY3RseSBjb2luY2lkZW50IHdpdGggdGhlIGV4aXN0aW5nIHBvaW50P1xuICB4cCA9ICt0cmVlLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgeXAgPSArdHJlZS5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIGlmICh4ID09PSB4cCAmJiB5ID09PSB5cCkgcmV0dXJuIGxlYWYubmV4dCA9IG5vZGUsIHBhcmVudCA/IHBhcmVudFtpXSA9IGxlYWYgOiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBPdGhlcndpc2UsIHNwbGl0IHRoZSBsZWFmIG5vZGUgdW50aWwgdGhlIG9sZCBhbmQgbmV3IHBvaW50IGFyZSBzZXBhcmF0ZWQuXG4gIGRvIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQgPyBwYXJlbnRbaV0gPSBuZXcgQXJyYXkoNCkgOiB0cmVlLl9yb290ID0gbmV3IEFycmF5KDQpO1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICB9IHdoaWxlICgoaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHQpID09PSAoaiA9ICh5cCA+PSB5bSkgPDwgMSB8ICh4cCA+PSB4bSkpKTtcbiAgcmV0dXJuIHBhcmVudFtqXSA9IG5vZGUsIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRBbGwoZGF0YSkge1xuICB2YXIgZCwgaSwgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHl6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeDAgPSBJbmZpbml0eSxcbiAgICAgIHkwID0gSW5maW5pdHksXG4gICAgICB4MSA9IC1JbmZpbml0eSxcbiAgICAgIHkxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQgPSBkYXRhW2ldKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSBjb250aW51ZTtcbiAgICB4eltpXSA9IHg7XG4gICAgeXpbaV0gPSB5O1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdlcmUgbm8gKHZhbGlkKSBwb2ludHMsIGFib3J0LlxuICBpZiAoeDAgPiB4MSB8fCB5MCA+IHkxKSByZXR1cm4gdGhpcztcblxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXG4gIHRoaXMuY292ZXIoeDAsIHkwKS5jb3Zlcih4MSwgeTEpO1xuXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGFkZCh0aGlzLCB4eltpXSwgeXpbaV0sIGRhdGFbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIGlmIChpc05hTih4ID0gK3gpIHx8IGlzTmFOKHkgPSAreSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MTtcblxuICAvLyBJZiB0aGUgcXVhZHRyZWUgaGFzIG5vIGV4dGVudCwgaW5pdGlhbGl6ZSB0aGVtLlxuICAvLyBJbnRlZ2VyIGV4dGVudCBhcmUgbmVjZXNzYXJ5IHNvIHRoYXQgaWYgd2UgbGF0ZXIgZG91YmxlIHRoZSBleHRlbnQsXG4gIC8vIHRoZSBleGlzdGluZyBxdWFkcmFudCBib3VuZGFyaWVzIGRvbuKAmXQgY2hhbmdlIGR1ZSB0byBmbG9hdGluZyBwb2ludCBlcnJvciFcbiAgaWYgKGlzTmFOKHgwKSkge1xuICAgIHgxID0gKHgwID0gTWF0aC5mbG9vcih4KSkgKyAxO1xuICAgIHkxID0gKHkwID0gTWF0aC5mbG9vcih5KSkgKyAxO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkb3VibGUgcmVwZWF0ZWRseSB0byBjb3Zlci5cbiAgZWxzZSB7XG4gICAgdmFyIHogPSB4MSAtIHgwIHx8IDEsXG4gICAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAoeDAgPiB4IHx8IHggPj0geDEgfHwgeTAgPiB5IHx8IHkgPj0geTEpIHtcbiAgICAgIGkgPSAoeSA8IHkwKSA8PCAxIHwgKHggPCB4MCk7XG4gICAgICBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQsIHogKj0gMjtcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6IHgxID0geDAgKyB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogeDAgPSB4MSAtIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAyOiB4MSA9IHgwICsgeiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHgwID0geDEgLSB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5sZW5ndGgpIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gZGF0YS5wdXNoKG5vZGUuZGF0YSk7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuY292ZXIoK19bMF1bMF0sICtfWzBdWzFdKS5jb3ZlcigrX1sxXVswXSwgK19bMV1bMV0pXG4gICAgICA6IGlzTmFOKHRoaXMuX3gwKSA/IHVuZGVmaW5lZCA6IFtbdGhpcy5feDAsIHRoaXMuX3kwXSwgW3RoaXMuX3gxLCB0aGlzLl95MV1dO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeDMgPSB0aGlzLl94MSxcbiAgICAgIHkzID0gdGhpcy5feTEsXG4gICAgICBxdWFkcyA9IFtdLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBxLFxuICAgICAgaTtcblxuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB4MCwgeTAsIHgzLCB5MykpO1xuICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICBlbHNlIHtcbiAgICB4MCA9IHggLSByYWRpdXMsIHkwID0geSAtIHJhZGl1cztcbiAgICB4MyA9IHggKyByYWRpdXMsIHkzID0geSArIHJhZGl1cztcbiAgICByYWRpdXMgKj0gcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuXG4gICAgLy8gU3RvcCBzZWFyY2hpbmcgaWYgdGhpcyBxdWFkcmFudCBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh5MSA9IHEueTApID4geTNcbiAgICAgICAgfHwgKHgyID0gcS54MSkgPCB4MFxuICAgICAgICB8fCAoeTIgPSBxLnkxKSA8IHkwKSBjb250aW51ZTtcblxuICAgIC8vIEJpc2VjdCB0aGUgY3VycmVudCBxdWFkcmFudC5cbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgeW0gPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgICBxdWFkcy5wdXNoKFxuICAgICAgICBuZXcgUXVhZChub2RlWzNdLCB4bSwgeW0sIHgyLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMl0sIHgxLCB5bSwgeG0sIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsxXSwgeG0sIHkxLCB4MiwgeW0pLFxuICAgICAgICBuZXcgUXVhZChub2RlWzBdLCB4MSwgeTEsIHhtLCB5bSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFZpc2l0IHRoZSBjbG9zZXN0IHF1YWRyYW50IGZpcnN0LlxuICAgICAgaWYgKGkgPSAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xuICAgICAgICBxID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV0gPSBxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZpc2l0IHRoaXMgcG9pbnQuIChWaXNpdGluZyBjb2luY2lkZW50IHBvaW50cyBpc27igJl0IG5lY2Vzc2FyeSEpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZHggPSB4IC0gK3RoaXMuX3guY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGR5ID0geSAtICt0aGlzLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHJhZGl1cyA9IGQyKTtcbiAgICAgICAgeDAgPSB4IC0gZCwgeTAgPSB5IC0gZDtcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZDtcbiAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy55MCA9IHkwO1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbn1cbiIsImltcG9ydCB0cmVlX2FkZCwge2FkZEFsbCBhcyB0cmVlX2FkZEFsbH0gZnJvbSBcIi4vYWRkLmpzXCI7XG5pbXBvcnQgdHJlZV9jb3ZlciBmcm9tIFwiLi9jb3Zlci5qc1wiO1xuaW1wb3J0IHRyZWVfZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgdHJlZV9leHRlbnQgZnJvbSBcIi4vZXh0ZW50LmpzXCI7XG5pbXBvcnQgdHJlZV9maW5kIGZyb20gXCIuL2ZpbmQuanNcIjtcbmltcG9ydCB0cmVlX3JlbW92ZSwge3JlbW92ZUFsbCBhcyB0cmVlX3JlbW92ZUFsbH0gZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJlZV9yb290IGZyb20gXCIuL3Jvb3QuanNcIjtcbmltcG9ydCB0cmVlX3NpemUgZnJvbSBcIi4vc2l6ZS5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXQgZnJvbSBcIi4vdmlzaXQuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0QWZ0ZXIgZnJvbSBcIi4vdmlzaXRBZnRlci5qc1wiO1xuaW1wb3J0IHRyZWVfeCwge2RlZmF1bHRYfSBmcm9tIFwiLi94LmpzXCI7XG5pbXBvcnQgdHJlZV95LCB7ZGVmYXVsdFl9IGZyb20gXCIuL3kuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhZHRyZWUobm9kZXMsIHgsIHkpIHtcbiAgdmFyIHRyZWUgPSBuZXcgUXVhZHRyZWUoeCA9PSBudWxsID8gZGVmYXVsdFggOiB4LCB5ID09IG51bGwgPyBkZWZhdWx0WSA6IHksIE5hTiwgTmFOLCBOYU4sIE5hTik7XG4gIHJldHVybiBub2RlcyA9PSBudWxsID8gdHJlZSA6IHRyZWUuYWRkQWxsKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gUXVhZHRyZWUoeCwgeSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5feCA9IHg7XG4gIHRoaXMuX3kgPSB5O1xuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICB0aGlzLl9yb290ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBsZWFmX2NvcHkobGVhZikge1xuICB2YXIgY29weSA9IHtkYXRhOiBsZWFmLmRhdGF9LCBuZXh0ID0gY29weTtcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciB0cmVlUHJvdG8gPSBxdWFkdHJlZS5wcm90b3R5cGUgPSBRdWFkdHJlZS5wcm90b3R5cGU7XG5cbnRyZWVQcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3B5ID0gbmV3IFF1YWR0cmVlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgbm9kZXMsXG4gICAgICBjaGlsZDtcblxuICBpZiAoIW5vZGUpIHJldHVybiBjb3B5O1xuXG4gIGlmICghbm9kZS5sZW5ndGgpIHJldHVybiBjb3B5Ll9yb290ID0gbGVhZl9jb3B5KG5vZGUpLCBjb3B5O1xuXG4gIG5vZGVzID0gW3tzb3VyY2U6IG5vZGUsIHRhcmdldDogY29weS5fcm9vdCA9IG5ldyBBcnJheSg0KX1dO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGUuc291cmNlW2ldKSB7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGgpIG5vZGVzLnB1c2goe3NvdXJjZTogY2hpbGQsIHRhcmdldDogbm9kZS50YXJnZXRbaV0gPSBuZXcgQXJyYXkoNCl9KTtcbiAgICAgICAgZWxzZSBub2RlLnRhcmdldFtpXSA9IGxlYWZfY29weShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG50cmVlUHJvdG8uYWRkID0gdHJlZV9hZGQ7XG50cmVlUHJvdG8uYWRkQWxsID0gdHJlZV9hZGRBbGw7XG50cmVlUHJvdG8uY292ZXIgPSB0cmVlX2NvdmVyO1xudHJlZVByb3RvLmRhdGEgPSB0cmVlX2RhdGE7XG50cmVlUHJvdG8uZXh0ZW50ID0gdHJlZV9leHRlbnQ7XG50cmVlUHJvdG8uZmluZCA9IHRyZWVfZmluZDtcbnRyZWVQcm90by5yZW1vdmUgPSB0cmVlX3JlbW92ZTtcbnRyZWVQcm90by5yZW1vdmVBbGwgPSB0cmVlX3JlbW92ZUFsbDtcbnRyZWVQcm90by5yb290ID0gdHJlZV9yb290O1xudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XG50cmVlUHJvdG8udmlzaXQgPSB0cmVlX3Zpc2l0O1xudHJlZVByb3RvLnZpc2l0QWZ0ZXIgPSB0cmVlX3Zpc2l0QWZ0ZXI7XG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcbnRyZWVQcm90by55ID0gdHJlZV95O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHJldGFpbmVyLFxuICAgICAgcHJldmlvdXMsXG4gICAgICBuZXh0LFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoIShwYXJlbnQgPSBub2RlLCBub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiAzXSB8fCBwYXJlbnRbKGkgKyAyKSAmIDNdIHx8IHBhcmVudFsoaSArIDMpICYgM10pIHJldGFpbmVyID0gcGFyZW50LCBqID0gaTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHBvaW50IHRvIHJlbW92ZS5cbiAgd2hpbGUgKG5vZGUuZGF0YSAhPT0gZCkgaWYgKCEocHJldmlvdXMgPSBub2RlLCBub2RlID0gbm9kZS5uZXh0KSkgcmV0dXJuIHRoaXM7XG4gIGlmIChuZXh0ID0gbm9kZS5uZXh0KSBkZWxldGUgbm9kZS5uZXh0O1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb2luY2lkZW50IHBvaW50cywgcmVtb3ZlIGp1c3QgdGhlIHBvaW50LlxuICBpZiAocHJldmlvdXMpIHJldHVybiAobmV4dCA/IHByZXZpb3VzLm5leHQgPSBuZXh0IDogZGVsZXRlIHByZXZpb3VzLm5leHQpLCB0aGlzO1xuXG4gIC8vIElmIHRoaXMgaXMgdGhlIHJvb3QgcG9pbnQsIHJlbW92ZSBpdC5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiB0aGlzLl9yb290ID0gbmV4dCwgdGhpcztcblxuICAvLyBSZW1vdmUgdGhpcyBsZWFmLlxuICBuZXh0ID8gcGFyZW50W2ldID0gbmV4dCA6IGRlbGV0ZSBwYXJlbnRbaV07XG5cbiAgLy8gSWYgdGhlIHBhcmVudCBub3cgY29udGFpbnMgZXhhY3RseSBvbmUgbGVhZiwgY29sbGFwc2Ugc3VwZXJmbHVvdXMgcGFyZW50cy5cbiAgaWYgKChub2RlID0gcGFyZW50WzBdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzNdKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFszXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFswXSlcbiAgICAgICYmICFub2RlLmxlbmd0aCkge1xuICAgIGlmIChyZXRhaW5lcikgcmV0YWluZXJbal0gPSBub2RlO1xuICAgIGVsc2UgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbChkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHRoaXMucmVtb3ZlKGRhdGFbaV0pO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcm9vdDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvICsrc2l6ZTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIHEsIG5vZGUgPSB0aGlzLl9yb290LCBjaGlsZCwgeDAsIHkwLCB4MSwgeTE7XG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICBpZiAoIWNhbGxiYWNrKG5vZGUgPSBxLm5vZGUsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSkgJiYgbm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgcXVhZHMucHVzaChuZXcgUXVhZCh0aGlzLl9yb290LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgdmFyIG5vZGUgPSBxLm5vZGU7XG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgIH1cbiAgICBuZXh0LnB1c2gocSk7XG4gIH1cbiAgd2hpbGUgKHEgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLngxLCBxLnkxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xuICByZXR1cm4gZFsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gXywgdGhpcykgOiB0aGlzLl95O1xufVxuIiwiaW1wb3J0IGNvbG9ycyBmcm9tIFwiLi4vY29sb3JzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9ycyhcIjhkZDNjN2ZmZmZiM2JlYmFkYWZiODA3MjgwYjFkM2ZkYjQ2MmIzZGU2OWZjY2RlNWQ5ZDlkOWJjODBiZGNjZWJjNWZmZWQ2ZlwiKTtcbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4uL2NvbG9ycy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjb2xvcnMoXCIxZjc3YjRmZjdmMGUyY2EwMmNkNjI3Mjg5NDY3YmQ4YzU2NGJlMzc3YzI3ZjdmN2ZiY2JkMjIxN2JlY2ZcIik7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgdmFyIG4gPSBzcGVjaWZpZXIubGVuZ3RoIC8gNiB8IDAsIGNvbG9ycyA9IG5ldyBBcnJheShuKSwgaSA9IDA7XG4gIHdoaWxlIChpIDwgbikgY29sb3JzW2ldID0gXCIjXCIgKyBzcGVjaWZpZXIuc2xpY2UoaSAqIDYsICsraSAqIDYpO1xuICByZXR1cm4gY29sb3JzO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVJnYkJhc2lzfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgc2NoZW1lID0+IGludGVycG9sYXRlUmdiQmFzaXMoc2NoZW1lW3NjaGVtZS5sZW5ndGggLSAxXSk7XG4iLCJpbXBvcnQgY29sb3JzIGZyb20gXCIuLi9jb2xvcnMuanNcIjtcbmltcG9ydCByYW1wIGZyb20gXCIuLi9yYW1wLmpzXCI7XG5cbmV4cG9ydCB2YXIgc2NoZW1lID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmZWU4YzhmZGJiODRlMzRhMzNcIixcbiAgXCJmZWYwZDlmZGNjOGFmYzhkNTlkNzMwMWZcIixcbiAgXCJmZWYwZDlmZGNjOGFmYzhkNTllMzRhMzNiMzAwMDBcIixcbiAgXCJmZWYwZDlmZGQ0OWVmZGJiODRmYzhkNTllMzRhMzNiMzAwMDBcIixcbiAgXCJmZWYwZDlmZGQ0OWVmZGJiODRmYzhkNTllZjY1NDhkNzMwMWY5OTAwMDBcIixcbiAgXCJmZmY3ZWNmZWU4YzhmZGQ0OWVmZGJiODRmYzhkNTllZjY1NDhkNzMwMWY5OTAwMDBcIixcbiAgXCJmZmY3ZWNmZWU4YzhmZGQ0OWVmZGJiODRmYzhkNTllZjY1NDhkNzMwMWZiMzAwMDA3ZjAwMDBcIlxuKS5tYXAoY29sb3JzKTtcblxuZXhwb3J0IGRlZmF1bHQgcmFtcChzY2hlbWUpO1xuIiwiaW1wb3J0IGNvbG9ycyBmcm9tIFwiLi4vY29sb3JzLmpzXCI7XG5pbXBvcnQgcmFtcCBmcm9tIFwiLi4vcmFtcC5qc1wiO1xuXG5leHBvcnQgdmFyIHNjaGVtZSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWRmOGIxN2ZjZGJiMmM3ZmI4XCIsXG4gIFwiZmZmZmNjYTFkYWI0NDFiNmM0MjI1ZWE4XCIsXG4gIFwiZmZmZmNjYTFkYWI0NDFiNmM0MmM3ZmI4MjUzNDk0XCIsXG4gIFwiZmZmZmNjYzdlOWI0N2ZjZGJiNDFiNmM0MmM3ZmI4MjUzNDk0XCIsXG4gIFwiZmZmZmNjYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MGMyYzg0XCIsXG4gIFwiZmZmZmQ5ZWRmOGIxYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MGMyYzg0XCIsXG4gIFwiZmZmZmQ5ZWRmOGIxYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MjUzNDk0MDgxZDU4XCJcbikubWFwKGNvbG9ycyk7XG5cbmV4cG9ydCBkZWZhdWx0IHJhbXAoc2NoZW1lKTtcbiIsImltcG9ydCB7cmFuZ2UgYXMgc2VxdWVuY2V9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcbmltcG9ydCBvcmRpbmFsIGZyb20gXCIuL29yZGluYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFuZCgpIHtcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgcjAgPSAwLFxuICAgICAgcjEgPSAxLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByMSA8IHIwLFxuICAgICAgICBzdGFydCA9IHJldmVyc2UgPyByMSA6IHIwLFxuICAgICAgICBzdG9wID0gcmV2ZXJzZSA/IHIwIDogcjE7XG4gICAgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMSwgbiAtIHBhZGRpbmdJbm5lciArIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgIGlmIChyb3VuZCkgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgc3RhcnQgKz0gKHN0b3AgLSBzdGFydCAtIHN0ZXAgKiAobiAtIHBhZGRpbmdJbm5lcikpICogYWxpZ247XG4gICAgYmFuZHdpZHRoID0gc3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgICBpZiAocm91bmQpIHN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCksIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB2YXIgdmFsdWVzID0gc2VxdWVuY2UobikubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIHN0YXJ0ICsgc3RlcCAqIGk7IH0pO1xuICAgIHJldHVybiBvcmRpbmFsUmFuZ2UocmV2ZXJzZSA/IHZhbHVlcy5yZXZlcnNlKCkgOiB2YWx1ZXMpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFtyMCwgcjFdID0gXywgcjAgPSArcjAsIHIxID0gK3IxLCByZXNjYWxlKCkpIDogW3IwLCByMV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gW3IwLCByMV0gPSBfLCByMCA9ICtyMCwgcjEgPSArcjEsIHJvdW5kID0gdHJ1ZSwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmJhbmR3aWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kd2lkdGg7XG4gIH07XG5cbiAgc2NhbGUuc3RlcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzdGVwO1xuICB9O1xuXG4gIHNjYWxlLnJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISFfLCByZXNjYWxlKCkpIDogcm91bmQ7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbigxLCBwYWRkaW5nT3V0ZXIgPSArXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ0lubmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIF8pLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nT3V0ZXIgPSArXywgcmVzY2FsZSgpKSA6IHBhZGRpbmdPdXRlcjtcbiAgfTtcblxuICBzY2FsZS5hbGlnbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbGlnbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IGFsaWduO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZChkb21haW4oKSwgW3IwLCByMV0pXG4gICAgICAgIC5yb3VuZChyb3VuZClcbiAgICAgICAgLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpXG4gICAgICAgIC5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKVxuICAgICAgICAuYWxpZ24oYWxpZ24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkocmVzY2FsZSgpLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBwb2ludGlzaChzY2FsZSkge1xuICB2YXIgY29weSA9IHNjYWxlLmNvcHk7XG5cbiAgc2NhbGUucGFkZGluZyA9IHNjYWxlLnBhZGRpbmdPdXRlcjtcbiAgZGVsZXRlIHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgZGVsZXRlIHNjYWxlLnBhZGRpbmdPdXRlcjtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBvaW50aXNoKGNvcHkoKSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHJldHVybiBwb2ludGlzaChiYW5kLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFkZGluZ0lubmVyKDEpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnN0YW50cyh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGEsIGIpIHtcbiAgdmFyIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBiaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCk7XG4gICAgaWYgKGNsYW1wICE9PSBpZGVudGl0eSkgY2xhbXAgPSBjbGFtcGVyKGRvbWFpblswXSwgZG9tYWluW24gLSAxXSk7XG4gICAgcGllY2V3aXNlID0gbiA+IDIgPyBwb2x5bWFwIDogYmltYXA7XG4gICAgb3V0cHV0ID0gaW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKG91dHB1dCB8fCAob3V0cHV0ID0gcGllY2V3aXNlKGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgcmFuZ2UsIGludGVycG9sYXRlKSkpKHRyYW5zZm9ybShjbGFtcCh4KSkpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBjbGFtcCh1bnRyYW5zZm9ybSgoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlLCBkb21haW4ubWFwKHRyYW5zZm9ybSksIGludGVycG9sYXRlTnVtYmVyKSkpKHkpKSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IEFycmF5LmZyb20oXywgbnVtYmVyKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9IF8gPyB0cnVlIDogaWRlbnRpdHksIHJlc2NhbGUoKSkgOiBjbGFtcCAhPT0gaWRlbnRpdHk7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCwgdSkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHVudHJhbnNmb3JtID0gdTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250aW51b3VzKCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoKShpZGVudGl0eSwgaWRlbnRpdHkpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHtcbiAgICAgIGlmICh0eXBlb2YgZG9tYWluID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7XG4gICAgICBlbHNlIHRoaXMucmFuZ2UoZG9tYWluKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aGlzLmRvbWFpbihkb21haW4pO1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcnBvbGF0b3IgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yKTtcbiAgICAgIGVsc2UgdGhpcy5yYW5nZShpbnRlcnBvbGF0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IHt0aWNrcywgdGlja0luY3JlbWVudH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQgY29udGludW91cywge2NvcHl9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5pbXBvcnQgdGlja0Zvcm1hdCBmcm9tIFwiLi90aWNrRm9ybWF0LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJpc2goc2NhbGUpIHtcbiAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrRm9ybWF0KGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHZhciBpMCA9IDA7XG4gICAgdmFyIGkxID0gZC5sZW5ndGggLSAxO1xuICAgIHZhciBzdGFydCA9IGRbaTBdO1xuICAgIHZhciBzdG9wID0gZFtpMV07XG4gICAgdmFyIHByZXN0ZXA7XG4gICAgdmFyIHN0ZXA7XG4gICAgdmFyIG1heEl0ZXIgPSAxMDtcblxuICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gc3RlcDtcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xuICAgIH1cbiAgICBcbiAgICB3aGlsZSAobWF4SXRlci0tID4gMCkge1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICAgIGlmIChzdGVwID09PSBwcmVzdGVwKSB7XG4gICAgICAgIGRbaTBdID0gc3RhcnRcbiAgICAgICAgZFtpMV0gPSBzdG9wXG4gICAgICAgIHJldHVybiBkb21haW4oZCk7XG4gICAgICB9IGVsc2UgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgc3RvcCA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcHJlc3RlcCA9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGluZWFyKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKCk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuIiwiaW1wb3J0IHtJbnRlcm5NYXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGNvbnN0IGltcGxpY2l0ID0gU3ltYm9sKFwiaW1wbGljaXRcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGluYWwoKSB7XG4gIHZhciBpbmRleCA9IG5ldyBJbnRlcm5NYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgbGV0IGkgPSBpbmRleC5nZXQoZCk7XG4gICAgaWYgKGkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChkLCBpID0gZG9tYWluLnB1c2goZCkgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlW2kgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG5ldyBJbnRlcm5NYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIF8pIHtcbiAgICAgIGlmIChpbmRleC5oYXModmFsdWUpKSBjb250aW51ZTtcbiAgICAgIGluZGV4LnNldCh2YWx1ZSwgZG9tYWluLnB1c2godmFsdWUpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9yZGluYWwoZG9tYWluLCByYW5nZSkudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtjb3B5LCBpZGVudGl0eSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93aXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGV4cG9uZW50ID0gMTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHJldHVybiBleHBvbmVudCA9PT0gMSA/IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpXG4gICAgICAgIDogZXhwb25lbnQgPT09IDAuNSA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TcXJ0LCB0cmFuc2Zvcm1TcXVhcmUpXG4gICAgICAgIDogdHJhbnNmb3JtKHRyYW5zZm9ybVBvdyhleHBvbmVudCksIHRyYW5zZm9ybVBvdygxIC8gZXhwb25lbnQpKTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIHJlc2NhbGUoKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGVTb3J0ZWQgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdGhyZXNob2xkcyA9IFtdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gdGhyZXNob2xkKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAobGV0IGQgb2YgXykgaWYgKGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgZG9tYWluLnNvcnQoYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkcy5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpbGUoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHggPD0geCA/IHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXSA6IHVua25vd247XG4gIH1cblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgZG9tYWluID0gbmV3IEFycmF5KG4pO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkb21haW5baV0gPSAoKGkgKyAxKSAqIHgxIC0gKGkgLSBuKSAqIHgwKSAvIChuICsgMSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFt4MCwgeDFdID0gXywgeDAgPSAreDAsIHgxID0gK3gxLCByZXNjYWxlKCkpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IChyYW5nZSA9IEFycmF5LmZyb20oXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnRocmVzaG9sZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGl6ZSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShsaW5lYXJpc2goc2NhbGUpLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICB2YXIgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd24sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IEFycmF5LmZyb20oXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0LCBmb3JtYXRQcmVmaXgsIGZvcm1hdFNwZWNpZmllciwgcHJlY2lzaW9uRml4ZWQsIHByZWNpc2lvblByZWZpeCwgcHJlY2lzaW9uUm91bmR9IGZyb20gXCJkMy1mb3JtYXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGlja0Zvcm1hdChzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICB2YXIgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCksXG4gICAgICBwcmVjaXNpb247XG4gIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XG4gIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICBjYXNlIFwic1wiOiB7XG4gICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgcmV0dXJuIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgY2FzZSBcIlwiOlxuICAgIGNhc2UgXCJlXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJyXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZlwiOlxuICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvbkZpeGVkKHN0ZXApKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCIlXCIpICogMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHNwZWNpZmllcik7XG59XG4iLCIvLyBHaXZlbiBzb21ldGhpbmcgYXJyYXkgbGlrZSAob3IgbnVsbCksIHJldHVybnMgc29tZXRoaW5nIHRoYXQgaXMgc3RyaWN0bHkgYW5cbi8vIGFycmF5LiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYXJyYXktbGlrZSBvYmplY3RzIHBhc3NlZCB0byBkMy5zZWxlY3RBbGxcbi8vIG9yIHNlbGVjdGlvbi5zZWxlY3RBbGwgYXJlIGNvbnZlcnRlZCBpbnRvIHByb3BlciBhcnJheXMgd2hlbiBjcmVhdGluZyBhXG4vLyBzZWxlY3Rpb247IHdlIGRvbuKAmXQgZXZlciB3YW50IHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBiYWNrZWQgYnkgYSBsaXZlXG4vLyBIVE1MQ29sbGVjdGlvbiBvciBOb2RlTGlzdC4gSG93ZXZlciwgbm90ZSB0aGF0IHNlbGVjdGlvbi5zZWxlY3RBbGwgd2lsbCB1c2UgYVxuLy8gc3RhdGljIE5vZGVMaXN0IGFzIGEgZ3JvdXAsIHNpbmNlIGl0IHNhZmVseSBkZXJpdmVkIGZyb20gcXVlcnlTZWxlY3RvckFsbC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFycmF5KHgpIHtcbiAgcmV0dXJuIHggPT0gbnVsbCA/IFtdIDogQXJyYXkuaXNBcnJheSh4KSA/IHggOiBBcnJheS5mcm9tKHgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi9jcmVhdG9yLmpzXCI7XG5pbXBvcnQgc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3QoY3JlYXRvcihuYW1lKS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2UuanNcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkTWF0Y2hlcihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG4iLCJpbXBvcnQgbmFtZXNwYWNlcyBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG59XG4iLCJleHBvcnQgdmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQsIG5vZGUpIHtcbiAgZXZlbnQgPSBzb3VyY2VFdmVudChldmVudCk7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAobm9kZSkge1xuICAgIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtldmVudC5wYWdlWCwgZXZlbnQucGFnZVldO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbYXJyYXkoc2VsZWN0b3IpXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi4vbmFtZXNwYWNlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cbiIsImZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUodHJ1ZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7RW50ZXJOb2RlfSBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IG5ldyBNYXAsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApICsgXCJcIjtcbiAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUpKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKSArIFwiXCI7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUpKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZS5kZWxldGUoa2V5VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdHVtKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX19kYXRhX187XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLCBkYXR1bSk7XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gYXJyYXlsaWtlKHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG4vLyBHaXZlbiBzb21lIGRhdGEsIHRoaXMgcmV0dXJucyBhbiBhcnJheS1saWtlIHZpZXcgb2YgaXQ6IGFuIG9iamVjdCB0aGF0XG4vLyBleHBvc2VzIGEgbGVuZ3RoIHByb3BlcnR5IGFuZCBhbGxvd3MgbnVtZXJpYyBpbmRleGluZy4gTm90ZSB0aGF0IHVubGlrZVxuLy8gc2VsZWN0QWxsLCB0aGlzIGlzbuKAmXQgd29ycmllZCBhYm91dCDigJxsaXZl4oCdIGNvbGxlY3Rpb25zIGJlY2F1c2UgdGhlIHJlc3VsdGluZ1xuLy8gYXJyYXkgd2lsbCBvbmx5IGJlIHVzZWQgYnJpZWZseSB3aGlsZSBkYXRhIGlzIGJlaW5nIGJvdW5kLiAoSXQgaXMgcG9zc2libGUgdG9cbi8vIGNhdXNlIHRoZSBkYXRhIHRvIGNoYW5nZSB3aGlsZSBpdGVyYXRpbmcgYnkgdXNpbmcgYSBrZXkgZnVuY3Rpb24sIGJ1dCBwbGVhc2Vcbi8vIGRvbuKAmXQ7IHdl4oCZZCByYXRoZXIgYXZvaWQgYSBncmF0dWl0b3VzIGNvcHkuKVxuZnVuY3Rpb24gYXJyYXlsaWtlKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4gZGF0YVxuICAgID8gZGF0YSAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oZGF0YSk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQgZnJvbSBcIi4vc2VsZWN0Q2hpbGQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4gZnJvbSBcIi4vc2VsZWN0Q2hpbGRyZW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pdGVyYXRvciBmcm9tIFwiLi9pdGVyYXRvci5qc1wiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBqb2luOiBzZWxlY3Rpb25fam9pbixcbiAgbWVyZ2U6IHNlbGVjdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiBzZWxlY3Rpb25fc2VsZWN0aW9uLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX2l0ZXJhdG9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qKCkge1xuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9uZW50ZXIsIG9udXBkYXRlLCBvbmV4aXQpIHtcbiAgdmFyIGVudGVyID0gdGhpcy5lbnRlcigpLCB1cGRhdGUgPSB0aGlzLCBleGl0ID0gdGhpcy5leGl0KCk7XG4gIGlmICh0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZW50ZXIgPSBvbmVudGVyKGVudGVyKTtcbiAgICBpZiAoZW50ZXIpIGVudGVyID0gZW50ZXIuc2VsZWN0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgZW50ZXIgPSBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICB9XG4gIGlmIChvbnVwZGF0ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgICBpZiAodXBkYXRlKSB1cGRhdGUgPSB1cGRhdGUuc2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dDtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gc2VsZWN0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbiIsImZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCB0aGlzLl9fZGF0YV9fKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcih2YWx1ZSk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5vcHRpb25zID0gb3B0aW9ucyk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIG9wdGlvbnM6IG9wdGlvbnN9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5leHQpIF4gNCkgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn1cbiIsImZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IGFycmF5IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yQWxsIGZyb20gXCIuLi9zZWxlY3RvckFsbC5qc1wiO1xuXG5mdW5jdGlvbiBhcnJheUFsbChzZWxlY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcnJheShzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBhcnJheUFsbChzZWxlY3QpO1xuICBlbHNlIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbmQgPSBBcnJheS5wcm90b3R5cGUuZmluZDtcblxuZnVuY3Rpb24gY2hpbGRGaW5kKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmluZC5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRGaXJzdCgpIHtcbiAgcmV0dXJuIHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChtYXRjaCA9PSBudWxsID8gY2hpbGRGaXJzdFxuICAgICAgOiBjaGlsZEZpbmQodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcblxuZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjaGlsZHJlbkZpbHRlcihtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKG1hdGNoID09IG51bGwgPyBjaGlsZHJlblxuICAgICAgOiBjaGlsZHJlbkZpbHRlcih0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpICsrc2l6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGxldCBzb3VyY2VFdmVudDtcbiAgd2hpbGUgKHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQpIGV2ZW50ID0gc291cmNlRXZlbnQ7XG4gIHJldHVybiBldmVudDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YWJzLCBhY29zLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIG1heCwgbWluLCBwaSwgc2luLCBzcXJ0LCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcbmltcG9ydCB7d2l0aFBhdGh9IGZyb20gXCIuL3BhdGguanNcIjtcblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9IHkzMiAqIHgxMCAtIHgzMiAqIHkxMDtcbiAgaWYgKHQgKiB0IDwgZXBzaWxvbikgcmV0dXJuO1xuICB0ID0gKHgzMiAqICh5MCAtIHkyKSAtIHkzMiAqICh4MCAtIHgyKSkgLyB0O1xuICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbn1cblxuLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY29ybmVyVGFuZ2VudHMoeDAsIHkwLCB4MSwgeTEsIHIxLCByYywgY3cpIHtcbiAgdmFyIHgwMSA9IHgwIC0geDEsXG4gICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBzcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksXG4gICAgICBveCA9IGxvICogeTAxLFxuICAgICAgb3kgPSAtbG8gKiB4MDEsXG4gICAgICB4MTEgPSB4MCArIG94LFxuICAgICAgeTExID0geTAgKyBveSxcbiAgICAgIHgxMCA9IHgxICsgb3gsXG4gICAgICB5MTAgPSB5MSArIG95LFxuICAgICAgeDAwID0gKHgxMSArIHgxMCkgLyAyLFxuICAgICAgeTAwID0gKHkxMSArIHkxMCkgLyAyLFxuICAgICAgZHggPSB4MTAgLSB4MTEsXG4gICAgICBkeSA9IHkxMCAtIHkxMSxcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICByID0gcjEgLSByYyxcbiAgICAgIEQgPSB4MTEgKiB5MTAgLSB4MTAgKiB5MTEsXG4gICAgICBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBzcXJ0KG1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSxcbiAgICAgIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMixcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMixcbiAgICAgIGR4MCA9IGN4MCAtIHgwMCxcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcbiAgICAgIGR4MSA9IGN4MSAtIHgwMCxcbiAgICAgIGR5MSA9IGN5MSAtIHkwMDtcblxuICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBhcmNPdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvbnN0YW50KDApLFxuICAgICAgcGFkUmFkaXVzID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBhcmNTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBhcmNFbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChhcmMpO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IGFicyhhMSAtIGEwKSxcbiAgICAgICAgY3cgPSBhMSA+IGEwO1xuXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIG91dGVyIHJhZGl1cyBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIHJhZGl1cy5cbiAgICBpZiAocjEgPCByMCkgciA9IHIxLCByMSA9IHIwLCByMCA9IHI7XG5cbiAgICAvLyBJcyBpdCBhIHBvaW50P1xuICAgIGlmICghKHIxID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKDAsIDApO1xuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjbGUgb3IgYW5udWx1cz9cbiAgICBlbHNlIGlmIChkYSA+IHRhdSAtIGVwc2lsb24pIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHIxICogY29zKGEwKSwgcjEgKiBzaW4oYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogY29zKGExKSwgcjAgKiBzaW4oYTEpKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExLCBhMCwgY3cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY3VsYXIgb3IgYW5udWxhciBzZWN0b3I/XG4gICAgZWxzZSB7XG4gICAgICB2YXIgYTAxID0gYTAsXG4gICAgICAgICAgYTExID0gYTEsXG4gICAgICAgICAgYTAwID0gYTAsXG4gICAgICAgICAgYTEwID0gYTEsXG4gICAgICAgICAgZGEwID0gZGEsXG4gICAgICAgICAgZGExID0gZGEsXG4gICAgICAgICAgYXAgPSBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC8gMixcbiAgICAgICAgICBycCA9IChhcCA+IGVwc2lsb24pICYmIChwYWRSYWRpdXMgPyArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBtaW4oYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgICByYzAgPSByYyxcbiAgICAgICAgICByYzEgPSByYyxcbiAgICAgICAgICB0MCxcbiAgICAgICAgICB0MTtcblxuICAgICAgLy8gQXBwbHkgcGFkZGluZz8gTm90ZSB0aGF0IHNpbmNlIHIxIOKJpSByMCwgZGExIOKJpSBkYTAuXG4gICAgICBpZiAocnAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciBwMCA9IGFzaW4ocnAgLyByMCAqIHNpbihhcCkpLFxuICAgICAgICAgICAgcDEgPSBhc2luKHJwIC8gcjEgKiBzaW4oYXApKTtcbiAgICAgICAgaWYgKChkYTAgLT0gcDAgKiAyKSA+IGVwc2lsb24pIHAwICo9IChjdyA/IDEgOiAtMSksIGEwMCArPSBwMCwgYTEwIC09IHAwO1xuICAgICAgICBlbHNlIGRhMCA9IDAsIGEwMCA9IGExMCA9IChhMCArIGExKSAvIDI7XG4gICAgICAgIGlmICgoZGExIC09IHAxICogMikgPiBlcHNpbG9uKSBwMSAqPSAoY3cgPyAxIDogLTEpLCBhMDEgKz0gcDEsIGExMSAtPSBwMTtcbiAgICAgICAgZWxzZSBkYTEgPSAwLCBhMDEgPSBhMTEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDAxID0gcjEgKiBjb3MoYTAxKSxcbiAgICAgICAgICB5MDEgPSByMSAqIHNpbihhMDEpLFxuICAgICAgICAgIHgxMCA9IHIwICogY29zKGExMCksXG4gICAgICAgICAgeTEwID0gcjAgKiBzaW4oYTEwKTtcblxuICAgICAgLy8gQXBwbHkgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgaWYgKHJjID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgeDExID0gcjEgKiBjb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogc2luKGExMSksXG4gICAgICAgICAgICB4MDAgPSByMCAqIGNvcyhhMDApLFxuICAgICAgICAgICAgeTAwID0gcjAgKiBzaW4oYTAwKSxcbiAgICAgICAgICAgIG9jO1xuXG4gICAgICAgIC8vIFJlc3RyaWN0IHRoZSBjb3JuZXIgcmFkaXVzIGFjY29yZGluZyB0byB0aGUgc2VjdG9yIGFuZ2xlLiBJZiB0aGlzXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBmYWlscywgaXTigJlzIHByb2JhYmx5IGJlY2F1c2UgdGhlIGFyYyBpcyB0b28gc21hbGwsIHNvXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGNvcm5lciByYWRpdXMgZW50aXJlbHkuXG4gICAgICAgIGlmIChkYSA8IHBpKSB7XG4gICAgICAgICAgaWYgKG9jID0gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSkge1xuICAgICAgICAgICAgdmFyIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgICAgYXkgPSB5MDEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgICBieCA9IHgxMSAtIG9jWzBdLFxuICAgICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgICAga2MgPSAxIC8gc2luKGFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChzcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIHNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgICBsYyA9IHNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgICAgcmMwID0gbWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgICByYzEgPSBtaW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmMwID0gcmMxID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSXMgdGhlIHNlY3RvciBjb2xsYXBzZWQgdG8gYSBsaW5lP1xuICAgICAgaWYgKCEoZGExID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzEgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgaW5uZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEwLCBhMDAsIGN3KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsXG4gICAgICAgIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBwaSAvIDI7XG4gICAgcmV0dXJuIFtjb3MoYSkgKiByLCBzaW4oYSkgKiByXTtcbiAgfTtcblxuICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW5uZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGlubmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvdXRlclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogb3V0ZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZFJhZGl1cyA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZFJhZGl1cztcbiAgfTtcblxuICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRBbmdsZTtcbiAgfTtcblxuICBhcmMuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgYXJjKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyYztcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyLmpzXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeDAsIHkwLCB5MSkge1xuICB2YXIgeDEgPSBudWxsLFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChhcmVhKTtcblxuICB4MCA9IHR5cGVvZiB4MCA9PT0gXCJmdW5jdGlvblwiID8geDAgOiAoeDAgPT09IHVuZGVmaW5lZCkgPyBwb2ludFggOiBjb25zdGFudCgreDApO1xuICB5MCA9IHR5cGVvZiB5MCA9PT0gXCJmdW5jdGlvblwiID8geTAgOiAoeTAgPT09IHVuZGVmaW5lZCkgPyBjb25zdGFudCgwKSA6IGNvbnN0YW50KCt5MCk7XG4gIHkxID0gdHlwZW9mIHkxID09PSBcImZ1bmN0aW9uXCIgPyB5MSA6ICh5MSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WSA6IGNvbnN0YW50KCt5MSk7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSAoZGF0YSA9IGFycmF5KGRhdGEpKS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgeDB6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7XG4gICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFTdGFydCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGsgPSBpIC0gMTsgayA+PSBqOyAtLWspIHtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MHpba10sIHkweltrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSB7XG4gICAgICAgIHgweltpXSA9ICt4MChkLCBpLCBkYXRhKSwgeTB6W2ldID0gK3kwKGQsIGksIGRhdGEpO1xuICAgICAgICBvdXRwdXQucG9pbnQoeDEgPyAreDEoZCwgaSwgZGF0YSkgOiB4MHpbaV0sIHkxID8gK3kxKGQsIGksIGRhdGEpIDogeTB6W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlYWxpbmUoKSB7XG4gICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHgxID0gbnVsbCwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MTtcbiAgfTtcblxuICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeTEgPSBudWxsLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkxO1xuICB9O1xuXG4gIGFyZWEubGluZVgwID1cbiAgYXJlYS5saW5lWTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmxpbmVZMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xuICB9O1xuXG4gIGFyZWEubGluZVgxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MSkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGFyZWEpIDogZGVmaW5lZDtcbiAgfTtcblxuICBhcmVhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XG4gIH07XG5cbiAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBhcmVhKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyZWE7XG59XG4iLCJleHBvcnQgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIHhcbiAgICA/IHggLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKHgpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgcG9pbnRSYWRpYWwgZnJvbSBcIi4uL3BvaW50UmFkaWFsLmpzXCI7XG5cbmNsYXNzIEJ1bXAge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCB4KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5feCA9IHg7XG4gIH1cbiAgYXJlYVN0YXJ0KCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9XG4gIGFyZWFFbmQoKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfVxuICBsaW5lU3RhcnQoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9XG4gIGxpbmVFbmQoKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfVxuICBwb2ludCh4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmUpIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICBlbHNlIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl94KSB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8odGhpcy5feDAgPSAodGhpcy5feDAgKyB4KSAvIDIsIHRoaXMuX3kwLCB0aGlzLl94MCwgeSwgeCwgeSk7XG4gICAgICAgIGVsc2UgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHRoaXMuX3gwLCB0aGlzLl95MCA9ICh0aGlzLl95MCArIHkpIC8gMiwgeCwgdGhpcy5feTAsIHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feDAgPSB4LCB0aGlzLl95MCA9IHk7XG4gIH1cbn1cblxuY2xhc3MgQnVtcFJhZGlhbCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICBsaW5lU3RhcnQoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9XG4gIGxpbmVFbmQoKSB7fVxuICBwb2ludCh4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHRoaXMuX3BvaW50ID09PSAwKSB7XG4gICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHAwID0gcG9pbnRSYWRpYWwodGhpcy5feDAsIHRoaXMuX3kwKTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRSYWRpYWwodGhpcy5feDAsIHRoaXMuX3kwID0gKHRoaXMuX3kwICsgeSkgLyAyKTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRSYWRpYWwoeCwgdGhpcy5feTApO1xuICAgICAgY29uc3QgcDMgPSBwb2ludFJhZGlhbCh4LCB5KTtcbiAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKC4uLnAwKTtcbiAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyguLi5wMSwgLi4ucDIsIC4uLnAzKTtcbiAgICB9XG4gICAgdGhpcy5feDAgPSB4LCB0aGlzLl95MCA9IHk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXBYKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCdW1wKGNvbnRleHQsIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVtcFkoY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJ1bXAoY29udGV4dCwgZmFsc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVtcFJhZGlhbChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQnVtcFJhZGlhbChjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgcmV0dXJuIGQ7XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhci5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgobGluZSk7XG5cbiAgeCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogKHggPT09IHVuZGVmaW5lZCkgPyBwb2ludFggOiBjb25zdGFudCh4KTtcbiAgeSA9IHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5IDogKHkgPT09IHVuZGVmaW5lZCkgPyBwb2ludFkgOiBjb25zdGFudCh5KTtcblxuICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IChkYXRhID0gYXJyYXkoZGF0YSkpLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIG91dHB1dC5wb2ludCgreChkLCBpLCBkYXRhKSwgK3koZCwgaSwgZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHg7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5O1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuIiwiaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHtidW1wWCwgYnVtcFksIGJ1bXBSYWRpYWx9IGZyb20gXCIuL2N1cnZlL2J1bXAuanNcIjtcbmltcG9ydCB7d2l0aFBhdGh9IGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5rU291cmNlKGQpIHtcbiAgcmV0dXJuIGQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBsaW5rVGFyZ2V0KGQpIHtcbiAgcmV0dXJuIGQudGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluayhjdXJ2ZSkge1xuICBsZXQgc291cmNlID0gbGlua1NvdXJjZSxcbiAgICAgIHRhcmdldCA9IGxpbmtUYXJnZXQsXG4gICAgICB4ID0gcG9pbnRYLFxuICAgICAgeSA9IHBvaW50WSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgb3V0cHV0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChsaW5rKTtcblxuICBmdW5jdGlvbiBsaW5rKCkge1xuICAgIGxldCBidWZmZXI7XG4gICAgY29uc3QgYXJndiA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBzID0gc291cmNlLmFwcGx5KHRoaXMsIGFyZ3YpO1xuICAgIGNvbnN0IHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJndik7XG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcbiAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgYXJndlswXSA9IHMsIG91dHB1dC5wb2ludCgreC5hcHBseSh0aGlzLCBhcmd2KSwgK3kuYXBwbHkodGhpcywgYXJndikpO1xuICAgIGFyZ3ZbMF0gPSB0LCBvdXRwdXQucG9pbnQoK3guYXBwbHkodGhpcywgYXJndiksICt5LmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5rLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3VyY2UgPSBfLCBsaW5rKSA6IHNvdXJjZTtcbiAgfTtcblxuICBsaW5rLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXJnZXQgPSBfLCBsaW5rKSA6IHRhcmdldDtcbiAgfTtcblxuICBsaW5rLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHg7XG4gIH07XG5cbiAgbGluay55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluaykgOiB5O1xuICB9O1xuXG4gIGxpbmsuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluaykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5rO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlua0hvcml6b250YWwoKSB7XG4gIHJldHVybiBsaW5rKGJ1bXBYKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmtWZXJ0aWNhbCgpIHtcbiAgcmV0dXJuIGxpbmsoYnVtcFkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlua1JhZGlhbCgpIHtcbiAgY29uc3QgbCA9IGxpbmsoYnVtcFJhZGlhbCk7XG4gIGwuYW5nbGUgPSBsLngsIGRlbGV0ZSBsLng7XG4gIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xuICByZXR1cm4gbDtcbn1cbiIsImV4cG9ydCBjb25zdCBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCBjb25zdCBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgY29uc3QgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgY29uc3QgbWluID0gTWF0aC5taW47XG5leHBvcnQgY29uc3Qgc2luID0gTWF0aC5zaW47XG5leHBvcnQgY29uc3Qgc3FydCA9IE1hdGguc3FydDtcblxuZXhwb3J0IGNvbnN0IGVwc2lsb24gPSAxZS0xMjtcbmV4cG9ydCBjb25zdCBwaSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IGNvbnN0IHRhdSA9IDIgKiBwaTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPj0gMSA/IGhhbGZQaSA6IHggPD0gLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuIiwiaW1wb3J0IHtQYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gd2l0aFBhdGgoc2hhcGUpIHtcbiAgbGV0IGRpZ2l0cyA9IDM7XG5cbiAgc2hhcGUuZGlnaXRzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpZ2l0cztcbiAgICBpZiAoXyA9PSBudWxsKSB7XG4gICAgICBkaWdpdHMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkID0gTWF0aC5mbG9vcihfKTtcbiAgICAgIGlmICghKGQgPj0gMCkpIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGRpZ2l0czogJHtffWApO1xuICAgICAgZGlnaXRzID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHJldHVybiAoKSA9PiBuZXcgUGF0aChkaWdpdHMpO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmcuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHt0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsXG4gICAgICBzb3J0ID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSxcbiAgICAgIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSxcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQoMCk7XG5cbiAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IChkYXRhID0gYXJyYXkoZGF0YSkpLmxlbmd0aCxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGFyY3MgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUsIE1hdGgubWF4KC10YXUsIGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBhMCkpLFxuICAgICAgICBhMSxcbiAgICAgICAgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sIHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgdjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodiA9IGFyY3NbaW5kZXhbaV0gPSBpXSA9ICt2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKSkgPiAwKSB7XG4gICAgICAgIHN1bSArPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGlvbmFsbHkgc29ydCB0aGUgYXJjcyBieSBwcmV2aW91c2x5LWNvbXB1dGVkIHZhbHVlcyBvciBieSBkYXRhLlxuICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7XG4gICAgZWxzZSBpZiAoc29ydCAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7IH0pO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXG4gICAgZm9yIChpID0gMCwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwOyBpIDwgbjsgKytpLCBhMCA9IGExKSB7XG4gICAgICBqID0gaW5kZXhbaV0sIHYgPSBhcmNzW2pdLCBhMSA9IGEwICsgKHYgPiAwID8gdiAqIGsgOiAwKSArIHBhLCBhcmNzW2pdID0ge1xuICAgICAgICBkYXRhOiBkYXRhW2pdLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBhcmNzO1xuICB9XG5cbiAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiB2YWx1ZTtcbiAgfTtcblxuICBwaWUuc29ydFZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0VmFsdWVzID0gXywgc29ydCA9IG51bGwsIHBpZSkgOiBzb3J0VmFsdWVzO1xuICB9O1xuXG4gIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XG4gIH07XG5cbiAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgcmV0dXJuIHBpZTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiBbKHkgPSAreSkgKiBNYXRoLmNvcyh4IC09IE1hdGguUEkgLyAyKSwgeSAqIE1hdGguc2luKHgpXTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IGFzdGVyaXNrIGZyb20gXCIuL3N5bWJvbC9hc3Rlcmlzay5qc1wiO1xuaW1wb3J0IGNpcmNsZSBmcm9tIFwiLi9zeW1ib2wvY2lyY2xlLmpzXCI7XG5pbXBvcnQgY3Jvc3MgZnJvbSBcIi4vc3ltYm9sL2Nyb3NzLmpzXCI7XG5pbXBvcnQgZGlhbW9uZCBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZC5qc1wiO1xuaW1wb3J0IGRpYW1vbmQyIGZyb20gXCIuL3N5bWJvbC9kaWFtb25kMi5qc1wiO1xuaW1wb3J0IHBsdXMgZnJvbSBcIi4vc3ltYm9sL3BsdXMuanNcIjtcbmltcG9ydCBzcXVhcmUgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZS5qc1wiO1xuaW1wb3J0IHNxdWFyZTIgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZTIuanNcIjtcbmltcG9ydCBzdGFyIGZyb20gXCIuL3N5bWJvbC9zdGFyLmpzXCI7XG5pbXBvcnQgdHJpYW5nbGUgZnJvbSBcIi4vc3ltYm9sL3RyaWFuZ2xlLmpzXCI7XG5pbXBvcnQgdHJpYW5nbGUyIGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZTIuanNcIjtcbmltcG9ydCB3eWUgZnJvbSBcIi4vc3ltYm9sL3d5ZS5qc1wiO1xuaW1wb3J0IHRpbWVzIGZyb20gXCIuL3N5bWJvbC90aW1lcy5qc1wiO1xuXG4vLyBUaGVzZSBzeW1ib2xzIGFyZSBkZXNpZ25lZCB0byBiZSBmaWxsZWQuXG5leHBvcnQgY29uc3Qgc3ltYm9sc0ZpbGwgPSBbXG4gIGNpcmNsZSxcbiAgY3Jvc3MsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxuLy8gVGhlc2Ugc3ltYm9scyBhcmUgZGVzaWduZWQgdG8gYmUgc3Ryb2tlZCAod2l0aCBhIHdpZHRoIG9mIDEuNXB4IGFuZCByb3VuZCBjYXBzKS5cbmV4cG9ydCBjb25zdCBzeW1ib2xzU3Ryb2tlID0gW1xuICBjaXJjbGUsXG4gIHBsdXMsXG4gIHRpbWVzLFxuICB0cmlhbmdsZTIsXG4gIGFzdGVyaXNrLFxuICBzcXVhcmUyLFxuICBkaWFtb25kMlxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3ltYm9sKHR5cGUsIHNpemUpIHtcbiAgbGV0IGNvbnRleHQgPSBudWxsLFxuICAgICAgcGF0aCA9IHdpdGhQYXRoKHN5bWJvbCk7XG5cbiAgdHlwZSA9IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgPyB0eXBlIDogY29uc3RhbnQodHlwZSB8fCBjaXJjbGUpO1xuICBzaXplID0gdHlwZW9mIHNpemUgPT09IFwiZnVuY3Rpb25cIiA/IHNpemUgOiBjb25zdGFudChzaXplID09PSB1bmRlZmluZWQgPyA2NCA6ICtzaXplKTtcblxuICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgbGV0IGJ1ZmZlcjtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG4gICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gIH07XG5cbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgfTtcblxuICBzeW1ib2wuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHN5bWJvbCkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBzeW1ib2w7XG59XG4iLCJpbXBvcnQge21pbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuY29uc3Qgc3FydDMgPSBzcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgKyBtaW4oc2l6ZSAvIDI4LCAwLjc1KSkgKiAwLjU5NDM2O1xuICAgIGNvbnN0IHQgPSByIC8gMjtcbiAgICBjb25zdCB1ID0gdCAqIHNxcnQzO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0Lm1vdmVUbygtdSwgLXQpO1xuICAgIGNvbnRleHQubGluZVRvKHUsIHQpO1xuICAgIGNvbnRleHQubW92ZVRvKC11LCB0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh1LCAtdCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3BpLCBzcXJ0LCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAvIHBpKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgY29udGV4dC5tb3ZlVG8oLTMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgY29udGV4dC5saW5lVG8oLTMgKiByLCByKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCB0YW4zMCA9IHNxcnQoMSAvIDMpO1xuY29uc3QgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCB5ID0gc3FydChzaXplIC8gdGFuMzBfMik7XG4gICAgY29uc3QgeCA9IHkgKiB0YW4zMDtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXgsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSkgKiAwLjYyNjI1O1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7bWluLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLSBtaW4oc2l6ZSAvIDcsIDIpKSAqIDAuODc1NTk7XG4gICAgY29udGV4dC5tb3ZlVG8oLXIsIDApO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDApO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKDAsIC1yKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCB3ID0gc3FydChzaXplKTtcbiAgICBjb25zdCB4ID0gLXcgLyAyO1xuICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplKSAqIDAuNDQzMTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c2luLCBjb3MsIHNxcnQsIHBpLCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmNvbnN0IGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMDtcbmNvbnN0IGtyID0gc2luKHBpIC8gMTApIC8gc2luKDcgKiBwaSAvIDEwKTtcbmNvbnN0IGt4ID0gc2luKHRhdSAvIDEwKSAqIGtyO1xuY29uc3Qga3kgPSAtY29zKHRhdSAvIDEwKSAqIGtyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgKiBrYSk7XG4gICAgY29uc3QgeCA9IGt4ICogcjtcbiAgICBjb25zdCB5ID0ga3kgKiByO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDU7ICsraSkge1xuICAgICAgY29uc3QgYSA9IHRhdSAqIGkgLyA1O1xuICAgICAgY29uc3QgYyA9IGNvcyhhKTtcbiAgICAgIGNvbnN0IHMgPSBzaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHttaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAtIG1pbihzaXplIC8gNiwgMS43KSkgKiAwLjYxODk7XG4gICAgY29udGV4dC5tb3ZlVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICBjb250ZXh0Lm1vdmVUbygtciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBzcXJ0MyA9IHNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgeSA9IC1zcXJ0KHNpemUgLyAoc3FydDMgKiAzKSk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBzcXJ0MyA9IHNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgcyA9IHNxcnQoc2l6ZSkgKiAwLjY4MjQ7XG4gICAgY29uc3QgdCA9IHMgIC8gMjtcbiAgICBjb25zdCB1ID0gKHMgKiBzcXJ0MykgLyAyOyAvLyBjb3MoTWF0aC5QSSAvIDYpXG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXMpO1xuICAgIGNvbnRleHQubGluZVRvKHUsIHQpO1xuICAgIGNvbnRleHQubGluZVRvKC11LCB0KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBjID0gLTAuNTtcbmNvbnN0IHMgPSBzcXJ0KDMpIC8gMjtcbmNvbnN0IGsgPSAxIC8gc3FydCgxMik7XG5jb25zdCBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLyBhKTtcbiAgICBjb25zdCB4MCA9IHIgLyAyLCB5MCA9IHIgKiBrO1xuICAgIGNvbnN0IHgxID0geDAsIHkxID0gciAqIGsgKyByO1xuICAgIGNvbnN0IHgyID0gLXgxLCB5MiA9IHkxO1xuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMgKiB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgKyBzICogeTEsIGMgKiB5MSAtIHMgKiB4MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBldmVudCwgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IGFyYywgY3VydmVDYXRtdWxsUm9tLCBjdXJ2ZUxpbmVhciwgbGluZSB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IGRpc3BhdGNoIH0gZnJvbSAnZDMtZGlzcGF0Y2gnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG52YXIgQW5ub3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5ub3RhdGlvbihfcmVmKSB7XG4gICAgdmFyIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgICAgeCA9IF9yZWYkeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeCxcbiAgICAgICAgX3JlZiR5ID0gX3JlZi55LFxuICAgICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgICBueCA9IF9yZWYubngsXG4gICAgICAgIG55ID0gX3JlZi5ueSxcbiAgICAgICAgX3JlZiRkeSA9IF9yZWYuZHksXG4gICAgICAgIGR5ID0gX3JlZiRkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkZHksXG4gICAgICAgIF9yZWYkZHggPSBfcmVmLmR4LFxuICAgICAgICBkeCA9IF9yZWYkZHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGR4LFxuICAgICAgICBfcmVmJGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgICAgY29sb3IgPSBfcmVmJGNvbG9yID09PSB1bmRlZmluZWQgPyBcImdyZXlcIiA6IF9yZWYkY29sb3IsXG4gICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgIHN1YmplY3QgPSBfcmVmLnN1YmplY3QsXG4gICAgICAgIGNvbm5lY3RvciA9IF9yZWYuY29ubmVjdG9yLFxuICAgICAgICBub3RlID0gX3JlZi5ub3RlLFxuICAgICAgICBkaXNhYmxlID0gX3JlZi5kaXNhYmxlLFxuICAgICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEFubm90YXRpb24pO1xuXG4gICAgdGhpcy5fZHggPSBueCAhPT0gdW5kZWZpbmVkID8gbnggLSB4IDogZHg7XG4gICAgdGhpcy5fZHkgPSBueSAhPT0gdW5kZWZpbmVkID8gbnkgLSB5IDogZHk7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IFwiXCI7XG5cbiAgICB0aGlzLl90eXBlID0gdHlwZSB8fCBcIlwiO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICB0aGlzLm5vdGUgPSBub3RlIHx8IHt9O1xuICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yIHx8IHt9O1xuICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3QgfHwge307XG5cbiAgICB0aGlzLmRpc2FibGUgPSBkaXNhYmxlIHx8IFtdO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQW5ub3RhdGlvbiwgW3tcbiAgICBrZXk6IFwidXBkYXRlUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICBpZiAodGhpcy50eXBlLnNldFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudHlwZS5zZXRQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy50eXBlLnN1YmplY3QgJiYgdGhpcy50eXBlLnN1YmplY3Quc2VsZWN0QWxsKFwiOm5vdCguaGFuZGxlKVwiKS5ub2RlcygpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRoaXMudHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJDb21wb25lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMudHlwZS5jbGVhckNvbXBvbmVudHMgJiYgdGhpcy50eXBlLmNsZWFyQ29tcG9uZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMudHlwZS5zZXRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy50eXBlLnNldE9mZnNldCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUuY29ubmVjdG9yLnNlbGVjdEFsbChcIjpub3QoLmhhbmRsZSlcIikubm9kZXMoKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aGlzLnR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR5cGUucmVkcmF3Tm90ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGFzc05hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIGlmICh0aGlzLnR5cGUuc2V0Q2xhc3NOYW1lKSB0aGlzLnR5cGUuc2V0Q2xhc3NOYW1lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodHlwZSkge1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmNsZWFyQ29tcG9uZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHgpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHkpIHtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb2xvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoY29sb3IpIHtcbiAgICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkeCkge1xuICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkeSkge1xuICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm54XCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobngpIHtcbiAgICAgIHRoaXMuX2R4ID0gbnggLSB0aGlzLl94O1xuICAgICAgdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibnlcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShueSkge1xuICAgICAgdGhpcy5fZHkgPSBueSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMuX2R4LCB5OiB0aGlzLl9keSB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoX3JlZjIpIHtcbiAgICAgIHZhciB4ID0gX3JlZjIueCxcbiAgICAgICAgICB5ID0gX3JlZjIueTtcblxuICAgICAgdGhpcy5fZHggPSB4O1xuICAgICAgdGhpcy5fZHkgPSB5O1xuICAgICAgdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMuX3gsIHk6IHRoaXMuX3kgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKF9yZWYzKSB7XG4gICAgICB2YXIgeCA9IF9yZWYzLngsXG4gICAgICAgICAgeSA9IF9yZWYzLnk7XG5cbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLl94ICsgdGhpcy5fZHgsXG4gICAgICAgIHk6IHRoaXMuX3kgKyB0aGlzLl9keVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIHg6IHRoaXMuX3gsXG4gICAgICAgIHk6IHRoaXMuX3ksXG4gICAgICAgIGR4OiB0aGlzLl9keCxcbiAgICAgICAgZHk6IHRoaXMuX2R5XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5kYXRhICYmIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoID4gMCkganNvbi5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHRoaXMudHlwZSkganNvbi50eXBlID0gdGhpcy50eXBlO1xuICAgICAgaWYgKHRoaXMuX2NsYXNzTmFtZSkganNvbi5jbGFzc05hbWUgPSB0aGlzLl9jbGFzc05hbWU7XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3RvcikubGVuZ3RoID4gMCkganNvbi5jb25uZWN0b3IgPSB0aGlzLmNvbm5lY3RvcjtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnN1YmplY3QpLmxlbmd0aCA+IDApIGpzb24uc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm5vdGUpLmxlbmd0aCA+IDApIGpzb24ubm90ZSA9IHRoaXMubm90ZTtcblxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBbm5vdGF0aW9uO1xufSgpO1xuXG52YXIgQW5ub3RhdGlvbkNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25Db2xsZWN0aW9uKF9yZWYpIHtcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBfcmVmLmFubm90YXRpb25zLFxuICAgICAgICBhY2Nlc3NvcnMgPSBfcmVmLmFjY2Vzc29ycyxcbiAgICAgICAgYWNjZXNzb3JzSW52ZXJzZSA9IF9yZWYuYWNjZXNzb3JzSW52ZXJzZTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uQ29sbGVjdGlvbik7XG5cbiAgICB0aGlzLmFjY2Vzc29ycyA9IGFjY2Vzc29ycztcbiAgICB0aGlzLmFjY2Vzc29yc0ludmVyc2UgPSBhY2Nlc3NvcnNJbnZlcnNlO1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEFubm90YXRpb25Db2xsZWN0aW9uLCBbe1xuICAgIGtleTogXCJjbGVhclR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVHlwZXMobmV3U2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkLnR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGQuc3ViamVjdCA9IG5ld1NldHRpbmdzICYmIG5ld1NldHRpbmdzLnN1YmplY3QgfHwgZC5zdWJqZWN0O1xuICAgICAgICBkLmNvbm5lY3RvciA9IG5ld1NldHRpbmdzICYmIG5ld1NldHRpbmdzLmNvbm5lY3RvciB8fCBkLmNvbm5lY3RvcjtcbiAgICAgICAgZC5ub3RlID0gbmV3U2V0dGluZ3MgJiYgbmV3U2V0dGluZ3Mubm90ZSB8fCBkLm5vdGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25XaXRoQWNjZXNzb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uV2l0aEFjY2Vzc29ycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkLnR5cGUuc2V0UG9zaXRpb25XaXRoQWNjZXNzb3JzKF90aGlzLmFjY2Vzc29ycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE1vZGUoX2VkaXRNb2RlKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGEudHlwZS5lZGl0TW9kZSA9IF9lZGl0TW9kZTtcbiAgICAgICAgICBhLnR5cGUudXBkYXRlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZURpc2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzYWJsZShkaXNhYmxlKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGRpc2FibGUuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGEudHlwZVtkXSkge1xuICAgICAgICAgICAgICBhLnR5cGVbZF0ucmVtb3ZlICYmIGEudHlwZVtkXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgYS50eXBlW2RdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVGV4dFdyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGV4dFdyYXAodGV4dFdyYXApIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoYS50eXBlICYmIGEudHlwZS51cGRhdGVUZXh0V3JhcCkge1xuICAgICAgICAgIGEudHlwZS51cGRhdGVUZXh0V3JhcCh0ZXh0V3JhcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRleHQoKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSAmJiBhLnR5cGUuZHJhd1RleHQpIHtcbiAgICAgICAgICBhLnR5cGUuZHJhd1RleHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU5vdGVQYWRkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU5vdGVQYWRkaW5nKG5vdGVQYWRkaW5nKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGEudHlwZS5ub3RlUGFkZGluZyA9IG5vdGVQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIganNvbiA9IGEuanNvbjtcbiAgICAgICAgaWYgKF90aGlzMi5hY2Nlc3NvcnNJbnZlcnNlICYmIGEuZGF0YSkge1xuICAgICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzMi5hY2Nlc3NvcnNJbnZlcnNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBqc29uLmRhdGFba10gPSBfdGhpczIuYWNjZXNzb3JzSW52ZXJzZVtrXSh7IHg6IGEueCwgeTogYS55IH0pO1xuXG4gICAgICAgICAgICAvL1RPRE8gbWFrZSB0aGlzIGZlYXNpYmxlIHRvIG1hcCBiYWNrIHRvIGRhdGEgZm9yIG90aGVyIHR5cGVzIG9mIHN1YmplY3RzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm90ZU5vZGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhLnR5cGUuZ2V0Tm90ZUJCb3hPZmZzZXQoKSwgeyBwb3NpdGlvblg6IGEueCwgcG9zaXRpb25ZOiBhLnkgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvL1RPRE86IGNvbWUgYmFjayBhbmQgcmV0aGluayBpZiBhLnggYW5kIGEueSBhcmUgYXBwbGljYWJsZSBpbiBhbGwgc2l0dWF0aW9uc1xuICAgIC8vIGdldCBjb25uZWN0b3JOb2RlcygpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChhID0+ICh7IC4uLmEudHlwZS5nZXRDb25uZWN0b3JCQm94KCksIHN0YXJ0WDogYS54LCBzdGFydFk6IGEueX0pKVxuICAgIC8vIH1cblxuICAgIC8vIGdldCBzdWJqZWN0Tm9kZXMoKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoYSA9PiAoeyAuLi5hLnR5cGUuZ2V0U3ViamVjdEJCb3goKSwgc3RhcnRYOiBhLngsIHN0YXJ0WTogYS55fSkpXG4gICAgLy8gfVxuXG4gICAgLy8gZ2V0IGFubm90YXRpb25Ob2RlcygpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChhID0+ICh7IC4uLmEudHlwZS5nZXRBbm5vdGF0aW9uQkJveCgpLCBzdGFydFg6IGEueCwgc3RhcnRZOiBhLnl9KSlcbiAgICAvLyB9XG5cbiAgfV0pO1xuICByZXR1cm4gQW5ub3RhdGlvbkNvbGxlY3Rpb247XG59KCk7XG5cbnZhciBwb2ludEhhbmRsZSA9IGZ1bmN0aW9uIHBvaW50SGFuZGxlKF9yZWYpIHtcbiAgdmFyIF9yZWYkY3ggPSBfcmVmLmN4LFxuICAgICAgY3ggPSBfcmVmJGN4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRjeCxcbiAgICAgIF9yZWYkY3kgPSBfcmVmLmN5LFxuICAgICAgY3kgPSBfcmVmJGN5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRjeTtcblxuICByZXR1cm4geyBtb3ZlOiB7IHg6IGN4LCB5OiBjeSB9IH07XG59O1xuXG52YXIgY2lyY2xlSGFuZGxlcyA9IGZ1bmN0aW9uIGNpcmNsZUhhbmRsZXMoX3JlZjIpIHtcbiAgdmFyIF9yZWYyJGN4ID0gX3JlZjIuY3gsXG4gICAgICBjeCA9IF9yZWYyJGN4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkY3gsXG4gICAgICBfcmVmMiRjeSA9IF9yZWYyLmN5LFxuICAgICAgY3kgPSBfcmVmMiRjeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJGN5LFxuICAgICAgcjEgPSBfcmVmMi5yMSxcbiAgICAgIHIyID0gX3JlZjIucjIsXG4gICAgICBwYWRkaW5nID0gX3JlZjIucGFkZGluZztcblxuICB2YXIgaCA9IHsgbW92ZTogeyB4OiBjeCwgeTogY3kgfSB9O1xuXG4gIGlmIChyMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaC5yMSA9IHsgeDogY3ggKyByMSAvIE1hdGguc3FydCgyKSwgeTogY3kgKyByMSAvIE1hdGguc3FydCgyKSB9O1xuICB9XG5cbiAgaWYgKHIyICE9PSB1bmRlZmluZWQpIHtcbiAgICBoLnIyID0geyB4OiBjeCArIHIyIC8gTWF0aC5zcXJ0KDIpLCB5OiBjeSArIHIyIC8gTWF0aC5zcXJ0KDIpIH07XG4gIH1cblxuICBpZiAocGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaC5wYWRkaW5nID0geyB4OiBjeCArIHIxICsgcGFkZGluZywgeTogY3kgfTtcbiAgfVxuXG4gIHJldHVybiBoO1xufTtcblxuXG5cblxuXG4vL2FyYyBoYW5kbGVzXG52YXIgYWRkSGFuZGxlcyA9IGZ1bmN0aW9uIGFkZEhhbmRsZXMoX3JlZjUpIHtcbiAgdmFyIGdyb3VwID0gX3JlZjUuZ3JvdXAsXG4gICAgICBoYW5kbGVzID0gX3JlZjUuaGFuZGxlcyxcbiAgICAgIF9yZWY1JHIgPSBfcmVmNS5yLFxuICAgICAgciA9IF9yZWY1JHIgPT09IHVuZGVmaW5lZCA/IDEwIDogX3JlZjUkcjtcblxuICAvL2dpdmUgaXQgYSBncm91cCBhbmQgeCx5IHRvIGRyYXcgaGFuZGxlc1xuICAvL3RoZW4gZ2l2ZSBpdCBpbnN0cnVjdGlvbnMgb24gd2hhdCB0aGUgaGFuZGxlcyBjaGFuZ2VcbiAgdmFyIGggPSBncm91cC5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLmRhdGEoaGFuZGxlcyk7XG5cbiAgaC5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIikuYXR0cihcImZpbGxcIiwgXCJncmV5XCIpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMC4xKS5hdHRyKFwiY3Vyc29yXCIsIFwibW92ZVwiKS5hdHRyKFwic3Ryb2tlLWRhc2hhcnJheVwiLCA1KS5hdHRyKFwic3Ryb2tlXCIsIFwiZ3JleVwiKS5jYWxsKGRyYWcoKS5jb250YWluZXIoc2VsZWN0KFwiZy5hbm5vdGF0aW9uc1wiKS5ub2RlKCkpLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zdGFydCAmJiBkLnN0YXJ0KGQpO1xuICB9KS5vbihcImRyYWdcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5kcmFnICYmIGQuZHJhZyhkKTtcbiAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5lbmQgJiYgZC5lbmQoZCk7XG4gIH0pKTtcblxuICBncm91cC5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0pLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0pLmF0dHIoXCJyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuciB8fCByO1xuICB9KS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gXCJoYW5kbGUgXCIgKyAoZC5jbGFzc05hbWUgfHwgXCJcIik7XG4gIH0pO1xuXG4gIGguZXhpdCgpLnJlbW92ZSgpO1xufTtcblxudmFyIGxlZnRSaWdodER5bmFtaWMgPSBmdW5jdGlvbiBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCB5KSB7XG4gIGlmIChhbGlnbiA9PT0gXCJkeW5hbWljXCIgfHwgYWxpZ24gPT09IFwibGVmdFwiIHx8IGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICBpZiAoeSA8IDApIHtcbiAgICAgIGFsaWduID0gXCJ0b3BcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ24gPSBcImJvdHRvbVwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxpZ247XG59O1xuXG52YXIgdG9wQm90dG9tRHluYW1pYyA9IGZ1bmN0aW9uIHRvcEJvdHRvbUR5bmFtaWMoYWxpZ24sIHgpIHtcbiAgaWYgKGFsaWduID09PSBcImR5bmFtaWNcIiB8fCBhbGlnbiA9PT0gXCJ0b3BcIiB8fCBhbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgYWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWduID0gXCJsZWZ0XCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGlnbjtcbn07XG5cbnZhciBvcmllbnRhdGlvblRvcEJvdHRvbSA9IFtcInRvcEJvdHRvbVwiLCBcInRvcFwiLCBcImJvdHRvbVwiXTtcbnZhciBvcmllbnRhdGlvbkxlZnRSaWdodCA9IFtcImxlZnRSaWdodFwiLCBcImxlZnRcIiwgXCJyaWdodFwiXTtcblxudmFyIG5vdGVBbGlnbm1lbnQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIF9yZWYkcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHBhZGRpbmcsXG4gICAgICBfcmVmJGJib3ggPSBfcmVmLmJib3gsXG4gICAgICBiYm94ID0gX3JlZiRiYm94ID09PSB1bmRlZmluZWQgPyB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSA6IF9yZWYkYmJveCxcbiAgICAgIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIG9yaWVudGF0aW9uID0gX3JlZi5vcmllbnRhdGlvbixcbiAgICAgIF9yZWYkb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfcmVmJG9mZnNldCA9PT0gdW5kZWZpbmVkID8geyB4OiAwLCB5OiAwIH0gOiBfcmVmJG9mZnNldDtcblxuICB2YXIgeCA9IC1iYm94Lng7XG4gIHZhciB5ID0gMDsgLy8tYmJveC55XG4gIGlmIChvcmllbnRhdGlvblRvcEJvdHRvbS5pbmRleE9mKG9yaWVudGF0aW9uKSAhPT0gLTEpIHtcbiAgICBhbGlnbiA9IHRvcEJvdHRvbUR5bmFtaWMoYWxpZ24sIG9mZnNldC54KTtcbiAgICBpZiAob2Zmc2V0LnkgPCAwICYmIG9yaWVudGF0aW9uID09PSBcInRvcEJvdHRvbVwiIHx8IG9yaWVudGF0aW9uID09PSBcInRvcFwiKSB7XG4gICAgICB5IC09IGJib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSBwYWRkaW5nO1xuICAgIH1cblxuICAgIGlmIChhbGlnbiA9PT0gXCJtaWRkbGVcIikge1xuICAgICAgeCAtPSBiYm94LndpZHRoIC8gMjtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHggLT0gYmJveC53aWR0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JpZW50YXRpb25MZWZ0UmlnaHQuaW5kZXhPZihvcmllbnRhdGlvbikgIT09IC0xKSB7XG4gICAgYWxpZ24gPSBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCBvZmZzZXQueSk7XG4gICAgaWYgKG9mZnNldC54IDwgMCAmJiBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0UmlnaHRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHggLT0gYmJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gcGFkZGluZztcbiAgICB9XG5cbiAgICBpZiAoYWxpZ24gPT09IFwibWlkZGxlXCIpIHtcbiAgICAgIHkgLT0gYmJveC5oZWlnaHQgLyAyO1xuICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwidG9wXCIpIHtcbiAgICAgIHkgLT0gYmJveC5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xufSk7XG5cbnZhciBsaW5lQnVpbGRlciA9IGZ1bmN0aW9uIGxpbmVCdWlsZGVyKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBfcmVmJGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGN1cnZlID0gX3JlZiRjdXJ2ZSA9PT0gdW5kZWZpbmVkID8gY3VydmVMaW5lYXIgOiBfcmVmJGN1cnZlLFxuICAgICAgY2FudmFzQ29udGV4dCA9IF9yZWYuY2FudmFzQ29udGV4dCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NJRCA9IF9yZWYuY2xhc3NJRDtcblxuICB2YXIgbGluZUdlbiA9IGxpbmUoKS5jdXJ2ZShjdXJ2ZSk7XG5cbiAgdmFyIGJ1aWxkZXIgPSB7XG4gICAgdHlwZTogJ3BhdGgnLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNsYXNzSUQ6IGNsYXNzSUQsXG4gICAgZGF0YTogZGF0YVxuICB9O1xuXG4gIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgbGluZUdlbi5jb250ZXh0KGNhbnZhc0NvbnRleHQpO1xuICAgIGJ1aWxkZXIucGF0aE1ldGhvZHMgPSBsaW5lR2VuO1xuICB9IGVsc2Uge1xuICAgIGJ1aWxkZXIuYXR0cnMgPSB7XG4gICAgICBkOiBsaW5lR2VuKGRhdGEpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyO1xufTtcblxudmFyIGFyY0J1aWxkZXIgPSBmdW5jdGlvbiBhcmNCdWlsZGVyKF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRleHQgPSBfcmVmMi5jYW52YXNDb250ZXh0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NJRCA9IF9yZWYyLmNsYXNzSUQ7XG5cblxuICB2YXIgYnVpbGRlciA9IHtcbiAgICB0eXBlOiAncGF0aCcsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgY2xhc3NJRDogY2xhc3NJRCxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG5cbiAgdmFyIGFyY1NoYXBlID0gYXJjKCkuaW5uZXJSYWRpdXMoZGF0YS5pbm5lclJhZGl1cyB8fCAwKS5vdXRlclJhZGl1cyhkYXRhLm91dGVyUmFkaXVzIHx8IGRhdGEucmFkaXVzIHx8IDIpLnN0YXJ0QW5nbGUoZGF0YS5zdGFydEFuZ2xlIHx8IDApLmVuZEFuZ2xlKGRhdGEuZW5kQW5nbGUgfHwgMiAqIE1hdGguUEkpO1xuXG4gIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgYXJjU2hhcGUuY29udGV4dChjYW52YXNDb250ZXh0KTtcbiAgICBidWlsZGVyLnBhdGhNZXRob2RzID0gbGluZUdlbjtcbiAgfSBlbHNlIHtcblxuICAgIGJ1aWxkZXIuYXR0cnMgPSB7XG4gICAgICBkOiBhcmNTaGFwZSgpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyO1xufTtcblxudmFyIG5vdGVWZXJ0aWNhbCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgX3JlZiR4ID0gX3JlZi54LFxuICAgICAgeCA9IF9yZWYkeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeCxcbiAgICAgIF9yZWYkeSA9IF9yZWYueSxcbiAgICAgIHkgPSBfcmVmJHkgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHksXG4gICAgICBiYm94ID0gX3JlZi5iYm94LFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG5cbiAgYWxpZ24gPSBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCBvZmZzZXQueSk7XG5cbiAgaWYgKGFsaWduID09PSBcInRvcFwiKSB7XG4gICAgeSAtPSBiYm94LmhlaWdodDtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHkgLT0gYmJveC5oZWlnaHQgLyAyO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBbW3gsIHldLCBbeCwgeSArIGJib3guaGVpZ2h0XV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJub3RlLWxpbmVcIiB9KV0gfTtcbn0pO1xuXG52YXIgbm90ZUhvcml6b250YWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICBiYm94ID0gX3JlZi5iYm94O1xuXG4gIGFsaWduID0gdG9wQm90dG9tRHluYW1pYyhhbGlnbiwgb2Zmc2V0LngpO1xuXG4gIGlmIChhbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgeCAtPSBiYm94LndpZHRoO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSBcIm1pZGRsZVwiKSB7XG4gICAgeCAtPSBiYm94LndpZHRoIC8gMjtcbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4LCB5XSwgW3ggKyBiYm94LndpZHRoLCB5XV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJub3RlLWxpbmVcIiB9KV0gfTtcbn0pO1xuXG52YXIgbGluZVNldHVwID0gZnVuY3Rpb24gbGluZVNldHVwKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBzdWJqZWN0VHlwZSA9IF9yZWYuc3ViamVjdFR5cGU7XG5cbiAgdmFyIGFubm90YXRpb24gPSB0eXBlLmFubm90YXRpb247XG4gIHZhciBvZmZzZXQgPSBhbm5vdGF0aW9uLnBvc2l0aW9uO1xuXG4gIHZhciB4MSA9IGFubm90YXRpb24ueCAtIG9mZnNldC54LFxuICAgICAgeDIgPSB4MSArIGFubm90YXRpb24uZHgsXG4gICAgICB5MSA9IGFubm90YXRpb24ueSAtIG9mZnNldC55LFxuICAgICAgeTIgPSB5MSArIGFubm90YXRpb24uZHk7XG5cbiAgdmFyIHN1YmplY3REYXRhID0gYW5ub3RhdGlvbi5zdWJqZWN0O1xuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJjaXJjbGVcIiAmJiAoc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzKSkge1xuICAgIHZhciBoID0gTWF0aC5zcXJ0KCh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKSk7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKC15MiAvIGgpO1xuICAgIHZhciByID0gc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzICsgKHN1YmplY3REYXRhLnJhZGl1c1BhZGRpbmcgfHwgMCk7XG5cbiAgICB4MSA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSAqIHIpICogKHgyIDwgMCA/IC0xIDogMSk7XG4gICAgeTEgPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkgKiByKSAqICh5MiA8IDAgPyAtMSA6IDEpO1xuICB9XG5cbiAgaWYgKHN1YmplY3RUeXBlID09PSBcInJlY3RcIikge1xuICAgIHZhciB3aWR0aCA9IHN1YmplY3REYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICAgIGlmICh3aWR0aCA+IDAgJiYgYW5ub3RhdGlvbi5keCA+IDAgfHwgd2lkdGggPCAwICYmIGFubm90YXRpb24uZHggPCAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMod2lkdGgpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keCkpIHgxID0gd2lkdGggLyAyO2Vsc2UgeDEgPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IDAgJiYgYW5ub3RhdGlvbi5keSA+IDAgfHwgaGVpZ2h0IDwgMCAmJiBhbm5vdGF0aW9uLmR5IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPiBNYXRoLmFicyhhbm5vdGF0aW9uLmR5KSkgeTEgPSBoZWlnaHQgLyAyO2Vsc2UgeTEgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmICh4MSA9PT0gd2lkdGggLyAyICYmIHkxID09PSBoZWlnaHQgLyAyKSB7XG4gICAgICB4MSA9IHgyO3kxID0geTI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtbeDEsIHkxXSwgW3gyLCB5Ml1dO1xufTtcblxudmFyIGNvbm5lY3RvckxpbmUgPSAoZnVuY3Rpb24gKGNvbm5lY3RvckRhdGEpIHtcbiAgdmFyIGRhdGEgPSBsaW5lU2V0dXAoY29ubmVjdG9yRGF0YSk7XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV0gfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yRWxib3cgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBzdWJqZWN0VHlwZSA9IF9yZWYuc3ViamVjdFR5cGU7XG5cblxuICB2YXIgYW5ub3RhdGlvbiA9IHR5cGUuYW5ub3RhdGlvbjtcbiAgdmFyIG9mZnNldCA9IGFubm90YXRpb24ucG9zaXRpb247XG5cbiAgdmFyIHgxID0gYW5ub3RhdGlvbi54IC0gb2Zmc2V0LngsXG4gICAgICB4MiA9IHgxICsgYW5ub3RhdGlvbi5keCxcbiAgICAgIHkxID0gYW5ub3RhdGlvbi55IC0gb2Zmc2V0LnksXG4gICAgICB5MiA9IHkxICsgYW5ub3RhdGlvbi5keTtcblxuICB2YXIgc3ViamVjdERhdGEgPSBhbm5vdGF0aW9uLnN1YmplY3Q7XG5cbiAgaWYgKHN1YmplY3RUeXBlID09PSBcInJlY3RcIikge1xuICAgIHZhciB3aWR0aCA9IHN1YmplY3REYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICAgIGlmICh3aWR0aCA+IDAgJiYgYW5ub3RhdGlvbi5keCA+IDAgfHwgd2lkdGggPCAwICYmIGFubm90YXRpb24uZHggPCAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMod2lkdGgpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keCkpIHgxID0gd2lkdGggLyAyO2Vsc2UgeDEgPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IDAgJiYgYW5ub3RhdGlvbi5keSA+IDAgfHwgaGVpZ2h0IDwgMCAmJiBhbm5vdGF0aW9uLmR5IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPiBNYXRoLmFicyhhbm5vdGF0aW9uLmR5KSkgeTEgPSBoZWlnaHQgLyAyO2Vsc2UgeTEgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmICh4MSA9PT0gd2lkdGggLyAyICYmIHkxID09PSBoZWlnaHQgLyAyKSB7XG4gICAgICB4MSA9IHgyO3kxID0geTI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGEgPSBbW3gxLCB5MV0sIFt4MiwgeTJdXTtcblxuICB2YXIgZGlmZlkgPSB5MiAtIHkxO1xuICB2YXIgZGlmZlggPSB4MiAtIHgxO1xuICB2YXIgeGUgPSB4MjtcbiAgdmFyIHllID0geTI7XG4gIHZhciBvcHBvc2l0ZSA9IHkyIDwgeTEgJiYgeDIgPiB4MSB8fCB4MiA8IHgxICYmIHkyID4geTEgPyAtMSA6IDE7XG5cbiAgaWYgKE1hdGguYWJzKGRpZmZYKSA8IE1hdGguYWJzKGRpZmZZKSkge1xuICAgIHhlID0geDI7XG4gICAgeWUgPSB5MSArIGRpZmZYICogb3Bwb3NpdGU7XG4gIH0gZWxzZSB7XG4gICAgeWUgPSB5MjtcbiAgICB4ZSA9IHgxICsgZGlmZlkgKiBvcHBvc2l0ZTtcbiAgfVxuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJjaXJjbGVcIiAmJiAoc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzKSkge1xuICAgIHZhciByID0gKHN1YmplY3REYXRhLm91dGVyUmFkaXVzIHx8IHN1YmplY3REYXRhLnJhZGl1cykgKyAoc3ViamVjdERhdGEucmFkaXVzUGFkZGluZyB8fCAwKTtcbiAgICB2YXIgbGVuZ3RoID0gciAvIE1hdGguc3FydCgyKTtcblxuICAgIGlmIChNYXRoLmFicyhkaWZmWCkgPiBsZW5ndGggJiYgTWF0aC5hYnMoZGlmZlkpID4gbGVuZ3RoKSB7XG4gICAgICB4MSA9IGxlbmd0aCAqICh4MiA8IDAgPyAtMSA6IDEpO1xuICAgICAgeTEgPSBsZW5ndGggKiAoeTIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gxLCB5MV0sIFt4ZSwgeWVdLCBbeDIsIHkyXV07XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmWCkgPiBNYXRoLmFicyhkaWZmWSkpIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbigteTIgLyByKTtcbiAgICAgIHgxID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpICogcikgKiAoeDIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gxLCB5Ml0sIFt4MiwgeTJdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9hbmdsZSA9IE1hdGguYWNvcyh4MiAvIHIpO1xuICAgICAgeTEgPSBNYXRoLmFicyhNYXRoLnNpbihfYW5nbGUpICogcikgKiAoeTIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gyLCB5MV0sIFt4MiwgeTJdXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IFtbeDEsIHkxXSwgW3hlLCB5ZV0sIFt4MiwgeTJdXTtcbiAgfVxuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV0gfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yQ3VydmUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBjb25uZWN0b3JEYXRhID0gX3JlZi5jb25uZWN0b3JEYXRhLFxuICAgICAgc3ViamVjdFR5cGUgPSBfcmVmLnN1YmplY3RUeXBlO1xuXG5cbiAgaWYgKCFjb25uZWN0b3JEYXRhKSB7XG4gICAgY29ubmVjdG9yRGF0YSA9IHt9O1xuICB9XG4gIGlmICghY29ubmVjdG9yRGF0YS5wb2ludHMgfHwgdHlwZW9mIGNvbm5lY3RvckRhdGEucG9pbnRzID09PSBcIm51bWJlclwiKSB7XG4gICAgY29ubmVjdG9yRGF0YS5wb2ludHMgPSBjcmVhdGVQb2ludHModHlwZS5hbm5vdGF0aW9uLm9mZnNldCwgY29ubmVjdG9yRGF0YS5wb2ludHMpO1xuICB9XG4gIGlmICghY29ubmVjdG9yRGF0YS5jdXJ2ZSkge1xuICAgIGNvbm5lY3RvckRhdGEuY3VydmUgPSBjdXJ2ZUNhdG11bGxSb207XG4gIH1cblxuICB2YXIgaGFuZGxlcyA9IFtdO1xuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIGNIYW5kbGVzID0gY29ubmVjdG9yRGF0YS5wb2ludHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHBvaW50SGFuZGxlKHsgY3g6IGNbMF0sIGN5OiBjWzFdIH0pLCB7IGluZGV4OiBpIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIHVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gdXBkYXRlUG9pbnQoaW5kZXgpIHtcbiAgICAgIGNvbm5lY3RvckRhdGEucG9pbnRzW2luZGV4XVswXSArPSBldmVudC5keDtcbiAgICAgIGNvbm5lY3RvckRhdGEucG9pbnRzW2luZGV4XVsxXSArPSBldmVudC5keTtcbiAgICAgIHR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgfTtcblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMoY0hhbmRsZXMubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGgubW92ZSwgeyBkcmFnOiB1cGRhdGVQb2ludC5iaW5kKHR5cGUsIGguaW5kZXgpIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gbGluZVNldHVwKHsgdHlwZTogdHlwZSwgc3ViamVjdFR5cGU6IHN1YmplY3RUeXBlIH0pO1xuICBkYXRhID0gW2RhdGFbMF1dLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShjb25uZWN0b3JEYXRhLnBvaW50cyksIFtkYXRhWzFdXSk7XG4gIHZhciBjb21wb25lbnRzID0gW2xpbmVCdWlsZGVyKHsgZGF0YTogZGF0YSwgY3VydmU6IGNvbm5lY3RvckRhdGEuY3VydmUsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV07XG5cbiAgcmV0dXJuIHsgY29tcG9uZW50czogY29tcG9uZW50cywgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbnZhciBjcmVhdGVQb2ludHMgPSBmdW5jdGlvbiBjcmVhdGVQb2ludHMob2Zmc2V0KSB7XG4gIHZhciBhbmNob3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyO1xuXG4gIHZhciBkaWZmID0geyB4OiBvZmZzZXQueCAvIChhbmNob3JzICsgMSksIHk6IG9mZnNldC55IC8gKGFuY2hvcnMgKyAxKSB9O1xuICB2YXIgcCA9IFtdO1xuXG4gIHZhciBpID0gMTtcbiAgZm9yICg7IGkgPD0gYW5jaG9yczsgaSsrKSB7XG4gICAgcC5wdXNoKFtkaWZmLnggKiBpICsgaSAlIDIgKiAyMCwgZGlmZi55ICogaSAtIGkgJSAyICogMjBdKTtcbiAgfVxuICByZXR1cm4gcDtcbn07XG5cbnZhciBjb25uZWN0b3JBcnJvdyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYW5ub3RhdGlvbiA9IF9yZWYuYW5ub3RhdGlvbixcbiAgICAgIHN0YXJ0ID0gX3JlZi5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWYuZW5kLFxuICAgICAgX3JlZiRzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWYkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHNjYWxlO1xuXG4gIHZhciBvZmZzZXQgPSBhbm5vdGF0aW9uLnBvc2l0aW9uO1xuICBpZiAoIXN0YXJ0KSB7XG4gICAgc3RhcnQgPSBbYW5ub3RhdGlvbi5keCwgYW5ub3RhdGlvbi5keV07XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBbLWVuZFswXSArIHN0YXJ0WzBdLCAtZW5kWzFdICsgc3RhcnRbMV1dO1xuICB9XG4gIGlmICghZW5kKSB7XG4gICAgZW5kID0gW2Fubm90YXRpb24ueCAtIG9mZnNldC54LCBhbm5vdGF0aW9uLnkgLSBvZmZzZXQueV07XG4gIH1cblxuICB2YXIgeDEgPSBlbmRbMF0sXG4gICAgICB5MSA9IGVuZFsxXTtcblxuICB2YXIgZHggPSBzdGFydFswXTtcbiAgdmFyIGR5ID0gc3RhcnRbMV07XG5cbiAgdmFyIHNpemUgPSAxMCAqIHNjYWxlO1xuICB2YXIgYW5nbGVPZmZzZXQgPSAxNiAvIDE4MCAqIE1hdGguUEk7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcblxuICBpZiAoZHggPCAwKSB7XG4gICAgYW5nbGUgKz0gTWF0aC5QSTtcbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4MSwgeTFdLCBbTWF0aC5jb3MoYW5nbGUgKyBhbmdsZU9mZnNldCkgKiBzaXplICsgeDEsIE1hdGguc2luKGFuZ2xlICsgYW5nbGVPZmZzZXQpICogc2l6ZSArIHkxXSwgW01hdGguY29zKGFuZ2xlIC0gYW5nbGVPZmZzZXQpICogc2l6ZSArIHgxLCBNYXRoLnNpbihhbmdsZSAtIGFuZ2xlT2Zmc2V0KSAqIHNpemUgKyB5MV0sIFt4MSwgeTFdXTtcblxuICAvL1RPRE8gYWRkIGluIHJldmVyc2VcbiAgLy8gaWYgKGNhbnZhc0NvbnRleHQuYXJyb3dSZXZlcnNlKXtcbiAgLy8gICBkYXRhID0gW1t4MSwgeTFdLFxuICAvLyAgIFtNYXRoLmNvcyhhbmdsZSArIGFuZ2xlT2Zmc2V0KSpzaXplLCBNYXRoLnNpbihhbmdsZSArIGFuZ2xlT2Zmc2V0KSpzaXplXSxcbiAgLy8gICBbTWF0aC5jb3MoYW5nbGUgLSBhbmdsZU9mZnNldCkqc2l6ZSwgTWF0aC5zaW4oYW5nbGUgLSBhbmdsZU9mZnNldCkqc2l6ZV0sXG4gIC8vICAgW3gxLCB5MV1cbiAgLy8gICBdXG4gIC8vIH0gZWxzZSB7XG4gIC8vICAgZGF0YSA9IFtbeDEsIHkxXSxcbiAgLy8gICBbTWF0aC5jb3MoYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZSwgTWF0aC5zaW4oYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZV0sXG4gIC8vICAgW01hdGguY29zKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemUsIE1hdGguc2luKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemVdLFxuICAvLyAgIFt4MSwgeTFdXG4gIC8vICAgXVxuICAvLyB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0b3ItZW5kIGNvbm5lY3Rvci1hcnJvd1wiLFxuICAgICAgY2xhc3NJRDogXCJjb25uZWN0b3ItZW5kXCJcbiAgICB9KV1cbiAgfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yRG90ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBsaW5lJCQxID0gX3JlZi5saW5lLFxuICAgICAgX3JlZiRzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWYkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHNjYWxlO1xuXG4gIHZhciBkb3QgPSBhcmNCdWlsZGVyKHtcbiAgICBjbGFzc05hbWU6IFwiY29ubmVjdG9yLWVuZCBjb25uZWN0b3ItZG90XCIsXG4gICAgY2xhc3NJRDogXCJjb25uZWN0b3ItZW5kXCIsXG4gICAgZGF0YTogeyByYWRpdXM6IDMgKiBNYXRoLnNxcnQoc2NhbGUpIH1cbiAgfSk7XG4gIGRvdC5hdHRycy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGxpbmUkJDEuZGF0YVswXVswXSArIFwiLCBcIiArIGxpbmUkJDEuZGF0YVswXVsxXSArIFwiKVwiO1xuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtkb3RdIH07XG59KTtcblxudmFyIHN1YmplY3RDaXJjbGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN1YmplY3REYXRhID0gX3JlZi5zdWJqZWN0RGF0YSxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgaWYgKCFzdWJqZWN0RGF0YS5yYWRpdXMgJiYgIXN1YmplY3REYXRhLm91dGVyUmFkaXVzKSB7XG4gICAgc3ViamVjdERhdGEucmFkaXVzID0gMjA7XG4gIH1cblxuICB2YXIgaGFuZGxlcyA9IFtdO1xuICB2YXIgYyA9IGFyY0J1aWxkZXIoeyBkYXRhOiBzdWJqZWN0RGF0YSwgY2xhc3NOYW1lOiBcInN1YmplY3RcIiB9KTtcbiAgaWYgKHR5cGUuZWRpdE1vZGUpIHtcbiAgICB2YXIgaCA9IGNpcmNsZUhhbmRsZXMoe1xuICAgICAgcjE6IGMuZGF0YS5vdXRlclJhZGl1cyB8fCBjLmRhdGEucmFkaXVzLFxuICAgICAgcjI6IGMuZGF0YS5pbm5lclJhZGl1cyxcbiAgICAgIHBhZGRpbmc6IHN1YmplY3REYXRhLnJhZGl1c1BhZGRpbmdcbiAgICB9KTtcblxuICAgIHZhciB1cGRhdGVSYWRpdXMgPSBmdW5jdGlvbiB1cGRhdGVSYWRpdXMoYXR0cikge1xuICAgICAgdmFyIHIgPSBzdWJqZWN0RGF0YVthdHRyXSArIGV2ZW50LmR4ICogTWF0aC5zcXJ0KDIpO1xuICAgICAgc3ViamVjdERhdGFbYXR0cl0gPSByO1xuICAgICAgdHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICB2YXIgY0hhbmRsZXMgPSBbX2V4dGVuZHMoe30sIGgucjEsIHtcbiAgICAgIGRyYWc6IHVwZGF0ZVJhZGl1cy5iaW5kKHR5cGUsIHN1YmplY3REYXRhLm91dGVyUmFkaXVzICE9PSB1bmRlZmluZWQgPyBcIm91dGVyUmFkaXVzXCIgOiBcInJhZGl1c1wiKVxuICAgIH0pXTtcblxuICAgIGlmIChzdWJqZWN0RGF0YS5pbm5lclJhZGl1cykge1xuICAgICAgY0hhbmRsZXMucHVzaChfZXh0ZW5kcyh7fSwgaC5yMiwgeyBkcmFnOiB1cGRhdGVSYWRpdXMuYmluZCh0eXBlLCBcImlubmVyUmFkaXVzXCIpIH0pKTtcbiAgICB9XG4gICAgaGFuZGxlcyA9IHR5cGUubWFwSGFuZGxlcyhjSGFuZGxlcyk7XG4gIH1cblxuICBjLmF0dHJzW1wiZmlsbC1vcGFjaXR5XCJdID0gMDtcblxuICByZXR1cm4geyBjb21wb25lbnRzOiBbY10sIGhhbmRsZXM6IGhhbmRsZXMgfTtcbn0pO1xuXG52YXIgc3ViamVjdFJlY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN1YmplY3REYXRhID0gX3JlZi5zdWJqZWN0RGF0YSxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgaWYgKCFzdWJqZWN0RGF0YS53aWR0aCkge1xuICAgIHN1YmplY3REYXRhLndpZHRoID0gMTAwO1xuICB9XG4gIGlmICghc3ViamVjdERhdGEuaGVpZ2h0KSB7XG4gICAgc3ViamVjdERhdGEuaGVpZ2h0ID0gMTAwO1xuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcbiAgdmFyIHdpZHRoID0gc3ViamVjdERhdGEud2lkdGgsXG4gICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICB2YXIgZGF0YSA9IFtbMCwgMF0sIFt3aWR0aCwgMF0sIFt3aWR0aCwgaGVpZ2h0XSwgWzAsIGhlaWdodF0sIFswLCAwXV07XG4gIHZhciByZWN0ID0gbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6IFwic3ViamVjdFwiIH0pO1xuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIHVwZGF0ZVdpZHRoID0gZnVuY3Rpb24gdXBkYXRlV2lkdGgoKSB7XG4gICAgICBzdWJqZWN0RGF0YS53aWR0aCA9IGV2ZW50Lng7XG4gICAgICB0eXBlLnJlZHJhd1N1YmplY3QoKTtcbiAgICAgIHR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiB1cGRhdGVIZWlnaHQoKSB7XG4gICAgICBzdWJqZWN0RGF0YS5oZWlnaHQgPSBldmVudC55O1xuICAgICAgdHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICB2YXIgckhhbmRsZXMgPSBbeyB4OiB3aWR0aCwgeTogaGVpZ2h0IC8gMiwgZHJhZzogdXBkYXRlV2lkdGguYmluZCh0eXBlKSB9LCB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0LCBkcmFnOiB1cGRhdGVIZWlnaHQuYmluZCh0eXBlKSB9XTtcblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMockhhbmRsZXMpO1xuICB9XG4gIHJlY3QuYXR0cnNbXCJmaWxsLW9wYWNpdHlcIl0gPSAwLjE7XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtyZWN0XSwgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbnZhciBzdWJqZWN0VGhyZXNob2xkID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdWJqZWN0RGF0YSA9IF9yZWYuc3ViamVjdERhdGEsXG4gICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gIHZhciBvZmZzZXQgPSB0eXBlLmFubm90YXRpb24ucG9zaXRpb247XG5cbiAgdmFyIHgxID0gKHN1YmplY3REYXRhLngxICE9PSB1bmRlZmluZWQgPyBzdWJqZWN0RGF0YS54MSA6IG9mZnNldC54KSAtIG9mZnNldC54LFxuICAgICAgeDIgPSAoc3ViamVjdERhdGEueDIgIT09IHVuZGVmaW5lZCA/IHN1YmplY3REYXRhLngyIDogb2Zmc2V0LngpIC0gb2Zmc2V0LngsXG4gICAgICB5MSA9IChzdWJqZWN0RGF0YS55MSAhPT0gdW5kZWZpbmVkID8gc3ViamVjdERhdGEueTEgOiBvZmZzZXQueSkgLSBvZmZzZXQueSxcbiAgICAgIHkyID0gKHN1YmplY3REYXRhLnkyICE9PSB1bmRlZmluZWQgPyBzdWJqZWN0RGF0YS55MiA6IG9mZnNldC55KSAtIG9mZnNldC55O1xuXG4gIHZhciBkYXRhID0gW1t4MSwgeTFdLCBbeDIsIHkyXV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogJ3N1YmplY3QnIH0pXSB9O1xufSk7XG5cbnZhciBzdWJqZWN0QmFkZ2UgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIF9yZWYkc3ViamVjdERhdGEgPSBfcmVmLnN1YmplY3REYXRhLFxuICAgICAgc3ViamVjdERhdGEgPSBfcmVmJHN1YmplY3REYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkc3ViamVjdERhdGEsXG4gICAgICBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICB0eXBlID0gX3JlZiR0eXBlID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkdHlwZTtcbiAgdmFyIGFubm90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciB0eXBlU2V0dGluZ3MgPSB0eXBlLnR5cGVTZXR0aW5ncyAmJiB0eXBlLnR5cGVTZXR0aW5ncy5zdWJqZWN0O1xuXG4gIGlmICghc3ViamVjdERhdGEucmFkaXVzKSB7XG4gICAgaWYgKHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MucmFkaXVzKSB7XG4gICAgICBzdWJqZWN0RGF0YS5yYWRpdXMgPSB0eXBlU2V0dGluZ3MucmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJqZWN0RGF0YS5yYWRpdXMgPSAxNDtcbiAgICB9XG4gIH1cbiAgaWYgKCFzdWJqZWN0RGF0YS54KSB7XG4gICAgaWYgKHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MueCkge1xuICAgICAgc3ViamVjdERhdGEueCA9IHR5cGVTZXR0aW5ncy54O1xuICAgIH1cbiAgfVxuICBpZiAoIXN1YmplY3REYXRhLnkpIHtcbiAgICBpZiAodHlwZVNldHRpbmdzICYmIHR5cGVTZXR0aW5ncy55KSB7XG4gICAgICBzdWJqZWN0RGF0YS55ID0gdHlwZVNldHRpbmdzLnk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIHJhZGl1cyA9IHN1YmplY3REYXRhLnJhZGl1cztcbiAgdmFyIGlubmVyUmFkaXVzID0gcmFkaXVzICogMC43O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICB2YXIgbm90Q29ybmVyT2Zmc2V0ID0gTWF0aC5zcXJ0KDIpICogcmFkaXVzO1xuICB2YXIgcGxhY2VtZW50ID0ge1xuICAgIHhsZWZ0Y29ybmVyOiAtcmFkaXVzLFxuICAgIHhyaWdodGNvcm5lcjogcmFkaXVzLFxuICAgIHl0b3Bjb3JuZXI6IC1yYWRpdXMsXG4gICAgeWJvdHRvbWNvcm5lcjogcmFkaXVzLFxuICAgIHhsZWZ0OiAtbm90Q29ybmVyT2Zmc2V0LFxuICAgIHhyaWdodDogbm90Q29ybmVyT2Zmc2V0LFxuICAgIHl0b3A6IC1ub3RDb3JuZXJPZmZzZXQsXG4gICAgeWJvdHRvbTogbm90Q29ybmVyT2Zmc2V0XG4gIH07XG5cbiAgaWYgKHN1YmplY3REYXRhLnggJiYgIXN1YmplY3REYXRhLnkpIHtcbiAgICB4ID0gcGxhY2VtZW50W1wieFwiICsgc3ViamVjdERhdGEueF07XG4gIH0gZWxzZSBpZiAoc3ViamVjdERhdGEueSAmJiAhc3ViamVjdERhdGEueCkge1xuICAgIHkgPSBwbGFjZW1lbnRbXCJ5XCIgKyBzdWJqZWN0RGF0YS55XTtcbiAgfSBlbHNlIGlmIChzdWJqZWN0RGF0YS54ICYmIHN1YmplY3REYXRhLnkpIHtcbiAgICB4ID0gcGxhY2VtZW50W1wieFwiICsgc3ViamVjdERhdGEueCArIFwiY29ybmVyXCJdO1xuICAgIHkgPSBwbGFjZW1lbnRbXCJ5XCIgKyBzdWJqZWN0RGF0YS55ICsgXCJjb3JuZXJcIl07XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiKVwiO1xuICB2YXIgY2lyY2xlYmcgPSBhcmNCdWlsZGVyKHsgY2xhc3NOYW1lOiBcInN1YmplY3RcIiwgZGF0YTogeyByYWRpdXM6IHJhZGl1cyB9IH0pO1xuICBjaXJjbGViZy5hdHRycy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIGNpcmNsZWJnLmF0dHJzLmZpbGwgPSBhbm5vdGF0aW9uLmNvbG9yO1xuICBjaXJjbGViZy5hdHRyc1tcInN0cm9rZS1saW5lY2FwXCJdID0gXCJyb3VuZFwiO1xuICBjaXJjbGViZy5hdHRyc1tcInN0cm9rZS13aWR0aFwiXSA9IFwiM3B4XCI7XG5cbiAgdmFyIGNpcmNsZSA9IGFyY0J1aWxkZXIoe1xuICAgIGNsYXNzTmFtZTogXCJzdWJqZWN0LXJpbmdcIixcbiAgICBkYXRhOiB7IG91dGVyUmFkaXVzOiByYWRpdXMsIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyB9XG4gIH0pO1xuXG4gIGNpcmNsZS5hdHRycy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIC8vIGNpcmNsZS5hdHRycy5maWxsID0gYW5ub3RhdGlvbi5jb2xvclxuICBjaXJjbGUuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gPSBcIjNweFwiO1xuICBjaXJjbGUuYXR0cnMuZmlsbCA9IFwid2hpdGVcIjtcblxuICB2YXIgcG9pbnRlciA9IHZvaWQgMDtcbiAgaWYgKHggJiYgeSB8fCAheCAmJiAheSkge1xuICAgIHBvaW50ZXIgPSBsaW5lQnVpbGRlcih7XG4gICAgICBjbGFzc05hbWU6IFwic3ViamVjdC1wb2ludGVyXCIsXG4gICAgICBkYXRhOiBbWzAsIDBdLCBbeCB8fCAwLCAwXSwgWzAsIHkgfHwgMF0sIFswLCAwXV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh4IHx8IHkpIHtcbiAgICB2YXIgbm90Q29ybmVyUG9pbnRlclhZID0gZnVuY3Rpb24gbm90Q29ybmVyUG9pbnRlclhZKHYpIHtcbiAgICAgIHZhciBzaWduID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgcmV0dXJuIHYgJiYgdiAvIE1hdGguc3FydCgyKSAvIE1hdGguc3FydCgyKSB8fCBzaWduICogcmFkaXVzIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH07XG5cbiAgICBwb2ludGVyID0gbGluZUJ1aWxkZXIoe1xuICAgICAgY2xhc3NOYW1lOiBcInN1YmplY3QtcG9pbnRlclwiLFxuICAgICAgZGF0YTogW1swLCAwXSwgW25vdENvcm5lclBvaW50ZXJYWSh4KSwgbm90Q29ybmVyUG9pbnRlclhZKHkpXSwgW25vdENvcm5lclBvaW50ZXJYWSh4LCAtMSksIG5vdENvcm5lclBvaW50ZXJYWSh5LCAtMSldLCBbMCwgMF1dXG4gICAgfSk7XG4gIH1cblxuICBpZiAocG9pbnRlcikge1xuICAgIHBvaW50ZXIuYXR0cnMuZmlsbCA9IGFubm90YXRpb24uY29sb3I7XG4gICAgcG9pbnRlci5hdHRyc1tcInN0cm9rZS1saW5lY2FwXCJdID0gXCJyb3VuZFwiO1xuICAgIHBvaW50ZXIuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gPSBcIjNweFwiO1xuICAgIGNvbXBvbmVudHMucHVzaChwb2ludGVyKTtcbiAgfVxuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIGRyYWdCYWRnZSA9IGZ1bmN0aW9uIGRyYWdCYWRnZSgpIHtcbiAgICAgIHN1YmplY3REYXRhLnggPSBldmVudC54IDwgLXJhZGl1cyAqIDIgPyBcImxlZnRcIiA6IGV2ZW50LnggPiByYWRpdXMgKiAyID8gXCJyaWdodFwiIDogdW5kZWZpbmVkO1xuICAgICAgc3ViamVjdERhdGEueSA9IGV2ZW50LnkgPCAtcmFkaXVzICogMiA/IFwidG9wXCIgOiBldmVudC55ID4gcmFkaXVzICogMiA/IFwiYm90dG9tXCIgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHR5cGUucmVkcmF3U3ViamVjdCgpO1xuICAgIH07XG5cbiAgICB2YXIgYkhhbmRsZXMgPSB7IHg6IHggKiAyLCB5OiB5ICogMiwgZHJhZzogZHJhZ0JhZGdlLmJpbmQodHlwZSkgfTtcbiAgICBpZiAoIWJIYW5kbGVzLnggJiYgIWJIYW5kbGVzLnkpIHtcbiAgICAgIGJIYW5kbGVzLnkgPSAtcmFkaXVzO1xuICAgIH1cblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMoW2JIYW5kbGVzXSk7XG4gIH1cblxuICB2YXIgdGV4dCA9IHZvaWQgMDtcbiAgaWYgKHN1YmplY3REYXRhLnRleHQpIHtcbiAgICB0ZXh0ID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBjbGFzc05hbWU6IFwiYmFkZ2UtdGV4dFwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgZmlsbDogXCJ3aGl0ZVwiLFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIi43ZW1cIixcbiAgICAgICAgdGV4dDogc3ViamVjdERhdGEudGV4dCxcbiAgICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBcIm1pZGRsZVwiLFxuICAgICAgICBkeTogXCIuMjVlbVwiLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudHMucHVzaChjaXJjbGViZyk7XG4gIGNvbXBvbmVudHMucHVzaChjaXJjbGUpO1xuICBjb21wb25lbnRzLnB1c2godGV4dCk7XG5cbiAgcmV0dXJuIHsgY29tcG9uZW50czogY29tcG9uZW50cywgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbi8vTm90ZSBvcHRpb25zXG4vL0Nvbm5lY3RvciBvcHRpb25zXG4vL1N1YmplY3Qgb3B0aW9uc1xudmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFR5cGUoX3JlZikge1xuICAgIHZhciBhID0gX3JlZi5hLFxuICAgICAgICBhbm5vdGF0aW9uID0gX3JlZi5hbm5vdGF0aW9uLFxuICAgICAgICBlZGl0TW9kZSA9IF9yZWYuZWRpdE1vZGUsXG4gICAgICAgIGRpc3BhdGNoZXIgPSBfcmVmLmRpc3BhdGNoZXIsXG4gICAgICAgIG5vdGVQYWRkaW5nID0gX3JlZi5ub3RlUGFkZGluZyxcbiAgICAgICAgYWNjZXNzb3JzID0gX3JlZi5hY2Nlc3NvcnM7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZSk7XG5cbiAgICB0aGlzLmEgPSBhO1xuXG4gICAgdGhpcy5ub3RlID0gYW5ub3RhdGlvbi5kaXNhYmxlLmluZGV4T2YoXCJub3RlXCIpID09PSAtMSAmJiBhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1ub3RlXCIpO1xuICAgIHRoaXMubm90ZUNvbnRlbnQgPSB0aGlzLm5vdGUgJiYgYS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgIHRoaXMuY29ubmVjdG9yID0gYW5ub3RhdGlvbi5kaXNhYmxlLmluZGV4T2YoXCJjb25uZWN0b3JcIikgPT09IC0xICYmIGEuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLWNvbm5lY3RvclwiKTtcbiAgICB0aGlzLnN1YmplY3QgPSBhbm5vdGF0aW9uLmRpc2FibGUuaW5kZXhPZihcInN1YmplY3RcIikgPT09IC0xICYmIGEuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLXN1YmplY3RcIik7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIGlmIChkaXNwYXRjaGVyKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGFkZEhhbmRsZXJzLmJpbmQobnVsbCwgZGlzcGF0Y2hlciwgYW5ub3RhdGlvbik7XG4gICAgICBoYW5kbGVyKHsgY29tcG9uZW50OiB0aGlzLm5vdGUsIG5hbWU6IFwibm90ZVwiIH0pO1xuICAgICAgaGFuZGxlcih7IGNvbXBvbmVudDogdGhpcy5jb25uZWN0b3IsIG5hbWU6IFwiY29ubmVjdG9yXCIgfSk7XG4gICAgICBoYW5kbGVyKHsgY29tcG9uZW50OiB0aGlzLnN1YmplY3QsIG5hbWU6IFwic3ViamVjdFwiIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG4gICAgdGhpcy5lZGl0TW9kZSA9IGFubm90YXRpb24uZWRpdE1vZGUgfHwgZWRpdE1vZGU7XG4gICAgdGhpcy5ub3RlUGFkZGluZyA9IG5vdGVQYWRkaW5nICE9PSB1bmRlZmluZWQgPyBub3RlUGFkZGluZyA6IDM7XG4gICAgdGhpcy5vZmZzZXRDb3JuZXJYID0gMDtcbiAgICB0aGlzLm9mZnNldENvcm5lclkgPSAwO1xuXG4gICAgaWYgKGFjY2Vzc29ycyAmJiBhbm5vdGF0aW9uLmRhdGEpIHtcbiAgICAgIHRoaXMuaW5pdChhY2Nlc3NvcnMpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGUsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChhY2Nlc3NvcnMpIHtcbiAgICAgIGlmICghdGhpcy5hbm5vdGF0aW9uLngpIHtcbiAgICAgICAgdGhpcy5tYXBYKGFjY2Vzc29ycyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbi55KSB7XG4gICAgICAgIHRoaXMubWFwWShhY2Nlc3NvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFkoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoYWNjZXNzb3JzLnkpIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uLnkgPSBhY2Nlc3NvcnMueSh0aGlzLmFubm90YXRpb24uZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWChhY2Nlc3NvcnMpIHtcbiAgICAgIGlmIChhY2Nlc3NvcnMueCkge1xuICAgICAgICB0aGlzLmFubm90YXRpb24ueCA9IGFjY2Vzc29ycy54KHRoaXMuYW5ub3RhdGlvbi5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmEuc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5yZW1vdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd09uU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdPblNWRyhjb21wb25lbnQsIGJ1aWxkZXJzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYnVpbGRlcnMpKSB7XG4gICAgICAgIGJ1aWxkZXJzID0gW2J1aWxkZXJzXTtcbiAgICAgIH1cblxuICAgICAgYnVpbGRlcnMuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmMi50eXBlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgICAgICAgYXR0cnMgPSBfcmVmMi5hdHRycyxcbiAgICAgICAgICAgIGhhbmRsZXMgPSBfcmVmMi5oYW5kbGVzLFxuICAgICAgICAgICAgY2xhc3NJRCA9IF9yZWYyLmNsYXNzSUQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaGFuZGxlXCIpIHtcbiAgICAgICAgICBhZGRIYW5kbGVzKHsgZ3JvdXA6IGNvbXBvbmVudCwgcjogYXR0cnMgJiYgYXR0cnMuciwgaGFuZGxlczogaGFuZGxlcyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdXaXRoQ2xhc3MoY29tcG9uZW50LCBbX3RoaXMuYW5ub3RhdGlvbl0sIHR5cGUsIGNsYXNzTmFtZSwgY2xhc3NJRCk7XG4gICAgICAgICAgdmFyIGVsID0gY29tcG9uZW50LnNlbGVjdCh0eXBlICsgXCIuXCIgKyAoY2xhc3NJRCB8fCBjbGFzc05hbWUpKTtcbiAgICAgICAgICB2YXIgYWRkQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgICAgdmFyIHJlbW92ZUF0dHJzID0gW107XG5cbiAgICAgICAgICB2YXIgY3VycmVudEF0dHJzID0gZWwubm9kZSgpLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBjdXJyZW50QXR0cnNbaV0ubmFtZTtcbiAgICAgICAgICAgIGlmIChhZGRBdHRycy5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBuYW1lICE9PSBcImNsYXNzXCIpIHJlbW92ZUF0dHJzLnB1c2gobmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgIGVsLnRleHQoYXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwuYXR0cihhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZW1vdmVBdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihhdHRyLCBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy9UT0RPOiBob3cgdG8gZXh0ZW5kIHRoaXMgdG8gYSBkcmF3T25DYW52YXMgbW9kZT9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5vdGVCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vdGVCQm94KCkge1xuICAgICAgcmV0dXJuIGJib3hXaXRob3V0SGFuZGxlcyh0aGlzLm5vdGUsIFwiLmFubm90YXRpb24tbm90ZS1jb250ZW50IHRleHRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5vdGVCQm94T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vdGVCQm94T2Zmc2V0KCkge1xuICAgICAgdmFyIGJib3ggPSBiYm94V2l0aG91dEhhbmRsZXModGhpcy5ub3RlLCBcIi5hbm5vdGF0aW9uLW5vdGUtY29udGVudFwiKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLm5vdGVDb250ZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIikuc3BsaXQoL1xcKHxcXCx8XFwpL2cpO1xuICAgICAgYmJveC5vZmZzZXRDb3JuZXJYID0gcGFyc2VGbG9hdCh0cmFuc2Zvcm1bMV0pICsgdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgYmJveC5vZmZzZXRDb3JuZXJZID0gcGFyc2VGbG9hdCh0cmFuc2Zvcm1bMl0pICsgdGhpcy5hbm5vdGF0aW9uLmR5O1xuICAgICAgYmJveC5vZmZzZXRYID0gdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgYmJveC5vZmZzZXRZID0gdGhpcy5hbm5vdGF0aW9uLmR5O1xuICAgICAgcmV0dXJuIGJib3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTdWJqZWN0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdmFyIHN1YmplY3REYXRhID0gdGhpcy5hbm5vdGF0aW9uLnN1YmplY3Q7XG4gICAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICAgIHZhciBzdWJqZWN0UGFyYW1zID0geyB0eXBlOiB0aGlzLCBzdWJqZWN0RGF0YTogc3ViamVjdERhdGEgfTtcblxuICAgICAgdmFyIHN1YmplY3QgPSB7fTtcbiAgICAgIGlmICh0eXBlID09PSBcImNpcmNsZVwiKSBzdWJqZWN0ID0gc3ViamVjdENpcmNsZShzdWJqZWN0UGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcInJlY3RcIikgc3ViamVjdCA9IHN1YmplY3RSZWN0KHN1YmplY3RQYXJhbXMpO2Vsc2UgaWYgKHR5cGUgPT09IFwidGhyZXNob2xkXCIpIHN1YmplY3QgPSBzdWJqZWN0VGhyZXNob2xkKHN1YmplY3RQYXJhbXMpO2Vsc2UgaWYgKHR5cGUgPT09IFwiYmFkZ2VcIikgc3ViamVjdCA9IHN1YmplY3RCYWRnZShzdWJqZWN0UGFyYW1zLCB0aGlzLmFubm90YXRpb24pO1xuXG4gICAgICB2YXIgX3N1YmplY3QgPSBzdWJqZWN0LFxuICAgICAgICAgIF9zdWJqZWN0JGNvbXBvbmVudHMgPSBfc3ViamVjdC5jb21wb25lbnRzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfc3ViamVjdCRjb21wb25lbnRzID09PSB1bmRlZmluZWQgPyBbXSA6IF9zdWJqZWN0JGNvbXBvbmVudHMsXG4gICAgICAgICAgX3N1YmplY3QkaGFuZGxlcyA9IF9zdWJqZWN0LmhhbmRsZXMsXG4gICAgICAgICAgaGFuZGxlcyA9IF9zdWJqZWN0JGhhbmRsZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX3N1YmplY3QkaGFuZGxlcztcblxuICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICYmIGMuYXR0cnMgJiYgIWMuYXR0cnMuc3Ryb2tlKSB7XG4gICAgICAgICAgYy5hdHRycy5zdHJva2UgPSBfdGhpczIuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdCh0aGlzLm1hcEhhbmRsZXMoW3sgZHJhZzogdGhpcy5kcmFnU3ViamVjdC5iaW5kKHRoaXMpIH1dKSk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7IHR5cGU6IFwiaGFuZGxlXCIsIGhhbmRsZXM6IGhhbmRsZXMgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q29ubmVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDb25uZWN0b3IoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICB2YXIgY29ubmVjdG9yRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5jb25uZWN0b3I7XG4gICAgICB2YXIgdHlwZSA9IGNvbm5lY3RvckRhdGEudHlwZSB8fCBjb250ZXh0LnR5cGU7XG4gICAgICB2YXIgY29ubmVjdG9yUGFyYW1zID0geyB0eXBlOiB0aGlzLCBjb25uZWN0b3JEYXRhOiBjb25uZWN0b3JEYXRhIH07XG4gICAgICBjb25uZWN0b3JQYXJhbXMuc3ViamVjdFR5cGUgPSB0aGlzLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnR5cGVTZXR0aW5ncy5zdWJqZWN0ICYmIHRoaXMudHlwZVNldHRpbmdzLnN1YmplY3QudHlwZTtcblxuICAgICAgdmFyIGNvbm5lY3RvciA9IHt9O1xuICAgICAgaWYgKHR5cGUgPT09IFwiY3VydmVcIikgY29ubmVjdG9yID0gY29ubmVjdG9yQ3VydmUoY29ubmVjdG9yUGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcImVsYm93XCIpIGNvbm5lY3RvciA9IGNvbm5lY3RvckVsYm93KGNvbm5lY3RvclBhcmFtcyk7ZWxzZSBjb25uZWN0b3IgPSBjb25uZWN0b3JMaW5lKGNvbm5lY3RvclBhcmFtcyk7XG4gICAgICB2YXIgX2Nvbm5lY3RvciA9IGNvbm5lY3RvcixcbiAgICAgICAgICBfY29ubmVjdG9yJGNvbXBvbmVudHMgPSBfY29ubmVjdG9yLmNvbXBvbmVudHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF9jb25uZWN0b3IkY29tcG9uZW50cyA9PT0gdW5kZWZpbmVkID8gW10gOiBfY29ubmVjdG9yJGNvbXBvbmVudHMsXG4gICAgICAgICAgX2Nvbm5lY3RvciRoYW5kbGVzID0gX2Nvbm5lY3Rvci5oYW5kbGVzLFxuICAgICAgICAgIGhhbmRsZXMgPSBfY29ubmVjdG9yJGhhbmRsZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX2Nvbm5lY3RvciRoYW5kbGVzO1xuXG4gICAgICB2YXIgbGluZSQkMSA9IGNvbXBvbmVudHNbMF07XG4gICAgICAvL1RPRE86IGdlbmVyaWNpemUgdGhpcyBpbnRvIGZpbGwgdC9mIHN0cm9rZSB0L2ZcbiAgICAgIGlmIChsaW5lJCQxKSB7XG4gICAgICAgIGxpbmUkJDEuYXR0cnMuc3Ryb2tlID0gdGhpcy5hbm5vdGF0aW9uLmNvbG9yO1xuICAgICAgICBsaW5lJCQxLmF0dHJzLmZpbGwgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRUeXBlID0gY29ubmVjdG9yRGF0YS5lbmQgfHwgY29udGV4dC5lbmQ7XG4gICAgICB2YXIgZW5kID0ge307XG4gICAgICBpZiAoZW5kVHlwZSA9PT0gXCJhcnJvd1wiKSB7XG4gICAgICAgIHZhciBzID0gbGluZSQkMS5kYXRhWzFdO1xuICAgICAgICB2YXIgZSA9IGxpbmUkJDEuZGF0YVswXTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHNbMF0gLSBlWzBdLCAyKSArIE1hdGgucG93KHNbMV0gLSBlWzFdLCAyKSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IDUgJiYgbGluZSQkMS5kYXRhWzJdKSB7XG4gICAgICAgICAgcyA9IGxpbmUkJDEuZGF0YVsyXTtcbiAgICAgICAgfVxuICAgICAgICBlbmQgPSBjb25uZWN0b3JBcnJvdyh7XG4gICAgICAgICAgYW5ub3RhdGlvbjogdGhpcy5hbm5vdGF0aW9uLFxuICAgICAgICAgIHN0YXJ0OiBzLFxuICAgICAgICAgIGVuZDogZSxcbiAgICAgICAgICBzY2FsZTogY29ubmVjdG9yRGF0YS5lbmRTY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kVHlwZSA9PT0gXCJkb3RcIikge1xuICAgICAgICBlbmQgPSBjb25uZWN0b3JEb3QoeyBsaW5lOiBsaW5lJCQxLCBzY2FsZTogY29ubmVjdG9yRGF0YS5lbmRTY2FsZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVuZFR5cGUgfHwgZW5kVHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5jb25uZWN0b3Iuc2VsZWN0KFwiLmNvbm5lY3Rvci1lbmRcIikucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQuY29tcG9uZW50cykge1xuICAgICAgICBlbmQuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYy5hdHRycy5maWxsID0gX3RoaXMzLmFubm90YXRpb24uY29sb3I7XG4gICAgICAgICAgYy5hdHRycy5zdHJva2UgPSBfdGhpczMuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbXBvbmVudHMgPSBjb21wb25lbnRzLmNvbmNhdChlbmQuY29tcG9uZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGlmIChoYW5kbGVzLmxlbmd0aCAhPT0gMCkgY29tcG9uZW50cy5wdXNoKHsgdHlwZTogXCJoYW5kbGVcIiwgaGFuZGxlczogaGFuZGxlcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Tm90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Tm90ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHZhciBub3RlRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlO1xuICAgICAgdmFyIGFsaWduID0gbm90ZURhdGEuYWxpZ24gfHwgY29udGV4dC5hbGlnbiB8fCBcImR5bmFtaWNcIjtcbiAgICAgIHZhciBub3RlUGFyYW1zID0ge1xuICAgICAgICBiYm94OiBjb250ZXh0LmJib3gsXG4gICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmFubm90YXRpb24ub2Zmc2V0XG4gICAgICB9O1xuICAgICAgdmFyIGxpbmVUeXBlID0gbm90ZURhdGEubGluZVR5cGUgfHwgY29udGV4dC5saW5lVHlwZTtcbiAgICAgIHZhciBub3RlID0ge307XG4gICAgICBpZiAobGluZVR5cGUgPT09IFwidmVydGljYWxcIikgbm90ZSA9IG5vdGVWZXJ0aWNhbChub3RlUGFyYW1zKTtlbHNlIGlmIChsaW5lVHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIG5vdGUgPSBub3RlSG9yaXpvbnRhbChub3RlUGFyYW1zKTtcblxuICAgICAgdmFyIF9ub3RlID0gbm90ZSxcbiAgICAgICAgICBfbm90ZSRjb21wb25lbnRzID0gX25vdGUuY29tcG9uZW50cyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX25vdGUkY29tcG9uZW50cyA9PT0gdW5kZWZpbmVkID8gW10gOiBfbm90ZSRjb21wb25lbnRzLFxuICAgICAgICAgIF9ub3RlJGhhbmRsZXMgPSBfbm90ZS5oYW5kbGVzLFxuICAgICAgICAgIGhhbmRsZXMgPSBfbm90ZSRoYW5kbGVzID09PSB1bmRlZmluZWQgPyBbXSA6IF9ub3RlJGhhbmRsZXM7XG5cbiAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBjLmF0dHJzLnN0cm9rZSA9IF90aGlzNC5hbm5vdGF0aW9uLmNvbG9yO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGhhbmRsZXMgPSB0aGlzLm1hcEhhbmRsZXMoW3sgeDogMCwgeTogMCwgZHJhZzogdGhpcy5kcmFnTm90ZS5iaW5kKHRoaXMpIH1dKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHsgdHlwZTogXCJoYW5kbGVcIiwgaGFuZGxlczogaGFuZGxlcyB9KTtcblxuICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLmRyYWdOb3RlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuZHJhZ3N0YXJ0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuZHJhZ2VuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubm90ZS5jYWxsKGRyYWcoKS5jb250YWluZXIoc2VsZWN0KFwiZy5hbm5vdGF0aW9uc1wiKS5ub2RlKCkpLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnQoZCk7XG4gICAgICAgIH0pLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkcmFnZ2luZyhkKTtcbiAgICAgICAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZW5kKGQpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vdGUub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Tm90ZUNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGVDb250ZW50KGNvbnRleHQpIHtcbiAgICAgIHZhciBub3RlRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlO1xuICAgICAgdmFyIHBhZGRpbmcgPSBub3RlRGF0YS5wYWRkaW5nICE9PSB1bmRlZmluZWQgPyBub3RlRGF0YS5wYWRkaW5nIDogdGhpcy5ub3RlUGFkZGluZztcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IG5vdGVEYXRhLm9yaWVudGF0aW9uIHx8IGNvbnRleHQub3JpZW50YXRpb24gfHwgXCJ0b3BCb3R0b21cIjtcbiAgICAgIHZhciBsaW5lVHlwZSA9IG5vdGVEYXRhLmxpbmVUeXBlIHx8IGNvbnRleHQubGluZVR5cGU7XG4gICAgICB2YXIgYWxpZ24gPSBub3RlRGF0YS5hbGlnbiB8fCBjb250ZXh0LmFsaWduIHx8IFwiZHluYW1pY1wiO1xuXG4gICAgICBpZiAobGluZVR5cGUgPT09IFwidmVydGljYWxcIikgb3JpZW50YXRpb24gPSBcImxlZnRSaWdodFwiO2Vsc2UgaWYgKGxpbmVUeXBlID09PSBcImhvcml6b250YWxcIikgb3JpZW50YXRpb24gPSBcInRvcEJvdHRvbVwiO1xuXG4gICAgICB2YXIgbm90ZVBhcmFtcyA9IHtcbiAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgYmJveDogY29udGV4dC5iYm94LFxuICAgICAgICBvZmZzZXQ6IHRoaXMuYW5ub3RhdGlvbi5vZmZzZXQsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcbiAgICAgICAgYWxpZ246IGFsaWduXG4gICAgICB9O1xuXG4gICAgICB2YXIgX25vdGVBbGlnbm1lbnQgPSBub3RlQWxpZ25tZW50KG5vdGVQYXJhbXMpLFxuICAgICAgICAgIHggPSBfbm90ZUFsaWdubWVudC54LFxuICAgICAgICAgIHkgPSBfbm90ZUFsaWdubWVudC55O1xuXG4gICAgICB0aGlzLm9mZnNldENvcm5lclggPSB4ICsgdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgdGhpcy5vZmZzZXRDb3JuZXJZID0geSArIHRoaXMuYW5ub3RhdGlvbi5keTtcbiAgICAgIHRoaXMubm90ZSAmJiB0aGlzLm5vdGVDb250ZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiKVwiKTtcblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3T25TY3JlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd09uU2NyZWVuKGNvbXBvbmVudCwgZHJhd0Z1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3T25TVkcoY29tcG9uZW50LCBkcmF3RnVuY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhd1N1YmplY3QoKSB7XG4gICAgICB0aGlzLnN1YmplY3QgJiYgdGhpcy5kcmF3T25TY3JlZW4odGhpcy5zdWJqZWN0LCB0aGlzLmRyYXdTdWJqZWN0KCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdDb25uZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3Q29ubmVjdG9yKCkge1xuICAgICAgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5kcmF3T25TY3JlZW4odGhpcy5jb25uZWN0b3IsIHRoaXMuZHJhd0Nvbm5lY3RvcigpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3Tm90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXdOb3RlKCkge1xuICAgICAgdmFyIGJib3ggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuZ2V0Tm90ZUJCb3goKTtcblxuICAgICAgdGhpcy5ub3RlQ29udGVudCAmJiB0aGlzLmRyYXdPblNjcmVlbih0aGlzLm5vdGVDb250ZW50LCB0aGlzLmRyYXdOb3RlQ29udGVudCh7IGJib3g6IGJib3ggfSkpO1xuICAgICAgdGhpcy5ub3RlICYmIHRoaXMuZHJhd09uU2NyZWVuKHRoaXMubm90ZSwgdGhpcy5kcmF3Tm90ZSh7IGJib3g6IGJib3ggfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYW5ub3RhdGlvbi5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcG9zaXRpb24ueCArIFwiLCBcIiArIHBvc2l0aW9uLnkgKyBcIilcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQ29tcG9uZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLnN1YmplY3QgJiYgdGhpcy5zdWJqZWN0LnNlbGVjdChcIipcIikucmVtb3ZlKCk7XG4gICAgICB0aGlzLmNvbm5lY3RvciAmJiB0aGlzLmNvbm5lY3Rvci5zZWxlY3QoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgLy8gdGhpcy5ub3RlICYmIHRoaXMubm90ZS5zZWxlY3QoXCIqXCIpLnJlbW92ZSgpXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy5ub3RlKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmFubm90YXRpb24ub2Zmc2V0O1xuICAgICAgICB0aGlzLm5vdGUuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG9mZnNldC54ICsgXCIsIFwiICsgb2Zmc2V0LnkgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uV2l0aEFjY2Vzc29yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbldpdGhBY2Nlc3NvcnMoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoYWNjZXNzb3JzICYmIHRoaXMuYW5ub3RhdGlvbi5kYXRhKSB7XG4gICAgICAgIHRoaXMubWFwWChhY2Nlc3NvcnMpO1xuICAgICAgICB0aGlzLm1hcFkoYWNjZXNzb3JzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2xhc3NOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENsYXNzTmFtZSgpIHtcbiAgICAgIHRoaXMuYS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uIFwiICsgKHRoaXMuY2xhc3NOYW1lICYmIHRoaXMuY2xhc3NOYW1lKCkpICsgXCIgXCIgKyAodGhpcy5lZGl0TW9kZSA/IFwiZWRpdGFibGVcIiA6IFwiXCIpICsgXCIgXCIgKyAodGhpcy5hbm5vdGF0aW9uLmNsYXNzTmFtZSB8fCBcIlwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lKCk7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnNldE9mZnNldCgpO1xuICAgICAgdGhpcy5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0aGlzLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgICAgdGhpcy5yZWRyYXdOb3RlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdzdGFydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdzdGFydGVkKCkge1xuICAgICAgZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmRpc3BhdGNoZXIgJiYgdGhpcy5kaXNwYXRjaGVyLmNhbGwoXCJkcmFnc3RhcnRcIiwgdGhpcy5hLCB0aGlzLmFubm90YXRpb24pO1xuICAgICAgdGhpcy5hLmNsYXNzZWQoXCJkcmFnZ2luZ1wiLCB0cnVlKTtcbiAgICAgIHRoaXMuYS5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnZW5kZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ2VuZGVkKCkge1xuICAgICAgdGhpcy5kaXNwYXRjaGVyICYmIHRoaXMuZGlzcGF0Y2hlci5jYWxsKFwiZHJhZ2VuZFwiLCB0aGlzLmEsIHRoaXMuYW5ub3RhdGlvbik7XG4gICAgICB0aGlzLmEuY2xhc3NlZChcImRyYWdnaW5nXCIsIGZhbHNlKTtcbiAgICAgIHRoaXMuYS5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdTdWJqZWN0KCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5hbm5vdGF0aW9uLnBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24ueCArPSBldmVudC5keDtcbiAgICAgIHBvc2l0aW9uLnkgKz0gZXZlbnQuZHk7XG4gICAgICB0aGlzLmFubm90YXRpb24ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhZ05vdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ05vdGUoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5hbm5vdGF0aW9uLm9mZnNldDtcbiAgICAgIG9mZnNldC54ICs9IGV2ZW50LmR4O1xuICAgICAgb2Zmc2V0LnkgKz0gZXZlbnQuZHk7XG4gICAgICB0aGlzLmFubm90YXRpb24ub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBIYW5kbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcEhhbmRsZXMoaGFuZGxlcykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBoYW5kbGVzLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGgsIHtcbiAgICAgICAgICBzdGFydDogX3RoaXM1LmRyYWdzdGFydGVkLmJpbmQoX3RoaXM1KSxcbiAgICAgICAgICBlbmQ6IF90aGlzNS5kcmFnZW5kZWQuYmluZChfdGhpczUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlO1xufSgpO1xuXG52YXIgY3VzdG9tVHlwZSA9IGZ1bmN0aW9uIGN1c3RvbVR5cGUoaW5pdGlhbFR5cGUsIHR5cGVTZXR0aW5ncywgX2luaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfaW5pdGlhbFR5cGUpIHtcbiAgICBpbmhlcml0cyhjdXN0b21UeXBlLCBfaW5pdGlhbFR5cGUpO1xuXG4gICAgZnVuY3Rpb24gY3VzdG9tVHlwZShzZXR0aW5ncykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgY3VzdG9tVHlwZSk7XG5cbiAgICAgIHZhciBfdGhpczYgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChjdXN0b21UeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZSkpLmNhbGwodGhpcywgc2V0dGluZ3MpKTtcblxuICAgICAgX3RoaXM2LnR5cGVTZXR0aW5ncyA9IHR5cGVTZXR0aW5ncztcblxuICAgICAgaWYgKHR5cGVTZXR0aW5ncy5kaXNhYmxlKSB7XG4gICAgICAgIHR5cGVTZXR0aW5ncy5kaXNhYmxlLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBfdGhpczZbZF0gJiYgX3RoaXM2W2RdLnJlbW92ZSgpO1xuXG4gICAgICAgICAgX3RoaXM2W2RdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChkID09PSBcIm5vdGVcIikge1xuICAgICAgICAgICAgX3RoaXM2Lm5vdGVDb250ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXM2O1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKGN1c3RvbVR5cGUsIFt7XG4gICAgICBrZXk6IFwiY2xhc3NOYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJcIiArICh0eXBlU2V0dGluZ3MuY2xhc3NOYW1lIHx8IGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJjbGFzc05hbWVcIiwgdGhpcykgJiYgZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImNsYXNzTmFtZVwiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IFwiXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3U3ViamVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTdWJqZWN0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCA9IF9leHRlbmRzKHt9LCB0eXBlU2V0dGluZ3Muc3ViamVjdCwgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCk7XG4gICAgICAgIHJldHVybiBnZXQoY3VzdG9tVHlwZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXN0b21UeXBlLnByb3RvdHlwZSksIFwiZHJhd1N1YmplY3RcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Q29ubmVjdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Nvbm5lY3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHlwZVNldHRpbmdzLmNvbm5lY3RvciA9IF9leHRlbmRzKHt9LCB0eXBlU2V0dGluZ3MuY29ubmVjdG9yLCB0aGlzLnR5cGVTZXR0aW5ncy5jb25uZWN0b3IpO1xuICAgICAgICByZXR1cm4gZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImRyYXdDb25uZWN0b3JcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdHlwZVNldHRpbmdzLmNvbm5lY3RvciwgdGhpcy50eXBlU2V0dGluZ3MuY29ubmVjdG9yKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdOb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGUoY29udGV4dCkge1xuICAgICAgICB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlID0gX2V4dGVuZHMoe30sIHR5cGVTZXR0aW5ncy5ub3RlLCB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlKTtcbiAgICAgICAgcmV0dXJuIGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJkcmF3Tm90ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIF9leHRlbmRzKHt9LCBjb250ZXh0LCB0eXBlU2V0dGluZ3Mubm90ZSwgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Tm90ZUNvbnRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Tm90ZUNvbnRlbnQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImRyYXdOb3RlQ29udGVudFwiLCB0aGlzKS5jYWxsKHRoaXMsIF9leHRlbmRzKHt9LCBjb250ZXh0LCB0eXBlU2V0dGluZ3Mubm90ZSwgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSkpO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGFubm90YXRpb24sIGFjY2Vzc29ycykge1xuICAgICAgICBnZXQoY3VzdG9tVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBhbm5vdGF0aW9uLCBhY2Nlc3NvcnMpO1xuICAgICAgICBpZiAoX2luaXQpIHtcbiAgICAgICAgICBhbm5vdGF0aW9uID0gX2luaXQoYW5ub3RhdGlvbiwgYWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIGN1c3RvbVR5cGU7XG4gIH0oaW5pdGlhbFR5cGUpO1xufTtcblxudmFyIGQzTm90ZVRleHQgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoZDNOb3RlVGV4dCwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIGQzTm90ZVRleHQocGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgZDNOb3RlVGV4dCk7XG5cbiAgICB2YXIgX3RoaXM3ID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoZDNOb3RlVGV4dC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGQzTm90ZVRleHQpKS5jYWxsKHRoaXMsIHBhcmFtcykpO1xuXG4gICAgX3RoaXM3LnRleHRXcmFwID0gcGFyYW1zLnRleHRXcmFwIHx8IDEyMDtcbiAgICBfdGhpczcuZHJhd1RleHQoKTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoZDNOb3RlVGV4dCwgW3tcbiAgICBrZXk6IFwidXBkYXRlVGV4dFdyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGV4dFdyYXAodGV4dFdyYXApIHtcbiAgICAgIHRoaXMudGV4dFdyYXAgPSB0ZXh0V3JhcDtcbiAgICAgIHRoaXMuZHJhd1RleHQoKTtcbiAgICB9XG5cbiAgICAvL1RPRE86IGFkZCB1cGRhdGUgdGV4dCBmdW5jdGlvbmFsaXR5XG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLm5vdGUpIHtcbiAgICAgICAgbmV3V2l0aENsYXNzKHRoaXMubm90ZSwgW3RoaXMuYW5ub3RhdGlvbl0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuXG4gICAgICAgIHZhciBub3RlQ29udGVudCA9IHRoaXMubm90ZS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgICAgICBuZXdXaXRoQ2xhc3Mobm90ZUNvbnRlbnQsIFt0aGlzLmFubm90YXRpb25dLCBcInJlY3RcIiwgXCJhbm5vdGF0aW9uLW5vdGUtYmdcIik7XG4gICAgICAgIG5ld1dpdGhDbGFzcyhub3RlQ29udGVudCwgW3RoaXMuYW5ub3RhdGlvbl0sIFwidGV4dFwiLCBcImFubm90YXRpb24tbm90ZS1sYWJlbFwiKTtcbiAgICAgICAgbmV3V2l0aENsYXNzKG5vdGVDb250ZW50LCBbdGhpcy5hbm5vdGF0aW9uXSwgXCJ0ZXh0XCIsIFwiYW5ub3RhdGlvbi1ub3RlLXRpdGxlXCIpO1xuXG4gICAgICAgIHZhciB0aXRsZUJCb3ggPSB7IGhlaWdodDogMCB9O1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmEuc2VsZWN0KFwidGV4dC5hbm5vdGF0aW9uLW5vdGUtbGFiZWxcIik7XG4gICAgICAgIHZhciB3cmFwTGVuZ3RoID0gdGhpcy5hbm5vdGF0aW9uLm5vdGUgJiYgdGhpcy5hbm5vdGF0aW9uLm5vdGUud3JhcCB8fCB0aGlzLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUud3JhcCB8fCB0aGlzLnRleHRXcmFwO1xuXG4gICAgICAgIHZhciB3cmFwU3BsaXR0ZXIgPSB0aGlzLmFubm90YXRpb24ubm90ZSAmJiB0aGlzLmFubm90YXRpb24ubm90ZS53cmFwU3BsaXR0ZXIgfHwgdGhpcy50eXBlU2V0dGluZ3MgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlLndyYXBTcGxpdHRlcjtcblxuICAgICAgICB2YXIgYmdQYWRkaW5nID0gdGhpcy5hbm5vdGF0aW9uLm5vdGUgJiYgdGhpcy5hbm5vdGF0aW9uLm5vdGUuYmdQYWRkaW5nIHx8IHRoaXMudHlwZVNldHRpbmdzICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZS5iZ1BhZGRpbmc7XG5cbiAgICAgICAgdmFyIGJnUGFkZGluZ0ZpbmFsID0geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBiZ1BhZGRpbmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBiZ1BhZGRpbmdGaW5hbCA9IHtcbiAgICAgICAgICAgIHRvcDogYmdQYWRkaW5nLFxuICAgICAgICAgICAgYm90dG9tOiBiZ1BhZGRpbmcsXG4gICAgICAgICAgICBsZWZ0OiBiZ1BhZGRpbmcsXG4gICAgICAgICAgICByaWdodDogYmdQYWRkaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChiZ1BhZGRpbmcgJiYgKHR5cGVvZiBiZ1BhZGRpbmcgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihiZ1BhZGRpbmcpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGJnUGFkZGluZ0ZpbmFsID0gX2V4dGVuZHMoYmdQYWRkaW5nRmluYWwsIGJnUGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uLm5vdGUudGl0bGUpIHtcbiAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmEuc2VsZWN0KFwidGV4dC5hbm5vdGF0aW9uLW5vdGUtdGl0bGVcIik7XG4gICAgICAgICAgdGl0bGUudGV4dCh0aGlzLmFubm90YXRpb24ubm90ZS50aXRsZSk7XG4gICAgICAgICAgdGl0bGUuYXR0cihcImZpbGxcIiwgdGhpcy5hbm5vdGF0aW9uLmNvbG9yKTtcbiAgICAgICAgICB0aXRsZS5hdHRyKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpO1xuICAgICAgICAgIHRpdGxlLmNhbGwod3JhcCwgd3JhcExlbmd0aCwgd3JhcFNwbGl0dGVyKTtcbiAgICAgICAgICB0aXRsZUJCb3ggPSB0aXRsZS5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwudGV4dCh0aGlzLmFubm90YXRpb24ubm90ZS5sYWJlbCkuYXR0cihcImR4XCIsIFwiMFwiKTtcbiAgICAgICAgbGFiZWwuY2FsbCh3cmFwLCB3cmFwTGVuZ3RoLCB3cmFwU3BsaXR0ZXIpO1xuXG4gICAgICAgIGxhYmVsLmF0dHIoXCJ5XCIsIHRpdGxlQkJveC5oZWlnaHQgKiAxLjEgfHwgMCk7XG4gICAgICAgIGxhYmVsLmF0dHIoXCJmaWxsXCIsIHRoaXMuYW5ub3RhdGlvbi5jb2xvcik7XG5cbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldE5vdGVCQm94KCk7XG5cbiAgICAgICAgdGhpcy5hLnNlbGVjdChcInJlY3QuYW5ub3RhdGlvbi1ub3RlLWJnXCIpLmF0dHIoXCJ3aWR0aFwiLCBiYm94LndpZHRoICsgYmdQYWRkaW5nRmluYWwubGVmdCArIGJnUGFkZGluZ0ZpbmFsLnJpZ2h0KS5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0ICsgYmdQYWRkaW5nRmluYWwudG9wICsgYmdQYWRkaW5nRmluYWwuYm90dG9tKS5hdHRyKFwieFwiLCBiYm94LnggLSBiZ1BhZGRpbmdGaW5hbC5sZWZ0KS5hdHRyKFwieVwiLCAtYmdQYWRkaW5nRmluYWwudG9wKS5hdHRyKFwiZmlsbFwiLCBcIndoaXRlXCIpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBkM05vdGVUZXh0O1xufShUeXBlKTtcblxudmFyIGQzTGFiZWwgPSBjdXN0b21UeXBlKGQzTm90ZVRleHQsIHtcbiAgY2xhc3NOYW1lOiBcImxhYmVsXCIsXG4gIG5vdGU6IHsgYWxpZ246IFwibWlkZGxlXCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXQgPSBjdXN0b21UeXBlKGQzTm90ZVRleHQsIHtcbiAgY2xhc3NOYW1lOiBcImNhbGxvdXRcIixcbiAgbm90ZTogeyBsaW5lVHlwZTogXCJob3Jpem9udGFsXCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRFbGJvdyA9IGN1c3RvbVR5cGUoZDNDYWxsb3V0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IGVsYm93XCIsXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImVsYm93XCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRDdXJ2ZSA9IGN1c3RvbVR5cGUoZDNDYWxsb3V0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IGN1cnZlXCIsXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImN1cnZlXCIgfVxufSk7XG5cbnZhciBkM0JhZGdlID0gY3VzdG9tVHlwZShUeXBlLCB7XG4gIGNsYXNzTmFtZTogXCJiYWRnZVwiLFxuICBzdWJqZWN0OiB7IHR5cGU6IFwiYmFkZ2VcIiB9LFxuICBkaXNhYmxlOiBbXCJjb25uZWN0b3JcIiwgXCJub3RlXCJdXG59KTtcblxudmFyIGQzQ2FsbG91dENpcmNsZSA9IGN1c3RvbVR5cGUoZDNOb3RlVGV4dCwge1xuICBjbGFzc05hbWU6IFwiY2FsbG91dCBjaXJjbGVcIixcbiAgc3ViamVjdDogeyB0eXBlOiBcImNpcmNsZVwiIH0sXG4gIG5vdGU6IHsgbGluZVR5cGU6IFwiaG9yaXpvbnRhbFwiIH0sXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImVsYm93XCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRSZWN0ID0gY3VzdG9tVHlwZShkM05vdGVUZXh0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IHJlY3RcIixcbiAgc3ViamVjdDogeyB0eXBlOiBcInJlY3RcIiB9LFxuICBub3RlOiB7IGxpbmVUeXBlOiBcImhvcml6b250YWxcIiB9LFxuICBjb25uZWN0b3I6IHsgdHlwZTogXCJlbGJvd1wiIH1cbn0pO1xuXG52YXIgVGhyZXNob2xkTWFwID0gZnVuY3Rpb24gKF9kM0NhbGxvdXQpIHtcbiAgaW5oZXJpdHMoVGhyZXNob2xkTWFwLCBfZDNDYWxsb3V0KTtcblxuICBmdW5jdGlvbiBUaHJlc2hvbGRNYXAoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhyZXNob2xkTWFwKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGhyZXNob2xkTWFwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhyZXNob2xkTWFwKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUaHJlc2hvbGRNYXAsIFt7XG4gICAga2V5OiBcIm1hcFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWShhY2Nlc3NvcnMpIHtcbiAgICAgIGdldChUaHJlc2hvbGRNYXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhyZXNob2xkTWFwLnByb3RvdHlwZSksIFwibWFwWVwiLCB0aGlzKS5jYWxsKHRoaXMsIGFjY2Vzc29ycyk7XG4gICAgICB2YXIgYSA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgIGlmICgoYS5zdWJqZWN0LngxIHx8IGEuc3ViamVjdC54MikgJiYgYS5kYXRhICYmIGFjY2Vzc29ycy55KSB7XG4gICAgICAgIGEueSA9IGFjY2Vzc29ycy55KGEuZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKGEuc3ViamVjdC54MSB8fCBhLnN1YmplY3QueDIpICYmICFhLngpIHtcbiAgICAgICAgYS54ID0gYS5zdWJqZWN0LngxIHx8IGEuc3ViamVjdC54MjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBYKGFjY2Vzc29ycykge1xuICAgICAgZ2V0KFRocmVzaG9sZE1hcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaHJlc2hvbGRNYXAucHJvdG90eXBlKSwgXCJtYXBYXCIsIHRoaXMpLmNhbGwodGhpcywgYWNjZXNzb3JzKTtcbiAgICAgIHZhciBhID0gdGhpcy5hbm5vdGF0aW9uO1xuICAgICAgaWYgKChhLnN1YmplY3QueTEgfHwgYS5zdWJqZWN0LnkyKSAmJiBhLmRhdGEgJiYgYWNjZXNzb3JzLngpIHtcbiAgICAgICAgYS54ID0gYWNjZXNzb3JzLngoYS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICgoYS5zdWJqZWN0LnkxIHx8IGEuc3ViamVjdC55MikgJiYgIWEueSkge1xuICAgICAgICBhLnkgPSBhLnN1YmplY3QueTEgfHwgYS5zdWJqZWN0LnkyO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGhyZXNob2xkTWFwO1xufShkM0NhbGxvdXQpO1xuXG52YXIgZDNYWVRocmVzaG9sZCA9IGN1c3RvbVR5cGUoVGhyZXNob2xkTWFwLCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IHh5dGhyZXNob2xkXCIsXG4gIHN1YmplY3Q6IHsgdHlwZTogXCJ0aHJlc2hvbGRcIiB9XG59KTtcblxudmFyIG5ld1dpdGhDbGFzcyA9IGZ1bmN0aW9uIG5ld1dpdGhDbGFzcyhhLCBkLCB0eXBlLCBjbGFzc05hbWUsIGNsYXNzSUQpIHtcbiAgdmFyIGdyb3VwID0gYS5zZWxlY3RBbGwodHlwZSArIFwiLlwiICsgKGNsYXNzSUQgfHwgY2xhc3NOYW1lKSkuZGF0YShkKTtcbiAgZ3JvdXAuZW50ZXIoKS5hcHBlbmQodHlwZSkubWVyZ2UoZ3JvdXApLmF0dHIoXCJjbGFzc1wiLCBjbGFzc05hbWUpO1xuXG4gIGdyb3VwLmV4aXQoKS5yZW1vdmUoKTtcbiAgcmV0dXJuIGE7XG59O1xuXG52YXIgYWRkSGFuZGxlcnMgPSBmdW5jdGlvbiBhZGRIYW5kbGVycyhkaXNwYXRjaGVyLCBhbm5vdGF0aW9uLCBfcmVmMykge1xuICB2YXIgY29tcG9uZW50ID0gX3JlZjMuY29tcG9uZW50LFxuICAgICAgbmFtZSA9IF9yZWYzLm5hbWU7XG5cbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5vbihcIm1vdXNlb3Zlci5hbm5vdGF0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkaXNwYXRjaGVyLmNhbGwobmFtZSArIFwib3ZlclwiLCBjb21wb25lbnQsIGFubm90YXRpb24pO1xuICAgIH0pLm9uKFwibW91c2VvdXQuYW5ub3RhdGlvbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIuY2FsbChuYW1lICsgXCJvdXRcIiwgY29tcG9uZW50LCBhbm5vdGF0aW9uKTtcbiAgICB9KS5vbihcImNsaWNrLmFubm90YXRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLmNhbGwobmFtZSArIFwiY2xpY2tcIiwgY29tcG9uZW50LCBhbm5vdGF0aW9uKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy9UZXh0IHdyYXBwaW5nIGNvZGUgYWRhcHRlZCBmcm9tIE1pa2UgQm9zdG9ja1xudmFyIHdyYXAgPSBmdW5jdGlvbiB3cmFwKHRleHQsIHdpZHRoLCB3cmFwU3BsaXR0ZXIpIHtcbiAgdmFyIGxpbmVIZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDEuMjtcblxuICB0ZXh0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0ID0gc2VsZWN0KHRoaXMpLFxuICAgICAgICB3b3JkcyA9IHRleHQudGV4dCgpLnNwbGl0KHdyYXBTcGxpdHRlciB8fCAvWyBcXHRcXHJcXG5dKy8pLnJldmVyc2UoKS5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgIHJldHVybiB3ICE9PSBcIlwiO1xuICAgIH0pO1xuICAgIHZhciB3b3JkID0gdm9pZCAwLFxuICAgICAgICBsaW5lJCQxID0gW10sXG4gICAgICAgIHRzcGFuID0gdGV4dC50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCAwLjggKyBcImVtXCIpO1xuXG4gICAgd2hpbGUgKHdvcmQgPSB3b3Jkcy5wb3AoKSkge1xuICAgICAgbGluZSQkMS5wdXNoKHdvcmQpO1xuICAgICAgdHNwYW4udGV4dChsaW5lJCQxLmpvaW4oXCIgXCIpKTtcbiAgICAgIGlmICh0c3Bhbi5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPiB3aWR0aCAmJiBsaW5lJCQxLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGluZSQkMS5wb3AoKTtcbiAgICAgICAgdHNwYW4udGV4dChsaW5lJCQxLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbGluZSQkMSA9IFt3b3JkXTtcbiAgICAgICAgdHNwYW4gPSB0ZXh0LmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCBsaW5lSGVpZ2h0ICsgXCJlbVwiKS50ZXh0KHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgYmJveFdpdGhvdXRIYW5kbGVzID0gZnVuY3Rpb24gYmJveFdpdGhvdXRIYW5kbGVzKHNlbGVjdGlvbikge1xuICB2YXIgc2VsZWN0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiOm5vdCguaGFuZGxlKVwiO1xuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbi5zZWxlY3RBbGwoc2VsZWN0b3IpLm5vZGVzKCkucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgdmFyIGJib3ggPSBjLmdldEJCb3goKTtcbiAgICBwLnggPSBNYXRoLm1pbihwLngsIGJib3gueCk7XG4gICAgcC55ID0gTWF0aC5taW4ocC55LCBiYm94LnkpO1xuICAgIHAud2lkdGggPSBNYXRoLm1heChwLndpZHRoLCBiYm94LndpZHRoKTtcblxuICAgIHZhciB5T2Zmc2V0ID0gYyAmJiBjLmF0dHJpYnV0ZXMgJiYgYy5hdHRyaWJ1dGVzLnk7XG4gICAgcC5oZWlnaHQgPSBNYXRoLm1heChwLmhlaWdodCwgKHlPZmZzZXQgJiYgcGFyc2VGbG9hdCh5T2Zmc2V0LnZhbHVlKSB8fCAwKSArIGJib3guaGVpZ2h0KTtcbiAgICByZXR1cm4gcDtcbiAgfSwgeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbigpIHtcbiAgdmFyIGFubm90YXRpb25zID0gW10sXG4gICAgICBjb2xsZWN0aW9uID0gdm9pZCAwLFxuICAgICAgY29udGV4dCA9IHZvaWQgMCxcbiAgICAgIC8vVE9ETzogYWRkIGNhbnZhcyBmdW5jdGlvbmFsaXR5XG4gIGRpc2FibGUgPSBbXSxcbiAgICAgIGFjY2Vzc29ycyA9IHt9LFxuICAgICAgYWNjZXNzb3JzSW52ZXJzZSA9IHt9LFxuICAgICAgZWRpdE1vZGUgPSBmYWxzZSxcbiAgICAgIGlkcyA9IHZvaWQgMCxcbiAgICAgIHR5cGUgPSBkM0NhbGxvdXQsXG4gICAgICB0ZXh0V3JhcCA9IHZvaWQgMCxcbiAgICAgIG5vdGVQYWRkaW5nID0gdm9pZCAwLFxuICAgICAgYW5ub3RhdGlvbkRpc3BhdGNoZXIgPSBkaXNwYXRjaChcInN1YmplY3RvdmVyXCIsIFwic3ViamVjdG91dFwiLCBcInN1YmplY3RjbGlja1wiLCBcImNvbm5lY3Rvcm92ZXJcIiwgXCJjb25uZWN0b3JvdXRcIiwgXCJjb25uZWN0b3JjbGlja1wiLCBcIm5vdGVvdmVyXCIsIFwibm90ZW91dFwiLCBcIm5vdGVjbGlja1wiLCBcImRyYWdlbmRcIiwgXCJkcmFnc3RhcnRcIiksXG4gICAgICBzZWwgPSB2b2lkIDA7XG5cbiAgdmFyIGFubm90YXRpb24gPSBmdW5jdGlvbiBhbm5vdGF0aW9uKHNlbGVjdGlvbikge1xuICAgIHNlbCA9IHNlbGVjdGlvbjtcbiAgICAvL1RPRE86IGNoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIHN0aWxsIG5lZWRlZFxuICAgIGlmICghZWRpdE1vZGUpIHtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2xhdGVkQW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGlmICghYS50eXBlKSB7XG4gICAgICAgIGEudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoIWEuZGlzYWJsZSkge1xuICAgICAgICBhLmRpc2FibGUgPSBkaXNhYmxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKGEpO1xuICAgIH0pO1xuXG4gICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24gfHwgbmV3IEFubm90YXRpb25Db2xsZWN0aW9uKHtcbiAgICAgIGFubm90YXRpb25zOiB0cmFuc2xhdGVkQW5ub3RhdGlvbnMsXG4gICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29ycyxcbiAgICAgIGFjY2Vzc29yc0ludmVyc2U6IGFjY2Vzc29yc0ludmVyc2UsXG4gICAgICBpZHM6IGlkc1xuICAgIH0pO1xuXG4gICAgdmFyIGFubm90YXRpb25HID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcImdcIikuZGF0YShbY29sbGVjdGlvbl0pO1xuICAgIGFubm90YXRpb25HLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uc1wiKTtcblxuICAgIHZhciBncm91cCA9IHNlbGVjdGlvbi5zZWxlY3QoXCJnLmFubm90YXRpb25zXCIpO1xuICAgIG5ld1dpdGhDbGFzcyhncm91cCwgY29sbGVjdGlvbi5hbm5vdGF0aW9ucywgXCJnXCIsIFwiYW5ub3RhdGlvblwiKTtcblxuICAgIHZhciBhbm5vdGF0aW9uID0gZ3JvdXAuc2VsZWN0QWxsKFwiZy5hbm5vdGF0aW9uXCIpO1xuXG4gICAgYW5ub3RhdGlvbi5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYSA9IHNlbGVjdCh0aGlzKTtcblxuICAgICAgYS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uXCIpO1xuXG4gICAgICBuZXdXaXRoQ2xhc3MoYSwgW2RdLCBcImdcIiwgXCJhbm5vdGF0aW9uLWNvbm5lY3RvclwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tc3ViamVjdFwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZVwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1ub3RlXCIpLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgICAgZC50eXBlID0gZC50eXBlLnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBPYmplY3RdXCIgPyBkLnR5cGUgOiBuZXcgZC50eXBlKHtcbiAgICAgICAgYTogYSxcbiAgICAgICAgYW5ub3RhdGlvbjogZCxcbiAgICAgICAgdGV4dFdyYXA6IHRleHRXcmFwLFxuICAgICAgICBub3RlUGFkZGluZzogbm90ZVBhZGRpbmcsXG4gICAgICAgIGVkaXRNb2RlOiBlZGl0TW9kZSxcbiAgICAgICAgZGlzcGF0Y2hlcjogYW5ub3RhdGlvbkRpc3BhdGNoZXIsXG4gICAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzXG4gICAgICB9KTtcbiAgICAgIGQudHlwZS5kcmF3KCk7XG4gICAgICBkLnR5cGUuZHJhd1RleHQgJiYgZC50eXBlLmRyYXdUZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5qc29uID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBjb25zb2xlLmxvZyhcIkFubm90YXRpb25zIEpTT04gd2FzIGNvcGllZCB0byB5b3VyIGNsaXBib2FyZC4gUGxlYXNlIG5vdGUgdGhlIGFubm90YXRpb24gdHlwZSBpcyBub3QgSlNPTiBjb21wYXRpYmxlLiBJdCBhcHBlYXJzIGluIHRoZSBvYmplY3RzIGFycmF5IGluIHRoZSBjb25zb2xlLCBidXQgbm90IGluIHRoZSBjb3BpZWQgSlNPTi5cIiwgY29sbGVjdGlvbi5qc29uKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB3aW5kb3cuY29weShKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uLmpzb24ubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICBkZWxldGUgYS50eXBlO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSkpKTtcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYW5ub3RhdGlvbnMgJiYgY29sbGVjdGlvbikge1xuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICBhLnR5cGUuZHJhdygpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24udXBkYXRlVGV4dCh0ZXh0V3JhcCk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24udXBkYXRlZEFjY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb2xsZWN0aW9uLnNldFBvc2l0aW9uV2l0aEFjY2Vzc29ycygpO1xuICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmRpc2FibGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpc2FibGU7XG4gICAgZGlzYWJsZSA9IF87XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24udXBkYXRlRGlzYWJsZShkaXNhYmxlKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi50ZXh0V3JhcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGV4dFdyYXA7XG4gICAgdGV4dFdyYXAgPSBfO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZVRleHRXcmFwKHRleHRXcmFwKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5ub3RlUGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm90ZVBhZGRpbmc7XG4gICAgbm90ZVBhZGRpbmcgPSBfO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZU5vdGVQYWRkaW5nKG5vdGVQYWRkaW5nKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG4gIC8vdG9kbyB0aGluayBvZiBob3cgdG8gaGFuZGxlIHdoZW4gdW5kZWZpbmVkIGlzIHNlbnRcbiAgYW5ub3RhdGlvbi50eXBlID0gZnVuY3Rpb24gKF8sIHNldHRpbmdzKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHlwZTtcbiAgICB0eXBlID0gXztcbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS50eXBlLm5vdGUgJiYgYS50eXBlLm5vdGUuc2VsZWN0QWxsKFwiKjpub3QoLmFubm90YXRpb24tbm90ZS1jb250ZW50KVwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLm5vdGVDb250ZW50ICYmIGEudHlwZS5ub3RlQ29udGVudC5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBhLnR5cGUuc3ViamVjdCAmJiBhLnR5cGUuc3ViamVjdC5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBhLnR5cGUuY29ubmVjdG9yICYmIGEudHlwZS5jb25uZWN0b3Iuc2VsZWN0QWxsKFwiKlwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLnR5cGVTZXR0aW5ncyA9IHt9O1xuICAgICAgICBhLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIGEuc3ViamVjdCA9IHNldHRpbmdzICYmIHNldHRpbmdzLnN1YmplY3QgfHwgYS5zdWJqZWN0O1xuICAgICAgICBhLmNvbm5lY3RvciA9IHNldHRpbmdzICYmIHNldHRpbmdzLmNvbm5lY3RvciB8fCBhLmNvbm5lY3RvcjtcbiAgICAgICAgYS5ub3RlID0gc2V0dGluZ3MgJiYgc2V0dGluZ3Mubm90ZSB8fCBhLm5vdGU7XG4gICAgICB9KTtcblxuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmFubm90YXRpb25zID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMgfHwgYW5ub3RhdGlvbnM7XG4gICAgYW5ub3RhdGlvbnMgPSBfO1xuXG4gICAgaWYgKGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5hbm5vdGF0aW9ucykge1xuICAgICAgdmFyIHJlcnVuID0gYW5ub3RhdGlvbnMuc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWQudHlwZSB8fCBkLnR5cGUudG9TdHJpbmcoKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVydW4pIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGFubm90YXRpb24oc2VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgIGNvbnRleHQgPSBfO1xuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uYWNjZXNzb3JzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhY2Nlc3NvcnM7XG4gICAgYWNjZXNzb3JzID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmFjY2Vzc29yc0ludmVyc2UgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFjY2Vzc29yc0ludmVyc2U7XG4gICAgYWNjZXNzb3JzSW52ZXJzZSA9IF87XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5pZHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlkcztcbiAgICBpZHMgPSBfO1xuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uZWRpdE1vZGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVkaXRNb2RlO1xuICAgIGVkaXRNb2RlID0gXztcblxuICAgIGlmIChzZWwpIHtcbiAgICAgIHNlbC5zZWxlY3RBbGwoXCJnLmFubm90YXRpb25cIikuY2xhc3NlZChcImVkaXRhYmxlXCIsIGVkaXRNb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi5lZGl0TW9kZShlZGl0TW9kZSk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uY29sbGVjdGlvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgICBjb2xsZWN0aW9uID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLm9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IGFubm90YXRpb25EaXNwYXRjaGVyLm9uLmFwcGx5KGFubm90YXRpb25EaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gYW5ub3RhdGlvbkRpc3BhdGNoZXIgPyBhbm5vdGF0aW9uIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGFubm90YXRpb247XG59XG5cbnZhciBpbmRleCA9IHtcbiAgYW5ub3RhdGlvbjogYW5ub3RhdGlvbixcbiAgYW5ub3RhdGlvblR5cGVCYXNlOiBUeXBlLFxuICBhbm5vdGF0aW9uTGFiZWw6IGQzTGFiZWwsXG4gIGFubm90YXRpb25DYWxsb3V0OiBkM0NhbGxvdXQsXG4gIGFubm90YXRpb25DYWxsb3V0Q3VydmU6IGQzQ2FsbG91dEN1cnZlLFxuICBhbm5vdGF0aW9uQ2FsbG91dEVsYm93OiBkM0NhbGxvdXRFbGJvdyxcbiAgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGU6IGQzQ2FsbG91dENpcmNsZSxcbiAgYW5ub3RhdGlvbkNhbGxvdXRSZWN0OiBkM0NhbGxvdXRSZWN0LFxuICBhbm5vdGF0aW9uWFlUaHJlc2hvbGQ6IGQzWFlUaHJlc2hvbGQsXG4gIGFubm90YXRpb25CYWRnZTogZDNCYWRnZSxcbiAgYW5ub3RhdGlvbkN1c3RvbVR5cGU6IGN1c3RvbVR5cGVcbn07XG5cbmV4cG9ydCB7IGFubm90YXRpb24sIFR5cGUgYXMgYW5ub3RhdGlvblR5cGVCYXNlLCBkM0xhYmVsIGFzIGFubm90YXRpb25MYWJlbCwgZDNDYWxsb3V0IGFzIGFubm90YXRpb25DYWxsb3V0LCBkM0NhbGxvdXRDdXJ2ZSBhcyBhbm5vdGF0aW9uQ2FsbG91dEN1cnZlLCBkM0NhbGxvdXRFbGJvdyBhcyBhbm5vdGF0aW9uQ2FsbG91dEVsYm93LCBkM0NhbGxvdXRDaXJjbGUgYXMgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGUsIGQzQ2FsbG91dFJlY3QgYXMgYW5ub3RhdGlvbkNhbGxvdXRSZWN0LCBkM1hZVGhyZXNob2xkIGFzIGFubm90YXRpb25YWVRocmVzaG9sZCwgZDNCYWRnZSBhcyBhbm5vdGF0aW9uQmFkZ2UsIGN1c3RvbVR5cGUgYXMgYW5ub3RhdGlvbkN1c3RvbVR5cGUgfTtleHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Um9sbHVwTmV4dC5qcy5tYXBcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBkaXNwYXRjaH0gZnJvbSBcIi4vc3JjL2Rpc3BhdGNoXCI7XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge2V2ZW50LCBjdXN0b21FdmVudCwgc2VsZWN0LCBtb3VzZSwgdG91Y2h9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2RyYWcsIHt5ZXNkcmFnfSBmcm9tIFwiLi9ub2RyYWdcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgRHJhZ0V2ZW50IGZyb20gXCIuL2V2ZW50XCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcigpIHtcbiAgcmV0dXJuICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBldmVudC54LCB5OiBldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gZGVmYXVsdFN1YmplY3QsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgZ2VzdHVyZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxuICAgICAgYWN0aXZlID0gMCxcbiAgICAgIG1vdXNlZG93bngsXG4gICAgICBtb3VzZWRvd255LFxuICAgICAgbW91c2Vtb3ZpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiBkcmFnKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd25lZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuZHJhZ1wiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC5kcmFnIHRvdWNoY2FuY2VsLmRyYWdcIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnZXN0dXJlID0gYmVmb3Jlc3RhcnQoXCJtb3VzZVwiLCBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgbW91c2UsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCFnZXN0dXJlKSByZXR1cm47XG4gICAgc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLmRyYWdcIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLmRyYWdcIiwgbW91c2V1cHBlZCwgdHJ1ZSk7XG4gICAgbm9kcmFnKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBtb3VzZW1vdmluZyA9IGZhbHNlO1xuICAgIG1vdXNlZG93bnggPSBldmVudC5jbGllbnRYO1xuICAgIG1vdXNlZG93bnkgPSBldmVudC5jbGllbnRZO1xuICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoKSB7XG4gICAgbm9ldmVudCgpO1xuICAgIGlmICghbW91c2Vtb3ZpbmcpIHtcbiAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBtb3VzZWRvd254LCBkeSA9IGV2ZW50LmNsaWVudFkgLSBtb3VzZWRvd255O1xuICAgICAgbW91c2Vtb3ZpbmcgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgIH1cbiAgICBnZXN0dXJlcy5tb3VzZShcImRyYWdcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZXVwcGVkKCkge1xuICAgIHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKTtcbiAgICB5ZXNkcmFnKGV2ZW50LnZpZXcsIG1vdXNlbW92aW5nKTtcbiAgICBub2V2ZW50KCk7XG4gICAgZ2VzdHVyZXMubW91c2UoXCJlbmRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIGMgPSBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBiZWZvcmVzdGFydCh0b3VjaGVzW2ldLmlkZW50aWZpZXIsIGMsIHRvdWNoLCB0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vZXZlbnQoKTtcbiAgICAgICAgZ2VzdHVyZShcImRyYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbigpO1xuICAgICAgICBnZXN0dXJlKFwiZW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZXN0YXJ0KGlkLCBjb250YWluZXIsIHBvaW50LCB0aGF0LCBhcmdzKSB7XG4gICAgdmFyIHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgcywgZHgsIGR5LFxuICAgICAgICBzdWJsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29weSgpO1xuXG4gICAgaWYgKCFjdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIFwiYmVmb3Jlc3RhcnRcIiwgcywgaWQsIGFjdGl2ZSwgcFswXSwgcFsxXSwgMCwgMCwgc3VibGlzdGVuZXJzKSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKGV2ZW50LnN1YmplY3QgPSBzID0gc3ViamVjdC5hcHBseSh0aGF0LCBhcmdzKSkgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHggPSBzLnggLSBwWzBdIHx8IDA7XG4gICAgICBkeSA9IHMueSAtIHBbMV0gfHwgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pKSByZXR1cm47XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZ2VzdHVyZSh0eXBlKSB7XG4gICAgICB2YXIgcDAgPSBwLCBuO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOiBnZXN0dXJlc1tpZF0gPSBnZXN0dXJlLCBuID0gYWN0aXZlKys7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5kXCI6IGRlbGV0ZSBnZXN0dXJlc1tpZF0sIC0tYWN0aXZlOyAvLyBub2JyZWFrXG4gICAgICAgIGNhc2UgXCJkcmFnXCI6IHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgbiA9IGFjdGl2ZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIHR5cGUsIHMsIGlkLCBuLCBwWzBdICsgZHgsIHBbMV0gKyBkeSwgcFswXSAtIHAwWzBdLCBwWzFdIC0gcDBbMV0sIHN1Ymxpc3RlbmVycyksIHN1Ymxpc3RlbmVycy5hcHBseSwgc3VibGlzdGVuZXJzLCBbdHlwZSwgdGhhdCwgYXJnc10pO1xuICAgIH07XG4gIH1cblxuICBkcmFnLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogZmlsdGVyO1xuICB9O1xuXG4gIGRyYWcuY29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogY29udGFpbmVyO1xuICB9O1xuXG4gIGRyYWcuc3ViamVjdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdWJqZWN0ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBzdWJqZWN0O1xuICB9O1xuXG4gIGRyYWcudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgZHJhZy5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBkcmFnIDogdmFsdWU7XG4gIH07XG5cbiAgZHJhZy5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCBkcmFnKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIGRyYWc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnRXZlbnQodGFyZ2V0LCB0eXBlLCBzdWJqZWN0LCBpZCwgYWN0aXZlLCB4LCB5LCBkeCwgZHksIGRpc3BhdGNoKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICB0aGlzLmlkZW50aWZpZXIgPSBpZDtcbiAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZHggPSBkeDtcbiAgdGhpcy5keSA9IGR5O1xuICB0aGlzLl8gPSBkaXNwYXRjaDtcbn1cblxuRHJhZ0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcbn07XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgZHJhZ30gZnJvbSBcIi4vZHJhZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWdEaXNhYmxlLCB5ZXNkcmFnIGFzIGRyYWdFbmFibGV9IGZyb20gXCIuL25vZHJhZ1wiO1xuIiwiaW1wb3J0IHtzZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2V2ZW50IGZyb20gXCIuL25vZXZlbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHllc2RyYWcodmlldywgbm9jbGljaykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIGlmIChub2NsaWNrKSB7XG4gICAgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcbiAgfVxuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gcm9vdC5fX25vc2VsZWN0O1xuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XG4gIH1cbn1cbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJ2YXIgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3IsIGNjdyA9ICEhY2N3O1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi9jcmVhdG9yXCI7XG5pbXBvcnQgc2VsZWN0IGZyb20gXCIuL3NlbGVjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3QoY3JlYXRvcihuYW1lKS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2VcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdGV9IGZyb20gXCIuL2NyZWF0ZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0b3J9IGZyb20gXCIuL2NyZWF0b3JcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsb2NhbH0gZnJvbSBcIi4vbG9jYWxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtYXRjaGVyfSBmcm9tIFwiLi9tYXRjaGVyXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbW91c2V9IGZyb20gXCIuL21vdXNlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmFtZXNwYWNlfSBmcm9tIFwiLi9uYW1lc3BhY2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2VzfSBmcm9tIFwiLi9uYW1lc3BhY2VzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY2xpZW50UG9pbnR9IGZyb20gXCIuL3BvaW50XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0fSBmcm9tIFwiLi9zZWxlY3RcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RBbGx9IGZyb20gXCIuL3NlbGVjdEFsbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdGlvbn0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3J9IGZyb20gXCIuL3NlbGVjdG9yXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3JBbGx9IGZyb20gXCIuL3NlbGVjdG9yQWxsXCI7XG5leHBvcnQge3N0eWxlVmFsdWUgYXMgc3R5bGV9IGZyb20gXCIuL3NlbGVjdGlvbi9zdHlsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRvdWNofSBmcm9tIFwiLi90b3VjaFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRvdWNoZXN9IGZyb20gXCIuL3RvdWNoZXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB3aW5kb3d9IGZyb20gXCIuL3dpbmRvd1wiO1xuZXhwb3J0IHtldmVudCwgY3VzdG9tRXZlbnR9IGZyb20gXCIuL3NlbGVjdGlvbi9vblwiO1xuIiwidmFyIG5leHRJZCA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvY2FsKCkge1xuICByZXR1cm4gbmV3IExvY2FsO1xufVxuXG5mdW5jdGlvbiBMb2NhbCgpIHtcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcbn1cblxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTG9jYWwsXG4gIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICB3aGlsZSAoIShpZCBpbiBub2RlKSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gbm9kZVtpZF07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLl8gaW4gbm9kZSAmJiBkZWxldGUgbm9kZVt0aGlzLl9dO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudFwiO1xuaW1wb3J0IHBvaW50IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGV2ZW50ID0gc291cmNlRXZlbnQoKTtcbiAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSBldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICByZXR1cm4gcG9pbnQobm9kZSwgZXZlbnQpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSBcIi4vbmFtZXNwYWNlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lO1xufVxuIiwiZXhwb3J0IHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgZXZlbnQpIHtcbiAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG5cbiAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgfVxuXG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuLi9uYW1lc3BhY2VcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGUoZnVsbG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuIiwiZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUoZmFsc2UpLCB0aGlzLm5leHRTaWJsaW5nKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUodHJ1ZSksIHRoaXMubmV4dFNpYmxpbmcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnRcIjtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3dcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2VcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGxcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGFcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemVcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHlcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0clwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWRcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaFwiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvclwiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3RvclwiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgZW50ZXIgPSB0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiID8gb25lbnRlcihlbnRlcikgOiBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICBpZiAob251cGRhdGUgIT0gbnVsbCkgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaSA9IC0xO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwidmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG5leHBvcnQgdmFyIGV2ZW50ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50KSkge1xuICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApO1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzKSAmIDgpKSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQxKSB7XG4gICAgdmFyIGV2ZW50MCA9IGV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgIGV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXZlbnQ7XG4gIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICBldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXZlbnQgPSBldmVudDA7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuIiwiZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3JBbGwgZnJvbSBcIi4uL3NlbGVjdG9yQWxsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyArK3NpemU7IH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvd1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCIuL3NlbGVjdGlvbi9vblwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnQgPSBldmVudCwgc291cmNlO1xuICB3aGlsZSAoc291cmNlID0gY3VycmVudC5zb3VyY2VFdmVudCkgY3VycmVudCA9IHNvdXJjZTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnRcIjtcbmltcG9ydCBwb2ludCBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLmNoYW5nZWRUb3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIHRvdWNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudFwiO1xuaW1wb3J0IHBvaW50IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIHRvdWNoZXMpIHtcbiAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHBvaW50cyA9IG5ldyBBcnJheShuKTsgaSA8IG47ICsraSkge1xuICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYXJjfSBmcm9tIFwiLi9zcmMvYXJjXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXJlYX0gZnJvbSBcIi4vc3JjL2FyZWFcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsaW5lfSBmcm9tIFwiLi9zcmMvbGluZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZX0gZnJvbSBcIi4vc3JjL3BpZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhZGlhbEFyZWF9IGZyb20gXCIuL3NyYy9yYWRpYWxBcmVhXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFkaWFsTGluZX0gZnJvbSBcIi4vc3JjL3JhZGlhbExpbmVcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbCwgc3ltYm9sc30gZnJvbSBcIi4vc3JjL3N5bWJvbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbENpcmNsZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC9jaXJjbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xDcm9zc30gZnJvbSBcIi4vc3JjL3N5bWJvbC9jcm9zc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbERpYW1vbmR9IGZyb20gXCIuL3NyYy9zeW1ib2wvZGlhbW9uZFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFNxdWFyZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC9zcXVhcmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xTdGFyfSBmcm9tIFwiLi9zcmMvc3ltYm9sL3N0YXJcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xUcmlhbmdsZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC90cmlhbmdsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFd5ZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC93eWVcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXNDbG9zZWR9IGZyb20gXCIuL3NyYy9jdXJ2ZS9iYXNpc0Nsb3NlZFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXNPcGVufSBmcm9tIFwiLi9zcmMvY3VydmUvYmFzaXNPcGVuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCYXNpc30gZnJvbSBcIi4vc3JjL2N1cnZlL2Jhc2lzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCdW5kbGV9IGZyb20gXCIuL3NyYy9jdXJ2ZS9idW5kbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9zcmMvY3VydmUvY2FyZGluYWxDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsT3Blbn0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhcmRpbmFsT3BlblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2FyZGluYWx9IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXJkaW5hbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2F0bXVsbFJvbUNsb3NlZH0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb21PcGVufSBmcm9tIFwiLi9zcmMvY3VydmUvY2F0bXVsbFJvbU9wZW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb219IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVMaW5lYXJDbG9zZWR9IGZyb20gXCIuL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUxpbmVhcn0gZnJvbSBcIi4vc3JjL2N1cnZlL2xpbmVhclwiO1xuZXhwb3J0IHttb25vdG9uZVggYXMgY3VydmVNb25vdG9uZVgsIG1vbm90b25lWSBhcyBjdXJ2ZU1vbm90b25lWX0gZnJvbSBcIi4vc3JjL2N1cnZlL21vbm90b25lXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVOYXR1cmFsfSBmcm9tIFwiLi9zcmMvY3VydmUvbmF0dXJhbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlU3RlcCwgc3RlcEFmdGVyIGFzIGN1cnZlU3RlcEFmdGVyLCBzdGVwQmVmb3JlIGFzIGN1cnZlU3RlcEJlZm9yZX0gZnJvbSBcIi4vc3JjL2N1cnZlL3N0ZXBcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrfSBmcm9tIFwiLi9zcmMvc3RhY2tcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldEV4cGFuZH0gZnJvbSBcIi4vc3JjL29mZnNldC9leHBhbmRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldE5vbmV9IGZyb20gXCIuL3NyYy9vZmZzZXQvbm9uZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT2Zmc2V0U2lsaG91ZXR0ZX0gZnJvbSBcIi4vc3JjL29mZnNldC9zaWxob3VldHRlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXRXaWdnbGV9IGZyb20gXCIuL3NyYy9vZmZzZXQvd2lnZ2xlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlckFzY2VuZGluZ30gZnJvbSBcIi4vc3JjL29yZGVyL2FzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJEZXNjZW5kaW5nfSBmcm9tIFwiLi9zcmMvb3JkZXIvZGVzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJJbnNpZGVPdXR9IGZyb20gXCIuL3NyYy9vcmRlci9pbnNpZGVPdXRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyTm9uZX0gZnJvbSBcIi4vc3JjL29yZGVyL25vbmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyUmV2ZXJzZX0gZnJvbSBcIi4vc3JjL29yZGVyL3JldmVyc2VcIjtcbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IHtlcHNpbG9uLCBwaSwgaGFsZlBpLCB0YXV9IGZyb20gXCIuL21hdGhcIjtcblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gKHkzMiAqIHgxMCAtIHgzMiAqIHkxMCk7XG4gIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xufVxuXG4vLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtTGluZUludGVyc2VjdGlvbi5odG1sXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICB2YXIgeDAxID0geDAgLSB4MSxcbiAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIE1hdGguc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLFxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLFxuICAgICAgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxuICAgICAgZHgwID0gY3gwIC0geDAwLFxuICAgICAgZHkwID0gY3kwIC0geTAwLFxuICAgICAgZHgxID0gY3gxIC0geDAwLFxuICAgICAgZHkxID0gY3kxIC0geTAwO1xuXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcblxuICByZXR1cm4ge1xuICAgIGN4OiBjeDAsXG4gICAgY3k6IGN5MCxcbiAgICB4MDE6IC1veCxcbiAgICB5MDE6IC1veSxcbiAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcbiAgICB5MTE6IGN5MCAqIChyMSAvIHIgLSAxKVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gY29uc3RhbnQoMCksXG4gICAgICBwYWRSYWRpdXMgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGFyY0VuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IE1hdGguYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgIGVsc2UgaWYgKGRhID4gdGF1IC0gZXBzaWxvbikge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBNYXRoLmNvcyhhMCksIHIxICogTWF0aC5zaW4oYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogTWF0aC5jb3MoYTEpLCByMCAqIE1hdGguc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogTWF0aC5zcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBNYXRoLm1pbihNYXRoLmFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBNYXRoLnNpbihhcCkpLFxuICAgICAgICAgICAgcDEgPSBhc2luKHJwIC8gcjEgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbikgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICBlbHNlIGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MDEgPSByMSAqIE1hdGguY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBNYXRoLnNpbihhMDEpLFxuICAgICAgICAgIHgxMCA9IHIwICogTWF0aC5jb3MoYTEwKSxcbiAgICAgICAgICB5MTAgPSByMCAqIE1hdGguc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogTWF0aC5jb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogTWF0aC5zaW4oYTExKSxcbiAgICAgICAgICAgIHgwMCA9IHIwICogTWF0aC5jb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogTWF0aC5zaW4oYTAwKTtcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkpIHtcbiAgICAgICAgICB2YXIgb2MgPSBkYTAgPiBlcHNpbG9uID8gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSA6IFt4MTAsIHkxMF0sXG4gICAgICAgICAgICAgIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGJ4ID0geDExIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGtjID0gMSAvIE1hdGguc2luKE1hdGguYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgbGMgPSBNYXRoLnNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IE1hdGgubWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gTWF0aC5taW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBNYXRoLmF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIE1hdGguYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgTWF0aC5hdGFuMih0MS55MTEsIHQxLngxMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBNYXRoLmF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIE1hdGguYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBNYXRoLmF0YW4yKHQxLnkxMSwgdDEueDExKSwgTWF0aC5hdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgIHJldHVybiBbTWF0aC5jb3MoYSkgKiByLCBNYXRoLnNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB4MCA9IHBvaW50WCxcbiAgICAgIHgxID0gbnVsbCxcbiAgICAgIHkwID0gY29uc3RhbnQoMCksXG4gICAgICB5MSA9IHBvaW50WSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHtcbiAgICAgICAgICBqID0gaTtcbiAgICAgICAgICBvdXRwdXQuYXJlYVN0YXJ0KCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgweltrXSwgeTB6W2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQuYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIHtcbiAgICAgICAgeDB6W2ldID0gK3gwKGQsIGksIGRhdGEpLCB5MHpbaV0gPSAreTAoZCwgaSwgZGF0YSk7XG4gICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICByZXR1cm4gbGluZSgpLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpLmNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgxO1xuICB9O1xuXG4gIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTE7XG4gIH07XG5cbiAgYXJlYS5saW5lWDAgPVxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTApO1xuICB9O1xuXG4gIGFyZWEubGluZVkxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gIH07XG5cbiAgYXJlYS5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGFyZWEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBhcmVhLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJlYTtcbn1cbiIsImV4cG9ydCB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb25zdGFudCgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMyxcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyAyICogdGhhdC5feDEpIC8gMyxcbiAgICAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXG4gICAgKHRoYXQuX3kwICsgNCAqIHRoYXQuX3kxICsgeSkgLyA2XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpcy5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2Jhc2lzXCI7XG5cbmZ1bmN0aW9uIEJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MiA9IHgsIHRoaXMuX3kyID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5OyB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNDbG9zZWQoY29udGV4dCk7XG59XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59XG4iLCJpbXBvcnQge0Jhc2lzfSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGJldGEpIHtcblxuICBmdW5jdGlvbiBidW5kbGUoY29udGV4dCkge1xuICAgIHJldHVybiBiZXRhID09PSAxID8gbmV3IEJhc2lzKGNvbnRleHQpIDogbmV3IEJ1bmRsZShjb250ZXh0LCBiZXRhKTtcbiAgfVxuXG4gIGJ1bmRsZS5iZXRhID0gZnVuY3Rpb24oYmV0YSkge1xuICAgIHJldHVybiBjdXN0b20oK2JldGEpO1xuICB9O1xuXG4gIHJldHVybiBidW5kbGU7XG59KSgwLjg1KTtcbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhcmRpbmFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHtDYXJkaW5hbH0gZnJvbSBcIi4vY2FyZGluYWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdmFyIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgeDIgPSB0aGF0Ll94MixcbiAgICAgIHkyID0gdGhhdC5feTI7XG5cbiAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gIH1cblxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG59XG5cbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9jYXJkaW5hbENsb3NlZFwiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhdG11bGxSb21cIjtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsT3Blbn0gZnJvbSBcIi4vY2FyZGluYWxPcGVuXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcbiIsImZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcFwiO1xuXG5mdW5jdGlvbiBMaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZWxzZSB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyQ2xvc2VkKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBzbG9wZXMgb2YgdGhlIHRhbmdlbnRzIChIZXJtaXRlLXR5cGUgaW50ZXJwb2xhdGlvbikgYmFzZWQgb25cbi8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXG4vLyBJbnRlcnBvbGF0aW9uIGluIE9uZSBEaW1lbnNpb24uIEFzdHJvbm9teSBhbmQgQXN0cm9waHlzaWNzLCBWb2wuIDIzOSwgTk8uXG4vLyBOT1YoSUkpLCBQLiA0NDMsIDE5OTAuXG5mdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XG4gIHZhciBoMCA9IHRoYXQuX3gxIC0gdGhhdC5feDAsXG4gICAgICBoMSA9IHgyIC0gdGhhdC5feDEsXG4gICAgICBzMCA9ICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIChoMCB8fCBoMSA8IDAgJiYgLTApLFxuICAgICAgczEgPSAoeTIgLSB0aGF0Ll95MSkgLyAoaDEgfHwgaDAgPCAwICYmIC0wKSxcbiAgICAgIHAgPSAoczAgKiBoMSArIHMxICogaDApIC8gKGgwICsgaDEpO1xuICByZXR1cm4gKHNpZ24oczApICsgc2lnbihzMSkpICogTWF0aC5taW4oTWF0aC5hYnMoczApLCBNYXRoLmFicyhzMSksIDAuNSAqIE1hdGguYWJzKHApKSB8fCAwO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBvbmUtc2lkZWQgc2xvcGUuXG5mdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xuICB2YXIgaCA9IHRoYXQuX3gxIC0gdGhhdC5feDA7XG4gIHJldHVybiBoID8gKDMgKiAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyBoIC0gdCkgLyAyIDogdDtcbn1cblxuLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lI1JlcHJlc2VudGF0aW9uc1xuLy8gXCJ5b3UgY2FuIGV4cHJlc3MgY3ViaWMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGluIHRlcm1zIG9mIGN1YmljIELDqXppZXIgY3VydmVzXG4vLyB3aXRoIHJlc3BlY3QgdG8gdGhlIGZvdXIgdmFsdWVzIHAwLCBwMCArIG0wIC8gMywgcDEgLSBtMSAvIDMsIHAxXCIuXG5mdW5jdGlvbiBwb2ludCh0aGF0LCB0MCwgdDEpIHtcbiAgdmFyIHgwID0gdGhhdC5feDAsXG4gICAgICB5MCA9IHRoYXQuX3kwLFxuICAgICAgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICBkeCA9ICh4MSAtIHgwKSAvIDM7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk1vbm90b25lWC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9XG4gICAgdGhpcy5fdDAgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0MSA9IE5hTjtcblxuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBwb2ludCh0aGlzLCBzbG9wZTIodGhpcywgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpLCB0MSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICB0aGlzLl90MCA9IHQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWShjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBuZXcgUmVmbGVjdENvbnRleHQoY29udGV4dCk7XG59XG5cbihNb25vdG9uZVkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb25vdG9uZVgucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIE1vbm90b25lWC5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLCB5LCB4KTtcbn07XG5cbmZ1bmN0aW9uIFJlZmxlY3RDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubW92ZVRvKHksIHgpOyB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh5MSwgeDEsIHkyLCB4MiwgeSwgeCk7IH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbm90b25lWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVZKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gTmF0dXJhbChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5OYXR1cmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW107XG4gICAgdGhpcy5feSA9IFtdO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICBuID0geC5sZW5ndGg7XG5cbiAgICBpZiAobikge1xuICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHhbMF0sIHlbMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzFdLCB5WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBweCA9IGNvbnRyb2xQb2ludHMoeCksXG4gICAgICAgICAgICBweSA9IGNvbnRyb2xQb2ludHMoeSk7XG4gICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAxOyBpMSA8IG47ICsraTAsICsraTEpIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8ocHhbMF1baTBdLCBweVswXVtpMF0sIHB4WzFdW2kwXSwgcHlbMV1baTBdLCB4W2kxXSwgeVtpMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgbiA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgIHRoaXMuX3kucHVzaCgreSk7XG4gIH1cbn07XG5cbi8vIFNlZSBodHRwczovL3d3dy5wYXJ0aWNsZWluY2VsbC5jb20vMjAxMi9iZXppZXItc3BsaW5lcy8gZm9yIGRlcml2YXRpb24uXG5mdW5jdGlvbiBjb250cm9sUG9pbnRzKHgpIHtcbiAgdmFyIGksXG4gICAgICBuID0geC5sZW5ndGggLSAxLFxuICAgICAgbSxcbiAgICAgIGEgPSBuZXcgQXJyYXkobiksXG4gICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgciA9IG5ldyBBcnJheShuKTtcbiAgYVswXSA9IDAsIGJbMF0gPSAyLCByWzBdID0geFswXSArIDIgKiB4WzFdO1xuICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7ICsraSkgYVtpXSA9IDEsIGJbaV0gPSA0LCByW2ldID0gNCAqIHhbaV0gKyAyICogeFtpICsgMV07XG4gIGFbbiAtIDFdID0gMiwgYltuIC0gMV0gPSA3LCByW24gLSAxXSA9IDggKiB4W24gLSAxXSArIHhbbl07XG4gIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIG0gPSBhW2ldIC8gYltpIC0gMV0sIGJbaV0gLT0gbSwgcltpXSAtPSBtICogcltpIC0gMV07XG4gIGFbbiAtIDFdID0gcltuIC0gMV0gLyBiW24gLSAxXTtcbiAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSBhW2ldID0gKHJbaV0gLSBhW2kgKyAxXSkgLyBiW2ldO1xuICBiW24gLSAxXSA9ICh4W25dICsgYVtuIC0gMV0pIC8gMjtcbiAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyArK2kpIGJbaV0gPSAyICogeFtpICsgMV0gLSBhW2kgKyAxXTtcbiAgcmV0dXJuIFthLCBiXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IE5hdHVyYWwoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vbGluZWFyXCI7XG5cbmV4cG9ydCB2YXIgY3VydmVSYWRpYWxMaW5lYXIgPSBjdXJ2ZVJhZGlhbChjdXJ2ZUxpbmVhcik7XG5cbmZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xufVxuXG5SYWRpYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuXG4gIGZ1bmN0aW9uIHJhZGlhbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICB9XG5cbiAgcmFkaWFsLl9jdXJ2ZSA9IGN1cnZlO1xuXG4gIHJldHVybiByYWRpYWw7XG59XG4iLCJmdW5jdGlvbiBTdGVwKGNvbnRleHQsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX3QgPSB0O1xufVxuXG5TdGVwLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICgwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiB0aGlzLl9wb2ludCA9PT0gMikgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSk7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGlmICh0aGlzLl9saW5lID49IDApIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fdCA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHgxID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyB4ICogdGhpcy5fdDtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgdGhpcy5feSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94ID0geCwgdGhpcy5feSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDAuNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwQmVmb3JlKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEFmdGVyKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIHJldHVybiBkO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gcG9pbnRYLFxuICAgICAgeSA9IHBvaW50WSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIG91dHB1dC5wb2ludCgreChkLCBpLCBkYXRhKSwgK3koZCwgaSwgZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHg7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5O1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuIiwiZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciB0YXUgPSAyICogcGk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHt9XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIG4sIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aCwgeTsgaiA8IG07ICsraikge1xuICAgIGZvciAoeSA9IGkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIGlmICh5KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzZXJpZXNbaV1bal1bMV0gLz0geTtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMSkpIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDEsIHMwLCBzMSA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBzMCA9IHMxLCBzMSA9IHNlcmllc1tvcmRlcltpXV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIHMxW2pdWzFdICs9IHMxW2pdWzBdID0gaXNOYU4oczBbal1bMV0pID8gczBbal1bMF0gOiBzMFtqXVsxXTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaiA9IDAsIHMwID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMwLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCB5ID0gMDsgaSA8IG47ICsraSkgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcbiAgICBzMFtqXVsxXSArPSBzMFtqXVswXSA9IC15IC8gMjtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSB8fCAhKChtID0gKHMwID0gc2VyaWVzW29yZGVyWzBdXSkubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgczEgPSAwLCBzMiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBzaSA9IHNlcmllc1tvcmRlcltpXV0sXG4gICAgICAgICAgc2lqMCA9IHNpW2pdWzFdIHx8IDAsXG4gICAgICAgICAgc2lqMSA9IHNpW2ogLSAxXVsxXSB8fCAwLFxuICAgICAgICAgIHMzID0gKHNpajAgLSBzaWoxKSAvIDI7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7ICsraykge1xuICAgICAgICB2YXIgc2sgPSBzZXJpZXNbb3JkZXJba11dLFxuICAgICAgICAgICAgc2tqMCA9IHNrW2pdWzFdIHx8IDAsXG4gICAgICAgICAgICBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XG4gICAgICAgIHMzICs9IHNrajAgLSBza2oxO1xuICAgICAgfVxuICAgICAgczEgKz0gc2lqMCwgczIgKz0gczMgKiBzaWowO1xuICAgIH1cbiAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICBpZiAoczEpIHkgLT0gczIgLyBzMTtcbiAgfVxuICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBzdW1zID0gc2VyaWVzLm1hcChzdW0pO1xuICByZXR1cm4gbm9uZShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1thXSAtIHN1bXNbYl07IH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VtKHNlcmllcykge1xuICB2YXIgcyA9IDAsIGkgPSAtMSwgbiA9IHNlcmllcy5sZW5ndGgsIHY7XG4gIHdoaWxlICgrK2kgPCBuKSBpZiAodiA9ICtzZXJpZXNbaV1bMV0pIHMgKz0gdjtcbiAgcmV0dXJuIHM7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIGFzY2VuZGluZyhzZXJpZXMpLnJldmVyc2UoKTtcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcbmltcG9ydCB7c3VtfSBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgc3VtcyA9IHNlcmllcy5tYXAoc3VtKSxcbiAgICAgIG9yZGVyID0gbm9uZShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1tiXSAtIHN1bXNbYV07IH0pLFxuICAgICAgdG9wID0gMCxcbiAgICAgIGJvdHRvbSA9IDAsXG4gICAgICB0b3BzID0gW10sXG4gICAgICBib3R0b21zID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGogPSBvcmRlcltpXTtcbiAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgIHRvcHMucHVzaChqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICBib3R0b21zLnB1c2goaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvdHRvbXMucmV2ZXJzZSgpLmNvbmNhdCh0b3BzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkobik7XG4gIHdoaWxlICgtLW4gPj0gMCkgb1tuXSA9IG47XG4gIHJldHVybiBvO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIG5vbmUoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmdcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuaW1wb3J0IHt0YXV9IGZyb20gXCIuL21hdGhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsXG4gICAgICBzb3J0ID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSxcbiAgICAgIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSxcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQoMCk7XG5cbiAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBpbmRleCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYXJjcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYTAgPSArc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBkYSA9IE1hdGgubWluKHRhdSwgTWF0aC5tYXgoLXRhdSwgZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGEwKSksXG4gICAgICAgIGExLFxuICAgICAgICBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICB2O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh2ID0gYXJjc1tpbmRleFtpXSA9IGldID0gK3ZhbHVlKGRhdGFbaV0sIGksIGRhdGEpKSA+IDApIHtcbiAgICAgICAgc3VtICs9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWxseSBzb3J0IHRoZSBhcmNzIGJ5IHByZXZpb3VzbHktY29tcHV0ZWQgdmFsdWVzIG9yIGJ5IGRhdGEuXG4gICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0VmFsdWVzKGFyY3NbaV0sIGFyY3Nbal0pOyB9KTtcbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhcmNzISBUaGV5IGFyZSBzdG9yZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEncyBvcmRlci5cbiAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcbiAgICAgIGogPSBpbmRleFtpXSwgdiA9IGFyY3Nbal0sIGExID0gYTAgKyAodiA+IDAgPyB2ICogayA6IDApICsgcGEsIGFyY3Nbal0gPSB7XG4gICAgICAgIGRhdGE6IGRhdGFbal0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyY3M7XG4gIH1cblxuICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHZhbHVlO1xuICB9O1xuXG4gIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRWYWx1ZXMgPSBfLCBzb3J0ID0gbnVsbCwgcGllKSA6IHNvcnRWYWx1ZXM7XG4gIH07XG5cbiAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNvcnRWYWx1ZXMgPSBudWxsLCBwaWUpIDogc29ydDtcbiAgfTtcblxuICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBwYWRBbmdsZTtcbiAgfTtcblxuICByZXR1cm4gcGllO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWxcIjtcbmltcG9ydCBhcmVhIGZyb20gXCIuL2FyZWFcIjtcbmltcG9ydCB7cmFkaWFsTGluZX0gZnJvbSBcIi4vcmFkaWFsTGluZVwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgYSA9IGFyZWEoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhciksXG4gICAgICBjID0gYS5jdXJ2ZSxcbiAgICAgIHgwID0gYS5saW5lWDAsXG4gICAgICB4MSA9IGEubGluZVgxLFxuICAgICAgeTAgPSBhLmxpbmVZMCxcbiAgICAgIHkxID0gYS5saW5lWTE7XG5cbiAgYS5hbmdsZSA9IGEueCwgZGVsZXRlIGEueDtcbiAgYS5zdGFydEFuZ2xlID0gYS54MCwgZGVsZXRlIGEueDA7XG4gIGEuZW5kQW5nbGUgPSBhLngxLCBkZWxldGUgYS54MTtcbiAgYS5yYWRpdXMgPSBhLnksIGRlbGV0ZSBhLnk7XG4gIGEuaW5uZXJSYWRpdXMgPSBhLnkwLCBkZWxldGUgYS55MDtcbiAgYS5vdXRlclJhZGl1cyA9IGEueTEsIGRlbGV0ZSBhLnkxO1xuICBhLmxpbmVTdGFydEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHgwKCkpOyB9LCBkZWxldGUgYS5saW5lWDA7XG4gIGEubGluZUVuZEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHgxKCkpOyB9LCBkZWxldGUgYS5saW5lWDE7XG4gIGEubGluZUlubmVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHkwKCkpOyB9LCBkZWxldGUgYS5saW5lWTA7XG4gIGEubGluZU91dGVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHkxKCkpOyB9LCBkZWxldGUgYS5saW5lWTE7XG5cbiAgYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gYTtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWxcIjtcbmltcG9ydCBsaW5lIGZyb20gXCIuL2xpbmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbExpbmUobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiByYWRpYWxMaW5lKGxpbmUoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhcikpO1xufVxuIiwiaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IG9mZnNldE5vbmUgZnJvbSBcIi4vb2Zmc2V0L25vbmVcIjtcbmltcG9ydCBvcmRlck5vbmUgZnJvbSBcIi4vb3JkZXIvbm9uZVwiO1xuXG5mdW5jdGlvbiBzdGFja1ZhbHVlKGQsIGtleSkge1xuICByZXR1cm4gZFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBjb25zdGFudChbXSksXG4gICAgICBvcmRlciA9IG9yZGVyTm9uZSxcbiAgICAgIG9mZnNldCA9IG9mZnNldE5vbmUsXG4gICAgICB2YWx1ZSA9IHN0YWNrVmFsdWU7XG5cbiAgZnVuY3Rpb24gc3RhY2soZGF0YSkge1xuICAgIHZhciBreiA9IGtleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgaSxcbiAgICAgICAgbSA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBuID0ga3oubGVuZ3RoLFxuICAgICAgICBzeiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgb3o7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmb3IgKHZhciBraSA9IGt6W2ldLCBzaSA9IHN6W2ldID0gbmV3IEFycmF5KG0pLCBqID0gMCwgc2lqOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHNpW2pdID0gc2lqID0gWzAsICt2YWx1ZShkYXRhW2pdLCBraSwgaiwgZGF0YSldO1xuICAgICAgICBzaWouZGF0YSA9IGRhdGFbal07XG4gICAgICB9XG4gICAgICBzaS5rZXkgPSBraTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBveiA9IG9yZGVyKHN6KTsgaSA8IG47ICsraSkge1xuICAgICAgc3pbb3pbaV1dLmluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBvZmZzZXQoc3osIG96KTtcbiAgICByZXR1cm4gc3o7XG4gIH1cblxuICBzdGFjay5rZXlzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGtleXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBrZXlzO1xuICB9O1xuXG4gIHN0YWNrLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN0YWNrKSA6IHZhbHVlO1xuICB9O1xuXG4gIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gXyA9PSBudWxsID8gb3JkZXJOb25lIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDogb3JkZXI7XG4gIH07XG5cbiAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG9mZnNldE5vbmUgOiBfLCBzdGFjaykgOiBvZmZzZXQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNpcmNsZSBmcm9tIFwiLi9zeW1ib2wvY2lyY2xlXCI7XG5pbXBvcnQgY3Jvc3MgZnJvbSBcIi4vc3ltYm9sL2Nyb3NzXCI7XG5pbXBvcnQgZGlhbW9uZCBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZFwiO1xuaW1wb3J0IHN0YXIgZnJvbSBcIi4vc3ltYm9sL3N0YXJcIjtcbmltcG9ydCBzcXVhcmUgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZVwiO1xuaW1wb3J0IHRyaWFuZ2xlIGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZVwiO1xuaW1wb3J0IHd5ZSBmcm9tIFwiLi9zeW1ib2wvd3llXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcblxuZXhwb3J0IHZhciBzeW1ib2xzID0gW1xuICBjaXJjbGUsXG4gIGNyb3NzLFxuICBkaWFtb25kLFxuICBzcXVhcmUsXG4gIHN0YXIsXG4gIHRyaWFuZ2xlLFxuICB3eWVcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGNvbnN0YW50KGNpcmNsZSksXG4gICAgICBzaXplID0gY29uc3RhbnQoNjQpLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuICAgIHR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS5kcmF3KGNvbnRleHQsICtzaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHlwZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHN5bWJvbCkgOiB0eXBlO1xuICB9O1xuXG4gIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNpemUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3ltYm9sKSA6IHNpemU7XG4gIH07XG5cbiAgc3ltYm9sLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gc3ltYm9sO1xufVxuIiwiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyksXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLFxuICAgICAgICB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB3ID0gTWF0aC5zcXJ0KHNpemUpLFxuICAgICAgICB4ID0gLXcgLyAyO1xuICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgfVxufTtcbiIsImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGhcIjtcblxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcbiAgICBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLFxuICAgIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsXG4gICAga3kgPSAtTWF0aC5jb3ModGF1IC8gMTApICoga3I7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCB5ICogMik7XG4gICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgYyA9IC0wLjUsXG4gICAgcyA9IE1hdGguc3FydCgzKSAvIDIsXG4gICAgayA9IDEgLyBNYXRoLnNxcnQoMTIpLFxuICAgIGEgPSAoayAvIDIgKyAxKSAqIDM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBhKSxcbiAgICAgICAgeDAgPSByIC8gMixcbiAgICAgICAgeTAgPSByICogayxcbiAgICAgICAgeDEgPSB4MCxcbiAgICAgICAgeTEgPSByICogayArIHIsXG4gICAgICAgIHgyID0gLXgxLFxuICAgICAgICB5MiA9IHkxO1xuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMgKiB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgKyBzICogeTEsIGMgKiB5MSAtIHMgKiB4MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge1RpbWVyfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XG4gIHQucmVzdGFydChlbGFwc2VkID0+IHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwidmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbCh1bmRlZmluZWQsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtTQ0hFRFVMRUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBpO1xuXG4gIGlmIChzY2hlZHVsZXMpIHtcbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLnN0YXRlID4gU0NIRURVTEVEICYmIHNjaGVkdWxlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKFtbbm9kZV1dLCByb290LCBuYW1lLCAraSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhY3RpdmV9IGZyb20gXCIuL2FjdGl2ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycnVwdH0gZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG4iLCJpbXBvcnQge1NUQVJUSU5HLCBFTkRJTkcsIEVOREVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbXB0eSA9IHRydWUsXG4gICAgICBpO1xuXG4gIGlmICghc2NoZWR1bGVzKSByZXR1cm47XG5cbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcgJiYgc2NoZWR1bGUuc3RhdGUgPCBFTkRJTkc7XG4gICAgc2NoZWR1bGUuc3RhdGUgPSBFTkRFRDtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgc2NoZWR1bGUub24uY2FsbChhY3RpdmUgPyBcImludGVycnVwdFwiIDogXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2NoZWR1bGUuaW5kZXgsIHNjaGVkdWxlLmdyb3VwKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICB9XG5cbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnRlcnJ1cHQgZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuXG5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XG5zZWxlY3Rpb24ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBzZWxlY3Rpb25fdHJhbnNpdGlvbjtcbiIsImltcG9ydCBpbnRlcnJ1cHQgZnJvbSBcIi4uL2ludGVycnVwdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJydXB0KHRoaXMsIG5hbWUpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUgZnJvbSBcIi4uL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7ZWFzZUN1YmljSW5PdXR9IGZyb20gXCJkMy1lYXNlXCI7XG5pbXBvcnQge25vd30gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBkZWZhdWx0VGltaW5nID0ge1xuICB0aW1lOiBudWxsLCAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogZWFzZUN1YmljSW5PdXRcbn07XG5cbmZ1bmN0aW9uIGluaGVyaXQobm9kZSwgaWQpIHtcbiAgdmFyIHRpbWluZztcbiAgd2hpbGUgKCEodGltaW5nID0gbm9kZS5fX3RyYW5zaXRpb24pIHx8ICEodGltaW5nID0gdGltaW5nW2lkXSkpIHtcbiAgICBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2l0aW9uICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGltaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBpZCxcbiAgICAgIHRpbWluZztcblxuICBpZiAobmFtZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICBpZCA9IG5hbWUuX2lkLCBuYW1lID0gbmFtZS5fbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IG5ld0lkKCksICh0aW1pbmcgPSBkZWZhdWx0VGltaW5nKS50aW1lID0gbm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSksIGkgPSBmdWxsbmFtZSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KShmdWxsbmFtZSwgaSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge2dldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZGVsYXlGdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGF5Q29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZGVsYXk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkdXJhdGlvbkZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZHVyYXRpb25GdW5jdGlvblxuICAgICAgICAgIDogZHVyYXRpb25Db25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZHVyYXRpb247XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaChlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlVmFyeWluZyhpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy5lYWNoKGVhc2VWYXJ5aW5nKHRoaXMuX2lkLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgb24wLCBvbjEsIHRoYXQgPSB0aGlzLCBpZCA9IHRoYXQuX2lkLCBzaXplID0gdGhhdC5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgY2FuY2VsID0ge3ZhbHVlOiByZWplY3R9LFxuICAgICAgICBlbmQgPSB7dmFsdWU6IGZ1bmN0aW9uKCkgeyBpZiAoLS1zaXplID09PSAwKSByZXNvbHZlKCk7IH19O1xuXG4gICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgICAgaWYgKG9uICE9PSBvbjApIHtcbiAgICAgICAgb24xID0gKG9uMCA9IG9uKS5jb3B5KCk7XG4gICAgICAgIG9uMS5fLmNhbmNlbC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmludGVycnVwdC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmVuZC5wdXNoKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHNlbGVjdGlvbiB3YXMgZW1wdHksIHJlc29sdmUgZW5kIGltbWVkaWF0ZWx5XG4gICAgaWYgKHNpemUgPT09IDApIHJlc29sdmUoKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge21hdGNoZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHJUd2VlbiBmcm9tIFwiLi9hdHRyVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2RlbGF5IGZyb20gXCIuL2RlbGF5LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZSBmcm9tIFwiLi9lYXNlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlVmFyeWluZyBmcm9tIFwiLi9lYXNlVmFyeWluZy5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3Rpb24gZnJvbSBcIi4vc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGVUd2VlbiBmcm9tIFwiLi9zdHlsZVR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHRUd2VlbiBmcm9tIFwiLi90ZXh0VHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHdlZW4gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2VuZCBmcm9tIFwiLi9lbmQuanNcIjtcblxudmFyIGlkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zaXRpb24oZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCkge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3Rpb24oKS50cmFuc2l0aW9uKG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3SWQoKSB7XG4gIHJldHVybiArK2lkO1xufVxuXG52YXIgc2VsZWN0aW9uX3Byb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGU7XG5cblRyYW5zaXRpb24ucHJvdG90eXBlID0gdHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICBzZWxlY3Q6IHRyYW5zaXRpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHRyYW5zaXRpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogdHJhbnNpdGlvbl9maWx0ZXIsXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHRyYW5zaXRpb25fc2VsZWN0aW9uLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uX3RyYW5zaXRpb24sXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX3Byb3RvdHlwZS5lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX3Byb3RvdHlwZS5lYWNoLFxuICBvbjogdHJhbnNpdGlvbl9vbixcbiAgYXR0cjogdHJhbnNpdGlvbl9hdHRyLFxuICBhdHRyVHdlZW46IHRyYW5zaXRpb25fYXR0clR3ZWVuLFxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcbiAgc3R5bGVUd2VlbjogdHJhbnNpdGlvbl9zdHlsZVR3ZWVuLFxuICB0ZXh0OiB0cmFuc2l0aW9uX3RleHQsXG4gIHRleHRUd2VlbjogdHJhbnNpdGlvbl90ZXh0VHdlZW4sXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXG4gIHR3ZWVuOiB0cmFuc2l0aW9uX3R3ZWVuLFxuICBkZWxheTogdHJhbnNpdGlvbl9kZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXG4gIGVhc2U6IHRyYW5zaXRpb25fZWFzZSxcbiAgZWFzZVZhcnlpbmc6IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcsXG4gIGVuZDogdHJhbnNpdGlvbl9lbmQsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25fcHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl1cbn07XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUmdiLCBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGM7XG4gIHJldHVybiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIgPyBpbnRlcnBvbGF0ZU51bWJlclxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyBpbnRlcnBvbGF0ZVJnYlxuICAgICAgOiAoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gc3RhcnQobmFtZSkge1xuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsIG9uMSwgc2l0ID0gc3RhcnQobmFtZSkgPyBpbml0IDogc2V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2l0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCkgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihuYW1lLCBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyXG4gICAgICA/IGdldCh0aGlzLm5vZGUoKSwgaWQpLm9uLm9uKG5hbWUpXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyLCB0aW1lb3V0fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGVtcHR5T24gPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2FuY2VsXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxuZXhwb3J0IHZhciBDUkVBVEVEID0gMDtcbmV4cG9ydCB2YXIgU0NIRURVTEVEID0gMTtcbmV4cG9ydCB2YXIgU1RBUlRJTkcgPSAyO1xuZXhwb3J0IHZhciBTVEFSVEVEID0gMztcbmV4cG9ydCB2YXIgUlVOTklORyA9IDQ7XG5leHBvcnQgdmFyIEVORElORyA9IDU7XG5leHBvcnQgdmFyIEVOREVEID0gNjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSwgaWQsIGluZGV4LCBncm91cCwgdGltaW5nKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZXMpIG5vZGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKGlkIGluIHNjaGVkdWxlcykgcmV0dXJuO1xuICBjcmVhdGUobm9kZSwgaWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBlbXB0eU9uLFxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxuICAgIHRpbWU6IHRpbWluZy50aW1lLFxuICAgIGRlbGF5OiB0aW1pbmcuZGVsYXksXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcbiAgICBlYXNlOiB0aW1pbmcuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogQ1JFQVRFRFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gQ1JFQVRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgc2NoZWR1bGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gU1RBUlRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgcnVubmluZ1wiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgaWQsIHNlbGYpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgdHdlZW47XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuICBzY2hlZHVsZXNbaWRdID0gc2VsZjtcbiAgc2VsZi50aW1lciA9IHRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcblxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChzZWxmLmRlbGF5IDw9IGVsYXBzZWQpIHN0YXJ0KGVsYXBzZWQgLSBzZWxmLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICB2YXIgaSwgaiwgbiwgbztcblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgbyA9IHNjaGVkdWxlc1tpXTtcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XG5cbiAgICAgIC8vIFdoaWxlIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHN0YXJ0aW5nIHRyYW5zaXRpb24gZHVyaW5nIHRoaXMgZnJhbWUsXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcbiAgICAgIC8vIGNoYW5jZSB0byB0aWNrIChhbmQgcG9zc2libHkgZW5kKTsgc2VlIGQzL2QzLXRyYW5zaXRpb24jNTQhXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIHRpbWVvdXQoc3RhcnQpO1xuXG4gICAgICAvLyBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBhbnkgcHJlLWVtcHRlZCB0cmFuc2l0aW9ucy5cbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXG4gICAgLy8gTm90ZSB0aGUgdHJhbnNpdGlvbiBtYXkgYmUgY2FuY2VsZWQgYWZ0ZXIgc3RhcnQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdGljayFcbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBzY2hlZHVsZWQgYmVmb3JlIHRoZSBzdGFydCBldmVudDsgc2VlIGQzL2QzLXRyYW5zaXRpb24jMTYhXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxuICAgIHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gUlVOTklORztcbiAgICAgICAgc2VsZi50aW1lci5yZXN0YXJ0KHRpY2ssIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG4gICAgICAgIHRpY2soZWxhcHNlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgc3RhcnQgZXZlbnQuXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIHR3ZWVuIGFyZSBpbml0aWFsaXplZC5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0d2VlbiwgZGVsZXRpbmcgbnVsbCB0d2Vlbi5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGogPSAtMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG8gPSBzZWxmLnR3ZWVuW2ldLnZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCkpIHtcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgdmFyIHQgPSBlbGFwc2VkIDwgc2VsZi5kdXJhdGlvbiA/IHNlbGYuZWFzZS5jYWxsKG51bGwsIGVsYXBzZWQgLyBzZWxmLmR1cmF0aW9uKSA6IChzZWxmLnRpbWVyLnJlc3RhcnQoc3RvcCksIHNlbGYuc3RhdGUgPSBFTkRJTkcsIDEpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgdHdlZW5baV0uY2FsbChub2RlLCB0KTtcbiAgICB9XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuICAgIGlmIChzZWxmLnN0YXRlID09PSBFTkRJTkcpIHtcbiAgICAgIHNlbGYub24uY2FsbChcImVuZFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHNlbGYuc3RhdGUgPSBFTkRFRDtcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgICBzY2hlZHVsZShzdWJncm91cFtpXSwgbmFtZSwgaWQsIGksIHN1Ymdyb3VwLCBnZXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yQWxsfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCksIGNoaWxkLCBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkKSwgayA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGsgPCBsOyArK2spIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPSBjaGlsZHJlbltrXSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoY2hpbGQsIG5hbWUsIGlkLCBrLCBjaGlsZHJlbiwgaW5oZXJpdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbnZhciBTZWxlY3Rpb24gPSBzZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzdHlsZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVOdWxsKG5hbWUsIGludGVycG9sYXRlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgc3RyaW5nMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHN0cmluZzEwID0gc3RyaW5nMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgdmFsdWUxID0gdmFsdWUodGhpcyksXG4gICAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgc3RyaW5nMSA9IHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZU1heWJlUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciBvbjAsIG9uMSwgbGlzdGVuZXIwLCBrZXkgPSBcInN0eWxlLlwiICsgbmFtZSwgZXZlbnQgPSBcImVuZC5cIiArIGtleSwgcmVtb3ZlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbixcbiAgICAgICAgbGlzdGVuZXIgPSBzY2hlZHVsZS52YWx1ZVtrZXldID09IG51bGwgPyByZW1vdmUgfHwgKHJlbW92ZSA9IHN0eWxlUmVtb3ZlKG5hbWUpKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCB8fCBsaXN0ZW5lcjAgIT09IGxpc3RlbmVyKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKGV2ZW50LCBsaXN0ZW5lcjAgPSBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBpID0gKG5hbWUgKz0gXCJcIikgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlTnVsbChuYW1lLCBpKSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIHN0eWxlUmVtb3ZlKG5hbWUpKVxuICAgIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUZ1bmN0aW9uKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSkpXG4gICAgICAuZWFjaChzdHlsZU1heWJlUmVtb3ZlKHRoaXMuX2lkLCBuYW1lKSlcbiAgICA6IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUpLCBwcmlvcml0eSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIG51bGwpO1xufVxuIiwiZnVuY3Rpb24gc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaS5jYWxsKHRoaXMsIHQpLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciB0LCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdCA9IChpMCA9IGkpICYmIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIga2V5ID0gXCJzdHlsZS5cIiArIChuYW1lICs9IFwiXCIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpO1xufVxuIiwiaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlMSA9PSBudWxsID8gXCJcIiA6IHZhbHVlMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IHRleHRGdW5jdGlvbih0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufVxuIiwiZnVuY3Rpb24gdGV4dEludGVycG9sYXRlKGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gaS5jYWxsKHRoaXMsIHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0VHdlZW4odmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiB0ZXh0SW50ZXJwb2xhdGUoaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcInRleHRcIjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHRleHRUd2Vlbih2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxuICAgICAgaWQxID0gbmV3SWQoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldChub2RlLCBpZDApO1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZDEsIGksIGdyb3VwLCB7XG4gICAgICAgICAgdGltZTogaW5oZXJpdC50aW1lICsgaW5oZXJpdC5kZWxheSArIGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiB0d2VlblJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gdHdlZW4wID0gdHdlZW47XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xID0gdHdlZW4xLnNsaWNlKCk7XG4gICAgICAgICAgdHdlZW4xLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0d2VlbkZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9ICh0d2VlbjAgPSB0d2Vlbikuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIHQgPSB7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSwgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMVtpXSA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBuKSB0d2VlbjEucHVzaCh0KTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgbmFtZSArPSBcIlwiO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciB0d2VlbiA9IGdldCh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4ubGVuZ3RoLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHQgPSB0d2VlbltpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gdHdlZW5SZW1vdmUgOiB0d2VlbkZ1bmN0aW9uKShpZCwgbmFtZSwgdmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG5cbiAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlLnZhbHVlIHx8IChzY2hlZHVsZS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBnZXQobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9vbUV2ZW50KHR5cGUsIHtcbiAgc291cmNlRXZlbnQsXG4gIHRhcmdldCxcbiAgdHJhbnNmb3JtLFxuICBkaXNwYXRjaFxufSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHlwZToge3ZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHNvdXJjZUV2ZW50OiB7dmFsdWU6IHNvdXJjZUV2ZW50LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRhcmdldDoge3ZhbHVlOiB0YXJnZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdHJhbnNmb3JtOiB7dmFsdWU6IHRyYW5zZm9ybSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBfOiB7dmFsdWU6IGRpc3BhdGNofVxuICB9KTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgem9vbVRyYW5zZm9ybSwgaWRlbnRpdHkgYXMgem9vbUlkZW50aXR5LCBUcmFuc2Zvcm0gYXMgWm9vbVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKGssIHgsIHkpIHtcbiAgdGhpcy5rID0gaztcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuayAqIGssIHRoaXMueCwgdGhpcy55KTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IDAgJiB5ID09PSAwID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB4LCB0aGlzLnkgKyB0aGlzLmsgKiB5KTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludFswXSAqIHRoaXMuayArIHRoaXMueCwgcG9pbnRbMV0gKiB0aGlzLmsgKyB0aGlzLnldO1xuICB9LFxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCAqIHRoaXMuayArIHRoaXMueDtcbiAgfSxcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLmsgKyB0aGlzLnk7XG4gIH0sXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gWyhsb2NhdGlvblswXSAtIHRoaXMueCkgLyB0aGlzLmssIChsb2NhdGlvblsxXSAtIHRoaXMueSkgLyB0aGlzLmtdO1xuICB9LFxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4IC0gdGhpcy54KSAvIHRoaXMuaztcbiAgfSxcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoeSAtIHRoaXMueSkgLyB0aGlzLms7XG4gIH0sXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguY29weSgpLmRvbWFpbih4LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCwgdGhpcykubWFwKHguaW52ZXJ0LCB4KSk7XG4gIH0sXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkuY29weSgpLmRvbWFpbih5LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WSwgdGhpcykubWFwKHkuaW52ZXJ0LCB5KSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtkcmFnRGlzYWJsZSwgZHJhZ0VuYWJsZX0gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVab29tfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c2VsZWN0LCBwb2ludGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2ludGVycnVwdH0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IFpvb21FdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuaW1wb3J0IHtUcmFuc2Zvcm0sIGlkZW50aXR5fSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbi8vIGV4Y2VwdCBmb3IgcGluY2gtdG8tem9vbSwgd2hpY2ggaXMgc2VudCBhcyBhIHdoZWVsK2N0cmxLZXkgZXZlbnRcbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoZXZlbnQpIHtcbiAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBldmVudC50eXBlID09PSAnd2hlZWwnKSAmJiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXh0ZW50KCkge1xuICB2YXIgZSA9IHRoaXM7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIGlmIChlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICAgIGUgPSBlLnZpZXdCb3guYmFzZVZhbDtcbiAgICAgIHJldHVybiBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV07XG4gICAgfVxuICAgIHJldHVybiBbWzAsIDBdLCBbZS53aWR0aC5iYXNlVmFsLnZhbHVlLCBlLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtlLmNsaWVudFdpZHRoLCBlLmNsaWVudEhlaWdodF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKGV2ZW50KSB7XG4gIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogKGV2ZW50LmN0cmxLZXkgPyAxMCA6IDEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29uc3RyYWluKHRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpIHtcbiAgdmFyIGR4MCA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFswXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMF0sXG4gICAgICBkeDEgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMV1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzBdLFxuICAgICAgZHkwID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzBdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVsxXSxcbiAgICAgIGR5MSA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFsxXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMV07XG4gIHJldHVybiB0cmFuc2Zvcm0udHJhbnNsYXRlKFxuICAgIGR4MSA+IGR4MCA/IChkeDAgKyBkeDEpIC8gMiA6IE1hdGgubWluKDAsIGR4MCkgfHwgTWF0aC5tYXgoMCwgZHgxKSxcbiAgICBkeTEgPiBkeTAgPyAoZHkwICsgZHkxKSAvIDIgOiBNYXRoLm1pbigwLCBkeTApIHx8IE1hdGgubWF4KDAsIGR5MSlcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGNvbnN0cmFpbiA9IGRlZmF1bHRDb25zdHJhaW4sXG4gICAgICB3aGVlbERlbHRhID0gZGVmYXVsdFdoZWVsRGVsdGEsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgc2NhbGVFeHRlbnQgPSBbMCwgSW5maW5pdHldLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVpvb20sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSxcbiAgICAgIHRvdWNoc3RhcnRpbmcsXG4gICAgICB0b3VjaGZpcnN0LFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMCxcbiAgICAgIHRhcERpc3RhbmNlID0gMTA7XG5cbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZCwge3Bhc3NpdmU6IGZhbHNlfSlcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vkb3duZWQpXG4gICAgICAgIC5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuem9vbVwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcbiAgICBzZWxlY3Rpb24ucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSk7XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW50ZXJydXB0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgLmV2ZW50KGV2ZW50KVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLnpvb20obnVsbCwgdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0cmFuc2Zvcm0pXG4gICAgICAgICAgLmVuZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHpvb20uc2NhbGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHAsXG4gICAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBudWxsLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbihpZGVudGl0eS50cmFuc2xhdGUocDBbMF0sIHAwWzFdKS5zY2FsZSh0LmspLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IC15LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteVxuICAgICAgKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCBrKSB7XG4gICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgaykpO1xuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xuICAgIHZhciB4ID0gcDBbMF0gLSBwMVswXSAqIHRyYW5zZm9ybS5rLCB5ID0gcDBbMV0gLSBwMVsxXSAqIHRyYW5zZm9ybS5rO1xuICAgIHJldHVybiB4ID09PSB0cmFuc2Zvcm0ueCAmJiB5ID09PSB0cmFuc2Zvcm0ueSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtLmssIHgsIHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB0cmFuc2l0aW9uXG4gICAgICAgIC5vbihcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuZW5kKCk7IH0pXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgICAgICAgIGUgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyksXG4gICAgICAgICAgICAgIHAgPSBwb2ludCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcG9pbnQgPT09IFwiZnVuY3Rpb25cIiA/IHBvaW50LmFwcGx5KHRoYXQsIGFyZ3MpIDogcG9pbnQsXG4gICAgICAgICAgICAgIHcgPSBNYXRoLm1heChlWzFdWzBdIC0gZVswXVswXSwgZVsxXVsxXSAtIGVbMF1bMV0pLFxuICAgICAgICAgICAgICBhID0gdGhhdC5fX3pvb20sXG4gICAgICAgICAgICAgIGIgPSB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhhdCwgYXJncykgOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGkgPSBpbnRlcnBvbGF0ZShhLmludmVydChwKS5jb25jYXQodyAvIGEuayksIGIuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYi5rKSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0ID0gYjsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3Igb24gZW5kLlxuICAgICAgICAgICAgZWxzZSB7IHZhciBsID0gaSh0KSwgayA9IHcgLyBsWzJdOyB0ID0gbmV3IFRyYW5zZm9ybShrLCBwWzBdIC0gbFswXSAqIGssIHBbMV0gLSBsWzFdICogayk7IH1cbiAgICAgICAgICAgIGcuem9vbShudWxsLCB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlc3R1cmUodGhhdCwgYXJncywgY2xlYW4pIHtcbiAgICByZXR1cm4gKCFjbGVhbiAmJiB0aGF0Ll9fem9vbWluZykgfHwgbmV3IEdlc3R1cmUodGhhdCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBHZXN0dXJlKHRoYXQsIGFyZ3MpIHtcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIHRoaXMuc291cmNlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIHRoaXMudGFwcyA9IDA7XG4gIH1cblxuICBHZXN0dXJlLnByb3RvdHlwZSA9IHtcbiAgICBldmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkgdGhpcy5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkge1xuICAgICAgICB0aGlzLnRoYXQuX196b29taW5nID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhcnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uKGtleSwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodGhpcy5tb3VzZSAmJiBrZXkgIT09IFwibW91c2VcIikgdGhpcy5tb3VzZVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy5tb3VzZVswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDAgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gwWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMFswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDEgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gxWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMVswXSk7XG4gICAgICB0aGlzLnRoYXQuX196b29tID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5lbWl0KFwiem9vbVwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRoYXQuX196b29taW5nO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBkID0gc2VsZWN0KHRoaXMudGhhdCkuZGF0dW0oKTtcbiAgICAgIGxpc3RlbmVycy5jYWxsKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLnRoYXQsXG4gICAgICAgIG5ldyBab29tRXZlbnQodHlwZSwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiB0aGlzLnNvdXJjZUV2ZW50LFxuICAgICAgICAgIHRhcmdldDogem9vbSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy50aGF0Ll9fem9vbSxcbiAgICAgICAgICBkaXNwYXRjaDogbGlzdGVuZXJzXG4gICAgICAgIH0pLFxuICAgICAgICBkXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgdC5rICogTWF0aC5wb3coMiwgd2hlZWxEZWx0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCk7XG5cbiAgICAvLyBJZiB0aGUgbW91c2UgaXMgaW4gdGhlIHNhbWUgbG9jYXRpb24gYXMgYmVmb3JlLCByZXVzZSBpdC5cbiAgICAvLyBJZiB0aGVyZSB3ZXJlIHJlY2VudCB3aGVlbCBldmVudHMsIHJlc2V0IHRoZSB3aGVlbCBpZGxlIHRpbWVvdXQuXG4gICAgaWYgKGcud2hlZWwpIHtcbiAgICAgIGlmIChnLm1vdXNlWzBdWzBdICE9PSBwWzBdIHx8IGcubW91c2VbMF1bMV0gIT09IHBbMV0pIHtcbiAgICAgICAgZy5tb3VzZVsxXSA9IHQuaW52ZXJ0KGcubW91c2VbMF0gPSBwKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChnLndoZWVsKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHdoZWVsIGV2ZW50IHdvbuKAmXQgdHJpZ2dlciBhIHRyYW5zZm9ybSBjaGFuZ2UsIGlnbm9yZSBpdC5cbiAgICBlbHNlIGlmICh0LmsgPT09IGspIHJldHVybjtcblxuICAgIC8vIE90aGVyd2lzZSwgY2FwdHVyZSB0aGUgbW91c2UgcG9pbnQgYW5kIGxvY2F0aW9uIGF0IHRoZSBzdGFydC5cbiAgICBlbHNlIHtcbiAgICAgIGcubW91c2UgPSBbcCwgdC5pbnZlcnQocCldO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgdHJ1ZSkuZXZlbnQoZXZlbnQpLFxuICAgICAgICB2ID0gc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLnpvb21cIiwgbW91c2V1cHBlZCwgdHJ1ZSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgeDAgPSBldmVudC5jbGllbnRYLFxuICAgICAgICB5MCA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICBkcmFnRGlzYWJsZShldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBnLm1vdXNlID0gW3AsIHRoaXMuX196b29tLmludmVydChwKV07XG4gICAgaW50ZXJydXB0KHRoaXMpO1xuICAgIGcuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZWQoZXZlbnQpIHtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKCFnLm1vdmVkKSB7XG4gICAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSB4MCwgZHkgPSBldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy5ldmVudChldmVudClcbiAgICAgICAuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXBwZWQoZXZlbnQpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkcmFnRW5hYmxlKGV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBnLmV2ZW50KGV2ZW50KS5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICBwMCA9IHBvaW50ZXIoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50LCB0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmdzKSwgdHJhbnNsYXRlRXh0ZW50KTtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCwgZXZlbnQpO1xuICAgIGVsc2Ugc2VsZWN0KHRoaXMpLmNhbGwoem9vbS50cmFuc2Zvcm0sIHQxLCBwMCwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgc3RhcnRlZCwgaSwgdCwgcDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaGZpcnN0ID0gcFswXSwgdG91Y2hzdGFydGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoc3RhcnRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0LCBwLCBsO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gwWzBdID0gcDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gxWzBdID0gcDtcbiAgICB9XG4gICAgdCA9IGcudGhhdC5fX3pvb207XG4gICAgaWYgKGcudG91Y2gxKSB7XG4gICAgICB2YXIgcDAgPSBnLnRvdWNoMFswXSwgbDAgPSBnLnRvdWNoMFsxXSxcbiAgICAgICAgICBwMSA9IGcudG91Y2gxWzBdLCBsMSA9IGcudG91Y2gxWzFdLFxuICAgICAgICAgIGRwID0gKGRwID0gcDFbMF0gLSBwMFswXSkgKiBkcCArIChkcCA9IHAxWzFdIC0gcDBbMV0pICogZHAsXG4gICAgICAgICAgZGwgPSAoZGwgPSBsMVswXSAtIGwwWzBdKSAqIGRsICsgKGRsID0gbDFbMV0gLSBsMFsxXSkgKiBkbDtcbiAgICAgIHQgPSBzY2FsZSh0LCBNYXRoLnNxcnQoZHAgLyBkbCkpO1xuICAgICAgcCA9IFsocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyXTtcbiAgICAgIGwgPSBbKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGcudG91Y2gwKSBwID0gZy50b3VjaDBbMF0sIGwgPSBnLnRvdWNoMFsxXTtcbiAgICBlbHNlIHJldHVybjtcblxuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQ7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICB9XG4gICAgaWYgKGcudG91Y2gxICYmICFnLnRvdWNoMCkgZy50b3VjaDAgPSBnLnRvdWNoMSwgZGVsZXRlIGcudG91Y2gxO1xuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgZy5lbmQoKTtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgZGJsdGFwLCByZXJvdXRlIHRvIHRoZSAob3B0aW9uYWwpIGRibGNsaWNrLnpvb20gaGFuZGxlci5cbiAgICAgIGlmIChnLnRhcHMgPT09IDIpIHtcbiAgICAgICAgdCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICAgIGlmIChNYXRoLmh5cG90KHRvdWNoZmlyc3RbMF0gLSB0WzBdLCB0b3VjaGZpcnN0WzFdIC0gdFsxXSkgPCB0YXBEaXN0YW5jZSkge1xuICAgICAgICAgIHZhciBwID0gc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgICBpZiAocCkgcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdoZWVsRGVsdGEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgem9vbSkgOiB3aGVlbERlbHRhO1xuICB9O1xuXG4gIHpvb20uZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgem9vbS50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgem9vbSkgOiBleHRlbnQ7XG4gIH07XG5cbiAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZUV4dGVudFswXSA9ICtfWzBdLCBzY2FsZUV4dGVudFsxXSA9ICtfWzFdLCB6b29tKSA6IFtzY2FsZUV4dGVudFswXSwgc2NhbGVFeHRlbnRbMV1dO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25zdHJhaW4gPSBfLCB6b29tKSA6IGNvbnN0cmFpbjtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgem9vbS50YXBEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXBEaXN0YW5jZSA9ICtfLCB6b29tKSA6IHRhcERpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufVxuIiwiZXhwb3J0IGNsYXNzIEludGVybk1hcCBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMsIGtleSA9IGtleW9mKSB7XG4gICAgc3VwZXIoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7X2ludGVybjoge3ZhbHVlOiBuZXcgTWFwKCl9LCBfa2V5OiB7dmFsdWU6IGtleX19KTtcbiAgICBpZiAoZW50cmllcyAhPSBudWxsKSBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldChpbnRlcm5fZ2V0KHRoaXMsIGtleSkpO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIuaGFzKGludGVybl9nZXQodGhpcywga2V5KSk7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0KGludGVybl9zZXQodGhpcywga2V5KSwgdmFsdWUpO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKGludGVybl9kZWxldGUodGhpcywga2V5KSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludGVyblNldCBleHRlbmRzIFNldCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlcywga2V5ID0ga2V5b2YpIHtcbiAgICBzdXBlcigpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtfaW50ZXJuOiB7dmFsdWU6IG5ldyBNYXAoKX0sIF9rZXk6IHt2YWx1ZToga2V5fX0pO1xuICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHRoaXMuYWRkKHZhbHVlKTtcbiAgfVxuICBoYXModmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuaGFzKGludGVybl9nZXQodGhpcywgdmFsdWUpKTtcbiAgfVxuICBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkKGludGVybl9zZXQodGhpcywgdmFsdWUpKTtcbiAgfVxuICBkZWxldGUodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKGludGVybl9kZWxldGUodGhpcywgdmFsdWUpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcm5fZ2V0KHtfaW50ZXJuLCBfa2V5fSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5ID0gX2tleSh2YWx1ZSk7XG4gIHJldHVybiBfaW50ZXJuLmhhcyhrZXkpID8gX2ludGVybi5nZXQoa2V5KSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5fc2V0KHtfaW50ZXJuLCBfa2V5fSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5ID0gX2tleSh2YWx1ZSk7XG4gIGlmIChfaW50ZXJuLmhhcyhrZXkpKSByZXR1cm4gX2ludGVybi5nZXQoa2V5KTtcbiAgX2ludGVybi5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuX2RlbGV0ZSh7X2ludGVybiwgX2tleX0sIHZhbHVlKSB7XG4gIGNvbnN0IGtleSA9IF9rZXkodmFsdWUpO1xuICBpZiAoX2ludGVybi5oYXMoa2V5KSkge1xuICAgIHZhbHVlID0gX2ludGVybi5nZXQoa2V5KTtcbiAgICBfaW50ZXJuLmRlbGV0ZShrZXkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24ga2V5b2YodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xufVxuIiwiLy8ganNvbnN0YXQtdG9vbGtpdCB2MS41LjMgQ29weXJpZ2h0IDIwMjQgWGF2aWVyIEJhZG9zYSBodHRwczovL2pzb25zdGF0LmNvbVxuZnVuY3Rpb24gdChpLHIpe3ZhciBsLHMsYSxvLHU9ZnVuY3Rpb24odCxpLHIpe2lmKDA9PT1PYmplY3QuZW50cmllcyh0KS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGwscz1bXTtpZihyJiYhbihyLm5hbWUpJiYocj1udWxsKSxcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9W3RdKSxBcnJheS5pc0FycmF5KHQpfHxlKHQpKXtpZih0Lmxlbmd0aD09PWkpcmV0dXJuIHImJi0xPT09dC5maW5kSW5kZXgoKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10fSkpP3IuZnJvbSh0KTp0O2lmKDE9PT10Lmxlbmd0aCl7Zm9yKGw9MDtsPGk7bCsrKXMucHVzaCh0WzBdKTtyZXR1cm4gc319Zm9yKGw9MDtsPGk7bCsrKXt2YXIgYT12b2lkIDA9PT10W2xdP251bGw6dFtsXTtzLnB1c2goYSl9cmV0dXJuIHN9O2lmKHRoaXMubGVuZ3RoPTAsdGhpcy5pZD1bXSxudWxsIT1pKXN3aXRjaCh0aGlzLmNsYXNzPWkuY2xhc3N8fFwiYnVuZGxlXCIsdGhpcy5jbGFzcyl7Y2FzZVwiYnVuZGxlXCI6dmFyIGg9W10sZj0wO2lmKHRoaXMuZXJyb3I9bnVsbCx0aGlzLmxlbmd0aD0wLG51bGw9PT1pfHxcIm9iamVjdFwiIT10eXBlb2YgaSlyZXR1cm4gdm9pZCh0aGlzLmNsYXNzPW51bGwpO2lmKGkuaGFzT3duUHJvcGVydHkoXCJlcnJvclwiKSlyZXR1cm4gdm9pZCh0aGlzLmVycm9yPWkuZXJyb3IpO2lmKFwiZGF0YXNldFwiPT09aS5jbGFzc3x8XCJjb2xsZWN0aW9uXCI9PT1pLmNsYXNzfHxcImRpbWVuc2lvblwiPT09aS5jbGFzcylyZXR1cm4gbmV3IHQoaSk7Zm9yKHMgaW4gaSlmKyssaC5wdXNoKHMpO3RoaXMuX190cmVlX189aSx0aGlzLmxlbmd0aD1mLHRoaXMuaWQ9aDticmVhaztjYXNlXCJkYXRhc2V0XCI6aS5oYXNPd25Qcm9wZXJ0eShcIl9fdHJlZV9fXCIpP3RoaXMuX190cmVlX189bD1pLl9fdHJlZV9fOnRoaXMuX190cmVlX189bD1pLHRoaXMubGFiZWw9bC5sYWJlbHx8bnVsbCx0aGlzLm5vdGU9bC5ub3RlfHxudWxsLHRoaXMubGluaz1sLmxpbmt8fG51bGwsdGhpcy5ocmVmPWwuaHJlZnx8bnVsbCx0aGlzLnVwZGF0ZWQ9bC51cGRhdGVkfHxudWxsLHRoaXMuc291cmNlPWwuc291cmNlfHxudWxsLHRoaXMuZXh0ZW5zaW9uPWwuZXh0ZW5zaW9ufHxudWxsO3ZhciBjLGQ9MCx2PWwuc2l6ZXx8bC5kaW1lbnNpb24mJmwuZGltZW5zaW9uLnNpemU7aWYodGhpcy5zaXplPXYsdGhpcy52YWx1ZT1sLmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJm51bGwhPT1sLnZhbHVlJiYwIT09bC52YWx1ZS5sZW5ndGg/bC52YWx1ZTp7fSxBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpfHxlKHRoaXMudmFsdWUpKWQ9dGhpcy52YWx1ZS5sZW5ndGg7ZWxzZXt2YXIgeT0xO2ZvcihjPXYubGVuZ3RoO2MtLTspeSo9dltjXTtkPXl9aWYodGhpcy52YWx1ZT11KHRoaXMudmFsdWUsZCxyKSx0aGlzLnN0YXR1cz1sLmhhc093blByb3BlcnR5KFwic3RhdHVzXCIpJiZudWxsIT09bC5zdGF0dXM/dShsLnN0YXR1cyxkKTpudWxsLGwuaGFzT3duUHJvcGVydHkoXCJkaW1lbnNpb25cIikpe3ZhciBwPWwuZGltZW5zaW9uLGc9bC5yb2xlfHwhbC52ZXJzaW9uJiZwLnJvbGV8fG51bGwsYj1sLmlkfHxwLmlkLG09di5sZW5ndGgsXz1mdW5jdGlvbih0KXtnLmhhc093blByb3BlcnR5KHQpfHwoZ1t0XT1udWxsKX07aWYoIUFycmF5LmlzQXJyYXkoYil8fCFBcnJheS5pc0FycmF5KHYpfHxiLmxlbmd0aCE9bSlyZXR1cm47aWYodGhpcy5sZW5ndGg9bSx0aGlzLmlkPWIsZyYmKF8oXCJ0aW1lXCIpLF8oXCJnZW9cIiksXyhcIm1ldHJpY1wiKSxfKFwiY2xhc3NpZmljYXRpb25cIikpLGcmJm51bGw9PT1nLmNsYXNzaWZpY2F0aW9uKXt2YXIgeD1bXSxPPVtcInRpbWVcIixcImdlb1wiLFwibWV0cmljXCJdLEE9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5sZW5ndGg7bi0tOylpZih0PT09ZVtuXSlyZXR1cm4hMDtyZXR1cm4hMX07Zm9yKGM9MDtjPDM7YysrKXt2YXIgdz1nW09bY11dO251bGwhPT13JiYoeD14LmNvbmNhdCh3KSl9Zm9yKGcuY2xhc3NpZmljYXRpb249W10sYz0wO2M8bTtjKyspQShiW2NdLHgpfHxnLmNsYXNzaWZpY2F0aW9uLnB1c2goYltjXSk7MD09PWcuY2xhc3NpZmljYXRpb24ubGVuZ3RoJiYoZy5jbGFzc2lmaWNhdGlvbj1udWxsKX10aGlzLnJvbGU9Zyx0aGlzLm49ZDtmb3IodmFyIGo9MCxrPXRoaXMubGVuZ3RoO2o8aztqKyspaWYocFtiW2pdXS5jYXRlZ29yeS5oYXNPd25Qcm9wZXJ0eShcImluZGV4XCIpKXtpZihBcnJheS5pc0FycmF5KHBbYltqXV0uY2F0ZWdvcnkuaW5kZXgpKXt2YXIgRD17fSxQPXBbYltqXV0uY2F0ZWdvcnkuaW5kZXg7Zm9yKGE9UC5sZW5ndGgsbz0wO288YTtvKyspRFtQW29dXT1vO3BbYltqXV0uY2F0ZWdvcnkuaW5kZXg9RH19ZWxzZXt2YXIgRT0wO2ZvcihzIGluIHBbYltqXV0uY2F0ZWdvcnkuaW5kZXg9e30scFtiW2pdXS5jYXRlZ29yeS5sYWJlbClwW2Jbal1dLmNhdGVnb3J5LmluZGV4W3NdPUUrK319ZWxzZSB0aGlzLmxlbmd0aD0wO2JyZWFrO2Nhc2VcImRpbWVuc2lvblwiOmlmKCFpLmhhc093blByb3BlcnR5KFwiX190cmVlX19cIikpcmV0dXJuIG5ldyB0KHt2ZXJzaW9uOlwiMi4wXCIsY2xhc3M6XCJkYXRhc2V0XCIsZGltZW5zaW9uOntkOml9LGlkOltcImRcIl0sc2l6ZTpbZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwPT09dC5pbmRleD90LmxhYmVsOnQuaW5kZXg7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5sZW5ndGg6T2JqZWN0LmtleXMoZSkubGVuZ3RofShpLmNhdGVnb3J5KV0sdmFsdWU6W251bGxdfSkuRGltZW5zaW9uKDApO3ZhciB6PVtdLFM9KGw9aS5fX3RyZWVfXykuY2F0ZWdvcnk7aWYoIWwuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeVwiKSlyZXR1cm47aWYoIVMuaGFzT3duUHJvcGVydHkoXCJsYWJlbFwiKSlmb3IocyBpbiBTLmxhYmVsPXt9LFMuaW5kZXgpUy5sYWJlbFtzXT1zO2ZvcihzIGluIFMuaW5kZXgpeltTLmluZGV4W3NdXT1zO3RoaXMuX190cmVlX189bCx0aGlzLmxhYmVsPWwubGFiZWx8fG51bGwsdGhpcy5ub3RlPWwubm90ZXx8bnVsbCx0aGlzLmxpbms9bC5saW5rfHxudWxsLHRoaXMuaHJlZj1sLmhyZWZ8fG51bGwsdGhpcy5pZD16LHRoaXMubGVuZ3RoPXoubGVuZ3RoLHRoaXMucm9sZT1pLnJvbGUsdGhpcy5oaWVyYXJjaHk9Uy5oYXNPd25Qcm9wZXJ0eShcImNoaWxkXCIpLHRoaXMuZXh0ZW5zaW9uPWwuZXh0ZW5zaW9ufHxudWxsO2JyZWFrO2Nhc2VcImNhdGVnb3J5XCI6dmFyIEk9aS5jaGlsZDt0aGlzLmlkPUksdGhpcy5sZW5ndGg9bnVsbD09PUk/MDpJLmxlbmd0aCx0aGlzLmluZGV4PWkuaW5kZXgsdGhpcy5sYWJlbD1pLmxhYmVsLHRoaXMubm90ZT1pLm5vdGV8fG51bGwsdGhpcy51bml0PWkudW5pdCx0aGlzLmNvb3JkaW5hdGVzPWkuY29vcmQ7YnJlYWs7Y2FzZVwiY29sbGVjdGlvblwiOmlmKHRoaXMubGVuZ3RoPTAsdGhpcy5sYWJlbD1pLmxhYmVsfHxudWxsLHRoaXMubm90ZT1pLm5vdGV8fG51bGwsdGhpcy5saW5rPWkubGlua3x8bnVsbCx0aGlzLmhyZWY9aS5ocmVmfHxudWxsLHRoaXMudXBkYXRlZD1pLnVwZGF0ZWR8fG51bGwsdGhpcy5zb3VyY2U9aS5zb3VyY2V8fG51bGwsdGhpcy5leHRlbnNpb249aS5leHRlbnNpb258fG51bGwsbnVsbCE9PXRoaXMubGluayYmaS5saW5rLml0ZW0pe3ZhciBDPWkubGluay5pdGVtO2lmKHRoaXMubGVuZ3RoPUFycmF5LmlzQXJyYXkoQyk/Qy5sZW5ndGg6MCx0aGlzLmxlbmd0aClmb3Iobz0wO288dGhpcy5sZW5ndGg7bysrKXRoaXMuaWRbb109Q1tvXS5ocmVmfX19ZnVuY3Rpb24gZSh0KXtyZXR1cm5cIltvYmplY3QgQXJyYXlCdWZmZXJdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5idWZmZXIpfWZ1bmN0aW9uIG4odCl7cmV0dXJuLTEhPT1bXCJJbnQ4QXJyYXlcIixcIlVpbnQ4QXJyYXlcIixcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXCJJbnQxNkFycmF5XCIsXCJVaW50MTZBcnJheVwiLFwiSW50MzJBcnJheVwiLFwiVWludDMyQXJyYXlcIixcIkZsb2F0MzJBcnJheVwiLFwiRmxvYXQ2NEFycmF5XCIsXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiXS5pbmRleE9mKHQpfWZ1bmN0aW9uIGkodCl7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKHQuc3RhdHVzK1wiIFwiK3Quc3RhdHVzVGV4dCk7cmV0dXJuIHQuanNvbigpfWZ1bmN0aW9uIHIoZSxuLHIpe3ZhciBsPVwib2JqZWN0XCI9PXR5cGVvZiBuP246bnVsbDtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiByJiYocj1udWxsKSxyfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBufHwocj1uKSxcIm9iamVjdFwiPT10eXBlb2YgZT9uZXcgdChlLHIpOlwidmVyc2lvblwiPT09ZT9cIjEuNS4zXCI6ZmV0Y2g/ZmV0Y2goZSxsKS50aGVuKGkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlLHIpfSkpOnZvaWQgMH10LnByb3RvdHlwZS5JdGVtPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzfHxcImNvbGxlY3Rpb25cIiE9PXRoaXMuY2xhc3N8fCF0aGlzLmxlbmd0aClyZXR1cm4gbnVsbDtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gdD50aGlzLmxlbmd0aHx8dDwwP251bGw6dGhpcy5saW5rLml0ZW1bdF07dmFyIGUsbj1bXTtpZihcIm9iamVjdFwiPT10eXBlb2YgdCl7aWYoIXQuY2xhc3MmJiF0LmZvbGxvdylyZXR1cm4gbnVsbDt0LmNsYXNzJiYoZT1cImRhdGFzZXRcIj09PXQuY2xhc3MmJlwiYm9vbGVhblwiPT10eXBlb2YgdC5lbWJlZGRlZD8hMD09PXQuZW1iZWRkZWQ/ZnVuY3Rpb24odCxlLGkpe3ZhciByPXQubGluay5pdGVtW2VdO2kuY2xhc3M9PT1yLmNsYXNzJiZyLmlkJiZyLnNpemUmJnIuZGltZW5zaW9uJiZuLnB1c2gocil9OmZ1bmN0aW9uKHQsZSxpKXt2YXIgcj10LmxpbmsuaXRlbVtlXTtpLmNsYXNzIT09ci5jbGFzc3x8ci5pZCYmci5zaXplJiZyLmRpbWVuc2lvbnx8bi5wdXNoKHIpfTpmdW5jdGlvbih0LGUsaSl7aS5jbGFzcz09PXQubGluay5pdGVtW2VdLmNsYXNzJiZuLnB1c2godC5saW5rLml0ZW1bZV0pfSl9ZWxzZSBlPWZ1bmN0aW9uKHQsZSl7bi5wdXNoKHQubGluay5pdGVtW2VdKX07Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aDtpKyspZSh0aGlzLGksdCk7cmV0dXJuIG59LHQucHJvdG90eXBlLkRhdGFzZXQ9ZnVuY3Rpb24oZSl7aWYobnVsbD09PXRoaXMpcmV0dXJuIG51bGw7aWYoXCJkYXRhc2V0XCI9PT10aGlzLmNsYXNzKXJldHVybiB2b2lkIDAhPT1lP3RoaXM6W3RoaXNdO3ZhciBuLGk9W10scj0wO2lmKFwiY29sbGVjdGlvblwiPT09dGhpcy5jbGFzcyl7dmFyIGw9dGhpcy5JdGVtKHtjbGFzczpcImRhdGFzZXRcIixlbWJlZGRlZDohMH0pO2lmKHZvaWQgMD09PWUpe2ZvcihuPWwubGVuZ3RoO3I8bjtyKyspaS5wdXNoKG5ldyB0KGxbcl0pKTtyZXR1cm4gaX1pZihcIm51bWJlclwiPT10eXBlb2YgZSYmZT49MCYmZTxsLmxlbmd0aClyZXR1cm4gbmV3IHQobFtlXSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpZm9yKG49bC5sZW5ndGg7cjxuO3IrKylpZihsW3JdLmhyZWY9PT1lKXJldHVybiBuZXcgdChsW3JdKTtyZXR1cm4gbnVsbH1pZihcImJ1bmRsZVwiIT09dGhpcy5jbGFzcylyZXR1cm4gbnVsbDtpZih2b2lkIDA9PT1lKXtmb3Iobj10aGlzLmlkLmxlbmd0aDtyPG47cisrKWkucHVzaCh0aGlzLkRhdGFzZXQodGhpcy5pZFtyXSkpO3JldHVybiBpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXt2YXIgcz10aGlzLmlkW2VdO3JldHVybiB2b2lkIDAhPT1zP3RoaXMuRGF0YXNldChzKTpudWxsfXZhciBhPXRoaXMuX190cmVlX19bZV07cmV0dXJuIHZvaWQgMD09PWE/bnVsbDpuZXcgdCh7Y2xhc3M6XCJkYXRhc2V0XCIsX190cmVlX186YX0pfSx0LnByb3RvdHlwZS5EaW1lbnNpb249ZnVuY3Rpb24oZSxuKXtuPVwiYm9vbGVhblwiIT10eXBlb2Ygbnx8bjt2YXIgaSxyPVtdLGw9dGhpcy5pZC5sZW5ndGgscz1mdW5jdGlvbih0LGUpe2lmKG51bGwhPT10KWZvcih2YXIgbiBpbiB0KWZvcih2YXIgaT1udWxsIT09dFtuXT90W25dLmxlbmd0aDowO2ktLTspaWYodFtuXVtpXT09PWUpcmV0dXJuIG47cmV0dXJuIG51bGx9O2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3MpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09ZSl7Zm9yKGk9MDtpPGw7aSsrKXIucHVzaCh0aGlzLkRpbWVuc2lvbih0aGlzLmlkW2ldKSk7cmV0dXJuIHJ9aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3ZhciBhPXRoaXMuaWRbZV07cmV0dXJuIHZvaWQgMCE9PWE/dGhpcy5EaW1lbnNpb24oYSxuKTpudWxsfXZhciBvPXRoaXMucm9sZTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSl7aWYoZS5oYXNPd25Qcm9wZXJ0eShcInJvbGVcIikpe2ZvcihpPTA7aTxsO2krKyl7dmFyIHU9dGhpcy5pZFtpXTtzKG8sdSk9PT1lLnJvbGUmJnIucHVzaCh0aGlzLkRpbWVuc2lvbih1LG4pKX1yZXR1cm4gdm9pZCAwPT09clswXT9udWxsOnJ9cmV0dXJuIG51bGx9dmFyIGg9dGhpcy5fX3RyZWVfXy5kaW1lbnNpb247aWYodm9pZCAwPT09aClyZXR1cm4gbnVsbDt2YXIgZj1oW2VdO3JldHVybiB2b2lkIDA9PT1mP251bGw6bj9uZXcgdCh7Y2xhc3M6XCJkaW1lbnNpb25cIixfX3RyZWVfXzpmLHJvbGU6cyhvLGUpfSk6ZnVuY3Rpb24odCxlKXt2YXIgbj1bXTtmb3IodmFyIGkgaW4gdCluW3RbaV1dPWVbaV07cmV0dXJuIG59KGYuY2F0ZWdvcnkuaW5kZXgsZi5jYXRlZ29yeS5sYWJlbCl9LHQucHJvdG90eXBlLkNhdGVnb3J5PWZ1bmN0aW9uKGUpe2lmKG51bGw9PT10aGlzfHxcImRpbWVuc2lvblwiIT09dGhpcy5jbGFzcylyZXR1cm4gbnVsbDtpZih2b2lkIDA9PT1lKXtmb3IodmFyIG49W10saT0wLHI9dGhpcy5pZC5sZW5ndGg7aTxyO2krKyluLnB1c2godGhpcy5DYXRlZ29yeSh0aGlzLmlkW2ldKSk7cmV0dXJuIG59aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3ZhciBsPXRoaXMuaWRbZV07cmV0dXJuIHZvaWQgMCE9PWw/dGhpcy5DYXRlZ29yeShsKTpudWxsfXZhciBzPXRoaXMuX190cmVlX18uY2F0ZWdvcnk7aWYodm9pZCAwPT09cylyZXR1cm4gbnVsbDt2YXIgYT1zLmluZGV4W2VdO2lmKHZvaWQgMD09PWEpcmV0dXJuIG51bGw7dmFyIG89cy51bml0JiZzLnVuaXRbZV18fG51bGwsdT1zLmNvb3JkaW5hdGVzJiZzLmNvb3JkaW5hdGVzW2VdfHxudWxsLGg9cy5jaGlsZCYmcy5jaGlsZFtlXXx8bnVsbCxmPXMubm90ZSYmcy5ub3RlW2VdfHxudWxsO3JldHVybiBuZXcgdCh7Y2xhc3M6XCJjYXRlZ29yeVwiLGluZGV4OmEsbGFiZWw6cy5sYWJlbFtlXSxub3RlOmYsY2hpbGQ6aCx1bml0Om8sY29vcmQ6dX0pfSx0LnByb3RvdHlwZS5EaWNlPWZ1bmN0aW9uKG4saSxyKXt2YXIgbCxzLGEsbyx1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaGFzT3duUHJvcGVydHkoZSkmJiEhdFtlXX07aWYobnVsbD09PXRoaXN8fFwiZGF0YXNldFwiIT09dGhpcy5jbGFzc3x8bnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIG51bGw7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG4pcmV0dXJuIHRoaXM7XCJvYmplY3RcIiE9dHlwZW9mIGk/KFwiYm9vbGVhblwiPT10eXBlb2YgaSYmITA9PT1pJiYobD0hMCksXCJib29sZWFuXCI9PXR5cGVvZiByJiYhMD09PXJ8fChyPSExKSk6KGw9dShpLFwiY2xvbmVcIikscj11KGksXCJkcm9wXCIpLHM9dShpLFwic3RyaW5naWZ5XCIpLGE9dShpLFwib3ZhbHVlXCIpLG89dShpLFwib3N0YXR1c1wiKSk7dmFyIGgsZj10aGlzLnZhbHVlLGM9bD9uZXcgdChKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMpKSk6dGhpcyxkPWMuc3RhdHVzLHY9W10seT1bXSxwPWZ1bmN0aW9uKHQsZSl7dmFyIG4saSxyLGw9KG49dCxpPWUscj17fSxBcnJheS5pc0FycmF5KG5baV0pPyhuW2ldLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7bnVsbCE9PXQmJihyW1N0cmluZyhlKV09dCl9KSkscik6bltpXSk7ZGVsZXRlIHRbZV0sdFtlXT1sfTtBcnJheS5pc0FycmF5KG4pJiYobj1mdW5jdGlvbih0KXt2YXIgZT17fTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RbMF1dPXRbMV19KSksZX0obikpLG51bGw9PT1uJiYobj17fSk7dmFyIGc9T2JqZWN0LmtleXMobik7cmV0dXJuIGcubGVuZ3RoPjAmJihnLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPW5bdF07QXJyYXkuaXNBcnJheShlKXx8KG5bdF09W2VdKSwwPT09blt0XS5sZW5ndGgmJmRlbGV0ZSBuW3RdfSkpLHImJihuPWZ1bmN0aW9uKHQpe3ZhciBlPXt9O3JldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXtlW25dPWMuRGltZW5zaW9uKG4pLmlkLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuLTE9PT10W25dLmluZGV4T2YoZSl9KSl9KSksZX0obikpLGMudG9UYWJsZSh7dHlwZTpcImFycm9ialwiLGNvbnRlbnQ6XCJpZFwiLHN0YXR1czohMH0pLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7dmFyIGk9W107Zy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgcj1uW2VdLGw9W107ci5mb3JFYWNoKChmdW5jdGlvbihuKXtsLnB1c2godFtlXT09PW4pfSkpLGkucHVzaCgtMSE9PWwuaW5kZXhPZighMCkpfSkpLC0xPT09aS5pbmRleE9mKCExKSYmKHYucHVzaCh0LnZhbHVlKSx5LnB1c2godC5zdGF0dXMpKX0pKSxnLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWMuRGltZW5zaW9uKHQpLmlkLGk9MCxyPXt9O2Muc2l6ZVtjLmlkLmluZGV4T2YodCldPW5bdF0ubGVuZ3RoLGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7LTEhPT1uW3RdLmluZGV4T2YoZSkmJihyW2VdPWksaSsrKX0pKSxjLl9fdHJlZV9fLmRpbWVuc2lvblt0XS5jYXRlZ29yeS5pbmRleD1yfSkpLGMubj12Lmxlbmd0aCxjLnZhbHVlPWMuX190cmVlX18udmFsdWU9ZShmKT9mdW5jdGlvbih0LGUpe3JldHVybiBlLmZyb20odCl9KHYsZi5jb25zdHJ1Y3Rvcik6dixjLnN0YXR1cz1jLl9fdHJlZV9fLnN0YXR1cz1udWxsIT09ZD95Om51bGwpLHM/KChoPWMuX190cmVlX18pLmhhc093blByb3BlcnR5KFwiaWRcIil8fChoLnZlcnNpb249XCIyLjBcIixoLmhhc093blByb3BlcnR5KFwiY2xhc3NcIil8fChoLmNsYXNzPVwiZGF0YXNldFwiKSxoLmlkPWguZGltZW5zaW9uLmlkLGguc2l6ZT1oLmRpbWVuc2lvbi5zaXplLGRlbGV0ZSBoLmRpbWVuc2lvbi5pZCxkZWxldGUgaC5kaW1lbnNpb24uc2l6ZSxoLmRpbWVuc2lvbi5oYXNPd25Qcm9wZXJ0eShcInJvbGVcIikmJihoLnJvbGU9aC5kaW1lbnNpb24ucm9sZSxkZWxldGUgaC5kaW1lbnNpb24ucm9sZSkpLGguaGFzT3duUHJvcGVydHkoXCJzdGF0dXNcIikmJi0xIT09W1wibnVsbFwiLFwie31cIixcIltdXCJdLmluZGV4T2YoSlNPTi5zdHJpbmdpZnkoaC5zdGF0dXMpKSYmZGVsZXRlIGguc3RhdHVzLGguaGFzT3duUHJvcGVydHkoXCJyb2xlXCIpJiYoZGVsZXRlIGgucm9sZS5jbGFzc2lmaWNhdGlvbixbXCJnZW9cIixcInRpbWVcIixcIm1ldHJpY1wiXS5mb3JFYWNoKChmdW5jdGlvbih0KXtudWxsPT09aC5yb2xlW3RdJiZkZWxldGUgaC5yb2xlW3RdfSkpKSxhJiZwKGgsXCJ2YWx1ZVwiKSxvJiZoLmhhc093blByb3BlcnR5KFwic3RhdHVzXCIpJiZwKGgsXCJzdGF0dXNcIiksSlNPTi5zdHJpbmdpZnkoaCkpOmN9LHQucHJvdG90eXBlLlNsaWNlPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3N8fDA9PT1PYmplY3QuZW50cmllcyh0aGlzLnZhbHVlKS5sZW5ndGgpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcztpZighQXJyYXkuaXNBcnJheSh0KSl7dmFyIGUsbj1bXTtmb3IoZSBpbiB0KW4ucHVzaChbZSx0W2VdXSk7dD1ufXJldHVybiB0aGlzLkRpY2UodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblt0WzBdLFt0WzFdXV19KSkpfSx0LnByb3RvdHlwZS5EYXRhPWZ1bmN0aW9uKHQsZSl7dmFyIG4saSxyPVtdLGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gZX07aWYobnVsbD09PXRoaXN8fFwiZGF0YXNldFwiIT09dGhpcy5jbGFzc3x8bnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09dCl7Zm9yKGk9dGhpcy52YWx1ZS5sZW5ndGgsbj0wO248aTtuKyspci5wdXNoKHRoaXMuRGF0YShuKSk7cmV0dXJuIHJ9aWYoXCJib29sZWFuXCIhPXR5cGVvZiBlJiYoZT0hMCksXCJudW1iZXJcIj09dHlwZW9mIHQpe3ZhciBzPXRoaXMudmFsdWVbdF07cmV0dXJuIHZvaWQgMD09PXM/bnVsbDplP3t2YWx1ZTpzLHN0YXR1czp0aGlzLnN0YXR1cz90aGlzLnN0YXR1c1t0XTpudWxsfTpzfXZhciBhPVwib2JqZWN0XCIsbz10aGlzLl9fdHJlZV9fLHU9by5zaXplfHxvLmRpbWVuc2lvbiYmby5kaW1lbnNpb24uc2l6ZSxoPXUubGVuZ3RoO2lmKEFycmF5LmlzQXJyYXkodCkpe2lmKCFBcnJheS5pc0FycmF5KHRbMF0pKXtpZih0aGlzLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiBudWxsO3ZhciBmPTEsYz0wLGQ9W10sdj1bXTtmb3Iobj0wO248aDtuKyspaWYodm9pZCAwIT09dFtuXSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHRbbl18fHRbbl0+PXVbbl0pcmV0dXJuIG51bGw7Yys9KGYqPW4+MD91W2gtbl06MSkqdFtoLW4tMV19ZWxzZSBkLnB1c2gobiksdi5wdXNoKHVbbl0pO2lmKGQubGVuZ3RoPjEpcmV0dXJuIG51bGw7aWYoMT09PWQubGVuZ3RoKXtmb3IodmFyIHk9MCxwPXZbMF07eTxwO3krKyl7dmFyIGc9W107Zm9yKG49MDtuPGg7bisrKW4hPT1kWzBdP2cucHVzaCh0W25dKTpnLnB1c2goeSk7ci5wdXNoKHRoaXMuRGF0YShnLGUpKX1yZXR1cm4gcn1yZXR1cm4gZT97dmFsdWU6dGhpcy52YWx1ZVtjXSxzdGF0dXM6dGhpcy5zdGF0dXM/dGhpcy5zdGF0dXNbY106bnVsbH06dGhpcy52YWx1ZVtjXX1hPVwiYXJyYXlcIn12YXIgYj1mdW5jdGlvbih0LGUsbil7dmFyIGkscj1bXSxzPXt9LGE9dC5kaW1lbnNpb24sbz10LmlkfHxhLmlkLHU9dC5zaXplfHxhJiZhLnNpemU7aWYoXCJhcnJheVwiPT09bil7Zm9yKGk9ZS5sZW5ndGg7aS0tOylzW2VbaV1bMF1dPWVbaV1bMV07ZT1zfWZvcih2YXIgaD0wLGY9by5sZW5ndGg7aDxmO2grKyl7dmFyIGM9b1toXSxkPWVbY107ci5wdXNoKFwic3RyaW5nXCI9PXR5cGVvZiBkP2Q6MT09PXVbaF0/bChhW2NdLmNhdGVnb3J5LmluZGV4KTpudWxsKX1yZXR1cm4gcn0obyx0LGEpLG09W10sXz1vLmRpbWVuc2lvbix4PW8uaWR8fF8uaWQ7Zm9yKG49MCxpPWIubGVuZ3RoO248aTtuKyspbS5wdXNoKF9beFtuXV0uY2F0ZWdvcnkuaW5kZXhbYltuXV0pO3JldHVybiB0aGlzLkRhdGEobSxlKX0sdC5wcm90b3R5cGUudG9UYWJsZT1mdW5jdGlvbih0LGUpe2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3N8fG51bGw9PT10aGlzLnZhbHVlKXJldHVybiBudWxsOzE9PWFyZ3VtZW50cy5sZW5ndGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihlPXQsdD1udWxsKSxcImFycm9ialwiIT09KHQ9dHx8e2ZpZWxkOlwibGFiZWxcIixjb250ZW50OlwibGFiZWxcIix2bGFiZWw6XCJWYWx1ZVwiLHNsYWJlbDpcIlN0YXR1c1wiLHR5cGU6XCJhcnJheVwiLHN0YXR1czohMSx1bml0OiExLGJ5Om51bGwscHJlZml4OlwiXCIsZHJvcDpbXSxtZXRhOiExLGNvbW1hOiExLGJ5bGFiZWw6ITF9KS50eXBlJiZcIm9iamFyclwiIT09dC50eXBlfHx2b2lkIDAhPT10LmZpZWxkfHwodC5maWVsZD1cImlkXCIpO3ZhciBpLHIsbCxzLGEsbyx1LGgsZixjPVwiaWRcIj09PXQuZmllbGQsZD1mdW5jdGlvbih0KXtyZXR1cm4oYz9cInZhbHVlXCI6dCl8fFwiVmFsdWVcIn0sdj1mdW5jdGlvbih0KXtyZXR1cm4oYz9cInN0YXR1c1wiOnQpfHxcIlN0YXR1c1wifSx5PXRoaXMuX190cmVlX18scD0hMD09PXQuc3RhdHVzO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpe2k9dGhpcy50b1RhYmxlKHQpO3ZhciBnPVtdLGI9XCJhcnJheVwiIT09dC50eXBlPzA6MTtmb3IoYT0oVj1cIm9iamVjdFwiIT09dC50eXBlP2kuc2xpY2UoYik6aS5yb3dzLnNsaWNlKDApKS5sZW5ndGgscj0wO3I8YTtyKyspe3ZhciBtPWUuY2FsbCh0aGlzLFZbcl0scik7dm9pZCAwIT09bSYmZy5wdXNoKG0pfXJldHVyblwib2JqZWN0XCI9PT10LnR5cGU/e2NvbHM6aS5jb2xzLHJvd3M6Z306KFwiYXJyYXlcIj09PXQudHlwZSYmZy51bnNoaWZ0KGlbMF0pLGcpfWlmKFwiYXJyb2JqXCI9PT10LnR5cGV8fFwib2JqYXJyXCI9PT10LnR5cGUpe3ZhciBfPVtdLHg9eS5yb2xlJiZ5LnJvbGUubWV0cmljLE89ZnVuY3Rpb24oKXt9LEE9e30sdz10aGlzLGo9dy5pZCxrPXQuYnkmJi0xIT09ai5pbmRleE9mKHQuYnkpP3QuYnk6bnVsbCxEPSEwPT09dC5tZXRhLFA9dm9pZCAwIT09dC5kcm9wJiZBcnJheS5pc0FycmF5KHQuZHJvcCk/dC5kcm9wOltdLEU9ITA9PT10LmNvbW1hLHo9ITA9PT10LmJ5bGFiZWwsUz13LnZhbHVlLmNvbnN0cnVjdG9yLEk9ZnVuY3Rpb24oZSl7dmFyIGkscj17fSxsPWQodC52bGFiZWwpO2lmKFwib2JqYXJyXCI9PT10LnR5cGUmJihpPW51bGw9PT1rJiZuKFMubmFtZSk/ZnVuY3Rpb24odCl7clt0XT10PT09bD9TLmZyb20oZSwoZnVuY3Rpb24oZSl7cmV0dXJuIGVbdF19KSk6ZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlW3RdfSkpfTpmdW5jdGlvbih0KXtyW3RdPWUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZVt0XX0pKX0sT2JqZWN0LmtleXMoZVswXSkuZm9yRWFjaChpKSxlPXIpLEQpe3I9e307cmV0dXJuIGouZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dy5EaW1lbnNpb24odCk7clt0XT17bGFiZWw6ZS5sYWJlbCxyb2xlOmUucm9sZSxjYXRlZ29yaWVzOntpZDplLmlkLGxhYmVsOncuRGltZW5zaW9uKHQsITEpfX19KSkse21ldGE6e2xhYmVsOncubGFiZWwsc291cmNlOncuc291cmNlLHVwZGF0ZWQ6dy51cGRhdGVkLGlkOmosc3RhdHVzOnAsdW5pdDp0LnVuaXQsYnk6ayxieWxhYmVsOnosZHJvcDpudWxsIT09ayYmUC5sZW5ndGg+MD9QOm51bGwscHJlZml4Om51bGwhPT1rP0d8fFwiXCI6bnVsbCxjb21tYTpFLGRpbWVuc2lvbnM6cn0sZGF0YTplfX1yZXR1cm4gZX07ayYmKHQuZmllbGQ9XCJpZFwiKTt2YXIgQz0oaT10aGlzLnRvVGFibGUoe2ZpZWxkOnQuZmllbGQsdmxhYmVsOnQudmxhYmVsLHNsYWJlbDp0LnNsYWJlbCxjb250ZW50OnQuY29udGVudCxzdGF0dXM6cH0pKS5zaGlmdCgpO2lmKG51bGw9PT1rJiZ0LnVuaXQmJngpe2lmKFwiaWRcIiE9PXQuY29udGVudClmb3IodmFyIFQ9eC5sZW5ndGg7VC0tOyl7dmFyIFU9dGhpcy5EaW1lbnNpb24oeFtUXSk7QVt4W1RdXT17fTtmb3IodmFyIEo9VS5sZW5ndGg7Si0tOylBW3hbVF1dW1UuQ2F0ZWdvcnkoSikubGFiZWxdPVUuaWRbSl19Tz1mdW5jdGlvbihlLG4pe2lmKC0xIT09eC5pbmRleE9mKGUpKXt2YXIgaT15LmRpbWVuc2lvbltlXS5jYXRlZ29yeTtpLnVuaXQ/Ti51bml0PWkudW5pdFtcImlkXCIhPT10LmNvbnRlbnQ/QVtlXVtuXTpuXTpOLnVuaXQ9bnVsbH19LHQudW5pdD0hMH1lbHNlIHQudW5pdD0hMTtmb3IoYT1pLmxlbmd0aCxyPTA7cjxhO3IrKyl7dmFyIE49e307Zm9yKGw9aVtyXS5sZW5ndGg7bC0tOylOW0NbbF1dPWlbcl1bbF0sTyhDW2xdLGlbcl1bbF0pO18ucHVzaChOKX1pZihFJiZfLmZvckVhY2goKGZ1bmN0aW9uKHQpe251bGwhPT10LnZhbHVlJiYodC52YWx1ZT0oXCJcIit0LnZhbHVlKS5yZXBsYWNlKFwiLlwiLFwiLFwiKSl9KSksbnVsbCE9PWspe3ZhciBCLEY9e30sVj1bXSxxPXt9LEc9dm9pZCAwIT09dC5wcmVmaXg/dC5wcmVmaXg6XCJcIjtQLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7KCF3LkRpbWVuc2lvbih0KXx8dy5EaW1lbnNpb24odCkubGVuZ3RoPjEpJiYoUFtlXT1cIlwiKX0pKTt2YXIgSD1qLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQhPT1rJiYtMT09PVAuaW5kZXhPZih0KX0pKSxLPXcuRGltZW5zaW9uKGspO2Zvcih2YXIgTCBpblwiaWRcIiE9PXQuY29udGVudD96P0I9ZnVuY3Rpb24odCxlLG4pe3RbZV1bRytuW2tdXT1uLnZhbHVlfTooSy5DYXRlZ29yeSgpLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7cVt0LmxhYmVsXT1LLmlkW2VdfSkpLEI9ZnVuY3Rpb24odCxlLG4pe3RbZV1bRytxW25ba11dXT1uLnZhbHVlfSk6Qj1mdW5jdGlvbih0LGUsbil7dFtlXVtHK25ba11dPW4udmFsdWV9LF8uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1bXTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlKXtuLnB1c2godFtlXSl9KSksbi5qb2luKFwiXFx0XCIpfSh0LEgpO3ZvaWQgMD09PUZbZV0mJihGW2VdPWZ1bmN0aW9uKHQsZSl7dmFyIG49e307cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bltlXT10W2VdfSkpLG59KHQsSCkpLEIoRixlLHQsayl9KSksRilWLnB1c2goRltMXSk7cmV0dXJuIHA9ITEsSShWKX1yZXR1cm4gSShfKX1pZihcIm9iamVjdFwiPT09dC50eXBlKXt2YXIgTT1cIm51bWJlclwiPT10eXBlb2YgdGhpcy52YWx1ZVswXXx8bnVsbD09PXRoaXMudmFsdWVbMF0/XCJudW1iZXJcIjpcInN0cmluZ1wiO289ZnVuY3Rpb24odCxlKXt2YXIgbj1jJiZ0fHxlfHx0O2l0LnB1c2goe2lkOnQsbGFiZWw6bix0eXBlOlwic3RyaW5nXCJ9KX0sdT1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZCh0KSxyPXYoZSk7biYmaXQucHVzaCh7aWQ6XCJzdGF0dXNcIixsYWJlbDpyLHR5cGU6XCJzdHJpbmdcIn0pLGl0LnB1c2goe2lkOlwidmFsdWVcIixsYWJlbDppLHR5cGU6TX0pfSxoPWZ1bmN0aW9uKHQpe3l0LnB1c2goe3Y6dH0pfSxmPWZ1bmN0aW9uKHQpe3l0LnB1c2goe3Y6dH0pLHJ0LnB1c2goe2M6eXR9KX19ZWxzZSBvPWZ1bmN0aW9uKHQsZSl7dmFyIG49YyYmdHx8ZXx8dDtpdC5wdXNoKG4pfSx1PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1kKHQpLHI9dihlKTtuJiZpdC5wdXNoKHIpLGl0LnB1c2goaSksbnQucHVzaChpdCl9LGg9ZnVuY3Rpb24odCl7eXQucHVzaCh0KX0sZj1mdW5jdGlvbih0KXt5dC5wdXNoKHQpLG50LnB1c2goeXQpfTt2YXIgUT15LmRpbWVuc2lvbixSPXkuaWR8fFEuaWQsVz15LnNpemV8fFEuc2l6ZSxYPVIubGVuZ3RoO2lmKFghPVcubGVuZ3RoKXJldHVybiExO3ZhciBZPVtdLFo9MSwkPShUPTEsW10pLHR0PVtdLGV0PVtdLG50PVtdLGl0PVtdLHJ0PVtdO2ZvcihyPTA7cjxYO3IrKyl7dmFyIGx0PVJbcl07byhsdCxRW2x0XS5sYWJlbCksWio9V1tyXSxUKj1XW3JdO3ZhciBzdD1bXTtmb3IobD0wO2w8V1tyXTtsKyspZm9yKHZhciBhdCBpbiBRW1Jbcl1dLmNhdGVnb3J5LmluZGV4KWlmKFFbUltyXV0uY2F0ZWdvcnkuaW5kZXhbYXRdPT09bCl7dmFyIG90PVwiaWRcIiE9PXQuY29udGVudCYmUVtSW3JdXS5jYXRlZ29yeS5sYWJlbD9RW1Jbcl1dLmNhdGVnb3J5LmxhYmVsW2F0XTphdDtzdC5wdXNoKG90KX1ZLnB1c2goc3QpLCQucHVzaChUKX1mb3IodSh0LnZsYWJlbCx0LnNsYWJlbCxwKSxhPVkubGVuZ3RoLHI9MDtyPGE7cisrKXtmb3IodmFyIHV0PVtdLGh0PTAsZnQ9WVtyXS5sZW5ndGg7aHQ8ZnQ7aHQrKylmb3IodmFyIGN0PTA7Y3Q8Wi8kW3JdO2N0KyspdXQucHVzaChZW3JdW2h0XSk7dHQucHVzaCh1dCl9Zm9yKGE9dHQubGVuZ3RoLHI9MDtyPGE7cisrKXt2YXIgZHQ9W10sdnQ9MDtmb3Iocz0wO3M8WjtzKyspZHQucHVzaCh0dFtyXVt2dF0pLCsrdnQ9PT10dFtyXS5sZW5ndGgmJih2dD0wKTtldC5wdXNoKGR0KX1mb3Iocz0wO3M8WjtzKyspe3ZhciB5dD1bXTthPXR0Lmxlbmd0aDtmb3IodmFyIHB0PTA7cHQ8YTtwdCsrKWgoZXRbcHRdW3NdKTtwJiZoKHRoaXMuc3RhdHVzP3RoaXMuc3RhdHVzW3NdOm51bGwpLGYodGhpcy52YWx1ZVtzXSl9cmV0dXJuXCJvYmplY3RcIj09PXQudHlwZT97Y29sczppdCxyb3dzOnJ0fTpudH0sdC5wcm90b3R5cGUubm9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fdHJlZV9ffSx0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfTtleHBvcnR7ciBhcyBkZWZhdWx0fTtcbiIsIi8qKlxuICogW1NpbXBsZSBsaW5lYXIgcmVncmVzc2lvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfbGluZWFyX3JlZ3Jlc3Npb24pXG4gKiBpcyBhIHNpbXBsZSB3YXkgdG8gZmluZCBhIGZpdHRlZCBsaW5lXG4gKiBiZXR3ZWVuIGEgc2V0IG9mIGNvb3JkaW5hdGVzLiBUaGlzIGFsZ29yaXRobSBmaW5kcyB0aGUgc2xvcGUgYW5kIHktaW50ZXJjZXB0IG9mIGEgcmVncmVzc2lvbiBsaW5lXG4gKiB1c2luZyB0aGUgbGVhc3Qgc3VtIG9mIHNxdWFyZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGF0YSBhbiBhcnJheSBvZiB0d28tZWxlbWVudCBvZiBhcnJheXMsXG4gKiBsaWtlIGBbWzAsIDFdLCBbMiwgM11dYFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgc2xvcGUgYW5kIGludGVyc2VjdCBvZiByZWdyZXNzaW9uIGxpbmVcbiAqIEBleGFtcGxlXG4gKiBsaW5lYXJSZWdyZXNzaW9uKFtbMCwgMF0sIFsxLCAxXV0pOyAvLyA9PiB7IG06IDEsIGI6IDAgfVxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uKGRhdGEpIHtcbiAgICB2YXIgbTtcbiAgICB2YXIgYjtcblxuICAgIC8vIFN0b3JlIGRhdGEgbGVuZ3RoIGluIGEgbG9jYWwgdmFyaWFibGUgdG8gcmVkdWNlXG4gICAgLy8gcmVwZWF0ZWQgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgLy9pZiB0aGVyZSdzIG9ubHkgb25lIHBvaW50LCBhcmJpdHJhcmlseSBjaG9vc2UgYSBzbG9wZSBvZiAwXG4gICAgLy9hbmQgYSB5LWludGVyY2VwdCBvZiB3aGF0ZXZlciB0aGUgeSBvZiB0aGUgaW5pdGlhbCBwb2ludCBpc1xuICAgIGlmIChkYXRhTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBiID0gZGF0YVswXVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbml0aWFsaXplIG91ciBzdW1zIGFuZCBzY29wZSB0aGUgYG1gIGFuZCBgYmBcbiAgICAgICAgLy8gdmFyaWFibGVzIHRoYXQgZGVmaW5lIHRoZSBsaW5lLlxuICAgICAgICB2YXIgc3VtWCA9IDA7XG4gICAgICAgIHZhciBzdW1ZID0gMDtcbiAgICAgICAgdmFyIHN1bVhYID0gMDtcbiAgICAgICAgdmFyIHN1bVhZID0gMDtcblxuICAgICAgICAvLyBVc2UgbG9jYWwgdmFyaWFibGVzIHRvIGdyYWIgcG9pbnQgdmFsdWVzXG4gICAgICAgIC8vIHdpdGggbWluaW1hbCBvYmplY3QgcHJvcGVydHkgbG9va3Vwc1xuICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcblxuICAgICAgICAvLyBHYXRoZXIgdGhlIHN1bSBvZiBhbGwgeCB2YWx1ZXMsIHRoZSBzdW0gb2YgYWxsXG4gICAgICAgIC8vIHkgdmFsdWVzLCBhbmQgdGhlIHN1bSBvZiB4XjIgYW5kICh4KnkpIGZvciBlYWNoXG4gICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBtYXRoIG5vdGF0aW9uLCB0aGVzZSB3b3VsZCBiZSBTU194LCBTU195LCBTU194eCwgYW5kIFNTX3h5XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgICAgICAgICB4ID0gcG9pbnRbMF07XG4gICAgICAgICAgICB5ID0gcG9pbnRbMV07XG5cbiAgICAgICAgICAgIHN1bVggKz0geDtcbiAgICAgICAgICAgIHN1bVkgKz0geTtcblxuICAgICAgICAgICAgc3VtWFggKz0geCAqIHg7XG4gICAgICAgICAgICBzdW1YWSArPSB4ICogeTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBtYCBpcyB0aGUgc2xvcGUgb2YgdGhlIHJlZ3Jlc3Npb24gbGluZVxuICAgICAgICBtID1cbiAgICAgICAgICAgIChkYXRhTGVuZ3RoICogc3VtWFkgLSBzdW1YICogc3VtWSkgL1xuICAgICAgICAgICAgKGRhdGFMZW5ndGggKiBzdW1YWCAtIHN1bVggKiBzdW1YKTtcblxuICAgICAgICAvLyBgYmAgaXMgdGhlIHktaW50ZXJjZXB0IG9mIHRoZSBsaW5lLlxuICAgICAgICBiID0gc3VtWSAvIGRhdGFMZW5ndGggLSAobSAqIHN1bVgpIC8gZGF0YUxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYm90aCB2YWx1ZXMgYXMgYW4gb2JqZWN0LlxuICAgIHJldHVybiB7XG4gICAgICAgIG06IG0sXG4gICAgICAgIGI6IGJcbiAgICB9O1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBvdXRwdXQgb2YgYGxpbmVhclJlZ3Jlc3Npb25gOiBhbiBvYmplY3RcbiAqIHdpdGggYG1gIGFuZCBgYmAgdmFsdWVzIGluZGljYXRpbmcgc2xvcGUgYW5kIGludGVyY2VwdCxcbiAqIHJlc3BlY3RpdmVseSwgZ2VuZXJhdGUgYSBsaW5lIGZ1bmN0aW9uIHRoYXQgdHJhbnNsYXRlc1xuICogeCB2YWx1ZXMgaW50byB5IHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWIgb2JqZWN0IHdpdGggYG1gIGFuZCBgYmAgbWVtYmVycywgcmVwcmVzZW50aW5nXG4gKiBzbG9wZSBhbmQgaW50ZXJzZWN0IG9mIGRlc2lyZWQgbGluZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBtZXRob2QgdGhhdCBjb21wdXRlcyB5LXZhbHVlIGF0IGFueSBnaXZlblxuICogeC12YWx1ZSBvbiB0aGUgbGluZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbCA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24oW1swLCAwXSwgWzEsIDFdXSkpO1xuICogbCgwKSAvLyA9IDBcbiAqIGwoMikgLy8gPSAyXG4gKiBsaW5lYXJSZWdyZXNzaW9uTGluZSh7IGI6IDAsIG06IDEgfSkoMSk7IC8vID0+IDFcbiAqIGxpbmVhclJlZ3Jlc3Npb25MaW5lKHsgYjogMSwgbTogMSB9KSgxKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uTGluZShtYiAvKjogeyBiOiBudW1iZXIsIG06IG51bWJlciB9Ki8pIHtcbiAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIGEgYHlgIHZhbHVlIGZvciBlYWNoXG4gICAgLy8geCB2YWx1ZSBpdCBpcyBnaXZlbiwgYmFzZWQgb24gdGhlIHZhbHVlcyBvZiBgYmAgYW5kIGBhYFxuICAgIC8vIHRoYXQgd2UganVzdCBjb21wdXRlZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG1iLmIgKyBtYi5tICogeDtcbiAgICB9O1xufVxuXG4vKipcbiAqIE91ciBkZWZhdWx0IHN1bSBpcyB0aGUgW0thaGFuLUJhYnVza2EgYWxnb3JpdGhtXShodHRwczovL3BkZnMuc2VtYW50aWNzY2hvbGFyLm9yZy8xNzYwLzdkNDY3Y2RhMWQwMjc3YWQyNzJkZWIyMTEzNTMzMTMxZGMwOS5wZGYpLlxuICogVGhpcyBtZXRob2QgaXMgYW4gaW1wcm92ZW1lbnQgb3ZlciB0aGUgY2xhc3NpY2FsXG4gKiBbS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FoYW5fc3VtbWF0aW9uX2FsZ29yaXRobSkuXG4gKiBJdCBhaW1zIGF0IGNvbXB1dGluZyB0aGUgc3VtIG9mIGEgbGlzdCBvZiBudW1iZXJzIHdoaWxlIGNvcnJlY3RpbmcgZm9yXG4gKiBmbG9hdGluZy1wb2ludCBlcnJvcnMuIFRyYWRpdGlvbmFsbHksIHN1bXMgYXJlIGNhbGN1bGF0ZWQgYXMgbWFueVxuICogc3VjY2Vzc2l2ZSBhZGRpdGlvbnMsIGVhY2ggb25lIHdpdGggaXRzIG93biBmbG9hdGluZy1wb2ludCByb3VuZG9mZi4gVGhlc2VcbiAqIGxvc3NlcyBpbiBwcmVjaXNpb24gYWRkIHVwIGFzIHRoZSBudW1iZXIgb2YgbnVtYmVycyBpbmNyZWFzZXMuIFRoaXMgYWx0ZXJuYXRpdmVcbiAqIGFsZ29yaXRobSBpcyBtb3JlIGFjY3VyYXRlIHRoYW4gdGhlIHNpbXBsZSB3YXkgb2YgY2FsY3VsYXRpbmcgc3VtcyBieSBzaW1wbGVcbiAqIGFkZGl0aW9uLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHN1bSBvZiBhbGwgaW5wdXQgbnVtYmVyc1xuICogQGV4YW1wbGVcbiAqIHN1bShbMSwgMiwgM10pOyAvLyA9PiA2XG4gKi9cbmZ1bmN0aW9uIHN1bSh4KSB7XG4gICAgLy8gSWYgdGhlIGFycmF5IGlzIGVtcHR5LCB3ZSBuZWVkbid0IGJvdGhlciBjb21wdXRpbmcgaXRzIHN1bVxuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIHN1bSBhcyB0aGUgZmlyc3QgbnVtYmVyIGluIHRoZSBhcnJheVxuICAgIHZhciBzdW0gPSB4WzBdO1xuXG4gICAgLy8gS2VlcGluZyB0cmFjayBvZiB0aGUgZmxvYXRpbmctcG9pbnQgZXJyb3IgY29ycmVjdGlvblxuICAgIHZhciBjb3JyZWN0aW9uID0gMDtcblxuICAgIHZhciB0cmFuc2l0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBzdW0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeFtpXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNpdGlvbiA9IHN1bSArIHhbaV07XG5cbiAgICAgICAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY29ycmVjdGlvbiBpbiBhIGRpZmZlcmVudCBmYXNoaW9uXG4gICAgICAgIC8vIGlmIHRoZSBuZXcgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBhYnNvbHV0ZSBzdW1cbiAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPj0gTWF0aC5hYnMoeFtpXSkpIHtcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gKz0gc3VtIC0gdHJhbnNpdGlvbiArIHhbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3JyZWN0aW9uICs9IHhbaV0gLSB0cmFuc2l0aW9uICsgc3VtO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VtID0gdHJhbnNpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5pbmcgdGhlIGNvcnJlY3RlZCBzdW1cbiAgICByZXR1cm4gc3VtICsgY29ycmVjdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgbWVhbiwgX2Fsc28ga25vd24gYXMgYXZlcmFnZV8sXG4gKiBpcyB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMgb3ZlciB0aGUgbnVtYmVyIG9mIHZhbHVlcy5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQHJldHVybnMge251bWJlcn0gbWVhblxuICogQGV4YW1wbGVcbiAqIG1lYW4oWzAsIDEwXSk7IC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gbWVhbih4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSh4KSAvIHgubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBzdW0gb2YgZGV2aWF0aW9ucyB0byB0aGUgTnRoIHBvd2VyLlxuICogV2hlbiBuPTIgaXQncyB0aGUgc3VtIG9mIHNxdWFyZWQgZGV2aWF0aW9ucy5cbiAqIFdoZW4gbj0zIGl0J3MgdGhlIHN1bSBvZiBjdWJlZCBkZXZpYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geFxuICogQHBhcmFtIHtudW1iZXJ9IG4gcG93ZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHN1bSBvZiBudGggcG93ZXIgZGV2aWF0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5wdXQgPSBbMSwgMiwgM107XG4gKiAvLyBzaW5jZSB0aGUgdmFyaWFuY2Ugb2YgYSBzZXQgaXMgdGhlIG1lYW4gc3F1YXJlZFxuICogLy8gZGV2aWF0aW9ucywgd2UgY2FuIGNhbGN1bGF0ZSB0aGF0IHdpdGggc3VtTnRoUG93ZXJEZXZpYXRpb25zOlxuICogc3VtTnRoUG93ZXJEZXZpYXRpb25zKGlucHV0LCAyKSAvIGlucHV0Lmxlbmd0aDtcbiAqL1xuZnVuY3Rpb24gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgsIG4pIHtcbiAgICB2YXIgbWVhblZhbHVlID0gbWVhbih4KTtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgdGVtcFZhbHVlO1xuICAgIHZhciBpO1xuXG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb246IHdoZW4gbiBpcyAyICh3ZSdyZSBjb21wdXRpbmcgYSBudW1iZXIgc3F1YXJlZCksXG4gICAgLy8gbXVsdGlwbHlpbmcgdGhlIG51bWJlciBieSBpdHNlbGYgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiB1c2luZ1xuICAgIC8vIHRoZSBNYXRoLnBvdyBtZXRob2QuXG4gICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgICAgICBzdW0gKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4W2ldIC0gbWVhblZhbHVlLCBuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdW07XG59XG5cbi8qKlxuICogVGhlIFt2YXJpYW5jZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYW5jZSlcbiAqIGlzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW4uXG4gKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB2YXJpYW5jZSwgbm90IHNhbXBsZSB2YXJpYW5jZTpcbiAqIHNlZSB0aGUgYHNhbXBsZVZhcmlhbmNlYCBtZXRob2QgaWYgeW91IHdhbnQgYSBzYW1wbGUgbWVhc3VyZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBwb3B1bGF0aW9uIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB2YXJpYW5jZTogYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cbiAqIHplcm8gaW5kaWNhdGVzIHRoYXQgYWxsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHgncyBsZW5ndGggaXMgMFxuICogQGV4YW1wbGVcbiAqIHZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1LCA2XSk7IC8vID0+IDIuOTE2NjY2NjY2NjY2NjY2NVxuICovXG5mdW5jdGlvbiB2YXJpYW5jZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIG1lYW4gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGJldHdlZW4gdGhlXG4gICAgLy8gbWVhbiB2YWx1ZSBhbmQgZWFjaCB2YWx1ZS5cbiAgICByZXR1cm4gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgsIDIpIC8geC5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIFtzdGFuZGFyZCBkZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfZGV2aWF0aW9uKVxuICogaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YXJpYW5jZS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIHRoZSBwb3B1bGF0aW9uXG4gKiBzdGFuZGFyZCBkZXZpYXRpb24uIEl0J3MgdXNlZnVsIGZvciBtZWFzdXJpbmcgdGhlIGFtb3VudFxuICogb2YgdmFyaWF0aW9uIG9yIGRpc3BlcnNpb24gaW4gYSBzZXQgb2YgdmFsdWVzLlxuICpcbiAqIFN0YW5kYXJkIGRldmlhdGlvbiBpcyBvbmx5IGFwcHJvcHJpYXRlIGZvciBmdWxsLXBvcHVsYXRpb24ga25vd2xlZGdlOiBmb3JcbiAqIHNhbXBsZXMgb2YgYSBwb3B1bGF0aW9uLCB7QGxpbmsgc2FtcGxlU3RhbmRhcmREZXZpYXRpb259IGlzXG4gKiBtb3JlIGFwcHJvcHJpYXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc3RhbmRhcmQgZGV2aWF0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyaWFuY2UoWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gNFxuICogc3RhbmRhcmREZXZpYXRpb24oWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBzdGFuZGFyZERldmlhdGlvbih4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgdiA9IHZhcmlhbmNlKHgpO1xuICAgIHJldHVybiBNYXRoLnNxcnQodik7XG59XG5cbi8qKlxuICogVGhlIFtSIFNxdWFyZWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29lZmZpY2llbnRfb2ZfZGV0ZXJtaW5hdGlvbilcbiAqIHZhbHVlIG9mIGRhdGEgY29tcGFyZWQgd2l0aCBhIGZ1bmN0aW9uIGBmYFxuICogaXMgdGhlIHN1bSBvZiB0aGUgc3F1YXJlZCBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBwcmVkaWN0aW9uXG4gKiBhbmQgdGhlIGFjdHVhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSB4IGlucHV0IGRhdGE6IHRoaXMgc2hvdWxkIGJlIGRvdWJseS1uZXN0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gY2FsbGVkIG9uIGBbaV1bMF1gIHZhbHVlcyB3aXRoaW4gdGhlIGRhdGFzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHItc3F1YXJlZCB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIHZhciBzYW1wbGVzID0gW1swLCAwXSwgWzEsIDFdXTtcbiAqIHZhciByZWdyZXNzaW9uTGluZSA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24oc2FtcGxlcykpO1xuICogclNxdWFyZWQoc2FtcGxlcywgcmVncmVzc2lvbkxpbmUpOyAvLyA9IDEgdGhpcyBsaW5lIGlzIGEgcGVyZmVjdCBmaXRcbiAqL1xuZnVuY3Rpb24gclNxdWFyZWQoeCwgZnVuYykge1xuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXZlcmFnZSB5IHZhbHVlIGZvciB0aGUgYWN0dWFsXG4gICAgLy8gZGF0YSBzZXQgaW4gb3JkZXIgdG8gY29tcHV0ZSB0aGVcbiAgICAvLyBfdG90YWwgc3VtIG9mIHNxdWFyZXNfXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSB4W2ldWzFdO1xuICAgIH1cbiAgICB2YXIgYXZlcmFnZSA9IHN1bSAvIHgubGVuZ3RoO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgdG90YWwgc3VtIG9mIHNxdWFyZXMgLSB0aGVcbiAgICAvLyBzcXVhcmVkIGRpZmZlcmVuY2UgYmV0d2VlbiBlYWNoIHBvaW50XG4gICAgLy8gYW5kIHRoZSBhdmVyYWdlIG9mIGFsbCBwb2ludHMuXG4gICAgdmFyIHN1bU9mU3F1YXJlcyA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB4Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bU9mU3F1YXJlcyArPSBNYXRoLnBvdyhhdmVyYWdlIC0geFtqXVsxXSwgMik7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSBlc3RpbWF0ZSB0aGUgZXJyb3I6IHRoZSBzcXVhcmVkXG4gICAgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBlc3RpbWF0ZSBhbmQgdGhlIGFjdHVhbCBkYXRhXG4gICAgLy8gdmFsdWUgYXQgZWFjaCBwb2ludC5cbiAgICB2YXIgZXJyID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHgubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgZXJyICs9IE1hdGgucG93KHhba11bMV0gLSBmdW5jKHhba11bMF0pLCAyKTtcbiAgICB9XG5cbiAgICAvLyBBcyB0aGUgZXJyb3IgZ3Jvd3MgbGFyZ2VyLCBpdHMgcmF0aW8gdG8gdGhlXG4gICAgLy8gc3VtIG9mIHNxdWFyZXMgaW5jcmVhc2VzIGFuZCB0aGUgciBzcXVhcmVkXG4gICAgLy8gdmFsdWUgZ3Jvd3MgbG93ZXIuXG4gICAgcmV0dXJuIDEgLSBlcnIgLyBzdW1PZlNxdWFyZXM7XG59XG5cbi8qKlxuICogVGhlIFttb2RlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2RlXyUyOHN0YXRpc3RpY3MlMjkpIGlzIHRoZSBudW1iZXJcbiAqIHRoYXQgYXBwZWFycyBpbiBhIGxpc3QgdGhlIGhpZ2hlc3QgbnVtYmVyIG9mIHRpbWVzLlxuICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIG1vZGVzIGluIGEgbGlzdDogaW4gdGhlIGV2ZW50IG9mIGEgdGllLCB0aGlzXG4gKiBhbGdvcml0aG0gd2lsbCByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgc2VlbiBtb2RlLlxuICpcbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgIGJlY2F1c2UgdGhlIGlucHV0IGlzIHNvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNvcnRlZCBhIHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gbW9kZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHNvcnRlZCBpcyBlbXB0eVxuICogQGV4YW1wbGVcbiAqIG1vZGVTb3J0ZWQoWzAsIDAsIDFdKTsgLy8gPT4gMFxuICovXG5mdW5jdGlvbiBtb2RlU29ydGVkKHNvcnRlZCkge1xuICAgIC8vIEhhbmRsZSBlZGdlIGNhc2VzOlxuICAgIC8vIFRoZSBtb2RlIG9mIGFuIGVtcHR5IGxpc3QgaXMgdW5kZWZpbmVkXG4gICAgaWYgKHNvcnRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG4gICAgaWYgKHNvcnRlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRlZFswXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGFzc3VtZXMgaXQgaXMgZGVhbGluZyB3aXRoIGFuIGFycmF5IG9mIHNpemUgPiAxLCBzaW5jZSBzaXplXG4gICAgLy8gMCBhbmQgMSBhcmUgaGFuZGxlZCBpbW1lZGlhdGVseS4gSGVuY2UgaXQgc3RhcnRzIGF0IGluZGV4IDEgaW4gdGhlXG4gICAgLy8gYXJyYXkuXG4gICAgdmFyIGxhc3QgPSBzb3J0ZWRbMF07XG4gICAgLy8gc3RvcmUgdGhlIG1vZGUgYXMgd2UgZmluZCBuZXcgbW9kZXNcbiAgICB2YXIgdmFsdWUgPSBOdW1iZXIuTmFOO1xuICAgIC8vIHN0b3JlIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHNlZW4gdGhlIG1vZGVcbiAgICB2YXIgbWF4U2VlbiA9IDA7XG4gICAgLy8gaG93IG1hbnkgdGltZXMgdGhlIGN1cnJlbnQgY2FuZGlkYXRlIGZvciB0aGUgbW9kZVxuICAgIC8vIGhhcyBiZWVuIHNlZW5cbiAgICB2YXIgc2VlblRoaXMgPSAxO1xuXG4gICAgLy8gZW5kIGF0IHNvcnRlZC5sZW5ndGggKyAxIHRvIGZpeCB0aGUgY2FzZSBpbiB3aGljaCB0aGUgbW9kZSBpc1xuICAgIC8vIHRoZSBoaWdoZXN0IG51bWJlciB0aGF0IG9jY3VycyBpbiB0aGUgc2VxdWVuY2UuIHRoZSBsYXN0IGl0ZXJhdGlvblxuICAgIC8vIGNvbXBhcmVzIHNvcnRlZFtpXSwgd2hpY2ggaXMgdW5kZWZpbmVkLCB0byB0aGUgaGlnaGVzdCBudW1iZXJcbiAgICAvLyBpbiB0aGUgc2VyaWVzXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzb3J0ZWQubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgIC8vIHdlJ3JlIHNlZWluZyBhIG5ldyBudW1iZXIgcGFzcyBieVxuICAgICAgICBpZiAoc29ydGVkW2ldICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAvLyB0aGUgbGFzdCBudW1iZXIgaXMgdGhlIG5ldyBtb2RlIHNpbmNlIHdlIHNhdyBpdCBtb3JlXG4gICAgICAgICAgICAvLyBvZnRlbiB0aGFuIHRoZSBvbGQgb25lXG4gICAgICAgICAgICBpZiAoc2VlblRoaXMgPiBtYXhTZWVuKSB7XG4gICAgICAgICAgICAgICAgbWF4U2VlbiA9IHNlZW5UaGlzO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5UaGlzID0gMTtcbiAgICAgICAgICAgIGxhc3QgPSBzb3J0ZWRbaV07XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzbid0IGEgbmV3IG51bWJlciwgaXQncyBvbmUgbW9yZSBvY2N1cnJlbmNlIG9mXG4gICAgICAgICAgICAvLyB0aGUgcG90ZW50aWFsIG1vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW5UaGlzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFNvcnQgYW4gYXJyYXkgb2YgbnVtYmVycyBieSB0aGVpciBudW1lcmljIHZhbHVlLCBlbnN1cmluZyB0aGF0IHRoZVxuICogYXJyYXkgaXMgbm90IGNoYW5nZWQgaW4gcGxhY2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiAuc29ydFxuICogaW4gSmF2YVNjcmlwdCBpcyB0byBzb3J0IGFycmF5cyBhcyBzdHJpbmcgdmFsdWVzXG4gKlxuICogICAgIFsxLCAxMCwgMTIsIDEwMiwgMjBdLnNvcnQoKVxuICogICAgIC8vIG91dHB1dFxuICogICAgIFsxLCAxMCwgMTAyLCAxMiwgMjBdXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBzb3J0ZWQgYXJyYXlcbiAqIEBwcml2YXRlXG4gKiBAZXhhbXBsZVxuICogbnVtZXJpY1NvcnQoWzMsIDIsIDFdKSAvLyA9PiBbMSwgMiwgM11cbiAqL1xuZnVuY3Rpb24gbnVtZXJpY1NvcnQoeCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHhcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgYXJyYXkgaXMgbm90IGNoYW5nZWQgaW4tcGxhY2VcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAvLyBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYXQgdHJlYXRzIGlucHV0IGFzIG51bWVyaWNcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSlcbiAgICApO1xufVxuXG4vKipcbiAqIFRoZSBbbW9kZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kZV8lMjhzdGF0aXN0aWNzJTI5KSBpcyB0aGUgbnVtYmVyXG4gKiB0aGF0IGFwcGVhcnMgaW4gYSBsaXN0IHRoZSBoaWdoZXN0IG51bWJlciBvZiB0aW1lcy5cbiAqIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSBtb2RlcyBpbiBhIGxpc3Q6IGluIHRoZSBldmVudCBvZiBhIHRpZSwgdGhpc1xuICogYWxnb3JpdGhtIHdpbGwgcmV0dXJuIHRoZSBtb3N0IHJlY2VudGx5IHNlZW4gbW9kZS5cbiAqXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4gbG9nKG4pKWAgYmVjYXVzZSBpdCBuZWVkcyB0byBzb3J0IHRoZSBhcnJheSBpbnRlcm5hbGx5XG4gKiBiZWZvcmUgcnVubmluZyBhbiBgTyhuKWAgc2VhcmNoIHRvIGZpbmQgdGhlIG1vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtb2RlXG4gKiBAZXhhbXBsZVxuICogbW9kZShbMCwgMCwgMV0pOyAvLyA9PiAwXG4gKi9cbmZ1bmN0aW9uIG1vZGUoeCkge1xuICAgIC8vIFNvcnRpbmcgdGhlIGFycmF5IGxldHMgdXMgaXRlcmF0ZSB0aHJvdWdoIGl0IGJlbG93IGFuZCBiZSBzdXJlXG4gICAgLy8gdGhhdCBldmVyeSB0aW1lIHdlIHNlZSBhIG5ldyBudW1iZXIgaXQncyBuZXcgYW5kIHdlJ2xsIG5ldmVyXG4gICAgLy8gc2VlIHRoZSBzYW1lIG51bWJlciB0d2ljZVxuICAgIHJldHVybiBtb2RlU29ydGVkKG51bWVyaWNTb3J0KHgpKTtcbn1cblxuLyogZ2xvYmFscyBNYXA6IGZhbHNlICovXG5cbi8qKlxuICogVGhlIFttb2RlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2RlXyUyOHN0YXRpc3RpY3MlMjkpIGlzIHRoZSBudW1iZXJcbiAqIHRoYXQgYXBwZWFycyBpbiBhIGxpc3QgdGhlIGhpZ2hlc3QgbnVtYmVyIG9mIHRpbWVzLlxuICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIG1vZGVzIGluIGEgbGlzdDogaW4gdGhlIGV2ZW50IG9mIGEgdGllLCB0aGlzXG4gKiBhbGdvcml0aG0gd2lsbCByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgc2VlbiBtb2RlLlxuICpcbiAqIG1vZGVGYXN0IHVzZXMgYSBNYXAgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIG1vZGUsIGluc3RlYWQgb2YgdGhlIGFwcHJvYWNoXG4gKiB1c2VkIHdpdGggYG1vZGVgLCBhIHNvcnRlZCBhcnJheS4gQXMgYSByZXN1bHQsIGl0IGlzIGZhc3RlclxuICogdGhhbiBgbW9kZWAgYW5kIHN1cHBvcnRzIGFueSBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBgPT1gLlxuICogSXQgYWxzbyByZXF1aXJlcyBhXG4gKiBbSmF2YVNjcmlwdCBlbnZpcm9ubWVudCB3aXRoIHN1cHBvcnQgZm9yIE1hcF0oaHR0cHM6Ly9rYW5nYXguZ2l0aHViLmlvL2NvbXBhdC10YWJsZS9lczYvI3Rlc3QtTWFwKSxcbiAqIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIE1hcCBpcyBub3QgYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB4IGEgc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7Pyp9IG1vZGVcbiAqIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBpZiB0aGUgSmF2YVNjcmlwdCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgTWFwXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBpcyBlbXB0eVxuICogQGV4YW1wbGVcbiAqIG1vZGVGYXN0KFsncmFiYml0cycsICdyYWJiaXRzJywgJ3NxdWlycmVscyddKTsgLy8gPT4gJ3JhYmJpdHMnXG4gKi9cbmZ1bmN0aW9uIG1vZGVGYXN0KHgpIHtcbiAgICAvLyBUaGlzIGluZGV4IHdpbGwgcmVmbGVjdCB0aGUgaW5jaWRlbmNlIG9mIGRpZmZlcmVudCB2YWx1ZXMsIGluZGV4aW5nXG4gICAgLy8gdGhlbSBsaWtlXG4gICAgLy8geyB2YWx1ZTogY291bnQgfVxuICAgIHZhciBpbmRleCA9IG5ldyBNYXAoKTtcblxuICAgIC8vIEEgcnVubmluZyBgbW9kZWAgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgaXQgaGFzIGJlZW4gZW5jb3VudGVyZWQuXG4gICAgdmFyIG1vZGU7XG4gICAgdmFyIG1vZGVDb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NvdW50ID0gaW5kZXguZ2V0KHhbaV0pO1xuICAgICAgICBpZiAobmV3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3Q291bnQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q291bnQgPiBtb2RlQ291bnQpIHtcbiAgICAgICAgICAgIG1vZGUgPSB4W2ldO1xuICAgICAgICAgICAgbW9kZUNvdW50ID0gbmV3Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXguc2V0KHhbaV0sIG5ld0NvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobW9kZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGUgcmVxdWlyZXMgYXQgbGFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZTtcbn1cblxuLyoqXG4gKiBUaGUgbWluIGlzIHRoZSBsb3dlc3QgbnVtYmVyIGluIHRoZSBhcnJheS5cbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gb25lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtaW5pbXVtIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogbWluKFsxLCA1LCAtMTAsIDEwMCwgMl0pOyAvLyA9PiAtMTBcbiAqL1xuZnVuY3Rpb24gbWluKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWluIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHhbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0geFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBjb21wdXRlcyB0aGUgbWF4aW11bSBudW1iZXIgaW4gYW4gYXJyYXkuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtYXhpbXVtIHZhbHVlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEBleGFtcGxlXG4gKiBtYXgoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IDRcbiAqL1xuZnVuY3Rpb24gbWF4KHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHhbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldID4gdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0geFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBjb21wdXRlcyB0aGUgbWluaW11bSAmIG1heGltdW0gbnVtYmVyIGluIGFuIGFycmF5LlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IG1pbmltdW0gJiBtYXhpbXVtIHZhbHVlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEBleGFtcGxlXG4gKiBleHRlbnQoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFsxLCA0XVxuICovXG5mdW5jdGlvbiBleHRlbnQoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnQgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IHhbMF07XG4gICAgdmFyIG1heCA9IHhbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB4W2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4W2ldIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSB4W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWluLCBtYXhdO1xufVxuXG4vKipcbiAqIFRoZSBtaW5pbXVtIGlzIHRoZSBsb3dlc3QgbnVtYmVyIGluIHRoZSBhcnJheS4gV2l0aCBhIHNvcnRlZCBhcnJheSxcbiAqIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBhbHdheXMgdGhlIHNtYWxsZXN0LCBzbyB0aGlzIGNhbGN1bGF0aW9uXG4gKiBjYW4gYmUgZG9uZSBpbiBvbmUgc3RlcCwgb3IgY29uc3RhbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1pbmltdW0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtaW5Tb3J0ZWQoWy0xMDAsIC0xMCwgMSwgMiwgNV0pOyAvLyA9PiAtMTAwXG4gKi9cbmZ1bmN0aW9uIG1pblNvcnRlZCh4KSB7XG4gICAgcmV0dXJuIHhbMF07XG59XG5cbi8qKlxuICogVGhlIG1heGltdW0gaXMgdGhlIGhpZ2hlc3QgbnVtYmVyIGluIHRoZSBhcnJheS4gV2l0aCBhIHNvcnRlZCBhcnJheSxcbiAqIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIGFsd2F5cyB0aGUgbGFyZ2VzdCwgc28gdGhpcyBjYWxjdWxhdGlvblxuICogY2FuIGJlIGRvbmUgaW4gb25lIHN0ZXAsIG9yIGNvbnN0YW50IHRpbWUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtYXhpbXVtIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogbWF4U29ydGVkKFstMTAwLCAtMTAsIDEsIDIsIDVdKTsgLy8gPT4gNVxuICovXG5mdW5jdGlvbiBtYXhTb3J0ZWQoeCkge1xuICAgIHJldHVybiB4W3gubGVuZ3RoIC0gMV07XG59XG5cbi8qKlxuICogVGhlIGV4dGVudCBpcyB0aGUgbG93ZXN0ICYgaGlnaGVzdCBudW1iZXIgaW4gdGhlIGFycmF5LiBXaXRoIGEgc29ydGVkIGFycmF5LFxuICogdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIGFsd2F5cyB0aGUgbG93ZXN0IHdoaWxlIHRoZSBsYXN0IGVsZW1lbnQgaXMgYWx3YXlzIHRoZSBsYXJnZXN0LCBzbyB0aGlzIGNhbGN1bGF0aW9uXG4gKiBjYW4gYmUgZG9uZSBpbiBvbmUgc3RlcCwgb3IgY29uc3RhbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBtaW5pbXVtICYgbWF4aW11bSB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIGV4dGVudFNvcnRlZChbLTEwMCwgLTEwLCAxLCAyLCA1XSk7IC8vID0+IFstMTAwLCA1XVxuICovXG5mdW5jdGlvbiBleHRlbnRTb3J0ZWQoeCkge1xuICAgIHJldHVybiBbeFswXSwgeFt4Lmxlbmd0aCAtIDFdXTtcbn1cblxuLyoqXG4gKiBUaGUgc2ltcGxlIFtzdW1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1bW1hdGlvbikgb2YgYW4gYXJyYXlcbiAqIGlzIHRoZSByZXN1bHQgb2YgYWRkaW5nIGFsbCBudW1iZXJzIHRvZ2V0aGVyLCBzdGFydGluZyBmcm9tIHplcm8uXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gc3VtIG9mIGFsbCBpbnB1dCBudW1iZXJzXG4gKiBAZXhhbXBsZVxuICogc3VtU2ltcGxlKFsxLCAyLCAzXSk7IC8vID0+IDZcbiAqL1xuZnVuY3Rpb24gc3VtU2ltcGxlKHgpIHtcbiAgICB2YXIgdmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIHhbaV0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IHhbaV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgW3Byb2R1Y3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2R1Y3RfKG1hdGhlbWF0aWNzKSkgb2YgYW4gYXJyYXlcbiAqIGlzIHRoZSByZXN1bHQgb2YgbXVsdGlwbHlpbmcgYWxsIG51bWJlcnMgdG9nZXRoZXIsIHN0YXJ0aW5nIHVzaW5nIG9uZSBhcyB0aGUgbXVsdGlwbGljYXRpdmUgaWRlbnRpdHkuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gcHJvZHVjdCBvZiBhbGwgaW5wdXQgbnVtYmVyc1xuICogQGV4YW1wbGVcbiAqIHByb2R1Y3QoWzEsIDIsIDMsIDRdKTsgLy8gPT4gMjRcbiAqL1xuZnVuY3Rpb24gcHJvZHVjdCh4KSB7XG4gICAgdmFyIHZhbHVlID0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgKj0geFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHF1YW50aWxlczogd2hlbiB5b3Uga25vd1xuICogdGhhdCB0aGUgb3JkZXIgaXMgc29ydGVkLCB5b3UgZG9uJ3QgbmVlZCB0byByZS1zb3J0IGl0LCBhbmQgdGhlIGNvbXB1dGF0aW9uc1xuICogYXJlIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gcCBkZXNpcmVkIHF1YW50aWxlOiBhIG51bWJlciBiZXR3ZWVuIDAgdG8gMSwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBxdWFudGlsZSB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHAgaXggb3V0c2lkZSBvZiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDFcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVTb3J0ZWQoWzMsIDYsIDcsIDgsIDgsIDksIDEwLCAxMywgMTUsIDE2LCAyMF0sIDAuNSk7IC8vID0+IDlcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQoeCwgcCkge1xuICAgIHZhciBpZHggPSB4Lmxlbmd0aCAqIHA7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInF1YW50aWxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50LlwiKTtcbiAgICB9IGVsc2UgaWYgKHAgPCAwIHx8IHAgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInF1YW50aWxlcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMVwiKTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFt4Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIDAsIGRpcmVjdGx5IHJldHVybiB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFswXTtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgcCBpcyBub3QgaW50ZWdlciwgcmV0dXJuIHRoZSBuZXh0IGVsZW1lbnQgaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHhbTWF0aC5jZWlsKGlkeCkgLSAxXTtcbiAgICB9IGVsc2UgaWYgKHgubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhpcyBudW1iZXJcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHZhbHVlLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgcmV0dXJuICh4W2lkeCAtIDFdICsgeFtpZHhdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgdmFsdWVcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgeCB2YWx1ZSBhdCB0aGUgaW5kZXguXG4gICAgICAgIHJldHVybiB4W2lkeF07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlYXJyYW5nZSBpdGVtcyBpbiBgYXJyYCBzbyB0aGF0IGFsbCBpdGVtcyBpbiBgW2xlZnQsIGtdYCByYW5nZSBhcmUgdGhlIHNtYWxsZXN0LlxuICogVGhlIGBrYC10aCBlbGVtZW50IHdpbGwgaGF2ZSB0aGUgYChrIC0gbGVmdCArIDEpYC10aCBzbWFsbGVzdCB2YWx1ZSBpbiBgW2xlZnQsIHJpZ2h0XWAuXG4gKlxuICogSW1wbGVtZW50cyBGbG95ZC1SaXZlc3Qgc2VsZWN0aW9uIGFsZ29yaXRobSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZC1SaXZlc3RfYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhcnIgaW5wdXQgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBrIHBpdm90IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW2xlZnRdIGxlZnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmlnaHRdIHJpZ2h0IGluZGV4XG4gKiBAcmV0dXJucyB7dm9pZH0gbXV0YXRlcyBpbnB1dCBhcnJheVxuICogQGV4YW1wbGVcbiAqIHZhciBhcnIgPSBbNjUsIDI4LCA1OSwgMzMsIDIxLCA1NiwgMjIsIDk1LCA1MCwgMTIsIDkwLCA1MywgMjgsIDc3LCAzOV07XG4gKiBxdWlja3NlbGVjdChhcnIsIDgpO1xuICogLy8gPSBbMzksIDI4LCAyOCwgMzMsIDIxLCAxMiwgMjIsIDUwLCA1MywgNTYsIDU5LCA2NSwgOTAsIDc3LCA5NV1cbiAqL1xuZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCkge1xuICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgcmlnaHQgPSByaWdodCB8fCBhcnIubGVuZ3RoIC0gMTtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgLy8gNjAwIGFuZCAwLjUgYXJlIGFyYml0cmFyeSBjb25zdGFudHMgY2hvc2VuIGluIHRoZSBvcmlnaW5hbCBwYXBlciB0byBtaW5pbWl6ZSBleGVjdXRpb24gdGltZVxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKCgyICogeikgLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCgoeiAqIHMgKiAobiAtIHMpKSAvIG4pO1xuICAgICAgICAgICAgaWYgKG0gLSBuIC8gMiA8IDApIHsgc2QgKj0gLTE7IH1cbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gKG0gKiBzKSAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcihrICsgKChuIC0gbSkgKiBzKSAvIG4gKyBzZClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gYXJyW2tdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoYXJyW3JpZ2h0XSA+IHQpIHsgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTsgfVxuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGFycltpXSA8IHQpIHsgaSsrOyB9XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2pdID4gdCkgeyBqLS07IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJbbGVmdF0gPT09IHQpIHsgc3dhcChhcnIsIGxlZnQsIGopOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIHsgbGVmdCA9IGogKyAxOyB9XG4gICAgICAgIGlmIChrIDw9IGopIHsgcmlnaHQgPSBqIC0gMTsgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbi8qKlxuICogVGhlIFtxdWFudGlsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUpOlxuICogdGhpcyBpcyBhIHBvcHVsYXRpb24gcXVhbnRpbGUsIHNpbmNlIHdlIGFzc3VtZSB0byBrbm93IHRoZSBlbnRpcmVcbiAqIGRhdGFzZXQgaW4gdGhpcyBsaWJyYXJ5LiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICogW1F1YW50aWxlcyBvZiBhIFBvcHVsYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUjUXVhbnRpbGVzX29mX2FfcG9wdWxhdGlvbilcbiAqIGFsZ29yaXRobSBmcm9tIHdpa2lwZWRpYS5cbiAqXG4gKiBTYW1wbGUgaXMgYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2YgbnVtYmVycyxcbiAqIGFuZCBwIGlzIGVpdGhlciBhIGRlY2ltYWwgbnVtYmVyIGZyb20gMCB0byAxIG9yIGFuIGFycmF5IG9mIGRlY2ltYWxcbiAqIG51bWJlcnMgZnJvbSAwIHRvIDEuXG4gKiBJbiB0ZXJtcyBvZiBhIGsvcSBxdWFudGlsZSwgcCA9IGsvcSAtIGl0J3MganVzdCBkZWFsaW5nIHdpdGggZnJhY3Rpb25zIG9yIGRlYWxpbmdcbiAqIHdpdGggZGVjaW1hbCB2YWx1ZXMuXG4gKiBXaGVuIHAgaXMgYW4gYXJyYXksIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlzIGFsc28gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYXBwcm9wcmlhdGVcbiAqIHF1YW50aWxlcyBpbiBpbnB1dCBvcmRlclxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+IHwgbnVtYmVyfSBwIHRoZSBkZXNpcmVkIHF1YW50aWxlLCBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHF1YW50aWxlXG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGUoWzMsIDYsIDcsIDgsIDgsIDksIDEwLCAxMywgMTUsIDE2LCAyMF0sIDAuNSk7IC8vID0+IDlcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGUoeCwgcCkge1xuICAgIHZhciBjb3B5ID0geC5zbGljZSgpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocCkpIHtcbiAgICAgICAgLy8gcmVhcnJhbmdlIGVsZW1lbnRzIHNvIHRoYXQgZWFjaCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSByZXF1ZXN0ZWRcbiAgICAgICAgLy8gcXVhbnRpbGUgaXMgb24gYSBwbGFjZSBpdCB3b3VsZCBiZSBpZiB0aGUgYXJyYXkgd2FzIGZ1bGx5IHNvcnRlZFxuICAgICAgICBtdWx0aVF1YW50aWxlU2VsZWN0KGNvcHksIHApO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgLy8gRm9yIGVhY2ggcmVxdWVzdGVkIHF1YW50aWxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHF1YW50aWxlU29ydGVkKGNvcHksIHBbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBxdWFudGlsZUluZGV4KGNvcHkubGVuZ3RoLCBwKTtcbiAgICAgICAgcXVhbnRpbGVTZWxlY3QoY29weSwgaWR4LCAwLCBjb3B5Lmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gcXVhbnRpbGVTb3J0ZWQoY29weSwgcCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBxdWFudGlsZVNlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGsgJSAxID09PSAwKSB7XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSBNYXRoLmZsb29yKGspO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrICsgMSwgayArIDEsIHJpZ2h0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG11bHRpUXVhbnRpbGVTZWxlY3QoYXJyLCBwKSB7XG4gICAgdmFyIGluZGljZXMgPSBbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaChxdWFudGlsZUluZGV4KGFyci5sZW5ndGgsIHBbaV0pKTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKGFyci5sZW5ndGggLSAxKTtcbiAgICBpbmRpY2VzLnNvcnQoY29tcGFyZSk7XG5cbiAgICB2YXIgc3RhY2sgPSBbMCwgaW5kaWNlcy5sZW5ndGggLSAxXTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHIgPSBNYXRoLmNlaWwoc3RhY2sucG9wKCkpO1xuICAgICAgICB2YXIgbCA9IE1hdGguZmxvb3Ioc3RhY2sucG9wKCkpO1xuICAgICAgICBpZiAociAtIGwgPD0gMSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtID0gTWF0aC5mbG9vcigobCArIHIpIC8gMik7XG4gICAgICAgIHF1YW50aWxlU2VsZWN0KFxuICAgICAgICAgICAgYXJyLFxuICAgICAgICAgICAgaW5kaWNlc1ttXSxcbiAgICAgICAgICAgIE1hdGguZmxvb3IoaW5kaWNlc1tsXSksXG4gICAgICAgICAgICBNYXRoLmNlaWwoaW5kaWNlc1tyXSlcbiAgICAgICAgKTtcblxuICAgICAgICBzdGFjay5wdXNoKGwsIG0sIG0sIHIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBxdWFudGlsZUluZGV4KGxlbiwgcCkge1xuICAgIHZhciBpZHggPSBsZW4gKiBwO1xuICAgIGlmIChwID09PSAxKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMSwgZGlyZWN0bHkgcmV0dXJuIHRoZSBsYXN0IGluZGV4XG4gICAgICAgIHJldHVybiBsZW4gLSAxO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIDAsIGRpcmVjdGx5IHJldHVybiB0aGUgZmlyc3QgaW5kZXhcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChpZHggJSAxICE9PSAwKSB7XG4gICAgICAgIC8vIElmIGluZGV4IGlzIG5vdCBpbnRlZ2VyLCByZXR1cm4gdGhlIG5leHQgaW5kZXggaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChpZHgpIC0gMTtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDIgPT09IDApIHtcbiAgICAgICAgLy8gSWYgdGhlIGxpc3QgaGFzIGV2ZW4tbGVuZ3RoLCB3ZSdsbCByZXR1cm4gdGhlIG1pZGRsZSBvZiB0d28gaW5kaWNlc1xuICAgICAgICAvLyBhcm91bmQgcXVhbnRpbGUgdG8gaW5kaWNhdGUgdGhhdCB3ZSBuZWVkIGFuIGF2ZXJhZ2UgdmFsdWUgb2YgdGhlIHR3b1xuICAgICAgICByZXR1cm4gaWR4IC0gMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpbmFsbHksIGluIHRoZSBzaW1wbGUgY2FzZSBvZiBhbiBpbnRlZ2VyIGluZGV4XG4gICAgICAgIC8vIHdpdGggYW4gb2RkLWxlbmd0aCBsaXN0LCByZXR1cm4gdGhlIGluZGV4XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxufVxuXG4vKiBlc2xpbnQgbm8tYml0d2lzZTogMCAqL1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcXVhbnRpbGUgaW4gd2hpY2ggb25lIHdvdWxkIGZpbmQgdGhlIGdpdmVuIHZhbHVlIGluXG4gKiB0aGUgZ2l2ZW4gYXJyYXkuIFdpdGggYSBzb3J0ZWQgYXJyYXksIGxldmVyYWdpbmcgYmluYXJ5IHNlYXJjaCwgd2UgY2FuIGZpbmRcbiAqIHRoaXMgaW5mb3JtYXRpb24gaW4gbG9nYXJpdGhtaWMgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVSYW5rU29ydGVkKFsxLCAyLCAzLCA0XSwgMyk7IC8vID0+IDAuNzVcbiAqIHF1YW50aWxlUmFua1NvcnRlZChbMSwgMiwgMywgMywgNF0sIDMpOyAvLyA9PiAwLjdcbiAqIHF1YW50aWxlUmFua1NvcnRlZChbMSwgMiwgMywgNF0sIDYpOyAvLyA9PiAxXG4gKiBxdWFudGlsZVJhbmtTb3J0ZWQoWzEsIDIsIDMsIDMsIDVdLCA0KTsgLy8gPT4gMC44XG4gKi9cbmZ1bmN0aW9uIHF1YW50aWxlUmFua1NvcnRlZCh4LCB2YWx1ZSkge1xuICAgIC8vIFZhbHVlIGlzIGxlc3NlciB0aGFuIGFueSB2YWx1ZSBpbiB0aGUgYXJyYXlcbiAgICBpZiAodmFsdWUgPCB4WzBdKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIFZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBhbnkgdmFsdWUgaW4gdGhlIGFycmF5XG4gICAgaWYgKHZhbHVlID4geFt4Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBsID0gbG93ZXJCb3VuZCh4LCB2YWx1ZSk7XG5cbiAgICAvLyBWYWx1ZSBpcyBub3QgaW4gdGhlIGFycmF5XG4gICAgaWYgKHhbbF0gIT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsIC8geC5sZW5ndGg7XG4gICAgfVxuXG4gICAgbCsrO1xuXG4gICAgdmFyIHUgPSB1cHBlckJvdW5kKHgsIHZhbHVlKTtcblxuICAgIC8vIFRoZSB2YWx1ZSBleGlzdHMgb25seSBvbmNlIGluIHRoZSBhcnJheVxuICAgIGlmICh1ID09PSBsKSB7XG4gICAgICAgIHJldHVybiBsIC8geC5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gSGVyZSwgd2UgYXJlIGJhc2ljYWxseSBjb21wdXRpbmcgdGhlIG1lYW4gb2YgdGhlIHJhbmdlIG9mIGluZGljZXNcbiAgICAvLyBjb250YWluaW5nIG91ciBzZWFyY2hlZCB2YWx1ZS4gQnV0LCBpbnN0ZWFkLCBvZiBpbml0aWFsaXppbmcgYW5cbiAgICAvLyBhcnJheSBhbmQgbG9vcGluZyBvdmVyIGl0LCB0aGVyZSBpcyBhIGRlZGljYXRlZCBtYXRoIGZvcm11bGEgdGhhdFxuICAgIC8vIHdlIGFwcGx5IGJlbG93IHRvIGdldCB0aGUgcmVzdWx0LlxuICAgIHZhciByID0gdSAtIGwgKyAxO1xuICAgIHZhciBzdW0gPSAociAqICh1ICsgbCkpIC8gMjtcbiAgICB2YXIgbWVhbiA9IHN1bSAvIHI7XG5cbiAgICByZXR1cm4gbWVhbiAvIHgubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBsb3dlckJvdW5kKHgsIHZhbHVlKSB7XG4gICAgdmFyIG1pZCA9IDA7XG4gICAgdmFyIGxvID0gMDtcbiAgICB2YXIgaGkgPSB4Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcblxuICAgICAgICBpZiAodmFsdWUgPD0geFttaWRdKSB7XG4gICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvID0gLX5taWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIHVwcGVyQm91bmQoeCwgdmFsdWUpIHtcbiAgICB2YXIgbWlkID0gMDtcbiAgICB2YXIgbG8gPSAwO1xuICAgIHZhciBoaSA9IHgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuXG4gICAgICAgIGlmICh2YWx1ZSA+PSB4W21pZF0pIHtcbiAgICAgICAgICAgIGxvID0gLX5taWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsbztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHF1YW50aWxlIGluIHdoaWNoIG9uZSB3b3VsZCBmaW5kIHRoZSBnaXZlbiB2YWx1ZSBpblxuICogdGhlIGdpdmVuIGFycmF5LiBJdCB3aWxsIGNvcHkgYW5kIHNvcnQgeW91ciBhcnJheSBiZWZvcmUgZWFjaCBydW4sIHNvXG4gKiBpZiB5b3Uga25vdyB5b3VyIGFycmF5IGlzIGFscmVhZHkgc29ydGVkLCB5b3Ugc2hvdWxkIHVzZSBgcXVhbnRpbGVSYW5rU29ydGVkYFxuICogaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVSYW5rKFs0LCAzLCAxLCAyXSwgMyk7IC8vID0+IDAuNzVcbiAqIHF1YW50aWxlUmFuayhbNCwgMywgMiwgMywgMV0sIDMpOyAvLyA9PiAwLjdcbiAqIHF1YW50aWxlUmFuayhbMiwgNCwgMSwgM10sIDYpOyAvLyA9PiAxXG4gKiBxdWFudGlsZVJhbmsoWzUsIDMsIDEsIDIsIDNdLCA0KTsgLy8gPT4gMC44XG4gKi9cbmZ1bmN0aW9uIHF1YW50aWxlUmFuayh4LCB2YWx1ZSkge1xuICAgIC8vIENsb25pbmcgYW5kIHNvcnRpbmcgdGhlIGFycmF5XG4gICAgdmFyIHNvcnRlZENvcHkgPSBudW1lcmljU29ydCh4KTtcblxuICAgIHJldHVybiBxdWFudGlsZVJhbmtTb3J0ZWQoc29ydGVkQ29weSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBbSW50ZXJxdWFydGlsZSByYW5nZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnF1YXJ0aWxlX3JhbmdlKSBpc1xuICogYSBtZWFzdXJlIG9mIHN0YXRpc3RpY2FsIGRpc3BlcnNpb24sIG9yIGhvdyBzY2F0dGVyZWQsIHNwcmVhZCwgb3JcbiAqIGNvbmNlbnRyYXRlZCBhIGRpc3RyaWJ1dGlvbiBpcy4gSXQncyBjb21wdXRlZCBhcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gKiB0aGUgdGhpcmQgcXVhcnRpbGUgYW5kIGZpcnN0IHF1YXJ0aWxlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHJldHVybnMge251bWJlcn0gaW50ZXJxdWFydGlsZSByYW5nZTogdGhlIHNwYW4gYmV0d2VlbiBsb3dlciBhbmQgdXBwZXIgcXVhcnRpbGUsXG4gKiAwLjI1IGFuZCAwLjc1XG4gKiBAZXhhbXBsZVxuICogaW50ZXJxdWFydGlsZVJhbmdlKFswLCAxLCAyLCAzXSk7IC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gaW50ZXJxdWFydGlsZVJhbmdlKHgpIHtcbiAgICAvLyBJbnRlcnF1YXJ0aWxlIHJhbmdlIGlzIHRoZSBzcGFuIGJldHdlZW4gdGhlIHVwcGVyIHF1YXJ0aWxlLFxuICAgIC8vIGF0IGAwLjc1YCwgYW5kIGxvd2VyIHF1YXJ0aWxlLCBgMC4yNWBcbiAgICB2YXIgcTEgPSBxdWFudGlsZSh4LCAwLjc1KTtcbiAgICB2YXIgcTIgPSBxdWFudGlsZSh4LCAwLjI1KTtcblxuICAgIGlmICh0eXBlb2YgcTEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHEyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBxMSAtIHEyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgW21lZGlhbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZWRpYW4pIGlzXG4gKiB0aGUgbWlkZGxlIG51bWJlciBvZiBhIGxpc3QuIFRoaXMgaXMgb2Z0ZW4gYSBnb29kIGluZGljYXRvciBvZiAndGhlIG1pZGRsZSdcbiAqIHdoZW4gdGhlcmUgYXJlIG91dGxpZXJzIHRoYXQgc2tldyB0aGUgYG1lYW4oKWAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhlIG1lZGlhbiBpc24ndCBuZWNlc3NhcmlseSBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBsaXN0OiB0aGUgdmFsdWVcbiAqIGNhbiBiZSB0aGUgYXZlcmFnZSBvZiB0d28gZWxlbWVudHMgaWYgdGhlIGxpc3QgaGFzIGFuIGV2ZW4gbGVuZ3RoXG4gKiBhbmQgdGhlIHR3byBjZW50cmFsIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gbWVkaWFuIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogbWVkaWFuKFsxMCwgMiwgNSwgMTAwLCAyLCAxXSk7IC8vID0+IDMuNVxuICovXG5mdW5jdGlvbiBtZWRpYW4oeCkge1xuICAgIHJldHVybiArcXVhbnRpbGUoeCwgMC41KTtcbn1cblxuLyoqXG4gKiBUaGUgW01lZGlhbiBBYnNvbHV0ZSBEZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVkaWFuX2Fic29sdXRlX2RldmlhdGlvbikgaXNcbiAqIGEgcm9idXN0IG1lYXN1cmUgb2Ygc3RhdGlzdGljYWxcbiAqIGRpc3BlcnNpb24uIEl0IGlzIG1vcmUgcmVzaWxpZW50IHRvIG91dGxpZXJzIHRoYW4gdGhlIHN0YW5kYXJkIGRldmlhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXQgYXJyYXlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1lZGlhbiBhYnNvbHV0ZSBkZXZpYXRpb25cbiAqIEBleGFtcGxlXG4gKiBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbihbMSwgMSwgMiwgMiwgNCwgNiwgOV0pOyAvLyA9PiAxXG4gKi9cbmZ1bmN0aW9uIG1lZGlhbkFic29sdXRlRGV2aWF0aW9uKHgpIHtcbiAgICB2YXIgbWVkaWFuVmFsdWUgPSBtZWRpYW4oeCk7XG4gICAgdmFyIG1lZGlhbkFic29sdXRlRGV2aWF0aW9ucyA9IFtdO1xuXG4gICAgLy8gTWFrZSBhIGxpc3Qgb2YgYWJzb2x1dGUgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWRpYW5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb25zLnB1c2goTWF0aC5hYnMoeFtpXSAtIG1lZGlhblZhbHVlKSk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgbWVkaWFuIHZhbHVlIG9mIHRoYXQgbGlzdFxuICAgIHJldHVybiBtZWRpYW4obWVkaWFuQWJzb2x1dGVEZXZpYXRpb25zKTtcbn1cblxuLyoqXG4gKiBTcGxpdCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBhIHNwZWNpZmllZCBzaXplLiBUaGlzIGZ1bmN0aW9uXG4gKiBoYXMgdGhlIHNhbWUgYmVoYXZpb3IgYXMgW1BIUCdzIGFycmF5X2NodW5rXShodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uYXJyYXktY2h1bmsucGhwKVxuICogZnVuY3Rpb24sIGFuZCB0aHVzIHdpbGwgaW5zZXJ0IHNtYWxsZXItc2l6ZWQgY2h1bmtzIGF0IHRoZSBlbmQgaWZcbiAqIHRoZSBpbnB1dCBzaXplIGlzIG5vdCBkaXZpc2libGUgYnkgdGhlIGNodW5rIHNpemUuXG4gKlxuICogYHhgIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5LCBhbmQgYGNodW5rU2l6ZWAgYSBudW1iZXIuXG4gKiBUaGUgYHhgIGFycmF5IGNhbiBjb250YWluIGFueSBraW5kIG9mIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBhIHNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGNodW5rU2l6ZSBzaXplIG9mIGVhY2ggb3V0cHV0IGFycmF5LiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYSBjaHVua2VkIGFycmF5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2h1bmsgc2l6ZSBpcyBsZXNzIHRoYW4gMSBvciBub3QgYW4gaW50ZWdlclxuICogQGV4YW1wbGVcbiAqIGNodW5rKFsxLCAyLCAzLCA0LCA1LCA2XSwgMik7XG4gKiAvLyA9PiBbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV1cbiAqL1xuZnVuY3Rpb24gY2h1bmsoeCwgY2h1bmtTaXplKSB7XG4gICAgLy8gYSBsaXN0IG9mIHJlc3VsdCBjaHVua3MsIGFzIGFycmF5cyBpbiBhbiBhcnJheVxuICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgIC8vIGBjaHVua1NpemVgIG11c3QgYmUgemVybyBvciBoaWdoZXIgLSBvdGhlcndpc2UgdGhlIGxvb3AgYmVsb3csXG4gICAgLy8gaW4gd2hpY2ggd2UgY2FsbCBgc3RhcnQgKz0gY2h1bmtTaXplYCwgd2lsbCBsb29wIGluZmluaXRlbHkuXG4gICAgLy8gU28sIHdlJ2xsIGRldGVjdCBhbmQgdGhyb3cgaW4gdGhhdCBjYXNlIHRvIGluZGljYXRlXG4gICAgLy8gaW52YWxpZCBpbnB1dC5cbiAgICBpZiAoY2h1bmtTaXplIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaHVuayBzaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguZmxvb3IoY2h1bmtTaXplKSAhPT0gY2h1bmtTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rIHNpemUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgIH1cblxuICAgIC8vIGBzdGFydGAgaXMgdGhlIGluZGV4IGF0IHdoaWNoIGAuc2xpY2VgIHdpbGwgc3RhcnQgc2VsZWN0aW5nXG4gICAgLy8gbmV3IGFycmF5IGVsZW1lbnRzXG4gICAgZm9yICh2YXIgc3RhcnQgPSAwOyBzdGFydCA8IHgubGVuZ3RoOyBzdGFydCArPSBjaHVua1NpemUpIHtcbiAgICAgICAgLy8gZm9yIGVhY2ggY2h1bmssIHNsaWNlIHRoYXQgcGFydCBvZiB0aGUgYXJyYXkgYW5kIGFkZCBpdFxuICAgICAgICAvLyB0byB0aGUgb3V0cHV0LiBUaGUgYC5zbGljZWAgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICAgICAgb3V0cHV0LnB1c2goeC5zbGljZShzdGFydCwgc3RhcnQgKyBjaHVua1NpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBTYW1wbGluZyB3aXRoIHJlcGxhY2VtZW50IGlzIGEgdHlwZSBvZiBzYW1wbGluZyB0aGF0IGFsbG93cyB0aGUgc2FtZVxuICogaXRlbSB0byBiZSBwaWNrZWQgb3V0IG9mIGEgcG9wdWxhdGlvbiBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB4IGFuIGFycmF5IG9mIGFueSBraW5kIG9mIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBjb3VudCBvZiBob3cgbWFueSBlbGVtZW50cyB0byB0YWtlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmFuZG9tU291cmNlPU1hdGgucmFuZG9tXSBhbiBvcHRpb25hbCBlbnRyb3B5IHNvdXJjZSB0aGF0XG4gKiByZXR1cm5zIG51bWJlcnMgYmV0d2VlbiAwIGluY2x1c2l2ZSBhbmQgMSBleGNsdXNpdmU6IHRoZSByYW5nZSBbMCwgMSlcbiAqIEByZXR1cm4ge0FycmF5fSBuIHNhbXBsZWQgaXRlbXMgZnJvbSB0aGUgcG9wdWxhdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciB2YWx1ZXMgPSBbMSwgMiwgMywgNF07XG4gKiBzYW1wbGVXaXRoUmVwbGFjZW1lbnQodmFsdWVzLCAyKTsgLy8gcmV0dXJucyAyIHJhbmRvbSB2YWx1ZXMsIGxpa2UgWzIsIDRdO1xuICovXG5mdW5jdGlvbiBzYW1wbGVXaXRoUmVwbGFjZW1lbnQoeCwgbiwgcmFuZG9tU291cmNlKSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBhIGN1c3RvbSByYW5kb20gbnVtYmVyIHNvdXJjZSBjYW4gYmUgcHJvdmlkZWQgaWYgeW91IHdhbnQgdG8gdXNlXG4gICAgLy8gYSBmaXhlZCBzZWVkIG9yIGFub3RoZXIgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IsIGxpa2VcbiAgICAvLyBbcmFuZG9tLWpzXShodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9yYW5kb20tanMpXG4gICAgcmFuZG9tU291cmNlID0gcmFuZG9tU291cmNlIHx8IE1hdGgucmFuZG9tO1xuXG4gICAgdmFyIGxlbmd0aCA9IHgubGVuZ3RoO1xuICAgIHZhciBzYW1wbGUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IocmFuZG9tU291cmNlKCkgKiBsZW5ndGgpO1xuXG4gICAgICAgIHNhbXBsZS5wdXNoKHhbaW5kZXhdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2FtcGxlO1xufVxuXG4vKipcbiAqIEEgW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlciVFMiU4MCU5M1lhdGVzX3NodWZmbGUpXG4gKiBpbi1wbGFjZSAtIHdoaWNoIG1lYW5zIHRoYXQgaXQgKip3aWxsIGNoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsXG4gKiBhcnJheSBieSByZWZlcmVuY2UqKi5cbiAqXG4gKiBUaGlzIGlzIGFuIGFsZ29yaXRobSB0aGF0IGdlbmVyYXRlcyBhIHJhbmRvbSBbcGVybXV0YXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Blcm11dGF0aW9uKVxuICogb2YgYSBzZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdFxuICogcmV0dXJucyBudW1iZXJzIGJldHdlZW4gMCBpbmNsdXNpdmUgYW5kIDEgZXhjbHVzaXZlOiB0aGUgcmFuZ2UgWzAsIDEpXG4gKiBAcmV0dXJucyB7QXJyYXl9IHhcbiAqIEBleGFtcGxlXG4gKiB2YXIgeCA9IFsxLCAyLCAzLCA0XTtcbiAqIHNodWZmbGVJblBsYWNlKHgpO1xuICogLy8geCBpcyBzaHVmZmxlZCB0byBhIHZhbHVlIGxpa2UgWzIsIDEsIDQsIDNdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVJblBsYWNlKHgsIHJhbmRvbVNvdXJjZSkge1xuICAgIC8vIGEgY3VzdG9tIHJhbmRvbSBudW1iZXIgc291cmNlIGNhbiBiZSBwcm92aWRlZCBpZiB5b3Ugd2FudCB0byB1c2VcbiAgICAvLyBhIGZpeGVkIHNlZWQgb3IgYW5vdGhlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvciwgbGlrZVxuICAgIC8vIFtyYW5kb20tanNdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL3JhbmRvbS1qcylcbiAgICByYW5kb21Tb3VyY2UgPSByYW5kb21Tb3VyY2UgfHwgTWF0aC5yYW5kb207XG5cbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHggdG8gZGV0ZXJtaW5lXG4gICAgLy8gd2hlbiBubyBlbGVtZW50cyByZW1haW4gdG8gc2h1ZmZsZS5cbiAgICB2YXIgbGVuZ3RoID0geC5sZW5ndGg7XG5cbiAgICAvLyB0ZW1wb3JhcnkgaXMgdXNlZCB0byBob2xkIGFuIGl0ZW0gd2hlbiBpdCBpcyBiZWluZ1xuICAgIC8vIHN3YXBwZWQgYmV0d2VlbiBpbmRpY2VzLlxuICAgIHZhciB0ZW1wb3Jhcnk7XG5cbiAgICAvLyBUaGUgaW5kZXggdG8gc3dhcCBhdCBlYWNoIHN0YWdlLlxuICAgIHZhciBpbmRleDtcblxuICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBzdGlsbCBpdGVtcyB0byBzaHVmZmxlXG4gICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gY2hvb3NlIGEgcmFuZG9tIGluZGV4IHdpdGhpbiB0aGUgc3Vic2V0IG9mIHRoZSBhcnJheVxuICAgICAgICAvLyB0aGF0IGlzIG5vdCB5ZXQgc2h1ZmZsZWRcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKHJhbmRvbVNvdXJjZSgpICogbGVuZ3RoLS0pO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSB2YWx1ZSB0aGF0IHdlJ2xsIG1vdmUgdGVtcG9yYXJpbHlcbiAgICAgICAgdGVtcG9yYXJ5ID0geFtsZW5ndGhdO1xuXG4gICAgICAgIC8vIHN3YXAgdGhlIHZhbHVlIGF0IGB4W2xlbmd0aF1gIHdpdGggYHhbaW5kZXhdYFxuICAgICAgICB4W2xlbmd0aF0gPSB4W2luZGV4XTtcbiAgICAgICAgeFtpbmRleF0gPSB0ZW1wb3Jhcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG59XG5cbi8qKlxuICogQSBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZSlcbiAqIGlzIGEgZmFzdCB3YXkgdG8gY3JlYXRlIGEgcmFuZG9tIHBlcm11dGF0aW9uIG9mIGEgZmluaXRlIHNldC4gVGhpcyBpc1xuICogYSBmdW5jdGlvbiBhcm91bmQgYHNodWZmbGVfaW5fcGxhY2VgIHRoYXQgYWRkcyB0aGUgZ3VhcmFudGVlIHRoYXRcbiAqIGl0IHdpbGwgbm90IG1vZGlmeSBpdHMgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBzYW1wbGUgb2YgMCBvciBtb3JlIG51bWJlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlIHRoYXRcbiAqIHJldHVybnMgbnVtYmVycyBiZXR3ZWVuIDAgaW5jbHVzaXZlIGFuZCAxIGV4Y2x1c2l2ZTogdGhlIHJhbmdlIFswLCAxKVxuICogQHJldHVybiB7QXJyYXl9IHNodWZmbGVkIHZlcnNpb24gb2YgaW5wdXRcbiAqIEBleGFtcGxlXG4gKiB2YXIgc2h1ZmZsZWQgPSBzaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gKiBzaHVmZmxlZDsgLy8gPSBbMiwgMywgMSwgNF0gb3IgYW55IG90aGVyIHJhbmRvbSBwZXJtdXRhdGlvblxuICovXG5mdW5jdGlvbiBzaHVmZmxlKHgsIHJhbmRvbVNvdXJjZSkge1xuICAgIC8vIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheSBzbyB0aGF0IGl0IGlzIG5vdCBtb2RpZmllZFxuICAgIHZhciBzYW1wbGUgPSB4LnNsaWNlKCk7XG5cbiAgICAvLyBhbmQgdGhlbiBzaHVmZmxlIHRoYXQgc2hhbGxvdy1jb3BpZWQgYXJyYXksIGluIHBsYWNlXG4gICAgcmV0dXJuIHNodWZmbGVJblBsYWNlKHNhbXBsZSwgcmFuZG9tU291cmNlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBbc2ltcGxlIHJhbmRvbSBzYW1wbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2ltcGxlX3JhbmRvbV9zYW1wbGUpXG4gKiBmcm9tIGEgZ2l2ZW4gYXJyYXkgb2YgYG5gIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBzYW1wbGVkIHZhbHVlcyB3aWxsIGJlIGluIGFueSBvcmRlciwgbm90IG5lY2Vzc2FyaWx5IHRoZSBvcmRlclxuICogdGhleSBhcHBlYXIgaW4gdGhlIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0geCBpbnB1dCBhcnJheS4gY2FuIGNvbnRhaW4gYW55IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIGNvdW50IG9mIGhvdyBtYW55IGVsZW1lbnRzIHRvIHRha2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlIHRoYXRcbiAqIHJldHVybnMgbnVtYmVycyBiZXR3ZWVuIDAgaW5jbHVzaXZlIGFuZCAxIGV4Y2x1c2l2ZTogdGhlIHJhbmdlIFswLCAxKVxuICogQHJldHVybiB7QXJyYXl9IHN1YnNldCBvZiBuIGVsZW1lbnRzIGluIG9yaWdpbmFsIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB2YWx1ZXMgPSBbMSwgMiwgNCwgNSwgNiwgNywgOCwgOV07XG4gKiBzYW1wbGUodmFsdWVzLCAzKTsgLy8gcmV0dXJucyAzIHJhbmRvbSB2YWx1ZXMsIGxpa2UgWzIsIDUsIDhdO1xuICovXG5mdW5jdGlvbiBzYW1wbGUoeCwgbiwgcmFuZG9tU291cmNlKSB7XG4gICAgLy8gc2h1ZmZsZSB0aGUgb3JpZ2luYWwgYXJyYXkgdXNpbmcgYSBmaXNoZXIteWF0ZXMgc2h1ZmZsZVxuICAgIHZhciBzaHVmZmxlZCA9IHNodWZmbGUoeCwgcmFuZG9tU291cmNlKTtcblxuICAgIC8vIGFuZCB0aGVuIHJldHVybiBhIHN1YnNldCBvZiBpdCAtIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMuXG4gICAgcmV0dXJuIHNodWZmbGVkLnNsaWNlKDAsIG4pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjb2x1bW4geCByb3cgbWF0cml4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBtYXRyaXhcbiAqIEBleGFtcGxlXG4gKiBtYWtlTWF0cml4KDEwLCAxMCk7XG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXRyaXgoY29sdW1ucywgcm93cykge1xuICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICB2YXIgY29sdW1uID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93czsgaisrKSB7XG4gICAgICAgICAgICBjb2x1bW4ucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXgucHVzaChjb2x1bW4pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufVxuXG4vKipcbiAqIEZvciBhIHNvcnRlZCBpbnB1dCwgY291bnRpbmcgdGhlIG51bWJlciBvZiB1bmlxdWUgdmFsdWVzXG4gKiBpcyBwb3NzaWJsZSBpbiBjb25zdGFudCB0aW1lIGFuZCBjb25zdGFudCBtZW1vcnkuIFRoaXMgaXNcbiAqIGEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBhbGdvcml0aG0uXG4gKlxuICogVmFsdWVzIGFyZSBjb21wYXJlZCB3aXRoIGA9PT1gLCBzbyBvYmplY3RzIGFuZCBub24tcHJpbWl0aXZlIG9iamVjdHNcbiAqIGFyZSBub3QgaGFuZGxlZCBpbiBhbnkgc3BlY2lhbCB3YXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTwqPn0geCBhbiBhcnJheSBvZiBhbnkga2luZCBvZiB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gY291bnQgb2YgdW5pcXVlIHZhbHVlc1xuICogQGV4YW1wbGVcbiAqIHVuaXF1ZUNvdW50U29ydGVkKFsxLCAyLCAzXSk7IC8vID0+IDNcbiAqIHVuaXF1ZUNvdW50U29ydGVkKFsxLCAxLCAxXSk7IC8vID0+IDFcbiAqL1xuZnVuY3Rpb24gdW5pcXVlQ291bnRTb3J0ZWQoeCkge1xuICAgIHZhciB1bmlxdWVWYWx1ZUNvdW50ID0gMDtcbiAgICB2YXIgbGFzdFNlZW5WYWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgeFtpXSAhPT0gbGFzdFNlZW5WYWx1ZSkge1xuICAgICAgICAgICAgbGFzdFNlZW5WYWx1ZSA9IHhbaV07XG4gICAgICAgICAgICB1bmlxdWVWYWx1ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZVZhbHVlQ291bnQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGluY3JlbWVudGFsbHkgY29tcHV0ZWQgdmFsdWVzIGJhc2VkIG9uIHRoZSBzdW1zIGFuZCBzdW1zIG9mXG4gKiBzcXVhcmVzIGZvciB0aGUgZGF0YSBhcnJheVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0galxuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc3Vtc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zT2ZTcXVhcmVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAZXhhbXBsZVxuICogc3NxKDAsIDEsIFstMSwgMCwgMl0sIFsxLCAxLCA1XSk7XG4gKi9cbmZ1bmN0aW9uIHNzcShqLCBpLCBzdW1zLCBzdW1zT2ZTcXVhcmVzKSB7XG4gICAgdmFyIHNqaTsgLy8gcyhqLCBpKVxuICAgIGlmIChqID4gMCkge1xuICAgICAgICB2YXIgbXVqaSA9IChzdW1zW2ldIC0gc3Vtc1tqIC0gMV0pIC8gKGkgLSBqICsgMSk7IC8vIG11KGosIGkpXG4gICAgICAgIHNqaSA9XG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzW2ldIC0gc3Vtc09mU3F1YXJlc1tqIC0gMV0gLSAoaSAtIGogKyAxKSAqIG11amkgKiBtdWppO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNqaSA9IHN1bXNPZlNxdWFyZXNbaV0gLSAoc3Vtc1tpXSAqIHN1bXNbaV0pIC8gKGkgKyAxKTtcbiAgICB9XG4gICAgaWYgKHNqaSA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBzamk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZWN1cnNpdmVseSBkaXZpZGVzIGFuZCBjb25xdWVycyBjb21wdXRhdGlvbnNcbiAqIGZvciBjbHVzdGVyIGpcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGlNaW4gTWluaW11bSBpbmRleCBpbiBjbHVzdGVyIHRvIGJlIGNvbXB1dGVkXG4gKiBAcGFyYW0ge251bWJlcn0gaU1heCBNYXhpbXVtIGluZGV4IGluIGNsdXN0ZXIgdG8gYmUgY29tcHV0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbHVzdGVyIEluZGV4IG9mIHRoZSBjbHVzdGVyIGN1cnJlbnRseSBiZWluZyBjb21wdXRlZFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0cml4XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBiYWNrdHJhY2tNYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc3Vtc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zT2ZTcXVhcmVzXG4gKi9cbmZ1bmN0aW9uIGZpbGxNYXRyaXhDb2x1bW4oXG4gICAgaU1pbixcbiAgICBpTWF4LFxuICAgIGNsdXN0ZXIsXG4gICAgbWF0cml4LFxuICAgIGJhY2t0cmFja01hdHJpeCxcbiAgICBzdW1zLFxuICAgIHN1bXNPZlNxdWFyZXNcbikge1xuICAgIGlmIChpTWluID4gaU1heCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYXQgbWlkcG9pbnQgYmV0d2VlbiBpTWluIGFuZCBpTWF4XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKChpTWluICsgaU1heCkgLyAyKTtcblxuICAgIG1hdHJpeFtjbHVzdGVyXVtpXSA9IG1hdHJpeFtjbHVzdGVyIC0gMV1baSAtIDFdO1xuICAgIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpXSA9IGk7XG5cbiAgICB2YXIgamxvdyA9IGNsdXN0ZXI7IC8vIHRoZSBsb3dlciBlbmQgZm9yIGpcblxuICAgIGlmIChpTWluID4gY2x1c3Rlcikge1xuICAgICAgICBqbG93ID0gTWF0aC5tYXgoamxvdywgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2lNaW4gLSAxXSB8fCAwKTtcbiAgICB9XG4gICAgamxvdyA9IE1hdGgubWF4KGpsb3csIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyIC0gMV1baV0gfHwgMCk7XG5cbiAgICB2YXIgamhpZ2ggPSBpIC0gMTsgLy8gdGhlIHVwcGVyIGVuZCBmb3IgalxuICAgIGlmIChpTWF4IDwgbWF0cml4WzBdLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGpoaWdoID0gTWF0aC5taW4oamhpZ2gsIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpTWF4ICsgMV0gfHwgMCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBlbmQgKi9cbiAgICB9XG5cbiAgICB2YXIgc2ppO1xuICAgIHZhciBzamxvd2k7XG4gICAgdmFyIHNzcWpsb3c7XG4gICAgdmFyIHNzcWo7XG4gICAgZm9yICh2YXIgaiA9IGpoaWdoOyBqID49IGpsb3c7IC0taikge1xuICAgICAgICBzamkgPSBzc3EoaiwgaSwgc3Vtcywgc3Vtc09mU3F1YXJlcyk7XG5cbiAgICAgICAgaWYgKHNqaSArIG1hdHJpeFtjbHVzdGVyIC0gMV1bamxvdyAtIDFdID49IG1hdHJpeFtjbHVzdGVyXVtpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGFtaW5lIHRoZSBsb3dlciBib3VuZCBvZiB0aGUgY2x1c3RlciBib3JkZXJcbiAgICAgICAgc2psb3dpID0gc3NxKGpsb3csIGksIHN1bXMsIHN1bXNPZlNxdWFyZXMpO1xuXG4gICAgICAgIHNzcWpsb3cgPSBzamxvd2kgKyBtYXRyaXhbY2x1c3RlciAtIDFdW2psb3cgLSAxXTtcblxuICAgICAgICBpZiAoc3NxamxvdyA8IG1hdHJpeFtjbHVzdGVyXVtpXSkge1xuICAgICAgICAgICAgLy8gU2hyaW5rIHRoZSBsb3dlciBib3VuZFxuICAgICAgICAgICAgbWF0cml4W2NsdXN0ZXJdW2ldID0gc3NxamxvdztcbiAgICAgICAgICAgIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpXSA9IGpsb3c7XG4gICAgICAgIH1cbiAgICAgICAgamxvdysrO1xuXG4gICAgICAgIHNzcWogPSBzamkgKyBtYXRyaXhbY2x1c3RlciAtIDFdW2ogLSAxXTtcbiAgICAgICAgaWYgKHNzcWogPCBtYXRyaXhbY2x1c3Rlcl1baV0pIHtcbiAgICAgICAgICAgIG1hdHJpeFtjbHVzdGVyXVtpXSA9IHNzcWo7XG4gICAgICAgICAgICBiYWNrdHJhY2tNYXRyaXhbY2x1c3Rlcl1baV0gPSBqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlsbE1hdHJpeENvbHVtbihcbiAgICAgICAgaU1pbixcbiAgICAgICAgaSAtIDEsXG4gICAgICAgIGNsdXN0ZXIsXG4gICAgICAgIG1hdHJpeCxcbiAgICAgICAgYmFja3RyYWNrTWF0cml4LFxuICAgICAgICBzdW1zLFxuICAgICAgICBzdW1zT2ZTcXVhcmVzXG4gICAgKTtcbiAgICBmaWxsTWF0cml4Q29sdW1uKFxuICAgICAgICBpICsgMSxcbiAgICAgICAgaU1heCxcbiAgICAgICAgY2x1c3RlcixcbiAgICAgICAgbWF0cml4LFxuICAgICAgICBiYWNrdHJhY2tNYXRyaXgsXG4gICAgICAgIHN1bXMsXG4gICAgICAgIHN1bXNPZlNxdWFyZXNcbiAgICApO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBtYWluIG1hdHJpY2VzIHVzZWQgaW4gQ2ttZWFucyBhbmQga2lja3NcbiAqIG9mZiB0aGUgZGl2aWRlIGFuZCBjb25xdWVyIGNsdXN0ZXIgY29tcHV0YXRpb24gc3RyYXRlZ3lcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhIHNvcnRlZCBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdHJpeFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gYmFja3RyYWNrTWF0cml4XG4gKi9cbmZ1bmN0aW9uIGZpbGxNYXRyaWNlcyhkYXRhLCBtYXRyaXgsIGJhY2t0cmFja01hdHJpeCkge1xuICAgIHZhciBuVmFsdWVzID0gbWF0cml4WzBdLmxlbmd0aDtcblxuICAgIC8vIFNoaWZ0IHZhbHVlcyBieSB0aGUgbWVkaWFuIHRvIGltcHJvdmUgbnVtZXJpYyBzdGFiaWxpdHlcbiAgICB2YXIgc2hpZnQgPSBkYXRhW01hdGguZmxvb3IoblZhbHVlcyAvIDIpXTtcblxuICAgIC8vIEN1bXVsYXRpdmUgc3VtIGFuZCBjdW11bGF0aXZlIHN1bSBvZiBzcXVhcmVzIGZvciBhbGwgdmFsdWVzIGluIGRhdGEgYXJyYXlcbiAgICB2YXIgc3VtcyA9IFtdO1xuICAgIHZhciBzdW1zT2ZTcXVhcmVzID0gW107XG5cbiAgICAvLyBJbml0aWFsaXplIGZpcnN0IGNvbHVtbiBpbiBtYXRyaXggJiBiYWNrdHJhY2tNYXRyaXhcbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnRlZFZhbHVlID0gKHZvaWQgMCk7IGkgPCBuVmFsdWVzOyArK2kpIHtcbiAgICAgICAgc2hpZnRlZFZhbHVlID0gZGF0YVtpXSAtIHNoaWZ0O1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgc3Vtcy5wdXNoKHNoaWZ0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzLnB1c2goc2hpZnRlZFZhbHVlICogc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1bXMucHVzaChzdW1zW2kgLSAxXSArIHNoaWZ0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzLnB1c2goXG4gICAgICAgICAgICAgICAgc3Vtc09mU3F1YXJlc1tpIC0gMV0gKyBzaGlmdGVkVmFsdWUgKiBzaGlmdGVkVmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIGZvciBjbHVzdGVyID0gMFxuICAgICAgICBtYXRyaXhbMF1baV0gPSBzc3EoMCwgaSwgc3Vtcywgc3Vtc09mU3F1YXJlcyk7XG4gICAgICAgIGJhY2t0cmFja01hdHJpeFswXVtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVzdCBvZiB0aGUgY29sdW1uc1xuICAgIHZhciBpTWluO1xuICAgIGZvciAodmFyIGNsdXN0ZXIgPSAxOyBjbHVzdGVyIDwgbWF0cml4Lmxlbmd0aDsgKytjbHVzdGVyKSB7XG4gICAgICAgIGlmIChjbHVzdGVyIDwgbWF0cml4Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlNaW4gPSBjbHVzdGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjb21wdXRlIG1hdHJpeFtLLTFdWzBdIC4uLiBtYXRyaXhbSy0xXVtOLTJdXG4gICAgICAgICAgICBpTWluID0gblZhbHVlcyAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBmaWxsTWF0cml4Q29sdW1uKFxuICAgICAgICAgICAgaU1pbixcbiAgICAgICAgICAgIG5WYWx1ZXMgLSAxLFxuICAgICAgICAgICAgY2x1c3RlcixcbiAgICAgICAgICAgIG1hdHJpeCxcbiAgICAgICAgICAgIGJhY2t0cmFja01hdHJpeCxcbiAgICAgICAgICAgIHN1bXMsXG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIENrbWVhbnMgY2x1c3RlcmluZyBpcyBhbiBpbXByb3ZlbWVudCBvbiBoZXVyaXN0aWMtYmFzZWQgY2x1c3RlcmluZ1xuICogYXBwcm9hY2hlcyBsaWtlIEplbmtzLiBUaGUgYWxnb3JpdGhtIHdhcyBkZXZlbG9wZWQgaW5cbiAqIFtIYWl6aG91IFdhbmcgYW5kIE1pbmd6aG91IFNvbmddKGh0dHA6Ly9qb3VybmFsLnItcHJvamVjdC5vcmcvYXJjaGl2ZS8yMDExLTIvUkpvdXJuYWxfMjAxMS0yX1dhbmcrU29uZy5wZGYpXG4gKiBhcyBhIFtkeW5hbWljIHByb2dyYW1taW5nXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EeW5hbWljX3Byb2dyYW1taW5nKSBhcHByb2FjaFxuICogdG8gdGhlIHByb2JsZW0gb2YgY2x1c3RlcmluZyBudW1lcmljIGRhdGEgaW50byBncm91cHMgd2l0aCB0aGUgbGVhc3RcbiAqIHdpdGhpbi1ncm91cCBzdW0tb2Ytc3F1YXJlZC1kZXZpYXRpb25zLlxuICpcbiAqIE1pbmltaXppbmcgdGhlIGRpZmZlcmVuY2Ugd2l0aGluIGdyb3VwcyAtIHdoYXQgV2FuZyAmIFNvbmcgcmVmZXIgdG8gYXNcbiAqIGB3aXRoaW5zc2AsIG9yIHdpdGhpbiBzdW0tb2Ytc3F1YXJlcywgbWVhbnMgdGhhdCBncm91cHMgYXJlIG9wdGltYWxseVxuICogaG9tb2dlbm91cyB3aXRoaW4gYW5kIHRoZSBkYXRhIGlzIHNwbGl0IGludG8gcmVwcmVzZW50YXRpdmUgZ3JvdXBzLlxuICogVGhpcyBpcyB2ZXJ5IHVzZWZ1bCBmb3IgdmlzdWFsaXphdGlvbiwgd2hlcmUgeW91IG1heSB3YW50IHRvIHJlcHJlc2VudFxuICogYSBjb250aW51b3VzIHZhcmlhYmxlIGluIGRpc2NyZXRlIGNvbG9yIG9yIHN0eWxlIGdyb3Vwcy4gVGhpcyBmdW5jdGlvblxuICogY2FuIHByb3ZpZGUgZ3JvdXBzIHRoYXQgZW1waGFzaXplIGRpZmZlcmVuY2VzIGJldHdlZW4gZGF0YS5cbiAqXG4gKiBCZWluZyBhIGR5bmFtaWMgYXBwcm9hY2gsIHRoaXMgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIHR3byBtYXRyaWNlcyB0aGF0XG4gKiBzdG9yZSBpbmNyZW1lbnRhbGx5LWNvbXB1dGVkIHZhbHVlcyBmb3Igc3F1YXJlZCBkZXZpYXRpb25zIGFuZCBiYWNrdHJhY2tpbmdcbiAqIGluZGV4ZXMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiBDa21lYW5zIDMuNC42LCB3aGljaCBpbnRyb2R1Y2VkIGEgbmV3IGRpdmlkZVxuICogYW5kIGNvbnF1ZXIgYXBwcm9hY2ggdGhhdCBpbXByb3ZlZCBydW50aW1lIGZyb20gTyhrbl4yKSB0byBPKGtuIGxvZyhuKSkuXG4gKlxuICogVW5saWtlIHRoZSBbb3JpZ2luYWwgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vY3Jhbi5yLXByb2plY3Qub3JnL3dlYi9wYWNrYWdlcy9Da21lYW5zLjFkLmRwL2luZGV4Lmh0bWwpLFxuICogdGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBpbmNsdWRlIGFueSBjb2RlIHRvIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lXG4gKiB0aGUgb3B0aW1hbCBudW1iZXIgb2YgY2x1c3RlcnM6IHRoaXMgaW5mb3JtYXRpb24gbmVlZHMgdG8gYmUgZXhwbGljaXRseVxuICogcHJvdmlkZWQuXG4gKlxuICogIyMjIFJlZmVyZW5jZXNcbiAqIF9Da21lYW5zLjFkLmRwOiBPcHRpbWFsIGstbWVhbnMgQ2x1c3RlcmluZyBpbiBPbmUgRGltZW5zaW9uIGJ5IER5bmFtaWNcbiAqIFByb2dyYW1taW5nXyBIYWl6aG91IFdhbmcgYW5kIE1pbmd6aG91IFNvbmcgSVNTTiAyMDczLTQ4NTlcbiAqXG4gKiBmcm9tIFRoZSBSIEpvdXJuYWwgVm9sLiAzLzIsIERlY2VtYmVyIDIwMTFcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dCBkYXRhLCBhcyBhbiBhcnJheSBvZiBudW1iZXIgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbkNsdXN0ZXJzIG51bWJlciBvZiBkZXNpcmVkIGNsYXNzZXMuIFRoaXMgY2Fubm90IGJlXG4gKiBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiB2YWx1ZXMgaW4gdGhlIGRhdGEgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNsdXN0ZXJlZCBpbnB1dFxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBudW1iZXIgb2YgcmVxdWVzdGVkIGNsdXN0ZXJzIGlzIGhpZ2hlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogY2ttZWFucyhbLTEsIDIsIC0xLCAyLCA0LCA1LCA2LCAtMSwgMiwgLTFdLCAzKTtcbiAqIC8vIFRoZSBpbnB1dCwgY2x1c3RlcmVkIGludG8gZ3JvdXBzIG9mIHNpbWlsYXIgbnVtYmVycy5cbiAqIC8vPSBbWy0xLCAtMSwgLTEsIC0xXSwgWzIsIDIsIDJdLCBbNCwgNSwgNl1dKTtcbiAqL1xuZnVuY3Rpb24gY2ttZWFucyh4LCBuQ2x1c3RlcnMpIHtcbiAgICBpZiAobkNsdXN0ZXJzID4geC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJjYW5ub3QgZ2VuZXJhdGUgbW9yZSBjbGFzc2VzIHRoYW4gdGhlcmUgYXJlIGRhdGEgdmFsdWVzXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc29ydGVkID0gbnVtZXJpY1NvcnQoeCk7XG4gICAgLy8gd2UnbGwgdXNlIHRoaXMgYXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNsdXN0ZXJzXG4gICAgdmFyIHVuaXF1ZUNvdW50ID0gdW5pcXVlQ291bnRTb3J0ZWQoc29ydGVkKTtcblxuICAgIC8vIGlmIGFsbCBvZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBpZGVudGljYWwsIHRoZXJlJ3Mgb25lIGNsdXN0ZXJcbiAgICAvLyB3aXRoIGFsbCBvZiB0aGUgaW5wdXQgaW4gaXQuXG4gICAgaWYgKHVuaXF1ZUNvdW50ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbc29ydGVkXTtcbiAgICB9XG5cbiAgICAvLyBuYW1lZCAnUycgb3JpZ2luYWxseVxuICAgIHZhciBtYXRyaXggPSBtYWtlTWF0cml4KG5DbHVzdGVycywgc29ydGVkLmxlbmd0aCk7XG4gICAgLy8gbmFtZWQgJ0onIG9yaWdpbmFsbHlcbiAgICB2YXIgYmFja3RyYWNrTWF0cml4ID0gbWFrZU1hdHJpeChuQ2x1c3RlcnMsIHNvcnRlZC5sZW5ndGgpO1xuXG4gICAgLy8gVGhpcyBpcyBhIGR5bmFtaWMgcHJvZ3JhbW1pbmcgd2F5IHRvIHNvbHZlIHRoZSBwcm9ibGVtIG9mIG1pbmltaXppbmdcbiAgICAvLyB3aXRoaW4tY2x1c3RlciBzdW0gb2Ygc3F1YXJlcy4gSXQncyBzaW1pbGFyIHRvIGxpbmVhciByZWdyZXNzaW9uXG4gICAgLy8gaW4gdGhpcyB3YXksIGFuZCB0aGlzIGNhbGN1bGF0aW9uIGluY3JlbWVudGFsbHkgY29tcHV0ZXMgdGhlXG4gICAgLy8gc3VtIG9mIHNxdWFyZXMgdGhhdCBhcmUgbGF0ZXIgcmVhZC5cbiAgICBmaWxsTWF0cmljZXMoc29ydGVkLCBtYXRyaXgsIGJhY2t0cmFja01hdHJpeCk7XG5cbiAgICAvLyBUaGUgcmVhbCB3b3JrIG9mIENrbWVhbnMgY2x1c3RlcmluZyBoYXBwZW5zIGluIHRoZSBtYXRyaXggZ2VuZXJhdGlvbjpcbiAgICAvLyB0aGUgZ2VuZXJhdGVkIG1hdHJpY2VzIGVuY29kZSBhbGwgcG9zc2libGUgY2x1c3RlcmluZyBjb21iaW5hdGlvbnMsIGFuZFxuICAgIC8vIG9uY2UgdGhleSdyZSBnZW5lcmF0ZWQgd2UgY2FuIHNvbHZlIGZvciB0aGUgYmVzdCBjbHVzdGVyaW5nIGdyb3Vwc1xuICAgIC8vIHZlcnkgcXVpY2tseS5cbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICB2YXIgY2x1c3RlclJpZ2h0ID0gYmFja3RyYWNrTWF0cml4WzBdLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBCYWNrdHJhY2sgdGhlIGNsdXN0ZXJzIGZyb20gdGhlIGR5bmFtaWMgcHJvZ3JhbW1pbmcgbWF0cml4LiBUaGlzXG4gICAgLy8gc3RhcnRzIGF0IHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIHRoZSBtYXRyaXggKGlmIHRoZSB0b3AtbGVmdCBpcyAwLCAwKSxcbiAgICAvLyBhbmQgbW92ZXMgdGhlIGNsdXN0ZXIgdGFyZ2V0IHdpdGggdGhlIGxvb3AuXG4gICAgZm9yICh2YXIgY2x1c3RlciA9IGJhY2t0cmFja01hdHJpeC5sZW5ndGggLSAxOyBjbHVzdGVyID49IDA7IGNsdXN0ZXItLSkge1xuICAgICAgICB2YXIgY2x1c3RlckxlZnQgPSBiYWNrdHJhY2tNYXRyaXhbY2x1c3Rlcl1bY2x1c3RlclJpZ2h0XTtcblxuICAgICAgICAvLyBmaWxsIHRoZSBjbHVzdGVyIGZyb20gdGhlIHNvcnRlZCBpbnB1dCBieSB0YWtpbmcgYSBzbGljZSBvZiB0aGVcbiAgICAgICAgLy8gYXJyYXkuIHRoZSBiYWNrdHJhY2sgbWF0cml4IG1ha2VzIHRoaXMgZWFzeSAtIGl0IHN0b3JlcyB0aGVcbiAgICAgICAgLy8gaW5kZXhlcyB3aGVyZSB0aGUgY2x1c3RlciBzaG91bGQgc3RhcnQgYW5kIGVuZC5cbiAgICAgICAgY2x1c3RlcnNbY2x1c3Rlcl0gPSBzb3J0ZWQuc2xpY2UoY2x1c3RlckxlZnQsIGNsdXN0ZXJSaWdodCArIDEpO1xuXG4gICAgICAgIGlmIChjbHVzdGVyID4gMCkge1xuICAgICAgICAgICAgY2x1c3RlclJpZ2h0ID0gY2x1c3RlckxlZnQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG4vKlxuICogUHVsbCBCcmVha3MgVmFsdWVzIGZvciBKZW5rc1xuICpcbiAqIHRoZSBzZWNvbmQgcGFydCBvZiB0aGUgamVua3MgcmVjaXBlOiB0YWtlIHRoZSBjYWxjdWxhdGVkIG1hdHJpY2VzXG4gKiBhbmQgZGVyaXZlIGFuIGFycmF5IG9mIG4gYnJlYWtzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGplbmtzQnJlYWtzKGRhdGEsIGxvd2VyQ2xhc3NMaW1pdHMsIG5DbGFzc2VzKSB7XG4gICAgdmFyIGsgPSBkYXRhLmxlbmd0aDtcbiAgICB2YXIga2NsYXNzID0gW107XG4gICAgdmFyIGNvdW50TnVtID0gbkNsYXNzZXM7XG5cbiAgICAvLyB0aGUgY2FsY3VsYXRpb24gb2YgY2xhc3NlcyB3aWxsIG5ldmVyIGluY2x1ZGUgdGhlIHVwcGVyXG4gICAgLy8gYm91bmQsIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSBzZXQgaXRcbiAgICBrY2xhc3NbbkNsYXNzZXNdID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gdGhlIGxvd2VyQ2xhc3NMaW1pdHMgbWF0cml4IGlzIHVzZWQgYXMgaW5kaWNlcyBpbnRvIGl0c2VsZlxuICAgIC8vIGhlcmU6IHRoZSBga2AgdmFyaWFibGUgaXMgcmV1c2VkIGluIGVhY2ggaXRlcmF0aW9uLlxuICAgIHdoaWxlIChjb3VudE51bSA+IDApIHtcbiAgICAgICAga2NsYXNzW2NvdW50TnVtIC0gMV0gPSBkYXRhW2xvd2VyQ2xhc3NMaW1pdHNba11bY291bnROdW1dIC0gMV07XG4gICAgICAgIGsgPSBsb3dlckNsYXNzTGltaXRzW2tdW2NvdW50TnVtXSAtIDE7XG4gICAgICAgIGNvdW50TnVtLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGtjbGFzcztcbn1cblxuLypcbiAqIENvbXB1dGUgTWF0cmljZXMgZm9yIEplbmtzXG4gKlxuICogQ29tcHV0ZSB0aGUgbWF0cmljZXMgcmVxdWlyZWQgZm9yIEplbmtzIGJyZWFrcy4gVGhlc2UgbWF0cmljZXNcbiAqIGNhbiBiZSB1c2VkIGZvciBhbnkgY2xhc3Npbmcgb2YgZGF0YSB3aXRoIGBjbGFzc2VzIDw9IG5DbGFzc2VzYFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGplbmtzTWF0cmljZXMoZGF0YSwgbkNsYXNzZXMpIHtcbiAgICAvLyBpbiB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24sIHRoZXNlIG1hdHJpY2VzIGFyZSByZWZlcnJlZCB0b1xuICAgIC8vIGFzIGBMQ2AgYW5kIGBPUGBcbiAgICAvL1xuICAgIC8vICogbG93ZXJDbGFzc0xpbWl0cyAoTEMpOiBvcHRpbWFsIGxvd2VyIGNsYXNzIGxpbWl0c1xuICAgIC8vICogdmFyaWFuY2VDb21iaW5hdGlvbnMgKE9QKTogb3B0aW1hbCB2YXJpYW5jZSBjb21iaW5hdGlvbnMgZm9yIGFsbCBjbGFzc2VzXG4gICAgdmFyIGxvd2VyQ2xhc3NMaW1pdHMgPSBbXTtcbiAgICB2YXIgdmFyaWFuY2VDb21iaW5hdGlvbnMgPSBbXTtcbiAgICAvLyBsb29wIGNvdW50ZXJzXG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG4gICAgLy8gdGhlIHZhcmlhbmNlLCBhcyBjb21wdXRlZCBhdCBlYWNoIHN0ZXAgaW4gdGhlIGNhbGN1bGF0aW9uXG4gICAgdmFyIHZhcmlhbmNlID0gMDtcblxuICAgIC8vIEluaXRpYWxpemUgYW5kIGZpbGwgZWFjaCBtYXRyaXggd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgICAgdmFyIHRtcDEgPSBbXTtcbiAgICAgICAgdmFyIHRtcDIgPSBbXTtcbiAgICAgICAgLy8gZGVzcGl0ZSB0aGVzZSBhcnJheXMgaGF2aW5nIHRoZSBzYW1lIHZhbHVlcywgd2UgbmVlZFxuICAgICAgICAvLyB0byBrZWVwIHRoZW0gc2VwYXJhdGUgc28gdGhhdCBjaGFuZ2luZyBvbmUgZG9lcyBub3QgY2hhbmdlXG4gICAgICAgIC8vIHRoZSBvdGhlclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbkNsYXNzZXMgKyAxOyBqKyspIHtcbiAgICAgICAgICAgIHRtcDEucHVzaCgwKTtcbiAgICAgICAgICAgIHRtcDIucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBsb3dlckNsYXNzTGltaXRzLnB1c2godG1wMSk7XG4gICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zLnB1c2godG1wMik7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMTsgaSA8IG5DbGFzc2VzICsgMTsgaSsrKSB7XG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHNbMV1baV0gPSAxO1xuICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1sxXVtpXSA9IDA7XG4gICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiwgOTk5OTk5OSBpcyB1c2VkIGJ1dFxuICAgICAgICAvLyBzaW5jZSBKYXZhc2NyaXB0IGhhcyBgSW5maW5pdHlgLCB3ZSB1c2UgdGhhdC5cbiAgICAgICAgZm9yIChqID0gMjsgaiA8IGRhdGEubGVuZ3RoICsgMTsgaisrKSB7XG4gICAgICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1tqXVtpXSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGwgPSAyOyBsIDwgZGF0YS5sZW5ndGggKyAxOyBsKyspIHtcbiAgICAgICAgLy8gYFNaYCBvcmlnaW5hbGx5LiB0aGlzIGlzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBzZWVuIHRodXNcbiAgICAgICAgLy8gZmFyIHdoZW4gY2FsY3VsYXRpbmcgdmFyaWFuY2UuXG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAvLyBgWlNRYCBvcmlnaW5hbGx5LiB0aGUgc3VtIG9mIHNxdWFyZXMgb2YgdmFsdWVzIHNlZW5cbiAgICAgICAgLy8gdGh1cyBmYXJcbiAgICAgICAgdmFyIHN1bVNxdWFyZXMgPSAwO1xuICAgICAgICAvLyBgV1RgIG9yaWdpbmFsbHkuIFRoaXMgaXMgdGhlIG51bWJlciBvZlxuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIC8vIGBJVmAgb3JpZ2luYWxseVxuICAgICAgICB2YXIgaTQgPSAwO1xuXG4gICAgICAgIC8vIGluIHNldmVyYWwgaW5zdGFuY2VzLCB5b3UgY291bGQgc2F5IGBNYXRoLnBvdyh4LCAyKWBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBgeCAqIHhgLCBidXQgdGhpcyBpcyBzbG93ZXIgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICAvLyBpbnRyb2R1Y2VzIGFuIHVubmVjZXNzYXJ5IGNvbmNlcHQuXG4gICAgICAgIGZvciAodmFyIG0gPSAxOyBtIDwgbCArIDE7IG0rKykge1xuICAgICAgICAgICAgLy8gYElJSWAgb3JpZ2luYWxseVxuICAgICAgICAgICAgdmFyIGxvd2VyQ2xhc3NMaW1pdCA9IGwgLSBtICsgMTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhW2xvd2VyQ2xhc3NMaW1pdCAtIDFdO1xuXG4gICAgICAgICAgICAvLyBoZXJlIHdlJ3JlIGVzdGltYXRpbmcgdmFyaWFuY2UgZm9yIGVhY2ggcG90ZW50aWFsIGNsYXNzaW5nXG4gICAgICAgICAgICAvLyBvZiB0aGUgZGF0YSwgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZiBjbGFzc2VzLiBgd2BcbiAgICAgICAgICAgIC8vIGlzIHRoZSBudW1iZXIgb2YgZGF0YSBwb2ludHMgY29uc2lkZXJlZCBzbyBmYXIuXG4gICAgICAgICAgICB3Kys7XG5cbiAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBjdXJyZW50IHN1bSBhbmQgc3VtLW9mLXNxdWFyZXNcbiAgICAgICAgICAgIHN1bSArPSB2YWw7XG4gICAgICAgICAgICBzdW1TcXVhcmVzICs9IHZhbCAqIHZhbDtcblxuICAgICAgICAgICAgLy8gdGhlIHZhcmlhbmNlIGF0IHRoaXMgcG9pbnQgaW4gdGhlIHNlcXVlbmNlIGlzIHRoZSBkaWZmZXJlbmNlXG4gICAgICAgICAgICAvLyBiZXR3ZWVuIHRoZSBzdW0gb2Ygc3F1YXJlcyBhbmQgdGhlIHRvdGFsIHggMiwgb3ZlciB0aGUgbnVtYmVyXG4gICAgICAgICAgICAvLyBvZiBzYW1wbGVzLlxuICAgICAgICAgICAgdmFyaWFuY2UgPSBzdW1TcXVhcmVzIC0gKHN1bSAqIHN1bSkgLyB3O1xuXG4gICAgICAgICAgICBpNCA9IGxvd2VyQ2xhc3NMaW1pdCAtIDE7XG5cbiAgICAgICAgICAgIGlmIChpNCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDI7IGogPCBuQ2xhc3NlcyArIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhZGRpbmcgdGhpcyBlbGVtZW50IHRvIGFuIGV4aXN0aW5nIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgaW5jcmVhc2UgaXRzIHZhcmlhbmNlIGJleW9uZCB0aGUgbGltaXQsIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjbGFzcyBhdCB0aGlzIHBvaW50LCBzZXR0aW5nIHRoZSBgbG93ZXJDbGFzc0xpbWl0YFxuICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1tsXVtqXSA+PVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFuY2UgKyB2YXJpYW5jZUNvbWJpbmF0aW9uc1tpNF1baiAtIDFdXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJDbGFzc0xpbWl0c1tsXVtqXSA9IGxvd2VyQ2xhc3NMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zW2xdW2pdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW5jZSArIHZhcmlhbmNlQ29tYmluYXRpb25zW2k0XVtqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb3dlckNsYXNzTGltaXRzW2xdWzFdID0gMTtcbiAgICAgICAgdmFyaWFuY2VDb21iaW5hdGlvbnNbbF1bMV0gPSB2YXJpYW5jZTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdGhlIHR3byBtYXRyaWNlcy4gZm9yIGp1c3QgcHJvdmlkaW5nIGJyZWFrcywgb25seVxuICAgIC8vIGBsb3dlckNsYXNzTGltaXRzYCBpcyBuZWVkZWQsIGJ1dCB2YXJpYW5jZXMgY2FuIGJlIHVzZWZ1bCB0b1xuICAgIC8vIGV2YWx1YXRlIGdvb2RuZXNzIG9mIGZpdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBsb3dlckNsYXNzTGltaXRzOiBsb3dlckNsYXNzTGltaXRzLFxuICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uczogdmFyaWFuY2VDb21iaW5hdGlvbnNcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSAqKltqZW5rcyBuYXR1cmFsIGJyZWFrcyBvcHRpbWl6YXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVua3NfbmF0dXJhbF9icmVha3Nfb3B0aW1pemF0aW9uKSoqXG4gKiBpcyBhbiBhbGdvcml0aG0gY29tbW9ubHkgdXNlZCBpbiBjYXJ0b2dyYXBoeSBhbmQgdmlzdWFsaXphdGlvbiB0byBkZWNpZGVcbiAqIHVwb24gZ3JvdXBpbmdzIG9mIGRhdGEgdmFsdWVzIHRoYXQgbWluaW1pemUgdmFyaWFuY2Ugd2l0aGluIHRoZW1zZWx2ZXNcbiAqIGFuZCBtYXhpbWl6ZSB2YXJpYXRpb24gYmV0d2VlbiB0aGVtc2VsdmVzLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgY2FydG9ncmFwaGVycyBvZnRlbiB1c2UgamVua3MgaW4gb3JkZXIgdG8gY2hvb3NlIHdoaWNoXG4gKiB2YWx1ZXMgYXJlIGFzc2lnbmVkIHRvIHdoaWNoIGNvbG9ycyBpbiBhIFtjaG9yb3BsZXRoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaG9yb3BsZXRoX21hcClcbiAqIG1hcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhdGEgaW5wdXQgZGF0YSwgYXMgYW4gYXJyYXkgb2YgbnVtYmVyIHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5DbGFzc2VzIG51bWJlciBvZiBkZXNpcmVkIGNsYXNzZXNcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBhcnJheSBvZiBjbGFzcyBicmVhayBwb3NpdGlvbnNcbiAqIC8vIHNwbGl0IGRhdGEgaW50byAzIGJyZWFrIHBvaW50c1xuICogamVua3MoWzEsIDIsIDQsIDUsIDcsIDksIDEwLCAyMF0sIDMpIC8vID0gWzEsIDcsIDIwLCAyMF1cbiAqL1xuZnVuY3Rpb24gamVua3MoZGF0YSwgbkNsYXNzZXMpIHtcbiAgICBpZiAobkNsYXNzZXMgPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzb3J0IGRhdGEgaW4gbnVtZXJpY2FsIG9yZGVyLCBzaW5jZSB0aGlzIGlzIGV4cGVjdGVkXG4gICAgLy8gYnkgdGhlIG1hdHJpY2VzIGZ1bmN0aW9uXG4gICAgZGF0YSA9IGRhdGEuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcblxuICAgIC8vIGdldCBvdXIgYmFzaWMgbWF0cmljZXNcbiAgICB2YXIgbWF0cmljZXMgPSBqZW5rc01hdHJpY2VzKGRhdGEsIG5DbGFzc2VzKTtcbiAgICAvLyB3ZSBvbmx5IG5lZWQgbG93ZXIgY2xhc3MgbGltaXRzIGhlcmVcbiAgICB2YXIgbG93ZXJDbGFzc0xpbWl0cyA9IG1hdHJpY2VzLmxvd2VyQ2xhc3NMaW1pdHM7XG5cbiAgICAvLyBleHRyYWN0IG5DbGFzc2VzIG91dCBvZiB0aGUgY29tcHV0ZWQgbWF0cmljZXNcbiAgICByZXR1cm4gamVua3NCcmVha3MoZGF0YSwgbG93ZXJDbGFzc0xpbWl0cywgbkNsYXNzZXMpO1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHgsIHRoaXMgd2lsbCBmaW5kIHRoZSBleHRlbnQgb2YgdGhlXG4gKiB4IGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgYnJlYWtzIHRoYXQgY2FuIGJlIHVzZWRcbiAqIHRvIGNhdGVnb3JpemUgdGhlIHggaW50byBhIG51bWJlciBvZiBjbGFzc2VzLiBUaGVcbiAqIHJldHVybmVkIGFycmF5IHdpbGwgYWx3YXlzIGJlIDEgbG9uZ2VyIHRoYW4gdGhlIG51bWJlciBvZlxuICogY2xhc3NlcyBiZWNhdXNlIGl0IGluY2x1ZGVzIHRoZSBtaW5pbXVtIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhbiBhcnJheSBvZiBudW1iZXIgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbkNsYXNzZXMgbnVtYmVyIG9mIGRlc2lyZWQgY2xhc3Nlc1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGFycmF5IG9mIGNsYXNzIGJyZWFrIHBvc2l0aW9uc1xuICogQGV4YW1wbGVcbiAqIGVxdWFsSW50ZXJ2YWxCcmVha3MoWzEsIDIsIDMsIDQsIDUsIDZdLCA0KTsgLy8gPT4gWzEsIDIuMjUsIDMuNSwgNC43NSwgNl1cbiAqL1xuZnVuY3Rpb24gZXF1YWxJbnRlcnZhbEJyZWFrcyh4LCBuQ2xhc3Nlcykge1xuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgdmFyIHRoZU1pbiA9IG1pbih4KTtcbiAgICB2YXIgdGhlTWF4ID0gbWF4KHgpO1xuXG4gICAgLy8gdGhlIGZpcnN0IGJyZWFrIHdpbGwgYWx3YXlzIGJlIHRoZSBtaW5pbXVtIHZhbHVlXG4gICAgLy8gaW4gdGhlIHhzZXRcbiAgICB2YXIgYnJlYWtzID0gW3RoZU1pbl07XG5cbiAgICAvLyBUaGUgc2l6ZSBvZiBlYWNoIGJyZWFrIGlzIHRoZSBmdWxsIHJhbmdlIG9mIHRoZSB4XG4gICAgLy8gZGl2aWRlZCBieSB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgcmVxdWVzdGVkXG4gICAgdmFyIGJyZWFrU2l6ZSA9ICh0aGVNYXggLSB0aGVNaW4pIC8gbkNsYXNzZXM7XG5cbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBuQ2xhc3NlcyA9IDEsIHRoaXMgbG9vcCB3b24ndCBydW5cbiAgICAvLyBhbmQgdGhlIHJldHVybmVkIGJyZWFrcyB3aWxsIGJlIFttaW4sIG1heF1cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5DbGFzc2VzOyBpKyspIHtcbiAgICAgICAgYnJlYWtzLnB1c2goYnJlYWtzWzBdICsgYnJlYWtTaXplICogaSk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGxhc3QgYnJlYWsgd2lsbCBhbHdheXMgYmUgdGhlXG4gICAgLy8gbWF4aW11bS5cbiAgICBicmVha3MucHVzaCh0aGVNYXgpO1xuXG4gICAgcmV0dXJuIGJyZWFrcztcbn1cblxuLyoqXG4gKiBbU2FtcGxlIGNvdmFyaWFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NhbXBsZV9tZWFuX2FuZF9jb3ZhcmlhbmNlKSBvZiB0d28gZGF0YXNldHM6XG4gKiBob3cgbXVjaCBkbyB0aGUgdHdvIGRhdGFzZXRzIG1vdmUgdG9nZXRoZXI/XG4gKiB4IGFuZCB5IGFyZSB0d28gZGF0YXNldHMsIHJlcHJlc2VudGVkIGFzIGFycmF5cyBvZiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiB0d28gb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5IGEgc2FtcGxlIG9mIHR3byBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBhbmQgeSBkbyBub3QgaGF2ZSBlcXVhbCBsZW5ndGhzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBvciB5IGhhdmUgbGVuZ3RoIG9mIG9uZSBvciBsZXNzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzYW1wbGUgY292YXJpYW5jZVxuICogQGV4YW1wbGVcbiAqIHNhbXBsZUNvdmFyaWFuY2UoWzEsIDIsIDMsIDQsIDUsIDZdLCBbNiwgNSwgNCwgMywgMiwgMV0pOyAvLyA9PiAtMy41XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZUNvdmFyaWFuY2UoeCwgeSkge1xuICAgIC8vIFRoZSB0d28gZGF0YXNldHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCB3aGljaCBtdXN0IGJlIG1vcmUgdGhhbiAxXG4gICAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIHNhbXBsZXMgd2l0aCBlcXVhbCBsZW5ndGhzXCIpO1xuICAgIH1cblxuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBkYXRhIHBvaW50cyBpbiBlYWNoIHNhbXBsZVwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBtZWFuIG9mIGVhY2ggZGF0YXNldCBzbyB0aGF0IHdlIGNhbiBqdWRnZSBlYWNoXG4gICAgLy8gdmFsdWUgb2YgdGhlIGRhdGFzZXQgZmFpcmx5IGFzIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIG1lYW4uIHRoaXNcbiAgICAvLyB3YXksIGlmIG9uZSBkYXRhc2V0IGlzIFsxLCAyLCAzXSBhbmQgWzIsIDMsIDRdLCB0aGVpciBjb3ZhcmlhbmNlXG4gICAgLy8gZG9lcyBub3Qgc3VmZmVyIGJlY2F1c2Ugb2YgdGhlIGRpZmZlcmVuY2UgaW4gYWJzb2x1dGUgdmFsdWVzXG4gICAgdmFyIHhtZWFuID0gbWVhbih4KTtcbiAgICB2YXIgeW1lYW4gPSBtZWFuKHkpO1xuICAgIHZhciBzdW0gPSAwO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBvZiB2YWx1ZXMsIHRoZSBjb3ZhcmlhbmNlIGluY3JlYXNlcyB3aGVuIHRoZWlyXG4gICAgLy8gZGlmZmVyZW5jZSBmcm9tIHRoZSBtZWFuIGlzIGFzc29jaWF0ZWQgLSBpZiBib3RoIGFyZSB3ZWxsIGFib3ZlXG4gICAgLy8gb3IgaWYgYm90aCBhcmUgd2VsbCBiZWxvd1xuICAgIC8vIHRoZSBtZWFuLCB0aGUgY292YXJpYW5jZSBpbmNyZWFzZXMgc2lnbmlmaWNhbnRseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9ICh4W2ldIC0geG1lYW4pICogKHlbaV0gLSB5bWVhbik7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIHRoZSBjb3ZhcmlhbmNlIGlzIHdlaWdodGVkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGRhdGFzZXRzLlxuICAgIHJldHVybiBzdW0gLyBiZXNzZWxzQ29ycmVjdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgW3NhbXBsZSB2YXJpYW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFyaWFuY2UjU2FtcGxlX3ZhcmlhbmNlKVxuICogaXMgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbi4gVGhlIHNhbXBsZSB2YXJpYW5jZVxuICogaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHRoZSB2YXJpYW5jZSBieSB0aGUgdXNhZ2Ugb2YgW0Jlc3NlbCdzIENvcnJlY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jlc3NlbCdzX2NvcnJlY3Rpb24pOlxuICogaW5zdGVhZCBvZiBkaXZpZGluZyB0aGUgc3VtIG9mIHNxdWFyZWQgZGV2aWF0aW9ucyBieSB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCxcbiAqIGl0IGlzIGRpdmlkZWQgYnkgdGhlIGxlbmd0aCBtaW51cyBvbmUuIFRoaXMgY29ycmVjdHMgdGhlIGJpYXMgaW4gZXN0aW1hdGluZ1xuICogYSB2YWx1ZSBmcm9tIGEgc2V0IHRoYXQgeW91IGRvbid0IGtub3cgaWYgZnVsbC5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICogKiBbV29sZnJhbSBNYXRoV29ybGQgb24gU2FtcGxlIFZhcmlhbmNlXShodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL1NhbXBsZVZhcmlhbmNlLmh0bWwpXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIHR3byBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHNhbXBsZSB2YXJpYW5jZVxuICogQGV4YW1wbGVcbiAqIHNhbXBsZVZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1XSk7IC8vID0+IDIuNVxuICovXG5mdW5jdGlvbiBzYW1wbGVWYXJpYW5jZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVWYXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gZGF0YSBwb2ludHNcIik7XG4gICAgfVxuXG4gICAgdmFyIHN1bVNxdWFyZWREZXZpYXRpb25zVmFsdWUgPSBzdW1OdGhQb3dlckRldmlhdGlvbnMoeCwgMik7XG5cbiAgICAvLyB0aGlzIGlzIEJlc3NlbHMnIENvcnJlY3Rpb246IGFuIGFkanVzdG1lbnQgbWFkZSB0byBzYW1wbGUgc3RhdGlzdGljc1xuICAgIC8vIHRoYXQgYWxsb3dzIGZvciB0aGUgcmVkdWNlZCBkZWdyZWUgb2YgZnJlZWRvbSBlbnRhaWxlZCBpbiBjYWxjdWxhdGluZ1xuICAgIC8vIHZhbHVlcyBmcm9tIHNhbXBsZXMgcmF0aGVyIHRoYW4gY29tcGxldGUgcG9wdWxhdGlvbnMuXG4gICAgdmFyIGJlc3NlbHNDb3JyZWN0aW9uID0geC5sZW5ndGggLSAxO1xuXG4gICAgLy8gRmluZCB0aGUgbWVhbiB2YWx1ZSBvZiB0aGF0IGxpc3RcbiAgICByZXR1cm4gc3VtU3F1YXJlZERldmlhdGlvbnNWYWx1ZSAvIGJlc3NlbHNDb3JyZWN0aW9uO1xufVxuXG4vKipcbiAqIFRoZSBbc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9kZXZpYXRpb24jU2FtcGxlX3N0YW5kYXJkX2RldmlhdGlvbilcbiAqIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc2FtcGxlIHZhcmlhbmNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dCBhcnJheVxuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvblxuICogQGV4YW1wbGVcbiAqIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKFsyLCA0LCA0LCA0LCA1LCA1LCA3LCA5XSkudG9GaXhlZCgyKTtcbiAqIC8vID0+ICcyLjE0J1xuICovXG5mdW5jdGlvbiBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih4KSB7XG4gICAgdmFyIHNhbXBsZVZhcmlhbmNlWCA9IHNhbXBsZVZhcmlhbmNlKHgpO1xuICAgIHJldHVybiBNYXRoLnNxcnQoc2FtcGxlVmFyaWFuY2VYKTtcbn1cblxuLyoqXG4gKiBUaGUgW2NvcnJlbGF0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvcnJlbGF0aW9uX2FuZF9kZXBlbmRlbmNlKSBpc1xuICogYSBtZWFzdXJlIG9mIGhvdyBjb3JyZWxhdGVkIHR3byBkYXRhc2V0cyBhcmUsIGJldHdlZW4gLTEgYW5kIDFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggZmlyc3QgaW5wdXRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geSBzZWNvbmQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBjb3JyZWxhdGlvblxuICogQGV4YW1wbGVcbiAqIHNhbXBsZUNvcnJlbGF0aW9uKFsxLCAyLCAzLCA0LCA1LCA2XSwgWzIsIDIsIDMsIDQsIDUsIDYwXSkudG9GaXhlZCgyKTtcbiAqIC8vID0+ICcwLjY5J1xuICovXG5mdW5jdGlvbiBzYW1wbGVDb3JyZWxhdGlvbih4LCB5KSB7XG4gICAgdmFyIGNvdiA9IHNhbXBsZUNvdmFyaWFuY2UoeCwgeSk7XG4gICAgdmFyIHhzdGQgPSBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih4KTtcbiAgICB2YXIgeXN0ZCA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHkpO1xuXG4gICAgcmV0dXJuIGNvdiAvIHhzdGQgLyB5c3RkO1xufVxuXG4vKipcbiAqIFRoZSBbcmFuayBjb3JyZWxhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFua19jb3JyZWxhdGlvbikgaXNcbiAqIGEgbWVhc3VyZSBvZiB0aGUgc3RyZW5ndGggb2YgbW9ub3RvbmljIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHR3byBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggZmlyc3QgaW5wdXRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geSBzZWNvbmQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSByYW5rIGNvcnJlbGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVJhbmtDb3JyZWxhdGlvbih4LCB5KSB7XG4gICAgdmFyIHhJbmRleGVzID0geFxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuIFt2YWx1ZSwgaW5kZXhdOyB9KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhaXIpIHsgcmV0dXJuIHBhaXJbMV07IH0pO1xuICAgIHZhciB5SW5kZXhlcyA9IHlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7IHJldHVybiBbdmFsdWUsIGluZGV4XTsgfSlcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwYWlyKSB7IHJldHVybiBwYWlyWzFdOyB9KTtcblxuICAgIC8vIEF0IHRoaXMgc3RlcCwgd2UgaGF2ZSBhbiBhcnJheSBvZiBpbmRleGVzXG4gICAgLy8gdGhhdCBtYXAgZnJvbSBzb3J0ZWQgbnVtYmVycyB0byB0aGVpciBvcmlnaW5hbCBpbmRleGVzLiBXZSByZXZlcnNlXG4gICAgLy8gdGhhdCBzbyB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIHRoZSBzb3J0ZWQgZGVzdGluYXRpb24gaW5kZXguXG4gICAgdmFyIHhSYW5rcyA9IEFycmF5KHhJbmRleGVzLmxlbmd0aCk7XG4gICAgdmFyIHlSYW5rcyA9IEFycmF5KHhJbmRleGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB4UmFua3NbeEluZGV4ZXNbaV1dID0gaTtcbiAgICAgICAgeVJhbmtzW3lJbmRleGVzW2ldXSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhbXBsZUNvcnJlbGF0aW9uKHhSYW5rcywgeVJhbmtzKTtcbn1cblxuLyoqXG4gKiBbU2tld25lc3NdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2tld25lc3MpIGlzXG4gKiBhIG1lYXN1cmUgb2YgdGhlIGV4dGVudCB0byB3aGljaCBhIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiBvZiBhXG4gKiByZWFsLXZhbHVlZCByYW5kb20gdmFyaWFibGUgXCJsZWFuc1wiIHRvIG9uZSBzaWRlIG9mIHRoZSBtZWFuLlxuICogVGhlIHNrZXduZXNzIHZhbHVlIGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgb3IgZXZlbiB1bmRlZmluZWQuXG4gKlxuICogSW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIGFkanVzdGVkIEZpc2hlci1QZWFyc29uIHN0YW5kYXJkaXplZFxuICogbW9tZW50IGNvZWZmaWNpZW50LCB3aGljaCBpcyB0aGUgdmVyc2lvbiBmb3VuZCBpbiBFeGNlbCBhbmQgc2V2ZXJhbFxuICogc3RhdGlzdGljYWwgcGFja2FnZXMgaW5jbHVkaW5nIE1pbml0YWIsIFNBUyBhbmQgU1BTUy5cbiAqXG4gKiBAc2luY2UgNC4xLjBcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiAzIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBza2V3bmVzc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggaGFzIGxlbmd0aCBsZXNzIHRoYW4gM1xuICogQGV4YW1wbGVcbiAqIHNhbXBsZVNrZXduZXNzKFsyLCA0LCA2LCAzLCAxXSk7IC8vID0+IDAuNTkwMTI4NjU2Mzg0MzY1XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVNrZXduZXNzKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZVNrZXduZXNzIHJlcXVpcmVzIGF0IGxlYXN0IHRocmVlIGRhdGEgcG9pbnRzXCIpO1xuICAgIH1cblxuICAgIHZhciBtZWFuVmFsdWUgPSBtZWFuKHgpO1xuICAgIHZhciB0ZW1wVmFsdWU7XG4gICAgdmFyIHN1bVNxdWFyZWREZXZpYXRpb25zID0gMDtcbiAgICB2YXIgc3VtQ3ViZWREZXZpYXRpb25zID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZW1wVmFsdWUgPSB4W2ldIC0gbWVhblZhbHVlO1xuICAgICAgICBzdW1TcXVhcmVkRGV2aWF0aW9ucyArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgICAgIHN1bUN1YmVkRGV2aWF0aW9ucyArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIEZpbmQgdGhlIG1lYW4gdmFsdWUgb2YgdGhhdCBsaXN0XG4gICAgdmFyIHRoZVNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KFxuICAgICAgICBzdW1TcXVhcmVkRGV2aWF0aW9ucyAvIGJlc3NlbHNDb3JyZWN0aW9uXG4gICAgKTtcblxuICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgdmFyIGN1YmVkUyA9IE1hdGgucG93KHRoZVNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uLCAzKTtcblxuICAgIHJldHVybiAobiAqIHN1bUN1YmVkRGV2aWF0aW9ucykgLyAoKG4gLSAxKSAqIChuIC0gMikgKiBjdWJlZFMpO1xufVxuXG4vKipcbiAqIFtLdXJ0b3Npc10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LdXJ0b3NpcykgaXNcbiAqIGEgbWVhc3VyZSBvZiB0aGUgaGVhdmluZXNzIG9mIGEgZGlzdHJpYnV0aW9uJ3MgdGFpbHMgcmVsYXRpdmUgdG8gaXRzXG4gKiB2YXJpYW5jZS4gVGhlIGt1cnRvc2lzIHZhbHVlIGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgb3IgZXZlbiB1bmRlZmluZWQuXG4gKlxuICogSW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gRmlzaGVyJ3MgZXhjZXNzIGt1cnRvc2lzIGRlZmluaXRpb24gYW5kIHVzZXNcbiAqIHVuYmlhc2VkIG1vbWVudCBlc3RpbWF0b3JzLiBUaGlzIGlzIHRoZSB2ZXJzaW9uIGZvdW5kIGluIEV4Y2VsIGFuZCBhdmFpbGFibGVcbiAqIGluIHNldmVyYWwgc3RhdGlzdGljYWwgcGFja2FnZXMsIGluY2x1ZGluZyBTQVMgYW5kIFNjaVB5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiA0IG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBrdXJ0b3Npc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggaGFzIGxlbmd0aCBsZXNzIHRoYW4gNFxuICogQGV4YW1wbGVcbiAqIHNhbXBsZUt1cnRvc2lzKFsxLCAyLCAyLCAzLCA1XSk7IC8vID0+IDEuNDU1NTc2NTU5NTQ2MzEyMlxuICovXG5mdW5jdGlvbiBzYW1wbGVLdXJ0b3Npcyh4KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcblxuICAgIGlmIChuIDwgNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVLdXJ0b3NpcyByZXF1aXJlcyBhdCBsZWFzdCBmb3VyIGRhdGEgcG9pbnRzXCIpO1xuICAgIH1cblxuICAgIHZhciBtZWFuVmFsdWUgPSBtZWFuKHgpO1xuICAgIHZhciB0ZW1wVmFsdWU7XG4gICAgdmFyIHNlY29uZENlbnRyYWxNb21lbnQgPSAwO1xuICAgIHZhciBmb3VydGhDZW50cmFsTW9tZW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgIHNlY29uZENlbnRyYWxNb21lbnQgKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgICAgICBmb3VydGhDZW50cmFsTW9tZW50ICs9IHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICAoKG4gLSAxKSAvICgobiAtIDIpICogKG4gLSAzKSkpICpcbiAgICAgICAgKChuICogKG4gKyAxKSAqIGZvdXJ0aENlbnRyYWxNb21lbnQpIC9cbiAgICAgICAgICAgIChzZWNvbmRDZW50cmFsTW9tZW50ICogc2Vjb25kQ2VudHJhbE1vbWVudCkgLVxuICAgICAgICAgICAgMyAqIChuIC0gMSkpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBbSGVhcCdzIEFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVhcCUyN3NfYWxnb3JpdGhtKVxuICogZm9yIGdlbmVyYXRpbmcgcGVybXV0YXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIGFueSB0eXBlIG9mIGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IGFycmF5IG9mIHBlcm11dGF0aW9uc1xuICovXG5mdW5jdGlvbiBwZXJtdXRhdGlvbnNIZWFwKGVsZW1lbnRzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBuZXcgQXJyYXkoZWxlbWVudHMubGVuZ3RoKTtcbiAgICB2YXIgcGVybXV0YXRpb25zID0gW2VsZW1lbnRzLnNsaWNlKCldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbmRleGVzW2ldID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBlbGVtZW50cy5sZW5ndGg7ICkge1xuICAgICAgICBpZiAoaW5kZXhlc1tpJDFdIDwgaSQxKSB7XG4gICAgICAgICAgICAvLyBBdCBvZGQgaW5kZXhlcywgc3dhcCBmcm9tIGluZGV4ZXNbaV0gaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICAgICAgICAgICAgdmFyIHN3YXBGcm9tID0gMDtcbiAgICAgICAgICAgIGlmIChpJDEgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc3dhcEZyb20gPSBpbmRleGVzW2kkMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN3YXAgYmV0d2VlbiBzd2FwRnJvbSBhbmQgaSwgdXNpbmdcbiAgICAgICAgICAgIC8vIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIGFzIHN0b3JhZ2UuXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGVsZW1lbnRzW3N3YXBGcm9tXTtcbiAgICAgICAgICAgIGVsZW1lbnRzW3N3YXBGcm9tXSA9IGVsZW1lbnRzW2kkMV07XG4gICAgICAgICAgICBlbGVtZW50c1tpJDFdID0gdGVtcDtcblxuICAgICAgICAgICAgcGVybXV0YXRpb25zLnB1c2goZWxlbWVudHMuc2xpY2UoKSk7XG4gICAgICAgICAgICBpbmRleGVzW2kkMV0rKztcbiAgICAgICAgICAgIGkkMSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleGVzW2kkMV0gPSAwO1xuICAgICAgICAgICAgaSQxKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIENvbWJpbmF0aW9uc1xuICogQ29tYmluYXRpb25zIGFyZSB1bmlxdWUgc3Vic2V0cyBvZiBhIGNvbGxlY3Rpb24gLSBpbiB0aGlzIGNhc2UsIGsgeCBmcm9tIGEgY29sbGVjdGlvbiBhdCBhIHRpbWUuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5hdGlvblxuICogQHBhcmFtIHtBcnJheX0geCBhbnkgdHlwZSBvZiBkYXRhXG4gKiBAcGFyYW0ge2ludH0gayB0aGUgbnVtYmVyIG9mIG9iamVjdHMgaW4gZWFjaCBncm91cCAod2l0aG91dCByZXBsYWNlbWVudClcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IGFycmF5IG9mIHBlcm11dGF0aW9uc1xuICogQGV4YW1wbGVcbiAqIGNvbWJpbmF0aW9ucyhbMSwgMiwgM10sIDIpOyAvLyA9PiBbWzEsMl0sIFsxLDNdLCBbMiwzXV1cbiAqL1xuXG5mdW5jdGlvbiBjb21iaW5hdGlvbnMoeCwgaykge1xuICAgIHZhciBpO1xuICAgIHZhciBzdWJJO1xuICAgIHZhciBjb21iaW5hdGlvbkxpc3QgPSBbXTtcbiAgICB2YXIgc3Vic2V0Q29tYmluYXRpb25zO1xuICAgIHZhciBuZXh0O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbWJpbmF0aW9uTGlzdC5wdXNoKFt4W2ldXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzZXRDb21iaW5hdGlvbnMgPSBjb21iaW5hdGlvbnMoeC5zbGljZShpICsgMSwgeC5sZW5ndGgpLCBrIC0gMSk7XG4gICAgICAgICAgICBmb3IgKHN1YkkgPSAwOyBzdWJJIDwgc3Vic2V0Q29tYmluYXRpb25zLmxlbmd0aDsgc3ViSSsrKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHN1YnNldENvbWJpbmF0aW9uc1tzdWJJXTtcbiAgICAgICAgICAgICAgICBuZXh0LnVuc2hpZnQoeFtpXSk7XG4gICAgICAgICAgICAgICAgY29tYmluYXRpb25MaXN0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmF0aW9uTGlzdDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBbQ29tYmluYXRpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5hdGlvbikgd2l0aCByZXBsYWNlbWVudFxuICogQ29tYmluYXRpb25zIGFyZSB1bmlxdWUgc3Vic2V0cyBvZiBhIGNvbGxlY3Rpb24gLSBpbiB0aGlzIGNhc2UsIGsgeCBmcm9tIGEgY29sbGVjdGlvbiBhdCBhIHRpbWUuXG4gKiAnV2l0aCByZXBsYWNlbWVudCcgbWVhbnMgdGhhdCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGNob3NlbiBtdWx0aXBsZSB0aW1lcy5cbiAqIFVubGlrZSBwZXJtdXRhdGlvbiwgb3JkZXIgZG9lc24ndCBtYXR0ZXIgZm9yIGNvbWJpbmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IGFueSB0eXBlIG9mIGRhdGFcbiAqIEBwYXJhbSB7aW50fSBrIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiBlYWNoIGdyb3VwICh3aXRob3V0IHJlcGxhY2VtZW50KVxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYXJyYXkgb2YgcGVybXV0YXRpb25zXG4gKiBAZXhhbXBsZVxuICogY29tYmluYXRpb25zUmVwbGFjZW1lbnQoWzEsIDJdLCAyKTsgLy8gPT4gW1sxLCAxXSwgWzEsIDJdLCBbMiwgMl1dXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmF0aW9uc1JlcGxhY2VtZW50KHgsIGspIHtcbiAgICB2YXIgY29tYmluYXRpb25MaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHJlcXVlc3RlZCB0byBmaW5kIG9ubHkgb25lIGVsZW1lbnQsIHdlIGRvbid0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHJlY3Vyc2U6IGp1c3QgcHVzaCBgeFtpXWAgb250byB0aGUgbGlzdCBvZiBjb21iaW5hdGlvbnMuXG4gICAgICAgICAgICBjb21iaW5hdGlvbkxpc3QucHVzaChbeFtpXV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWN1cnNpdmVseSBmaW5kIGNvbWJpbmF0aW9ucywgZ2l2ZW4gYGsgLSAxYC4gTm90ZSB0aGF0XG4gICAgICAgICAgICAvLyB3ZSByZXF1ZXN0IGBrIC0gMWAsIHNvIGlmIHlvdSB3ZXJlIGxvb2tpbmcgZm9yIGs9MyBjb21iaW5hdGlvbnMsIHdlJ3JlXG4gICAgICAgICAgICAvLyByZXF1ZXN0aW5nIGs9Mi4gVGhpcyAtMSBnZXRzIHJldmVyc2VkIGluIHRoZSBmb3IgbG9vcCByaWdodCBhZnRlciB0aGlzXG4gICAgICAgICAgICAvLyBjb2RlLCBzaW5jZSB3ZSBjb25jYXRlbmF0ZSBgeFtpXWAgb250byB0aGUgc2VsZWN0ZWQgY29tYmluYXRpb25zLFxuICAgICAgICAgICAgLy8gYnJpbmdpbmcgYGtgIGJhY2sgdXAgdG8geW91ciByZXF1ZXN0ZWQgbGV2ZWwuXG4gICAgICAgICAgICAvLyBUaGlzIHJlY3Vyc2lvbiBtYXkgZ28gbWFueSBsZXZlbHMgZGVlcCwgc2luY2UgaXQgb25seSBzdG9wcyBvbmNlXG4gICAgICAgICAgICAvLyBrPTEuXG4gICAgICAgICAgICB2YXIgc3Vic2V0Q29tYmluYXRpb25zID0gY29tYmluYXRpb25zUmVwbGFjZW1lbnQoXG4gICAgICAgICAgICAgICAgeC5zbGljZShpLCB4Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgayAtIDFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3Vic2V0Q29tYmluYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29tYmluYXRpb25MaXN0LnB1c2goW3hbaV1dLmNvbmNhdChzdWJzZXRDb21iaW5hdGlvbnNbal0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5hdGlvbkxpc3Q7XG59XG5cbi8qKlxuICogV2hlbiBhZGRpbmcgYSBuZXcgdmFsdWUgdG8gYSBsaXN0LCBvbmUgZG9lcyBub3QgaGF2ZSB0byBuZWNlc3NhcnlcbiAqIHJlY29tcHV0ZSB0aGUgbWVhbiBvZiB0aGUgbGlzdCBpbiBsaW5lYXIgdGltZS4gVGhleSBjYW4gaW5zdGVhZCB1c2VcbiAqIHRoaXMgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgbmV3IG1lYW4gYnkgcHJvdmlkaW5nIHRoZSBjdXJyZW50IG1lYW4sXG4gKiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBsaXN0IHRoYXQgcHJvZHVjZWQgaXQgYW5kIHRoZSBuZXdcbiAqIHZhbHVlIHRvIGFkZC5cbiAqXG4gKiBAc2luY2UgMi41LjBcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuIGN1cnJlbnQgbWVhblxuICogQHBhcmFtIHtudW1iZXJ9IG4gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgdGhlIGFkZGVkIHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbmV3IG1lYW5cbiAqXG4gKiBAZXhhbXBsZVxuICogYWRkVG9NZWFuKDE0LCA1LCA1Myk7IC8vID0+IDIwLjVcbiAqL1xuZnVuY3Rpb24gYWRkVG9NZWFuKG1lYW4sIG4sIG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIG1lYW4gKyAobmV3VmFsdWUgLSBtZWFuKSAvIChuICsgMSk7XG59XG5cbi8qKlxuICogV2hlbiBjb21iaW5pbmcgdHdvIGxpc3RzIG9mIHZhbHVlcyBmb3Igd2hpY2ggb25lIGFscmVhZHkga25vd3MgdGhlIG1lYW5zLFxuICogb25lIGRvZXMgbm90IGhhdmUgdG8gbmVjZXNzYXJ5IHJlY29tcHV0ZSB0aGUgbWVhbiBvZiB0aGUgY29tYmluZWQgbGlzdHMgaW5cbiAqIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGNvbWJpbmVkXG4gKiBtZWFuIGJ5IHByb3ZpZGluZyB0aGUgbWVhbiAmIG51bWJlciBvZiB2YWx1ZXMgb2YgdGhlIGZpcnN0IGxpc3QgYW5kIHRoZSBtZWFuXG4gKiAmIG51bWJlciBvZiB2YWx1ZXMgb2YgdGhlIHNlY29uZCBsaXN0LlxuICpcbiAqIEBzaW5jZSAzLjAuMFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4xIG1lYW4gb2YgdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuMiBtZWFuIG9mIHRoZSBzZWNvbmQgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4yIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc2Vjb25kIGxpc3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb21iaW5lZCBtZWFuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbWJpbmVNZWFucyg1LCAzLCA0LCAzKTsgLy8gPT4gNC41XG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVNZWFucyhtZWFuMSwgbjEsIG1lYW4yLCBuMikge1xuICAgIHJldHVybiAobWVhbjEgKiBuMSArIG1lYW4yICogbjIpIC8gKG4xICsgbjIpO1xufVxuXG4vKipcbiAqIFdoZW4gY29tYmluaW5nIHR3byBsaXN0cyBvZiB2YWx1ZXMgZm9yIHdoaWNoIG9uZSBhbHJlYWR5IGtub3dzIHRoZSB2YXJpYW5jZXMsXG4gKiBvbmUgZG9lcyBub3QgaGF2ZSB0byBuZWNlc3NhcnkgcmVjb21wdXRlIHRoZSB2YXJpYW5jZSBvZiB0aGUgY29tYmluZWQgbGlzdHNcbiAqIGluIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGNvbWJpbmVkXG4gKiB2YXJpYW5jZSBieSBwcm92aWRpbmcgdGhlIHZhcmlhbmNlLCBtZWFuICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgZmlyc3QgbGlzdFxuICogYW5kIHRoZSB2YXJpYW5jZSwgbWVhbiAmIG51bWJlciBvZiB2YWx1ZXMgb2YgdGhlIHNlY29uZCBsaXN0LlxuICpcbiAqIEBzaW5jZSAzLjAuMFxuICogQHBhcmFtIHtudW1iZXJ9IHZhcmlhbmNlMSB2YXJpYW5jZSBvZiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4xIG1lYW4gb2YgdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YXJpYW5jZTIgdmFyaWFuY2Ugb2YgdGhlIHNlY29uZCBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbWVhbjIgbWVhbiBvZiB0aGUgc2Vjb25kIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMiBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHNlY29uZCBsaXN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY29tYmluZWQgbWVhblxuICpcbiAqIEBleGFtcGxlXG4gKiBjb21iaW5lVmFyaWFuY2VzKDE0IC8gMywgNSwgMywgOCAvIDMsIDQsIDMpOyAvLyA9PiA0NyAvIDEyXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVWYXJpYW5jZXModmFyaWFuY2UxLCBtZWFuMSwgbjEsIHZhcmlhbmNlMiwgbWVhbjIsIG4yKSB7XG4gICAgdmFyIG5ld01lYW4gPSBjb21iaW5lTWVhbnMobWVhbjEsIG4xLCBtZWFuMiwgbjIpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgKG4xICogKHZhcmlhbmNlMSArIE1hdGgucG93KG1lYW4xIC0gbmV3TWVhbiwgMikpICtcbiAgICAgICAgICAgIG4yICogKHZhcmlhbmNlMiArIE1hdGgucG93KG1lYW4yIC0gbmV3TWVhbiwgMikpKSAvXG4gICAgICAgIChuMSArIG4yKVxuICAgICk7XG59XG5cbi8qKlxuICogVGhlIFtHZW9tZXRyaWMgTWVhbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvbWV0cmljX21lYW4pIGlzXG4gKiBhIG1lYW4gZnVuY3Rpb24gdGhhdCBpcyBtb3JlIHVzZWZ1bCBmb3IgbnVtYmVycyBpbiBkaWZmZXJlbnRcbiAqIHJhbmdlcy5cbiAqXG4gKiBUaGlzIGlzIHRoZSBudGggcm9vdCBvZiB0aGUgaW5wdXQgbnVtYmVycyBtdWx0aXBsaWVkIGJ5IGVhY2ggb3RoZXIuXG4gKlxuICogVGhlIGdlb21ldHJpYyBtZWFuIGlzIG9mdGVuIHVzZWZ1bCBmb3JcbiAqICoqW3Byb3BvcnRpb25hbCBncm93dGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb21ldHJpY19tZWFuI1Byb3BvcnRpb25hbF9ncm93dGgpKio6IGdpdmVuXG4gKiBncm93dGggcmF0ZXMgZm9yIG11bHRpcGxlIHllYXJzLCBsaWtlIF84MCUsIDE2LjY2JSBhbmQgNDIuODUlXywgYSBzaW1wbGVcbiAqIG1lYW4gd2lsbCBpbmNvcnJlY3RseSBlc3RpbWF0ZSBhbiBhdmVyYWdlIGdyb3d0aCByYXRlLCB3aGVyZWFzIGEgZ2VvbWV0cmljXG4gKiBtZWFuIHdpbGwgY29ycmVjdGx5IGVzdGltYXRlIGEgZ3Jvd3RoIHJhdGUgdGhhdCwgb3ZlciB0aG9zZSB5ZWFycyxcbiAqIHdpbGwgeWllbGQgdGhlIHNhbWUgZW5kIHZhbHVlLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gZ2VvbWV0cmljIG1lYW5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBjb250YWlucyBhIG5lZ2F0aXZlIG51bWJlclxuICogQGV4YW1wbGVcbiAqIHZhciBncm93dGhSYXRlcyA9IFsxLjgwLCAxLjE2NjY2NiwgMS40Mjg1NzFdO1xuICogdmFyIGF2ZXJhZ2VHcm93dGggPSBzcy5nZW9tZXRyaWNNZWFuKGdyb3d0aFJhdGVzKTtcbiAqIHZhciBhdmVyYWdlR3Jvd3RoUmF0ZXMgPSBbYXZlcmFnZUdyb3d0aCwgYXZlcmFnZUdyb3d0aCwgYXZlcmFnZUdyb3d0aF07XG4gKiB2YXIgc3RhcnRpbmdWYWx1ZSA9IDEwO1xuICogdmFyIHN0YXJ0aW5nVmFsdWVNZWFuID0gMTA7XG4gKiBncm93dGhSYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhdGUpIHtcbiAqICAgc3RhcnRpbmdWYWx1ZSAqPSByYXRlO1xuICogfSk7XG4gKiBhdmVyYWdlR3Jvd3RoUmF0ZXMuZm9yRWFjaChmdW5jdGlvbihyYXRlKSB7XG4gKiAgIHN0YXJ0aW5nVmFsdWVNZWFuICo9IHJhdGU7XG4gKiB9KTtcbiAqIHN0YXJ0aW5nVmFsdWVNZWFuID09PSBzdGFydGluZ1ZhbHVlO1xuICovXG5mdW5jdGlvbiBnZW9tZXRyaWNNZWFuKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvbWV0cmljTWVhbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgc3RhcnRpbmcgdmFsdWUuXG4gICAgdmFyIHZhbHVlID0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB0aGUgZ2VvbWV0cmljIG1lYW4gaXMgb25seSB2YWxpZCBmb3IgcG9zaXRpdmUgbnVtYmVyc1xuICAgICAgICBpZiAoeFtpXSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImdlb21ldHJpY01lYW4gcmVxdWlyZXMgb25seSBub24tbmVnYXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwZWF0ZWRseSBtdWx0aXBseSB0aGUgdmFsdWUgYnkgZWFjaCBudW1iZXJcbiAgICAgICAgdmFsdWUgKj0geFtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5wb3codmFsdWUsIDEgLyB4Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogVGhlIFtsb2cgYXZlcmFnZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvbWV0cmljX21lYW4jUmVsYXRpb25zaGlwX3dpdGhfbG9nYXJpdGhtcylcbiAqIGlzIGFuIGVxdWl2YWxlbnQgd2F5IG9mIGNvbXB1dGluZyB0aGUgZ2VvbWV0cmljIG1lYW4gb2YgYW4gYXJyYXkgc3VpdGFibGUgZm9yIGxhcmdlIG9yIHNtYWxsIHByb2R1Y3RzLlxuICpcbiAqIEl0J3MgZm91bmQgYnkgY2FsY3VsYXRpbmcgdGhlIGF2ZXJhZ2UgbG9nYXJpdGhtIG9mIHRoZSBlbGVtZW50cyBhbmQgZXhwb25lbnRpYXRpbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gZ2VvbWV0cmljIG1lYW5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBjb250YWlucyBhIG5lZ2F0aXZlIG51bWJlclxuICovXG5mdW5jdGlvbiBsb2dBdmVyYWdlKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9nQXZlcmFnZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeFtpXSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImxvZ0F2ZXJhZ2UgcmVxdWlyZXMgb25seSBub24tbmVnYXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IE1hdGgubG9nKHhbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmV4cCh2YWx1ZSAvIHgubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBUaGUgW0hhcm1vbmljIE1lYW5dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhcm1vbmljX21lYW4pIGlzXG4gKiBhIG1lYW4gZnVuY3Rpb24gdHlwaWNhbGx5IHVzZWQgdG8gZmluZCB0aGUgYXZlcmFnZSBvZiByYXRlcy5cbiAqIFRoaXMgbWVhbiBpcyBjYWxjdWxhdGVkIGJ5IHRha2luZyB0aGUgcmVjaXByb2NhbCBvZiB0aGUgYXJpdGhtZXRpYyBtZWFuXG4gKiBvZiB0aGUgcmVjaXByb2NhbHMgb2YgdGhlIGlucHV0IG51bWJlcnMuXG4gKlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gaGFybW9uaWMgbWVhblxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGNvbnRhaW5zIGEgbmVnYXRpdmUgbnVtYmVyXG4gKiBAZXhhbXBsZVxuICogaGFybW9uaWNNZWFuKFsyLCAzXSkudG9GaXhlZCgyKSAvLyA9PiAnMi40MCdcbiAqL1xuZnVuY3Rpb24gaGFybW9uaWNNZWFuKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFybW9uaWNNZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciByZWNpcHJvY2FsU3VtID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB0aGUgaGFybW9uaWMgbWVhbiBpcyBvbmx5IHZhbGlkIGZvciBwb3NpdGl2ZSBudW1iZXJzXG4gICAgICAgIGlmICh4W2ldIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImhhcm1vbmljTWVhbiByZXF1aXJlcyBvbmx5IHBvc2l0aXZlIG51bWJlcnMgYXMgaW5wdXRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2lwcm9jYWxTdW0gKz0gMSAvIHhbaV07XG4gICAgfVxuXG4gICAgLy8gZGl2aWRlIG4gYnkgdGhlIHJlY2lwcm9jYWwgc3VtXG4gICAgcmV0dXJuIHgubGVuZ3RoIC8gcmVjaXByb2NhbFN1bTtcbn1cblxuLyoqXG4gKiBUaGUgbWVhbiwgX2Fsc28ga25vd24gYXMgYXZlcmFnZV8sXG4gKiBpcyB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMgb3ZlciB0aGUgbnVtYmVyIG9mIHZhbHVlcy5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGUgc2ltcGxlIG1lYW4gdXNlcyB0aGUgc3VjY2Vzc2l2ZSBhZGRpdGlvbiBtZXRob2QgaW50ZXJuYWxseVxuICogdG8gY2FsY3VsYXRlIGl0J3MgcmVzdWx0LiBFcnJvcnMgaW4gZmxvYXRpbmctcG9pbnQgYWRkaXRpb24gYXJlXG4gKiBub3QgYWNjb3VudGVkIGZvciwgc28gaWYgcHJlY2lzaW9uIGlzIHJlcXVpcmVkLCB0aGUgc3RhbmRhcmQge0BsaW5rIG1lYW59XG4gKiBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1lYW5cbiAqIEBleGFtcGxlXG4gKiBtZWFuKFswLCAxMF0pOyAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIG1lYW5TaW1wbGUoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZWFuU2ltcGxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdW1TaW1wbGUoeCkgLyB4Lmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgW21lZGlhbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZWRpYW4pIGlzXG4gKiB0aGUgbWlkZGxlIG51bWJlciBvZiBhIGxpc3QuIFRoaXMgaXMgb2Z0ZW4gYSBnb29kIGluZGljYXRvciBvZiAndGhlIG1pZGRsZSdcbiAqIHdoZW4gdGhlcmUgYXJlIG91dGxpZXJzIHRoYXQgc2tldyB0aGUgYG1lYW4oKWAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhlIG1lZGlhbiBpc24ndCBuZWNlc3NhcmlseSBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBsaXN0OiB0aGUgdmFsdWVcbiAqIGNhbiBiZSB0aGUgYXZlcmFnZSBvZiB0d28gZWxlbWVudHMgaWYgdGhlIGxpc3QgaGFzIGFuIGV2ZW4gbGVuZ3RoXG4gKiBhbmQgdGhlIHR3byBjZW50cmFsIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc29ydGVkIGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWRpYW4gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtZWRpYW5Tb3J0ZWQoWzEwLCAyLCA1LCAxMDAsIDIsIDFdKTsgLy8gPT4gNTIuNVxuICovXG5mdW5jdGlvbiBtZWRpYW5Tb3J0ZWQoc29ydGVkKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlU29ydGVkKHNvcnRlZCwgMC41KTtcbn1cblxuLyoqXG4gKiBXaGVuIHJlbW92aW5nIGEgdmFsdWUgZnJvbSBhIGxpc3QsIG9uZSBkb2VzIG5vdCBoYXZlIHRvIG5lY2Vzc2FyeVxuICogcmVjb21wdXRlIHRoZSBtZWFuIG9mIHRoZSBsaXN0IGluIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZVxuICogdGhpcyBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBuZXcgbWVhbiBieSBwcm92aWRpbmcgdGhlIGN1cnJlbnQgbWVhbixcbiAqIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3QgdGhhdCBwcm9kdWNlZCBpdCBhbmQgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuIGN1cnJlbnQgbWVhblxuICogQHBhcmFtIHtudW1iZXJ9IG4gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlbW92ZVxuICogQHJldHVybnMge251bWJlcn0gdGhlIG5ldyBtZWFuXG4gKlxuICogQGV4YW1wbGVcbiAqIHN1YnRyYWN0RnJvbU1lYW4oMjAuNSwgNiwgNTMpOyAvLyA9PiAxNFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdEZyb21NZWFuKG1lYW4sIG4sIHZhbHVlKSB7XG4gICAgcmV0dXJuIChtZWFuICogbiAtIHZhbHVlKSAvIChuIC0gMSk7XG59XG5cbi8qKlxuICogVGhlIFJvb3QgTWVhbiBTcXVhcmUgKFJNUykgaXNcbiAqIGEgbWVhbiBmdW5jdGlvbiB1c2VkIGFzIGEgbWVhc3VyZSBvZiB0aGUgbWFnbml0dWRlIG9mIGEgc2V0XG4gKiBvZiBudW1iZXJzLCByZWdhcmRsZXNzIG9mIHRoZWlyIHNpZ24uXG4gKiBUaGlzIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgbWVhbiBvZiB0aGUgc3F1YXJlcyBvZiB0aGVcbiAqIGlucHV0IG51bWJlcnMuXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gcm9vdCBtZWFuIHNxdWFyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEBleGFtcGxlXG4gKiByb290TWVhblNxdWFyZShbLTEsIDEsIC0xLCAxXSk7IC8vID0+IDFcbiAqL1xuZnVuY3Rpb24gcm9vdE1lYW5TcXVhcmUoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyb290TWVhblNxdWFyZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtT2ZTcXVhcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtT2ZTcXVhcmVzICs9IE1hdGgucG93KHhbaV0sIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnNxcnQoc3VtT2ZTcXVhcmVzIC8geC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRoZWBjb2VmZmljaWVudCBvZiB2YXJpYXRpb25gXyBpcyB0aGUgcmF0aW8gb2YgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiB0byB0aGUgbWVhbi5cbiAqIC4uX2Bjb2VmZmljaWVudCBvZiB2YXJpYXRpb25gOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2VmZmljaWVudF9vZl92YXJpYXRpb25cbiAqXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uXG4gKiBAZXhhbXBsZVxuICogY29lZmZpY2llbnRPZlZhcmlhdGlvbihbMSwgMiwgMywgNF0pLnRvRml4ZWQoMyk7IC8vID0+IDAuNTE2XG4gKiBjb2VmZmljaWVudE9mVmFyaWF0aW9uKFsxLCAyLCAzLCA0LCA1XSkudG9GaXhlZCgzKTsgLy8gPT4gMC41MjdcbiAqIGNvZWZmaWNpZW50T2ZWYXJpYXRpb24oWy0xLCAwLCAxLCAyLCAzLCA0XSkudG9GaXhlZCgzKTsgLy8gPT4gMS4yNDdcbiAqL1xuZnVuY3Rpb24gY29lZmZpY2llbnRPZlZhcmlhdGlvbih4KSB7XG4gICAgcmV0dXJuIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpIC8gbWVhbih4KTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRvIGNvbXB1dGUgW2Egb25lLXNhbXBsZSB0LXRlc3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0dWRlbnQlMjdzX3QtdGVzdCNPbmUtc2FtcGxlX3QtdGVzdCksIGNvbXBhcmluZyB0aGUgbWVhblxuICogb2YgYSBzYW1wbGUgdG8gYSBrbm93biB2YWx1ZSwgeC5cbiAqXG4gKiBpbiB0aGlzIGNhc2UsIHdlJ3JlIHRyeWluZyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIHBvcHVsYXRpb24gbWVhbiBpcyBlcXVhbCB0byB0aGUgdmFsdWUgdGhhdCB3ZSBrbm93LCB3aGljaCBpcyBgeGBcbiAqIGhlcmUuIFVzdWFsbHkgdGhlIHJlc3VsdHMgaGVyZSBhcmUgdXNlZCB0byBsb29rIHVwIGFcbiAqIFtwLXZhbHVlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1AtdmFsdWUpLCB3aGljaCwgZm9yXG4gKiBhIGNlcnRhaW4gbGV2ZWwgb2Ygc2lnbmlmaWNhbmNlLCB3aWxsIGxldCB5b3UgZGV0ZXJtaW5lIHRoYXQgdGhlXG4gKiBudWxsIGh5cG90aGVzaXMgY2FuIG9yIGNhbm5vdCBiZSByZWplY3RlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZFZhbHVlIGV4cGVjdGVkIHZhbHVlIG9mIHRoZSBwb3B1bGF0aW9uIG1lYW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gKiBAZXhhbXBsZVxuICogdFRlc3QoWzEsIDIsIDMsIDQsIDUsIDZdLCAzLjM4NSkudG9GaXhlZCgyKTsgLy8gPT4gJzAuMTYnXG4gKi9cbmZ1bmN0aW9uIHRUZXN0KHgsIGV4cGVjdGVkVmFsdWUpIHtcbiAgICAvLyBUaGUgbWVhbiBvZiB0aGUgc2FtcGxlXG4gICAgdmFyIHNhbXBsZU1lYW4gPSBtZWFuKHgpO1xuXG4gICAgLy8gVGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgc2FtcGxlXG4gICAgdmFyIHNkID0gc3RhbmRhcmREZXZpYXRpb24oeCk7XG5cbiAgICAvLyBTcXVhcmUgcm9vdCB0aGUgbGVuZ3RoIG9mIHRoZSBzYW1wbGVcbiAgICB2YXIgcm9vdE4gPSBNYXRoLnNxcnQoeC5sZW5ndGgpO1xuXG4gICAgLy8gcmV0dXJuaW5nIHRoZSB0IHZhbHVlXG4gICAgcmV0dXJuIChzYW1wbGVNZWFuIC0gZXhwZWN0ZWRWYWx1ZSkgLyAoc2QgLyByb290Tik7XG59XG5cbi8qKlxuICogVGhpcyBpcyB0byBjb21wdXRlIFt0d28gc2FtcGxlIHQtdGVzdF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdHVkZW50J3NfdC10ZXN0KS5cbiAqIFRlc3RzIHdoZXRoZXIgXCJtZWFuKFgpLW1lYW4oWSkgPSBkaWZmZXJlbmNlXCIsIChcbiAqIGluIHRoZSBtb3N0IGNvbW1vbiBjYXNlLCB3ZSBvZnRlbiBoYXZlIGBkaWZmZXJlbmNlID09IDBgIHRvIHRlc3QgaWYgdHdvIHNhbXBsZXNcbiAqIGFyZSBsaWtlbHkgdG8gYmUgdGFrZW4gZnJvbSBwb3B1bGF0aW9ucyB3aXRoIHRoZSBzYW1lIG1lYW4gdmFsdWUpIHdpdGhcbiAqIG5vIHByaW9yIGtub3dsZWRnZSBvbiBzdGFuZGFyZCBkZXZpYXRpb25zIG9mIGJvdGggc2FtcGxlc1xuICogb3RoZXIgdGhhbiB0aGUgZmFjdCB0aGF0IHRoZXkgaGF2ZSB0aGUgc2FtZSBzdGFuZGFyZCBkZXZpYXRpb24uXG4gKlxuICogVXN1YWxseSB0aGUgcmVzdWx0cyBoZXJlIGFyZSB1c2VkIHRvIGxvb2sgdXAgYVxuICogW3AtdmFsdWVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUC12YWx1ZSksIHdoaWNoLCBmb3JcbiAqIGEgY2VydGFpbiBsZXZlbCBvZiBzaWduaWZpY2FuY2UsIHdpbGwgbGV0IHlvdSBkZXRlcm1pbmUgdGhhdCB0aGVcbiAqIG51bGwgaHlwb3RoZXNpcyBjYW4gb3IgY2Fubm90IGJlIHJlamVjdGVkLlxuICpcbiAqIGBkaWZmYCBjYW4gYmUgb21pdHRlZCBpZiBpdCBlcXVhbHMgMC5cbiAqXG4gKiBbVGhpcyBpcyB1c2VkIHRvIHJlamVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhjbHVzaW9uX29mX3RoZV9udWxsX2h5cG90aGVzaXMpXG4gKiBhIG51bGwgaHlwb3RoZXNpcyB0aGF0IHRoZSB0d28gcG9wdWxhdGlvbnMgdGhhdCBoYXZlIGJlZW4gc2FtcGxlZCBpbnRvXG4gKiBgc2FtcGxlWGAgYW5kIGBzYW1wbGVZYCBhcmUgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVggYSBzYW1wbGUgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzYW1wbGVZIGEgc2FtcGxlIGFzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGlmZmVyZW5jZT0wXVxuICogQHJldHVybnMge251bWJlcnxudWxsfSB0ZXN0IHJlc3VsdFxuICpcbiAqIEBleGFtcGxlXG4gKiB0VGVzdFR3b1NhbXBsZShbMSwgMiwgMywgNF0sIFszLCA0LCA1LCA2XSwgMCk7IC8vID0+IC0yLjE5MDg5MDIzMDAyMDY2NDNcbiAqL1xuZnVuY3Rpb24gdFRlc3RUd29TYW1wbGUoc2FtcGxlWCwgc2FtcGxlWSwgZGlmZmVyZW5jZSkge1xuICAgIHZhciBuID0gc2FtcGxlWC5sZW5ndGg7XG4gICAgdmFyIG0gPSBzYW1wbGVZLmxlbmd0aDtcblxuICAgIC8vIElmIGVpdGhlciBzYW1wbGUgZG9lc24ndCBhY3R1YWxseSBoYXZlIGFueSB2YWx1ZXMsIHdlIGNhbid0XG4gICAgLy8gY29tcHV0ZSB0aGlzIGF0IGFsbCwgc28gd2UgcmV0dXJuIGBudWxsYC5cbiAgICBpZiAoIW4gfHwgIW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBkaWZmZXJlbmNlIChtdSkgaXMgemVyb1xuICAgIGlmICghZGlmZmVyZW5jZSkge1xuICAgICAgICBkaWZmZXJlbmNlID0gMDtcbiAgICB9XG5cbiAgICB2YXIgbWVhblggPSBtZWFuKHNhbXBsZVgpO1xuICAgIHZhciBtZWFuWSA9IG1lYW4oc2FtcGxlWSk7XG4gICAgdmFyIHNhbXBsZVZhcmlhbmNlWCA9IHNhbXBsZVZhcmlhbmNlKHNhbXBsZVgpO1xuICAgIHZhciBzYW1wbGVWYXJpYW5jZVkgPSBzYW1wbGVWYXJpYW5jZShzYW1wbGVZKTtcblxuICAgIGlmIChcbiAgICAgICAgdHlwZW9mIG1lYW5YID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBtZWFuWSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2Ygc2FtcGxlVmFyaWFuY2VYID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBzYW1wbGVWYXJpYW5jZVkgPT09IFwibnVtYmVyXCJcbiAgICApIHtcbiAgICAgICAgdmFyIHdlaWdodGVkVmFyaWFuY2UgPVxuICAgICAgICAgICAgKChuIC0gMSkgKiBzYW1wbGVWYXJpYW5jZVggKyAobSAtIDEpICogc2FtcGxlVmFyaWFuY2VZKSAvXG4gICAgICAgICAgICAobiArIG0gLSAyKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG1lYW5YIC0gbWVhblkgLSBkaWZmZXJlbmNlKSAvXG4gICAgICAgICAgICBNYXRoLnNxcnQod2VpZ2h0ZWRWYXJpYW5jZSAqICgxIC8gbiArIDEgLyBtKSlcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBXaWxjb3hvbiByYW5rIHN1bSBzdGF0aXN0aWMgZm9yIHRoZSBmaXJzdCBzYW1wbGVcbiAqIHdpdGggcmVzcGVjdCB0byB0aGUgc2Vjb25kLiBUaGUgV2lsY294b24gcmFuayBzdW0gdGVzdCBpcyBhIG5vbi1wYXJhbWV0cmljXG4gKiBhbHRlcm5hdGl2ZSB0byB0aGUgdC10ZXN0IHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlXG4gKiBbTWFubi1XaGl0bmV5IFUgdGVzdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFubiVFMiU4MCU5M1doaXRuZXlfVV90ZXN0KS5cbiAqIFRoZSBzdGF0aXN0aWMgaXMgY2FsY3VsYXRlZCBieSBwb29saW5nIGFsbCB0aGUgb2JzZXJ2YXRpb25zIHRvZ2V0aGVyLCByYW5raW5nIHRoZW0sXG4gKiBhbmQgdGhlbiBzdW1taW5nIHRoZSByYW5rcyBhc3NvY2lhdGVkIHdpdGggb25lIG9mIHRoZSBzYW1wbGVzLiBJZiB0aGlzIHJhbmsgc3VtIGlzXG4gKiBzdWZmaWNpZW50bHkgbGFyZ2Ugb3Igc21hbGwgd2UgcmVqZWN0IHRoZSBoeXBvdGhlc2lzIHRoYXQgdGhlIHR3byBzYW1wbGVzIGNvbWVcbiAqIGZyb20gdGhlIHNhbWUgZGlzdHJpYnV0aW9uIGluIGZhdm9yIG9mIHRoZSBhbHRlcm5hdGl2ZSB0aGF0IG9uZSBpcyBzaGlmdGVkIHdpdGhcbiAqIHJlc3BlY3QgdG8gdGhlIG90aGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWCBhIHNhbXBsZSBhcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVkgYSBzYW1wbGUgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybnMge251bWJlcn0gcmFuayBzdW0gZm9yIHNhbXBsZVhcbiAqXG4gKiBAZXhhbXBsZVxuICogd2lsY294b25SYW5rU3VtKFsxLCA0LCA4XSwgWzksIDEyLCAxNV0pOyAvLyA9PiA2XG4gKi9cbmZ1bmN0aW9uIHdpbGNveG9uUmFua1N1bShzYW1wbGVYLCBzYW1wbGVZKSB7XG4gICAgaWYgKCFzYW1wbGVYLmxlbmd0aCB8fCAhc2FtcGxlWS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVpdGhlciBzYW1wbGUgY2FuIGJlIGVtcHR5XCIpO1xuICAgIH1cblxuICAgIHZhciBwb29sZWRTYW1wbGVzID0gc2FtcGxlWFxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAoeyBsYWJlbDogXCJ4XCIsIHZhbHVlOiB4IH0pOyB9KVxuICAgICAgICAuY29uY2F0KHNhbXBsZVkubWFwKGZ1bmN0aW9uICh5KSB7IHJldHVybiAoeyBsYWJlbDogXCJ5XCIsIHZhbHVlOiB5IH0pOyB9KSlcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlOyB9KTtcblxuICAgIGZvciAodmFyIHJhbmsgPSAwOyByYW5rIDwgcG9vbGVkU2FtcGxlcy5sZW5ndGg7IHJhbmsrKykge1xuICAgICAgICBwb29sZWRTYW1wbGVzW3JhbmtdLnJhbmsgPSByYW5rO1xuICAgIH1cblxuICAgIHZhciB0aWVkUmFua3MgPSBbcG9vbGVkU2FtcGxlc1swXS5yYW5rXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvb2xlZFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBvb2xlZFNhbXBsZXNbaV0udmFsdWUgPT09IHBvb2xlZFNhbXBsZXNbaSAtIDFdLnZhbHVlKSB7XG4gICAgICAgICAgICB0aWVkUmFua3MucHVzaChwb29sZWRTYW1wbGVzW2ldLnJhbmspO1xuICAgICAgICAgICAgaWYgKGkgPT09IHBvb2xlZFNhbXBsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VSYW5rc0luUGxhY2UocG9vbGVkU2FtcGxlcywgdGllZFJhbmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aWVkUmFua3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmVwbGFjZVJhbmtzSW5QbGFjZShwb29sZWRTYW1wbGVzLCB0aWVkUmFua3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGllZFJhbmtzID0gW3Bvb2xlZFNhbXBsZXNbaV0ucmFua107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlUmFua3NJblBsYWNlKHBvb2xlZFNhbXBsZXMsIHRpZWRSYW5rcykge1xuICAgICAgICB2YXIgYXZlcmFnZSA9ICh0aWVkUmFua3NbMF0gKyB0aWVkUmFua3NbdGllZFJhbmtzLmxlbmd0aCAtIDFdKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGllZFJhbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb29sZWRTYW1wbGVzW3RpZWRSYW5rc1tpXV0ucmFuayA9IGF2ZXJhZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmFua1N1bSA9IDA7XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb29sZWRTYW1wbGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHNhbXBsZSA9IHBvb2xlZFNhbXBsZXNbaSQxXTtcbiAgICAgICAgaWYgKHNhbXBsZS5sYWJlbCA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJhbmtTdW0gKz0gc2FtcGxlLnJhbmsgKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmtTdW07XG59XG5cbi8qKlxuICogW0JheWVzaWFuIENsYXNzaWZpZXJdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmFpdmVfQmF5ZXNfY2xhc3NpZmllcilcbiAqXG4gKiBUaGlzIGlzIGEgbmHDr3ZlIGJheWVzaWFuIGNsYXNzaWZpZXIgdGhhdCB0YWtlc1xuICogc2luZ2x5LW5lc3RlZCBvYmplY3RzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIHZhciBiYXllcyA9IG5ldyBCYXllc2lhbkNsYXNzaWZpZXIoKTtcbiAqIGJheWVzLnRyYWluKHtcbiAqICAgc3BlY2llczogJ0NhdCdcbiAqIH0sICdhbmltYWwnKTtcbiAqIHZhciByZXN1bHQgPSBiYXllcy5zY29yZSh7XG4gKiAgIHNwZWNpZXM6ICdDYXQnXG4gKiB9KVxuICogLy8gcmVzdWx0XG4gKiAvLyB7XG4gKiAvLyAgIGFuaW1hbDogMVxuICogLy8gfVxuICovXG52YXIgQmF5ZXNpYW5DbGFzc2lmaWVyID0gZnVuY3Rpb24gQmF5ZXNpYW5DbGFzc2lmaWVyKCkge1xuICAgIC8vIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBhcmUgY3VycmVudGx5XG4gICAgLy8gY2xhc3NpZmllZCBpbiB0aGUgbW9kZWxcbiAgICB0aGlzLnRvdGFsQ291bnQgPSAwO1xuICAgIC8vIEV2ZXJ5IGl0ZW0gY2xhc3NpZmllZCBpbiB0aGUgbW9kZWxcbiAgICB0aGlzLmRhdGEgPSB7fTtcbn07XG5cbi8qKlxuICogVHJhaW4gdGhlIGNsYXNzaWZpZXIgd2l0aCBhIG5ldyBpdGVtLCB3aGljaCBoYXMgYSBzaW5nbGVcbiAqIGRpbWVuc2lvbiBvZiBKYXZhc2NyaXB0IGxpdGVyYWwga2V5cyBhbmQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIGFuIG9iamVjdCB3aXRoIHNpbmdseS1kZWVwIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSB0aGUgY2F0ZWdvcnkgdGhpcyBpdGVtIGJlbG9uZ3MgdG9cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gYWRkcyB0aGUgaXRlbSB0byB0aGUgY2xhc3NpZmllclxuICovXG5CYXllc2lhbkNsYXNzaWZpZXIucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gdHJhaW4gKGl0ZW0sIGNhdGVnb3J5KSB7XG4gICAgLy8gSWYgdGhlIGRhdGEgb2JqZWN0IGRvZXNuJ3QgaGF2ZSBhbnkgdmFsdWVzXG4gICAgLy8gZm9yIHRoaXMgY2F0ZWdvcnksIGNyZWF0ZSBhIG5ldyBvYmplY3QgZm9yIGl0LlxuICAgIGlmICghdGhpcy5kYXRhW2NhdGVnb3J5XSkge1xuICAgICAgICB0aGlzLmRhdGFbY2F0ZWdvcnldID0ge307XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2gga2V5IGluIHRoZSBpdGVtLlxuICAgIGZvciAodmFyIGsgaW4gaXRlbSkge1xuICAgICAgICB2YXIgdiA9IGl0ZW1ba107XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG5lc3RlZCBvYmplY3QgYGRhdGFbY2F0ZWdvcnldW2tdW2l0ZW1ba11dYFxuICAgICAgICAvLyB3aXRoIGFuIG9iamVjdCBvZiBrZXlzIHRoYXQgZXF1YWwgMC5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVtjYXRlZ29yeV1ba10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2NhdGVnb3J5XVtrXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGFbY2F0ZWdvcnldW2tdW3ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtjYXRlZ29yeV1ba11bdl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5kIGluY3JlbWVudCB0aGUga2V5IGZvciB0aGlzIGtleS92YWx1ZSBjb21iaW5hdGlvbi5cbiAgICAgICAgdGhpcy5kYXRhW2NhdGVnb3J5XVtrXVt2XSsrO1xuICAgIH1cblxuICAgIC8vIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGNsYXNzaWZpZWRcbiAgICB0aGlzLnRvdGFsQ291bnQrKztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzY29yZSBvZiBob3cgd2VsbCB0aGlzIGl0ZW0gbWF0Y2hlcyBhbGxcbiAqIHBvc3NpYmxlIGNhdGVnb3JpZXMgYmFzZWQgb24gaXRzIGF0dHJpYnV0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSBhbiBpdGVtIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB3aXRoIHRyYWluXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvZiBwcm9iYWJpbGl0aWVzIHRoYXQgdGhpcyBpdGVtIGJlbG9uZ3MgdG8gYVxuICogZ2l2ZW4gY2F0ZWdvcnkuXG4gKi9cbkJheWVzaWFuQ2xhc3NpZmllci5wcm90b3R5cGUuc2NvcmUgPSBmdW5jdGlvbiBzY29yZSAoaXRlbSkge1xuICAgIC8vIEluaXRpYWxpemUgYW4gZW1wdHkgYXJyYXkgb2Ygb2RkcyBwZXIgY2F0ZWdvcnkuXG4gICAgdmFyIG9kZHMgPSB7fTtcbiAgICB2YXIgY2F0ZWdvcnk7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2gga2V5IGluIHRoZSBpdGVtLFxuICAgIC8vIHRoZW4gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggY2F0ZWdvcnkgdGhhdCBoYXMgYmVlbiB1c2VkXG4gICAgLy8gaW4gcHJldmlvdXMgY2FsbHMgdG8gYC50cmFpbigpYFxuICAgIGZvciAodmFyIGsgaW4gaXRlbSkge1xuICAgICAgICB2YXIgdiA9IGl0ZW1ba107XG4gICAgICAgIGZvciAoY2F0ZWdvcnkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgb2JqZWN0IGZvciBzdG9yaW5nIGtleSAtIHZhbHVlIGNvbWJpbmF0aW9uc1xuICAgICAgICAgICAgLy8gZm9yIHRoaXMgY2F0ZWdvcnkuXG4gICAgICAgICAgICBvZGRzW2NhdGVnb3J5XSA9IHt9O1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGl0ZW0gZG9lc24ndCBldmVuIGhhdmUgYSBwcm9wZXJ0eSwgaXQgY291bnRzIGZvciBub3RoaW5nLFxuICAgICAgICAgICAgLy8gYnV0IGlmIGl0IGRvZXMgaGF2ZSB0aGUgcHJvcGVydHkgdGhhdCB3ZSdyZSBsb29raW5nIGZvciBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgaXRlbSB0byBjYXRlZ29yaXplLCBpdCBjb3VudHMgYmFzZWQgb24gaG93IHBvcHVsYXIgaXQgaXNcbiAgICAgICAgICAgIC8vIHZlcnN1cyB0aGUgd2hvbGUgcG9wdWxhdGlvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbY2F0ZWdvcnldW2tdKSB7XG4gICAgICAgICAgICAgICAgb2Rkc1tjYXRlZ29yeV1bayArIFwiX1wiICsgdl0gPVxuICAgICAgICAgICAgICAgICAgICAodGhpcy5kYXRhW2NhdGVnb3J5XVtrXVt2XSB8fCAwKSAvIHRoaXMudG90YWxDb3VudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Rkc1tjYXRlZ29yeV1bayArIFwiX1wiICsgdl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIGEgbmV3IG9iamVjdCB0aGF0IHdpbGwgY29udGFpbiBzdW1zIG9mIHRoZXNlIG9kZHMgYnkgY2F0ZWdvcnlcbiAgICB2YXIgb2Rkc1N1bXMgPSB7fTtcblxuICAgIGZvciAoY2F0ZWdvcnkgaW4gb2Rkcykge1xuICAgICAgICAvLyBUYWxseSBhbGwgb2YgdGhlIG9kZHMgZm9yIGVhY2ggY2F0ZWdvcnktY29tYmluYXRpb24gcGFpciAtXG4gICAgICAgIC8vIHRoZSBub24tZXhpc3RlbmNlIG9mIGEgY2F0ZWdvcnkgZG9lcyBub3QgYWRkIGFueXRoaW5nIHRvIHRoZVxuICAgICAgICAvLyBzY29yZS5cbiAgICAgICAgb2Rkc1N1bXNbY2F0ZWdvcnldID0gMDtcbiAgICAgICAgZm9yICh2YXIgY29tYmluYXRpb24gaW4gb2Rkc1tjYXRlZ29yeV0pIHtcbiAgICAgICAgICAgIG9kZHNTdW1zW2NhdGVnb3J5XSArPSBvZGRzW2NhdGVnb3J5XVtjb21iaW5hdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2Rkc1N1bXM7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBzaW5nbGUtbGF5ZXIgW1BlcmNlcHRyb24gQ2xhc3NpZmllcl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QZXJjZXB0cm9uKSB0aGF0IHRha2VzXG4gKiBhcnJheXMgb2YgbnVtYmVycyBhbmQgcHJlZGljdHMgd2hldGhlciB0aGV5IHNob3VsZCBiZSBjbGFzc2lmaWVkXG4gKiBhcyBlaXRoZXIgMCBvciAxIChuZWdhdGl2ZSBvciBwb3NpdGl2ZSBleGFtcGxlcykuXG4gKiBAY2xhc3NcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgdGhlIG1vZGVsXG4gKiB2YXIgcCA9IG5ldyBQZXJjZXB0cm9uTW9kZWwoKTtcbiAqIC8vIFRyYWluIHRoZSBtb2RlbCB3aXRoIGlucHV0IHdpdGggYSBkaWFnb25hbCBib3VuZGFyeS5cbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gKiAgICAgcC50cmFpbihbMSwgMV0sIDEpO1xuICogICAgIHAudHJhaW4oWzAsIDFdLCAwKTtcbiAqICAgICBwLnRyYWluKFsxLCAwXSwgMCk7XG4gKiAgICAgcC50cmFpbihbMCwgMF0sIDApO1xuICogfVxuICogcC5wcmVkaWN0KFswLCAwXSk7IC8vIDBcbiAqIHAucHJlZGljdChbMCwgMV0pOyAvLyAwXG4gKiBwLnByZWRpY3QoWzEsIDBdKTsgLy8gMFxuICogcC5wcmVkaWN0KFsxLCAxXSk7IC8vIDFcbiAqL1xudmFyIFBlcmNlcHRyb25Nb2RlbCA9IGZ1bmN0aW9uIFBlcmNlcHRyb25Nb2RlbCgpIHtcbiAgICAvLyBUaGUgd2VpZ2h0cywgb3IgY29lZmZpY2llbnRzIG9mIHRoZSBtb2RlbDtcbiAgICAvLyB3ZWlnaHRzIGFyZSBvbmx5IHBvcHVsYXRlZCB3aGVuIHRyYWluaW5nIHdpdGggZGF0YS5cbiAgICB0aGlzLndlaWdodHMgPSBbXTtcbiAgICAvLyBUaGUgYmlhcyB0ZXJtLCBvciBpbnRlcmNlcHQ7IGl0IGlzIGFsc28gYSB3ZWlnaHQgYnV0XG4gICAgLy8gaXQncyBzdG9yZWQgc2VwYXJhdGVseSBmb3IgY29udmVuaWVuY2UgYXMgaXQgaXMgYWx3YXlzXG4gICAgLy8gbXVsdGlwbGllZCBieSBvbmUuXG4gICAgdGhpcy5iaWFzID0gMDtcbn07XG4vKipcbiAqICoqUHJlZGljdCoqOiBVc2UgYW4gYXJyYXkgb2YgZmVhdHVyZXMgd2l0aCB0aGUgd2VpZ2h0IGFycmF5IGFuZCBiaWFzXG4gKiB0byBwcmVkaWN0IHdoZXRoZXIgYW4gZXhhbXBsZSBpcyBsYWJlbGVkIDAgb3IgMS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVzIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFzIG51bWJlcnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDEgaWYgdGhlIHNjb3JlIGlzIG92ZXIgMCwgb3RoZXJ3aXNlIDBcbiAqL1xuUGVyY2VwdHJvbk1vZGVsLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gcHJlZGljdCAoZmVhdHVyZXMpIHtcbiAgICAvLyBPbmx5IHByZWRpY3QgaWYgcHJldmlvdXNseSB0cmFpbmVkXG4gICAgLy8gb24gdGhlIHNhbWUgc2l6ZSBmZWF0dXJlIGFycmF5KHMpLlxuICAgIGlmIChmZWF0dXJlcy5sZW5ndGggIT09IHRoaXMud2VpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2YgZmVhdHVyZXMgdGltZXMgd2VpZ2h0cyxcbiAgICAvLyB3aXRoIHRoZSBiaWFzIGFkZGVkIChpbXBsaWNpdGx5IHRpbWVzIG9uZSkuXG4gICAgdmFyIHNjb3JlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzY29yZSArPSB0aGlzLndlaWdodHNbaV0gKiBmZWF0dXJlc1tpXTtcbiAgICB9XG4gICAgc2NvcmUgKz0gdGhpcy5iaWFzO1xuXG4gICAgLy8gQ2xhc3NpZnkgYXMgMSBpZiB0aGUgc2NvcmUgaXMgb3ZlciAwLCBvdGhlcndpc2UgMC5cbiAgICBpZiAoc2NvcmUgPiAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogKipUcmFpbioqIHRoZSBjbGFzc2lmaWVyIHdpdGggYSBuZXcgZXhhbXBsZSwgd2hpY2ggaXNcbiAqIGEgbnVtZXJpYyBhcnJheSBvZiBmZWF0dXJlcyBhbmQgYSAwIG9yIDEgbGFiZWwuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmZWF0dXJlcyBhbiBhcnJheSBvZiBmZWF0dXJlcyBhcyBudW1iZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gbGFiZWwgZWl0aGVyIDAgb3IgMVxuICogQHJldHVybnMge1BlcmNlcHRyb25Nb2RlbH0gdGhpc1xuICovXG5QZXJjZXB0cm9uTW9kZWwucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gdHJhaW4gKGZlYXR1cmVzLCBsYWJlbCkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCBvbmx5IGxhYmVscyBvZiAwIG9yIDEgYXJlIGNvbnNpZGVyZWQuXG4gICAgaWYgKGxhYmVsICE9PSAwICYmIGxhYmVsICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGUgbGVuZ3RoIG9mIHRoZSBmZWF0dXJlIGFycmF5IGRldGVybWluZXNcbiAgICAvLyB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWlnaHQgYXJyYXkuXG4gICAgLy8gVGhlIHBlcmNlcHRyb24gd2lsbCBjb250aW51ZSBsZWFybmluZyBhcyBsb25nIGFzXG4gICAgLy8gaXQga2VlcHMgc2VlaW5nIGZlYXR1cmUgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aC5cbiAgICAvLyBXaGVuIGl0IHNlZXMgYSBuZXcgZGF0YSBzaGFwZSwgaXQgaW5pdGlhbGl6ZXMuXG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCAhPT0gdGhpcy53ZWlnaHRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLndlaWdodHMgPSBmZWF0dXJlcztcbiAgICAgICAgdGhpcy5iaWFzID0gMTtcbiAgICB9XG4gICAgLy8gTWFrZSBhIHByZWRpY3Rpb24gYmFzZWQgb24gY3VycmVudCB3ZWlnaHRzLlxuICAgIHZhciBwcmVkaWN0aW9uID0gdGhpcy5wcmVkaWN0KGZlYXR1cmVzKTtcbiAgICAvLyBVcGRhdGUgdGhlIHdlaWdodHMgaWYgdGhlIHByZWRpY3Rpb24gaXMgd3JvbmcuXG4gICAgaWYgKHR5cGVvZiBwcmVkaWN0aW9uID09PSBcIm51bWJlclwiICYmIHByZWRpY3Rpb24gIT09IGxhYmVsKSB7XG4gICAgICAgIHZhciBncmFkaWVudCA9IGxhYmVsIC0gcHJlZGljdGlvbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud2VpZ2h0c1tpXSArPSBncmFkaWVudCAqIGZlYXR1cmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmlhcyArPSBncmFkaWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdlIHVzZSBgzrVgLCBlcHNpbG9uLCBhcyBhIHN0b3BwaW5nIGNyaXRlcmlvbiB3aGVuIHdlIHdhbnQgdG8gaXRlcmF0ZVxuICogdW50aWwgd2UncmUgXCJjbG9zZSBlbm91Z2hcIi4gRXBzaWxvbiBpcyBhIHZlcnkgc21hbGwgbnVtYmVyOiBmb3JcbiAqIHNpbXBsZSBzdGF0aXN0aWNzLCB0aGF0IG51bWJlciBpcyAqKjAuMDAwMSoqXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIGNhbGN1bGF0aW9ucyBsaWtlIHRoZSBiaW5vbWlhbERpc3RyaWJ1dGlvbiwgaW4gd2hpY2hcbiAqIHRoZSBwcm9jZXNzIG9mIGZpbmRpbmcgYSB2YWx1ZSBpcyBbaXRlcmF0aXZlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JdGVyYXRpdmVfbWV0aG9kKTpcbiAqIGl0IHByb2dyZXNzZXMgdW50aWwgaXQgaXMgY2xvc2UgZW5vdWdoLlxuICpcbiAqIEJlbG93IGlzIGFuIGV4YW1wbGUgb2YgdXNpbmcgZXBzaWxvbiBpbiBbZ3JhZGllbnQgZGVzY2VudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JhZGllbnRfZGVzY2VudCksXG4gKiB3aGVyZSB3ZSdyZSB0cnlpbmcgdG8gZmluZCBhIGxvY2FsIG1pbmltdW0gb2YgYSBmdW5jdGlvbidzIGRlcml2YXRpdmUsXG4gKiBnaXZlbiBieSB0aGUgYGZEZXJpdmF0aXZlYCBtZXRob2QuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZyb20gY2FsY3VsYXRpb24sIHdlIGV4cGVjdCB0aGF0IHRoZSBsb2NhbCBtaW5pbXVtIG9jY3VycyBhdCB4PTkvNFxuICogdmFyIHhfb2xkID0gMDtcbiAqIC8vIFRoZSBhbGdvcml0aG0gc3RhcnRzIGF0IHg9NlxuICogdmFyIHhfbmV3ID0gNjtcbiAqIHZhciBzdGVwU2l6ZSA9IDAuMDE7XG4gKlxuICogZnVuY3Rpb24gZkRlcml2YXRpdmUoeCkge1xuICogICByZXR1cm4gNCAqIE1hdGgucG93KHgsIDMpIC0gOSAqIE1hdGgucG93KHgsIDIpO1xuICogfVxuICpcbiAqIC8vIFRoZSBsb29wIHJ1bnMgdW50aWwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcHJldmlvdXNcbiAqIC8vIHZhbHVlIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gZXBzaWxvbiAtIGEgcm91Z2hcbiAqIC8vIG1lYXVyZSBvZiAnY2xvc2UgZW5vdWdoJ1xuICogd2hpbGUgKE1hdGguYWJzKHhfbmV3IC0geF9vbGQpID4gc3MuZXBzaWxvbikge1xuICogICB4X29sZCA9IHhfbmV3O1xuICogICB4X25ldyA9IHhfb2xkIC0gc3RlcFNpemUgKiBmRGVyaXZhdGl2ZSh4X29sZCk7XG4gKiB9XG4gKlxuICogY29uc29sZS5sb2coJ0xvY2FsIG1pbmltdW0gb2NjdXJzIGF0JywgeF9uZXcpO1xuICovXG52YXIgZXBzaWxvbiA9IDAuMDAwMTtcblxuLyoqXG4gKiBBIFtGYWN0b3JpYWxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZhY3RvcmlhbCksIHVzdWFsbHkgd3JpdHRlbiBuISwgaXMgdGhlIHByb2R1Y3Qgb2YgYWxsIHBvc2l0aXZlXG4gKiBpbnRlZ2VycyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbi4gT2Z0ZW4gZmFjdG9yaWFsIGlzIGltcGxlbWVudGVkXG4gKiByZWN1cnNpdmVseSwgYnV0IHRoaXMgaXRlcmF0aXZlIGFwcHJvYWNoIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyXG4gKiBhbmQgc2ltcGxlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBpbnB1dCwgbXVzdCBiZSBhbiBpbnRlZ2VyIG51bWJlciAxIG9yIGdyZWF0ZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGZhY3RvcmlhbDogbiFcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBuIGlzIGxlc3MgdGhhbiAwIG9yIG5vdCBhbiBpbnRlZ2VyXG4gKiBAZXhhbXBsZVxuICogZmFjdG9yaWFsKDUpOyAvLyA9PiAxMjBcbiAqL1xuZnVuY3Rpb24gZmFjdG9yaWFsKG4pIHtcbiAgICAvLyBmYWN0b3JpYWwgaXMgbWF0aGVtYXRpY2FsbHkgdW5kZWZpbmVkIGZvciBuZWdhdGl2ZSBudW1iZXJzXG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhY3RvcmlhbCByZXF1aXJlcyBhIG5vbi1uZWdhdGl2ZSB2YWx1ZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5mbG9vcihuKSAhPT0gbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3JpYWwgcmVxdWlyZXMgYW4gaW50ZWdlciBpbnB1dFwiKTtcbiAgICB9XG5cbiAgICAvLyB0eXBpY2FsbHkgeW91J2xsIGV4cGFuZCB0aGUgZmFjdG9yaWFsIGZ1bmN0aW9uIGdvaW5nIGRvd24sIGxpa2VcbiAgICAvLyA1ISA9IDUgKiA0ICogMyAqIDIgKiAxLiBUaGlzIGlzIGdvaW5nIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sXG4gICAgLy8gY291bnRpbmcgZnJvbSAyIHVwIHRvIHRoZSBudW1iZXIgaW4gcXVlc3Rpb24sIGFuZCBzaW5jZSBhbnl0aGluZ1xuICAgIC8vIG11bHRpcGxpZWQgYnkgMSBpcyBpdHNlbGYsIHRoZSBsb29wIG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgMi5cbiAgICB2YXIgYWNjdW11bGF0b3IgPSAxO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDw9IG47IGkrKykge1xuICAgICAgICAvLyBmb3IgZWFjaCBudW1iZXIgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgbnVtYmVyIGBuYCwgbXVsdGlwbHlcbiAgICAgICAgLy8gdGhlIGFjY3VtdWxhdG9yIG15IHRoYXQgbnVtYmVyLlxuICAgICAgICBhY2N1bXVsYXRvciAqPSBpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgW2dhbW1hIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbikgb2YgYSB2YWx1ZSB1c2luZyBOZW1lcycgYXBwcm94aW1hdGlvbi5cbiAqIFRoZSBnYW1tYSBvZiBuIGlzIGVxdWl2YWxlbnQgdG8gKG4tMSkhLCBidXQgdW5saWtlIHRoZSBmYWN0b3JpYWwgZnVuY3Rpb24sIGdhbW1hIGlzIGRlZmluZWQgZm9yIGFsbCByZWFsIG4gZXhjZXB0IHplcm9cbiAqIGFuZCBuZWdhdGl2ZSBpbnRlZ2VycyAod2hlcmUgTmFOIGlzIHJldHVybmVkKS4gTm90ZSwgdGhlIGdhbW1hIGZ1bmN0aW9uIGlzIGFsc28gd2VsbC1kZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnMsXG4gKiB0aG91Z2ggdGhpcyBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZG9lcyBub3QgaGFuZGxlIGNvbXBsZXggbnVtYmVycyBhcyBpbnB1dCB2YWx1ZXMuXG4gKiBOZW1lcycgYXBwcm94aW1hdGlvbiBpcyBkZWZpbmVkIFtoZXJlXShodHRwczovL2FyeGl2Lm9yZy9hYnMvMTAwMy42MDIwKSBhcyBUaGVvcmVtIDIuMi5cbiAqIE5lZ2F0aXZlIHZhbHVlcyB1c2UgW0V1bGVyJ3MgcmVmbGVjdGlvbiBmb3JtdWxhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbiNQcm9wZXJ0aWVzKSBmb3IgY29tcHV0YXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG4gQW55IHJlYWwgbnVtYmVyIGV4Y2VwdCBmb3IgemVybyBhbmQgbmVnYXRpdmUgaW50ZWdlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZ2FtbWEgb2YgdGhlIGlucHV0IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBnYW1tYSgxMS41KTsgLy8gMTE4OTk0MjMuMDg0MDM3MDM4XG4gKiBnYW1tYSgtMTEuNSk7IC8vIDIuMjk1NzU4MTA0ODE2MDllLThcbiAqIGdhbW1hKDUpOyAvLyAyNFxuICovXG5mdW5jdGlvbiBnYW1tYShuKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgICAgLy8gZ2FtbWEgbm90IGRlZmluZWQgZm9yIHplcm8gb3IgbmVnYXRpdmUgaW50ZWdlcnNcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlIGZhY3RvcmlhbCBmb3IgaW50ZWdlciBpbnB1dHNcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3JpYWwobiAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVjcmVtZW50IG4sIGJlY2F1c2UgYXBwcm94aW1hdGlvbiBpcyBkZWZpbmVkIGZvciBuIC0gMVxuICAgIG4tLTtcblxuICAgIGlmIChuIDwgMCkge1xuICAgICAgICAvLyBVc2UgRXVsZXIncyByZWZsZWN0aW9uIGZvcm11bGEgZm9yIG5lZ2F0aXZlIGlucHV0c1xuICAgICAgICAvLyBzZWU6ICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbiNQcm9wZXJ0aWVzXG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiAtbikgKiBnYW1tYSgtbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5lbWVzJyBleHBhbnNpb24gYXBwcm94aW1hdGlvblxuICAgICAgICB2YXIgc2VyaWVzQ29lZmZpY2llbnQgPVxuICAgICAgICAgICAgTWF0aC5wb3cobiAvIE1hdGguRSwgbikgKiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgKiAobiArIDEgLyA2KSk7XG5cbiAgICAgICAgdmFyIHNlcmllc0Rlbm9tID0gbiArIDEgLyA0O1xuXG4gICAgICAgIHZhciBzZXJpZXNFeHBhbnNpb24gPVxuICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAxIC8gMTQ0IC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDIpIC1cbiAgICAgICAgICAgIDEgLyAxMjk2MCAvIE1hdGgucG93KHNlcmllc0Rlbm9tLCAzKSAtXG4gICAgICAgICAgICAyNTcgLyAyMDczNjAgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNCkgLVxuICAgICAgICAgICAgNTIgLyAyNjEyNzM2IC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDUpICtcbiAgICAgICAgICAgIDU3NDExNzMgLyA5NDA1ODQ5NjAwIC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDYpICtcbiAgICAgICAgICAgIDM3NTI5IC8gMTg4MTE2OTkyMDAgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNyk7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0NvZWZmaWNpZW50ICogc2VyaWVzRXhwYW5zaW9uO1xuICAgIH1cbn1cblxuLy8gRGVmaW5lIHNlcmllcyBjb2VmZmljaWVudHNcbnZhciBDT0VGRklDSUVOVFMgPSBbXG4gICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MiwgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LCAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAgIDE0LjEzNjA5Nzk3NDc0MTc0NzE3NCwgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCwgLTAuOTgzNzQ0NzUzMDQ4Nzk1NjQ2NzdlLTQsXG4gICAgMC4xNTgwODg3MDMyMjQ5MTI0ODg4NGUtMywgLTAuMjEwMjY0NDQxNzI0MTA0ODgzMTllLTMsXG4gICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyZS0zLCAtMC4xNjQzMTgxMDY1MzY3NjM4OTAyMmUtMyxcbiAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LCAtMC4yNjE5MDgzODQwMTU4MTQwODY3ZS00LFxuICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbl07XG5cbnZhciBnID0gNjA3IC8gMTI4O1xudmFyIExPR1NRUlQyUEkgPSBNYXRoLmxvZyhNYXRoLnNxcnQoMiAqIE1hdGguUEkpKTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsb2dhcml0aG0gb2YgdGhlIFtnYW1tYSBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2FtbWFfZnVuY3Rpb24pIG9mIGEgdmFsdWUgdXNpbmcgTGFuY3pvcycgYXBwcm94aW1hdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYXMgaW5wdXQgYW55IHJlYWwtdmFsdWUgbiBncmVhdGVyIHRoYW4gMC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciB2YWx1ZXMgb2YgbiB0b28gbGFyZ2UgZm9yIHRoZSBub3JtYWwgZ2FtbWEgZnVuY3Rpb24gKG4gPiAxNjUpLlxuICogVGhlIGNvZGUgaXMgYmFzZWQgb24gTGFuY3pvJ3MgR2FtbWEgYXBwcm94aW1hdGlvbiwgZGVmaW5lZCBbaGVyZV0oaHR0cDovL215LmZpdC5lZHUvfmdhYmRvL2dhbW1hLnR4dCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG4gQW55IHJlYWwgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGxvZ2FyaXRobSBvZiBnYW1tYSBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGdhbW1hbG4oNTAwKTsgLy8gMjYwNS4xMTU4NTAzNjE3MzM1XG4gKiBnYW1tYWxuKDIuNCk7IC8vIDAuMjE2ODU5MzIyNDQ4ODQwNDNcbiAqL1xuZnVuY3Rpb24gZ2FtbWFsbihuKSB7XG4gICAgLy8gUmV0dXJuIGluZmluaXR5IGlmIHZhbHVlIG5vdCBpbiBkb21haW5cbiAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuXG4gICAgLy8gRGVjcmVtZW50IG4sIGJlY2F1c2UgYXBwcm94aW1hdGlvbiBpcyBkZWZpbmVkIGZvciBuIC0gMVxuICAgIG4tLTtcblxuICAgIC8vIENyZWF0ZSBzZXJpZXMgYXBwcm94aW1hdGlvblxuICAgIHZhciBhID0gQ09FRkZJQ0lFTlRTWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICAgIGEgKz0gQ09FRkZJQ0lFTlRTW2ldIC8gKG4gKyBpKTtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gZyArIDAuNSArIG47XG5cbiAgICAvLyBSZXR1cm4gbmF0dXJhbCBsb2dhcml0aG0gb2YgZ2FtbWEobilcbiAgICByZXR1cm4gTE9HU1FSVDJQSSArIE1hdGgubG9nKGEpIC0gdG1wICsgKG4gKyAwLjUpICogTWF0aC5sb2codG1wKTtcbn1cblxuLyoqXG4gKiBUaGUgW0Jlcm5vdWxsaSBkaXN0cmlidXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybm91bGxpX2Rpc3RyaWJ1dGlvbilcbiAqIGlzIHRoZSBwcm9iYWJpbGl0eSBkaXNjcmV0ZVxuICogZGlzdHJpYnV0aW9uIG9mIGEgcmFuZG9tIHZhcmlhYmxlIHdoaWNoIHRha2VzIHZhbHVlIDEgd2l0aCBzdWNjZXNzXG4gKiBwcm9iYWJpbGl0eSBgcGAgYW5kIHZhbHVlIDAgd2l0aCBmYWlsdXJlXG4gKiBwcm9iYWJpbGl0eSBgcWAgPSAxIC0gYHBgLiBJdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIHJlcHJlc2VudCB0aGVcbiAqIHRvc3Mgb2YgYSBjb2luLCB3aGVyZSBcIjFcIiBpcyBkZWZpbmVkIHRvIG1lYW4gXCJoZWFkc1wiIGFuZCBcIjBcIiBpcyBkZWZpbmVkXG4gKiB0byBtZWFuIFwidGFpbHNcIiAob3IgdmljZSB2ZXJzYSkuIEl0IGlzXG4gKiBhIHNwZWNpYWwgY2FzZSBvZiBhIEJpbm9taWFsIERpc3RyaWJ1dGlvblxuICogd2hlcmUgYG5gID0gMS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcCBpbnB1dCB2YWx1ZSwgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZVxuICogQHJldHVybnMge251bWJlcltdfSB2YWx1ZXMgb2YgYmVybm91bGxpIGRpc3RyaWJ1dGlvbiBhdCB0aGlzIHBvaW50XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcCBpcyBvdXRzaWRlIDAgYW5kIDFcbiAqIEBleGFtcGxlXG4gKiBiZXJub3VsbGlEaXN0cmlidXRpb24oMC4zKTsgLy8gPT4gWzAuNywgMC4zXVxuICovXG5mdW5jdGlvbiBiZXJub3VsbGlEaXN0cmlidXRpb24ocCkgLyo6IG51bWJlcltdICovIHtcbiAgICAvLyBDaGVjayB0aGF0IGBwYCBpcyBhIHZhbGlkIHByb2JhYmlsaXR5ICgwIOKJpCBwIOKJpCAxKVxuICAgIGlmIChwIDwgMCB8fCBwID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcImJlcm5vdWxsaURpc3RyaWJ1dGlvbiByZXF1aXJlcyBwcm9iYWJpbGl0eSB0byBiZSBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWzEgLSBwLCBwXTtcbn1cblxuLyoqXG4gKiBUaGUgW0Jpbm9taWFsIERpc3RyaWJ1dGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaW5vbWlhbF9kaXN0cmlidXRpb24pIGlzIHRoZSBkaXNjcmV0ZSBwcm9iYWJpbGl0eVxuICogZGlzdHJpYnV0aW9uIG9mIHRoZSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGluIGEgc2VxdWVuY2Ugb2YgbiBpbmRlcGVuZGVudCB5ZXMvbm8gZXhwZXJpbWVudHMsIGVhY2ggb2Ygd2hpY2ggeWllbGRzXG4gKiBzdWNjZXNzIHdpdGggcHJvYmFiaWxpdHkgYHByb2JhYmlsaXR5YC4gU3VjaCBhIHN1Y2Nlc3MvZmFpbHVyZSBleHBlcmltZW50IGlzIGFsc28gY2FsbGVkIGEgQmVybm91bGxpIGV4cGVyaW1lbnQgb3JcbiAqIEJlcm5vdWxsaSB0cmlhbDsgd2hlbiB0cmlhbHMgPSAxLCB0aGUgQmlub21pYWwgRGlzdHJpYnV0aW9uIGlzIGEgQmVybm91bGxpIERpc3RyaWJ1dGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdHJpYWxzIG51bWJlciBvZiB0cmlhbHMgdG8gc2ltdWxhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9iYWJpbGl0eVxuICogQHJldHVybnMge251bWJlcltdfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gYmlub21pYWxEaXN0cmlidXRpb24odHJpYWxzLCBwcm9iYWJpbGl0eSkgLyo6ID9udW1iZXJbXSAqLyB7XG4gICAgLy8gQ2hlY2sgdGhhdCBgcGAgaXMgYSB2YWxpZCBwcm9iYWJpbGl0eSAoMCDiiaQgcCDiiaQgMSksXG4gICAgLy8gdGhhdCBgbmAgaXMgYW4gaW50ZWdlciwgc3RyaWN0bHkgcG9zaXRpdmUuXG4gICAgaWYgKHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEgfHwgdHJpYWxzIDw9IDAgfHwgdHJpYWxzICUgMSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFdlIGluaXRpYWxpemUgYHhgLCB0aGUgcmFuZG9tIHZhcmlhYmxlLCBhbmQgYGFjY3VtdWxhdG9yYCwgYW4gYWNjdW11bGF0b3JcbiAgICAvLyBmb3IgdGhlIGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uIGZ1bmN0aW9uIHRvIDAuIGBkaXN0cmlidXRpb25fZnVuY3Rpb25zYFxuICAgIC8vIGlzIHRoZSBvYmplY3Qgd2UnbGwgcmV0dXJuIHdpdGggdGhlIGBwcm9iYWJpbGl0eV9vZl94YCBhbmQgdGhlXG4gICAgLy8gYGN1bXVsYXRpdmVQcm9iYWJpbGl0eV9vZl94YCwgYXMgd2VsbCBhcyB0aGUgY2FsY3VsYXRlZCBtZWFuICZcbiAgICAvLyB2YXJpYW5jZS4gV2UgaXRlcmF0ZSB1bnRpbCB0aGUgYGN1bXVsYXRpdmVQcm9iYWJpbGl0eV9vZl94YCBpc1xuICAgIC8vIHdpdGhpbiBgZXBzaWxvbmAgb2YgMS4wLlxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgY3VtdWxhdGl2ZVByb2JhYmlsaXR5ID0gMDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICB2YXIgYmlub21pYWxDb2VmZmljaWVudCA9IDE7XG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBpdGVyYXRlcyB0aHJvdWdoIGVhY2ggcG90ZW50aWFsIG91dGNvbWUsXG4gICAgLy8gdW50aWwgdGhlIGBjdW11bGF0aXZlUHJvYmFiaWxpdHlgIGlzIHZlcnkgY2xvc2UgdG8gMSwgYXRcbiAgICAvLyB3aGljaCBwb2ludCB3ZSd2ZSBkZWZpbmVkIHRoZSB2YXN0IG1ham9yaXR5IG9mIG91dGNvbWVzXG4gICAgZG8ge1xuICAgICAgICAvLyBhIFtwcm9iYWJpbGl0eSBtYXNzIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9iYWJpbGl0eV9tYXNzX2Z1bmN0aW9uKVxuICAgICAgICBjZWxsc1t4XSA9XG4gICAgICAgICAgICBiaW5vbWlhbENvZWZmaWNpZW50ICpcbiAgICAgICAgICAgIE1hdGgucG93KHByb2JhYmlsaXR5LCB4KSAqXG4gICAgICAgICAgICBNYXRoLnBvdygxIC0gcHJvYmFiaWxpdHksIHRyaWFscyAtIHgpO1xuICAgICAgICBjdW11bGF0aXZlUHJvYmFiaWxpdHkgKz0gY2VsbHNbeF07XG4gICAgICAgIHgrKztcbiAgICAgICAgYmlub21pYWxDb2VmZmljaWVudCA9IChiaW5vbWlhbENvZWZmaWNpZW50ICogKHRyaWFscyAtIHggKyAxKSkgLyB4O1xuICAgICAgICAvLyB3aGVuIHRoZSBjdW11bGF0aXZlUHJvYmFiaWxpdHkgaXMgbmVhcmx5IDEsIHdlJ3ZlIGNhbGN1bGF0ZWRcbiAgICAgICAgLy8gdGhlIHVzZWZ1bCByYW5nZSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxuICAgIH0gd2hpbGUgKGN1bXVsYXRpdmVQcm9iYWJpbGl0eSA8IDEgLSBlcHNpbG9uKTtcblxuICAgIHJldHVybiBjZWxscztcbn1cblxuLyoqXG4gKiBUaGUgW1BvaXNzb24gRGlzdHJpYnV0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvaXNzb25fZGlzdHJpYnV0aW9uKVxuICogaXMgYSBkaXNjcmV0ZSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24gdGhhdCBleHByZXNzZXMgdGhlIHByb2JhYmlsaXR5XG4gKiBvZiBhIGdpdmVuIG51bWJlciBvZiBldmVudHMgb2NjdXJyaW5nIGluIGEgZml4ZWQgaW50ZXJ2YWwgb2YgdGltZVxuICogYW5kL29yIHNwYWNlIGlmIHRoZXNlIGV2ZW50cyBvY2N1ciB3aXRoIGEga25vd24gYXZlcmFnZSByYXRlIGFuZFxuICogaW5kZXBlbmRlbnRseSBvZiB0aGUgdGltZSBzaW5jZSB0aGUgbGFzdCBldmVudC5cbiAqXG4gKiBUaGUgUG9pc3NvbiBEaXN0cmlidXRpb24gaXMgY2hhcmFjdGVyaXplZCBieSB0aGUgc3RyaWN0bHkgcG9zaXRpdmVcbiAqIG1lYW4gYXJyaXZhbCBvciBvY2N1cnJlbmNlIHJhdGUsIGDOu2AuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxhbWJkYSBsb2NhdGlvbiBwb2lzc29uIGRpc3RyaWJ1dGlvblxuICogQHJldHVybnMge251bWJlcltdfSB2YWx1ZXMgb2YgcG9pc3NvbiBkaXN0cmlidXRpb24gYXQgdGhhdCBwb2ludFxuICovXG5mdW5jdGlvbiBwb2lzc29uRGlzdHJpYnV0aW9uKGxhbWJkYSkgLyo6ID9udW1iZXJbXSAqLyB7XG4gICAgLy8gQ2hlY2sgdGhhdCBsYW1iZGEgaXMgc3RyaWN0bHkgcG9zaXRpdmVcbiAgICBpZiAobGFtYmRhIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBvdXIgY3VycmVudCBwbGFjZSBpbiB0aGUgZGlzdHJpYnV0aW9uXG4gICAgdmFyIHggPSAwO1xuICAgIC8vIGFuZCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IGN1bXVsYXRpdmUgcHJvYmFiaWxpdHksIGluXG4gICAgLy8gb3JkZXIgdG8ga25vdyB3aGVuIHRvIHN0b3AgY2FsY3VsYXRpbmcgY2hhbmNlcy5cbiAgICB2YXIgY3VtdWxhdGl2ZVByb2JhYmlsaXR5ID0gMDtcbiAgICAvLyB0aGUgY2FsY3VsYXRlZCBjZWxscyB0byBiZSByZXR1cm5lZFxuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIHZhciBmYWN0b3JpYWxYID0gMTtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGl0ZXJhdGVzIHRocm91Z2ggZWFjaCBwb3RlbnRpYWwgb3V0Y29tZSxcbiAgICAvLyB1bnRpbCB0aGUgYGN1bXVsYXRpdmVQcm9iYWJpbGl0eWAgaXMgdmVyeSBjbG9zZSB0byAxLCBhdFxuICAgIC8vIHdoaWNoIHBvaW50IHdlJ3ZlIGRlZmluZWQgdGhlIHZhc3QgbWFqb3JpdHkgb2Ygb3V0Y29tZXNcbiAgICBkbyB7XG4gICAgICAgIC8vIGEgW3Byb2JhYmlsaXR5IG1hc3MgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JhYmlsaXR5X21hc3NfZnVuY3Rpb24pXG4gICAgICAgIGNlbGxzW3hdID0gKE1hdGguZXhwKC1sYW1iZGEpICogTWF0aC5wb3cobGFtYmRhLCB4KSkgLyBmYWN0b3JpYWxYO1xuICAgICAgICBjdW11bGF0aXZlUHJvYmFiaWxpdHkgKz0gY2VsbHNbeF07XG4gICAgICAgIHgrKztcbiAgICAgICAgZmFjdG9yaWFsWCAqPSB4O1xuICAgICAgICAvLyB3aGVuIHRoZSBjdW11bGF0aXZlUHJvYmFiaWxpdHkgaXMgbmVhcmx5IDEsIHdlJ3ZlIGNhbGN1bGF0ZWRcbiAgICAgICAgLy8gdGhlIHVzZWZ1bCByYW5nZSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxuICAgIH0gd2hpbGUgKGN1bXVsYXRpdmVQcm9iYWJpbGl0eSA8IDEgLSBlcHNpbG9uKTtcblxuICAgIHJldHVybiBjZWxscztcbn1cblxuLyoqXG4gKiAqKlBlcmNlbnRhZ2UgUG9pbnRzIG9mIHRoZSDPhzIgKENoaS1TcXVhcmVkKSBEaXN0cmlidXRpb24qKlxuICpcbiAqIFRoZSBbz4cyIChDaGktU3F1YXJlZCkgRGlzdHJpYnV0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoaS1zcXVhcmVkX2Rpc3RyaWJ1dGlvbikgaXMgdXNlZCBpbiB0aGUgY29tbW9uXG4gKiBjaGktc3F1YXJlZCB0ZXN0cyBmb3IgZ29vZG5lc3Mgb2YgZml0IG9mIGFuIG9ic2VydmVkIGRpc3RyaWJ1dGlvbiB0byBhIHRoZW9yZXRpY2FsIG9uZSwgdGhlIGluZGVwZW5kZW5jZSBvZiB0d29cbiAqIGNyaXRlcmlhIG9mIGNsYXNzaWZpY2F0aW9uIG9mIHF1YWxpdGF0aXZlIGRhdGEsIGFuZCBpbiBjb25maWRlbmNlIGludGVydmFsIGVzdGltYXRpb24gZm9yIGEgcG9wdWxhdGlvbiBzdGFuZGFyZFxuICogZGV2aWF0aW9uIG9mIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBmcm9tIGEgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbi5cbiAqXG4gKiBWYWx1ZXMgZnJvbSBBcHBlbmRpeCAxLCBUYWJsZSBJSUkgb2YgV2lsbGlhbSBXLiBIaW5lcyAmIERvdWdsYXMgQy4gTW9udGdvbWVyeSwgXCJQcm9iYWJpbGl0eSBhbmQgU3RhdGlzdGljcyBpblxuICogRW5naW5lZXJpbmcgYW5kIE1hbmFnZW1lbnQgU2NpZW5jZVwiLCBXaWxleSAoMTk4MCkuXG4gKi9cbnZhciBjaGlTcXVhcmVkRGlzdHJpYnV0aW9uVGFibGUgPSB7XG4gICAgMToge1xuICAgICAgICAwLjk5NTogMCxcbiAgICAgICAgMC45OTogMCxcbiAgICAgICAgMC45NzU6IDAsXG4gICAgICAgIDAuOTU6IDAsXG4gICAgICAgIDAuOTogMC4wMixcbiAgICAgICAgMC41OiAwLjQ1LFxuICAgICAgICAwLjE6IDIuNzEsXG4gICAgICAgIDAuMDU6IDMuODQsXG4gICAgICAgIDAuMDI1OiA1LjAyLFxuICAgICAgICAwLjAxOiA2LjYzLFxuICAgICAgICAwLjAwNTogNy44OFxuICAgIH0sXG4gICAgMjoge1xuICAgICAgICAwLjk5NTogMC4wMSxcbiAgICAgICAgMC45OTogMC4wMixcbiAgICAgICAgMC45NzU6IDAuMDUsXG4gICAgICAgIDAuOTU6IDAuMSxcbiAgICAgICAgMC45OiAwLjIxLFxuICAgICAgICAwLjU6IDEuMzksXG4gICAgICAgIDAuMTogNC42MSxcbiAgICAgICAgMC4wNTogNS45OSxcbiAgICAgICAgMC4wMjU6IDcuMzgsXG4gICAgICAgIDAuMDE6IDkuMjEsXG4gICAgICAgIDAuMDA1OiAxMC42XG4gICAgfSxcbiAgICAzOiB7XG4gICAgICAgIDAuOTk1OiAwLjA3LFxuICAgICAgICAwLjk5OiAwLjExLFxuICAgICAgICAwLjk3NTogMC4yMixcbiAgICAgICAgMC45NTogMC4zNSxcbiAgICAgICAgMC45OiAwLjU4LFxuICAgICAgICAwLjU6IDIuMzcsXG4gICAgICAgIDAuMTogNi4yNSxcbiAgICAgICAgMC4wNTogNy44MSxcbiAgICAgICAgMC4wMjU6IDkuMzUsXG4gICAgICAgIDAuMDE6IDExLjM0LFxuICAgICAgICAwLjAwNTogMTIuODRcbiAgICB9LFxuICAgIDQ6IHtcbiAgICAgICAgMC45OTU6IDAuMjEsXG4gICAgICAgIDAuOTk6IDAuMyxcbiAgICAgICAgMC45NzU6IDAuNDgsXG4gICAgICAgIDAuOTU6IDAuNzEsXG4gICAgICAgIDAuOTogMS4wNixcbiAgICAgICAgMC41OiAzLjM2LFxuICAgICAgICAwLjE6IDcuNzgsXG4gICAgICAgIDAuMDU6IDkuNDksXG4gICAgICAgIDAuMDI1OiAxMS4xNCxcbiAgICAgICAgMC4wMTogMTMuMjgsXG4gICAgICAgIDAuMDA1OiAxNC44NlxuICAgIH0sXG4gICAgNToge1xuICAgICAgICAwLjk5NTogMC40MSxcbiAgICAgICAgMC45OTogMC41NSxcbiAgICAgICAgMC45NzU6IDAuODMsXG4gICAgICAgIDAuOTU6IDEuMTUsXG4gICAgICAgIDAuOTogMS42MSxcbiAgICAgICAgMC41OiA0LjM1LFxuICAgICAgICAwLjE6IDkuMjQsXG4gICAgICAgIDAuMDU6IDExLjA3LFxuICAgICAgICAwLjAyNTogMTIuODMsXG4gICAgICAgIDAuMDE6IDE1LjA5LFxuICAgICAgICAwLjAwNTogMTYuNzVcbiAgICB9LFxuICAgIDY6IHtcbiAgICAgICAgMC45OTU6IDAuNjgsXG4gICAgICAgIDAuOTk6IDAuODcsXG4gICAgICAgIDAuOTc1OiAxLjI0LFxuICAgICAgICAwLjk1OiAxLjY0LFxuICAgICAgICAwLjk6IDIuMixcbiAgICAgICAgMC41OiA1LjM1LFxuICAgICAgICAwLjE6IDEwLjY1LFxuICAgICAgICAwLjA1OiAxMi41OSxcbiAgICAgICAgMC4wMjU6IDE0LjQ1LFxuICAgICAgICAwLjAxOiAxNi44MSxcbiAgICAgICAgMC4wMDU6IDE4LjU1XG4gICAgfSxcbiAgICA3OiB7XG4gICAgICAgIDAuOTk1OiAwLjk5LFxuICAgICAgICAwLjk5OiAxLjI1LFxuICAgICAgICAwLjk3NTogMS42OSxcbiAgICAgICAgMC45NTogMi4xNyxcbiAgICAgICAgMC45OiAyLjgzLFxuICAgICAgICAwLjU6IDYuMzUsXG4gICAgICAgIDAuMTogMTIuMDIsXG4gICAgICAgIDAuMDU6IDE0LjA3LFxuICAgICAgICAwLjAyNTogMTYuMDEsXG4gICAgICAgIDAuMDE6IDE4LjQ4LFxuICAgICAgICAwLjAwNTogMjAuMjhcbiAgICB9LFxuICAgIDg6IHtcbiAgICAgICAgMC45OTU6IDEuMzQsXG4gICAgICAgIDAuOTk6IDEuNjUsXG4gICAgICAgIDAuOTc1OiAyLjE4LFxuICAgICAgICAwLjk1OiAyLjczLFxuICAgICAgICAwLjk6IDMuNDksXG4gICAgICAgIDAuNTogNy4zNCxcbiAgICAgICAgMC4xOiAxMy4zNixcbiAgICAgICAgMC4wNTogMTUuNTEsXG4gICAgICAgIDAuMDI1OiAxNy41MyxcbiAgICAgICAgMC4wMTogMjAuMDksXG4gICAgICAgIDAuMDA1OiAyMS45NlxuICAgIH0sXG4gICAgOToge1xuICAgICAgICAwLjk5NTogMS43MyxcbiAgICAgICAgMC45OTogMi4wOSxcbiAgICAgICAgMC45NzU6IDIuNyxcbiAgICAgICAgMC45NTogMy4zMyxcbiAgICAgICAgMC45OiA0LjE3LFxuICAgICAgICAwLjU6IDguMzQsXG4gICAgICAgIDAuMTogMTQuNjgsXG4gICAgICAgIDAuMDU6IDE2LjkyLFxuICAgICAgICAwLjAyNTogMTkuMDIsXG4gICAgICAgIDAuMDE6IDIxLjY3LFxuICAgICAgICAwLjAwNTogMjMuNTlcbiAgICB9LFxuICAgIDEwOiB7XG4gICAgICAgIDAuOTk1OiAyLjE2LFxuICAgICAgICAwLjk5OiAyLjU2LFxuICAgICAgICAwLjk3NTogMy4yNSxcbiAgICAgICAgMC45NTogMy45NCxcbiAgICAgICAgMC45OiA0Ljg3LFxuICAgICAgICAwLjU6IDkuMzQsXG4gICAgICAgIDAuMTogMTUuOTksXG4gICAgICAgIDAuMDU6IDE4LjMxLFxuICAgICAgICAwLjAyNTogMjAuNDgsXG4gICAgICAgIDAuMDE6IDIzLjIxLFxuICAgICAgICAwLjAwNTogMjUuMTlcbiAgICB9LFxuICAgIDExOiB7XG4gICAgICAgIDAuOTk1OiAyLjYsXG4gICAgICAgIDAuOTk6IDMuMDUsXG4gICAgICAgIDAuOTc1OiAzLjgyLFxuICAgICAgICAwLjk1OiA0LjU3LFxuICAgICAgICAwLjk6IDUuNTgsXG4gICAgICAgIDAuNTogMTAuMzQsXG4gICAgICAgIDAuMTogMTcuMjgsXG4gICAgICAgIDAuMDU6IDE5LjY4LFxuICAgICAgICAwLjAyNTogMjEuOTIsXG4gICAgICAgIDAuMDE6IDI0LjcyLFxuICAgICAgICAwLjAwNTogMjYuNzZcbiAgICB9LFxuICAgIDEyOiB7XG4gICAgICAgIDAuOTk1OiAzLjA3LFxuICAgICAgICAwLjk5OiAzLjU3LFxuICAgICAgICAwLjk3NTogNC40LFxuICAgICAgICAwLjk1OiA1LjIzLFxuICAgICAgICAwLjk6IDYuMyxcbiAgICAgICAgMC41OiAxMS4zNCxcbiAgICAgICAgMC4xOiAxOC41NSxcbiAgICAgICAgMC4wNTogMjEuMDMsXG4gICAgICAgIDAuMDI1OiAyMy4zNCxcbiAgICAgICAgMC4wMTogMjYuMjIsXG4gICAgICAgIDAuMDA1OiAyOC4zXG4gICAgfSxcbiAgICAxMzoge1xuICAgICAgICAwLjk5NTogMy41NyxcbiAgICAgICAgMC45OTogNC4xMSxcbiAgICAgICAgMC45NzU6IDUuMDEsXG4gICAgICAgIDAuOTU6IDUuODksXG4gICAgICAgIDAuOTogNy4wNCxcbiAgICAgICAgMC41OiAxMi4zNCxcbiAgICAgICAgMC4xOiAxOS44MSxcbiAgICAgICAgMC4wNTogMjIuMzYsXG4gICAgICAgIDAuMDI1OiAyNC43NCxcbiAgICAgICAgMC4wMTogMjcuNjksXG4gICAgICAgIDAuMDA1OiAyOS44MlxuICAgIH0sXG4gICAgMTQ6IHtcbiAgICAgICAgMC45OTU6IDQuMDcsXG4gICAgICAgIDAuOTk6IDQuNjYsXG4gICAgICAgIDAuOTc1OiA1LjYzLFxuICAgICAgICAwLjk1OiA2LjU3LFxuICAgICAgICAwLjk6IDcuNzksXG4gICAgICAgIDAuNTogMTMuMzQsXG4gICAgICAgIDAuMTogMjEuMDYsXG4gICAgICAgIDAuMDU6IDIzLjY4LFxuICAgICAgICAwLjAyNTogMjYuMTIsXG4gICAgICAgIDAuMDE6IDI5LjE0LFxuICAgICAgICAwLjAwNTogMzEuMzJcbiAgICB9LFxuICAgIDE1OiB7XG4gICAgICAgIDAuOTk1OiA0LjYsXG4gICAgICAgIDAuOTk6IDUuMjMsXG4gICAgICAgIDAuOTc1OiA2LjI3LFxuICAgICAgICAwLjk1OiA3LjI2LFxuICAgICAgICAwLjk6IDguNTUsXG4gICAgICAgIDAuNTogMTQuMzQsXG4gICAgICAgIDAuMTogMjIuMzEsXG4gICAgICAgIDAuMDU6IDI1LFxuICAgICAgICAwLjAyNTogMjcuNDksXG4gICAgICAgIDAuMDE6IDMwLjU4LFxuICAgICAgICAwLjAwNTogMzIuOFxuICAgIH0sXG4gICAgMTY6IHtcbiAgICAgICAgMC45OTU6IDUuMTQsXG4gICAgICAgIDAuOTk6IDUuODEsXG4gICAgICAgIDAuOTc1OiA2LjkxLFxuICAgICAgICAwLjk1OiA3Ljk2LFxuICAgICAgICAwLjk6IDkuMzEsXG4gICAgICAgIDAuNTogMTUuMzQsXG4gICAgICAgIDAuMTogMjMuNTQsXG4gICAgICAgIDAuMDU6IDI2LjMsXG4gICAgICAgIDAuMDI1OiAyOC44NSxcbiAgICAgICAgMC4wMTogMzIsXG4gICAgICAgIDAuMDA1OiAzNC4yN1xuICAgIH0sXG4gICAgMTc6IHtcbiAgICAgICAgMC45OTU6IDUuNyxcbiAgICAgICAgMC45OTogNi40MSxcbiAgICAgICAgMC45NzU6IDcuNTYsXG4gICAgICAgIDAuOTU6IDguNjcsXG4gICAgICAgIDAuOTogMTAuMDksXG4gICAgICAgIDAuNTogMTYuMzQsXG4gICAgICAgIDAuMTogMjQuNzcsXG4gICAgICAgIDAuMDU6IDI3LjU5LFxuICAgICAgICAwLjAyNTogMzAuMTksXG4gICAgICAgIDAuMDE6IDMzLjQxLFxuICAgICAgICAwLjAwNTogMzUuNzJcbiAgICB9LFxuICAgIDE4OiB7XG4gICAgICAgIDAuOTk1OiA2LjI2LFxuICAgICAgICAwLjk5OiA3LjAxLFxuICAgICAgICAwLjk3NTogOC4yMyxcbiAgICAgICAgMC45NTogOS4zOSxcbiAgICAgICAgMC45OiAxMC44NyxcbiAgICAgICAgMC41OiAxNy4zNCxcbiAgICAgICAgMC4xOiAyNS45OSxcbiAgICAgICAgMC4wNTogMjguODcsXG4gICAgICAgIDAuMDI1OiAzMS41MyxcbiAgICAgICAgMC4wMTogMzQuODEsXG4gICAgICAgIDAuMDA1OiAzNy4xNlxuICAgIH0sXG4gICAgMTk6IHtcbiAgICAgICAgMC45OTU6IDYuODQsXG4gICAgICAgIDAuOTk6IDcuNjMsXG4gICAgICAgIDAuOTc1OiA4LjkxLFxuICAgICAgICAwLjk1OiAxMC4xMixcbiAgICAgICAgMC45OiAxMS42NSxcbiAgICAgICAgMC41OiAxOC4zNCxcbiAgICAgICAgMC4xOiAyNy4yLFxuICAgICAgICAwLjA1OiAzMC4xNCxcbiAgICAgICAgMC4wMjU6IDMyLjg1LFxuICAgICAgICAwLjAxOiAzNi4xOSxcbiAgICAgICAgMC4wMDU6IDM4LjU4XG4gICAgfSxcbiAgICAyMDoge1xuICAgICAgICAwLjk5NTogNy40MyxcbiAgICAgICAgMC45OTogOC4yNixcbiAgICAgICAgMC45NzU6IDkuNTksXG4gICAgICAgIDAuOTU6IDEwLjg1LFxuICAgICAgICAwLjk6IDEyLjQ0LFxuICAgICAgICAwLjU6IDE5LjM0LFxuICAgICAgICAwLjE6IDI4LjQxLFxuICAgICAgICAwLjA1OiAzMS40MSxcbiAgICAgICAgMC4wMjU6IDM0LjE3LFxuICAgICAgICAwLjAxOiAzNy41NyxcbiAgICAgICAgMC4wMDU6IDQwXG4gICAgfSxcbiAgICAyMToge1xuICAgICAgICAwLjk5NTogOC4wMyxcbiAgICAgICAgMC45OTogOC45LFxuICAgICAgICAwLjk3NTogMTAuMjgsXG4gICAgICAgIDAuOTU6IDExLjU5LFxuICAgICAgICAwLjk6IDEzLjI0LFxuICAgICAgICAwLjU6IDIwLjM0LFxuICAgICAgICAwLjE6IDI5LjYyLFxuICAgICAgICAwLjA1OiAzMi42NyxcbiAgICAgICAgMC4wMjU6IDM1LjQ4LFxuICAgICAgICAwLjAxOiAzOC45MyxcbiAgICAgICAgMC4wMDU6IDQxLjRcbiAgICB9LFxuICAgIDIyOiB7XG4gICAgICAgIDAuOTk1OiA4LjY0LFxuICAgICAgICAwLjk5OiA5LjU0LFxuICAgICAgICAwLjk3NTogMTAuOTgsXG4gICAgICAgIDAuOTU6IDEyLjM0LFxuICAgICAgICAwLjk6IDE0LjA0LFxuICAgICAgICAwLjU6IDIxLjM0LFxuICAgICAgICAwLjE6IDMwLjgxLFxuICAgICAgICAwLjA1OiAzMy45MixcbiAgICAgICAgMC4wMjU6IDM2Ljc4LFxuICAgICAgICAwLjAxOiA0MC4yOSxcbiAgICAgICAgMC4wMDU6IDQyLjhcbiAgICB9LFxuICAgIDIzOiB7XG4gICAgICAgIDAuOTk1OiA5LjI2LFxuICAgICAgICAwLjk5OiAxMC4yLFxuICAgICAgICAwLjk3NTogMTEuNjksXG4gICAgICAgIDAuOTU6IDEzLjA5LFxuICAgICAgICAwLjk6IDE0Ljg1LFxuICAgICAgICAwLjU6IDIyLjM0LFxuICAgICAgICAwLjE6IDMyLjAxLFxuICAgICAgICAwLjA1OiAzNS4xNyxcbiAgICAgICAgMC4wMjU6IDM4LjA4LFxuICAgICAgICAwLjAxOiA0MS42NCxcbiAgICAgICAgMC4wMDU6IDQ0LjE4XG4gICAgfSxcbiAgICAyNDoge1xuICAgICAgICAwLjk5NTogOS44OSxcbiAgICAgICAgMC45OTogMTAuODYsXG4gICAgICAgIDAuOTc1OiAxMi40LFxuICAgICAgICAwLjk1OiAxMy44NSxcbiAgICAgICAgMC45OiAxNS42NixcbiAgICAgICAgMC41OiAyMy4zNCxcbiAgICAgICAgMC4xOiAzMy4yLFxuICAgICAgICAwLjA1OiAzNi40MixcbiAgICAgICAgMC4wMjU6IDM5LjM2LFxuICAgICAgICAwLjAxOiA0Mi45OCxcbiAgICAgICAgMC4wMDU6IDQ1LjU2XG4gICAgfSxcbiAgICAyNToge1xuICAgICAgICAwLjk5NTogMTAuNTIsXG4gICAgICAgIDAuOTk6IDExLjUyLFxuICAgICAgICAwLjk3NTogMTMuMTIsXG4gICAgICAgIDAuOTU6IDE0LjYxLFxuICAgICAgICAwLjk6IDE2LjQ3LFxuICAgICAgICAwLjU6IDI0LjM0LFxuICAgICAgICAwLjE6IDM0LjI4LFxuICAgICAgICAwLjA1OiAzNy42NSxcbiAgICAgICAgMC4wMjU6IDQwLjY1LFxuICAgICAgICAwLjAxOiA0NC4zMSxcbiAgICAgICAgMC4wMDU6IDQ2LjkzXG4gICAgfSxcbiAgICAyNjoge1xuICAgICAgICAwLjk5NTogMTEuMTYsXG4gICAgICAgIDAuOTk6IDEyLjIsXG4gICAgICAgIDAuOTc1OiAxMy44NCxcbiAgICAgICAgMC45NTogMTUuMzgsXG4gICAgICAgIDAuOTogMTcuMjksXG4gICAgICAgIDAuNTogMjUuMzQsXG4gICAgICAgIDAuMTogMzUuNTYsXG4gICAgICAgIDAuMDU6IDM4Ljg5LFxuICAgICAgICAwLjAyNTogNDEuOTIsXG4gICAgICAgIDAuMDE6IDQ1LjY0LFxuICAgICAgICAwLjAwNTogNDguMjlcbiAgICB9LFxuICAgIDI3OiB7XG4gICAgICAgIDAuOTk1OiAxMS44MSxcbiAgICAgICAgMC45OTogMTIuODgsXG4gICAgICAgIDAuOTc1OiAxNC41NyxcbiAgICAgICAgMC45NTogMTYuMTUsXG4gICAgICAgIDAuOTogMTguMTEsXG4gICAgICAgIDAuNTogMjYuMzQsXG4gICAgICAgIDAuMTogMzYuNzQsXG4gICAgICAgIDAuMDU6IDQwLjExLFxuICAgICAgICAwLjAyNTogNDMuMTksXG4gICAgICAgIDAuMDE6IDQ2Ljk2LFxuICAgICAgICAwLjAwNTogNDkuNjVcbiAgICB9LFxuICAgIDI4OiB7XG4gICAgICAgIDAuOTk1OiAxMi40NixcbiAgICAgICAgMC45OTogMTMuNTcsXG4gICAgICAgIDAuOTc1OiAxNS4zMSxcbiAgICAgICAgMC45NTogMTYuOTMsXG4gICAgICAgIDAuOTogMTguOTQsXG4gICAgICAgIDAuNTogMjcuMzQsXG4gICAgICAgIDAuMTogMzcuOTIsXG4gICAgICAgIDAuMDU6IDQxLjM0LFxuICAgICAgICAwLjAyNTogNDQuNDYsXG4gICAgICAgIDAuMDE6IDQ4LjI4LFxuICAgICAgICAwLjAwNTogNTAuOTlcbiAgICB9LFxuICAgIDI5OiB7XG4gICAgICAgIDAuOTk1OiAxMy4xMixcbiAgICAgICAgMC45OTogMTQuMjYsXG4gICAgICAgIDAuOTc1OiAxNi4wNSxcbiAgICAgICAgMC45NTogMTcuNzEsXG4gICAgICAgIDAuOTogMTkuNzcsXG4gICAgICAgIDAuNTogMjguMzQsXG4gICAgICAgIDAuMTogMzkuMDksXG4gICAgICAgIDAuMDU6IDQyLjU2LFxuICAgICAgICAwLjAyNTogNDUuNzIsXG4gICAgICAgIDAuMDE6IDQ5LjU5LFxuICAgICAgICAwLjAwNTogNTIuMzRcbiAgICB9LFxuICAgIDMwOiB7XG4gICAgICAgIDAuOTk1OiAxMy43OSxcbiAgICAgICAgMC45OTogMTQuOTUsXG4gICAgICAgIDAuOTc1OiAxNi43OSxcbiAgICAgICAgMC45NTogMTguNDksXG4gICAgICAgIDAuOTogMjAuNixcbiAgICAgICAgMC41OiAyOS4zNCxcbiAgICAgICAgMC4xOiA0MC4yNixcbiAgICAgICAgMC4wNTogNDMuNzcsXG4gICAgICAgIDAuMDI1OiA0Ni45OCxcbiAgICAgICAgMC4wMTogNTAuODksXG4gICAgICAgIDAuMDA1OiA1My42N1xuICAgIH0sXG4gICAgNDA6IHtcbiAgICAgICAgMC45OTU6IDIwLjcxLFxuICAgICAgICAwLjk5OiAyMi4xNixcbiAgICAgICAgMC45NzU6IDI0LjQzLFxuICAgICAgICAwLjk1OiAyNi41MSxcbiAgICAgICAgMC45OiAyOS4wNSxcbiAgICAgICAgMC41OiAzOS4zNCxcbiAgICAgICAgMC4xOiA1MS44MSxcbiAgICAgICAgMC4wNTogNTUuNzYsXG4gICAgICAgIDAuMDI1OiA1OS4zNCxcbiAgICAgICAgMC4wMTogNjMuNjksXG4gICAgICAgIDAuMDA1OiA2Ni43N1xuICAgIH0sXG4gICAgNTA6IHtcbiAgICAgICAgMC45OTU6IDI3Ljk5LFxuICAgICAgICAwLjk5OiAyOS43MSxcbiAgICAgICAgMC45NzU6IDMyLjM2LFxuICAgICAgICAwLjk1OiAzNC43NixcbiAgICAgICAgMC45OiAzNy42OSxcbiAgICAgICAgMC41OiA0OS4zMyxcbiAgICAgICAgMC4xOiA2My4xNyxcbiAgICAgICAgMC4wNTogNjcuNSxcbiAgICAgICAgMC4wMjU6IDcxLjQyLFxuICAgICAgICAwLjAxOiA3Ni4xNSxcbiAgICAgICAgMC4wMDU6IDc5LjQ5XG4gICAgfSxcbiAgICA2MDoge1xuICAgICAgICAwLjk5NTogMzUuNTMsXG4gICAgICAgIDAuOTk6IDM3LjQ4LFxuICAgICAgICAwLjk3NTogNDAuNDgsXG4gICAgICAgIDAuOTU6IDQzLjE5LFxuICAgICAgICAwLjk6IDQ2LjQ2LFxuICAgICAgICAwLjU6IDU5LjMzLFxuICAgICAgICAwLjE6IDc0LjQsXG4gICAgICAgIDAuMDU6IDc5LjA4LFxuICAgICAgICAwLjAyNTogODMuMyxcbiAgICAgICAgMC4wMTogODguMzgsXG4gICAgICAgIDAuMDA1OiA5MS45NVxuICAgIH0sXG4gICAgNzA6IHtcbiAgICAgICAgMC45OTU6IDQzLjI4LFxuICAgICAgICAwLjk5OiA0NS40NCxcbiAgICAgICAgMC45NzU6IDQ4Ljc2LFxuICAgICAgICAwLjk1OiA1MS43NCxcbiAgICAgICAgMC45OiA1NS4zMyxcbiAgICAgICAgMC41OiA2OS4zMyxcbiAgICAgICAgMC4xOiA4NS41MyxcbiAgICAgICAgMC4wNTogOTAuNTMsXG4gICAgICAgIDAuMDI1OiA5NS4wMixcbiAgICAgICAgMC4wMTogMTAwLjQyLFxuICAgICAgICAwLjAwNTogMTA0LjIyXG4gICAgfSxcbiAgICA4MDoge1xuICAgICAgICAwLjk5NTogNTEuMTcsXG4gICAgICAgIDAuOTk6IDUzLjU0LFxuICAgICAgICAwLjk3NTogNTcuMTUsXG4gICAgICAgIDAuOTU6IDYwLjM5LFxuICAgICAgICAwLjk6IDY0LjI4LFxuICAgICAgICAwLjU6IDc5LjMzLFxuICAgICAgICAwLjE6IDk2LjU4LFxuICAgICAgICAwLjA1OiAxMDEuODgsXG4gICAgICAgIDAuMDI1OiAxMDYuNjMsXG4gICAgICAgIDAuMDE6IDExMi4zMyxcbiAgICAgICAgMC4wMDU6IDExNi4zMlxuICAgIH0sXG4gICAgOTA6IHtcbiAgICAgICAgMC45OTU6IDU5LjIsXG4gICAgICAgIDAuOTk6IDYxLjc1LFxuICAgICAgICAwLjk3NTogNjUuNjUsXG4gICAgICAgIDAuOTU6IDY5LjEzLFxuICAgICAgICAwLjk6IDczLjI5LFxuICAgICAgICAwLjU6IDg5LjMzLFxuICAgICAgICAwLjE6IDEwNy41NyxcbiAgICAgICAgMC4wNTogMTEzLjE0LFxuICAgICAgICAwLjAyNTogMTE4LjE0LFxuICAgICAgICAwLjAxOiAxMjQuMTIsXG4gICAgICAgIDAuMDA1OiAxMjguM1xuICAgIH0sXG4gICAgMTAwOiB7XG4gICAgICAgIDAuOTk1OiA2Ny4zMyxcbiAgICAgICAgMC45OTogNzAuMDYsXG4gICAgICAgIDAuOTc1OiA3NC4yMixcbiAgICAgICAgMC45NTogNzcuOTMsXG4gICAgICAgIDAuOTogODIuMzYsXG4gICAgICAgIDAuNTogOTkuMzMsXG4gICAgICAgIDAuMTogMTE4LjUsXG4gICAgICAgIDAuMDU6IDEyNC4zNCxcbiAgICAgICAgMC4wMjU6IDEyOS41NixcbiAgICAgICAgMC4wMTogMTM1LjgxLFxuICAgICAgICAwLjAwNTogMTQwLjE3XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgW8+HMiAoQ2hpLVNxdWFyZWQpIEdvb2RuZXNzLW9mLUZpdCBUZXN0XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dvb2RuZXNzX29mX2ZpdCNQZWFyc29uLjI3c19jaGktc3F1YXJlZF90ZXN0KVxuICogdXNlcyBhIG1lYXN1cmUgb2YgZ29vZG5lc3Mgb2YgZml0IHdoaWNoIGlzIHRoZSBzdW0gb2YgZGlmZmVyZW5jZXMgYmV0d2VlbiBvYnNlcnZlZCBhbmQgZXhwZWN0ZWQgb3V0Y29tZSBmcmVxdWVuY2llc1xuICogKHRoYXQgaXMsIGNvdW50cyBvZiBvYnNlcnZhdGlvbnMpLCBlYWNoIHNxdWFyZWQgYW5kIGRpdmlkZWQgYnkgdGhlIG51bWJlciBvZiBvYnNlcnZhdGlvbnMgZXhwZWN0ZWQgZ2l2ZW4gdGhlXG4gKiBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLiBUaGUgcmVzdWx0aW5nIM+HMiBzdGF0aXN0aWMsIGBjaGlTcXVhcmVkYCwgY2FuIGJlIGNvbXBhcmVkIHRvIHRoZSBjaGktc3F1YXJlZCBkaXN0cmlidXRpb25cbiAqIHRvIGRldGVybWluZSB0aGUgZ29vZG5lc3Mgb2YgZml0LiBJbiBvcmRlciB0byBkZXRlcm1pbmUgdGhlIGRlZ3JlZXMgb2YgZnJlZWRvbSBvZiB0aGUgY2hpLXNxdWFyZWQgZGlzdHJpYnV0aW9uLCBvbmVcbiAqIHRha2VzIHRoZSB0b3RhbCBudW1iZXIgb2Ygb2JzZXJ2ZWQgZnJlcXVlbmNpZXMgYW5kIHN1YnRyYWN0cyB0aGUgbnVtYmVyIG9mIGVzdGltYXRlZCBwYXJhbWV0ZXJzLiBUaGUgdGVzdCBzdGF0aXN0aWNcbiAqIGZvbGxvd3MsIGFwcHJveGltYXRlbHksIGEgY2hpLXNxdWFyZSBkaXN0cmlidXRpb24gd2l0aCAoayDiiJIgYykgZGVncmVlcyBvZiBmcmVlZG9tIHdoZXJlIGBrYCBpcyB0aGUgbnVtYmVyIG9mIG5vbi1lbXB0eVxuICogY2VsbHMgYW5kIGBjYCBpcyB0aGUgbnVtYmVyIG9mIGVzdGltYXRlZCBwYXJhbWV0ZXJzIGZvciB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzdHJpYnV0aW9uVHlwZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBvaW50IGluIGEgZGlzdHJpYnV0aW9uOlxuICogZm9yIGluc3RhbmNlLCBiaW5vbWlhbCwgYmVybm91bGxpLCBvciBwb2lzc29uXG4gKiBAcGFyYW0ge251bWJlcn0gc2lnbmlmaWNhbmNlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjaGkgc3F1YXJlZCBnb29kbmVzcyBvZiBmaXRcbiAqIEBleGFtcGxlXG4gKiAvLyBEYXRhIGZyb20gUG9pc3NvbiBnb29kbmVzcy1vZi1maXQgZXhhbXBsZSAxMC0xOSBpbiBXaWxsaWFtIFcuIEhpbmVzICYgRG91Z2xhcyBDLiBNb250Z29tZXJ5LFxuICogLy8gXCJQcm9iYWJpbGl0eSBhbmQgU3RhdGlzdGljcyBpbiBFbmdpbmVlcmluZyBhbmQgTWFuYWdlbWVudCBTY2llbmNlXCIsIFdpbGV5ICgxOTgwKS5cbiAqIHZhciBkYXRhMTAxOSA9IFtcbiAqICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICogICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gKiAgICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAqICAgICAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLFxuICogICAgIDMsIDMsIDMsIDNcbiAqIF07XG4gKiBzcy5jaGlTcXVhcmVkR29vZG5lc3NPZkZpdChkYXRhMTAxOSwgc3MucG9pc3NvbkRpc3RyaWJ1dGlvbiwgMC4wNSk7IC8vPSBmYWxzZVxuICovXG5mdW5jdGlvbiBjaGlTcXVhcmVkR29vZG5lc3NPZkZpdChkYXRhLCBkaXN0cmlidXRpb25UeXBlLCBzaWduaWZpY2FuY2UpIHtcbiAgICAvLyBFc3RpbWF0ZSBmcm9tIHRoZSBzYW1wbGUgZGF0YSwgYSB3ZWlnaHRlZCBtZWFuLlxuICAgIHZhciBpbnB1dE1lYW4gPSBtZWFuKGRhdGEpO1xuICAgIC8vIENhbGN1bGF0ZWQgdmFsdWUgb2YgdGhlIM+HMiBzdGF0aXN0aWMuXG4gICAgdmFyIGNoaVNxdWFyZWQgPSAwO1xuICAgIC8vIE51bWJlciBvZiBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uIHBhcmFtZXRlcnMgZXN0aW1hdGVkLCBleHBlY3RlZCB0byBiZSBzdXBwbGllZCBpbiB0aGUgZGlzdHJpYnV0aW9uIHRlc3QuXG4gICAgLy8gTG9zZSBvbmUgZGVncmVlIG9mIGZyZWVkb20gZm9yIGVzdGltYXRpbmcgYGxhbWJkYWAgZnJvbSB0aGUgc2FtcGxlIGRhdGEuXG4gICAgdmFyIGMgPSAxO1xuICAgIC8vIFRoZSBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLlxuICAgIC8vIEdlbmVyYXRlIHRoZSBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLlxuICAgIHZhciBoeXBvdGhlc2l6ZWREaXN0cmlidXRpb24gPSBkaXN0cmlidXRpb25UeXBlKGlucHV0TWVhbik7XG4gICAgdmFyIG9ic2VydmVkRnJlcXVlbmNpZXMgPSBbXTtcbiAgICB2YXIgZXhwZWN0ZWRGcmVxdWVuY2llcyA9IFtdO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IGhvbGRpbmcgYSBoaXN0b2dyYW0gZnJvbSB0aGUgc2FtcGxlIGRhdGEsIG9mXG4gICAgLy8gdGhlIGZvcm0gYHsgdmFsdWU6IG51bWJlck9mT2N1cnJlbmNlcyB9YFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAob2JzZXJ2ZWRGcmVxdWVuY2llc1tkYXRhW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlZEZyZXF1ZW5jaWVzW2RhdGFbaV1dID0gMDtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlZEZyZXF1ZW5jaWVzW2RhdGFbaV1dKys7XG4gICAgfVxuXG4gICAgLy8gVGhlIGhpc3RvZ3JhbSB3ZSBjcmVhdGVkIG1pZ2h0IGJlIHNwYXJzZSAtIHRoZXJlIG1pZ2h0IGJlIGdhcHNcbiAgICAvLyBiZXR3ZWVuIHZhbHVlcy4gU28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBoaXN0b2dyYW0sIG1ha2luZ1xuICAgIC8vIHN1cmUgdGhhdCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCwgZ2FwcyBoYXZlIDAgdmFsdWVzLlxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9ic2VydmVkRnJlcXVlbmNpZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICBpZiAob2JzZXJ2ZWRGcmVxdWVuY2llc1tpJDFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbaSQxXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gYXJyYXkgaG9sZGluZyBhIGhpc3RvZ3JhbSBvZiBleHBlY3RlZCBkYXRhIGdpdmVuIHRoZVxuICAgIC8vIHNhbXBsZSBzaXplIGFuZCBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLlxuICAgIGZvciAodmFyIGsgaW4gaHlwb3RoZXNpemVkRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChrIGluIG9ic2VydmVkRnJlcXVlbmNpZXMpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXNbK2tdID0gaHlwb3RoZXNpemVkRGlzdHJpYnV0aW9uW2tdICogZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JraW5nIGJhY2t3YXJkIHRocm91Z2ggdGhlIGV4cGVjdGVkIGZyZXF1ZW5jaWVzLCBjb2xsYXBzZSBjbGFzc2VzXG4gICAgLy8gaWYgbGVzcyB0aGFuIHRocmVlIG9ic2VydmF0aW9ucyBhcmUgZXhwZWN0ZWQgZm9yIGEgY2xhc3MuXG4gICAgLy8gVGhpcyB0cmFuc2Zvcm1hdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBvYnNlcnZlZCBmcmVxdWVuY2llcyBhcyB3ZWxsLlxuICAgIGZvciAodmFyIGskMSA9IGV4cGVjdGVkRnJlcXVlbmNpZXMubGVuZ3RoIC0gMTsgayQxID49IDA7IGskMS0tKSB7XG4gICAgICAgIGlmIChleHBlY3RlZEZyZXF1ZW5jaWVzW2skMV0gPCAzKSB7XG4gICAgICAgICAgICBleHBlY3RlZEZyZXF1ZW5jaWVzW2skMSAtIDFdICs9IGV4cGVjdGVkRnJlcXVlbmNpZXNbayQxXTtcbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXMucG9wKCk7XG5cbiAgICAgICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbayQxIC0gMV0gKz0gb2JzZXJ2ZWRGcmVxdWVuY2llc1trJDFdO1xuICAgICAgICAgICAgb2JzZXJ2ZWRGcmVxdWVuY2llcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3F1YXJlZCBkaWZmZXJlbmNlcyBiZXR3ZWVuIG9ic2VydmVkICYgZXhwZWN0ZWRcbiAgICAvLyBmcmVxdWVuY2llcywgYWNjdW11bGF0aW5nIHRoZSBgY2hpU3F1YXJlZGAgc3RhdGlzdGljLlxuICAgIGZvciAodmFyIGskMiA9IDA7IGskMiA8IG9ic2VydmVkRnJlcXVlbmNpZXMubGVuZ3RoOyBrJDIrKykge1xuICAgICAgICBjaGlTcXVhcmVkICs9XG4gICAgICAgICAgICBNYXRoLnBvdyhvYnNlcnZlZEZyZXF1ZW5jaWVzW2skMl0gLSBleHBlY3RlZEZyZXF1ZW5jaWVzW2skMl0sIDIpIC9cbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXNbayQyXTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVncmVlcyBvZiBmcmVlZG9tIGZvciB0aGlzIHRlc3QgYW5kIGxvb2sgaXQgdXAgaW4gdGhlXG4gICAgLy8gYGNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZWAgaW4gb3JkZXIgdG9cbiAgICAvLyBhY2NlcHQgb3IgcmVqZWN0IHRoZSBnb29kbmVzcy1vZi1maXQgb2YgdGhlIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgLy8gRGVncmVlcyBvZiBmcmVlZG9tLCBjYWxjdWxhdGVkIGFzIChudW1iZXIgb2YgY2xhc3MgaW50ZXJ2YWxzIC1cbiAgICAvLyBudW1iZXIgb2YgaHlwb3RoZXNpemVkIGRpc3RyaWJ1dGlvbiBwYXJhbWV0ZXJzIGVzdGltYXRlZCAtIDEpXG4gICAgdmFyIGRlZ3JlZXNPZkZyZWVkb20gPSBvYnNlcnZlZEZyZXF1ZW5jaWVzLmxlbmd0aCAtIGMgLSAxO1xuICAgIHJldHVybiAoXG4gICAgICAgIGNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZVtkZWdyZWVzT2ZGcmVlZG9tXVtzaWduaWZpY2FuY2VdIDwgY2hpU3F1YXJlZFxuICAgICk7XG59XG5cbnZhciBTUVJUXzJQSSQxID0gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKTtcblxuLyoqXG4gKiBbV2VsbC1rbm93biBrZXJuZWxzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LZXJuZWxfKHN0YXRpc3RpY3MpI0tlcm5lbF9mdW5jdGlvbnNfaW5fY29tbW9uX3VzZSlcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBrZXJuZWxzID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBnYXVzc2lhbiBrZXJuZWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnYXVzc2lhbjogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiB1ICogdSkgLyBTUVJUXzJQSSQxO1xuICAgIH1cbn07XG5cbi8qKlxuICogV2VsbCBrbm93biBiYW5kd2lkdGggc2VsZWN0aW9uIG1ldGhvZHNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBiYW5kd2lkdGhNZXRob2RzID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBbXCJub3JtYWwgcmVmZXJlbmNlIGRpc3RyaWJ1dGlvblwiXG4gICAgICogcnVsZS1vZi10aHVtYl0oaHR0cHM6Ly9zdGF0LmV0aHouY2gvUi1tYW51YWwvUi1kZXZlbC9saWJyYXJ5L01BU1MvaHRtbC9iYW5kd2lkdGgubnJkLmh0bWwpLFxuICAgICAqIGEgY29tbW9ubHkgdXNlZCB2ZXJzaW9uIG9mIFtTaWx2ZXJtYW4nc1xuICAgICAqIHJ1bGUtb2YtdGh1bWJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlcm5lbF9kZW5zaXR5X2VzdGltYXRpb24jQV9ydWxlLW9mLXRodW1iX2JhbmR3aWR0aF9lc3RpbWF0b3IpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbnJkOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcyA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpO1xuICAgICAgICB2YXIgaXFyID0gaW50ZXJxdWFydGlsZVJhbmdlKHgpO1xuICAgICAgICBpZiAodHlwZW9mIGlxciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcyA9IE1hdGgubWluKHMsIGlxciAvIDEuMzQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxLjA2ICogcyAqIE1hdGgucG93KHgubGVuZ3RoLCAtMC4yKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFtLZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LZXJuZWxfZGVuc2l0eV9lc3RpbWF0aW9uKVxuICogaXMgYSB1c2VmdWwgdG9vbCBmb3IsIGFtb25nIG90aGVyIHRoaW5ncywgZXN0aW1hdGluZyB0aGUgc2hhcGUgb2YgdGhlXG4gKiB1bmRlcmx5aW5nIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiBmcm9tIGEgc2FtcGxlLlxuICpcbiAqIEBuYW1lIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uXG4gKiBAcGFyYW0gWCBzYW1wbGUgdmFsdWVzXG4gKiBAcGFyYW0ga2VybmVsIFRoZSBrZXJuZWwgZnVuY3Rpb24gdG8gdXNlLiBJZiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpdCBzaG91bGQgcmV0dXJuIG5vbi1uZWdhdGl2ZSB2YWx1ZXMgYW5kIGludGVncmF0ZSB0byAxLiBEZWZhdWx0cyB0byAnZ2F1c3NpYW4nLlxuICogQHBhcmFtIGJhbmR3aWR0aE1ldGhvZCBUaGUgXCJiYW5kd2lkdGggc2VsZWN0aW9uXCIgbWV0aG9kIHRvIHVzZSwgb3IgYSBmaXhlZCBiYW5kd2lkdGggdmFsdWUuIERlZmF1bHRzIHRvIFwibnJkXCIsIHRoZSBjb21tb25seS11c2VkIFtcIm5vcm1hbCByZWZlcmVuY2UgZGlzdHJpYnV0aW9uXCIgcnVsZS1vZi10aHVtYl0oaHR0cHM6Ly9zdGF0LmV0aHouY2gvUi1tYW51YWwvUi1kZXZlbC9saWJyYXJ5L01BU1MvaHRtbC9iYW5kd2lkdGgubnJkLmh0bWwpLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBbiBlc3RpbWF0ZWQgW3Byb2JhYmlsaXR5IGRlbnNpdHkgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JhYmlsaXR5X2RlbnNpdHlfZnVuY3Rpb24pIGZvciB0aGUgZ2l2ZW4gc2FtcGxlLiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gcnVucyBpbiBgTyhYLmxlbmd0aClgLlxuICovXG5mdW5jdGlvbiBrZXJuZWxEZW5zaXR5RXN0aW1hdGlvbihYLCBrZXJuZWwsIGJhbmR3aWR0aE1ldGhvZCkge1xuICAgIHZhciBrZXJuZWxGbjtcbiAgICBpZiAoa2VybmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVsRm4gPSBrZXJuZWxzLmdhdXNzaWFuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtlcm5lbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIWtlcm5lbHNba2VybmVsXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGtlcm5lbCBcIicgKyBrZXJuZWwgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBrZXJuZWxGbiA9IGtlcm5lbHNba2VybmVsXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXJuZWxGbiA9IGtlcm5lbDtcbiAgICB9XG5cbiAgICB2YXIgYmFuZHdpZHRoO1xuICAgIGlmICh0eXBlb2YgYmFuZHdpZHRoTWV0aG9kID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGJhbmR3aWR0aCA9IGJhbmR3aWR0aE1ldGhvZHMubnJkKFgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJhbmR3aWR0aE1ldGhvZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIWJhbmR3aWR0aE1ldGhvZHNbYmFuZHdpZHRoTWV0aG9kXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmtub3duIGJhbmR3aWR0aCBtZXRob2QgXCInICsgYmFuZHdpZHRoTWV0aG9kICsgJ1wiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBiYW5kd2lkdGggPSBiYW5kd2lkdGhNZXRob2RzW2JhbmR3aWR0aE1ldGhvZF0oWCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmFuZHdpZHRoID0gYmFuZHdpZHRoTWV0aG9kO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgWC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGtlcm5lbEZuKCh4IC0gWFtpXSkgLyBiYW5kd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyBiYW5kd2lkdGggLyBYLmxlbmd0aDtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBbWi1TY29yZSwgb3IgU3RhbmRhcmQgU2NvcmVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfc2NvcmUpLlxuICpcbiAqIFRoZSBzdGFuZGFyZCBzY29yZSBpcyB0aGUgbnVtYmVyIG9mIHN0YW5kYXJkIGRldmlhdGlvbnMgYW4gb2JzZXJ2YXRpb25cbiAqIG9yIGRhdHVtIGlzIGFib3ZlIG9yIGJlbG93IHRoZSBtZWFuLiBUaHVzLCBhIHBvc2l0aXZlIHN0YW5kYXJkIHNjb3JlXG4gKiByZXByZXNlbnRzIGEgZGF0dW0gYWJvdmUgdGhlIG1lYW4sIHdoaWxlIGEgbmVnYXRpdmUgc3RhbmRhcmQgc2NvcmVcbiAqIHJlcHJlc2VudHMgYSBkYXR1bSBiZWxvdyB0aGUgbWVhbi4gSXQgaXMgYSBkaW1lbnNpb25sZXNzIHF1YW50aXR5XG4gKiBvYnRhaW5lZCBieSBzdWJ0cmFjdGluZyB0aGUgcG9wdWxhdGlvbiBtZWFuIGZyb20gYW4gaW5kaXZpZHVhbCByYXdcbiAqIHNjb3JlIGFuZCB0aGVuIGRpdmlkaW5nIHRoZSBkaWZmZXJlbmNlIGJ5IHRoZSBwb3B1bGF0aW9uIHN0YW5kYXJkXG4gKiBkZXZpYXRpb24uXG4gKlxuICogVGhlIHotc2NvcmUgaXMgb25seSBkZWZpbmVkIGlmIG9uZSBrbm93cyB0aGUgcG9wdWxhdGlvbiBwYXJhbWV0ZXJzO1xuICogaWYgb25lIG9ubHkgaGFzIGEgc2FtcGxlIHNldCwgdGhlbiB0aGUgYW5hbG9nb3VzIGNvbXB1dGF0aW9uIHdpdGhcbiAqIHNhbXBsZSBtZWFuIGFuZCBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIHlpZWxkcyB0aGVcbiAqIFN0dWRlbnQncyB0LXN0YXRpc3RpYy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFuZGFyZERldmlhdGlvblxuICogQHJldHVybiB7bnVtYmVyfSB6IHNjb3JlXG4gKiBAZXhhbXBsZVxuICogelNjb3JlKDc4LCA4MCwgNSk7IC8vID0+IC0wLjRcbiAqL1xuZnVuY3Rpb24gelNjb3JlKHgsIG1lYW4sIHN0YW5kYXJkRGV2aWF0aW9uKSB7XG4gICAgcmV0dXJuICh4IC0gbWVhbikgLyBzdGFuZGFyZERldmlhdGlvbjtcbn1cblxudmFyIFNRUlRfMlBJID0gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKTtcblxuZnVuY3Rpb24gY3VtdWxhdGl2ZURpc3RyaWJ1dGlvbih6KSB7XG4gICAgdmFyIHN1bSA9IHo7XG4gICAgdmFyIHRtcCA9IHo7XG5cbiAgICAvLyAxNSBpdGVyYXRpb25zIGFyZSBlbm91Z2ggZm9yIDQtZGlnaXQgcHJlY2lzaW9uXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICAgIHRtcCAqPSAoeiAqIHopIC8gKDIgKiBpICsgMSk7XG4gICAgICAgIHN1bSArPSB0bXA7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIE1hdGgucm91bmQoKDAuNSArIChzdW0gLyBTUVJUXzJQSSkgKiBNYXRoLmV4cCgoLXogKiB6KSAvIDIpKSAqIDFlNCkgL1xuICAgICAgICAxZTRcbiAgICApO1xufVxuXG4vKipcbiAqIEEgc3RhbmRhcmQgbm9ybWFsIHRhYmxlLCBhbHNvIGNhbGxlZCB0aGUgdW5pdCBub3JtYWwgdGFibGUgb3IgWiB0YWJsZSxcbiAqIGlzIGEgbWF0aGVtYXRpY2FsIHRhYmxlIGZvciB0aGUgdmFsdWVzIG9mIM6mIChwaGkpLCB3aGljaCBhcmUgdGhlIHZhbHVlcyBvZlxuICogdGhlIFtjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFsX2Rpc3RyaWJ1dGlvbiNDdW11bGF0aXZlX2Rpc3RyaWJ1dGlvbl9mdW5jdGlvbilcbiAqIG9mIHRoZSBub3JtYWwgZGlzdHJpYnV0aW9uLiBJdCBpcyB1c2VkIHRvIGZpbmQgdGhlIHByb2JhYmlsaXR5IHRoYXQgYVxuICogc3RhdGlzdGljIGlzIG9ic2VydmVkIGJlbG93LCBhYm92ZSwgb3IgYmV0d2VlbiB2YWx1ZXMgb24gdGhlIHN0YW5kYXJkXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uLCBhbmQgYnkgZXh0ZW5zaW9uLCBhbnkgbm9ybWFsIGRpc3RyaWJ1dGlvbi5cbiAqL1xudmFyIHN0YW5kYXJkTm9ybWFsVGFibGUgPSBbXTtcblxuZm9yICh2YXIgeiA9IDA7IHogPD0gMy4wOTsgeiArPSAwLjAxKSB7XG4gICAgc3RhbmRhcmROb3JtYWxUYWJsZS5wdXNoKGN1bXVsYXRpdmVEaXN0cmlidXRpb24oeikpO1xufVxuXG4vKipcbiAqICoqW0N1bXVsYXRpdmUgU3RhbmRhcmQgTm9ybWFsIFByb2JhYmlsaXR5XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0YW5kYXJkX25vcm1hbF90YWJsZSkqKlxuICpcbiAqIFNpbmNlIHByb2JhYmlsaXR5IHRhYmxlcyBjYW5ub3QgYmVcbiAqIHByaW50ZWQgZm9yIGV2ZXJ5IG5vcm1hbCBkaXN0cmlidXRpb24sIGFzIHRoZXJlIGFyZSBhbiBpbmZpbml0ZSB2YXJpZXR5XG4gKiBvZiBub3JtYWwgZGlzdHJpYnV0aW9ucywgaXQgaXMgY29tbW9uIHByYWN0aWNlIHRvIGNvbnZlcnQgYSBub3JtYWwgdG8gYVxuICogc3RhbmRhcmQgbm9ybWFsIGFuZCB0aGVuIHVzZSB0aGUgc3RhbmRhcmQgbm9ybWFsIHRhYmxlIHRvIGZpbmQgcHJvYmFiaWxpdGllcy5cbiAqXG4gKiBZb3UgY2FuIHVzZSBgLjUgKyAuNSAqIGVycm9yRnVuY3Rpb24oeCAvIE1hdGguc3FydCgyKSlgIHRvIGNhbGN1bGF0ZSB0aGUgcHJvYmFiaWxpdHlcbiAqIGluc3RlYWQgb2YgbG9va2luZyBpdCB1cCBpbiBhIHRhYmxlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjdW11bGF0aXZlIHN0YW5kYXJkIG5vcm1hbCBwcm9iYWJpbGl0eVxuICovXG5mdW5jdGlvbiBjdW11bGF0aXZlU3RkTm9ybWFsUHJvYmFiaWxpdHkoeikge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhpcyB2YWx1ZS5cbiAgICB2YXIgYWJzWiA9IE1hdGguYWJzKHopO1xuICAgIC8vIEVhY2ggcm93IGJlZ2lucyB3aXRoIGEgZGlmZmVyZW50XG4gICAgLy8gc2lnbmlmaWNhbnQgZGlnaXQ6IDAuNSwgMC42LCAwLjcsIGFuZCBzbyBvbi4gRWFjaCB2YWx1ZSBpbiB0aGUgdGFibGVcbiAgICAvLyBjb3JyZXNwb25kcyB0byBhIHJhbmdlIG9mIDAuMDEgaW4gdGhlIGlucHV0IHZhbHVlcywgc28gdGhlIHZhbHVlIGlzXG4gICAgLy8gbXVsdGlwbGllZCBieSAxMDAuXG4gICAgdmFyIGluZGV4ID0gTWF0aC5taW4oXG4gICAgICAgIE1hdGgucm91bmQoYWJzWiAqIDEwMCksXG4gICAgICAgIHN0YW5kYXJkTm9ybWFsVGFibGUubGVuZ3RoIC0gMVxuICAgICk7XG5cbiAgICAvLyBUaGUgaW5kZXggd2UgY2FsY3VsYXRlIG11c3QgYmUgaW4gdGhlIHRhYmxlIGFzIGEgcG9zaXRpdmUgdmFsdWUsXG4gICAgLy8gYnV0IHdlIHN0aWxsIHBheSBhdHRlbnRpb24gdG8gd2hldGhlciB0aGUgaW5wdXQgaXMgcG9zaXRpdmVcbiAgICAvLyBvciBuZWdhdGl2ZSwgYW5kIGZsaXAgdGhlIG91dHB1dCB2YWx1ZSBhcyBhIGxhc3Qgc3RlcC5cbiAgICBpZiAoeiA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFuZGFyZE5vcm1hbFRhYmxlW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkdWUgdG8gZmxvYXRpbmctcG9pbnQgYXJpdGhtZXRpYywgdmFsdWVzIGluIHRoZSB0YWJsZSB3aXRoXG4gICAgICAgIC8vIDQgc2lnbmlmaWNhbnQgZmlndXJlcyBjYW4gbmV2ZXJ0aGVsZXNzIGVuZCB1cCBhcyByZXBlYXRpbmdcbiAgICAgICAgLy8gZnJhY3Rpb25zIHdoZW4gdGhleSdyZSBjb21wdXRlZCBoZXJlLlxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgoMSAtIHN0YW5kYXJkTm9ybWFsVGFibGVbaW5kZXhdKSAqIDFlNCkgLyAxZTQ7XG4gICAgfVxufVxuXG4vKipcbiAqICoqW0xvZ2lzdGljIEN1bXVsYXRpdmUgRGlzdHJpYnV0aW9uIEZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dpc3RpY19kaXN0cmlidXRpb24pKipcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybnMge251bWJlcn0gY3VtdWxhdGl2ZSBzdGFuZGFyZCBsb2dpc3RpYyBwcm9iYWJpbGl0eVxuICovXG5mdW5jdGlvbiBjdW11bGF0aXZlU3RkTG9naXN0aWNQcm9iYWJpbGl0eSh4KSB7XG4gICAgcmV0dXJuIDEgLyAoTWF0aC5leHAoLXgpICsgMSk7XG59XG5cbi8qKlxuICogKipbR2F1c3NpYW4gZXJyb3IgZnVuY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24pKipcbiAqXG4gKiBUaGUgYGVycm9yRnVuY3Rpb24oeC8oc2QgKiBNYXRoLnNxcnQoMikpKWAgaXMgdGhlIHByb2JhYmlsaXR5IHRoYXQgYSB2YWx1ZSBpbiBhXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uIHdpdGggc3RhbmRhcmQgZGV2aWF0aW9uIHNkIGlzIHdpdGhpbiB4IG9mIHRoZSBtZWFuLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG51bWVyaWNhbCBhcHByb3hpbWF0aW9uIHRvIHRoZSBleGFjdCB2YWx1ZS5cbiAqIEl0IHVzZXMgSG9ybmVyJ3MgbWV0aG9kIHRvIGV2YWx1YXRlIHRoZSBwb2x5bm9taWFsIG9mIM+EICh0YXUpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGVycm9yIGVzdGltYXRpb25cbiAqIEBleGFtcGxlXG4gKiBlcnJvckZ1bmN0aW9uKDEpLnRvRml4ZWQoMik7IC8vID0+ICcwLjg0J1xuICovXG5mdW5jdGlvbiBlcnJvckZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgdCA9IDEgLyAoMSArIDAuNSAqIE1hdGguYWJzKHgpKTtcbiAgICB2YXIgdGF1ID1cbiAgICAgICAgdCAqXG4gICAgICAgIE1hdGguZXhwKFxuICAgICAgICAgICAgLXggKiB4ICtcbiAgICAgICAgICAgICAgICAoKCgoKCgoKDAuMTcwODcyNzcgKiB0IC0gMC44MjIxNTIyMykgKiB0ICsgMS40ODg1MTU4NykgKiB0IC1cbiAgICAgICAgICAgICAgICAgICAgMS4xMzUyMDM5OCkgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMC4yNzg4NjgwNykgKlxuICAgICAgICAgICAgICAgICAgICB0IC1cbiAgICAgICAgICAgICAgICAgICAgMC4xODYyODgwNikgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMC4wOTY3ODQxOCkgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMC4zNzQwOTE5NikgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMS4wMDAwMjM2OCkgKlxuICAgICAgICAgICAgICAgICAgICB0IC1cbiAgICAgICAgICAgICAgICAxLjI2NTUxMjIzXG4gICAgICAgICk7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgICByZXR1cm4gMSAtIHRhdTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGF1IC0gMTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIEludmVyc2UgW0dhdXNzaWFuIGVycm9yIGZ1bmN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Vycm9yX2Z1bmN0aW9uKVxuICogcmV0dXJucyBhIG51bWVyaWNhbCBhcHByb3hpbWF0aW9uIHRvIHRoZSB2YWx1ZSB0aGF0IHdvdWxkIGhhdmUgY2F1c2VkXG4gKiBgZXJyb3JGdW5jdGlvbigpYCB0byByZXR1cm4geC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCB2YWx1ZSBvZiBlcnJvciBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gZXN0aW1hdGVkIGludmVydGVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGludmVyc2VFcnJvckZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgYSA9ICg4ICogKE1hdGguUEkgLSAzKSkgLyAoMyAqIE1hdGguUEkgKiAoNCAtIE1hdGguUEkpKTtcblxuICAgIHZhciBpbnYgPSBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KDIgLyAoTWF0aC5QSSAqIGEpICsgTWF0aC5sb2coMSAtIHggKiB4KSAvIDIsIDIpIC1cbiAgICAgICAgICAgICAgICBNYXRoLmxvZygxIC0geCAqIHgpIC8gYVxuICAgICAgICApIC1cbiAgICAgICAgICAgICgyIC8gKE1hdGguUEkgKiBhKSArIE1hdGgubG9nKDEgLSB4ICogeCkgLyAyKVxuICAgICk7XG5cbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpbnY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC1pbnY7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBbUHJvYml0XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JpdClcbiAqIGlzIHRoZSBpbnZlcnNlIG9mIGN1bXVsYXRpdmVTdGROb3JtYWxQcm9iYWJpbGl0eSgpLFxuICogYW5kIGlzIGFsc28ga25vd24gYXMgdGhlIG5vcm1hbCBxdWFudGlsZSBmdW5jdGlvbi5cbiAqXG4gKiBJdCByZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWFuXG4gKiB3aGVyZSB0aGUgcCd0aCBxdWFudGlsZSBvZiB2YWx1ZXMgY2FuIGJlIGZvdW5kIGluIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbi5cbiAqIFNvLCBmb3IgZXhhbXBsZSwgcHJvYml0KDAuNSArIDAuNjgyNy8yKSDiiYggMSBiZWNhdXNlIDY4LjI3JSBvZiB2YWx1ZXMgYXJlXG4gKiBub3JtYWxseSBmb3VuZCB3aXRoaW4gMSBzdGFuZGFyZCBkZXZpYXRpb24gYWJvdmUgb3IgYmVsb3cgdGhlIG1lYW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHByb2JpdFxuICovXG5mdW5jdGlvbiBwcm9iaXQocCkge1xuICAgIGlmIChwID09PSAwKSB7XG4gICAgICAgIHAgPSBlcHNpbG9uO1xuICAgIH0gZWxzZSBpZiAocCA+PSAxKSB7XG4gICAgICAgIHAgPSAxIC0gZXBzaWxvbjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydCgyKSAqIGludmVyc2VFcnJvckZ1bmN0aW9uKDIgKiBwIC0gMSk7XG59XG5cbi8qKlxuICogVGhlIFtMb2dpdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9naXQpXG4gKiBpcyB0aGUgaW52ZXJzZSBvZiBjdW11bGF0aXZlU3RkTG9naXN0aWNQcm9iYWJpbGl0eSxcbiAqIGFuZCBpcyBhbHNvIGtub3duIGFzIHRoZSBsb2dpc3RpYyBxdWFudGlsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcFxuICogQHJldHVybnMge251bWJlcn0gbG9naXRcbiAqL1xuZnVuY3Rpb24gbG9naXQocCkge1xuICAgIGlmIChwIDw9IDAgfHwgcCA+PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInAgbXVzdCBiZSBzdHJpY3RseSBiZXR3ZWVuIHplcm8gYW5kIG9uZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nKHAgLyAoMSAtIHApKTtcbn1cblxuLyoqXG4gKiBDb25kdWN0cyBhIFtwZXJtdXRhdGlvbiB0ZXN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZXNhbXBsaW5nXyhzdGF0aXN0aWNzKSNQZXJtdXRhdGlvbl90ZXN0cylcbiAqIHRvIGRldGVybWluZSBpZiB0d28gZGF0YSBzZXRzIGFyZSAqc2lnbmlmaWNhbnRseSogZGlmZmVyZW50IGZyb20gZWFjaCBvdGhlciwgdXNpbmdcbiAqIHRoZSBkaWZmZXJlbmNlIG9mIG1lYW5zIGJldHdlZW4gdGhlIGdyb3VwcyBhcyB0aGUgdGVzdCBzdGF0aXN0aWMuXG4gKiBUaGUgZnVuY3Rpb24gYWxsb3dzIGZvciB0aGUgZm9sbG93aW5nIGh5cG90aGVzZXM6XG4gKiAtIHR3b190YWlsID0gTnVsbCBoeXBvdGhlc2lzOiB0aGUgdHdvIGRpc3RyaWJ1dGlvbnMgYXJlIGVxdWFsLlxuICogLSBncmVhdGVyID0gTnVsbCBoeXBvdGhlc2lzOiBvYnNlcnZhdGlvbnMgZnJvbSBzYW1wbGVYIHRlbmQgdG8gYmUgc21hbGxlciB0aGFuIHRob3NlIGZyb20gc2FtcGxlWS5cbiAqIC0gbGVzcyA9IE51bGwgaHlwb3RoZXNpczogb2JzZXJ2YXRpb25zIGZyb20gc2FtcGxlWCB0ZW5kIHRvIGJlIGdyZWF0ZXIgdGhhbiB0aG9zZSBmcm9tIHNhbXBsZVkuXG4gKiBbTGVhcm4gbW9yZSBhYm91dCBvbmUtdGFpbCB2cyB0d28tdGFpbCB0ZXN0cy5dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09uZS1fYW5kX3R3by10YWlsZWRfdGVzdHMpXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzYW1wbGVYIGZpcnN0IGRhdGFzZXQgKGUuZy4gdHJlYXRtZW50IGRhdGEpXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVkgc2Vjb25kIGRhdGFzZXQgKGUuZy4gY29udHJvbCBkYXRhKVxuICogQHBhcmFtIHtzdHJpbmd9IGFsdGVybmF0aXZlIGFsdGVybmF0aXZlIGh5cG90aGVzaXMsIGVpdGhlciAndHdvX3NpZGVkJyAoZGVmYXVsdCksICdncmVhdGVyJywgb3IgJ2xlc3MnXG4gKiBAcGFyYW0ge251bWJlcn0gayBudW1iZXIgb2YgdmFsdWVzIGluIHBlcm11dGF0aW9uIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBwLXZhbHVlIFRoZSBwcm9iYWJpbGl0eSBvZiBvYnNlcnZpbmcgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBncm91cHMgKGFzIG9yIG1vcmUgZXh0cmVtZSB0aGFuIHdoYXQgd2UgZGlkKSwgYXNzdW1pbmcgdGhlIG51bGwgaHlwb3RoZXNpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRyb2wgPSBbMiwgNSwgMywgNiwgNywgMiwgNV07XG4gKiB2YXIgdHJlYXRtZW50ID0gWzIwLCA1LCAxMywgMTIsIDcsIDIsIDJdO1xuICogcGVybXV0YXRpb25UZXN0KGNvbnRyb2wsIHRyZWF0bWVudCk7IC8vIH4wLjEzMjRcbiAqL1xuZnVuY3Rpb24gcGVybXV0YXRpb25UZXN0KHNhbXBsZVgsIHNhbXBsZVksIGFsdGVybmF0aXZlLCBrLCByYW5kb21Tb3VyY2UpIHtcbiAgICAvLyBTZXQgZGVmYXVsdCBhcmd1bWVudHNcbiAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGsgPSAxMDAwMDtcbiAgICB9XG4gICAgaWYgKGFsdGVybmF0aXZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWx0ZXJuYXRpdmUgPSBcInR3b19zaWRlXCI7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICAgYWx0ZXJuYXRpdmUgIT09IFwidHdvX3NpZGVcIiAmJlxuICAgICAgICBhbHRlcm5hdGl2ZSAhPT0gXCJncmVhdGVyXCIgJiZcbiAgICAgICAgYWx0ZXJuYXRpdmUgIT09IFwibGVzc1wiXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiYGFsdGVybmF0aXZlYCBtdXN0IGJlIGVpdGhlciAndHdvX3NpZGUnLCAnZ3JlYXRlcicsIG9yICdsZXNzJy5cIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIGdldCBtZWFucyBmb3IgZWFjaCBzYW1wbGVcbiAgICB2YXIgbWVhblggPSBtZWFuKHNhbXBsZVgpO1xuICAgIHZhciBtZWFuWSA9IG1lYW4oc2FtcGxlWSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaW5pdGlhbCB0ZXN0IHN0YXRpc3RpYy4gVGhpcyB3aWxsIGJlIG91ciBwb2ludCBvZiBjb21wYXJpc29uIHdpdGhcbiAgICAvLyB0aGUgZ2VuZXJhdGVkIHRlc3Qgc3RhdGlzdGljcy5cbiAgICB2YXIgdGVzdFN0YXRpc3RpYyA9IG1lYW5YIC0gbWVhblk7XG5cbiAgICAvLyBjcmVhdGUgdGVzdC1zdGF0aXN0aWMgZGlzdHJpYnV0aW9uXG4gICAgdmFyIHRlc3RTdGF0RHNuID0gbmV3IEFycmF5KGspO1xuXG4gICAgLy8gY29tYmluZSBkYXRzZXRzIHNvIHdlIGNhbiBlYXNpbHkgc2h1ZmZsZSBsYXRlclxuICAgIHZhciBhbGxEYXRhID0gc2FtcGxlWC5jb25jYXQoc2FtcGxlWSk7XG4gICAgdmFyIG1pZEluZGV4ID0gTWF0aC5mbG9vcihhbGxEYXRhLmxlbmd0aCAvIDIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgLy8gMS4gc2h1ZmZsZSBkYXRhIGFzc2lnbm1lbnRzXG4gICAgICAgIHNodWZmbGVJblBsYWNlKGFsbERhdGEsIHJhbmRvbVNvdXJjZSk7XG4gICAgICAgIHZhciBwZXJtTGVmdCA9IGFsbERhdGEuc2xpY2UoMCwgbWlkSW5kZXgpO1xuICAgICAgICB2YXIgcGVybVJpZ2h0ID0gYWxsRGF0YS5zbGljZShtaWRJbmRleCwgYWxsRGF0YS5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDIucmUtY2FsY3VsYXRlIHRlc3Qgc3RhdGlzdGljXG4gICAgICAgIHZhciBwZXJtVGVzdFN0YXRpc3RpYyA9IG1lYW4ocGVybUxlZnQpIC0gbWVhbihwZXJtUmlnaHQpO1xuXG4gICAgICAgIC8vIDMuIHN0b3JlIHRlc3Qgc3RhdGlzdGljIHRvIGJ1aWxkIHRlc3Qgc3RhdGlzdGljIGRpc3RyaWJ1dGlvblxuICAgICAgICB0ZXN0U3RhdERzbltpXSA9IHBlcm1UZXN0U3RhdGlzdGljO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBwLXZhbHVlIGRlcGVuZGluZyBvbiBhbHRlcm5hdGl2ZVxuICAgIC8vIEZvciB0aGlzIHRlc3QsIHdlIGNhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiAnZXh0cmVtZScgdGVzdCBzdGF0aXN0aWNzIChzdWJqZWN0IHRvIG91ciBoeXBvdGhlc2lzKVxuICAgIC8vIG1vcmUgaW5mbyBvbiBwZXJtdXRhdGlvbiB0ZXN0IHAtdmFsdWUgY2FsY3VsYXRpb25zOiBodHRwczovL29ubGluZWNvdXJzZXMuc2NpZW5jZS5wc3UuZWR1L3N0YXQ0NjQvbm9kZS8zNVxuICAgIHZhciBudW1FeHRyZW1lVFN0YXRzID0gMDtcbiAgICBpZiAoYWx0ZXJuYXRpdmUgPT09IFwidHdvX3NpZGVcIikge1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPD0gazsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0ZXN0U3RhdERzbltpJDFdKSA+PSBNYXRoLmFicyh0ZXN0U3RhdGlzdGljKSkge1xuICAgICAgICAgICAgICAgIG51bUV4dHJlbWVUU3RhdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRpdmUgPT09IFwiZ3JlYXRlclwiKSB7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8PSBrOyBpJDIrKykge1xuICAgICAgICAgICAgaWYgKHRlc3RTdGF0RHNuW2kkMl0gPj0gdGVzdFN0YXRpc3RpYykge1xuICAgICAgICAgICAgICAgIG51bUV4dHJlbWVUU3RhdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFsdGVybmF0aXZlID09PSAnbGVzcydcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDw9IGs7IGkkMysrKSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0ZXN0U3RhdERzbltpJDNdIDw9IHRlc3RTdGF0aXN0aWMpIHtcbiAgICAgICAgICAgICAgICBudW1FeHRyZW1lVFN0YXRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgZW5kICovXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtRXh0cmVtZVRTdGF0cyAvIGs7XG59XG5cbi8qKlxuICogW1NpZ25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpZ25fZnVuY3Rpb24pIGlzIGEgZnVuY3Rpb25cbiAqIHRoYXQgZXh0cmFjdHMgdGhlIHNpZ24gb2YgYSByZWFsIG51bWJlclxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzaWduIHZhbHVlIGVpdGhlciAxLCAwIG9yIC0xXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHRoZSBpbnB1dCBhcmd1bWVudCB4IGlzIG5vdCBhIG51bWJlclxuICogQHByaXZhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogc2lnbigyKTsgLy8gPT4gMVxuICovXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSBudW1iZXJcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIFtCaXNlY3Rpb24gbWV0aG9kXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaXNlY3Rpb25fbWV0aG9kKSBpcyBhIHJvb3QtZmluZGluZ1xuICogbWV0aG9kIHRoYXQgcmVwZWF0ZWRseSBiaXNlY3RzIGFuIGludGVydmFsIHRvIGZpbmQgdGhlIHJvb3QuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbnVtZXJpY2FsIGFwcHJveGltYXRpb24gdG8gdGhlIGV4YWN0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgaW5wdXQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IG9mIGludGVydmFsXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gZW5kIG9mIGludGVydmFsXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4SXRlcmF0aW9ucyAtIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gZXJyb3JUb2xlcmFuY2UgLSB0aGUgZXJyb3IgdG9sZXJhbmNlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBlc3RpbWF0ZWQgcm9vdCB2YWx1ZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBBcmd1bWVudCBmdW5jIG11c3QgYmUgYSBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBiaXNlY3QoTWF0aC5jb3MsMCw0LDEwMCwwLjAwMyk7IC8vID0+IDEuNTcyMjY1NjI1XG4gKi9cbmZ1bmN0aW9uIGJpc2VjdChmdW5jLCBzdGFydCwgZW5kLCBtYXhJdGVyYXRpb25zLCBlcnJvclRvbGVyYW5jZSkge1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJmdW5jIG11c3QgYmUgYSBmdW5jdGlvblwiKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IChzdGFydCArIGVuZCkgLyAyO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZ1bmMob3V0cHV0KSA9PT0gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnMoKGVuZCAtIHN0YXJ0KSAvIDIpIDwgZXJyb3JUb2xlcmFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZ24oZnVuYyhvdXRwdXQpKSA9PT0gc2lnbihmdW5jKHN0YXJ0KSkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gb3V0cHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBleGNlZWRlZFwiKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGVmdCBGaXJzdCBOLWRpbWVuc2lvbmFsIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSByaWdodCBTZWNvbmQgTi1kaW1lbnNpb25hbCBwb2ludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3RhbmNlLlxuICovXG5mdW5jdGlvbiBldWNsaWRlYW5EaXN0YW5jZShsZWZ0LCByaWdodCkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlmZiA9IGxlZnRbaV0gLSByaWdodFtpXTtcbiAgICAgICAgc3VtICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0ga01lYW5zUmV0dXJuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxhYmVscyBUaGUgbGFiZWxzLlxuICogQHByb3BlcnR5IHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY2VudHJvaWRzIFRoZSBjbHVzdGVyIGNlbnRyb2lkcy5cbiAqL1xuXG4vKipcbiAqIFBlcmZvcm0gay1tZWFucyBjbHVzdGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBOLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGVzIG9mIHBvaW50cyB0byBiZSBjbHVzdGVyZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQ2x1c3RlciBIb3cgbWFueSBjbHVzdGVycyB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByYW5kb21Tb3VyY2UgQW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdCBnZW5lcmF0ZXMgdW5pZm9ybSB2YWx1ZXMgaW4gWzAsIDEpLlxuICogQHJldHVybiB7a01lYW5zUmV0dXJufSBMYWJlbHMgKHNhbWUgbGVuZ3RoIGFzIGRhdGEpIGFuZCBjZW50cm9pZHMgKHNhbWUgbGVuZ3RoIGFzIG51bUNsdXN0ZXIpLlxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSBjZW50cm9pZHMgd2luZCB1cCBmcmllbmRsZXNzIChpLmUuLCB3aXRob3V0IGFzc29jaWF0ZWQgcG9pbnRzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICoga01lYW5zQ2x1c3RlcihbWzAuMCwgMC41XSwgWzEuMCwgMC41XV0sIDIpOyAvLyA9PiB7bGFiZWxzOiBbMCwgMV0sIGNlbnRyb2lkczogW1swLjAsIDAuNV0sIFsxLjAgMC41XV19XG4gKi9cbmZ1bmN0aW9uIGtNZWFuc0NsdXN0ZXIocG9pbnRzLCBudW1DbHVzdGVyLCByYW5kb21Tb3VyY2UpIHtcbiAgICBpZiAoIHJhbmRvbVNvdXJjZSA9PT0gdm9pZCAwICkgcmFuZG9tU291cmNlID0gTWF0aC5yYW5kb207XG5cbiAgICB2YXIgb2xkQ2VudHJvaWRzID0gbnVsbDtcbiAgICB2YXIgbmV3Q2VudHJvaWRzID0gc2FtcGxlKHBvaW50cywgbnVtQ2x1c3RlciwgcmFuZG9tU291cmNlKTtcbiAgICB2YXIgbGFiZWxzID0gbnVsbDtcbiAgICB2YXIgY2hhbmdlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB3aGlsZSAoY2hhbmdlICE9PSAwKSB7XG4gICAgICAgIGxhYmVscyA9IGxhYmVsUG9pbnRzKHBvaW50cywgbmV3Q2VudHJvaWRzKTtcbiAgICAgICAgb2xkQ2VudHJvaWRzID0gbmV3Q2VudHJvaWRzO1xuICAgICAgICBuZXdDZW50cm9pZHMgPSBjYWxjdWxhdGVDZW50cm9pZHMocG9pbnRzLCBsYWJlbHMsIG51bUNsdXN0ZXIpO1xuICAgICAgICBjaGFuZ2UgPSBjYWxjdWxhdGVDaGFuZ2UobmV3Q2VudHJvaWRzLCBvbGRDZW50cm9pZHMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgY2VudHJvaWRzOiBuZXdDZW50cm9pZHNcbiAgICB9O1xufVxuXG4vKipcbiAqIExhYmVsIGVhY2ggcG9pbnQgYWNjb3JkaW5nIHRvIHdoaWNoIGNlbnRyb2lkIGl0IGlzIGNsb3Nlc3QgdG8uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBBcnJheSBvZiBYWSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNlbnRyb2lkcyBDdXJyZW50IGNlbnRyb2lkcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEdyb3VwIGxhYmVscy5cbiAqL1xuZnVuY3Rpb24gbGFiZWxQb2ludHMocG9pbnRzLCBjZW50cm9pZHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHZhciBsYWJlbCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbnRyb2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBldWNsaWRlYW5EaXN0YW5jZShwLCBjZW50cm9pZHNbaV0pO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY2VudHJvaWRzIGZvciBwb2ludHMgZ2l2ZW4gbGFiZWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwb2ludHMgQXJyYXkgb2YgWFkgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGxhYmVscyBXaGljaCBncm91cHMgcG9pbnRzIGJlbG9uZyB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1DbHVzdGVyIE51bWJlciBvZiBjbHVzdGVycyBiZWluZyBjcmVhdGVkLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IENlbnRyb2lkIGZvciBlYWNoIGdyb3VwLlxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSBjZW50cm9pZHMgd2luZCB1cCBmcmllbmRsZXNzIChpLmUuLCB3aXRob3V0IGFzc29jaWF0ZWQgcG9pbnRzKS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQ2VudHJvaWRzKHBvaW50cywgbGFiZWxzLCBudW1DbHVzdGVyKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhY2N1bXVsYXRvcnMuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHBvaW50c1swXS5sZW5ndGg7XG4gICAgdmFyIGNlbnRyb2lkcyA9IG1ha2VNYXRyaXgobnVtQ2x1c3RlciwgZGltZW5zaW9uKTtcbiAgICB2YXIgY291bnRzID0gQXJyYXkobnVtQ2x1c3RlcikuZmlsbCgwKTtcblxuICAgIC8vIEFkZCBwb2ludHMgdG8gY2VudHJvaWRzJyBhY2N1bXVsYXRvcnMgYW5kIGNvdW50IHBvaW50cyBwZXIgY2VudHJvaWQuXG4gICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjZW50cm9pZHNbbGFiZWxdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICBjdXJyZW50W2pdICs9IHBvaW50W2pdO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50c1tsYWJlbF0gKz0gMTtcbiAgICB9XG5cbiAgICAvLyBSZXNjYWxlIGNlbnRyb2lkcywgY2hlY2tpbmcgZm9yIGFueSB0aGF0IGhhdmUgbm8gcG9pbnRzLlxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG51bUNsdXN0ZXI7IGkkMSsrKSB7XG4gICAgICAgIGlmIChjb3VudHNbaSQxXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkNlbnRyb2lkIFwiICsgaSQxICsgXCIgaGFzIG5vIGZyaWVuZHNcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkc1tpJDFdO1xuICAgICAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBkaW1lbnNpb247IGokMSsrKSB7XG4gICAgICAgICAgICBjZW50cm9pZFtqJDFdIC89IGNvdW50c1tpJDFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRyb2lkcztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbGQgY2VudHJvaWRzIGFuZCBuZXcgY2VudHJvaWRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBsZWZ0IE9uZSBsaXN0IG9mIGNlbnRyb2lkcy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHJpZ2h0IEFub3RoZXIgbGlzdCBvZiBjZW50cm9pZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gY2VudHJvaWRzLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDaGFuZ2UobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBldWNsaWRlYW5EaXN0YW5jZShsZWZ0W2ldLCByaWdodFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIFtzaWxob3VldHRlIHZhbHVlc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lsaG91ZXR0ZV8oY2x1c3RlcmluZykpXG4gKiBmb3IgY2x1c3RlcmVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy4gVGhpcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBhcyBgcG9pbnRzYCxcbiAqIGFuZCB2YWx1ZXMgbXVzdCBsaWUgaW4gWzAuLkctMV0sIHdoZXJlIEcgaXMgdGhlIG51bWJlciBvZiBncm91cHMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc2lsaG91ZXR0ZSB2YWx1ZSBmb3IgZWFjaCBwb2ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogc2lsaG91ZXR0ZShbWzAuMjVdLCBbMC43NV1dLCBbMCwgMF0pOyAvLyA9PiBbMS4wLCAxLjBdXG4gKi9cbmZ1bmN0aW9uIHNpbGhvdWV0dGUocG9pbnRzLCBsYWJlbHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCAhPT0gbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IGhhdmUgZXhhY3RseSBhcyBtYW55IGxhYmVscyBhcyBwb2ludHNcIik7XG4gICAgfVxuICAgIHZhciBncm91cGluZ3MgPSBjcmVhdGVHcm91cHMobGFiZWxzKTtcbiAgICB2YXIgZGlzdGFuY2VzID0gY2FsY3VsYXRlQWxsRGlzdGFuY2VzKHBvaW50cyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgaWYgKGdyb3VwaW5nc1tsYWJlbHNbaV1dLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBhID0gbWVhbkRpc3RhbmNlRnJvbVBvaW50VG9Hcm91cChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGdyb3VwaW5nc1tsYWJlbHNbaV1dLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBiID0gbWVhbkRpc3RhbmNlVG9OZWFyZXN0R3JvdXAoXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBsYWJlbHMsXG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdzLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHMgPSAoYiAtIGEpIC8gTWF0aC5tYXgoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbG9va3VwIHRhYmxlIG1hcHBpbmcgZ3JvdXAgSURzIHRvIHBvaW50IElEcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy4gVGhpcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBhcyBgcG9pbnRzYCxcbiAqIGFuZCB2YWx1ZXMgbXVzdCBsaWUgaW4gWzAuLkctMV0sIHdoZXJlIEcgaXMgdGhlIG51bWJlciBvZiBncm91cHMuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQW4gYXJyYXkgb2YgbGVuZ3RoIEcsIGVhY2ggb2Ygd2hvc2UgZW50cmllcyBpcyBhbiBhcnJheVxuICogY29udGFpbmluZyB0aGUgaW5kaWNlcyBvZiB0aGUgcG9pbnRzIGluIHRoYXQgZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwcyhsYWJlbHMpIHtcbiAgICB2YXIgbnVtR3JvdXBzID0gMSArIG1heChsYWJlbHMpO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShudW1Hcm91cHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgaWYgKHJlc3VsdFtsYWJlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0W2xhYmVsXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtsYWJlbF0ucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsb29rdXAgdGFibGUgb2YgYWxsIGludGVyLXBvaW50IGRpc3RhbmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IEEgc3ltbWV0cmljIHNxdWFyZSBhcnJheSBvZiBpbnRlci1wb2ludCBkaXN0YW5jZXNcbiAqICh6ZXJvIG9uIHRoZSBkaWFnb25hbCkuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFsbERpc3RhbmNlcyhwb2ludHMpIHtcbiAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbWFrZU1hdHJpeChudW1Qb2ludHMsIG51bVBvaW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldW2pdID0gZXVjbGlkZWFuRGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbal0pO1xuICAgICAgICAgICAgcmVzdWx0W2pdW2ldID0gcmVzdWx0W2ldW2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBtZWFuIGRpc3RhbmNlIGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYWxsIHRoZSBwb2ludHMgaW4gdGhlXG4gKiBuZWFyZXN0IGdyb3VwIChhcyBkZXRlcm1pbmVkIGJ5IHdoaWNoIHBvaW50IGluIGFub3RoZXIgZ3JvdXAgaXMgY2xvc2VzdCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aGljaCBUaGUgaW5kZXggb2YgdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIExhYmVscyBvZiBwb2ludHMuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBncm91cGluZ3MgQW4gYXJyYXkgd2hvc2UgZW50cmllcyBhcmUgYXJyYXlzXG4gKiBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSBwb2ludHMgaW4gdGhhdCBncm91cC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRpc3RhbmNlcyBBIHN5bW1ldHJpYyBzcXVhcmUgYXJyYXkgb2YgaW50ZXItcG9pbnRcbiAqIGRpc3RhbmNlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1lYW4gZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIG90aGVycyBpbiB0aGUgbmVhcmVzdFxuICogZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIG1lYW5EaXN0YW5jZVRvTmVhcmVzdEdyb3VwKHdoaWNoLCBsYWJlbHMsIGdyb3VwaW5ncywgZGlzdGFuY2VzKSB7XG4gICAgdmFyIGxhYmVsID0gbGFiZWxzW3doaWNoXTtcbiAgICB2YXIgcmVzdWx0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gbGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBkID0gbWVhbkRpc3RhbmNlRnJvbVBvaW50VG9Hcm91cChcbiAgICAgICAgICAgICAgICB3aGljaCxcbiAgICAgICAgICAgICAgICBncm91cGluZ3NbaV0sXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGQgPCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBtZWFuIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCBhbmQgYWxsIHRoZSBwb2ludHMgaW4gYSBncm91cFxuICogKHBvc3NpYmx5IGl0cyBvd24pLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gd2hpY2ggVGhlIGluZGV4IG9mIHRoaXMgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGdyb3VwIFRoZSBpbmRpY2VzIG9mIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBncm91cCBpblxuICogcXVlc3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBkaXN0YW5jZXMgQSBzeW1tZXRyaWMgc3F1YXJlIGFycmF5IG9mIGludGVyLXBvaW50XG4gKiBkaXN0YW5jZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtZWFuIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBvdGhlcnMgaW4gdGhlXG4gKiBzcGVjaWZpZWQgZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIG1lYW5EaXN0YW5jZUZyb21Qb2ludFRvR3JvdXAod2hpY2gsIGdyb3VwLCBkaXN0YW5jZXMpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gZGlzdGFuY2VzW3doaWNoXVtncm91cFtpXV07XG4gICAgfVxuICAgIHJldHVybiB0b3RhbCAvIGdyb3VwLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIFtzaWxob3VldHRlIG1ldHJpY10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lsaG91ZXR0ZV8oY2x1c3RlcmluZykpXG4gKiBmb3IgYSBzZXQgb2YgTi1kaW1lbnNpb25hbCBwb2ludHMgYXJyYW5nZWQgaW4gZ3JvdXBzLiBUaGUgbWV0cmljIGlzIHRoZSBsYXJnZXN0XG4gKiBpbmRpdmlkdWFsIHNpbGhvdWV0dGUgdmFsdWUgZm9yIHRoZSBkYXRhLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBOLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGVzIG9mIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIExhYmVscyBvZiBwb2ludHMuIFRoaXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGggYXMgYHBvaW50c2AsXG4gKiBhbmQgdmFsdWVzIG11c3QgbGllIGluIFswLi5HLTFdLCB3aGVyZSBHIGlzIHRoZSBudW1iZXIgb2YgZ3JvdXBzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc2lsaG91ZXR0ZSBtZXRyaWMgZm9yIHRoZSBncm91cGluZ3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIHNpbGhvdWV0dGVNZXRyaWMoW1swLjI1XSwgWzAuNzVdXSwgWzAsIDBdKTsgLy8gPT4gMS4wXG4gKi9cbmZ1bmN0aW9uIHNpbGhvdWV0dGVNZXRyaWMocG9pbnRzLCBsYWJlbHMpIHtcbiAgICB2YXIgdmFsdWVzID0gc2lsaG91ZXR0ZShwb2ludHMsIGxhYmVscyk7XG4gICAgcmV0dXJuIG1heCh2YWx1ZXMpO1xufVxuXG4vKipcbiAqIFJlbGF0aXZlIGVycm9yLlxuICpcbiAqIFRoaXMgaXMgbW9yZSBkaWZmaWN1bHQgdG8gY2FsY3VsYXRlIHRoYW4gaXQgZmlyc3QgYXBwZWFycyBbMSwyXS4gIFRoZSB1c3VhbFxuICogZm9ybXVsYSBmb3IgdGhlIHJlbGF0aXZlIGVycm9yIGJldHdlZW4gYW4gYWN0dWFsIHZhbHVlIEEgYW5kIGFuIGV4cGVjdGVkXG4gKiB2YWx1ZSBFIGlzIGB8KEEtRSkvRXxgLCBidXQ6XG4gKlxuICogMS4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIDAsIGFueSBvdGhlciB2YWx1ZSBoYXMgaW5maW5pdGUgcmVsYXRpdmUgZXJyb3IsXG4gKiAgICB3aGljaCBpcyBjb3VudGVyLWludHVpdGl2ZTogaWYgdGhlIGV4cGVjdGVkIHZvbHRhZ2UgaXMgMCwgZ2V0dGluZyAxLzEwdGhcbiAqICAgIG9mIGEgdm9sdCBkb2Vzbid0IGZlZWwgbGlrZSBhbiBpbmZpbml0ZWx5IGxhcmdlIGVycm9yLlxuICpcbiAqIDIuIFRoaXMgZm9ybXVsYSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBtYXRoZW1hdGljYWwgZGVmaW5pdGlvbiBvZiBhIG1ldHJpYyBbM10uXG4gKiAgICBbNF0gc29sdmVkIHRoaXMgcHJvYmxlbSBieSBkZWZpbmluZyB0aGUgcmVsYXRpdmUgZXJyb3IgYXMgYHxsbih8QS9FfCl8YCxcbiAqICAgIGJ1dCB0aGF0IGZvcm11bGEgb25seSB3b3JrcyBpZiBhbGwgdmFsdWVzIGFyZSBwb3NpdGl2ZTogZm9yIGV4YW1wbGUsIGl0XG4gKiAgICByZXBvcnRzIHRoZSByZWxhdGl2ZSBlcnJvciBvZiAtMTAgYW5kIDEwIGFzIDAuXG4gKlxuICogT3VyIGltcGxlbWVudGF0aW9uIHN0aWNrcyB3aXRoIGNvbnZlbnRpb24gYW5kIHJldHVybnM6XG4gKlxuICogLSAwIGlmIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyBhcmUgYm90aCB6ZXJvXG4gKiAtIEluZmluaXR5IGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgbm9uLXplcm8gYW5kIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyB6ZXJvXG4gKiAtIGB8KEEtRSkvRXxgIGluIGFsbCBvdGhlciBjYXNlc1xuICpcbiAqIFsxXSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzY3Nzg1Mi9ob3ctdG8tY2FsY3VsYXRlLXJlbGF0aXZlLWVycm9yLXdoZW4tdHJ1ZS12YWx1ZS1pcy16ZXJvXG4gKiBbMl0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVsYXRpdmVfY2hhbmdlX2FuZF9kaWZmZXJlbmNlXG4gKiBbM10gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWV0cmljXyhtYXRoZW1hdGljcykjRGVmaW5pdGlvblxuICogWzRdIEYuVy5KLiBPbHZlcjogXCJBIE5ldyBBcHByb2FjaCB0byBFcnJvciBBcml0aG1ldGljLlwiIFNJQU0gSm91cm5hbCBvblxuICogICAgIE51bWVyaWNhbCBBbmFseXNpcywgMTUoMiksIDE5NzgsIDEwLjExMzcvMDcxNTAyNC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsIFRoZSBhY3R1YWwgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWQgVGhlIGV4cGVjdGVkIHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVsYXRpdmUgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlRXJyb3IoYWN0dWFsLCBleHBlY3RlZCkge1xuICAgIC8vIFRoZXNlIGxpbmVzIGFyZSBhY3R1YWxseSBjb3ZlcmVkIGJ5IHRlc3RzLCBidXQgaXQgc2VlbXNcbiAgICAvLyBsaWtlIGM4IGhhcyBhIGJ1ZyB0aGF0IG1hcmtzIHRoZW0gYXMgbm90IGNvdmVyZWQuXG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGFjdHVhbCA9PT0gMCAmJiBleHBlY3RlZCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIGVuZCAqL1xuICAgIHJldHVybiBNYXRoLmFicygoYWN0dWFsIC0gZXhwZWN0ZWQpIC8gZXhwZWN0ZWQpO1xufVxuXG4vKipcbiAqIEFwcHJveGltYXRlIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWwgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCBUaGUgcmVmZXJlbmNlIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUaGUgYWNjZXB0YWJsZSByZWxhdGl2ZSBkaWZmZXJlbmNlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBudW1iZXJzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICovXG5mdW5jdGlvbiBhcHByb3hFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAoIHRvbGVyYW5jZSA9PT0gdm9pZCAwICkgdG9sZXJhbmNlID0gZXBzaWxvbjtcblxuICAgIHJldHVybiByZWxhdGl2ZUVycm9yKGFjdHVhbCwgZXhwZWN0ZWQpIDw9IHRvbGVyYW5jZTtcbn1cblxuZXhwb3J0IHsgQmF5ZXNpYW5DbGFzc2lmaWVyLCBQZXJjZXB0cm9uTW9kZWwsIGFkZFRvTWVhbiwgYXBwcm94RXF1YWwsIG1lYW4gYXMgYXZlcmFnZSwgbWVhblNpbXBsZSBhcyBhdmVyYWdlU2ltcGxlLCBCYXllc2lhbkNsYXNzaWZpZXIgYXMgYmF5ZXNpYW4sIGJlcm5vdWxsaURpc3RyaWJ1dGlvbiwgYmlub21pYWxEaXN0cmlidXRpb24sIGJpc2VjdCwgY2hpU3F1YXJlZERpc3RyaWJ1dGlvblRhYmxlLCBjaGlTcXVhcmVkR29vZG5lc3NPZkZpdCwgY2h1bmssIGNrbWVhbnMsIGNvZWZmaWNpZW50T2ZWYXJpYXRpb24sIGNvbWJpbmF0aW9ucywgY29tYmluYXRpb25zUmVwbGFjZW1lbnQsIGNvbWJpbmVNZWFucywgY29tYmluZVZhcmlhbmNlcywgY3VtdWxhdGl2ZVN0ZExvZ2lzdGljUHJvYmFiaWxpdHksIGN1bXVsYXRpdmVTdGROb3JtYWxQcm9iYWJpbGl0eSwgZXBzaWxvbiwgZXF1YWxJbnRlcnZhbEJyZWFrcywgZXJyb3JGdW5jdGlvbiBhcyBlcmYsIGVycm9yRnVuY3Rpb24sIGV4dGVudCwgZXh0ZW50U29ydGVkLCBmYWN0b3JpYWwsIGdhbW1hLCBnYW1tYWxuLCBnZW9tZXRyaWNNZWFuLCBoYXJtb25pY01lYW4sIGludGVycXVhcnRpbGVSYW5nZSwgaW52ZXJzZUVycm9yRnVuY3Rpb24sIGludGVycXVhcnRpbGVSYW5nZSBhcyBpcXIsIGplbmtzLCBrTWVhbnNDbHVzdGVyLCBrZXJuZWxEZW5zaXR5RXN0aW1hdGlvbiBhcyBrZGUsIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uLCBsaW5lYXJSZWdyZXNzaW9uLCBsaW5lYXJSZWdyZXNzaW9uTGluZSwgbG9nQXZlcmFnZSwgbG9naXQsIG1lZGlhbkFic29sdXRlRGV2aWF0aW9uIGFzIG1hZCwgbWF4LCBtYXhTb3J0ZWQsIG1lYW4sIG1lYW5TaW1wbGUsIG1lZGlhbiwgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb24sIG1lZGlhblNvcnRlZCwgbWluLCBtaW5Tb3J0ZWQsIG1vZGUsIG1vZGVGYXN0LCBtb2RlU29ydGVkLCBudW1lcmljU29ydCwgUGVyY2VwdHJvbk1vZGVsIGFzIHBlcmNlcHRyb24sIHBlcm11dGF0aW9uVGVzdCwgcGVybXV0YXRpb25zSGVhcCwgcG9pc3NvbkRpc3RyaWJ1dGlvbiwgcHJvYml0LCBwcm9kdWN0LCBxdWFudGlsZSwgcXVhbnRpbGVSYW5rLCBxdWFudGlsZVJhbmtTb3J0ZWQsIHF1YW50aWxlU29ydGVkLCBxdWlja3NlbGVjdCwgclNxdWFyZWQsIHJlbGF0aXZlRXJyb3IsIHJvb3RNZWFuU3F1YXJlIGFzIHJtcywgcm9vdE1lYW5TcXVhcmUsIHNhbXBsZSwgc2FtcGxlQ29ycmVsYXRpb24sIHNhbXBsZUNvdmFyaWFuY2UsIHNhbXBsZUt1cnRvc2lzLCBzYW1wbGVSYW5rQ29ycmVsYXRpb24sIHNhbXBsZVNrZXduZXNzLCBzYW1wbGVTdGFuZGFyZERldmlhdGlvbiwgc2FtcGxlVmFyaWFuY2UsIHNhbXBsZVdpdGhSZXBsYWNlbWVudCwgc2h1ZmZsZSwgc2h1ZmZsZUluUGxhY2UsIHNpZ24sIHNpbGhvdWV0dGUsIHNpbGhvdWV0dGVNZXRyaWMsIHN0YW5kYXJkRGV2aWF0aW9uLCBzdGFuZGFyZE5vcm1hbFRhYmxlLCBzdWJ0cmFjdEZyb21NZWFuLCBzdW0sIHN1bU50aFBvd2VyRGV2aWF0aW9ucywgc3VtU2ltcGxlLCB0VGVzdCwgdFRlc3RUd29TYW1wbGUsIHVuaXF1ZUNvdW50U29ydGVkLCB2YXJpYW5jZSwgd2lsY294b25SYW5rU3VtLCB6U2NvcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1zdGF0aXN0aWNzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG4gIGNzcyArPSBvYmouY3NzO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9XG5cbiAgLy8gRm9yIG9sZCBJRVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfVxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiaW1wb3J0IHRyYW5zZm9ybSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgdmFyIHQgPSB0cmFuc2Zvcm0odG9wb2xvZ3kudHJhbnNmb3JtKSwga2V5LFxuICAgICAgeDAgPSBJbmZpbml0eSwgeTAgPSB4MCwgeDEgPSAteDAsIHkxID0gLXgwO1xuXG4gIGZ1bmN0aW9uIGJib3hQb2ludChwKSB7XG4gICAgcCA9IHQocCk7XG4gICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICBpZiAocFsxXSA8IHkwKSB5MCA9IHBbMV07XG4gICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gYmJveEdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChiYm94R2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBiYm94UG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogby5jb29yZGluYXRlcy5mb3JFYWNoKGJib3hQb2ludCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJjLmxlbmd0aCwgcDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcCA9IHQoYXJjW2ldLCBpKTtcbiAgICAgIGlmIChwWzBdIDwgeDApIHgwID0gcFswXTtcbiAgICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICAgIGlmIChwWzFdID4geTEpIHkxID0gcFsxXTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvciAoa2V5IGluIHRvcG9sb2d5Lm9iamVjdHMpIHtcbiAgICBiYm94R2VvbWV0cnkodG9wb2xvZ3kub2JqZWN0c1trZXldKTtcbiAgfVxuXG4gIHJldHVybiBbeDAsIHkwLCB4MSwgeTFdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgeCkge1xuICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgZWxzZSBoaSA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG87XG59XG4iLCJpbXBvcnQgcmV2ZXJzZSBmcm9tIFwiLi9yZXZlcnNlLmpzXCI7XG5pbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgbykge1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIG8gPSB0b3BvbG9neS5vYmplY3RzW29dO1xuICByZXR1cm4gby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiXG4gICAgICA/IHt0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUodG9wb2xvZ3ksIG8pOyB9KX1cbiAgICAgIDogZmVhdHVyZSh0b3BvbG9neSwgbyk7XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIGlkID0gby5pZCxcbiAgICAgIGJib3ggPSBvLmJib3gsXG4gICAgICBwcm9wZXJ0aWVzID0gby5wcm9wZXJ0aWVzID09IG51bGwgPyB7fSA6IG8ucHJvcGVydGllcyxcbiAgICAgIGdlb21ldHJ5ID0gb2JqZWN0KHRvcG9sb2d5LCBvKTtcbiAgcmV0dXJuIGlkID09IG51bGwgJiYgYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IGJib3ggPT0gbnVsbCA/IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBiYm94OiBiYm94LCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KHRvcG9sb2d5LCBvKSB7XG4gIHZhciB0cmFuc2Zvcm1Qb2ludCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgYXJjcyA9IHRvcG9sb2d5LmFyY3M7XG5cbiAgZnVuY3Rpb24gYXJjKGksIHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgZm9yICh2YXIgYSA9IGFyY3NbaSA8IDAgPyB+aSA6IGldLCBrID0gMCwgbiA9IGEubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICBwb2ludHMucHVzaCh0cmFuc2Zvcm1Qb2ludChhW2tdLCBrKSk7XG4gICAgfVxuICAgIGlmIChpIDwgMCkgcmV2ZXJzZShwb2ludHMsIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludChwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXSk7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBwZXIgdGhlIHNwZWNpZmljYXRpb24uXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpbmcoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgIHdoaWxlIChwb2ludHMubGVuZ3RoIDwgNCkgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIGFuIGFyYyBoYXMgb25seSB0d28gcG9pbnRzLlxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MpIHtcbiAgICByZXR1cm4gYXJjcy5tYXAocmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgdmFyIHR5cGUgPSBvLnR5cGUsIGNvb3JkaW5hdGVzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiByZXR1cm4ge3R5cGU6IHR5cGUsIGdlb21ldHJpZXM6IG8uZ2VvbWV0cmllcy5tYXAoZ2VvbWV0cnkpfTtcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBjb29yZGluYXRlcyA9IHBvaW50KG8uY29vcmRpbmF0ZXMpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IGNvb3JkaW5hdGVzID0gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGNvb3JkaW5hdGVzID0gbGluZShvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKGxpbmUpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGNvb3JkaW5hdGVzID0gcG9seWdvbihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKHBvbHlnb24pOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6IHR5cGUsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307XG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnkobyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGJib3h9IGZyb20gXCIuL2Jib3guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmZWF0dXJlfSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVzaCwgbWVzaEFyY3N9IGZyb20gXCIuL21lc2guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXJnZSwgbWVyZ2VBcmNzfSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5laWdoYm9yc30gZnJvbSBcIi4vbmVpZ2hib3JzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNmb3JtfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB1bnRyYW5zZm9ybX0gZnJvbSBcIi4vdW50cmFuc2Zvcm0uanNcIjtcbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5mdW5jdGlvbiBwbGFuYXJSaW5nQXJlYShyaW5nKSB7XG4gIHZhciBpID0gLTEsIG4gPSByaW5nLmxlbmd0aCwgYSwgYiA9IHJpbmdbbiAtIDFdLCBhcmVhID0gMDtcbiAgd2hpbGUgKCsraSA8IG4pIGEgPSBiLCBiID0gcmluZ1tpXSwgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICByZXR1cm4gTWF0aC5hYnMoYXJlYSk7IC8vIE5vdGU6IGRvdWJsZWQgYXJlYSFcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVyZ2VBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gIHZhciBwb2x5Z29uc0J5QXJjID0ge30sXG4gICAgICBwb2x5Z29ucyA9IFtdLFxuICAgICAgZ3JvdXBzID0gW107XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3Qoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6IG8uYXJjcy5mb3JFYWNoKGV4dHJhY3QpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0KHBvbHlnb24pIHtcbiAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAocG9seWdvbnNCeUFyY1thcmMgPSBhcmMgPCAwID8gfmFyYyA6IGFyY10gfHwgKHBvbHlnb25zQnlBcmNbYXJjXSA9IFtdKSkucHVzaChwb2x5Z29uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhKHJpbmcpIHtcbiAgICByZXR1cm4gcGxhbmFyUmluZ0FyZWEob2JqZWN0KHRvcG9sb2d5LCB7dHlwZTogXCJQb2x5Z29uXCIsIGFyY3M6IFtyaW5nXX0pLmNvb3JkaW5hdGVzWzBdKTtcbiAgfVxuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgd2hpbGUgKHBvbHlnb24gPSBuZWlnaGJvcnMucG9wKCkpIHtcbiAgICAgICAgZ3JvdXAucHVzaChwb2x5Z29uKTtcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICBwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICBkZWxldGUgcG9seWdvbi5fO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgYXJjczogZ3JvdXBzLm1hcChmdW5jdGlvbihwb2x5Z29ucykge1xuICAgICAgdmFyIGFyY3MgPSBbXSwgbjtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIGFyY3MucHVzaChhcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGl0Y2ggdGhlIGFyY3MgaW50byBvbmUgb3IgbW9yZSByaW5ncy5cbiAgICAgIGFyY3MgPSBzdGl0Y2godG9wb2xvZ3ksIGFyY3MpO1xuXG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIHJpbmcgaXMgcmV0dXJuZWQsXG4gICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgLy8gY2hvb3NlIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3QgYWJzb2x1dGUgYXJlYS5cbiAgICAgIGlmICgobiA9IGFyY3MubGVuZ3RoKSA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGsgPSBhcmVhKGFyY3NbMF0pLCBraSwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICgoa2kgPSBhcmVhKGFyY3NbaV0pKSA+IGspIHtcbiAgICAgICAgICAgIHQgPSBhcmNzWzBdLCBhcmNzWzBdID0gYXJjc1tpXSwgYXJjc1tpXSA9IHQsIGsgPSBraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGFyY3MpIHtcbiAgICAgIHJldHVybiBhcmNzLmxlbmd0aCA+IDA7XG4gICAgfSlcbiAgfTtcbn1cbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcywgaSwgbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBhcmNzID0gZXh0cmFjdEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKTtcbiAgZWxzZSBmb3IgKGkgPSAwLCBhcmNzID0gbmV3IEFycmF5KG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aCk7IGkgPCBuOyArK2kpIGFyY3NbaV0gPSBpO1xuICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGFyY3M6IHN0aXRjaCh0b3BvbG9neSwgYXJjcyl9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpIHtcbiAgdmFyIGFyY3MgPSBbXSxcbiAgICAgIGdlb21zQnlBcmMgPSBbXSxcbiAgICAgIGdlb207XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDAoaSkge1xuICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgKGdlb21zQnlBcmNbal0gfHwgKGdlb21zQnlBcmNbal0gPSBbXSkpLnB1c2goe2k6IGksIGc6IGdlb219KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QxKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDIoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MyhhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKGdlb20gPSBvLCBvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGV4dHJhY3QxKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjYXNlIFwiUG9seWdvblwiOiBleHRyYWN0MihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogZXh0cmFjdDMoby5hcmNzKTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZ2VvbWV0cnkob2JqZWN0KTtcblxuICBnZW9tc0J5QXJjLmZvckVhY2goZmlsdGVyID09IG51bGxcbiAgICAgID8gZnVuY3Rpb24oZ2VvbXMpIHsgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9XG4gICAgICA6IGZ1bmN0aW9uKGdlb21zKSB7IGlmIChmaWx0ZXIoZ2VvbXNbMF0uZywgZ2VvbXNbZ2VvbXMubGVuZ3RoIC0gMV0uZykpIGFyY3MucHVzaChnZW9tc1swXS5pKTsgfSk7XG5cbiAgcmV0dXJuIGFyY3M7XG59XG4iLCJpbXBvcnQgYmlzZWN0IGZyb20gXCIuL2Jpc2VjdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3RzKSB7XG4gIHZhciBpbmRleGVzQnlBcmMgPSB7fSwgLy8gYXJjIGluZGV4IC0+IGFycmF5IG9mIG9iamVjdCBpbmRleGVzXG4gICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICBmdW5jdGlvbiBsaW5lKGFyY3MsIGkpIHtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICB2YXIgbyA9IGluZGV4ZXNCeUFyY1thXTtcbiAgICAgIGlmIChvKSBvLnB1c2goaSk7XG4gICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgbGluZShhcmMsIGkpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChmdW5jdGlvbihvKSB7IGdlb21ldHJ5KG8sIGkpOyB9KTtcbiAgICBlbHNlIGlmIChvLnR5cGUgaW4gZ2VvbWV0cnlUeXBlKSBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MsIGkpO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcywgaSkgeyBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IHBvbHlnb24oYXJjLCBpKTsgfSk7IH1cbiAgfTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZvciAodmFyIGkgaW4gaW5kZXhlc0J5QXJjKSB7XG4gICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbTsgKytrKSB7XG4gICAgICAgIHZhciBpaiA9IGluZGV4ZXNbal0sIGlrID0gaW5kZXhlc1trXSwgbjtcbiAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWtdKVtpID0gYmlzZWN0KG4sIGlqKV0gIT09IGlqKSBuLnNwbGljZShpLCAwLCBpaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn1cbiIsImltcG9ydCBiYm94IGZyb20gXCIuL2Jib3guanNcIjtcbmltcG9ydCB1bnRyYW5zZm9ybSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgdHJhbnNmb3JtKSB7XG4gIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgcXVhbnRpemVkXCIpO1xuXG4gIGlmICghdHJhbnNmb3JtIHx8ICF0cmFuc2Zvcm0uc2NhbGUpIHtcbiAgICBpZiAoISgobiA9IE1hdGguZmxvb3IodHJhbnNmb3JtKSkgPj0gMikpIHRocm93IG5ldyBFcnJvcihcIm4gbXVzdCBiZSDiiaUyXCIpO1xuICAgIGJveCA9IHRvcG9sb2d5LmJib3ggfHwgYmJveCh0b3BvbG9neSk7XG4gICAgdmFyIHgwID0gYm94WzBdLCB5MCA9IGJveFsxXSwgeDEgPSBib3hbMl0sIHkxID0gYm94WzNdLCBuO1xuICAgIHRyYW5zZm9ybSA9IHtzY2FsZTogW3gxIC0geDAgPyAoeDEgLSB4MCkgLyAobiAtIDEpIDogMSwgeTEgLSB5MCA/ICh5MSAtIHkwKSAvIChuIC0gMSkgOiAxXSwgdHJhbnNsYXRlOiBbeDAsIHkwXX07XG4gIH0gZWxzZSB7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveDtcbiAgfVxuXG4gIHZhciB0ID0gdW50cmFuc2Zvcm0odHJhbnNmb3JtKSwgYm94LCBrZXksIGlucHV0cyA9IHRvcG9sb2d5Lm9iamVjdHMsIG91dHB1dHMgPSB7fTtcblxuICBmdW5jdGlvbiBxdWFudGl6ZVBvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHQocG9pbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVHZW9tZXRyeShpbnB1dCkge1xuICAgIHZhciBvdXRwdXQ7XG4gICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG91dHB1dCA9IHt0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLCBnZW9tZXRyaWVzOiBpbnB1dC5nZW9tZXRyaWVzLm1hcChxdWFudGl6ZUdlb21ldHJ5KX07IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IG91dHB1dCA9IHt0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBxdWFudGl6ZVBvaW50KGlucHV0LmNvb3JkaW5hdGVzKX07IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogaW5wdXQuY29vcmRpbmF0ZXMubWFwKHF1YW50aXplUG9pbnQpfTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dC5pZCAhPSBudWxsKSBvdXRwdXQuaWQgPSBpbnB1dC5pZDtcbiAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKSBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgaWYgKGlucHV0LnByb3BlcnRpZXMgIT0gbnVsbCkgb3V0cHV0LnByb3BlcnRpZXMgPSBpbnB1dC5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUFyYyhpbnB1dCkge1xuICAgIHZhciBpID0gMCwgaiA9IDEsIG4gPSBpbnB1dC5sZW5ndGgsIHAsIG91dHB1dCA9IG5ldyBBcnJheShuKTsgLy8gcGVzc2ltaXN0aWNcbiAgICBvdXRwdXRbMF0gPSB0KGlucHV0WzBdLCAwKTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKChwID0gdChpbnB1dFtpXSwgaSkpWzBdIHx8IHBbMV0pIG91dHB1dFtqKytdID0gcDsgLy8gbm9uLWNvaW5jaWRlbnQgcG9pbnRzXG4gICAgaWYgKGogPT09IDEpIG91dHB1dFtqKytdID0gWzAsIDBdOyAvLyBhbiBhcmMgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICBvdXRwdXQubGVuZ3RoID0gajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgZm9yIChrZXkgaW4gaW5wdXRzKSBvdXRwdXRzW2tleV0gPSBxdWFudGl6ZUdlb21ldHJ5KGlucHV0c1trZXldKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVG9wb2xvZ3lcIixcbiAgICBiYm94OiBib3gsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgb2JqZWN0czogb3V0cHV0cyxcbiAgICBhcmNzOiB0b3BvbG9neS5hcmNzLm1hcChxdWFudGl6ZUFyYylcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBuKSB7XG4gIHZhciB0LCBqID0gYXJyYXkubGVuZ3RoLCBpID0gaiAtIG47XG4gIHdoaWxlIChpIDwgLS1qKSB0ID0gYXJyYXlbaV0sIGFycmF5W2krK10gPSBhcnJheVtqXSwgYXJyYXlbal0gPSB0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3ksIGFyY3MpIHtcbiAgdmFyIHN0aXRjaGVkQXJjcyA9IHt9LFxuICAgICAgZnJhZ21lbnRCeVN0YXJ0ID0ge30sXG4gICAgICBmcmFnbWVudEJ5RW5kID0ge30sXG4gICAgICBmcmFnbWVudHMgPSBbXSxcbiAgICAgIGVtcHR5SW5kZXggPSAtMTtcblxuICAvLyBTdGl0Y2ggZW1wdHkgYXJjcyBmaXJzdCwgc2luY2UgdGhleSBtYXkgYmUgc3Vic3VtZWQgYnkgb3RoZXIgYXJjcy5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGksIGopIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHQ7XG4gICAgaWYgKGFyYy5sZW5ndGggPCAzICYmICFhcmNbMV1bMF0gJiYgIWFyY1sxXVsxXSkge1xuICAgICAgdCA9IGFyY3NbKytlbXB0eUluZGV4XSwgYXJjc1tlbXB0eUluZGV4XSA9IGksIGFyY3Nbal0gPSB0O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgZSA9IGVuZHMoaSksXG4gICAgICAgIHN0YXJ0ID0gZVswXSxcbiAgICAgICAgZW5kID0gZVsxXSxcbiAgICAgICAgZiwgZztcblxuICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgIGYucHVzaChpKTtcbiAgICAgIGYuZW5kID0gZW5kO1xuICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdO1xuICAgICAgICB2YXIgZmcgPSBnID09PSBmID8gZiA6IGYuY29uY2F0KGcpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZmcuc3RhcnQgPSBmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZmcuZW5kID0gZy5lbmRdID0gZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBmLnVuc2hpZnQoaSk7XG4gICAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2cuZW5kXTtcbiAgICAgICAgdmFyIGdmID0gZyA9PT0gZiA/IGYgOiBnLmNvbmNhdChmKTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2dmLnN0YXJ0ID0gZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2dmLmVuZCA9IGYuZW5kXSA9IGdmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmID0gW2ldO1xuICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kXSA9IGY7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBlbmRzKGkpIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHAwID0gYXJjWzBdLCBwMTtcbiAgICBpZiAodG9wb2xvZ3kudHJhbnNmb3JtKSBwMSA9IFswLCAwXSwgYXJjLmZvckVhY2goZnVuY3Rpb24oZHApIHsgcDFbMF0gKz0gZHBbMF0sIHAxWzFdICs9IGRwWzFdOyB9KTtcbiAgICBlbHNlIHAxID0gYXJjW2FyYy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gaSA8IDAgPyBbcDEsIHAwXSA6IFtwMCwgcDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KSB7XG4gICAgZm9yICh2YXIgayBpbiBmcmFnbWVudEJ5RW5kKSB7XG4gICAgICB2YXIgZiA9IGZyYWdtZW50QnlFbmRba107XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgZGVsZXRlIGYuc3RhcnQ7XG4gICAgICBkZWxldGUgZi5lbmQ7XG4gICAgICBmLmZvckVhY2goZnVuY3Rpb24oaSkgeyBzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldID0gMTsgfSk7XG4gICAgICBmcmFnbWVudHMucHVzaChmKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpO1xuICBmbHVzaChmcmFnbWVudEJ5U3RhcnQsIGZyYWdtZW50QnlFbmQpO1xuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkgeyBpZiAoIXN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0pIGZyYWdtZW50cy5wdXNoKFtpXSk7IH0pO1xuXG4gIHJldHVybiBmcmFnbWVudHM7XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLCBuID0gaW5wdXQubGVuZ3RoLCBvdXRwdXQgPSBuZXcgQXJyYXkobik7XG4gICAgb3V0cHV0WzBdID0gKHgwICs9IGlucHV0WzBdKSAqIGt4ICsgZHg7XG4gICAgb3V0cHV0WzFdID0gKHkwICs9IGlucHV0WzFdKSAqIGt5ICsgZHk7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLFxuICAgICAgICBuID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHgxID0gTWF0aC5yb3VuZCgoaW5wdXRbMF0gLSBkeCkgLyBreCksXG4gICAgICAgIHkxID0gTWF0aC5yb3VuZCgoaW5wdXRbMV0gLSBkeSkgLyBreSk7XG4gICAgb3V0cHV0WzBdID0geDEgLSB4MCwgeDAgPSB4MTtcbiAgICBvdXRwdXRbMV0gPSB5MSAtIHkwLCB5MCA9IHkxO1xuICAgIHdoaWxlIChqIDwgbikgb3V0cHV0W2pdID0gaW5wdXRbal0sICsrajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuIiwiaW1wb3J0IHtcclxuICAgIGFubm90YXRpb24sXHJcbiAgICBhbm5vdGF0aW9uTGFiZWwsXHJcbiAgICBhbm5vdGF0aW9uQ2FsbG91dCxcclxuICAgIGFubm90YXRpb25DYWxsb3V0UmVjdCxcclxuICAgIGFubm90YXRpb25DYWxsb3V0Q2lyY2xlLFxyXG4gICAgYW5ub3RhdGlvblhZVGhyZXNob2xkLFxyXG59IGZyb20gJ2QzLXN2Zy1hbm5vdGF0aW9uJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEFubm90YXRpb25zKG1hcCkge1xyXG4gICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAvL2NsZWFyIHByZXZpb3VzXHJcbiAgICAgICAgem9vbUdyb3VwLnNlbGVjdEFsbCgnLmVtLWFubm90YXRpb24tZ3JvdXAnKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICBjb25zdCBhbm5vdGF0aW9uc0NvbmZpZyA9IG1hcC5hbm5vdGF0aW9uc19cclxuXHJcbiAgICAgICAgaWYgKGFubm90YXRpb25zQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIC8vIERlZmluZSBhIG1hcCB0aGF0IG1hcHMgdGhlIHR5cGUgc3RyaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIGFubm90YXRpb24gZnVuY3Rpb25cclxuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblR5cGVNYXAgPSB7XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uTGFiZWw6IGFubm90YXRpb25MYWJlbCxcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25DYWxsb3V0OiBhbm5vdGF0aW9uQ2FsbG91dCxcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25DYWxsb3V0UmVjdDogYW5ub3RhdGlvbkNhbGxvdXRSZWN0LFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGU6IGFubm90YXRpb25DYWxsb3V0Q2lyY2xlLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvblhZVGhyZXNob2xkOiBhbm5vdGF0aW9uWFlUaHJlc2hvbGQsIC8vIEFkZCBhbnkgb3RoZXIgdHlwZXMgeW91IG5lZWRcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFwIGFubm90YXRpb25zIGRhdGEgdG8gZW5zdXJlIGVhY2ggYW5ub3RhdGlvbiBoYXMgdGhlIHByb3BlciBmdW5jdGlvblxyXG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uc1dpdGhUeXBlcyA9IGFubm90YXRpb25zQ29uZmlnLmFubm90YXRpb25zLm1hcCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgJ3R5cGUnIHN0cmluZyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGFubm90YXRpb24gZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvblR5cGVNYXBbZC50eXBlXSB8fCBhbm5vdGF0aW9uTGFiZWwgLy8gRGVmYXVsdCB0byBhbm5vdGF0aW9uTGFiZWxcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmQsIHR5cGU6IGFubm90YXRpb25UeXBlIH0gLy8gVXBkYXRlICd0eXBlJyB3aXRoIHRoZSBmdW5jdGlvbiByZWZlcmVuY2VcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgY29uc3QgbWFrZUFubm90YXRpb25zID0gYW5ub3RhdGlvbigpLnR5cGUoYW5ub3RhdGlvbkxhYmVsKS5hbm5vdGF0aW9ucyhhbm5vdGF0aW9uc1dpdGhUeXBlcykuZWRpdE1vZGUoYW5ub3RhdGlvbnNDb25maWcuZWRpdE1vZGUpXHJcblxyXG4gICAgICAgICAgICAvLyBhcHBlbmQgbmV3XHJcbiAgICAgICAgICAgIHpvb21Hcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1hbm5vdGF0aW9uLWdyb3VwJykuY2FsbChtYWtlQW5ub3RhdGlvbnMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBjc3ZQYXJzZVJvd3MgfSBmcm9tICdkMy1kc3YnXHJcblxyXG4vLyBkcmF3IGdyaWQgY2FydG9ncmFtIGdlb21ldHJpZXNcclxuZXhwb3J0IGNvbnN0IGJ1aWxkR3JpZENhcnRvZ3JhbUJhc2UgPSBmdW5jdGlvbiAob3V0KSB7XHJcbiAgICBjb25zdCB6b29tR3JvdXAgPSBzZWxlY3QoYCNlbS16b29tLWdyb3VwLSR7b3V0LnN2Z0lkX31gKVxyXG4gICAgY29uc3QgZ3JpZEdyb3VwID0gem9vbUdyb3VwLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLWdyaWQtY29udGFpbmVyJylcclxuXHJcbiAgICAvLyBFbnN1cmUgbWFyZ2lucyBleGlzdCB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfID0gb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zXyB8fCB7IHRvcDogODAsIHJpZ2h0OiA4MCwgYm90dG9tOiA4MCwgbGVmdDogODAgfVxyXG5cclxuICAgIC8vIEdldCBncmlkIGxheW91dFxyXG4gICAgY29uc3QgZ3JpZExheW91dCA9IGdldEdyaWRMYXlvdXQob3V0KVxyXG4gICAgY29uc3QgcG9zaXRpb24gPSBwYXJzZUdyaWRMYXlvdXQoZ3JpZExheW91dClcclxuICAgIGNvbnN0IGdyaWREYXRhID0gZ2V0R3JpZERhdGEocG9zaXRpb24sIG91dClcclxuXHJcbiAgICAvLyBEcmF3IHRoZSBhcHByb3ByaWF0ZSBncmlkXHJcbiAgICBpZiAob3V0LmdyaWRDYXJ0b2dyYW1TaGFwZV8gPT09ICdoZXhhZ29uJykge1xyXG4gICAgICAgIGRyYXdIZXhhZ29uR3JpZChncmlkR3JvdXAsIGdyaWREYXRhLCBvdXQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdTcXVhcmVHcmlkKGdyaWRHcm91cCwgZ3JpZERhdGEsIG91dClcclxuICAgIH1cclxuXHJcbiAgICAvLyBDZW50ZXIgdGhlIGdyaWRcclxuICAgIGNlbnRlckdyaWQoZ3JpZEdyb3VwLCBvdXQud2lkdGhfLCBvdXQuaGVpZ2h0Xywgb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zXylcclxufVxyXG5cclxuLyoqIERldGVybWluZXMgdGhlIGdyaWQgbGF5b3V0IGJhc2VkIG9uIHNldHRpbmdzICovXHJcbmNvbnN0IGdldEdyaWRMYXlvdXQgPSAob3V0KSA9PiB7XHJcbiAgICBjb25zdCBzcXVhcmVHcmlkID0gYFxyXG4gICAgICAgICxJUywgICwgICxOTyxTRSxGSSwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsRUUsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLExWLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICxJRSxVSywgICwgICxESywgICxMVCwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsTkwsREUsUEwsICAsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLEJFLExVLENaLFNLLFVBLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICxGUixDSCxMSSxBVCxIVSxSTyxNRCwgICwgICwgICxcclxuICAgICAgICAsUFQsRVMsICAsSVQsU0ksSFIsUlMsQkcsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLEJBLE1FLE1LLCAgLCAgLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLEFMLEVMLFRSLEdFLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLE1ULCAgLCAgLCAgLCAgLENZLCAgLCAgLCAgYFxyXG5cclxuICAgIGNvbnN0IGhleGFnb25HcmlkID0gYFxyXG4gICAgICAgICxJUywgICwgICwgICwgICwgICwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsTk8sU0UsRkksRUUsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLExWLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICxJRSxVSywgICwgICxESywgICxMVCwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsTkwsREUsUEwsICAsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLEJFLExVLENaLFNLLFVBLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICxGUixDSCxMSSxBVCxIVSxSTyxNRCwgICwgICwgICxcclxuICAgICAgICAsUFQsRVMsICAsSVQsU0ksSFIsUlMsQkcsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLEJBLE1FLE1LLCAgLCAgLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLEFMLEVMLFRSLEdFLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLE1ULCAgLCAgLCAgLCAgLENZLCAgLCAgLCAgYFxyXG5cclxuICAgIHJldHVybiBvdXQuZ3JpZENhcnRvZ3JhbVBvc2l0aW9uc18gfHwgKG91dC5ncmlkQ2FydG9ncmFtU2hhcGVfID09PSAnaGV4YWdvbicgPyBoZXhhZ29uR3JpZCA6IHNxdWFyZUdyaWQpXHJcbn1cclxuXHJcbi8qKiBQYXJzZXMgdGhlIGdyaWQgbGF5b3V0IGFuZCBtYXBzIGVhY2ggSUQgdG8gaXRzIHBvc2l0aW9uICovXHJcbmNvbnN0IHBhcnNlR3JpZExheW91dCA9IChncmlkTGF5b3V0KSA9PiB7XHJcbiAgICBjb25zdCBwb3NpdGlvbkJ5SWQgPSBuZXcgTWFwKClcclxuICAgIGNzdlBhcnNlUm93cyhncmlkTGF5b3V0LnRyaW0oKSwgKHJvdywgaikgPT4ge1xyXG4gICAgICAgIHJvdy5mb3JFYWNoKChpZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoKGlkID0gaWQudHJpbSgpKSkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25CeUlkLnNldChpZCwgW2ksIGpdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbiAgICByZXR1cm4gcG9zaXRpb25CeUlkXHJcbn1cclxuXHJcbi8qKiBDb252ZXJ0cyBwYXJzZWQgcG9zaXRpb25zIGludG8gc3RydWN0dXJlZCBncmlkIGRhdGEgKi9cclxuY29uc3QgZ2V0R3JpZERhdGEgPSAocG9zaXRpb24sIG91dCkgPT4ge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocG9zaXRpb24sIChbaWQsIFtjb2wsIHJvd11dKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IG91dC5HZW9tZXRyaWVzLmdlb0pTT05zLm51dHNyZy5maW5kKChyZykgPT4gcmcucHJvcGVydGllcy5pZCA9PSBpZClcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICByb3csXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGZlYXR1cmUgPyBmZWF0dXJlLnByb3BlcnRpZXMubmEgOiAnJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG4vKiogRHJhd3MgYSBzcXVhcmUgZ3JpZCAqL1xyXG5jb25zdCBkcmF3U3F1YXJlR3JpZCA9IChncmlkR3JvdXAsIGdyaWREYXRhLCBvdXQpID0+IHtcclxuICAgIGNvbnN0IG51bUNvbHMgPSBNYXRoLm1heCguLi5ncmlkRGF0YS5tYXAoKGQpID0+IGQuY29sKSkgKyAxXHJcbiAgICBjb25zdCBudW1Sb3dzID0gTWF0aC5tYXgoLi4uZ3JpZERhdGEubWFwKChkKSA9PiBkLnJvdykpICsgMVxyXG5cclxuICAgIGNvbnN0IG1hcmdpbnMgPSBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfXHJcbiAgICBjb25zdCBjZWxsUGFkZGluZyA9IG91dC5ncmlkQ2FydG9ncmFtQ2VsbFBhZGRpbmdfIHx8IDAgLy8gS2VlcCBjZWxsIHBhZGRpbmdcclxuXHJcbiAgICBjb25zdCBjZWxsV2lkdGggPSAob3V0LndpZHRoXyAtIG1hcmdpbnMubGVmdCAtIG1hcmdpbnMucmlnaHQpIC8gbnVtQ29scyAtIGNlbGxQYWRkaW5nXHJcbiAgICBjb25zdCBjZWxsSGVpZ2h0ID0gKG91dC5oZWlnaHRfIC0gbWFyZ2lucy50b3AgLSBtYXJnaW5zLmJvdHRvbSkgLyBudW1Sb3dzIC0gY2VsbFBhZGRpbmdcclxuICAgIGNvbnN0IGNlbGxTaXplID0gTWF0aC5taW4oY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KVxyXG5cclxuICAgIGdyaWRHcm91cFxyXG4gICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLWNlbGwnKVxyXG4gICAgICAgIC5kYXRhKGdyaWREYXRhKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtY2VsbCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiBgdHJhbnNsYXRlKCR7ZC5jb2wgKiAoY2VsbFNpemUgKyBjZWxsUGFkZGluZykgKyBtYXJnaW5zLmxlZnR9LCAke2Qucm93ICogKGNlbGxTaXplICsgY2VsbFBhZGRpbmcpICsgbWFyZ2lucy50b3B9KWApXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmFwcGVuZCgncmVjdCcpLmF0dHIoJ3dpZHRoJywgY2VsbFNpemUpLmF0dHIoJ2hlaWdodCcsIGNlbGxTaXplKS5hdHRyKCdjbGFzcycsICdlbS1ncmlkLXJlY3QnKVxyXG5cclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoZC5pZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgY2VsbFNpemUgLyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBjZWxsU2l6ZSAvIDIgKyA1KVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbi8qKiBEcmF3cyBhIGhleGFnb24gZ3JpZCAqL1xyXG5jb25zdCBkcmF3SGV4YWdvbkdyaWQgPSAoZ3JpZEdyb3VwLCBncmlkRGF0YSwgb3V0KSA9PiB7XHJcbiAgICBjb25zdCBudW1Db2xzID0gTWF0aC5tYXgoLi4uZ3JpZERhdGEubWFwKChkKSA9PiBkLmNvbCkpICsgMVxyXG4gICAgY29uc3QgbnVtUm93cyA9IE1hdGgubWF4KC4uLmdyaWREYXRhLm1hcCgoZCkgPT4gZC5yb3cpKSArIDFcclxuXHJcbiAgICBjb25zdCBtYXJnaW5zID0gb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zX1xyXG4gICAgY29uc3QgY2VsbFBhZGRpbmcgPSBvdXQuZ3JpZENhcnRvZ3JhbUNlbGxQYWRkaW5nXyB8fCAwIC8vIEtlZXAgY2VsbCBwYWRkaW5nXHJcblxyXG4gICAgY29uc3QgYmFzZUhleFJhZGl1cyA9IE1hdGgubWluKFxyXG4gICAgICAgIChvdXQud2lkdGhfIC0gbWFyZ2lucy5sZWZ0IC0gbWFyZ2lucy5yaWdodCkgLyAobnVtQ29scyAqIDEuNSksXHJcbiAgICAgICAgKG91dC5oZWlnaHRfIC0gbWFyZ2lucy50b3AgLSBtYXJnaW5zLmJvdHRvbSkgLyAobnVtUm93cyAqIE1hdGguc3FydCgzKSlcclxuICAgIClcclxuXHJcbiAgICBjb25zdCBoZXhSYWRpdXMgPSBiYXNlSGV4UmFkaXVzXHJcbiAgICBjb25zdCBoZXhIZWlnaHQgPSBNYXRoLnNxcnQoMykgKiBoZXhSYWRpdXNcclxuXHJcbiAgICBncmlkR3JvdXBcclxuICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC1jZWxsJylcclxuICAgICAgICAuZGF0YShncmlkRGF0YSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1ncmlkLWNlbGwnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gZC5jb2wgKiAoMS41ICogaGV4UmFkaXVzICsgY2VsbFBhZGRpbmcpICsgbWFyZ2lucy5sZWZ0XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBkLnJvdyAqIChoZXhIZWlnaHQgKyBjZWxsUGFkZGluZykgKyAoZC5jb2wgJSAyID09PSAxID8gKGhleEhlaWdodCArIGNlbGxQYWRkaW5nKSAvIDIgOiAwKSArIG1hcmdpbnMudG9wXHJcbiAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBkcmF3SGV4YWdvbihoZXhSYWRpdXMpKS5hdHRyKCdjbGFzcycsICdlbS1ncmlkLWhleGFnb24nKVxyXG5cclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoZC5pZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgNSlcclxuICAgICAgICB9KVxyXG59XHJcblxyXG4vKiogR2VuZXJhdGVzIHRoZSBoZXhhZ29uIHBhdGggKi9cclxuY29uc3QgZHJhd0hleGFnb24gPSAocikgPT4ge1xyXG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLlBJIC8gM1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2IH0sIChfLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSByICogTWF0aC5jb3MoYW5nbGUgKiBpKVxyXG4gICAgICAgICAgICBjb25zdCB5ID0gciAqIE1hdGguc2luKGFuZ2xlICogaSlcclxuICAgICAgICAgICAgcmV0dXJuIGAke2kgPT09IDAgPyAnTScgOiAnTCd9JHt4fSwke3l9YFxyXG4gICAgICAgIH0pLmpvaW4oJyAnKSArICcgWidcclxuICAgIClcclxufVxyXG5cclxuLyoqIENlbnRlcnMgdGhlIGdyaWQgd2l0aGluIHRoZSBTVkcgKi9cclxuY29uc3QgY2VudGVyR3JpZCA9IChncmlkR3JvdXAsIHN2Z1dpZHRoLCBzdmdIZWlnaHQsIG1hcmdpbnMpID0+IHtcclxuICAgIGdyaWRHcm91cC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KClcclxuICAgICAgICBjb25zdCBkeCA9IChzdmdXaWR0aCAtIG1hcmdpbnMubGVmdCAtIG1hcmdpbnMucmlnaHQgLSBiYm94LndpZHRoKSAvIDIgLSBiYm94LnggKyBtYXJnaW5zLmxlZnRcclxuICAgICAgICBjb25zdCBkeSA9IChzdmdIZWlnaHQgLSBtYXJnaW5zLnRvcCAtIG1hcmdpbnMuYm90dG9tIC0gYmJveC5oZWlnaHQpIC8gMiAtIGJib3gueSArIG1hcmdpbnMudG9wXHJcbiAgICAgICAgZ3JpZEdyb3VwLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtkeH0sICR7ZHl9KWApXHJcbiAgICB9KVxyXG59XHJcbiIsImltcG9ydCB7IHVwZGF0ZUNTU1J1bGUgfSBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuLyogcHJldHRpZXItaWdub3JlICovXHJcbi8vIHRvIGtlZXAgdHJhY2sgb2YgZGVwcmVjYXRlZCBmdW5jdGlvbnMgd2hpbHN0IGtlZXBpbmcgdGhlIGN1cnJlbnQgdmVyc2lvbiBjbGVhbi5cclxuLy8gYWxzbyBwYXNzZXMgYW55IGltcG9ydGFudCBwYXJhbWV0ZXJzIHRvIHRoZSBuZXcgZnVuY3Rpb25zIChpZiB0aGV5IGV4aXN0KSBhbmQgb3ZlcndyaXRlcyBhbnkgQ1NTIHN0eWxlIHJ1bGVzLlxyXG4vLyBUbyBiZSByZW1vdmVkIHdoZW4gY29tcGxldGVseSBwaGFzZWQgb3V0LlxyXG5cclxuZXhwb3J0IGNvbnN0IGRlZmluZURlcHJlY2F0ZWRGdW5jdGlvbnMgPSAob3V0KSA9PiB7XHJcbiAgICAvLyBzdHlsZXNcclxuICAgIG91dC5zZWFGaWxsU3R5bGUgPSAodikgPT4gKGNvbnNvbGUud2Fybignc2VhRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1zZWEgQ1NTIGNsYXNzJyksIHVwZGF0ZUNTU1J1bGUoJy5lbS1zZWEnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5jbnRyZ0ZpbGxTdHlsZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdjbnRyZ0ZpbGxTdHlsZSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tY250cmcgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLWNudHJnJywnZmlsbCcsdiksIG91dCk7XHJcbiAgICBvdXQubnV0c3JnRmlsbFN0eWxlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ251dHNyZ0ZpbGxTdHlsZSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tbnV0c3JnIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1udXRzcmcnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5udXRzYm5TdHJva2UgPSAodikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignbnV0c2JuU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5ibl8wLCAuYm5fMSwgLmJuXzIsIC5ibl8zIENTUyBjbGFzc2VzJylcclxuICAgICAgICBpZiAodlsnMCddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8wJywnc3Ryb2tlJyx2WycwJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WycxJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzEnLCdzdHJva2UnLHZbJzEnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzInXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMicsJ3N0cm9rZScsdlsnMiddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8zJywnc3Ryb2tlJyx2WyczJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH07XHJcbiAgICBvdXQubnV0c2JuU3Ryb2tlV2lkdGggPSAodikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignbnV0c2JuU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmJuXzAsIC5ibl8xLCAuYm5fMiwgLmJuXzMgQ1NTIGNsYXNzZXMnKVxyXG4gICAgICAgIGlmICh2WycwJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzAnLCdzdHJva2Utd2lkdGgnLHZbJzAnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzEnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMScsJ3N0cm9rZS13aWR0aCcsdlsnMSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMiddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8yJywnc3Ryb2tlLXdpZHRoJyx2WycyJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WyczJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzMnLCdzdHJva2Utd2lkdGgnLHZbJzMnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC5ncmF0aWN1bGVTdHJva2UgPSAodikgPT4gKGNvbnNvbGUud2FybignZ3JhdGljdWxlU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1ncmF0aWN1bGUgQ1NTIGNsYXNzJyksIHVwZGF0ZUNTU1J1bGUoJy5lbS1ncmF0aWN1bGUnLCdzdHJva2UnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmdyYXRpY3VsZVN0cm9rZVdpZHRoID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2dyYXRpY3VsZVN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1ncmF0aWN1bGUgQ1NTIGNsYXNzJyksIHVwZGF0ZUNTU1J1bGUoJy5lbS1ncmF0aWN1bGUnLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG4gICAgb3V0Lm51dHNyZ1NlbEZpbGxTdHkgPSAodikgPT4gKGNvbnNvbGUud2FybignbnV0c3JnU2VsRmlsbFN0eSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIGhvdmVyQ29sb3IoKSBpbnN0ZWFkJyksIG91dC5ob3ZlckNvbG9yXyA9IHYsIG91dCk7XHJcbiAgICBvdXQudGl0bGVGb250U2l6ZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAudGl0bGVGb250U2l6ZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tdGl0bGUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXRpdGxlJywnZm9udC1zaXplJyx2KSwgb3V0KTtcclxuICAgIG91dC5zdWJ0aXRsZUZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5zdWJ0aXRsZUZvbnRTaXplKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdWJ0aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tc3VidGl0bGUnLCdmb250LXNpemUnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnN1YnRpdGxlRm9udFdlaWdodCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuc3VidGl0bGVGb250V2VpZ2h0KCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdWJ0aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tc3VidGl0bGUnLCdmb250LXdlaWdodCcsdiksIG91dCk7XHJcbiAgICBvdXQudGl0bGVGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50aXRsZUZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS10aXRsZScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnN1YnRpdGxlRmlsbCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuc3VidGl0bGVGaWxsKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdWJ0aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tc3VidGl0bGUnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5jbnRiblN0cm9rZSA9ICh2KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdjbnRiblN0cm9rZSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tY250Ym4gLmVtLWJuLWV1IC5lbS1ibi1lZnRhIC5lbS1ibi1jYyAuZW0tYm4tb3RoIENTUyBjbGFzc2VzJylcclxuICAgICAgICBpZiAodlsnZXUnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tZXUnLCdzdHJva2UnLHZbJ2V1J10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydlZnRhJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWVmdGEnLCdzdHJva2UnLHZbJ2VmdGEnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2NjJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWNjJywnc3Ryb2tlJyx2WydjYyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnb3RoJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLW90aCcsJ3N0cm9rZScsdlsnb3RoJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydjbyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZScsdlsnY28nXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC5jbnRiblN0cm9rZVdpZHRoID0gKHYpID0+IHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2NudGJuU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLWNudGJuIC5lbS13b3JsZGJuIC5lbS1ibi1ldSAuZW0tYm4tZWZ0YSAuZW0tYm4tY2MgLmVtLWJuLW90aCBDU1MgY2xhc3NlcycpXHJcbiAgICAgICAgaWYgKHZbJ2V1J10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWV1Jywnc3Ryb2tlLXdpZHRoJyx2WydldSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnZWZ0YSddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1lZnRhJywnc3Ryb2tlLXdpZHRoJyx2WydlZnRhJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydjYyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jYycsJ3N0cm9rZS13aWR0aCcsdlsnY2MnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ290aCddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1vdGgnLCdzdHJva2Utd2lkdGgnLHZbJ290aCddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnY28nXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY28nLCdzdHJva2Utd2lkdGgnLHZbJ2NvJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH07XHJcbiAgICBvdXQud29ybGRTdHJva2UgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS13b3JsZGJuIC5lbS1ibi1jbyAuZW0tYm4tZCBDU1MgY2xhc3NlcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS13b3JsZGJuJywnc3Ryb2tlJyx2KSwgb3V0KTtcclxuICAgIG91dC53b3JsZFN0cm9rZVdpZHRoID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZFN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS13b3JsZGJuIC5lbS1ibi1jbyAuZW0tYm4tZCBDU1MgY2xhc3NlcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS13b3JsZGJuJywnc3Ryb2tlLXdpZHRoJyx2KSwgb3V0KTtcclxuICAgIG91dC53b3JsZENvYXN0U3Ryb2tlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZENvYXN0U3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1ibi1jbyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY28nLCdzdHJva2UnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkQ29hc3RTdHJva2VXaWR0aCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAud29ybGRDb2FzdFN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1ibi1jbyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY28nLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkRmlsbFN0eWxlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZEZpbGxTdHlsZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0td29ybGRyZyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0td29ybGRyZycsJ2ZpbGwnLHYpLCBvdXQpOyBcclxuICAgIG91dC5jb2FzdGFsTWFyZ2luV2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmNvYXN0YWxNYXJnaW5XaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAjZW0tY29hc3QtbWFyZ2luIENTUyBydWxlJyksdXBkYXRlQ1NTUnVsZSgnI2VtLWNvYXN0LW1hcmdpbicsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7ICBcclxuICAgIG91dC5jb2FzdGFsTWFyZ2luQ29sb3IgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmNvYXN0YWxNYXJnaW5Db2xvcigpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAjZW0tY29hc3QtbWFyZ2luIENTUyBydWxlJyksdXBkYXRlQ1NTUnVsZSgnI2VtLWNvYXN0LW1hcmdpbicsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQuZm9udEZhbWlseSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuZm9udEZhbWlseSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tbWFwIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1tYXAnLCdmb250LWZhbWlseScsdiksIG91dCk7XHJcbiAgICBvdXQuYm90VHh0Rm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmJvdFR4dEZvbnRTaXplKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1mb290bm90ZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tZm9vdG5vdGUnLCdmb250LXNpemUnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZpbGwgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmJvdFR4dEZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZvb3Rub3RlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mb290bm90ZScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnNjYWxlYmFyRm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnNjYWxlYmFyRm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXNjYWxlYmFyLWxhYmVsIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zY2FsZWJhci1sYWJlbCcsJ2ZvbnQtc2l6ZScsdiksIG91dCk7XHJcbiAgICBvdXQuZnJhbWVTdHJva2UgPSAodik9PiAoY29uc29sZS53YXJuKCdtYXAuZnJhbWVTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZyYW1lIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mcmFtZScsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQuZnJhbWVTdHJva2VXaWR0aCA9ICh2KT0+IChjb25zb2xlLndhcm4oJ21hcC5mcmFtZVN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1mcmFtZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tZnJhbWUnLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG5cclxuICAgLy9vdGhlclxyXG4gICAgb3V0LnBzQ2xhc3NpZk1ldGhvZCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdwc0NsYXNzaWZNZXRob2QoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBwc0NsYXNzaWZpY2F0aW9uTWV0aG9kIGluc3RlYWQnKSxvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSB2LCBvdXQpO1xyXG4gICAgb3V0Lmdlb0NlbnRlciA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuZ2VvQ2VudGVyKCkgaXMgbm93IGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbWFwLnBvc2l0aW9uKHt4LHksen0pIGluc3RlYWQuJyksIG91dC5wb3NpdGlvbl8ueCA9IHZbMF0sIG91dC5wb3NpdGlvbl8ueSA9IHZbMV0sIG91dCk7XHJcbiAgICBvdXQucGl4ZWxTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5waXhlbFNpemUoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgeiBwcm9wZXJ0eSBpbiBtYXAucG9zaXRpb24oe3gseSx6fSkgaW5zdGVhZC4nKSwgb3V0LnBvc2l0aW9uXy56ID0gdiwgb3V0KTtcclxuICAgIG91dC5waXhTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5waXhlbFNpemUoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgeiBwcm9wZXJ0eSBpbiBtYXAucG9zaXRpb24oe3gseSx6fSkgaW5zdGVhZC4nKSwgb3V0LnBvc2l0aW9uXy56ID0gdiwgb3V0KTtcclxuICAgIG91dC50b29sdGlwVGV4dCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAudG9vbHRpcFRleHQoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtYXAudG9vbHRpcChjb25maWcudGV4dEZ1bmN0aW9uKSBpbnN0ZWFkLiBTZWUgQVBJIHJlZmVyZW5jZSBmb3IgZGV0YWlscy4nKSwgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHYsIG91dCk7XHJcbiAgICBvdXQuY2xhc3NpZk1ldGhvZCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY2xhc3NpZk1ldGhvZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC5jbGFzc2lmaWNhdGlvbk1ldGhvZCgpIGluc3RlYWQuJyksIG91dC5jbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSB2LG91dCk7XHJcbiAgICBvdXQudGhyZXNob2xkID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50aHJlc2hvbGQoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBtYXAudGhyZXNob2xkcygpIGluc3RlYWQuJyksIG91dC50aHJlc2hvbGRzXyA9IHYsb3V0KTtcclxuICAgIG91dC5wc1RocmVzaG9sZCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAucHNUaHJlc2hvbGQoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBtYXAucHNUaHJlc2hvbGRzKCkgaW5zdGVhZC4nKSwgb3V0LnBzVGhyZXNob2xkc18gPSB2LG91dCk7XHJcbiAgICBvdXQuY2xuYiA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY2xuYigpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC5udW1iZXJPZkNsYXNzZXMoKSBpbnN0ZWFkLicpLCBvdXQubnVtYmVyT2ZDbGFzc2VzXyA9IHYsb3V0KTtcclxuICAgIG91dC5udXRzTHZsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5udXRzTHZsKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLm51dHNMZXZlbCgpIGluc3RlYWQuJyksIG91dC5udXRzTGV2ZWxfID0gdixvdXQpO1xyXG4gICAgb3V0LmxnID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sZygpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC5sYW5ndWFnZSgpIGluc3RlYWQuJyksIG91dC5sYW5ndWFnZV8gPSB2LG91dCk7XHJcbiAgICBvdXQuYm90dG9tVGV4dCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdib3R0b21UZXh0IGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIHRoZSBmb290bm90ZSgpIG1ldGhvZCBhbmQgZW0tZm9vdG5vdGUgQ1NTIGNsYXNzIGluc3RlYWQuJyksb3V0LmZvb3Rub3RlXyA9IHYsb3V0KTtcclxuICAgIG91dC5ib3RUeHRGb250U2l6ZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdib3RUeHRGb250U2l6ZSBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSB0aGUgZW0tZm9vdG5vdGUgQ1NTIGNsYXNzIGluc3RlYWQuJyksb3V0KTtcclxuICAgIG91dC5ib3RUeHRGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdFR4dEZpbGwgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2UgdGhlIGVtLWZvb3Rub3RlIENTUyBjbGFzcyBpbnN0ZWFkLicpLG91dCk7XHJcbiAgICBvdXQuYm90VHh0UGFkZGluZyA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdib3RUeHRQYWRkaW5nIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIHRoZSBlbS1mb290bm90ZSBDU1MgY2xhc3MgaW5zdGVhZC4nKSxvdXQpO1xyXG4gICAgb3V0LmJvdFR4dFRvb2x0aXBUeHQgPSAodikgPT4gKGNvbnNvbGUud2FybignYm90VHh0VG9vbHRpcFR4dCBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBmb290bm90ZVRvb2x0aXBUZXh0KCkgaW5zdGVhZC4nKSxvdXQpO1xyXG4gICAgb3V0LnRvb2x0aXBTaG93RmxhZ3MgPSAodikgPT4oY29uc29sZS53YXJuKCd0b29sdGlwU2hvd0ZsYWdzIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC50b29sdGlwKHtzaG93RmxhZ3N9KSBpbnN0ZWFkLicpLG91dC50b29sdGlwXy5zaG93RmxhZ3MgPSB2LG91dCk7XHJcbiAgICBvdXQuY29sb3JGdW4gPSAodikgPT4oY29uc29sZS53YXJuKCdjb2xvckZ1biBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQuY29sb3JGdW5jdGlvbigpIGluc3RlYWQuJyksb3V0LmNvbG9yRnVuY3Rpb25fID0gdixvdXQpO1xyXG4gICAgb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuID0gKHYpPT4oY29uc29sZS53YXJuKCdmaWx0ZXJzRGVmaW5pdGlvbkZ1biBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbigpIGluc3RlYWQuJyksb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fID0gdixvdXQpO1xyXG4gICAgXHJcbiAgICAvL2xhYmVsbGluZ1xyXG4gICAgb3V0LmxhYmVsbGluZyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2xhYmVsbGluZyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHt9KSBjb25maWd1cmF0aW9uIG9iamVjdCBpbnN0ZWFkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKSxvdXQpO1xyXG4gICAgb3V0LmxhYmVsc0NvbmZpZyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2xhYmVsc0NvbmZpZyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtjb25maWc6eW91ckNvbmZpZ30pIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dC5sYWJlbHNfID1PYmplY3QuYXNzaWduKG91dC5sYWJlbHNfIHx8IHt9LCB7IGNvbmZpZzogdiB9KSxvdXQpO1xyXG4gICAgb3V0LnN0YXRMYWJlbHNQb3NpdGlvbnMgPSAodikgPT4oY29uc29sZS53YXJuKCdzdGF0TGFiZWxzUG9zaXRpb25zIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe3N0YXRMYWJlbHNQb3NpdGlvbnM6eW91clBvc2l0aW9uc30pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dC5sYWJlbHNfID0gT2JqZWN0LmFzc2lnbihvdXQubGFiZWxzXyB8fCB7fSwgeyBzdGF0TGFiZWxzUG9zaXRpb25zOiB2IH0pLG91dCk7XHJcbiAgICBvdXQubGFiZWxzVG9TaG93ID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxzVG9TaG93IGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe2xhYmVsRmlsdGVyRnVuY3Rpb246eW91ckZ1bmN0aW9uKHJlZ2lvbixtYXApfSkgZnVuY3Rpb24gaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0KTtcclxuICAgIG91dC5sYWJlbFNoYWRvd3NUb1Nob3cgPSAodikgPT4oY29uc29sZS53YXJuKCdsYWJlbFNoYWRvd3NUb1Nob3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxGaWx0ZXJGdW5jdGlvbjp5b3VyRnVuY3Rpb24ocmVnaW9uLG1hcCl9KSBmdW5jdGlvbiBpbnN0ZWFkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKSxvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93ID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxTaGFkb3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxTaGFkb3c6Ym9vbGVhbn0pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxTaGFkb3dXaWR0aCA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2xhYmVsU2hhZG93IGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe2xhYmVsU2hhZG93OmJvb2xlYW59KSBpbnN0ZWFkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKSxvdXQpO1xyXG4gICAgb3V0LmxhYmVsRmlsdGVyRnVuY3Rpb24gPSh2KSA9Pihjb25zb2xlLndhcm4oJ2xhYmVsRmlsdGVyRnVuY3Rpb24gaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxGaWx0ZXJGdW5jdGlvbjp5b3VyRnVuY3Rpb24ocmVnaW9uLG1hcCl9KSBpbnN0ZWFkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKSxvdXQpO1xyXG4gICAgb3V0LmxhYmVsRmlsbCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxGaWxsKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdGF0LWxhYmVscyBDU1MgY2xhc3MnKSwgb3V0KTtcclxuICAgIG91dC5sYWJlbFN0cm9rZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU3Ryb2tlV2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsT3BhY2l0eSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxPcGFjaXR5KCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdGF0LWxhYmVscyBDU1MgY2xhc3MnKSwgb3V0KTtcclxuICAgIG91dC5sYWJlbFZhbHVlc0ZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbFZhbHVlc0ZvbnRTaXplKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdGF0LWxhYmVscyBDU1MgY2xhc3MnKSwgb3V0KTtcclxuICAgIG91dC5sYWJlbFNoYWRvd1dpZHRoID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbFNoYWRvd1dpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdGF0LWxhYmVscy1zaGFkb3dzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93Q29sb3IgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsU2hhZG93Q29sb3IoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzLXNoYWRvd3MgQ1NTIGNsYXNzJyksIG91dCk7XHJcblxyXG4gICAgb3V0LmNvdW50cmllc1RvU2hvdyA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY291bnRyaWVzVG9TaG93KCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIG1hcC5maWx0ZXJHZW9tZXRyaWVzRnVuY3Rpb24oKSBmdW5jdGlvbiBpZiB5b3Ugd2lzaCB0byBmaWx0ZXIgdGhlIGRlZmF1bHQgZ2VvbWV0cmllcy4nKSwgb3V0KTtcclxuICAgIG91dC5ib3JkZXJzVG9TaG93ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5ib3JkZXJzVG9TaG93KCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIG1hcC5maWx0ZXJHZW9tZXRyaWVzRnVuY3Rpb24oKSBmdW5jdGlvbiBpZiB5b3Ugd2lzaCB0byBmaWx0ZXIgdGhlIGRlZmF1bHQgZ2VvbWV0cmllcy4nKSwgb3V0KTtcclxufVxyXG4iLCIvLyB0YWtlcyBjYXJlIG9mIHRoZSBtYXAncyBnZW9tZXRyaWVzXHJcbmltcG9ydCB7IGpzb24gfSBmcm9tICdkMy1mZXRjaCdcclxuaW1wb3J0IHsgZmVhdHVyZSB9IGZyb20gJ3RvcG9qc29uLWNsaWVudCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cyB9IGZyb20gJy4vdXRpbHMnXHJcbmltcG9ydCB7IGtvc292b0JuRmVhdHVyZXMgfSBmcm9tICcuL2tvc292bydcclxuaW1wb3J0IHsgZ2VvR3JhdGljdWxlIH0gZnJvbSAnZDMtZ2VvJ1xyXG5cclxuLy8gR2VvbWV0cmllcyBjbGFzcyB3cmFwcGVkIGFzIGEgZnVuY3Rpb25cclxuZXhwb3J0IGNvbnN0IEdlb21ldHJpZXMgPSBmdW5jdGlvbiAobWFwLCB3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICBsZXQgb3V0ID0ge31cclxuXHJcbiAgICAvLyBkZWZhdWx0c1xyXG4gICAgb3V0LmRlZmF1bHRHZW9EYXRhID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuYWxsTlVUU0dlb0RhdGEgPSB1bmRlZmluZWRcclxuICAgIG91dC5nZW9KU09OcyA9IHtcclxuICAgICAgICBtaXhlZDogeyByZzA6IHVuZGVmaW5lZCwgcmcxOiB1bmRlZmluZWQsIHJnMjogdW5kZWZpbmVkLCByZzM6IHVuZGVmaW5lZCB9LFxyXG4gICAgICAgIGNudGJuOiB1bmRlZmluZWQsXHJcbiAgICAgICAgY250cmc6IHVuZGVmaW5lZCxcclxuICAgICAgICBudXRzYm46IHVuZGVmaW5lZCxcclxuICAgICAgICBudXRzcmc6IHVuZGVmaW5lZCxcclxuICAgICAgICBncmE6IHVuZGVmaW5lZCxcclxuICAgICAgICB3b3JsZHJnOiB1bmRlZmluZWQsXHJcbiAgICAgICAgd29ybGRibjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGtvc292bzogdW5kZWZpbmVkLFxyXG4gICAgfVxyXG5cclxuICAgIC8vIHVzZXIgZGVmaW5lZCBnZW9tZXRyaWVzIChsYXllcnMpXHJcbiAgICBvdXQudXNlckdlb21ldHJpZXMgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvLyB1c2VyIGRlZmluZWQgc3RhdGlzdGljYWwgcmVnaW9uc1xyXG4gICAgb3V0LnN0YXRpc3RpY2FsUmVnaW9ucyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vY2VudHJvaWRzIGZvciBwcm9wIHN5bWJvbHMgZXRjXHJcbiAgICBvdXQuY2VudHJvaWRzRGF0YSA9IHVuZGVmaW5lZCAvL3Jhd1xyXG4gICAgb3V0LmNlbnRyb2lkc0ZlYXR1cmVzID0gdW5kZWZpbmVkIC8vZ2VvanNvbiBmZWF0dXJlc1xyXG5cclxuICAgIC8vIGdldCBnZW9qc29uIGZlYXR1cmVzIG9mIGFsbCBzdGF0aXN0aWNhbCByZWdpb25zXHJcbiAgICBvdXQuZ2V0UmVnaW9uRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG1hcC5nZW9fID09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5nZW9KU09Ocy53b3JsZHJnXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW291dC5nZW9KU09Ocy5taXhlZC5yZzAsIG91dC5nZW9KU09Ocy5taXhlZC5yZzEsIG91dC5nZW9KU09Ocy5taXhlZC5yZzIsIG91dC5nZW9KU09Ocy5taXhlZC5yZzNdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0Lmdlb0pTT05zLm51dHNyZy5jb25jYXQob3V0Lmdlb0pTT05zLmNudHJnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFuZCBwYXJzZXMgJ2RlZmF1bHQnIGdlbyBkYXRhIChmb3IgTlVUUyBvciBXb3JsZCBtYXBzKVxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0RGVmYXVsdEdlb0RhdGEgPSBmdW5jdGlvbiAoZ2VvLCBmaWx0ZXJHZW9tZXRyaWVzRnVuY3Rpb24sIG51dHNMZXZlbCkge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gb3V0LmdldERlZmF1bHRHZW9EYXRhUHJvbWlzZSgpXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxyXG4gICAgICAgICAgICAudGhlbigocmVzdWx0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckdlb21ldHJpZXNGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBmaWx0ZXJHZW9tZXRyaWVzRnVuY3Rpb24ocmVzdWx0cylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dC5hbGxOVVRTR2VvRGF0YSA9IHJlc3VsdHNcclxuICAgICAgICAgICAgICAgIG91dC5kZWZhdWx0R2VvRGF0YSA9IHJlc3VsdHNbMF1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAod2l0aENlbnRlclBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5jZW50cm9pZHNEYXRhID0gbnV0c0xldmVsID09PSAnbWl4ZWQnID8gW3Jlc3VsdHNbNF0sIHJlc3VsdHNbNV0sIHJlc3VsdHNbNl0sIHJlc3VsdHNbN11dIDogcmVzdWx0c1sxXVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzV29ybGQgPSBnZW8gPT09ICdXT1JMRCdcclxuICAgICAgICAgICAgICAgIC8vIERlY29kZSBUb3BvSlNPTiB0byBHZW9KU09OXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNXb3JsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy53b3JsZHJnID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLkNOVFJfUkdfMjBNXzIwMjBfNDMyNikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMud29ybGRibiA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5DTlRSX0JOXzIwTV8yMDIwXzQzMjYpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLmtvc292byA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5OVVRTX0JOXzIwTV8yMDIxX1JTX1hLX2JvcmRlcikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMuZ3JhdGljdWxlID0gW2dlb0dyYXRpY3VsZSgpLnN0ZXAoWzMwLCAzMF0pKCldXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5ncmF0aWN1bGUgPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMuZ3JhKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5udXRzcmcgPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMubnV0c3JnKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5udXRzYm4gPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMubnV0c2JuKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5jbnRyZyA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5jbnRyZykuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMuY250Ym4gPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMuY250Ym4pLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGZvciBOdXRzMkpTT04gdG9wb2pzb24gZGF0YS5cclxuICAgICAqL1xyXG4gICAgb3V0LmdldERlZmF1bHRHZW9EYXRhUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBudXRzTGV2ZWxzID0gWzAsIDEsIDIsIDNdXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxyXG5cclxuICAgICAgICBjb25zdCBidWlsZFVybCA9IChiYXNlLCB5ZWFyLCBnZW8sIHByb2osIHNjYWxlLCBsZXZlbCwgd2l0aENlbnRlciA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBwYXRoID0gYCR7YmFzZX0vJHt5ZWFyfWBcclxuXHJcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgZ2VvIHBhcnQgaWYgaXQncyBzcGVjaWZpZWQgYW5kIG5vdCAnRVVSJyBvciAnV09STEQnXHJcbiAgICAgICAgICAgIGlmIChnZW8gJiYgZ2VvICE9PSAnRVVSJyAmJiBnZW8gIT09ICdXT1JMRCcpIHBhdGggKz0gYC8ke2dlb31gXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcHJvamVjdGlvblxyXG4gICAgICAgICAgICBwYXRoICs9IGAvJHtnZW8gPT0gJ1dPUkxEJyA/ICc0MzI2JyA6IHByb2p9YCAvLyB3b3JsZCBnZW9kYXRhIGlzIGFsd2F5cyA0MzI2LCB0aGVuIHJlcHJvamVjdGVkXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgc2NhbGUgb25seSBpZiBub3QgdXNpbmcgY2VudGVyIHBvaW50c1xyXG4gICAgICAgICAgICBpZiAoIXdpdGhDZW50ZXIgJiYgc2NhbGUpIHBhdGggKz0gYC8ke3NjYWxlfWBcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgYXBwcm9wcmlhdGUgZmlsZSBuYW1lXHJcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3dpdGhDZW50ZXIgPyAnbnV0c3B0XycgOiAnJ30ke2xldmVsfS5qc29uYFxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhdGhcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJyAmJiBtYXAuZ2VvXyAhPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICBudXRzTGV2ZWxzLmZvckVhY2goKGx2bCkgPT4gcHJvbWlzZXMucHVzaChqc29uKGJ1aWxkVXJsKG1hcC5udXRzMmpzb25CYXNlVVJMXywgbWFwLm51dHNZZWFyXywgbWFwLmdlb18sIG1hcC5wcm9qXywgbWFwLnNjYWxlXywgbHZsKSkpKVxyXG4gICAgICAgICAgICBpZiAod2l0aENlbnRlclBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgbnV0c0xldmVscy5mb3JFYWNoKChsdmwpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChqc29uKGJ1aWxkVXJsKG1hcC5udXRzMmpzb25CYXNlVVJMXywgbWFwLm51dHNZZWFyXywgbWFwLmdlb18sIG1hcC5wcm9qXywgbWFwLnNjYWxlXywgbHZsLCB0cnVlKSkpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1hcC5nZW9fID09PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkTWFwVG9wb2pzb25VUkwgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUuaW5jbHVkZXMoJ2VjLmV1cm9wYS5ldScpXHJcbiAgICAgICAgICAgICAgICA/ICdodHRwczovL2VjLmV1cm9wYS5ldS9hc3NldHMvZXN0YXQvRS9FNC9naXNjby9JTUFHRS9XT1JMRF80MzI2Lmpzb24nXHJcbiAgICAgICAgICAgICAgICA6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXVyb3N0YXQvZXVyb3N0YXQtbWFwL21hc3Rlci9zcmMvYXNzZXRzL3RvcG9qc29uL1dPUkxEXzQzMjYuanNvbidcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChqc29uKHdvcmxkTWFwVG9wb2pzb25VUkwpKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goanNvbihidWlsZFVybChtYXAubnV0czJqc29uQmFzZVVSTF8sIG1hcC5udXRzWWVhcl8sIG1hcC5nZW9fLCBtYXAucHJval8sIG1hcC5zY2FsZV8sIG1hcC5udXRzTGV2ZWxfKSkpXHJcbiAgICAgICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGpzb24oYnVpbGRVcmwobWFwLm51dHMyanNvbkJhc2VVUkxfLCBtYXAubnV0c1llYXJfLCBtYXAuZ2VvXywgbWFwLnByb2pfLCBtYXAuc2NhbGVfLCBtYXAubnV0c0xldmVsXywgdHJ1ZSkpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvbWlzZXNcclxuICAgIH1cclxuICAgIC8qKiBDaGVja3MgaWYgYWxsIGdlbyBkYXRhIGlzIHJlYWR5ICovXHJcbiAgICBvdXQuaXNHZW9SZWFkeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIW91dC5kZWZhdWx0R2VvRGF0YSAmJiAhb3V0LnVzZXJHZW9tZXRyaWVzKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgbGV0IGFsbFJlYWR5ID0gdHJ1ZVxyXG5cclxuICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG51bGwsIChpbnNldCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc2V0Lkdlb21ldHJpZXMuaXNHZW9SZWFkeSgpKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxSZWFkeSA9IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gYWxsUmVhZHlcclxuICAgIH1cclxuXHJcbiAgICBvdXQuc2V0VXNlckdlb21ldHJpZXMgPSBmdW5jdGlvbiAoZ2VvbWV0cmllcykge1xyXG4gICAgICAgIHRoaXMudXNlckdlb21ldHJpZXMgPSBnZW9tZXRyaWVzXHJcblxyXG4gICAgICAgIC8vIGdldCByZWdpb25zIHRoYXQgYXJlIGxpbmtlZCB0byB0aGUgc3RhdGlzdGljc1xyXG4gICAgICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbWV0cnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LnN0YXRpc3RpY2FsUmVnaW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0aXN0aWNhbFJlZ2lvbnMgPSBnZW9tZXRyeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBvdXQuYWRkRGVmYXVsdEdlb21ldHJpZXNUb01hcCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGRyYXdHcmF0aWN1bGUsIHBhdGhGdW5jdGlvbiwgbnV0c0xldmVsLCBudXRzWWVhciwgZ2VvLCBwcm9qLCBzY2FsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLmdyYXRpY3VsZSAmJiBkcmF3R3JhdGljdWxlKSB7XHJcbiAgICAgICAgICAgIC8vZHJhdyBncmF0aWN1bGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1ncmF0aWN1bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMuZ3JhdGljdWxlKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMuY250cmcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jbnRyZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY250cmcnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLmNudHJnKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoY250cmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaWRzIGZvciBSUyBhbmQgRUwgc28gdGhhdCB3ZSBjYW4gY2hvb3NlIG5vdCB0byBhZGQgc3RhdGlzdGljYWwgZGF0YSB0byB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY250cmcucHJvcGVydGllcy5pZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PSAnUlMnIHx8IGlkID09ICdFTCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbS1jbnRyZy0nICsgaWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IHdvcmxkIG1hcFxyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLndvcmxkcmcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS13b3JsZHJnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS13b3JsZHJnJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy53b3JsZHJnKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgTlVUUyByZWdpb25zXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMubnV0c3JnKSB7XHJcbiAgICAgICAgICAgIGlmIChudXRzTGV2ZWwgPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzAgPSB0aGlzLmdlb0pTT05zLm51dHNyZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzEgPSBmZWF0dXJlKG91dC5hbGxOVVRTR2VvRGF0YVsxXSwgb3V0LmFsbE5VVFNHZW9EYXRhWzFdLm9iamVjdHMubnV0c3JnKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzIgPSBmZWF0dXJlKG91dC5hbGxOVVRTR2VvRGF0YVsyXSwgb3V0LmFsbE5VVFNHZW9EYXRhWzJdLm9iamVjdHMubnV0c3JnKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzMgPSBmZWF0dXJlKG91dC5hbGxOVVRTR2VvRGF0YVszXSwgb3V0LmFsbE5VVFNHZW9EYXRhWzNdLm9iamVjdHMubnV0c3JnKS5mZWF0dXJlc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZm9yIG1peGVkIE5VVFMsIHdlIGFkZCBldmVyeSBOVVRTIHJlZ2lvbiBhY3Jvc3MgYWxsIGxldmVscyBhbmQgaGlkZSBsZXZlbCAxLDIsMyBieSBkZWZhdWx0LCBvbmx5IHNob3dpbmcgdGhlbSB3aGVuIHRoZXkgaGF2ZSBzdGF0IGRhdGFcclxuICAgICAgICAgICAgICAgIC8vIHNlZSB1cGRhdGVDbGFzc2lmaWNhdGlvbiBhbmQgdXBkYXRlU3R5bGUgaW4gbWFwLWNob3JvcGxldGguanMgZm9yIGhpZGluZy9zaG93aW5nXHJcbiAgICAgICAgICAgICAgICA7W3RoaXMuZ2VvSlNPTnMubWl4ZWQucmcwLCB0aGlzLmdlb0pTT05zLm1peGVkLnJnMSwgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzIsIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmczXS5mb3JFYWNoKChyLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hcHBlbmQgZWFjaCBudXRzIGxldmVsIHRvIG1hcFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBlbS1udXRzcmcgZW0tbnV0c3JnLSR7aX1gKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEocilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignbHZsJywgaSkgLy90byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIG51dHMgbGV2ZWxzXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vYWRkIGtvc292b1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbyA9PSAnRVVSJyAmJiAocHJvaiA9PSAnMzAzNScgfHwgcHJvaiA9PSAnNDMyNicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGtvc292byBtYW51YWxseVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZEtvc292b0JvcmRlcihjb250YWluZXIsIHBhdGhGdW5jdGlvbiwgcHJvaiwgc2NhbGUsIG51dHNZZWFyKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBudXRzTGV2ZWwgaXMgbm90ICdtaXhlZCdcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMubnV0c3JnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBjb3VudHJ5IGJvdW5kYXJpZXNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5jbnRibikge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNudGJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jbnRibicpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMuY250Ym4pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmV1ID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZWZ0YSA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNjID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMub3RoID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY28gPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChibikgPT4gJ2VtLWJuLScgKyBibi5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTGlzdCA9IFtdXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmV1ID09PSAnVCcpIGNsYXNzTGlzdC5wdXNoKCdlbS1ibi1ldScpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZWZ0YSA9PT0gJ1QnKSBjbGFzc0xpc3QucHVzaCgnZW0tYm4tZWZ0YScpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY2MgPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLWNjJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5vdGggPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLW90aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY28gPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLWNvJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTGlzdC5qb2luKCcgJykgLy8gVXNlIGpvaW4gd2l0aCBhIHNwYWNlIHRvIGNyZWF0ZSBhIHZhbGlkIGNsYXNzIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBOVVRTIGJvdW5kYXJpZXNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5udXRzYm4gJiYgbnV0c0xldmVsICE9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VvSlNPTnMubnV0c2JuLnNvcnQoZnVuY3Rpb24gKGJuMSwgYm4yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYm4yLnByb3BlcnRpZXMubHZsIC0gYm4xLnByb3BlcnRpZXMubHZsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tbnV0c2JuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1udXRzYm4nKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLm51dHNibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmV1ID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZWZ0YSA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNjID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMub3RoID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY28gPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BzID0gYm4ucHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vS09TT1ZPXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmlkID4gMTAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZW0ta29zb3ZvLWJuJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuY28gPT09ICdUJykgcmV0dXJuICdlbS1ibi1jbydcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbCA9IFsnZW0tYm4tJyArIHByb3BzLmx2bF1cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChibi5vdGggPT09IFwiVFwiKSBjbC5wdXNoKFwiYm4tb3RoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbC5qb2luKCcgJylcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgd29ybGQgYm91bmRhcmllc1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLndvcmxkYm4pIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS13b3JsZGJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS13b3JsZGJuJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5QT0xfU1RBVCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kaXNwdXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2VtLWJuLWQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLkNPQVNfRkxBRyA9PT0gJ1QnID8gJ2VtLWJuLWNvJyA6ICdlbS13b3JsZGJuJ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8uYXR0cihcImlkXCIsIChibikgPT4gYm4ucHJvcGVydGllcy5DTlRSX0JOX0lEKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMua29zb3ZvKSB7XHJcbiAgICAgICAgICAgIC8vYWRkIGtvc292byB0byB3b3JsZCBtYXBzXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0ta29zb3ZvLWJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1rb3Nvdm8tYm4nKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLmtvc292bylcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRLb3Nvdm9Cb3JkZXIoY29udGFpbmVyLCBwYXRoRnVuY3Rpb24sIHByb2osIHNjYWxlLCBudXRzWWVhcikge1xyXG4gICAgICAgIGxldCBrb3Nvdm9GZWF0dXJlID0ga29zb3ZvQm5GZWF0dXJlc1tudXRzWWVhcl0gPyBrb3Nvdm9CbkZlYXR1cmVzW251dHNZZWFyXVtwcm9qXVtzY2FsZV0gOiBrb3Nvdm9CbkZlYXR1cmVzWzIwMjRdW3Byb2pdW3NjYWxlXVxyXG4gICAgICAgIGxldCBrb3Nvdm9CbiA9IGZlYXR1cmUoa29zb3ZvRmVhdHVyZSwgJ251dHNibl8xJykuZmVhdHVyZXNcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1rb3Nvdm8tYm4nKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0ta29zb3ZvLWJuIGVtLWJuLWNjJylcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXRhKGtvc292b0JuKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyB1c2VyLWRlZmluZWQgZ2VvbWV0cmllcyB0byB0aGUgbWFwXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBtYXAuZ2VvbWV0cmllcyhbXHJcbiAgICAgKiAgeyBpZDogJ3JlZ2lvbnMnLCBmZWF0dXJlczogZ2VvSlNPTi5mZWF0dXJlcywgY2xhc3M6IChmZWF0dXJlKSA9PiAncmVnaW9uJyB9LFxyXG4gICAgICogIHsgaWQ6ICdib3JkZXJzJywgZmVhdHVyZXM6IGJvcmRlcnNEYXRhLCBjbGFzczogKGZlYXR1cmUpID0+ICdib3JkZXInIH1cclxuICAgICAqIF0pXHJcbiAgICAgKiBAcGFyYW0gZ2VvbWV0cmllcyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgZ2VvSlNPTiBmZWF0dXJlc1xyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lciBkMyBzZWxlY3Rpb24gb2YgdGhlIHBhcmVudCB0aGF0IHdlIGFwcGVuZCB0aGUgZ2VvbWV0cmllcyB0b1xyXG4gICAgICogQHBhcmFtIHBhdGhGdW5jdGlvbiBkMyBwYXRoIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIG91dC5hZGRVc2VyR2VvbWV0cmllc1RvTWFwID0gZnVuY3Rpb24gKGdlb21ldHJpZXMsIGNvbnRhaW5lciwgcGF0aEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tZXRyeSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgZ2VvbWV0cnkuc3RhdGlzdGljYWxSZWdpb25zID8gJ2VtLXVzZXItcmVnaW9ucycgOiAnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGdlb21ldHJ5LmNsYXNzID8gZ2VvbWV0cnkuY2xhc3MgOiAnJylcclxuXHJcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IGdyb3VwLnNlbGVjdEFsbCgncGF0aCcpLmRhdGEoZ2VvbWV0cnkuZmVhdHVyZXMpLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBjYWxsIGNoYWluIG1vZGlmaWNhdGlvbnMgdGhyb3VnaCBvbkVhY2hcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW9tZXRyeS5vbkVhY2ggPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm9uRWFjaChlbGVtZW50cylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgbWFwVGVtcGxhdGUgfSBmcm9tICcuL21hcC10ZW1wbGF0ZSdcclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBpbnNldCBtYXBzIGZvciBhIG1hcCB0ZW1wbGF0ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJ1aWxkSW5zZXRzID0gZnVuY3Rpb24gKG91dCwgd2l0aENlbnRlclBvaW50cykge1xyXG4gICAgaWYgKCFvdXQuaW5zZXRCb3hQb3NpdGlvbl8pIHtcclxuICAgICAgICBvdXQuaW5zZXRCb3hQb3NpdGlvbl8gPSBbb3V0LndpZHRoXyAtIG91dC5pbnNldEJveFdpZHRoXyAtIDIgKiBvdXQuaW5zZXRCb3hQYWRkaW5nXywgMiAqIG91dC5pbnNldEJveFBhZGRpbmdfXVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBjb250YWluZXIgdG8gZHJhd2luZyBncm91cFxyXG4gICAgLy8gQ2Fubm90IHJlYWQgcHJvcGVydGllcyBvZiB1bmRlZmluZWQgKHJlYWRpbmcgJ3N2Z0lkJylcclxuICAgIGxldCBzdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkXylcclxuICAgIGxldCBkcmF3aW5nR3JvdXAgPSBzdmcuc2VsZWN0KCcjZW0tZHJhd2luZy0nICsgb3V0LnN2Z0lkXylcclxuICAgIGNvbnN0IGluZyA9IGRyYXdpbmdHcm91cFxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdlbS1pbnNldHMtZ3JvdXAnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1pbnNldHMnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBvdXQuaW5zZXRCb3hQb3NpdGlvbl9bMF0gKyAnLCcgKyBvdXQuaW5zZXRCb3hQb3NpdGlvbl9bMV0gKyAnKScpXHJcblxyXG4gICAgaWYgKG91dC5pbnNldHNfID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAvL2lmIG5lZWRlZCwgdXNlIGRlZmF1bHQgaW5zZXQgY29uZmlnXHJcbiAgICAgICAgb3V0Lmluc2V0c18gPSBkZWZhdWx0SW5zZXRDb25maWcob3V0Lmluc2V0Qm94V2lkdGhfLCBvdXQuaW5zZXRCb3hQYWRkaW5nXylcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBlbmQgZWFjaCBpbnNldCB0byBtYXBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmluc2V0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb25maWcgPSBvdXQuaW5zZXRzX1tpXVxyXG4gICAgICAgIGNvbmZpZy5zdmdJZCA9IGNvbmZpZy5zdmdJZCB8fCAnaW5zZXQnICsgY29uZmlnLmdlbyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KVxyXG5cclxuICAgICAgICAvL2dldCBzdmcgZWxlbWVudC5cclxuICAgICAgICBsZXQgc3ZnID0gc2VsZWN0KCcjJyArIGNvbmZpZy5zdmdJZClcclxuICAgICAgICBpZiAoc3ZnLnNpemUoKSA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBpdCBhcyBhbiBlbWJlZGVkIFNWRyBpZiBpdCBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAgICBjb25zdCB4ID0gY29uZmlnLnggPT0gdW5kZWZpbmVkID8gb3V0Lmluc2V0Qm94UGFkZGluZ18gOiBjb25maWcueFxyXG4gICAgICAgICAgICBjb25zdCB5ID0gY29uZmlnLnkgPT0gdW5kZWZpbmVkID8gb3V0Lmluc2V0Qm94UGFkZGluZ18gKyBpICogKG91dC5pbnNldEJveFBhZGRpbmdfICsgb3V0Lmluc2V0Qm94V2lkdGhfKSA6IGNvbmZpZy55XHJcbiAgICAgICAgICAgIGNvbnN0IGdnZW8gPSBpbmdcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWluc2V0LScgKyBjb25maWcuc3ZnSWQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0taW5zZXQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB5ICsgJyknKVxyXG4gICAgICAgICAgICBnZ2VvLmFwcGVuZCgnc3ZnJykuYXR0cignaWQnLCBjb25maWcuc3ZnSWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBidWlsZCBpbnNldFxyXG4gICAgICAgIC8vIEdJU0NPLTI2NzYgLSBQVCBhem9yZXMgaW5zZXQgaGFzIDIgaW5zZXRzIHdpdGggdGhlIHNhbWUgR2VvLCBzbyBzZWNvbmQgd2FzIG92ZXJyaWRpbmcgZmlyc3Q6XHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc19bY29uZmlnLmdlb10pIHtcclxuICAgICAgICAgICAgLy9pZiBpbnNldCBhbHJlYWR5IGV4aXN0cyBpbiBtYXAgd2l0aCBzYW1lIGdlbywgdGhlbiBwdXNoIGJvdGggdG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgbGV0IGluc2V0ID0gYnVpbGRJbnNldChjb25maWcsIG91dCwgd2l0aENlbnRlclBvaW50cylcclxuICAgICAgICAgICAgaW5zZXQuYnVpbGRNYXBUZW1wbGF0ZUJhc2UoKVxyXG4gICAgICAgICAgICBvdXQuaW5zZXRUZW1wbGF0ZXNfW2NvbmZpZy5nZW9dID0gW291dC5pbnNldFRlbXBsYXRlc19bY29uZmlnLmdlb10sIGluc2V0XVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBpbnNldCA9IGJ1aWxkSW5zZXQoY29uZmlnLCBvdXQsIHdpdGhDZW50ZXJQb2ludHMpXHJcbiAgICAgICAgICAgIGxldCBkcmF3bkluc2V0ID0gaW5zZXQuYnVpbGRNYXBUZW1wbGF0ZUJhc2UoKVxyXG4gICAgICAgICAgICBvdXQuaW5zZXRUZW1wbGF0ZXNfW2NvbmZpZy5nZW9dID0gZHJhd25JbnNldFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbi8qKiBCdWlsZCB0ZW1wbGF0ZSBmb3IgaW5zZXQsIGJhc2VkIG9uIG1haW4gb25lICovXHJcbmNvbnN0IGJ1aWxkSW5zZXQgPSBmdW5jdGlvbiAoY29uZmlnLCBvdXQsIHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgIC8vVE9ETyBmaW5kIGEgYmV0dGVyIHdheSB0byBkbyB0aGF0XHJcblxyXG4gICAgLy9jb3B5IG1hcFxyXG4gICAgLy9mb3IobGV0IGtleV9fIGluIG1hcCkge1xyXG4gICAgLy9tdFtrZXlfX10gPSBtYXBba2V5X19dO1xyXG4gICAgLy99XHJcblxyXG4gICAgY29uc3QgbXQgPSBtYXBUZW1wbGF0ZShjb25maWcsIHdpdGhDZW50ZXJQb2ludHMpXHJcblxyXG4gICAgLy9kZWZpbmUgZGVmYXVsdCB2YWx1ZXMgZm9yIGluc2V0IGNvbmZpZ3NcclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fVxyXG4gICAgY29uZmlnLnByb2ogPSBjb25maWcucHJvaiB8fCBfZGVmYXVsdENSU1tjb25maWcuZ2VvXVxyXG4gICAgY29uZmlnLnNjYWxlID0gY29uZmlnLnNjYWxlIHx8IG91dC5pbnNldFNjYWxlX1xyXG4gICAgY29uZmlnLmZvb3Rub3RlID0gY29uZmlnLmZvb3Rub3RlIHx8ICcnXHJcbiAgICBjb25maWcuc2hvd1NvdXJjZUxpbmsgPSBjb25maWcuc2hvd1NvdXJjZUxpbmsgfHwgZmFsc2VcclxuICAgIGNvbmZpZy56b29tRXh0ZW50ID0gY29uZmlnLnpvb21FeHRlbnQgfHwgb3V0Lmluc2V0Wm9vbUV4dGVudF9cclxuICAgIGNvbmZpZy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCBvdXQuaW5zZXRCb3hXaWR0aF9cclxuICAgIGNvbmZpZy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IG91dC5pbnNldEJveFdpZHRoX1xyXG4gICAgY29uZmlnLmluc2V0cyA9IGNvbmZpZy5pbnNldHMgfHwgW11cclxuICAgIGNvbmZpZy5pbnNldFRlbXBsYXRlcyA9IGNvbmZpZy5pbnNldFRlbXBsYXRlcyB8fCB7fVxyXG4gICAgY29uZmlnLmNhbGxiYWNrID0gY29uZmlnLmNhbGxiYWNrIHx8IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vY29weSBtYWluIG1hcCBhdHRyaWJ1dGVzXHJcbiAgICA7W1xyXG4gICAgICAgICdudXRzTGV2ZWxfJyxcclxuICAgICAgICAnbnV0c1llYXJfJyxcclxuICAgICAgICAnaG92ZXJDb2xvcl8nLFxyXG4gICAgICAgIC8vJ251dHNiblN0cm9rZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgLy8gJ251dHNiblN0cm9rZVdpZHRoXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnY250cmdGaWxsU3R5bGVfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjbnRiblN0cm9rZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2NudGJuU3Ryb2tlV2lkdGhfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdzZWFGaWxsU3R5bGVfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdkcmF3Q29hc3RhbE1hcmdpbl8nLFxyXG4gICAgICAgICdjb2FzdGFsTWFyZ2luQ29sb3JfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjb2FzdGFsTWFyZ2luV2lkdGhfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjb2FzdGFsTWFyZ2luU3RkRGV2XycsXHJcbiAgICAgICAgJ2dyYXRpY3VsZVN0cm9rZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2dyYXRpY3VsZVN0cm9rZVdpZHRoXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnbGdfJyxcclxuICAgICAgICAncHJvamVjdGlvbkZ1bmN0aW9uXycsXHJcbiAgICAgICAgJ2ZpbHRlckdlb21ldHJpZXNGdW5jdGlvbl8nLFxyXG4gICAgICAgICdwcm9jZXNzQ2VudHJvaWRzXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG10W2F0dF0gPSBvdXRbYXR0XVxyXG4gICAgfSlcclxuXHJcbiAgICAvL2NvcHkgc3RhdCBtYXAgYXR0cmlidXRlcy9tZXRob2RzXHJcbiAgICA7WydzdGF0JywgJ3N0YXREYXRhJywgJ2xlZ2VuZCcsICdsZWdlbmRPYmonLCAnbm9EYXRhVGV4dCcsICdsYW5ndWFnZScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndG9vbHRpcF8nLCAnY2xhc3NUb1RleHRfJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgbXRbYXR0XSA9IG91dFthdHRdXHJcbiAgICB9KVxyXG5cclxuICAgIC8vYXBwbHkgY29uZmlnIHZhbHVlcyBmb3IgaW5zZXRcclxuICAgIGZvciAobGV0IGtleSBpbiBjb25maWcpIG10W2tleSArICdfJ10gPSBjb25maWdba2V5XVxyXG5cclxuICAgIG10LmlzSW5zZXQgPSB0cnVlIC8vIGZsYWcgZm9yIGluc2V0LXNwZWNpZmljIHNldHRpbmdzIGUuZy4gQ1NTIGNsYXNzIGZvciB0aXRsZXNcclxuICAgIHJldHVybiBtdFxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGluc2V0cyBtYXBzIGZyb20gdGhlIERPTVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbW92ZUluc2V0cyA9IGZ1bmN0aW9uIChvdXQpIHtcclxuICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgZm9yIChsZXQgdGVtcGxhdGUgaW4gb3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBsZXQgaWQgPSBvdXQuaW5zZXRUZW1wbGF0ZXNfW3RlbXBsYXRlXS5zdmdJZF9cclxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nID0gc2VsZWN0KCcjJyArIGlkKVxyXG4gICAgICAgICAgICAvLyBpZiAoZXhpc3RpbmcpIGV4aXN0aW5nLnJlbW92ZSgpXHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZykgZXhpc3RpbmcuaHRtbCgnJykgLy8gZW1wdHkgdGhlbSwgYnV0IGRvbnQgcmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5pbnNldFRlbXBsYXRlc18gPSB7fSAvLyAgR0lTQ08tMjY3NlxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBpbnNldCBzZXR0aW5nLlxyXG4gKiBAcGFyYW0geyp9IHMgVGhlIHdpZHRoIG9mIHRoZSBpbnNldCBib3hcclxuICogQHBhcmFtIHsqfSBwIFRoZSBwYWRkaW5nXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0SW5zZXRDb25maWcgPSBmdW5jdGlvbiAocywgcCkge1xyXG4gICAgY29uc3Qgb3V0ID0gW1xyXG4gICAgICAgIHsgZ2VvOiAnSUMnLCB4OiAwLCB5OiAwLCB3aWR0aDogcywgaGVpZ2h0OiAwLjMgKiBzIH0sXHJcbiAgICAgICAgeyBnZW86ICdDQVJJQicsIHg6IDAsIHk6IDAuMyAqIHMgKyBwLCB3aWR0aDogMC41ICogcywgaGVpZ2h0OiBzIH0sXHJcbiAgICAgICAgeyBnZW86ICdHRicsIHg6IDAuNSAqIHMsIHk6IDAuMyAqIHMgKyBwLCB3aWR0aDogMC41ICogcywgaGVpZ2h0OiAwLjc1ICogcyB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnWVQnLFxyXG4gICAgICAgICAgICB4OiAwLjUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjA1ICogcyArIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnUkUnLFxyXG4gICAgICAgICAgICB4OiAwLjc1ICogcyxcclxuICAgICAgICAgICAgeTogMS4wNSAqIHMgKyBwLFxyXG4gICAgICAgICAgICB3aWR0aDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIGhlaWdodDogMC4yNSAqIHMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ1BUMjAnLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAxLjMgKiBzICsgMiAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjc1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnUFQzMCcsXHJcbiAgICAgICAgICAgIHg6IDAuNzUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjMgKiBzICsgMiAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgZ2VvOiAnTVQnLCB4OiAwLCB5OiAxLjU1ICogcyArIDMgKiBwLCB3aWR0aDogMC4yNSAqIHMsIGhlaWdodDogMC4yNSAqIHMgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ0xJJyxcclxuICAgICAgICAgICAgeDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuNTUgKiBzICsgMyAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnU0pfU1YnLFxyXG4gICAgICAgICAgICB4OiAwLjUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjU1ICogcyArIDMgKiBwLFxyXG4gICAgICAgICAgICB3aWR0aDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIGhlaWdodDogMC4yNSAqIHMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ1NKX0pNJyxcclxuICAgICAgICAgICAgeDogMC43NSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuNTUgKiBzICsgMyAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qe2dlbzpcIklDXCIsIHg6MCwgeTowfSwge2dlbzpcIlJFXCIsIHg6ZGQsIHk6MH0sIHtnZW86XCJZVFwiLCB4OjIqZGQsIHk6MH0sXHJcblx0XHR7Z2VvOlwiR1BcIiwgeDowLCB5OmRkfSwge2dlbzpcIk1RXCIsIHg6ZGQsIHk6ZGR9LCB7Z2VvOlwiR0ZcIixzY2FsZTpcIjEwTVwiLCB4OjIqZGQsIHk6ZGR9LFxyXG5cdFx0e2dlbzpcIlBUMjBcIiwgeDowLCB5OjIqZGR9LCB7Z2VvOlwiUFQzMFwiLCB4OmRkLCB5OjIqZGR9LCB7Z2VvOlwiTVRcIiwgeDoyKmRkLCB5OjIqZGR9LFxyXG5cdFx0e2dlbzpcIkxJXCIsc2NhbGU6XCIwMU1cIiwgeDowLCB5OjMqZGR9LCB7Z2VvOlwiU0pfU1ZcIiwgeDpkZCwgeTozKmRkfSwge2dlbzpcIlNKX0pNXCIsc2NhbGU6XCIwMU1cIiwgeDoyKmRkLCB5OjMqZGR9LCovXHJcbiAgICAgICAgLy97Z2VvOlwiQ0FSSUJcIiwgeDowLCB5OjMzMH0sIHtnZW86XCJJU1wiLCB4OmRkLCB5OjMzMH1cclxuICAgIF1cclxuICAgIC8vaGlkZSBncmF0aWN1bGUgZm9yIGluc2V0c1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIG91dFtpXS5kcmF3R3JhdGljdWxlID0gZmFsc2VcclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqIERlZmF1bHQgQ1JTIGZvciBlYWNoIGdlbyBhcmVhICovXHJcbmNvbnN0IF9kZWZhdWx0Q1JTID0ge1xyXG4gICAgRVVSOiAnMzAzNScsXHJcbiAgICBJQzogJzMyNjI4JyxcclxuICAgIEdQOiAnMzI2MjAnLFxyXG4gICAgTVE6ICczMjYyMCcsXHJcbiAgICBHRjogJzMyNjIyJyxcclxuICAgIFJFOiAnMzI3NDAnLFxyXG4gICAgWVQ6ICczMjczOCcsXHJcbiAgICBNVDogJzMwMzUnLFxyXG4gICAgUFQyMDogJzMyNjI2JyxcclxuICAgIFBUMzA6ICczMjYyOCcsXHJcbiAgICBMSTogJzMwMzUnLFxyXG4gICAgSVM6ICczMDM1JyxcclxuICAgIFNKX1NWOiAnMzAzNScsXHJcbiAgICBTSl9KTTogJzMwMzUnLFxyXG4gICAgQ0FSSUI6ICczMjYyMCcsXHJcbiAgICBXT1JMRDogJzU0MDMwJyxcclxufVxyXG4iLCIvLyBtaXhlZCBudXRzIGRvbnQgZHJhdyBudXRzYm4gc28gd2UgYWRkIHRoZW0gbWFudWFsbHlcclxuZXhwb3J0IGNvbnN0IGtvc292b0JuRmVhdHVyZXMgPSB7XHJcbiAgMjAyMTp7XHJcbiAgICAzMDM1OiB7XHJcbiAgICAgICcwM00nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMzA2MSwxMzAzXSxbLTE1MiwtNTldLFstMzIsLTY2XSxbLTY1LDcyXSxbLTk2LDddLFstMTYsNTldLFstNjQsMTldLFstNTYsLTM5XSxbLTEyMCwzOV0sWy0xODQsLTE5XSxbLTE2LDI2XSxbMzIsNTJdLFstMTYsNzJdLFsyNCw0MF0sWzgsMTgzXV0sW1syODg1LDBdLFstOCw0Nl0sWy02NSw4NV0sWy00MCwtN10sWy00MCw0MF0sWzAsMTExXSxbODAsMTNdLFsyNSw0Nl0sWzcyLDEzXSxbNDAsOThdLFstNTYsMTE4XSxbMTQ0LDE5Nl0sWy0yNCw3OV0sWzg4LDU5XSxbLTI0LDk4XSxbLTgsMjBdLFsyNCwzOV0sWzgsNTJdLFs0OCw3Ml0sWy04OCwxMjVdXSxbWzgyNSwyNjM4XSxbLTExMiwtOThdLFstNzIsLTddLFstODgsLTExOF0sWy0xNzYsLTM5XSxbNTYsLTkxXSxbODgsLTMzXSxbMjQsLTUzXSxbNTYsLTM5XSxbMjQsLTkxXSxbLTU2LC00Nl0sWzI0LC0xMDVdLFstNTYsLTkyXSxbLTEwNCwwXSxbLTQ4LC0xMDRdLFstMTYsLTQwXSxbLTU3LDddLFstNDAsLTUzXSxbLTE2LC03OF0sWzExMywtMTE4XSxbLTk3LC02NV0sWy04OCwtOTldLFstODAsMjBdLFstODAsLTM5XSxbLTI0LC0xM11dLFtbMTA5OCwyMzA0XSxbLTE5Myw2Nl0sWzI0LDM5XSxbLTE2LDM5XSxbNjUsMTNdLFswLDMzXSxbLTY1LDc5XSxbLTg4LDY1XV0sW1syMzA4LDE2ODldLFstMTUzLC0yMF0sWy02NCw1OV0sWy00MCw3XSxbLTk2LC0yN10sWy0xMDQsMTM4XSxbLTgsOTJdLFstMzIsNzhdLFstNjQsMjZdLFstMzIsLTU5XSxbLTI0LDBdLFstNTYsODZdLFstNDAsMTM3XSxbLTI1LDY1XSxbLTU2LDBdLFstNTYsNDZdLFstNjQsLTcyXSxbLTEyMCw1M10sWy04OCwtNDBdLFstODgsNDZdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlszNy43NjEwNDQ3NTI3Nzc1NjUsMzguNTQ3MzQyMDU2MjYxMTNdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDUsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcxME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbOTYyLDBdLFstMjksNzVdLFs0OCwxMzFdLFsyMSwzNV0sWzExLDM4XSxbMzIsMTE3XSxbLTI0LDQ0XV0sW1sxMDIxLDQ0MF0sWy02NCwtMjldLFstNzAsMzZdLFstMTIwLDJdLFszLDEyMV1dLFtbNzcwLDU3MF0sWy0xMjYsMTZdLFstNDAsOTFdLFstNDUsNF0sWy01MSw5M10sWy0xNDIsNF1dLFtbMjc1LDg5MV0sWy0xMzEsLTk5XSxbMzAsLTM2XSxbMjQsLTMxXSxbLTYsLTg2XSxbLTk4LC04Nl0sWzEzLC02NF0sWy0yNywtMzhdLFstODAsLTMxXV0sW1szNjYsNzc4XSxbLTM3LDIyXSxbLTU0LDkxXV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMTEzLjIwOTk0NDg1MTMwOTcsMTE0LjEyNzgyMDgxMzAzODAxXSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnMjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzUzNiwwXSxbLTI0LDQ1XSxbMTUsMzBdLFs0NSw5Ml0sWy0xLDQ0XSxbLTIsMzddXSxbWzU2OSwyNDhdLFstMTMwLDldLFstMTAsNjRdXSxbWzQyOSwzMjFdLFstNjQsMTBdLFstNzgsOTRdLFstODMsMTNdXSxbWzE1Myw1MDJdLFstNzMsLTUxXSxbMjYsLTg0XSxbLTQ4LC01M10sWy0zLC01Ml0sWy01NSwtMjVdXSxbWzIwNCw0MzhdLFstNTEsNjRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsyMDMuMTIzMDk2MDE0OTQxMjQsMjAyLjU2NTUxNDYzMDMxMjQ2XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnNjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzMxMCwxMzhdLFstMzYsLTJdLFstNDAsNDJdXSxbWzIzNCwxNzhdLFstMTIzLDY1XV0sW1s4NCwyNzhdLFstODQsLTE0N11dLFtbMTExLDI0M10sWy0yNywzNV1dLFtbMjkyLDBdLFsxOCwxMzhdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlszNzIuODQyODE3MzAyMTU2MzMsMzY0Ljg3NjExODk4NTgwNTM2XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNCxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAzLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDEsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMixcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA1LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19XHJcbiAgICB9LFxyXG4gICAgNDMyNjoge1xyXG4gICAgICAnMDNNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzE5MDAsMTI3NV0sWy0zMCwyN10sWy0yNywtMTNdLFstMzQsMjNdLFstODcsNl0sWzI1LDU5XSxbMSw3MF0sWzIwLDM0XSxbMjQsMTY3XV0sW1sxNzkyLDE2NDhdLFstMTE2LDFdLFstNjIsNzddLFstODksLThdLFstNjAsMTQ4XSxbNyw4Nl0sWy00LDE1XSxbLTEzLDYwXSxbLTQ1LDI4XSxbLTMzLC00OF0sWy0yNiw0XSxbLTMxLDE0Ml0sWy0xMSw1M10sWzUsNDNdLFstMTksNDRdLFstMzksOF0sWy00MCw0OV0sWy01MiwtNTldLFstOTMsNzFdLFstMzgsLTZdLFstMTYsLTI2XV0sW1s5NDUsMjM4OF0sWy01NCwyN10sWy0yMCwyOF0sWy0yMiwtM10sWy0xNywyMl0sWy0yNSwxXSxbLTEwLDEwXSxbNCwxN10sWzI3LDE0XSxbLTE1LDI5XSxbMSwxNl0sWzY4LDFdLFstOCwxNl0sWy01LDMwXSxbLTE0LDI5XSxbLTI3LDQyXSxbLTI1LDIyXSxbLTMwLDQxXV0sW1s3NzMsMjczMF0sWy04OSwtNjldLFstNjQsLTRdLFstODIsLTkyXSxbLTEzMywtMTVdLFsyNywtOTNdLFs2NCwtNDNdLFsxNiwtNTBdLFszOCwtNDRdLFs5LC03NV0sWy00OCwtNTFdLFs1LC00MV0sWzYsLTUwXSxbLTUyLC04NF0sWy03OCwxNF0sWy0zNSwtNjZdLFstMzMsLTYxXSxbLTQ1LDExXSxbLTM1LC00Ml0sWy0xOCwtNzJdLFszMywtNzFdLFs0OCwtNTVdXSxbWzEwMTcsMjMzMF0sWy03Miw1OF1dLFtbMzA3LDE2NzddLFstMzYsLTEyXSxbLTI1LC0yMV0sWy0yNiwtMTBdLFstNzYsLTkwXSxbLTE3LDRdLFstMzAsMzFdLFstNTIsLTE0XSxbLTI2LC0yM10sWy0xOSwxXV0sW1syMzE5LDExODVdLFstMTE2LC0zMl0sWy0zOSwtNTJdLFstNDIsNzBdLFstNjgsMjNdLFstMTIsNThdLFstNDMsMjNdLFstNDIsLTIzXSxbLTU3LDIzXV0sW1syMDQ0LDBdLFstNCw0M10sWy0zOCw4Ml0sWy0zNCw5XSxbLTI0LDQzXSxbMTMsOTddLFs2MSw0XSxbMzIsNDFdLFs0OSwwXSxbMzcsODJdLFstMjYsMTE4XSxbMTMwLDE2N10sWy04LDczXSxbNzQsNDZdLFstMiwxOF0sWy05LDkyXSxbMjQsMzVdLFs3LDQ5XSxbNDgsNTJdLFstNTUsMTM0XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDA2MDM4MzM5MjgzOTA4OTc0LDAuMDAwMzY5ODM0NzU1Njc3NjU5NzVdLFwidHJhbnNsYXRlXCI6WzIwLjM1MjkyODM5MzAwMDA3LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19LFxyXG4gICAgICAnMTBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzY1OSw0MzldLFstNTQsMTddLFsxNywxMTFdXSxbWzYyMiw1NjddLFstOTMsMzFdLFstMjUsOTJdLFstMzYsMTFdLFstMjksOTddLFstMjMsMV0sWy02MywzXV0sW1szMjgsODIyXSxbLTMzLDc0XSxbLTI3LDQ0XV0sW1syNjgsOTQwXSxbLTcyLC00NF0sWy0zOCwtMzFdLFsyNywtODZdLFstMTQsLTY1XSxbLTgxLC03OF0sWzE2LC01OF1dLFtbMzUzLDgwMl0sWy0yNSwyMF1dLFtbMTA2LDU3OF0sWy00MSwtMTldLFstNjUsLTI4XV0sW1s4MDUsNDA4XSxbLTU0LC0yMV0sWy05Miw1Ml1dLFtbNzA5LDBdLFstMjIsNzJdLFswLDE3XSxbNDAsMzZdLFsxOCw2N10sWzUzLDEwMV0sWzE2LDY0XSxbLTksNTFdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwMTc0MDUyMTU0NzkxMTUyNCwwLjAwMTA3NDA5NDU1NjM4Mjk5MDddLFwidHJhbnNsYXRlXCI6WzIwLjM1MjkyODM5MzAwMDA3LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19LFxyXG4gICAgICAnMjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzM4MCwyNTJdLFstMjEsMjZdLFswLDQ4XV0sW1szNTksMzI2XSxbLTQ5LDE3XSxbLTU2LDEwN10sWy01MSwxMV1dLFtbMTg5LDQ3Ml0sWy0zNCw2OF1dLFtbMTU1LDU0MF0sWy02NiwtMzldLFsxOCwtNjZdLFstNTQsLTY4XSxbOCwtMzVdXSxbWzYxLDMzMl0sWy0yMSwtMTNdLFstMTAsLTEyXSxbLTEzLDVdLFstMTcsLTddXSxbWzQ2NCwyMzRdLFstODQsMThdXSxbWzQwOSwwXSxbLTE0LDQ2XSxbNjEsMTEwXSxbOCw3OF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAzMDE4Mjc2ODMxODk2NDk4LDAuMDAxODY5NzIwMTUzNzAzNzI0NV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDcsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX0sXHJcbiAgICAgICc2ME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMjM1LDE1Nl0sWy0xMyw0Nl1dLFtbMjIyLDIwMl0sWy05Niw4NF1dLFtbMTE3LDI5M10sWy0yMSw0Ml1dLFtbOTYsMzM1XSxbLTU4LC0xMjldXSxbWzEyNiwyODZdLFstOSw3XV0sW1szOCwyMDZdLFstMzgsLTE3XV0sW1syODcsMTQ1XSxbLTUyLDExXV0sW1syNTMsMF0sWzM0LDE0NV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDA0ODc5NzIyODIyMjk5NTY0LDAuMDAzMDEzODc3MjYyNjg2NjAwNl0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDc0LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19XHJcbiAgICB9XHJcbiAgfSxcclxuICAyMDI0OntcclxuICAgIDMwMzU6IHtcclxuICAgICAgJzAzTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1s3MjgsMTUwOF0sWy00OCwxMl0sWy0yMiwxOF0sWy0xNSwtNV0sWy0xNiwxM10sWy0yMiwtNF0sWy0xMCw4XSxbMCwxM10sWzIxLDEzXSxbLTE2LDE3XSxbMCwxM10sWzU4LDldLFstNSw4XSxbLTEwLDIyXSxbLTE2LDE3XSxbLTI3LDI1XSxbLTIxLDEzXSxbLTMyLDI2XV0sW1sxOTEyLDBdLFstNiwzMF0sWy00Miw1MV0sWy0zMiwwXSxbLTIxLDMwXSxbMCw2OV0sWzUzLDhdLFsyMSwzNV0sWzQzLDRdLFsyNiw2MF0sWy0zNyw4MV0sWzk2LDEyOV0sWy0xNiw1MV0sWzU4LDQzXSxbMCw5XSxbLTIxLDY0XSxbMTYsMjZdLFs1LDM0XSxbMzIsNDNdLFstNTgsODVdXSxbWzI1MCw5NDJdLFstMjcsLTEzXSxbLTIxLC0xN10sWy0yMSwtOF0sWy01OSwtNzNdLFstMTYsMF0sWy0yNiwxN10sWy00MywtMTNdLFstMjEsLTIxXSxbLTE2LDBdXSxbWzE2NTcsODYxXSxbLTI3LDEzXSxbLTIxLC0xM10sWy0zMiwxM10sWy03NCwtOV0sWzE2LDQ3XSxbLTYsNDddLFsxMSwyNl0sWzUsMTIwXV0sW1sxNTI5LDExMDVdLFstMTAwLC0xN10sWy02NCw0N10sWy03NSwtMTddLFstNjMsOTRdLFstNiw2MF0sWy01LDEzXSxbLTE2LDM4XSxbLTQyLDEzXSxbLTIyLC0zOF0sWy0yMSwwXSxbLTQyLDk0XSxbLTE2LDM0XSxbMCwzMF0sWy0yMSwzMF0sWy0zMiwwXSxbLTM4LDMwXSxbLTQyLC00N10sWy04NSwzOV0sWy0zMiwtOV0sWy0xMCwtMjFdXSxbWzU0NywxNzI2XSxbLTY5LC02MF0sWy01MywtMTNdLFstNTksLTczXSxbLTExMSwtMjVdLFszMiwtNjBdLFs1OCwtMjJdLFsxNiwtMzRdLFszNywtMjZdLFsxNiwtNTFdLFstMzcsLTM5XSxbNSwtMzBdLFsxMSwtMzRdLFstMzcsLTY0XSxbLTY0LDRdLFstMjYsLTUxXSxbLTIyLC00N10sWy00Miw0XSxbLTIxLC0zNF0sWy0xMSwtNTJdLFszNywtNDddLFs0MywtMzBdXSxbWzc5NywxNDc4XSxbLTY5LDMwXV0sW1syMDI5LDg1Ml0sWy05NiwtMzhdLFstMzIsLTM5XSxbLTQyLDQzXSxbLTU5LDRdLFstMTYsMzldLFstNDIsMTNdLFstMzIsLTIyXSxbLTUzLDldXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOls1Ni45NzYyOTYwODM2MTExOSw1OC45MTUzNDY2NjUzNjMxOV0sXCJ0cmFuc2xhdGVcIjpbNTE2NzAyMC4wMzc0NTE4NzMsMjIwMjI3OC41MTAzMjU1MTY2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnMTBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzI0Miw1MDhdLFstMzMsNDddLFstMjcsMjddXSxbWzYzNywwXSxbLTI1LDQ2XSxbLTIsMTJdLFszMCwyOV0sWzcsNDddLFszNCw3NV0sWzcsNDVdLFstMTIsMzNdXSxbWzgzLDMxOF0sWy0zMiwtMThdLFstNTEsLTI2XV0sW1s1NTIsMjkwXSxbLTQ2LDVdLFszLDc4XV0sW1s1MDksMzczXSxbLTc5LDhdLFstMzAsNTldLFstMzAsM10sWy0zNCw2Ml0sWy0xOSwtMV0sWy01MiwtNl1dLFtbMTgyLDU4Ml0sWy01NSwtMzldLFstMjgsLTI1XSxbMzAsLTU2XSxbLTUsLTQ1XSxbLTU5LC02Ml0sWzE4LC0zN11dLFtbMjY1LDQ5OF0sWy0yMywxMF1dLFtbNjc2LDI4N10sWy00MywtMjFdLFstODEsMjRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsxNzEuMDc0NDk4Mjc0MzMzODIsMTc0LjcyMTQ1NzYzNjQ1NTA5XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA0XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA4XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA3XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAyXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAzXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA1XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA2XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAxXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcyME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbNTAsMTkxXSxbLTE3LC0xMV0sWy04LC0xMF0sWy0xMSwxXSxbLTE0LC02XV0sW1szMDUsMjI0XSxbLTQ0LDZdLFstNTgsNjhdLFstNDQsMl1dLFtbMTA5LDM1MF0sWy01MiwtMzZdLFsyMSwtNDVdLFstMzgsLTU0XSxbMTAsLTI0XV0sW1sxNTksMzAwXSxbLTE0LDZdXSxbWzE0NSwzMDZdLFstMzYsNDRdXSxbWzM4MSwwXSxbLTE3LDMxXSxbNDEsODVdLFstMSw1N11dLFtbNDA0LDE3M10sWy03NCwyXV0sW1szMzAsMTc1XSxbLTIwLDE1XSxbLTUsMzRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsyODYuMTMyOTQzNTYwNzU3OTUsMjkwLjUzNjgyMzg0MTE5MV0sXCJ0cmFuc2xhdGVcIjpbNTE2NzAyMC4wMzc0NTE4NzMsMjIwMjI3OC41MTAzMjU1MTY2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnNjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzI1OCwxMTFdLFstNDcsMV1dLFtbMzIsMTIzXSxbLTMyLC0xN11dLFtbMjExLDExMl0sWy0xNiwzMl1dLFtbMTk1LDE0NF0sWy05NCw0OV1dLFtbNzAsMjI1XSxbLTM4LC0xMDJdXSxbWzEwMSwxOTNdLFstOCw0XV0sW1s5MywxOTddLFstMjMsMjhdXSxbWzI0MywwXSxbMTUsMTExXV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbNDQ3Ljk4OTQzMTY0MjEyNTg1LDQ1MS45NDYxNzA0MTk2MzA1XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA3XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAxXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAyXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAzXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA1XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA2XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA0XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA4XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX1cclxuICAgIH0sXHJcbiAgICA0MzI2OiB7XHJcbiAgICAgICcwM00nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMTU0MywwXSxbLTQsMzJdLFstMjgsNjVdLFstMjQsNV0sWy0xOSwzM10sWzEwLDcwXSxbNDcsNV0sWzIzLDMzXSxbMzgsMF0sWzI4LDU5XSxbLTE5LDkyXSxbOTQsMTI0XSxbLTUsNTRdLFs1NiwzN10sWzAsMTFdLFstOSw3MF0sWzE5LDI3XSxbNCwzOF0sWzM4LDM4XSxbLTQyLDEwMl1dLFtbMTc1MCw4OTVdLFstODUsLTI3XSxbLTMyLC0zN10sWy0yOSw1NF0sWy01NiwxNl0sWy01LDQzXSxbLTMyLDE2XSxbLTMzLC0xNl0sWy00MywxNl1dLFtbMTQzNSw5NjBdLFstMjMsMjJdLFstMTksLTExXSxbLTI4LDE2XSxbLTY2LDVdLFsxOSw0NF0sWzAsNTRdLFsxNCwyNl0sWzE5LDEyNV1dLFtbMjMwLDEyNjJdLFstMjQsLTVdLFstMjMsLTE2XSxbLTE5LC0xMV0sWy01NiwtNjVdLFstMTQsMF0sWy0yNCwyN10sWy0zNywtMTFdLFstMTksLTIxXSxbLTE0LDVdXSxbWzEzNTEsMTI0MV0sWy04NCwwXSxbLTQ3LDU5XSxbLTcxLC02XSxbLTQyLDExNF0sWzUsNjRdLFstNSwxMV0sWy05LDQzXSxbLTMzLDIyXSxbLTI0LC0zOF0sWy0yMyw2XSxbLTIzLDEwOF0sWy01LDM3XSxbMCwzM10sWy0xNCwzMl0sWy0yOCw1XSxbLTI5LDM4XSxbLTQyLC00M10sWy03MCw1NF0sWy0yOCwtNV0sWy0xMCwtMjJdXSxbWzU4MiwyMDU1XSxbLTY2LC00OV0sWy00NywtNV0sWy02MSwtNzBdLFstMTAzLC0xMV0sWzE5LC03MF0sWzUxLC0zMl0sWzEwLC0zOF0sWzI4LC0zMl0sWzksLTU0XSxbLTM3LC00NF0sWzQsLTI2XSxbNSwtMzhdLFstMzcsLTY1XSxbLTYxLDExXSxbLTI5LC00OV0sWy0yMywtNDhdLFstMzMsMTFdLFstMjgsLTMzXSxbLTE0LC01NF0sWzI4LC01NF0sWzMzLC00M11dLFtbNzY5LDE3NTNdLFstNTYsNDhdXSxbWzcxMywxODAxXSxbLTQyLDE3XSxbLTE0LDIxXSxbLTE5LDBdLFstOSwxNl0sWy0xOSwwXSxbLTEwLDZdLFs1LDE2XSxbMTksMTFdLFstOSwyMV0sWzAsMTFdLFs1MSwwXSxbLTUsMTFdLFstNCwyMl0sWy0xMCwyNl0sWy0yMywyN10sWy0xOSwyMl0sWy0yMywyN11dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAwNzk5NDI2MTMyMDIwODg2MiwwLjAwMDQ5MTMzODQzNTUzNDkxNjldLFwidHJhbnNsYXRlXCI6WzIwLjM1MzYxNzY4MDg4NDA1LDQyLjI2MjE2MzEwODE1NTQwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzEwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1s1MzksMF0sWy0xNyw1Ml0sWzAsMTNdLFszMCwyN10sWzEzLDQ4XSxbNDEsNzRdLFsxMyw0N10sWy04LDM4XV0sW1s2MTEsMjk5XSxbLTQxLC0xNl0sWy02OSwzN11dLFtbNTAxLDMyMF0sWy00MSwxM10sWzEyLDgxXV0sW1s4MCw0MjFdLFstMzEsLTEyXSxbLTQ5LC0yMF1dLFtbNDcyLDQxNF0sWy03MSwyNF0sWy0xOCw2Nl0sWy0yOCw3XSxbLTIxLDcyXSxbLTE4LDBdLFstNDcsMl1dLFtbMjAzLDY4Nl0sWy01NCwtMzJdLFstMjksLTIyXSxbMjEsLTYzXSxbLTEyLC00N10sWy02MCwtNTddLFsxMSwtNDRdXSxbWzI2OSw1ODVdLFstMjAsMTZdXSxbWzI0OSw2MDFdLFstMjUsNTNdLFstMjEsMzJdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwMjI5MDA5ODM0OTgyODYzOCwwLjAwMTQ3MTg2NjU5NjI0NTI2ODVdLFwidHJhbnNsYXRlXCI6WzIwLjM1MzYxNzY4MDg4NDA1LDQyLjI2MjE2MzEwODE1NTQwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzIwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1szMzcsMF0sWy0xMiwzNl0sWzUxLDg0XSxbNiw2Ml1dLFtbMzgyLDE4Ml0sWy02OSwxM11dLFtbMzEzLDE5NV0sWy0xNywyMF0sWy0xLDM3XV0sW1s1MCwyNTZdLFstMTcsLTEwXSxbLTgsLThdLFstMTEsM10sWy0xNCwtNV1dLFtbMjk1LDI1Ml0sWy00MCwxM10sWy00Niw4Ml0sWy00MSw5XV0sW1sxMjcsNDE3XSxbLTU0LC0zMF0sWzE1LC01MV0sWy00NCwtNTNdLFs2LC0yN11dLFtbMTY4LDM1Nl0sWy0xMiwxMF1dLFtbMTU2LDM2Nl0sWy0yOSw1MV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAzNjYxODMyMzA2Mjc1MDAxNywwLjAwMjQyMTM0NDA4ODc4NzE4MDVdLFwidHJhbnNsYXRlXCI6WzIwLjM1MzYxNzY4MDg4NDA1LDQyLjI2MjE2MzEwODE1NTQwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzYwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1syMjAsMF0sWzI5LDExNl1dLFtbMjQ5LDExNl0sWy00NSw4XV0sW1syMDQsMTI0XSxbLTEyLDM3XV0sW1sxOTIsMTYxXSxbLTgzLDY2XV0sW1sxMDksMjI3XSxbLTgsNl1dLFtbMzMsMTYzXSxbLTMzLC0xMl1dLFtbODMsMjY2XSxbLTUwLC0xMDNdXSxbWzEwMSwyMzNdLFstMTgsMzNdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwNTYxNzc1MDc2NzA1NjQyNywwLjAwMzc5NTg2NjQ4NTA1MzU4N10sXCJ0cmFuc2xhdGVcIjpbMjAuMzUzNjE3NjgwODg0MDUsNDIuMjYyMTYzMTA4MTU1NDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IsIGV4ZWN1dGVGb3JBbGxJbnNldHMgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuLy8gaGFuZGxlcyBhbGwgbWFwIGxhYmVscyBlLmcuIHN0YXQgdmFsdWVzLCBvciBsYWJlbHMgc3BlY2lmaWVkIGluIG1hcC5sYWJlbHMoe2xhYmVsczpbdGV4dDonbXlMYWJlbCcsIHg6MTIzLCB5OiAxMjNdfSlcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gYWRkTGFiZWxzVG9NYXBcclxuICogQHBhcmFtIG1hcCBldXJvc3RhdG1hcCBtYXAgaW5zdGFuY2VcclxuICogQHBhcmFtIHpnIHpvb21ncm91cCAoZDMgc2VsZWN0aW9uIG9mIHpvb21hYmxlIGVsZW1lbnRzKVxyXG4gKiBAZGVzY3JpcHRpb24gYXBwZW5kcyB0ZXh0IGxhYmVscyB0byB0aGUgbWFwLiBMYWJlbHMgY2FuIGJlIGNvdW50cmllcywgY291bnRyeSBjb2Rlcywgb2NlYW4gbmFtZXMgb3Igc3RhdGlzdGljYWwgdmFsdWVzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWRkTGFiZWxzVG9NYXAgPSBmdW5jdGlvbiAobWFwLCB6Zykge1xyXG4gICAgLy8gc2V0IGRlZmF1bHRzXHJcbiAgICBpZiAoIW1hcC5sYWJlbHNfLmNvbmZpZykgbWFwLmxhYmVsc18uY29uZmlnID0gREVGQVVMVExBQkVMU1xyXG4gICAgaWYgKCFtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zKSBtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zID0gREVGQVVMVFNUQVRMQUJFTFBPU0lUSU9OU1xyXG5cclxuICAgIC8vIGNsZWFyIGV4aXN0aW5nIG9yIGFwcGVuZCBuZXcgY29udGFpbmVyXHJcbiAgICBsZXQgZXhpc3RpbmcgPSB6Zy5zZWxlY3QoJyNlbS1sYWJlbHMnKVxyXG4gICAgbGV0IGxhYmVsc0NvbnRhaW5lciA9IGV4aXN0aW5nLmVtcHR5KCkgPyB6Zy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1sYWJlbHMnKSA6IGV4aXN0aW5nXHJcblxyXG4gICAgLy9mb3Igc3RhdGlzdGljYWwgdmFsdWVzIG9uIG1hcHMgd2l0aG91dCBjZW50cm9pZHMsIHdlIG5lZWQgdG8gYWRkIGNlbnRyb2lkcyBpbml0aWFsbHksIHRoZW4gYWRkIHRleHQgdG8gdGhlbSBsYXRlciBvbmNlIHRoZSBzdGF0IGRhdGEgaXMgbG9hZGVkXHJcbiAgICBpZiAobWFwLmxhYmVsc18/LnZhbHVlcyAmJiBtYXAuX21hcFR5cGUgIT09ICdwcycpIGFwcGVuZFN0YXRMYWJlbENlbnRyb2lkc1RvTWFwKG1hcCwgbGFiZWxzQ29udGFpbmVyKVxyXG5cclxuICAgIC8vIGdldCBsYWJlbHMgYXJyYXlcclxuICAgIGxldCBsYWJlbHNBcnJheSA9IG1hcC5sYWJlbHNfPy5sYWJlbHMgfHwgREVGQVVMVExBQkVMU1tgJHttYXAuZ2VvfV8ke21hcC5wcm9qX30uY2NgXVxyXG5cclxuICAgIC8vIGFwcGVuZCBvdGhlciBsYWJlbHMgdG8gbWFwXHJcbiAgICBpZiAobGFiZWxzQXJyYXkpIHtcclxuICAgICAgICAvL2NvbW1vbiBzdHlsZXMgYmV0d2VlbiBhbGwgbGFiZWwgc2hhZG93c1xyXG4gICAgICAgIGNvbnN0IHNoYWRvd2cgPSBsYWJlbHNDb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGFiZWwtc2hhZG93cycpLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcblxyXG4gICAgICAgIC8vY29tbW9uIHN0eWxlcyBiZXR3ZWVuIGFsbCBsYWJlbHNcclxuICAgICAgICBjb25zdCBsYWJlbGcgPSBsYWJlbHNDb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGFiZWxzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAgICAgLy9TSEFET1dTXHJcbiAgICAgICAgaWYgKG1hcC5sYWJlbHNfPy5zaGFkb3dzKSB7XHJcbiAgICAgICAgICAgIGxldCBzaGFkb3dzID0gc2hhZG93Z1xyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShsYWJlbHNBcnJheSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAnZW0tbGFiZWwtc2hhZG93LScgKyBkLnRleHQucmVwbGFjZSgvXFxzKy9nLCAnLScpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgKGQpID0+ICdlbS1sYWJlbC1zaGFkb3cgZW0tbGFiZWwtc2hhZG93LScgKyBkLmNsYXNzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvL2ZvciByb3RhdGVkIHRleHQsIHggYW5kIHkgcG9zaXRpb25zIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVswXVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZC5yb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLy9mb3Igcm90YXRlZCB0ZXh0LCB4IGFuZCB5IHBvc2l0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgdHJhbnNmb3JtIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlbMV1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAtNykgLy8gc2V0IHkgcG9zaXRpb24gb2YgYm90dG9tIG9mIHRleHRcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gcG9zWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB5ID0gcG9zWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSkgcm90YXRlKCR7ZC5yb3RhdGV9KWBcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSgwKSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC50ZXh0XHJcbiAgICAgICAgICAgICAgICB9KSAvLyBkZWZpbmUgdGhlIHRleHQgdG8gZGlzcGxheVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9MQUJFTCB0ZXh0c1xyXG4gICAgICAgIGxhYmVsZ1xyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgLmRhdGEobGFiZWxzQXJyYXkpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gJ2VtLWxhYmVsLScgKyBkLnRleHQucmVwbGFjZSgvXFxzKy9nLCAnLScpKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAoZCkgPT4gJ2VtLWxhYmVsIGVtLWxhYmVsLScgKyBkLmNsYXNzKVxyXG4gICAgICAgICAgICAvL3Bvc2l0aW9uIGxhYmVsXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8vZm9yIHJvdGF0ZWQgdGV4dCwgeCBhbmQgeSBwb3NpdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVswXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5yb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvL2ZvciByb3RhdGVkIHRleHQsIHggYW5kIHkgcG9zaXRpb25zIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlbMV1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgLTcpIC8vIHNldCB5IHBvc2l0aW9uIG9mIGJvdHRvbSBvZiB0ZXh0XHJcbiAgICAgICAgICAgIC8vdHJhbnNmb3JtIGxhYmVscyB3aGljaCBoYXZlIGEgXCJyb3RhdGVcIiBwcm9wZXJ0eSBpbiB0aGUgbGFiZWxzIGNvbmZpZy4gRm9yIHJvdGF0ZWQgbGFiZWxzLCB0aGVpciBYLFkgbXVzdCBhbHNvIGJlIHNldCBpbiB0aGUgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICAvLyBub3RlOiBkb250IGFwcGx5IHRvIGNvdW50cnkgY29kZSBsYWJlbHNcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5yb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBwb3NbMF1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHBvc1sxXVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSkgcm90YXRlKCR7ZC5yb3RhdGV9KWBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyb3RhdGUoMCknXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC50ZXh0XHJcbiAgICAgICAgICAgIH0pIC8vIGRlZmluZSB0aGUgdGV4dCB0byBkaXNwbGF5XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gdXBkYXRlTGFiZWxzXHJcbiAqIEBkZXNjcmlwdGlvbiB1cGRhdGUgZXhpc3RpbmcgbWFwIGxhYmVsc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUxhYmVscyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGxhYmVsc1xyXG4gICAgICAgIGxldCBwcmV2TGFiZWxzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCcjZW0tbGFiZWxzID4gKicpXHJcbiAgICAgICAgaWYgKHByZXZMYWJlbHMpIHByZXZMYWJlbHMucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gTWFpbiBtYXBcclxuICAgICAgICBpZiAobWFwLmxhYmVsc18pIHtcclxuICAgICAgICAgICAgY29uc3QgbWFzdGVyQ29uZmlnID0gbWFwLmxhYmVsc19cclxuICAgICAgICAgICAgbGV0IHpnID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAgICAgYWRkTGFiZWxzVG9NYXAobWFwLCB6ZylcclxuICAgICAgICAgICAgaWYgKG1hc3RlckNvbmZpZy52YWx1ZXMgJiYgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERlZmluZSB0aGUgY2FsbGJhY2sgdG8gYXBwbHkgdG8gZWFjaCBpbnNldFxyXG4gICAgICAgICAgICBjb25zdCBhcHBseUxhYmVsc0NhbGxiYWNrID0gKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB6ZyA9IG1hcC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG1hcC5zdmdJZF8pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5sYWJlbHNfKSBhZGRMYWJlbHNUb01hcChtYXAsIHpnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXN0ZXJDb25maWcudmFsdWVzICYmIG1hcC51cGRhdGVWYWx1ZXNMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscyhtYXApXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBsYWJlbHMgdG8gYWxsIGluc2V0cyB1c2luZyB0aGUgZXhlY3V0ZUZvckFsbEluc2V0cyBmdW5jdGlvblxyXG4gICAgICAgICAgICBpZiAobWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhtYXAuaW5zZXRUZW1wbGF0ZXNfLCBtYXAuc3ZnSWRfLCBhcHBseUxhYmVsc0NhbGxiYWNrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSB0aGUgc3RhdGlzdGljYWwgdmFsdWVzIGxhYmVscyBvbiB0aGUgbWFwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgZXVyb3N0YXQtbWFwIG1hcCBpbnN0YW5jZVxyXG4gKiBAcmV0dXJuIHttYXB9IG91dFxyXG4gKiBOT1RFOiBUSElTIEZVTkNUSU9OIElTIE5PVCBDQUxMRUQgRk9SIFBST1BPUlRJT05BTCBTWU1CT0wgTUFQU1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVZhbHVlc0xhYmVscyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIGlmICghbWFwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBtYXAgc3BlY2lmaWVkJylcclxuICAgICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvL2NsZWFyIHByZXZpb3VzIGxhYmVsc1xyXG4gICAgbGV0IHByZXZMYWJlbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ2cuZW0tc3RhdC1sYWJlbCA+IConKVxyXG4gICAgcHJldkxhYmVscy5yZW1vdmUoKVxyXG4gICAgbGV0IHByZXZTaGFkb3dzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCdnLmVtLXN0YXQtbGFiZWwtc2hhZG93ID4gKicpXHJcbiAgICBwcmV2U2hhZG93cy5yZW1vdmUoKVxyXG4gICAgbGV0IHN0YXRMYWJlbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ2cuZW0tc3RhdC1sYWJlbCcpXHJcblxyXG4gICAgLy8gZmlsdGVyIHN0YXQtbGFiZWwgZWxlbWVudHMgdG8gb25seSBzaG93IHRob3NlIHdpdGggZGF0YVxyXG4gICAgY29uc3QgZmlsdGVyRnVuY3Rpb24gPSBtYXAubGFiZWxzXz8uc3RhdExhYmVsc0ZpbHRlckZ1bmN0aW9uID8gbWFwLmxhYmVsc18/LnN0YXRMYWJlbHNGaWx0ZXJGdW5jdGlvbiA6IGRlZmF1bHRTdGF0TGFiZWxGaWx0ZXJcclxuICAgIGNvbnN0IHN0YXREYXRhID0gbWFwLnN0YXREYXRhKClcclxuICAgIHN0YXRMYWJlbHNcclxuICAgICAgICAuZmlsdGVyKChyZykgPT4gZmlsdGVyRnVuY3Rpb24ocmcsIG1hcCkpXHJcbiAgICAgICAgLy8gLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHN0YXRMYWJlbHNUZXh0RnVuY3Rpb24oZCwgc3RhdERhdGEpIC8vIFVzZSAnZCcgZGlyZWN0bHkgZm9yIHRoZSBsYWJlbCB0ZXh0XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlIGJlaGluZCBsYWJlbFxyXG4gICAgICAgICAgICBpZiAobWFwLmxhYmVsc18uYmFja2dyb3VuZHMpIGFwcGVuZFJlY3QobGFiZWxUZXh0LCBzZWwpXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGV4dCBhZnRlciB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIHNlbC5hcHBlbmQoJ3RleHQnKS50ZXh0KGxhYmVsVGV4dCkuYXR0cignY2xhc3MnLCAnZW0tc3RhdC1sYWJlbC10ZXh0JylcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIGFwcGVuZCBhIHJlY3RhbmdsZSBiZWhpbmQgdGhlIGxhYmVsXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRSZWN0KGxhYmVsVGV4dCwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSA1IC8vIEFkZCBzb21lIHBhZGRpbmcgYXJvdW5kIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSAyIC8vIEFkZCBzb21lIHBhZGRpbmcgYXJvdW5kIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgdG8gZ2V0IHRoZSBzaXplXHJcbiAgICAgICAgY29uc3QgYmJveCA9IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykgLy8gTWFrZSB0aGUgdGVtcG9yYXJ5IHRleHQgaW52aXNpYmxlXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsVGV4dCkgLy8gU2V0IHRoZSBsYWJlbCB0ZXh0IHRvIGdldCBpdHMgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgIC5ub2RlKClcclxuICAgICAgICAgICAgLmdldEJCb3goKSAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGV4dFxyXG5cclxuICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gYmJveC53aWR0aFxyXG4gICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gYmJveC5oZWlnaHRcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgdGV4dCBlbGVtZW50IGFmdGVyIGdldHRpbmcgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3QoJ3RleHRbdmlzaWJpbGl0eT1cImhpZGRlblwiXScpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZSB0byBiZSBjZW50ZXJlZCBvbiB0aGUgdGV4dFxyXG4gICAgICAgIGNvbnN0IHggPSAtbGFiZWxXaWR0aCAvIDIgLSBwYWRkaW5nWCAvLyBDZW50ZXIgdGhlIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgY29uc3QgeSA9IC1sYWJlbEhlaWdodCAvIDIgLSBwYWRkaW5nWSAvLyBDZW50ZXIgdGhlIHJlY3QgdmVydGljYWxseVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlIHdpdGggcGFkZGluZ1xyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB4KSAvLyBQb3NpdGlvbiByZWN0IGhvcml6b250YWxseVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHkpIC8vIFBvc2l0aW9uIHJlY3QgdmVydGljYWxseVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBsYWJlbFdpZHRoICsgMiAqIHBhZGRpbmdYKSAvLyBXaWR0aCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGxhYmVsSGVpZ2h0ICsgMiAqIHBhZGRpbmdZKSAvLyBIZWlnaHQgb2YgdGhlIHJlY3Qgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgIH1cclxuXHJcbiAgICAvL2FkZCBzaGFkb3dzIHRvIGxhYmVsc1xyXG4gICAgaWYgKG1hcC5sYWJlbHNfPy5zaGFkb3dzKSB7XHJcbiAgICAgICAgbWFwLnN2Z19cclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZy5lbS1zdGF0LWxhYmVsLXNoYWRvdycpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHJnKSA9PiBmaWx0ZXJGdW5jdGlvbihyZywgbWFwKSlcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiBzdGF0TGFiZWxzVGV4dEZ1bmN0aW9uKGQsIHN0YXREYXRhKSkgLy8gVXNlICdkJyBkaXJlY3RseSBmb3IgdGhlIGxhYmVsIHRleHQpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gdGV4dCBmdW5jdGlvbiBmb3Igc3RhdGlzdGljYWwgbGFiZWxsaW5nXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIGQzIHNlbGVjdGlvbiBqc29uIGRhdGEgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdExhYmVsc1RleHRGdW5jdGlvbiA9IChkLCBzdGF0RGF0YSkgPT4ge1xyXG4gICAgaWYgKHN0YXREYXRhICYmIHN0YXREYXRhPy5nZXQpIHtcclxuICAgICAgICBjb25zdCBzdiA9IHN0YXREYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJydcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc3YudmFsdWUgIT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdi52YWx1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIHN0YXRpc3RpY2FsIGxhYmVsc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZCBkMyBzZWxlY3Rpb24ganNvbiBkYXRhIGVsZW1lbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRTdGF0TGFiZWxGaWx0ZXIgPSAocmVnaW9uLCBtYXApID0+IHtcclxuICAgIGNvbnN0IHMgPSBtYXAuc3RhdERhdGEoKVxyXG4gICAgY29uc3Qgc3YgPSBzLmdldChyZWdpb24ucHJvcGVydGllcy5pZClcclxuICAgIGlmICghc3YgfHwgKCFzdi52YWx1ZSAmJiBzdiAhPT0gMCAmJiBzdi52YWx1ZSAhPT0gMCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgYXBwZW5kU3RhdExhYmVsQ2VudHJvaWRzVG9NYXAgPSBmdW5jdGlvbiAobWFwLCBsYWJlbHNDb250YWluZXIpIHtcclxuICAgIC8vdmFsdWVzIGxhYmVsIHNoYWRvd3MgcGFyZW50IDxnPlxyXG4gICAgY29uc3QgZ3NscyA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVscy1zaGFkb3dzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAvLyB2YWx1ZXMgbGFiZWxzIHBhcmVudCA8Zz5cclxuICAgIGNvbnN0IHN0YXRMYWJlbHNHcm91cCA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVscycpLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcblxyXG4gICAgLy8gb3VyIGZlYXR1cmVzIGFycmF5XHJcbiAgICBsZXQgc3RhdExhYmVsUmVnaW9ucyA9IFtdXHJcblxyXG4gICAgLy8gZGVhZnVsdCBnZW9tZXRyaWVzXHJcbiAgICBpZiAobWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c3JnKSB7XHJcbiAgICAgICAgLy9hbGxvdyBmb3Igc3RhdCBsYWJlbCBwb3NpdGlvbmluZyBieSBhZGRpbmcgYSBnIGVsZW1lbnQgaGVyZSwgdGhlbiBhZGRpbmcgdGhlIHZhbHVlcyBpbiB0aGUgbWFwVHlwZSB1cGRhdGVWYWx1ZXNMYWJlbHMgZnVuY3Rpb25cclxuICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICBzdGF0TGFiZWxSZWdpb25zID0gbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmcwLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm1peGVkLnJnMSxcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm1peGVkLnJnMixcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm1peGVkLnJnMyxcclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLmNudHJnIC8vIE5FVzogYWxsb3cgbGFiZWxzIGZvciBjbnRyZ1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdExhYmVsUmVnaW9ucyA9IG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLm51dHNyZy5jb25jYXQobWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMuY250cmcpXHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykge1xyXG4gICAgICAgIC8vIHVzZXIgZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgc3RhdExhYmVsUmVnaW9ucyA9IG1hcC5HZW9tZXRyaWVzLnN0YXRpc3RpY2FsUmVnaW9ucy5mZWF0dXJlc1xyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETzogZG9udCBhZGQgbGFiZWxzIGZvciByZWdpb25zIHRoYXQgYXJlIG5vdCB2aXNpYmxlPyB3aGF0IGFib3V0IHBhbm5pbmcgYW5kIHpvb21pbmcgdGhvdWdoLiBPbmx5IHJlYWxseSBhbiBpc3N1ZSBmb3IgbWl4ZWQgTlVUUy5cclxuXHJcbiAgICAvLyBzdGF0cyBsYWJlbHNcclxuICAgIGNvbnN0IGZpbHRlcmVkUmVnaW9ucyA9IHN0YXRMYWJlbFJlZ2lvbnMuZmlsdGVyKChkLCBpLCBzZWxmKSA9PiBpID09PSBzZWxmLmZpbmRJbmRleCgodCkgPT4gdC5wcm9wZXJ0aWVzLmlkID09PSBkLnByb3BlcnRpZXMuaWQpKVxyXG4gICAgc3RhdExhYmVsc0dyb3VwXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgLmRhdGEoZmlsdGVyZWRSZWdpb25zKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSBwcmVkZWZpbmVkIGxhYmVsIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zW2QucHJvcGVydGllcy5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWFwLmxhYmVsc18uc3RhdExhYmVsc1Bvc2l0aW9uc1tkLnByb3BlcnRpZXMuaWRdXHJcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gbWFwLl9wcm9qZWN0aW9uKFtwb3NpdGlvbi54LCBwb3NpdGlvbi55XSlcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gcG9zWzBdLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gcG9zWzFdLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VudHJvaWQgPSBtYXAuX3BhdGhGdW5jdGlvbi5jZW50cm9pZChkKVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5wcm9jZXNzVmFsdWVMYWJlbENlbnRyb2lkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkID0gbWFwLmxhYmVsc18ucHJvY2Vzc1ZhbHVlTGFiZWxDZW50cm9pZHMoZCwgY2VudHJvaWQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgY2FsY3VsYXRlIGNlbnRyb2lkc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGNlbnRyb2lkICsgJyknXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVsJylcclxuXHJcbiAgICAvLyBzdGF0IGxhYmVscyBzaGFkb3dzXHJcbiAgICBpZiAobWFwLmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICBnc2xzLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgIC5kYXRhKHN0YXRMYWJlbFJlZ2lvbnMpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHVzZSBwcmVkZWZpbmVkIGxhYmVsIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmxhYmVsc18uc3RhdExhYmVsc1Bvc2l0aW9uc1tkLnByb3BlcnRpZXMuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IG1hcC5fcHJvamVjdGlvbihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnNbZC5wcm9wZXJ0aWVzLmlkXS54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zW2QucHJvcGVydGllcy5pZF0ueSxcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4ID0gcG9zWzBdLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHBvc1sxXS50b0ZpeGVkKDMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwke3l9KWBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbnRyb2lkID0gbWFwLl9wYXRoRnVuY3Rpb24uY2VudHJvaWQoZClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5sYWJlbHNfLnByb2Nlc3NWYWx1ZUxhYmVsQ2VudHJvaWRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkID0gbWFwLmxhYmVsc18ucHJvY2Vzc1ZhbHVlTGFiZWxDZW50cm9pZHMoZCwgY2VudHJvaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBjYWxjdWxhdGUgY2VudHJvaWRzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGNlbnRyb2lkICsgJyknXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc3RhdC1sYWJlbC1zaGFkb3cnKVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBsYWJlbHMgZm9yIGNvdW50cnkgLyBnZW9ncmFwaGljYWwgbmFtZXMuXHJcbiAqIFVzaW5nIGNlbnRyb2lkcyB3b3VsZCBjbGFzaCB3aXRoIHByb3BvcnRpb25hbCBzeW1ib2xzLCBhbmQgYXJlIGdlbmVyYWxseSBub3QgaWRlYWwgcGxhY2VtZW50cywgc28gbGFiZWxzIGFyZSBwb3NpdGlvbmVkIGluZGVwZW5kZW50bHlcclxuICogTGFiZWxzIGFyZSBwcm92aWRlZCBmb3IgYWxsIHN1cHBvcnRlZCBsYW5ndWFnZXM6IFwiZW5cIixcImZyXCIgYW5kIFwiZGVcIiAoZGVmaW5lZCB1c2luZyBtYXAubGFuZ3VhZ2UoKSlcclxuICovXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUTEFCRUxTID0ge1xyXG4gICAgRVVSXzMwMzU6IHtcclxuICAgICAgICBjYzogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTCcsIHg6IDUxNTAwMDAsIHk6IDIwNjAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FUJywgeDogNDY3MDAwMCwgeTogMjY5MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE4IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JFJywgeDogMzkzMDAwMCwgeTogMzAxMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JHJywgeDogNTU2NzAwMCwgeTogMjI1MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0hSJywgeDogNDg0MDAwMCwgeTogMjQ4MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NZJywgeDogNjQyNjAwMCwgeTogMTQ4MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NaJywgeDogNDcwNzAwMCwgeTogMjkyMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE4IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RLJywgeDogNDMxNjAwMCwgeTogMzYyMTAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VFJywgeDogNTIyMDAwMCwgeTogMzk5MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZJJywgeDogNTE1MDAwMCwgeTogNDQyNDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSJywgeDogMzc2Nzc0MCwgeTogMjY2MjgxNywgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RFJywgeDogNDM0NzI4NCwgeTogMzA5MzI3NiwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VMJywgeDogNTM3MDAwMCwgeTogMTc1MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0hVJywgeDogNTAyMDAwMCwgeTogMjYzMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lTJywgeDogMzA0MDAwMCwgeTogNDgzMzAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lFJywgeDogMzEzNjAwMCwgeTogMzM5NDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lUJywgeDogNDQ2OTk2NywgeTogMjE4MTk2MywgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xWJywgeDogNTI5MDAwMCwgeTogMzgwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xUJywgeDogNTE5MDAwMCwgeTogMzYzMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xVJywgeDogNDEyMDAwMCwgeTogMjk0MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01UJywgeDogNDczMTAwMCwgeTogMTMwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FJywgeDogNTA3MzAwMCwgeTogMjE4NTAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR0UnLCB4OiA2OTQyNjgwLCB5OiAyNjYwMDAwLCBjbGFzczogJ2NjJyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdVQScsIHg6IDU4OTAwMDAsIHk6IDMwNTAwMDAsIGNsYXNzOiAnY2MnIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JBJywgeDogNDk0OTI2MiwgeTogMjMzODY4OCwgY2xhc3M6ICdjYycgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUQnLCB4OiA1NzQwMDAwLCB5OiAyNzkwMDAwLCBjbGFzczogJ2NjJyB9LFxyXG5cclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUsnLCB4OiA1MzAwMDAwLCB5OiAyMDgwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTkwnLCB4OiA0MDIwMDAwLCB5OiAzMjA4MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk8nLCB4OiA0MzAwMDAwLCB5OiA0MTQ3MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUEwnLCB4OiA0OTY0MDAwLCB5OiAzMjAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUFQnLCB4OiAyNzcwMDAwLCB5OiAxOTkwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTggfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUk8nLCB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUlMnLCB4OiA1MjAwMDAwLCB5OiAyMzUwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0snLCB4OiA1MDQwMDAwLCB5OiAyODYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0knLCB4OiA0Njc1MDAwLCB5OiAyNTAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRVMnLCB4OiAzMTYwMDk2LCB5OiAxOTAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0UnLCB4OiA0NjMwMDAwLCB5OiA0MDAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ0gnLCB4OiA0MTcwMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTYgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFInLCB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVUsnLCB4OiAzNTU4MDAwLCB5OiAzMjUwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTcgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGVuOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FRElURVJSQU5FQU4gU0VBJywgeDogMzk4MDAwMCwgeTogMTYwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQVRMQU5USUMgT0NFQU4nLCB4OiAyODIwMDAwLCB5OiAyNTQwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JUSCBTRUEnLCB4OiAzOTE1MDAwLCB5OiAzNzAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCQUxUSUMgU0VBJywgeDogNDkwMDAwMCwgeTogMzczMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTUwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUldFR0lBTiBTRUEnLCB4OiAzODUwMDAwLCB5OiA0ODAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCTEFDSyBTRUEnLCB4OiA2MzAwMDAwLCB5OiAyNTAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogNCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTEJBTklBJywgY2M6ICdBTCcsIHg6IDUxMDAwMDAsIHk6IDIwNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiA4MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVVNUUklBJywgY2M6ICdBVCcsIHg6IDQ2NzAwMDAsIHk6IDI2MjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkVMR0lVTScsIGNjOiAnQkUnLCB4OiAzOTAwMDAwLCB5OiAzMDMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQlVMR0FSSUEnLCBjYzogJ0JHJywgeDogNTU2NzAwMCwgeTogMjI1NjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDUk9BVElBJywgY2M6ICdIUicsIHg6IDQ4NzYwMDAsIHk6IDI0NTUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDWVBSVVMnLCBjYzogJ0NZJywgeDogNjQyNjAwMCwgeTogMTQ4MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDWkVDSElBJywgY2M6ICdDWicsIHg6IDQ3MDcwMDAsIHk6IDI4ODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnREVOTUFSSycsIGNjOiAnREsnLCB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTVE9OSUEnLCBjYzogJ0VFJywgeDogNTIyMDAwMCwgeTogMzk5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZJTkxBTkQnLCBjYzogJ0ZJJywgeDogNTE1MDAwMCwgeTogNDQyNDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUkFOQ0UnLCBjYzogJ0ZSJywgeDogMzc2Nzc0MCwgeTogMjY2MjgxNywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdHRVJNQU5ZJywgY2M6ICdERScsIHg6IDQzNDcyODQsIHk6IDMwOTMyNzYsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR1JFRUNFJywgY2M6ICdFTCcsIHg6IDU0NzAwMDAsIHk6IDE4NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSFVOR0FSWScsIGNjOiAnSFUnLCB4OiA1MDIwMDAwLCB5OiAyNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lDRUxBTkQnLCBjYzogJ0lTJywgeDogMzA0MDAwMCwgeTogNDgzMzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJUkVMQU5EJywgY2M6ICdJRScsIHg6IDMxMzYwMDAsIHk6IDMzOTQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVRBTFknLCBjYzogJ0lUJywgeDogNDQ2OTk2NywgeTogMjE4MTk2MywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMQVRWSUEnLCBjYzogJ0xWJywgeDogNTI5MDAwMCwgeTogMzgwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xJVEhVQU5JQScsIGNjOiAnTFQnLCB4OiA1MTkwMDAwLCB5OiAzNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFVYLicsIGNjOiAnTFUnLCB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUFMVEEnLCBjYzogJ01UJywgeDogNDczMTAwMCwgeTogMTMzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01PTlQuJywgY2M6ICdNRScsIHg6IDUwNzMwMDAsIHk6IDIxODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOLiBNQUNFRE9OSUEnLCBjYzogJ01LJywgeDogNTMwMDAwMCwgeTogMjA4MjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05FVEhFUkxBTkRTJywgY2M6ICdOTCcsIHg6IDM5NzcwMDAsIHk6IDMyMDgwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JXQVknLCBjYzogJ05PJywgeDogNDMzMDAwMCwgeTogNDE0NzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9MQU5EJywgY2M6ICdQTCcsIHg6IDQ5NjQwMDAsIHk6IDMyNjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9SVFVHQUwnLCBjYzogJ1BUJywgeDogMjgzMDAwMCwgeTogMTk5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUk9NQU5JQScsIGNjOiAnUk8nLCB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NFUkJJQScsIGNjOiAnUlMnLCB4OiA1MjAwMDAwLCB5OiAyMzAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPVkFLSUEnLCBjYzogJ1NLJywgeDogNTA0MDAwMCwgeTogMjgzNTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9WRU5JQScsIGNjOiAnU0knLCB4OiA0NzM1MDAwLCB5OiAyNTIyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NQQUlOJywgY2M6ICdFUycsIHg6IDMxNjAwOTYsIHk6IDE4NTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU1dFREVOJywgY2M6ICdTRScsIHg6IDQ2MzAwMDAsIHk6IDQxMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NXSVRaRVJMQU5EJywgY2M6ICdDSCcsIHg6IDQyMDAwMDAsIHk6IDI1NjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUVVJLRVknLCBjYzogJ1RSJywgeDogNjUxMDAwMCwgeTogMjEwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdVLksuJywgY2M6ICdVSycsIHg6IDM1NTgwMDAsIHk6IDMyNTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGZyOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FUiBNw4lESVRFUlJBTsOJRScsIHg6IDU0NzIwMDAsIHk6IDEyNDIwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ09Dw4hBTiBBVExBTlRJUVVFJywgeDogMjgyMDAwMCwgeTogMjU0MDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIERVIE5PUkQnLCB4OiAzOTE1MDAwLCB5OiAzNzAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRVIgQkFMVElRVUUnLCB4OiA0OTAwMDAwLCB5OiAzNjcyMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIERFIE5PUlbDiEdFJywgeDogMzg1MDAwMCwgeTogNDgwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIE5PSVJFJywgeDogNjI2NTAwMCwgeTogMjQ3MjAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQUxCQU5JRScsIHg6IDUxMDAwMDAsIHk6IDIwNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiA4MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVVRSSUNIRScsIHg6IDQ2NzAwMDAsIHk6IDI2MjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkVMR0lRVUUnLCB4OiAzOTAwMDAwLCB5OiAzMDMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQlVMR0FSSUUnLCB4OiA1NTY3MDAwLCB5OiAyMjU2MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NST0FUSUUnLCB4OiA0ODc2MDAwLCB5OiAyNDU1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ0hZUFJFJywgeDogNjQyNjAwMCwgeTogMTQ4MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUQ0jDiVFVSUUnLCB4OiA0NzA3MDAwLCB5OiAyODg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RBTkVNQVJLJywgeDogNDMxNjAwMCwgeTogMzYyMTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFU1RPTklFJywgeDogNTIyMDAwMCwgeTogMzk5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGSU5MQU5ERScsIHg6IDUxMjUwMDAsIHk6IDQ0MjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlJBTkNFJywgeDogMzc2Nzc0MCwgeTogMjY2MjgxNywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTExFTUFHTkUnLCB4OiA0MzQ3Mjg0LCB5OiAzMDkzMjc2LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0dSw4hDRScsIHg6IDU0MjAwMDAsIHk6IDE4NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSE9OR1JJRScsIHg6IDUwMjAwMDAsIHk6IDI2NTQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVNMQU5ERScsIHg6IDMwNDAwMDAsIHk6IDQ4MzMwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVJMQU5ERScsIHg6IDMxMzYwMDAsIHk6IDMzOTQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVRBTElFJywgeDogNDUwMDAwMCwgeTogMjE4MTk2MywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMRVRUT05JRScsIHg6IDUyOTAwMDAsIHk6IDM3NzYwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTElUVUFOSUUnLCB4OiA1MTkwMDAwLCB5OiAzNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xVWC4nLCB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUFMVEUnLCB4OiA0NzMxMDAwLCB5OiAxMzM1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTU9OVC4nLCB4OiA1MDczMDAwLCB5OiAyMTg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUFDLiBEVSBOT1JEJywgeDogNTMwMDAwMCwgeTogMjA4MjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BBWVMtQkFTJywgeDogMzk3NzAwMCwgeTogMzIwODAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUlZFR0UnLCB4OiA0MzMwMDAwLCB5OiA0MTQ3MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT0xPR05FJywgeDogNDk2NDAwMCwgeTogMzI2OTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT1JUVUdBTCcsIHg6IDI4MzYxMzYsIHk6IDE5NTYxNzksIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JPVU1BTklFJywgeDogNTQ1MTAwMCwgeTogMjYwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTRVJCSUUnLCB4OiA1MjAwMDAwLCB5OiAyMzAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPVkFRVUlFJywgeDogNTA0MDAwMCwgeTogMjgzNTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9Ww4lOSUUnLCB4OiA0NzM1MDAwLCB5OiAyNTIyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTM1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTUEFHTkUnLCB4OiAzMTYwMDk2LCB5OiAxODUwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NVw4hERScsIHg6IDQ3MDAwMDAsIHk6IDQ0MDEwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NVSVNTRScsIHg6IDQyMDAwMDAsIHk6IDI1NjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUVVJRVUlFJywgeDogNjUxMDAwMCwgeTogMjEwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdST1lBVU1FLVVOSScsIHg6IDM1NTgwMDAsIHk6IDMyNTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRlOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01JVFRFTE1FRVInLCB4OiA1NDcyMDAwLCB5OiAxMjAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVExBTlRJU0NIRVIgT1pFQU4nLCB4OiAyODIwMDAwLCB5OiAyNTQwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JEU0VFJywgeDogMzkxNTAwMCwgeTogMzcwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnT1NUU0VFJywgeDogNDkwMDAwMCwgeTogMzY3MjAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTUwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUldFR0lTQ0hFIE1FRVInLCB4OiAzODUwMDAwLCB5OiA0ODAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTQ0hXQVJaRSBNRUVSJywgeDogNjMwMDAwMCwgeTogMjUwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQUxCQU5JRU4nLCB4OiA1MTAwMDAwLCB5OiAyMDYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogODAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnw5ZTVEVSUkVJQ0gnLCB4OiA0NjUwMDAwLCB5OiAyNjI5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkVMR0lFTicsIHg6IDM5MDAwMDAsIHk6IDMwMzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAzMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCVUxHQVJJRU4nLCB4OiA1NTY3MDAwLCB5OiAyMjU2MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0tST0FUSUVOJywgeDogNDg3NjAwMCwgeTogMjQ1NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1pZUEVSTicsIHg6IDY0MjYwMDAsIHk6IDE0ODAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFNDSEVDSElFTicsIHg6IDQ3MDcwMDAsIHk6IDI4ODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdEw4RORU1BUksnLCB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTVExBTkQnLCB4OiA1MjIwMDAwLCB5OiAzOTkwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRklOTkxBTkQnLCB4OiA1MTUwMDAwLCB5OiA0NDI0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSQU5LUkVJQ0gnLCB4OiAzNzY3NzQwLCB5OiAyNjYyODE3LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RFVVRTQ0hMQU5EJywgeDogNDM0NzI4NCwgeTogMzA5MzI3NiwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdHUklFQ0hFTkxBTkQnLCB4OiA1NTUwMDAwLCB5OiAxNTAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1VOR0FSTicsIHg6IDUwMjAwMDAsIHk6IDI2MzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVNMQU5EJywgeDogMzA0MDAwMCwgeTogNDgzMzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJUkxBTkQnLCB4OiAzMTM2MDAwLCB5OiAzMzk0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lUQUxJRU4nLCB4OiA0NDY5OTY3LCB5OiAyMTgxOTYzLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IDM1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xFVFRMQU5EJywgeDogNTI5MDAwMCwgeTogMzgwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xJVEFVRU4nLCB4OiA1MTkwMDAwLCB5OiAzNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFVYLicsIHg6IDQxMjAwMDAsIHk6IDI5NDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNQUxUQScsIHg6IDQ3MzEwMDAsIHk6IDEzMzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNT05ULicsIHg6IDUwNzMwMDAsIHk6IDIxODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JETUFaRURPTklFTicsIHg6IDUzNTAwMDAsIHk6IDIwODIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOSUVERVJMQU5ERScsIHg6IDM5NzcwMDAsIHk6IDMyMDgwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JXRUdFTicsIHg6IDQzMzAwMDAsIHk6IDQxNDcwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BPTEVOJywgeDogNDk2NDAwMCwgeTogMzI2OTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT1JUVUdBTCcsIHg6IDI4MzYxMzYsIHk6IDE5NTYxNzksIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JVTcOETklFTicsIHg6IDU0NTEwMDAsIHk6IDI2MDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0VSQklFTicsIHg6IDUyMDAwMDAsIHk6IDIzMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9XQUtFSScsIHg6IDUwNDAwMDAsIHk6IDI4MzUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAtMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPV0VOSUVOJywgeDogNDczNTAwMCwgeTogMjUyMjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTUEFOSUVOJywgeDogMzE2MDA5NiwgeTogMTg1MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTQ0hXRURFTicsIHg6IDQ2NzAwMDAsIHk6IDQxODAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NDSFdFSVonLCB4OiA0MjAwMDAwLCB5OiAyNTY0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFJVVEhBSE4nLCB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1ZFUkVJTklHVEVTJywgeDogMzU1MDAwMCwgeTogMzUyMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdLw5ZOSUdSRUlDSCcsIHg6IDM1NTAwMDAsIHk6IDM0MjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIElDXzMyNjI4OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdFUycsIHg6IDQyMDQ2OCwgeTogMzE4MDY0NywgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnQ2FuYXJ5IElzbGFuZHMnLCB4OiA0MjA0NjgsIHk6IDMxODA2NDcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZnI6IFt7IHRleHQ6ICdMZXMgw65sZXMgQ2FuYXJpZXMnLCB4OiA0MjA0NjgsIHk6IDMxODA2NDcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZGU6IFt7IHRleHQ6ICdLYW5hcmlzY2hlIEluc2VsbicsIHg6IDQxMDAwMCwgeTogMzE4MDY0NywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgIH0sXHJcbiAgICBHUF8zMjYyMDoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRlInLCB4OiA2NjcwMDAsIHk6IDE3NDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0d1YWRlbG91cGUnLCB4OiA3MDAwMDAsIHk6IDE4MTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICB9LFxyXG4gICAgTVFfMzI2MjA6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0ZSJywgeDogNzE2NTIxLCB5OiAxNjIxMzIyLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdNYXJ0aW5pcXVlJywgeDogNzE2NTIxLCB5OiAxNjIxMzIyLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgfSxcclxuICAgIEdGXzMyNjIyOiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdGUicsIHg6IDI2Njg1MiwgeTogNDQ0MDc0LCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdHdXlhbmUnLCB4OiAyNjY4NTIsIHk6IDQ0NDA3NCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ0d1YXlhbmEnLCB4OiAyNjY4NTIsIHk6IDQ0NDA3NCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgIH0sXHJcbiAgICBSRV8zMjc0MDoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRlInLCB4OiAzNDgwMTEsIHk6IDc2ODAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ1LDqXVuaW9uJywgeDogMzQ4MDExLCB5OiA3NjgwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgfSxcclxuICAgIFlUXzMyNzM4OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdGUicsIHg6IDUxNjU0OSwgeTogODU5MzkyMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnTWF5b3R0ZScsIHg6IDUxNjU0OSwgeTogODU5MzkyMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgIH0sXHJcbiAgICBNVF8zMDM1OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdNVCcsIHg6IDQ3MTk3NTUsIHk6IDE0MTA3MDEsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ01hbHRhJywgeDogNDcxOTc1NSwgeTogMTQxMDcwMSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgIH0sXHJcbiAgICBQVDIwXzMyNjI2OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdQVCcsIHg6IDM5NzQxOCwgeTogNDMyMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnQXpvcmVzJywgeDogMzk3NDE4LCB5OiA0MzIwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGZyOiBbeyB0ZXh0OiAnQcOnb3JlcycsIHg6IDM5NzQxOCwgeTogNDI3MTQ3MSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ0F6b3JlbicsIHg6IDM5NzQxOCwgeTogNDI3MTQ3MSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgIH0sXHJcbiAgICBQVDMwXzMyNjI4OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdQVCcsIHg6IDMzMzU4NiwgeTogMzYyNDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwLCByb3RhdGU6IDMwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnTWFkZWlyYScsIHg6IDMzMzU4NiwgeTogMzYyNDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCwgcm90YXRlOiAzMCB9XSxcclxuICAgICAgICBmcjogW3sgdGV4dDogJ01hZMOocmUnLCB4OiAzMzM1ODYsIHk6IDM2MjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogMzAgfV0sXHJcbiAgICB9LFxyXG4gICAgTElfMzAzNToge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnTEknLCB4OiA0Mjg3MDYwLCB5OiAyNjYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdMaWVjaHRlbnN0ZWluJywgeDogNDI4NzA2MCwgeTogMjY3OTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH1dLFxyXG4gICAgfSxcclxuICAgIElTXzMwMzU6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0lTJywgeDogMzAxMTgwNCwgeTogNDk2MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnSWNlbGFuZCcsIHg6IDMwMTE4MDQsIHk6IDQ5NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZnI6IFt7IHRleHQ6ICdJc2xhbmRlJywgeDogMzAxMTgwNCwgeTogNDk2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ0lzbGFuZCcsIHg6IDMwMTE4MDQsIHk6IDQ5NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICB9LFxyXG4gICAgU0pfU1ZfMzAzNToge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnTk8nLCB4OiA0NTcwMDAwLCB5OiA2MjYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdTdmFsYmFyZCcsIHg6IDQ1NzAwMDAsIHk6IDYyNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZGU6IFt7IHRleHQ6ICdTcGl0emJlcmdlbicsIHg6IDQ1NzAwMDAsIHk6IDYyNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9XSxcclxuICAgIH0sXHJcbiAgICBTSl9KTV8zMDM1OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdOTycsIHg6IDM2NDc3NjIsIHk6IDU0MjAzMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0phbiBNYXllbicsIHg6IDM2NDc3NjIsIHk6IDU0MjAzMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9XSxcclxuICAgIH0sXHJcbiAgICBDQVJJQl8zMjYyMDoge1xyXG4gICAgICAgIGNjOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSJywgeDogNzAwMDAwLCB5OiAxODEwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlInLCB4OiA2NDAwMDAsIHk6IDE1OTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUicsIHg6IDU0MDAwMCwgeTogMTk2MjAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDcgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGVuOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0d1YWRlbG91cGUnLCB4OiA3MDAwMDAsIHk6IDE4MTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTWFydGluaXF1ZScsIHg6IDU3MDAwMCwgeTogMTU5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTYWludCBNYXJ0aW4nLCB4OiA1OTcwMDAsIHk6IDE5NjIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAgLy8gbm90ZTogV09STEQgeC95IGFyZSBpbiBFUFNHOjQzMjYgdGhlbiByZXByb2plY3RlZCBieSBkMyB0byBFUFNHOjU0MDMwXHJcbiAgICBXT1JMRF81NDAzMDoge1xyXG4gICAgICAgIGVuOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUlRIIEFUTEFOVElDJywgeDogLTQ1LCB5OiAyNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU09VVEggQVRMQU5USUMnLCB4OiAtMTUsIHk6IC0yNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU09VVEggUEFDSUZJQycsIHg6IC0xMjYsIHk6IC0yNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SVEgnLCB4OiAtMTM2LCB5OiAyNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUEFDSUZJQycsIHg6IC0xMzQsIHk6IDIwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJTkRJQU4gT0NFQU4nLCB4OiA4MCwgeTogLTI1LCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTT1VUSEVSTiBPQ0VBTicsIHg6IC01LCB5OiAtNjcsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiA2IH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRTVEFUTEFCRUxQT1NJVElPTlMgPSB7XHJcbiAgICBBTDogeyB4OiA1MTUwMDAwLCB5OiAyMDAwMDAwIH0sXHJcbiAgICBBVDogeyB4OiA0NjcwMDAwLCB5OiAyNzQwMDAwIH0sXHJcbiAgICBCRTogeyB4OiAzOTMwMDAwLCB5OiAzMDYwMDAwIH0sXHJcbiAgICBCRzogeyB4OiA1NTY3MDAwLCB5OiAyMzAwMDAwIH0sXHJcbiAgICBIUjogeyB4OiA0NjU3NzE4LCB5OiAyNDAwMjQzIH0sXHJcbiAgICBDWTogeyB4OiA2NDI2MDAwLCB5OiAxNTcwMDAwIH0sXHJcbiAgICBDSDogeyB4OiA0MTcwMDAwLCB5OiAyNjAwMDAwIH0sXHJcbiAgICBDWjogeyB4OiA0NzA3MDAwLCB5OiAyOTUwMDAwIH0sXHJcbiAgICBESzogeyB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwIH0sXHJcbiAgICBFRTogeyB4OiA1MjIwMDAwLCB5OiA0MDUwMDAwIH0sXHJcbiAgICBGSTogeyB4OiA1MTUwMDAwLCB5OiA0NDI0MDAwIH0sXHJcbiAgICBGUjogeyB4OiAzNzY3NzQwLCB5OiAyNjYyODE3IH0sXHJcbiAgICBERTogeyB4OiA0MzQ3Mjg0LCB5OiAzMDkzMjc2IH0sXHJcbiAgICBFTDogeyB4OiA1MzcwMDAwLCB5OiAxNzUwMDAwIH0sXHJcbiAgICBIVTogeyB4OiA1MDIwMDAwLCB5OiAyNjcwMDAwIH0sXHJcbiAgICBJUzogeyB4OiAzMDQwMDAwLCB5OiA0ODMzMDAwIH0sXHJcbiAgICBJRTogeyB4OiAzMTM2MDAwLCB5OiAzMzk0MDAwIH0sXHJcbiAgICBJVDogeyB4OiA0NTAwMDAwLCB5OiAyMTgxOTYzIH0sXHJcbiAgICBMVjogeyB4OiA1MjkwMDAwLCB5OiAzODQwMDAwIH0sXHJcbiAgICBMVDogeyB4OiA1MTkwMDAwLCB5OiAzNjcwMDAwIH0sXHJcbiAgICBMVTogeyB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwIH0sXHJcbiAgICBNVDogeyB4OiA0ODgwMDAwLCB5OiAxNDgwMDAwIH0sXHJcbiAgICBHRTogeyB4OiA2OTEyNjgwLCB5OiAyNjk2NTU0IH0sXHJcbiAgICBVQTogeyB4OiA1ODY1NTA3LCB5OiAzMTMwMTU4IH0sXHJcbiAgICBCQTogeyB4OiA0OTU5MjYyLCB5OiAyMzY4Njg4IH0sXHJcbiAgICBNRDogeyB4OiA1NzM2MDE2LCB5OiAyODM1OTU3IH0sXHJcbiAgICBNRTogeyB4OiA1MDczMDAwLCB5OiAyMjMwMDAwIH0sXHJcbiAgICBNSzogeyB4OiA1MzAwMDAwLCB5OiAyMTMwMDAwIH0sXHJcbiAgICBOTDogeyB4OiA0MDIwMDAwLCB5OiAzMjA4MDAwIH0sXHJcbiAgICBOTzogeyB4OiA0MzAwMDAwLCB5OiA0MTQ3MDAwIH0sXHJcbiAgICBQTDogeyB4OiA0OTY0MDAwLCB5OiAzMjAwMDAwIH0sXHJcbiAgICBQVDogeyB4OiAyNzYwMDAwLCB5OiAxOTkwMDAwIH0sXHJcbiAgICBSTzogeyB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwIH0sXHJcbiAgICBSUzogeyB4OiA1MjAwMDAwLCB5OiAyMzcwMDAwIH0sXHJcbiAgICBTSzogeyB4OiA1MDQwMDAwLCB5OiAyODkwMDAwIH0sXHJcbiAgICBTSTogeyB4OiA0NjYwMDAwLCB5OiAyNTUwMDAwIH0sXHJcbiAgICBFUzogeyB4OiAzMjAwMDAwLCB5OiAyMDAwMDAwIH0sXHJcbiAgICBTRTogeyB4OiA0NjMwMDAwLCB5OiA0MDAwMDAwIH0sXHJcbiAgICBUUjogeyB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwIH0sXHJcbiAgICBVSzogeyB4OiAzNTU4MDAwLCB5OiAzMjUwMDAwIH0sXHJcbiAgICBSVTogeyB4OiA2ODQyMDg2LCB5OiAzMjMwNTE3IH0sXHJcbn1cclxuIiwiaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSAnZDMtem9vbSdcclxuaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGZvcm1hdERlZmF1bHRMb2NhbGUgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCB7IGdlb0lkZW50aXR5LCBnZW9QYXRoLCBnZW9DZW50cm9pZCB9IGZyb20gJ2QzLWdlbydcclxuaW1wb3J0IHsgZ2VvUm9iaW5zb24gfSBmcm9tICdkMy1nZW8tcHJvamVjdGlvbidcclxuaW1wb3J0IHsgZ2V0QkJPWEFzR2VvSlNPTiwgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Rm9udFNpemVGcm9tQ2xhc3MsIGdldFBhcmFtZXRlckJ5TmFtZSwgY29udmVydFJlY3RhbmdsZXNUb1BhdGhzIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IHsgYXBwZW5kQW5ub3RhdGlvbnMgfSBmcm9tICcuL2Fubm90YXRpb25zJ1xyXG5pbXBvcnQgeyBhZGRMYWJlbHNUb01hcCwgdXBkYXRlTGFiZWxzLCB1cGRhdGVWYWx1ZXNMYWJlbHMgfSBmcm9tICcuL2xhYmVscydcclxuaW1wb3J0IHsgZGVmaW5lRGVwcmVjYXRlZEZ1bmN0aW9ucyB9IGZyb20gJy4vZGVwcmVjYXRlZCdcclxuaW1wb3J0IHsgR2VvbWV0cmllcyB9IGZyb20gJy4vZ2VvbWV0cmllcydcclxuaW1wb3J0IHsgYnVpbGRJbnNldHMsIHJlbW92ZUluc2V0cyB9IGZyb20gJy4vaW5zZXRzJ1xyXG5pbXBvcnQgeyBhcHBlbmRTdGFtcCB9IGZyb20gJy4vc3RhbXBzJ1xyXG5pbXBvcnQgeyBidWlsZEdyaWRDYXJ0b2dyYW1CYXNlIH0gZnJvbSAnLi9jYXJ0b2dyYW1zJ1xyXG5cclxuLy8gc2V0IGRlZmF1bHQgZDMgbG9jYWxlXHJcbmZvcm1hdERlZmF1bHRMb2NhbGUoe1xyXG4gICAgZGVjaW1hbDogJy4nLFxyXG4gICAgdGhvdXNhbmRzOiAnICcsXHJcbiAgICBncm91cGluZzogWzNdLFxyXG4gICAgY3VycmVuY3k6IFsnJywgJ+KCrCddLFxyXG59KVxyXG5cclxuLyoqXHJcbiAqIFRoZSBtYXAgdGVtcGxhdGU6IG9ubHkgdGhlIGdlb21ldHJpY2FsIHBhcnQuXHJcbiAqIFRvIGJlIHVzZWQgYXMgYSBiYXNlIG1hcCBmb3IgYSBzdGF0aXN0aWNhbCBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gd2l0aENlbnRlclBvaW50cyBTZXQgdG8gdHJ1ZSAob3IgMSkgdG8gYWRkIHJlZ2lvbnMgY2VudGVyIHBvaW50cyB0byB0aGUgbWFwIHRlbXBsYXRlLCB0byBiZSB1c2VkIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9scyBtYXBzIGZvciBleGFtcGxlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbmZpZywgd2l0aENlbnRlclBvaW50cywgbWFwVHlwZSkge1xyXG4gICAgLy9idWlsZCBtYXAgdGVtcGxhdGUgb2JqZWN0XHJcbiAgICBjb25zdCBvdXQgPSB7fVxyXG4gICAgb3V0Ll9tYXBUeXBlID0gbWFwVHlwZVxyXG5cclxuICAgIC8vIGV4cG9zZSBpbXBvcnRlZCBmdW5jdGlvbiB0byBvdGhlciBtb2R1bGVzXHJcbiAgICBvdXQudXBkYXRlVmFsdWVzTGFiZWxzID0gdXBkYXRlVmFsdWVzTGFiZWxzXHJcblxyXG4gICAgLy9tYXBcclxuICAgIG91dC5zdmdJZF8gPSAnbWFwJ1xyXG4gICAgb3V0LnN2Z18gPSB1bmRlZmluZWRcclxuICAgIG91dC53aWR0aF8gPSBNYXRoLm1pbig3OTUsIHdpbmRvdy5pbm5lcldpZHRoKVxyXG4gICAgb3V0LmhlaWdodF8gPSAwXHJcbiAgICBvdXQuY29udGFpbmVySWRfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9nZW9ncmFwaGljYWwgZm9jdXNcclxuICAgIG91dC5ncmlkQ2FydG9ncmFtXyA9IGZhbHNlIC8vIGRyYXcgZ2VvbWV0cmllcyBhcyBncmlkIGNlbGxzXHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbVNoYXBlXyA9ICdzcXVhcmUnIC8vIHNxdWFyZSBvciBoZXhhZ29uXHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfID0geyB0b3A6IDgwLCByaWdodDogNTAsIGJvdHRvbTogODAsIGxlZnQ6IDE1MCB9XHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbUNlbGxQYWRkaW5nXyA9IDRcclxuICAgIG91dC5ncmlkQ2FydG9ncmFtUG9zaXRpb25zXyA9IHVuZGVmaW5lZCAvL3VzZXIgZGVmaW5lZCBjYXJ0b2dyYW1zXHJcbiAgICBvdXQubnV0c0xldmVsXyA9IDMgLy8gMCwxLDIsMywgb3IgJ21peGVkJ1xyXG4gICAgb3V0Lm51dHNZZWFyXyA9IDIwMjRcclxuICAgIG91dC5nZW9fID0gJ0VVUidcclxuICAgIG91dC5wcm9qXyA9ICczMDM1J1xyXG4gICAgb3V0LnByb2plY3Rpb25GdW5jdGlvbl8gPSB1bmRlZmluZWQgLy8gZS5nLiBkMy5nZW9Sb2JpbnNvbigpXHJcbiAgICBvdXQuZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uXyA9IHVuZGVmaW5lZCAvLyB1c2VyIGRlZmluZWQgZmlsdGVyIGZ1bmN0aW9uXHJcbiAgICBvdXQuc2NhbGVfID0gJzIwTScgLy9UT0RPIGNob29zZSBhdXRvbWF0aWNhbGx5LCBkZXBlbmRpbmcgb24gcGl4ZWxTaXplID9cclxuICAgIG91dC56b29tRXh0ZW50XyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0Lm1heEJvdW5kc18gPSB7IHhNaW46IC1JbmZpbml0eSwgeU1pbjogLUluZmluaXR5LCB4TWF4OiBJbmZpbml0eSwgeU1heDogSW5maW5pdHkgfVxyXG4gICAgb3V0Lmdlb21ldHJpZXNfID0gdW5kZWZpbmVkIC8vIFt7aWQ6U3RyaW5nLCBkYXRhOmdlb2pzb24sIGNsYXNzOmZ1bmN0aW9ufV0gdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgIG91dC5wcm9jZXNzQ2VudHJvaWRzXyA9IHVuZGVmaW5lZCAvLyBydW5zIG92ZXIgc3ltYm9sIGNlbnRyb2lkc1xyXG4gICAgb3V0LnBvc2l0aW9uXyA9IHsgeDogdW5kZWZpbmVkLCB5OiB1bmRlZmluZWQsIHo6IHVuZGVmaW5lZCB9IC8vIG1hcCB2aWV3XHJcblxyXG4gICAgLy9tYXAgdGl0bGVcclxuICAgIG91dC50aXRsZV8gPSAnJ1xyXG4gICAgb3V0LnRpdGxlUG9zaXRpb25fID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9tYXAgc3VidGl0bGVcclxuICAgIG91dC5zdWJ0aXRsZV8gPSAnJ1xyXG4gICAgb3V0LnN1YnRpdGxlUG9zaXRpb25fID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9zY2FsZWJhclxyXG4gICAgb3V0LnNob3dTY2FsZWJhcl8gPSBmYWxzZVxyXG4gICAgb3V0LnNjYWxlYmFyUG9zaXRpb25fID0gW11cclxuICAgIG91dC5zY2FsZWJhclVuaXRzXyA9ICcga20nIC8vbGFiZWxcclxuICAgIG91dC5zY2FsZWJhclRleHRPZmZzZXRfID0gWzAsIDEyXVxyXG4gICAgb3V0LnNjYWxlYmFyTWF4V2lkdGhfID0gMTUwIC8vcHhcclxuICAgIG91dC5zY2FsZWJhckhlaWdodF8gPSA5MCAvL3B4XHJcbiAgICBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gPSAxIC8vcHhcclxuICAgIG91dC5zY2FsZWJhclNlZ21lbnRIZWlnaHRfID0gNlxyXG4gICAgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8gPSA4XHJcblxyXG4gICAgLy8gc3RhbXAgYW5ub3RhdGlvblxyXG4gICAgb3V0LnN0YW1wXyA9IHVuZGVmaW5lZCAvL2UuZyB7eCx5LHRleHQsc2l6ZX1cclxuXHJcbiAgICAvL3Rvb2x0aXBcclxuICAgIG91dC50b29sdGlwXyA9IHtcclxuICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxyXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMjAwLFxyXG4gICAgICAgIHhPZmZzZXQ6IDAsXHJcbiAgICAgICAgeU9mZnNldDogMCxcclxuICAgICAgICB0ZXh0RnVuY3Rpb246IG51bGwsXHJcbiAgICAgICAgc2hvd0ZsYWdzOiBmYWxzZSxcclxuICAgIH0gLy8gIFNlZSB0b29sdGlwLmpzIGZvciBtb3JlIGRldGFpbHNcclxuXHJcbiAgICAvLyByZWdpb24gbW91c2VvdmVyIGNvbG9yXHJcbiAgICBvdXQuaG92ZXJDb2xvcl8gPSAncmVkJ1xyXG5cclxuICAgIC8vY29hc3RhbCBtYXJnaW5cclxuICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbl8gPSBmYWxzZVxyXG4gICAgb3V0LmNvYXN0YWxNYXJnaW5TdGREZXZfID0gM1xyXG5cclxuICAgIC8vZ3JhdGljdWxlXHJcbiAgICBvdXQuZHJhd0dyYXRpY3VsZV8gPSBmYWxzZVxyXG5cclxuICAgIC8vYmFja2dyb3VuZCBtYXAgdG9nZ2xlIChlLmcuIGZvciBkb3JsaW5nKVxyXG4gICAgb3V0LmJhY2tncm91bmRNYXBfID0gdHJ1ZVxyXG5cclxuICAgIC8vbGFiZWxsaW5nXHJcbiAgICAvLyBzZWUgZG9jc1xccmVmZXJlbmNlLm1kI2xhYmVsbGluZ1xyXG4gICAgb3V0LmxhYmVsc18gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL2Fubm90YXRpb25zXHJcbiAgICBvdXQuYW5ub3RhdGlvbnNfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuYW5ub3RhdGlvbnNBZGRlZCA9IGZhbHNlIC8vc2ltcGxlIGZsYWcgdG8ga25vdyB3aGVuIGFubm90YXRpb25zIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkXHJcblxyXG4gICAgLy9oYXRjaGluZ1xyXG4gICAgb3V0LnBhdHRlcm5GaWxsXyA9IHVuZGVmaW5lZCAvLyBlLmcuIHtwYXR0ZXJuOidoYXRjaGluZycscmVnaW9uSWRzOlsnREUnLCdGUiddfVxyXG5cclxuICAgIC8vZGF0YXNldCBzb3VyY2UgbGlua1xyXG4gICAgb3V0LnNob3dTb3VyY2VMaW5rXyA9IHRydWVcclxuXHJcbiAgICAvL2RlZmF1bHQgY29weXJpZ2h0IGFuZCBkaXNjbGFpbWVyIHRleHRcclxuICAgIG91dC5mb290bm90ZV8gPSAnQWRtaW5pc3RyYXRpdmUgYm91bmRhcmllczogXFx1MDBBOUV1cm9HZW9ncmFwaGljcyBcXHUwMEE5VU4tRkFPIFxcdTAwQTlJTlNUQVQgXFx1MDBBOVR1cmtzdGF0JyAvL1wiKEMpRXVyb0dlb2dyYXBoaWNzIChDKVVOLUZBTyAoQylUdXJrc3RhdFwiO1xyXG4gICAgb3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfID1cclxuICAgICAgICAnVGhlIGRlc2lnbmF0aW9ucyBlbXBsb3llZCBhbmQgdGhlIHByZXNlbnRhdGlvbiBvZiBtYXRlcmlhbCBvbiB0aGlzIG1hcCBkbyBub3QgaW1wbHkgdGhlIGV4cHJlc3Npb24gb2YgYW55IG9waW5pb24gd2hhdHNvZXZlciBvbiB0aGUgcGFydCBvZiB0aGUgRXVyb3BlYW4gVW5pb24gY29uY2VybmluZyB0aGUgbGVnYWwgc3RhdHVzIG9mIGFueSBjb3VudHJ5LCB0ZXJyaXRvcnksIGNpdHkgb3IgYXJlYSBvciBvZiBpdHMgYXV0aG9yaXRpZXMsIG9yIGNvbmNlcm5pbmcgdGhlIGRlbGltaXRhdGlvbiBvZiBpdHMgZnJvbnRpZXJzIG9yIGJvdW5kYXJpZXMuIEtvc292byo6IFRoaXMgZGVzaWduYXRpb24gaXMgd2l0aG91dCBwcmVqdWRpY2UgdG8gcG9zaXRpb25zIG9uIHN0YXR1cywgYW5kIGlzIGluIGxpbmUgd2l0aCBVTlNDUiAxMjQ0LzE5OTkgYW5kIHRoZSBJQ0ogT3BpbmlvbiBvbiB0aGUgS29zb3ZvIGRlY2xhcmF0aW9uIG9mIGluZGVwZW5kZW5jZS4nXHJcblxyXG4gICAgb3V0Lm51dHMyanNvbkJhc2VVUkxfID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmluY2x1ZGVzKCdlYy5ldXJvcGEuZXUnKVxyXG4gICAgICAgID8gJ2h0dHBzOi8vZWMuZXVyb3BhLmV1L2Fzc2V0cy9lc3RhdC9FL0U0L2dpc2NvL3B1Yi9udXRzMmpzb24vdjInXHJcbiAgICAgICAgOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V1cm9zdGF0L051dHMyanNvbi9tYXN0ZXIvcHViL3YyJ1xyXG5cclxuICAgIC8vc3R5bGUgZm9yIG5vIGRhdGEgcmVnaW9uc1xyXG4gICAgb3V0Lm5vRGF0YUZpbGxTdHlsZV8gPSAnI2JjYmNiYydcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2V0cy5cclxuICAgICAqIFRoZSBtYXAgdGVtcGxhdGUgaGFzIGEgcmVjdXJzaXZlIHN0cnVjdHVyZS5cclxuICAgICAqL1xyXG5cclxuICAgIC8vaW5zZXRzIHRvIHNob3csIGFzIGEgbGlzdCBvZiBtYXAgdGVtcGxhdGUgY29uZmlncy4gRXguOiBbe2dlbzpcIk1UXCJ9LHtnZW86XCJMSVwifSx7Z2VvOlwiUFQyMFwifV1cclxuICAgIG91dC5pbnNldHNfID0gW11cclxuICAgIC8vaW5zZXQgdGVtcGxhdGVzIC0gZWFjaCBpbnNldCBpcyBhIG1hcC10ZW1wbGF0ZSBpbnN0YW5jZS5cclxuICAgIG91dC5pbnNldFRlbXBsYXRlc18gPSB7fVxyXG5cclxuICAgIG91dC5pbnNldEJveFBvc2l0aW9uXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0Lmluc2V0Qm94UGFkZGluZ18gPSA1XHJcbiAgICBvdXQuaW5zZXRCb3hXaWR0aF8gPSAyMTBcclxuICAgIC8vb3V0Lmluc2V0Wm9vbUV4dGVudF8gPSBbMSwgM107XHJcbiAgICBvdXQuaW5zZXRab29tRXh0ZW50XyA9IG51bGwgLy96b29tIGRpc2FibGVkIGFzIGRlZmF1bHRcclxuICAgIG91dC5pbnNldFNjYWxlXyA9ICcwM00nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgZm9yIChjb25zdCBhdHQgaW4gb3V0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdhcm4gZXhpc3RpbmcgdXNlcnMgb2YgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGJhbmlzaGVkIHRvIHRoZSBzaGFkb3cgcmVhbG0uXHJcbiAgICBkZWZpbmVEZXByZWNhdGVkRnVuY3Rpb25zKG91dClcclxuXHJcbiAgICAvLyBjb252ZXJ0IGdlbyB0byB1cHBlcmNhc2VcclxuICAgIG91dC5nZW8gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5nZW9fXHJcbiAgICAgICAgb3V0Lmdlb18gPSB2LnRvVXBwZXJDYXNlKClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWFsIG9uZXMgd2hpY2ggYWZmZWN0IGFsc28gdGhlIGluc2V0c1xyXG4gICAgO1sndG9vbHRpcF8nLCAnbnV0czJqc29uQmFzZVVSTF8nLCAncHJvY2Vzc0NlbnRyb2lkc18nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xyXG4gICAgICAgICAgICAgICAgLy9vdmVycmlkZSBkZWZhdWx0IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0W2F0dF1bcF0gPSB2W3BdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9yZWN1cnNpdmUgY2FsbCB0byBpbnNldCBjb21wb25lbnRzXHJcbiAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKFxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5pbnNldFRlbXBsYXRlc18sXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnN2Z0lkXyxcclxuICAgICAgICAgICAgICAgICAgICAoaW5zZXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuTmFtZSA9IGF0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2V0W2ZuTmFtZV0odmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB2XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy90aXRsZSBnZXR0ZXIgYW5kIHNldHRlclxyXG4gICAgb3V0LnRpdGxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQudGl0bGVfXHJcbiAgICAgICAgb3V0LnRpdGxlXyA9IHZcclxuICAgICAgICBpZiAob3V0LnN2ZygpKVxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyN0aXRsZScgKyBvdXQuZ2VvKCkpXHJcbiAgICAgICAgICAgICAgICAudGV4dCh2KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL3N1YnRpdGxlIGdldHRlciBhbmQgc2V0dGVyXHJcbiAgICBvdXQuc3VidGl0bGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5zdWJ0aXRsZV9cclxuICAgICAgICBvdXQuc3VidGl0bGVfID0gdlxyXG4gICAgICAgIGlmIChvdXQuc3ZnKCkpXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnI3N1YnRpdGxlJyArIG91dC5nZW8oKSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KHYpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vaW5zZXRzIGdldHRlci9zZXR0ZXJcclxuICAgIG91dC5pbnNldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0Lmluc2V0c19cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIGFyZ3VtZW50c1swXSA9PT0gJ2RlZmF1bHQnKSBvdXQuaW5zZXRzXyA9ICdkZWZhdWx0J1xyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBhcmd1bWVudHNbMF0gPT09IGZhbHNlKSBvdXQuaW5zZXRzXyA9IGZhbHNlXHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkgb3V0Lmluc2V0c18gPSBhcmd1bWVudHNbMF1cclxuICAgICAgICBlbHNlIG91dC5pbnNldHNfID0gYXJndW1lbnRzXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGR5bmFtaWMgZHJhdyBncmF0aWN1bGVcclxuICAgIG91dC5kcmF3R3JhdGljdWxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuZHJhd0dyYXRpY3VsZV9cclxuICAgICAgICBvdXQuZHJhd0dyYXRpY3VsZV8gPSB2XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGdyYXRpY3VsZVxyXG4gICAgICAgIGxldCBncmF0aWN1bGUgPSBvdXQuc3ZnXyA/IG91dC5zdmcoKS5zZWxlY3QoJyNlbS1ncmF0aWN1bGUnKSA6IG51bGxcclxuICAgICAgICBsZXQgemcgPSBvdXQuc3ZnXyA/IG91dC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pIDogbnVsbFxyXG5cclxuICAgICAgICAvLyBpZiBleGlzdGluZyBhbmQgYXJndW1lbnQgaXMgZmFsc2VcclxuICAgICAgICBpZiAoZ3JhdGljdWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChncmF0aWN1bGUuX2dyb3Vwc1swXVswXSAmJiB2ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIGdyYXRpY3VsZS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIG1hcCBhbHJlYWR5IGNyZWF0ZWQgYW5kIGFyZ3VtZW50IGlzIHRydWVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5ncmF0aWN1bGUgJiYgb3V0Ll9wYXRoRnVuY3Rpb24gJiYgemcgJiYgdiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBleGlzdGluZyBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIGdyYXRpY3VsZS5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIG5ldyBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIHpnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMuZ3JhdGljdWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZ3JhdGljdWxlJylcclxuXHJcbiAgICAgICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tZ3JhdGljdWxlJylcclxuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZ3JhdGljdWxlIGJlaGluZCBsYW5kIG1hc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb18gPT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzNdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzFdKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vY29hc3RhbCBtYXJnaW4gb3ZlcnJpZGVcclxuICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmRyYXdDb2FzdGFsTWFyZ2luX1xyXG4gICAgICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbl8gPSB2XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGV4aXN0aW5nXHJcbiAgICAgICAgaWYgKG91dC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXJnaW4gPSBzZWxlY3RBbGwoJyNlbS1jb2FzdC1tYXJnaW4nKVxyXG4gICAgICAgICAgICBsZXQgZmlsdGVyID0gc2VsZWN0KCcjZW0tY29hc3RhbC1ibHVyJylcclxuICAgICAgICAgICAgbGV0IHpnID0gc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXykgfHwgbnVsbFxyXG4gICAgICAgICAgICBpZiAobWFyZ2luLl9ncm91cHNbMF1bMF0gJiYgdiA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ucmVtb3ZlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2ID09IHRydWUgJiYgb3V0Ll9wYXRoRnVuY3Rpb24gJiYgemcpIHtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGV4aXN0aW5nIGdyYXRpY3VsZVxyXG4gICAgICAgICAgICAgICAgbWFyZ2luLnJlbW92ZSgpXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIucmVtb3ZlKClcclxuICAgICAgICAgICAgICAgIC8vYWRkIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgb3V0LnN2Z19cclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdmaWx0ZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdGFsLWJsdXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICctMjAwJScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzQwMCUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnNDAwJScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZmVHYXVzc2lhbkJsdXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpbicsICdTb3VyY2VHcmFwaGljJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgb3V0LmNvYXN0YWxNYXJnaW5TdGREZXZfKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyBmb3IgbWFpbiBtYXAgLSBnZW9tZXRyaWVzIGFyZSBzdGlsbCBpbiBtZW1vcnkgc28gbm8gcmVidWlsZCBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdOZXdDb2FzdGFsTWFyZ2luID0gKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHpvb20gZ3JvdXAgbWlnaHQgbm90IGJlIGluc2lkZSBtYWluIG1hcCAob3V0LnN2Z18pXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgbmV3IGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2cgPSB6b29tR3JvdXAuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb3VudHJpZXMgYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLl9nZW9tLmNudGJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1jbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShtYXAuX2dlb20uY250Ym4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm4ucHJvcGVydGllcy5jbyA9PT0gJ1QnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIG1hcC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vbnV0cyBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuX2dlb20ubnV0c2JuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1udXRzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEobWFwLl9nZW9tLm51dHNibilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLmNvID09PSAnVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgbWFwLl9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLy93b3JsZCBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuX2dlb20ud29ybGRibilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4tbnV0cycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKG1hcC5fZ2VvbS53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuQ09BU19GTEFHID09PSAnVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgbWFwLl9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGZvciBpbnNldHMgLSByZXF1aXJlcyBnZW9tZXRyaWVzIHNvIHdlIGhhdmUgdG8gcmVidWlsZCBiYXNlIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXyAmJiBvdXQuZHJhd0NvYXN0YWxNYXJnaW5fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBkcmF3TmV3Q29hc3RhbE1hcmdpbilcclxuICAgICAgICAgICAgICAgICAgICBkcmF3TmV3Q29hc3RhbE1hcmdpbihvdXQpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBtYXJnaW4gdG8gYmFjayAoaW4gZnJvbnQgb2Ygc2VhKVxyXG4gICAgICAgICAgICAgICAgc2VsZWN0QWxsKCcjZW0tY29hc3QtbWFyZ2luJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb18gPT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXNbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlc1sxXSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vYW5ub3RhdGlvbnMgb3ZlcnJpZGUgKHVwZGF0ZSBhZnRlciBmaXJzdCBjYWxsKVxyXG4gICAgb3V0LmFubm90YXRpb25zID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvL2dldFxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5hbm5vdGF0aW9uc19cclxuICAgICAgICAvL3NldFxyXG4gICAgICAgIG91dC5hbm5vdGF0aW9uc18gPSB2XHJcbiAgICAgICAgLy91cGRhdGVcclxuICAgICAgICBhcHBlbmRBbm5vdGF0aW9ucyhvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhbXBzIG92ZXJyaWRlICh1cGRhdGUgYWZ0ZXIgZmlyc3QgY2FsbClcclxuICAgIG91dC5zdGFtcCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgLy9nZXRcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuc3RhbXBfXHJcbiAgICAgICAgLy9zZXRcclxuICAgICAgICBvdXQuc3RhbXBfID0gdlxyXG4gICAgICAgIC8vdXBkYXRlXHJcbiAgICAgICAgYXBwZW5kU3RhbXAob3V0LnN0YW1wXywgb3V0KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL2xhYmVscyBvdmVycmlkZSAodXBkYXRlIGFmdGVyIGZpcnN0IGNhbGwpXHJcbiAgICBvdXQubGFiZWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvL2dldFxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5sYWJlbHNfXHJcbiAgICAgICAgLy9zZXRcclxuICAgICAgICBvdXQubGFiZWxzXyA9IHZcclxuICAgICAgICAvL3VwZGF0ZVxyXG4gICAgICAgIHVwZGF0ZUxhYmVscyhvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGluaXRpYXRlIEdlb21ldHJpZXMgY2xhc3NcclxuICAgIG91dC5HZW9tZXRyaWVzID0gR2VvbWV0cmllcyhvdXQsIHdpdGhDZW50ZXJQb2ludHMpXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0cyBnZW9ncmFwaGljIGRhdGEgYW5kIHRoZW4gYnVpbGRzIHRoZSBtYXAgdGVtcGxhdGVcclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZUdlb01hcFRlbXBsYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gRXJhc2UgcHJldmlvdXMgZGF0YVxyXG4gICAgICAgIG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhID0gbnVsbFxyXG4gICAgICAgIG91dC5HZW9tZXRyaWVzLmFsbE5VVFNHZW9EYXRhID0gbnVsbFxyXG4gICAgICAgIG91dC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGEgPSBudWxsXHJcblxyXG4gICAgICAgIGlmIChvdXQuZ2VvbWV0cmllc18pIHtcclxuICAgICAgICAgICAgb3V0Lkdlb21ldHJpZXMuc2V0VXNlckdlb21ldHJpZXMob3V0Lmdlb21ldHJpZXNfKVxyXG4gICAgICAgICAgICAvLyB1c2UgY3VzdG9tIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgICAgIG91dC5idWlsZE1hcFRlbXBsYXRlKClcclxuXHJcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2sgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1c2UgZGVmYXVsdFxyXG4gICAgICAgICAgICBvdXQuR2VvbWV0cmllcy5nZXREZWZhdWx0R2VvRGF0YShvdXQuZ2VvXywgb3V0LmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbl8sIG91dC5udXRzTGV2ZWxfKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIG91dC5idWlsZE1hcFRlbXBsYXRlKClcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIGV4ZWN1dGVGb3JBbGxJbnNldHMgZm9yIHJlY3Vyc2l2ZSBpbnNldCB1cGRhdGVzXHJcbiAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCAoaW5zZXQpID0+IHtcclxuICAgICAgICAgICAgaW5zZXQudXBkYXRlR2VvTWFwVGVtcGxhdGUoY2FsbGJhY2spXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYSBtYXAgb2JqZWN0LCBpbmNsdWRpbmcgY29udGFpbmVyLCBmcmFtZSwgbWFwIHN2ZywgaW5zZXRzIGFuZCBkMyB6b29tXHJcbiAgICAgKi9cclxuICAgIG91dC5idWlsZE1hcFRlbXBsYXRlQmFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2dldCBzdmcgZWxlbWVudC4gQ3JlYXRlIGl0IGlmIGl0IGRvZXMgbm90IGV4aXN0c1xyXG4gICAgICAgIGxldCBzdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkKCkpXHJcbiAgICAgICAgaWYgKHN2Zy5zaXplKCkgPT0gMCkge1xyXG4gICAgICAgICAgICBzdmcgPSBzZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2lkJywgb3V0LnN2Z0lkKCkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN2Zy5hdHRyKCdjbGFzcycsICdlbS1tYXAnKVxyXG4gICAgICAgIG91dC5zdmdfID0gc3ZnXHJcblxyXG4gICAgICAgIC8vc2V0IGNvbnRhaW5lciBmb3IgY2FzZXMgd2hlcmUgY29udGFpbmVyIGNvbnRhaW5zIHZhcmlvdXMgbWFwc1xyXG4gICAgICAgIGlmICghb3V0LmNvbnRhaW5lcklkXykgb3V0LmNvbnRhaW5lcklkXyA9IG91dC5zdmdJZF9cclxuICAgICAgICAvL3Rvb2x0aXAgbmVlZHMgdG8ga25vdyBjb250YWluZXIgdG8gcHJldmVudCBvdmVyZmxvd1xyXG4gICAgICAgIGlmICghb3V0LnRvb2x0aXBfLmNvbnRhaW5lcklkKSB7XHJcbiAgICAgICAgICAgIG91dC50b29sdGlwXy5jb250YWluZXJJZCA9IG91dC5jb250YWluZXJJZF9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2xlYXIgU1ZHICh0byBhdm9pZCBidWlsZGluZyBtdWx0aXBsZSBzdmdzIG9uIHRvcCBvZiBlYWNoIG90aGVyIGR1cmluZyBtdWx0aXBsZSBidWlsZCgpIGNhbGxzKVxyXG4gICAgICAgIHNlbGVjdEFsbCgnIycgKyBvdXQuc3ZnSWQoKSArICcgPiAqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9zZXQgU1ZHIGRpbWVuc2lvbnNcclxuICAgICAgICBpZiAob3V0Lmdlb18udG9VcHBlckNhc2UoKSA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIC8vaWYgbm8gaGVpZ2h0IHdhcyBzcGVjaWZpZWQsIHVzZSA0NSUgb2YgdGhlIHdpZHRoLlxyXG4gICAgICAgICAgICBpZiAoIW91dC5oZWlnaHQoKSkgb3V0LmhlaWdodCgwLjU1ICogb3V0LndpZHRoKCkpXHJcbiAgICAgICAgICAgIHN2Zy5hdHRyKCd3aWR0aCcsIG91dC53aWR0aCgpKS5hdHRyKCdoZWlnaHQnLCBvdXQuaGVpZ2h0KCkpXHJcblxyXG4gICAgICAgICAgICAvL1dPUkxEIGdlbyBvbmx5IGFjY2VwdHMgcHJvaiA1NDAzMCAocm9iaW5zb24pIGF0IHRoZSBtb21lbnRcclxuICAgICAgICAgICAgb3V0LnByb2pfID0gNTQwMzBcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pZiBubyBoZWlnaHQgd2FzIHNwZWNpZmllZCwgdXNlIDg1JSBvZiB0aGUgd2lkdGguXHJcbiAgICAgICAgaWYgKCFvdXQuaGVpZ2h0KCkpIG91dC5oZWlnaHQoMC44NSAqIG91dC53aWR0aCgpKVxyXG4gICAgICAgIHN2Zy5hdHRyKCd3aWR0aCcsIG91dC53aWR0aCgpKS5hdHRyKCdoZWlnaHQnLCBvdXQuaGVpZ2h0KCkpXHJcblxyXG4gICAgICAgIC8vIGVhY2ggbWFwIHRlbXBsYXRlIG5lZWRzIGEgY2xpcFBhdGggdG8gYXZvaWQgb3ZlcmZsb3cuIFNlZSBHSVNDTy0yNzA3XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZGVmcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1kZWZzJylcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2xpcFBhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCBvdXQuc3ZnSWRfICsgJy1jbGlwLXBhdGgnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBjb252ZXJ0UmVjdGFuZ2xlc1RvUGF0aHMoMCwgMCwgb3V0LndpZHRoXywgb3V0LmhlaWdodF8pKVxyXG5cclxuICAgICAgICBpZiAob3V0LmRyYXdDb2FzdGFsTWFyZ2luXykge1xyXG4gICAgICAgICAgICAvL2RlZmluZSBmaWx0ZXIgZm9yIGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2ZpbHRlcicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3RhbC1ibHVyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICc0MDAlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnNDAwJScpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdmZUdhdXNzaWFuQmx1cicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaW4nLCAnU291cmNlR3JhcGhpYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgb3V0LmNvYXN0YWxNYXJnaW5TdGREZXZfKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgZHJhd2luZyBncm91cCwgYXMgZmlyc3QgY2hpbGRcclxuICAgICAgICBjb25zdCBkZyA9IHN2Z1xyXG4gICAgICAgICAgICAuaW5zZXJ0KCdnJywgJzpmaXJzdC1jaGlsZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1kcmF3aW5nLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZHJhd2luZy1ncm91cCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCMnICsgb3V0LnN2Z0lkXyArICctY2xpcC1wYXRoJyArICcpJylcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgbWFpbiB6b29tIGdyb3VwXHJcbiAgICAgICAgY29uc3QgemcgPSBkZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS16b29tLWdyb3VwJykgLy9vdXQuZ2VvIGNoYW5nZWQgdG8gb3V0LnN2Z0lkIGluIG9yZGVyIHRvIGJlIHVuaXF1ZVxyXG5cclxuICAgICAgICAvLyBidWlsZCBpbnNldHNcclxuICAgICAgICByZW1vdmVJbnNldHMob3V0KSAvL3JlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgIGJ1aWxkSW5zZXRzKG91dCwgd2l0aENlbnRlclBvaW50cykgLy9idWlsZCBuZXdcclxuXHJcbiAgICAgICAgLy9kcmF3IGZyYW1lXHJcbiAgICAgICAgZGcuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWZyYW1lLScgKyBvdXQuZ2VvXylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZyYW1lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC53aWR0aF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuaGVpZ2h0XylcclxuXHJcbiAgICAgICAgaWYgKG91dC5zdGFtcF8pIHtcclxuICAgICAgICAgICAgYXBwZW5kU3RhbXAob3V0LnN0YW1wXywgb3V0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpZCBhbiBlbXB0eSBtYXAgdGVtcGxhdGUsIGJhc2VkIG9uIHRoZSBnZW9tZXRyaWVzIG9ubHkuXHJcbiAgICAgKi9cclxuICAgIG91dC5idWlsZE1hcFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vcHJlcGFyZSBkcmF3aW5nIGdyb3VwXHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2ZygpLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgLy9yZW1vdmUgYWxsIGNoaWxkcmVuXHJcbiAgICAgICAgem9vbUdyb3VwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIHNlcGFyYXRlIGxvZ2ljIGZvciBjYXJ0b2dyYW1zXHJcbiAgICAgICAgaWYgKG91dC5ncmlkQ2FydG9ncmFtXyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkR3JpZENhcnRvZ3JhbUJhc2Uob3V0KVxyXG4gICAgICAgICAgICBvdXQuZm9vdG5vdGVfID0gZmFsc2UgLy9kb250IG5lZWQgY29weXJpZ2h0XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBnZW9ncmFwaGljIGxvZ2ljXHJcblxyXG4gICAgICAgICAgICAvLyBwb3NpdGlvblxyXG4gICAgICAgICAgICBpZiAoIW91dC5wb3NpdGlvbl8ueCB8fCAhb3V0LnBvc2l0aW9uXy55KSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVEZWZhdWx0UG9zaXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dC5wb3NpdGlvbl8ueiA9IG91dC5wb3NpdGlvbl8ueiB8fCBnZXREZWZhdWx0WigpXHJcblxyXG4gICAgICAgICAgICAvLyBkMyBwcm9qZWN0aW9uL3BhdGggZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIGRlZmluZVByb2plY3Rpb24oKVxyXG4gICAgICAgICAgICBkZWZpbmVQYXRoRnVuY3Rpb24oKVxyXG5cclxuICAgICAgICAgICAgLy8gZDMgem9vbVxyXG4gICAgICAgICAgICBpZiAob3V0Lnpvb21FeHRlbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lTWFwWm9vbSgpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQuYmFja2dyb3VuZE1hcF8pIHtcclxuICAgICAgICAgICAgICAgIGRyYXdCYWNrZ3JvdW5kTWFwKG91dClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9wcmVwYXJlIGdyb3VwIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9scywgd2l0aCBjZW50cm9pZHNcclxuICAgICAgICBpZiAod2l0aENlbnRlclBvaW50cykge1xyXG4gICAgICAgICAgICBhZGRDZW50cm9pZHNUb01hcChvdXQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgZ2VvZ3JhcGhpY2FsIGxhYmVscyB0byBtYXBcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18pIHtcclxuICAgICAgICAgICAgYWRkTGFiZWxzVG9NYXAob3V0LCB6b29tR3JvdXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2Fubm90YXRpb25zXHJcbiAgICAgICAgaWYgKG91dC5hbm5vdGF0aW9uc18pIHtcclxuICAgICAgICAgICAgYXBwZW5kQW5ub3RhdGlvbnMob3V0KVxyXG4gICAgICAgICAgICBvdXQuYW5ub3RhdGlvbnNBZGRlZCA9IHRydWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICBpZiAob3V0LnRpdGxlKCkpIHtcclxuICAgICAgICAgICAgLy9kZWZpbmUgZGVmYXVsdCBwb3NpdGlvblxyXG4gICAgICAgICAgICBsZXQgY3NzQ2xhc3MgPSBvdXQuaXNJbnNldCA/ICdlbS1pbnNldC10aXRsZScgOiAnZW0tdGl0bGUnXHJcbiAgICAgICAgICAgIGlmICghb3V0LnRpdGxlUG9zaXRpb24oKSkgb3V0LnRpdGxlUG9zaXRpb24oWzEwLCBnZXRGb250U2l6ZUZyb21DbGFzcyhjc3NDbGFzcykgKyAob3V0LmlzSW5zZXQgPyAwIDogMTApXSlcclxuICAgICAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAndGl0bGUnICsgb3V0Lmdlb18pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBjc3NDbGFzcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LnRpdGxlUG9zaXRpb24oKVswXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnRpdGxlUG9zaXRpb24oKVsxXSlcclxuICAgICAgICAgICAgICAgIC5odG1sKG91dC50aXRsZSgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zdWJ0aXRsZVxyXG4gICAgICAgIGlmIChvdXQuc3VidGl0bGUoKSkge1xyXG4gICAgICAgICAgICBsZXQgY3NzU3VidGl0bGVDbGFzcyA9IG91dC5pc0luc2V0ID8gJ2VtLWluc2V0LXN1YnRpdGxlJyA6ICdlbS1zdWJ0aXRsZSdcclxuICAgICAgICAgICAgbGV0IGNzc1RpdGxlQ2xhc3MgPSBvdXQuaXNJbnNldCA/ICdlbS1pbnNldC10aXRsZScgOiAnZW0tdGl0bGUnXHJcbiAgICAgICAgICAgIC8vZGVmaW5lIGRlZmF1bHQgcG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKCFvdXQuc3VidGl0bGVQb3NpdGlvbigpKSBvdXQuc3VidGl0bGVQb3NpdGlvbihbMTAsIGdldEZvbnRTaXplRnJvbUNsYXNzKGNzc1RpdGxlQ2xhc3MpICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoY3NzU3VidGl0bGVDbGFzcykgKyAxNV0pXHJcbiAgICAgICAgICAgIC8vZHJhdyBzdWJ0aXRsZVxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3N1YnRpdGxlJyArIG91dC5nZW9fKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgY3NzU3VidGl0bGVDbGFzcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LnN1YnRpdGxlUG9zaXRpb24oKVswXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnN1YnRpdGxlUG9zaXRpb24oKVsxXSlcclxuICAgICAgICAgICAgICAgIC5odG1sKG91dC5zdWJ0aXRsZSgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9ib3R0b20gdGV4dFxyXG4gICAgICAgIGlmIChvdXQuZm9vdG5vdGVfKSB7XHJcbiAgICAgICAgICAgIGFkZEZvb3Rub3RlKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc291cmNlIGRhdGFzZXQgVVJMXHJcbiAgICAgICAgaWYgKG91dC5zaG93U291cmNlTGlua18pIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRcclxuICAgICAgICAgICAgaWYgKHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXQgPSBvdXQuc3RhdCgnc2l6ZScpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ID0gb3V0LnN0YXQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdC5ldXJvc3RhdERhdGFzZXRDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kYXRhc2V0IGxpbmtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHN0YXQuZXVyb3N0YXREYXRhc2V0Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBgaHR0cHM6Ly9lYy5ldXJvcGEuZXUvZXVyb3N0YXQvZGF0YWJyb3dzZXIvdmlldy8ke2NvZGV9L2RlZmF1bHQvdGFibGU/bGFuZz1lbmBcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluayA9IG91dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnYScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zb3VyY2UtZGF0YXNldC1saW5rJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCB1cmwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0YXJnZXQnLCAnX2JsYW5rJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zb3VyY2UtZGF0YXNldC1saW5rLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC53aWR0aF8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmhlaWdodF8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KCdFVVJPU1RBVCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3ByZXRleHQgXCJTb3VyY2U6XCJcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlua1cgPSBsaW5rLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKVxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNvdXJjZS1wcmV0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQud2lkdGhfIC0gbGlua1cgLSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5oZWlnaHRfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dCgnU291cmNlOicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzY2FsZWJhclxyXG4gICAgICAgIGlmIChvdXQuc2hvd1NjYWxlYmFyXykge1xyXG4gICAgICAgICAgICBpZiAob3V0LnNjYWxlYmFyUG9zaXRpb25fLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgb3V0LnNjYWxlYmFyUG9zaXRpb25fWzBdID0gMTVcclxuICAgICAgICAgICAgICAgIG91dC5zY2FsZWJhclBvc2l0aW9uX1sxXSA9IG91dC5oZWlnaHRfIC0gNTBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRTY2FsZWJhclRvTWFwKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcmF3QmFja2dyb3VuZE1hcCA9IGZ1bmN0aW9uIChvdXQpIHtcclxuICAgICAgICAvL2RyYXcgYmFja2dyb3VuZCBtYXBcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBvdXQuc3ZnKCkuc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAvL2RyYXcgc2VhXHJcbiAgICAgICAgem9vbUdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnc2VhJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNlYScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgLTUgKiBvdXQud2lkdGhfKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIC01ICogb3V0LmhlaWdodF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDExICogb3V0LndpZHRoXylcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDExICogb3V0LmhlaWdodF8pXHJcblxyXG4gICAgICAgIC8vc3BoZXJlIGZvciB3b3JsZCBtYXBcclxuICAgICAgICBpZiAob3V0Lmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICB6b29tR3JvdXAuYXBwZW5kKCdwYXRoJykuZGF0dW0oeyB0eXBlOiAnU3BoZXJlJyB9KS5hdHRyKCdpZCcsICdzcGhlcmUnKS5hdHRyKCdkJywgb3V0Ll9wYXRoRnVuY3Rpb24pLmF0dHIoJ2NsYXNzJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb2FzdGFsIG1hcmdpblxyXG4gICAgICAgIGlmIChvdXQuZHJhd0NvYXN0YWxNYXJnaW5fKSB7XHJcbiAgICAgICAgICAgIGFkZENvYXN0YWxNYXJnaW5Ub01hcCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkcmF3IHBvbHlnb25zIGFuZCBib3JkZXJzXHJcbiAgICAgICAgaWYgKG91dC5nZW9tZXRyaWVzXykge1xyXG4gICAgICAgICAgICBvdXQuR2VvbWV0cmllcy5hZGRVc2VyR2VvbWV0cmllc1RvTWFwKG91dC5nZW9tZXRyaWVzXywgem9vbUdyb3VwLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXQuR2VvbWV0cmllcy5hZGREZWZhdWx0R2VvbWV0cmllc1RvTWFwKFxyXG4gICAgICAgICAgICAgICAgem9vbUdyb3VwLFxyXG4gICAgICAgICAgICAgICAgb3V0LmRyYXdHcmF0aWN1bGVfLFxyXG4gICAgICAgICAgICAgICAgb3V0Ll9wYXRoRnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBvdXQubnV0c0xldmVsXyxcclxuICAgICAgICAgICAgICAgIG91dC5udXRzWWVhcl8sXHJcbiAgICAgICAgICAgICAgICBvdXQuZ2VvXyxcclxuICAgICAgICAgICAgICAgIG91dC5wcm9qXyxcclxuICAgICAgICAgICAgICAgIG91dC5zY2FsZV9cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWZpbmVEZWZhdWx0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFBvc2l0aW9uID0gX2RlZmF1bHRQb3NpdGlvbltvdXQuZ2VvXyArICdfJyArIG91dC5wcm9qX11cclxuICAgICAgICBpZiAoZGVmYXVsdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIG91dC5wb3NpdGlvbl8ueCA9IG91dC5wb3NpdGlvbl8ueCB8fCBkZWZhdWx0UG9zaXRpb24uZ2VvQ2VudGVyWzBdXHJcbiAgICAgICAgICAgIG91dC5wb3NpdGlvbl8ueSA9IG91dC5wb3NpdGlvbl8ueSB8fCBkZWZhdWx0UG9zaXRpb24uZ2VvQ2VudGVyWzFdXHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YT8uYmJveCkge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGNlbnRlciBvZiBnZW9EYXRhIGJib3hcclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy54ID0gb3V0LnBvc2l0aW9uXy54IHx8IDAuNSAqIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzBdICsgb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFsyXSlcclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gb3V0LnBvc2l0aW9uXy55IHx8IDAuNSAqIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzFdICsgb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFszXSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL1RPRE86IGF1dG8tZGVmaW5lIHVzZXI9ZGVmaW5lZCBnZW9tZXRyaWVzIGdlb0NlbnRlclxyXG4gICAgICAgICAgICAvLyBvdXQucG9zaXRpb25fLnggPSBHZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzXHJcbiAgICAgICAgICAgIC8vIG91dC5wb3NpdGlvbl8ueSA9IEdlb21ldHJpZXMudXNlckdlb21ldHJpZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9wdGlvbmFsOiBzZXQgZnJvbSBVUkxcclxuICAgICAgICBzZXRWaWV3RnJvbVVSTCgpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2V0RGVmYXVsdFogPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFBvc2l0aW9uID0gX2RlZmF1bHRQb3NpdGlvbltvdXQuZ2VvXyArICdfJyArIG91dC5wcm9qX11cclxuICAgICAgICBpZiAoZGVmYXVsdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZGVmYXVsdFBvc2l0aW9uLnBpeGVsU2l6ZSAqIDgwMCkgLyBvdXQud2lkdGhfXHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YT8uYmJveCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICAob3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFsyXSAtIG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbMF0pIC8gb3V0LndpZHRoXyxcclxuICAgICAgICAgICAgICAgIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzNdIC0gb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFsxXSkgLyBvdXQuaGVpZ2h0X1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEwMFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWZpbmVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERlZmluZSBwcm9qZWN0aW9uIGJhc2VkIG9uIHRoZSBnZW9ncmFwaGljYWwgY29udGV4dFxyXG5cclxuICAgICAgICBpZiAob3V0Lmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgLy8gVXNlIFJvYmluc29uIHByb2plY3Rpb24gZm9yIHRoZSB3b3JsZCB3aXRoIG9wdGlvbmFsIGN1c3RvbSBwcm9qZWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIG91dC5fcHJvamVjdGlvbiA9XHJcbiAgICAgICAgICAgICAgICBvdXQucHJvamVjdGlvbkZ1bmN0aW9uXyB8fFxyXG4gICAgICAgICAgICAgICAgZ2VvUm9iaW5zb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW291dC53aWR0aF8gLyAyLCBvdXQuaGVpZ2h0XyAvIDJdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSgob3V0LndpZHRoXyAtIDIwKSAvICgyICogTWF0aC5QSSkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRm9yIG5vbi1XT1JMRCBnZW8sIHVzZSBjdXN0b20gb3IgZGVmYXVsdCBpZGVudGl0eSBwcm9qZWN0aW9uIHdpdGggY2FsY3VsYXRlZCBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgb3V0Ll9wcm9qZWN0aW9uID1cclxuICAgICAgICAgICAgICAgIG91dC5wcm9qZWN0aW9uRnVuY3Rpb25fIHx8IGdlb0lkZW50aXR5KCkucmVmbGVjdFkodHJ1ZSkuZml0U2l6ZShbb3V0LndpZHRoXywgb3V0LmhlaWdodF9dLCBnZXRCQk9YQXNHZW9KU09OKGdldEN1cnJlbnRCYm94KCkpKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGN1cnJlbnQgdmlldyBhcyBiYm94XHJcbiAgICBjb25zdCBnZXRDdXJyZW50QmJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBoYWxmV2lkdGggPSAwLjUgKiBvdXQucG9zaXRpb25fLnogKiBvdXQud2lkdGhfXHJcbiAgICAgICAgY29uc3QgaGFsZkhlaWdodCA9IDAuNSAqIG91dC5wb3NpdGlvbl8ueiAqIG91dC5oZWlnaHRfXHJcbiAgICAgICAgY29uc3QgYmJveCA9IFtvdXQucG9zaXRpb25fLnggLSBoYWxmV2lkdGgsIG91dC5wb3NpdGlvbl8ueSAtIGhhbGZIZWlnaHQsIG91dC5wb3NpdGlvbl8ueCArIGhhbGZXaWR0aCwgb3V0LnBvc2l0aW9uXy55ICsgaGFsZkhlaWdodF1cclxuICAgICAgICByZXR1cm4gYmJveFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZVBhdGhGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQuX3BhdGhGdW5jdGlvbiA9IGdlb1BhdGgoKS5wcm9qZWN0aW9uKG91dC5fcHJvamVjdGlvbilcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWZpbmVNYXBab29tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBzdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkKCkpXHJcbiAgICAgICAgbGV0IHByZXZpb3VzVCA9IHpvb21JZGVudGl0eVxyXG4gICAgICAgIGNvbnN0IHhvbyA9IHpvb20oKVxyXG4gICAgICAgICAgICAuc2NhbGVFeHRlbnQob3V0Lnpvb21FeHRlbnQoKSlcclxuICAgICAgICAgICAgLm9uKCd6b29tJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRyYW5zZm9ybVxyXG4gICAgICAgICAgICAgICAgaWYgKHQuayAhPT0gcHJldmlvdXNULmspIHtcclxuICAgICAgICAgICAgICAgICAgICB6b29tSGFuZGxlcihlLCBwcmV2aW91c1QpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhbkhhbmRsZXIoZSlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBkZWZhdWx0IHRyYW5zZm9ybSB0byBtYXBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21Hcm91cCA9IG91dC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgICAgICAgICB6b29tR3JvdXAuYXR0cigndHJhbnNmb3JtJywgdClcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVCA9IHRcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgc3ZnLmNhbGwoeG9vKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFpvb20gaGFuZGxlciBmdW5jdGlvblxyXG4gICAgY29uc3Qgem9vbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHByZXZpb3VzVCkge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybVxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByb2plY3RlZCBjZW50ZXJcclxuICAgICAgICBjb25zdCBjZW50ZXJYID0gKG91dC53aWR0aF8gLyAyIC0gdHJhbnNmb3JtLngpIC8gdHJhbnNmb3JtLmtcclxuICAgICAgICBjb25zdCBjZW50ZXJZID0gKG91dC5oZWlnaHRfIC8gMiAtIHRyYW5zZm9ybS55KSAvIHRyYW5zZm9ybS5rXHJcblxyXG4gICAgICAgIC8vIFVzZSB0aGUgcHJvamVjdGlvbiB0byBnZXQgdGhlIHByb2plY3RlZCBjZW50ZXIgaW4gRVBTRzozMDM1XHJcbiAgICAgICAgY29uc3QgW3Byb2plY3RlZFgsIHByb2plY3RlZFldID0gb3V0Ll9wcm9qZWN0aW9uLmludmVydChbY2VudGVyWCwgY2VudGVyWV0pXHJcblxyXG4gICAgICAgIC8vIHNldCBuZXcgcG9zaXRpb25cclxuICAgICAgICBvdXQucG9zaXRpb25fLnggPSBwcm9qZWN0ZWRYXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gcHJvamVjdGVkWVxyXG4gICAgICAgIG91dC5wb3NpdGlvbl8ueiA9IGdldE1ldHJlc1BlclBpeGVsKHRyYW5zZm9ybS5rIC8gcHJldmlvdXNULmspXHJcblxyXG4gICAgICAgIC8vIGFkanVzdCBzdHJva2UgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAgICBzY2FsZVN0cm9rZVdpZHRocyh0cmFuc2Zvcm0pXHJcblxyXG4gICAgICAgIC8vIGFkanVzdCBzdHJva2UgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAgICBpZiAob3V0LmxhYmVsc18/LnZhbHVlcykgc2NhbGVMYWJlbFRleHRzKHRyYW5zZm9ybSlcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHN0cm9rZSBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXz8uYmFja2dyb3VuZHMpIHNjYWxlTGFiZWxCYWNrZ3JvdW5kcyh0cmFuc2Zvcm0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYWRqdXN0cyB0ZXh0IGVsZW1lbnRzIGR5bmFtaWNhbGx5IGFjY29yZGluZyB0byB6b29tXHJcbiAgICAgKiBAcGFyYW0geyp9IHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBjb25zdCBzY2FsZUxhYmVsQmFja2dyb3VuZHMgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHpvb21Hcm91cC5zZWxlY3RBbGwoJy5lbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgICAgICBjb25zdCB6b29tRmFjdG9yID0gdHJhbnNmb3JtLmtcclxuICAgICAgICBjb25zdCB1cGRhdGVzID0gW11cclxuXHJcbiAgICAgICAgZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0LCB4LCBhbmQgeSBmcm9tIGRhdGEgYXR0cmlidXRlcyBvciBjdXJyZW50IGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLXdpZHRoJykpIHx8IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCd3aWR0aCcpKVxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLWhlaWdodCcpKSB8fCBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cignaGVpZ2h0JykpXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsWCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLXgnKSkgfHwgcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ3gnKSlcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxZID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEteScpKSB8fCBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cigneScpKVxyXG5cclxuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGVsZW1lbnRzIHRoYXQgaGF2ZSB2YWxpZCB3aWR0aCwgaGVpZ2h0LCB4LCBhbmQgeVxyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxXaWR0aCA+IDAgJiYgb3JpZ2luYWxIZWlnaHQgPiAwICYmICFpc05hTihvcmlnaW5hbFgpICYmICFpc05hTihvcmlnaW5hbFkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgd2lkdGgsIGhlaWdodCwgeCwgYW5kIHkgZm9yIHRoZSBmaXJzdCB0aW1lIGlmIG5vdCBhbHJlYWR5IHN0b3JlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmF0dHIoJ2RhdGEtd2lkdGgnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS13aWR0aCcsIG9yaWdpbmFsV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLWhlaWdodCcsIG9yaWdpbmFsSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS14Jywgb3JpZ2luYWxYKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS15Jywgb3JpZ2luYWxZKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFyZ2V0IHdpZHRoLCBoZWlnaHQsIHgsIGFuZCB5IGJhc2VkIG9uIHpvb20gZmFjdG9yIChpbnZlcnNlIHNjYWxpbmcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IG9yaWdpbmFsV2lkdGggKiAoMSAvIHpvb21GYWN0b3IpIC8vIEludmVyc2Ugc2NhbGluZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQgKiAoMSAvIHpvb21GYWN0b3IpIC8vIEludmVyc2Ugc2NhbGluZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0WCA9IG9yaWdpbmFsWCAqICgxIC8gem9vbUZhY3RvcikgLy8gQWRqdXN0IHggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFkgPSBvcmlnaW5hbFkgKiAoMSAvIHpvb21GYWN0b3IpIC8vIEFkanVzdCB5IHBvc2l0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzdHlsZSBjaGFuZ2UgdG8gYSBiYXRjaCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKHsgZWxlbWVudCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdGFyZ2V0WCwgdGFyZ2V0WSB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgYWxsIHN0eWxlIGNoYW5nZXMgYXQgb25jZVxyXG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaCgoeyBlbGVtZW50LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRYLCB0YXJnZXRZIH0pID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5hdHRyKCd3aWR0aCcsIHRhcmdldFdpZHRoKS5hdHRyKCdoZWlnaHQnLCB0YXJnZXRIZWlnaHQpLmF0dHIoJ3gnLCB0YXJnZXRYKS5hdHRyKCd5JywgdGFyZ2V0WSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYWRqdXN0cyB0ZXh0IGVsZW1lbnRzIGR5bmFtaWNhbGx5IGFjY29yZGluZyB0byB6b29tXHJcbiAgICAgKiBAcGFyYW0geyp9IHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBjb25zdCBzY2FsZUxhYmVsVGV4dHMgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSB6b29tR3JvdXAuc2VsZWN0KCcjZW0tbGFiZWxzJylcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGxhYmVscy5zZWxlY3RBbGwoJyonKSAvLyBTZWxlY3QgYWxsIGxhYmVsc1xyXG4gICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXVxyXG5cclxuICAgICAgICBlbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcylcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBmb250LXNpemUgZnJvbSBpbmxpbmUgb3IgY29tcHV0ZWQgc3R5bGVcclxuICAgICAgICAgICAgY29uc3QgaW5saW5lRm9udFNpemUgPSBlbGVtZW50LmF0dHIoJ2ZvbnQtc2l6ZScpXHJcbiAgICAgICAgICAgIGNvbnN0IGNzc0ZvbnRTaXplID0gY29tcHV0ZWRTdHlsZS5mb250U2l6ZVxyXG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IGlubGluZUZvbnRTaXplIHx8IGNzc0ZvbnRTaXplXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZWxlbWVudHMgdGhhdCBoYXZlIGEgZm9udCBzaXplIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKGZvbnRTaXplICYmIHBhcnNlRmxvYXQoZm9udFNpemUpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGb250U2l6ZSA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLWZzJykpIHx8IHBhcnNlRmxvYXQoaW5saW5lRm9udFNpemUpIHx8IHBhcnNlRmxvYXQoY3NzRm9udFNpemUpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGZvbnQgc2l6ZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5hdHRyKCdkYXRhLWZzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2RhdGEtZnMnLCBvcmlnaW5hbEZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFyZ2V0IGZvbnQgc2l6ZSBiYXNlZCBvbiB6b29tIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Rm9udFNpemUgPSBvcmlnaW5hbEZvbnRTaXplIC8gem9vbUZhY3RvclxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc3R5bGUgY2hhbmdlIHRvIGEgYmF0Y2ggYXJyYXlcclxuICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaCh7IGVsZW1lbnQ6IHRoaXMsIHRhcmdldEZvbnRTaXplIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBBcHBseSBhbGwgc3R5bGUgY2hhbmdlcyBhdCBvbmNlXHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKCh7IGVsZW1lbnQsIHRhcmdldEZvbnRTaXplIH0pID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnZm9udC1zaXplJywgYCR7dGFyZ2V0Rm9udFNpemV9cHhgLCAnaW1wb3J0YW50JylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGFkanVzdHMgYWxsIHN0cm9rZS13aWR0aHMgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAqIEBwYXJhbSB7Kn0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNjYWxlU3Ryb2tlV2lkdGhzID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIGNvbnN0IHpvb21Hcm91cCA9IG91dC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB6b29tR3JvdXAuc2VsZWN0QWxsKCcqJykgLy8gU2VsZWN0IGFsbCBlbGVtZW50cyBpbiB0aGUgem9vbSBncm91cFxyXG4gICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXVxyXG5cclxuICAgICAgICBlbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcylcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBzdHJva2Utd2lkdGggZnJvbSBpbmxpbmUgb3IgY29tcHV0ZWQgc3R5bGVcclxuICAgICAgICAgICAgY29uc3QgaW5saW5lU3Ryb2tlV2lkdGggPSBlbGVtZW50LmF0dHIoJ3N0cm9rZS13aWR0aCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGNzc1N0cm9rZVdpZHRoID0gY29tcHV0ZWRTdHlsZS5zdHJva2VXaWR0aFxyXG4gICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IGlubGluZVN0cm9rZVdpZHRoIHx8IGNzc1N0cm9rZVdpZHRoXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZWxlbWVudHMgdGhhdCBoYXZlIGEgc3Ryb2tlIHdpZHRoIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKHN0cm9rZVdpZHRoICYmIHBhcnNlRmxvYXQoc3Ryb2tlV2lkdGgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdHJva2VXaWR0aCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLXN3JykpIHx8IHBhcnNlRmxvYXQoaW5saW5lU3Ryb2tlV2lkdGgpIHx8IHBhcnNlRmxvYXQoY3NzU3Ryb2tlV2lkdGgpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHN0cm9rZSB3aWR0aCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5hdHRyKCdkYXRhLXN3JykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2RhdGEtc3cnLCBvcmlnaW5hbFN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFyZ2V0IHN0cm9rZSB3aWR0aFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0U3Ryb2tlV2lkdGggPSBvcmlnaW5hbFN0cm9rZVdpZHRoIC8gem9vbUZhY3RvclxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc3R5bGUgY2hhbmdlIHRvIGEgYmF0Y2ggYXJyYXlcclxuICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaCh7IGVsZW1lbnQ6IHRoaXMsIHRhcmdldFN0cm9rZVdpZHRoIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBBcHBseSBhbGwgc3R5bGUgY2hhbmdlcyBhdCBvbmNlXHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKCh7IGVsZW1lbnQsIHRhcmdldFN0cm9rZVdpZHRoIH0pID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnc3Ryb2tlLXdpZHRoJywgYCR7dGFyZ2V0U3Ryb2tlV2lkdGh9cHhgLCAnaW1wb3J0YW50JylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGdldCB0aGUgY3VycmVudCB2aWV3J3MgbWV0cmVzIHBlciBwaXhlbCwgYmFzZWQgb24gYSB6b29tRmFjdG9yXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbUZhY3RvciB0aGlzIHpvb20gLyBwcmV2aW91cyB6b29tXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldE1ldHJlc1BlclBpeGVsID0gZnVuY3Rpb24gKHpvb21GYWN0b3IpIHtcclxuICAgICAgICAvLyBHZXQgY3VycmVudCBib3VuZGluZyBib3ggd2lkdGggaW4gbWV0ZXJzXHJcbiAgICAgICAgY29uc3QgYmJveCA9IGdldEN1cnJlbnRCYm94KClcclxuICAgICAgICBjb25zdCBiYm94V2lkdGggPSBiYm94WzJdIC0gYmJveFswXSAvLyBCQk9YIHdpZHRoIGluIG1ldGVyc1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbWV0ZXJzIHBlciBwaXhlbFxyXG4gICAgICAgIGNvbnN0IG1ldGVyc1BlclBpeGVsID0gYmJveFdpZHRoIC8gKG91dC53aWR0aF8gKiB6b29tRmFjdG9yKVxyXG5cclxuICAgICAgICByZXR1cm4gbWV0ZXJzUGVyUGl4ZWxcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYW4gaGFuZGxlciBmdW5jdGlvblxyXG4gICAgY29uc3QgcGFuSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCwgcHJldmlvdXNUKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZXZlbnQudHJhbnNmb3JtXHJcblxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByb2plY3RlZCBjZW50ZXJcclxuICAgICAgICBjb25zdCBjZW50ZXJYID0gKG91dC53aWR0aF8gLyAyIC0gdHJhbnNmb3JtLngpIC8gdHJhbnNmb3JtLmtcclxuICAgICAgICBjb25zdCBjZW50ZXJZID0gKG91dC5oZWlnaHRfIC8gMiAtIHRyYW5zZm9ybS55KSAvIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgbGV0IFtnZW9YLCBnZW9ZXSA9IG91dC5fcHJvamVjdGlvbi5pbnZlcnQoW2NlbnRlclgsIGNlbnRlclldKVxyXG5cclxuICAgICAgICAvLyBDbGFtcCBnZW9YIGFuZCBnZW9ZIHRvIG1heCBib3VuZHMgYW5kIGFkanVzdCB0aGUgZXZlbnQgdHJhbnNmb3JtXHJcbiAgICAgICAgaWYgKG91dC5tYXhCb3VuZHNfLnhNaW4gIT09IHVuZGVmaW5lZCAmJiBnZW9YIDwgb3V0Lm1heEJvdW5kc18ueE1pbikge1xyXG4gICAgICAgICAgICBnZW9YID0gb3V0Lm1heEJvdW5kc18ueE1pblxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0ueCA9IG91dC53aWR0aF8gLyAyIC0gb3V0Ll9wcm9qZWN0aW9uKFtnZW9YLCBnZW9ZXSlbMF0gKiB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3V0Lm1heEJvdW5kc18ueU1pbiAhPT0gdW5kZWZpbmVkICYmIGdlb1kgPCBvdXQubWF4Qm91bmRzXy55TWluKSB7XHJcbiAgICAgICAgICAgIGdlb1kgPSBvdXQubWF4Qm91bmRzXy55TWluXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS55ID0gb3V0LmhlaWdodF8gLyAyIC0gb3V0Ll9wcm9qZWN0aW9uKFtnZW9YLCBnZW9ZXSlbMV0gKiB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3V0Lm1heEJvdW5kc18ueE1heCAhPT0gdW5kZWZpbmVkICYmIGdlb1ggPiBvdXQubWF4Qm91bmRzXy54TWF4KSB7XHJcbiAgICAgICAgICAgIGdlb1ggPSBvdXQubWF4Qm91bmRzXy54TWF4XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS54ID0gb3V0LndpZHRoXyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVswXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXQubWF4Qm91bmRzXy55TWF4ICE9PSB1bmRlZmluZWQgJiYgZ2VvWSA+IG91dC5tYXhCb3VuZHNfLnlNYXgpIHtcclxuICAgICAgICAgICAgZ2VvWSA9IG91dC5tYXhCb3VuZHNfLnlNYXhcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnkgPSBvdXQuaGVpZ2h0XyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVsxXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzZXQgbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy54ID0gZ2VvWFxyXG4gICAgICAgIG91dC5wb3NpdGlvbl8ueSA9IGdlb1lcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHgseSx6IGVsZW1lbnRzIGZyb20gVVJMIGFuZCBhc3NpZ24gdGhlbSB0byB0aGUgdmlldy4gKi9cclxuICAgIGNvbnN0IHNldFZpZXdGcm9tVVJMID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHggPSBnZXRQYXJhbWV0ZXJCeU5hbWUoJ3gnKSxcclxuICAgICAgICAgICAgeSA9IGdldFBhcmFtZXRlckJ5TmFtZSgneScpLFxyXG4gICAgICAgICAgICB6ID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCd6JylcclxuICAgICAgICBpZiAoeCAhPSBudWxsICYmIHggIT0gdW5kZWZpbmVkICYmICFpc05hTigreCkpIG91dC5wb3NpdGlvbl8ueCA9ICt4XHJcbiAgICAgICAgaWYgKHkgIT0gbnVsbCAmJiB5ICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4oK3kpKSBvdXQucG9zaXRpb25fLnkgPSAreVxyXG4gICAgICAgIGlmICh6ICE9IG51bGwgJiYgeiAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt6KSkgb3V0LnBvc2l0aW9uXy56ID0gK3pcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRGb290bm90ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1mb290bm90ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1mb290bm90ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuaGVpZ2h0XylcclxuICAgICAgICAgICAgLmh0bWwob3V0LmZvb3Rub3RlXylcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuX3Rvb2x0aXAubXdfX18gPSBvdXQuX3Rvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcpXHJcbiAgICAgICAgICAgICAgICBvdXQuX3Rvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcsICc0MDBweCcpXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC5mb290bm90ZVRvb2x0aXBUZXh0XylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5mb290bm90ZVRvb2x0aXBUZXh0Xykgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuZm9vdG5vdGVUb29sdGlwVGV4dF8pIG91dC5fdG9vbHRpcC5tb3VzZW91dChlKVxyXG4gICAgICAgICAgICAgICAgb3V0Ll90b29sdGlwLnN0eWxlKCdtYXgtd2lkdGgnLCBvdXQuX3Rvb2x0aXAubXdfX18pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkQ29hc3RhbE1hcmdpblRvTWFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHpnID0gb3V0LnN2ZygpLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgLy9kcmF3IGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgY29uc3QgY2cgPSB6Zy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4nKS5hdHRyKCdjbGFzcycsICdlbS1jb2FzdC1tYXJnaW4nKVxyXG5cclxuICAgICAgICAvL2NvdW50cmllcyBiblxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5jbnRibikge1xyXG4gICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1jbnQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNvYXN0LW1hcmdpbi1jbnQnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5jbnRibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLmNvID09PSAnVCdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgb3V0Ll9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL251dHMgYm5cclxuICAgICAgICBpZiAob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c2JuKSB7XHJcbiAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLW51dHMnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNvYXN0LW1hcmdpbi1udXRzJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c2JuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuY28gPT09ICdUJ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vd29ybGQgYm5cclxuICAgICAgICBpZiAob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMud29ybGRibikge1xyXG4gICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi13b3JsZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY29hc3QtbWFyZ2luLXdvcmxkJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMud29ybGRibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLkNPQVNfRkxBRyA9PT0gJ1QnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIG91dC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRDZW50cm9pZHNUb01hcCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBsZXQgY2VudHJvaWRGZWF0dXJlc1xyXG5cclxuICAgICAgICBpZiAoIW1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGEpIHtcclxuICAgICAgICAgICAgLy8gaWYgY2VudHJvaWRzIGRhdGEgaXMgYWJzZW50IChlLmcuIGZvciB3b3JsZCBtYXBzKSB0aGVuIGNhbGN1bGF0ZSBtYW51YWxseVxyXG4gICAgICAgICAgICBpZiAobWFwLmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgY2VudHJvaWRGZWF0dXJlcyA9IFtdXHJcbiAgICAgICAgICAgICAgICBtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy53b3JsZHJnLmZvckVhY2goKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RmVhdHVyZSA9IHsgLi4uZmVhdHVyZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGZvciBGcmFuY2UgKGJlY2F1c2UgZ3V5YW5lKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT0gJ0ZSJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGZWF0dXJlLmdlb21ldHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFsyLjIsIDQ2LjJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BvaW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZlYXR1cmUuZ2VvbWV0cnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogZ2VvQ2VudHJvaWQoZmVhdHVyZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkRmVhdHVyZXMucHVzaChuZXdGZWF0dXJlKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50cm9pZEZlYXR1cmVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGFbMF0uZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YVsxXS5mZWF0dXJlcyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5tYXAuR2VvbWV0cmllcy5jZW50cm9pZHNEYXRhWzJdLmZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGFbM10uZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjZW50cm9pZEZlYXR1cmVzID0gbWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YS5mZWF0dXJlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWFwLnByb2Nlc3NDZW50cm9pZHNfKSBjZW50cm9pZEZlYXR1cmVzID0gbWFwLnByb2Nlc3NDZW50cm9pZHNfKGNlbnRyb2lkRmVhdHVyZXMpXHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzY3JlZW4gY29vcmRpbmF0ZXMgYW5kIHNhdmUgY2VudHJvaWRzIHRvIG1hcFxyXG4gICAgICAgIG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMgPSBjZW50cm9pZEZlYXR1cmVzLm1hcCgoZCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29vcmRzID0gbWFwLl9wcm9qZWN0aW9uKGQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICAgIGQucHJvcGVydGllcy5jZW50cm9pZCA9IGNvb3Jkc1xyXG4gICAgICAgICAgICByZXR1cm4gZFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIGVtLXByb3Atc3ltYm9scyBpcyB0aGUgZyBlbGVtZW50IGNvbnRhaW5pbmcgYWxsIHByb3BvcnRpb25hbCBzeW1ib2xzIGZvciB0aGUgbWFwXHJcbiAgICAgICAgY29uc3QgemcgPSBtYXAuc3ZnKCkuc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICBjb25zdCBnY3AgPSB6Zy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1wcm9wLXN5bWJvbHMnKVxyXG5cclxuICAgICAgICAvLyBhZGQgY2VudHJvaWQgZWxlbWVudHNcclxuICAgICAgICAvLyB0aGVuIHN5bWJvbHMgYXJlIGRyYXduL2FwcGVuZGVkIHRvIHRoZXNlIGNvbnRhaW5lcnMgaW4gdGhlIG1hcC10eXBlIGpzIGZpbGVcclxuICAgICAgICBjb25zdCBzeW1ib2xDb250YWluZXJzID0gZ2NwXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShtYXAuR2VvbWV0cmllcy5jZW50cm9pZEZlYXR1cmVzKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzBdLnRvRml4ZWQoMykgKyAnLCcgKyBkLnByb3BlcnRpZXMuY2VudHJvaWRbMV0udG9GaXhlZCgzKSArICcpJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY2VudHJvaWQnKSAvLyBPVVIgU1lNQk9MIENPTlRBSU5FUlxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gJ3BzJyArIGQucHJvcGVydGllcy5pZClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBhZGRTY2FsZWJhclRvTWFwXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYXBwZW5kcyBhbiBTVkcgc2NhbGViYXIgdG8gdGhlIG1hcC4gVXNlcyBwaXhlbFNpemUgdG8gY2FsY3VsYXRlIHVuaXRzIGluIGttXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFkZFNjYWxlYmFyVG9NYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSnVsaWVuJ3MgbmljZSBzY2FsZWJhcnNcclxuICAgICAgICBjb25zdCBtYXJnaW5MZWZ0ID0gNVxyXG4gICAgICAgIGNvbnN0IG1heExlbmd0aFBpeCA9IG91dC5zY2FsZWJhck1heFdpZHRoX1xyXG4gICAgICAgIGNvbnN0IHRleHRPZmZzZXRYID0gb3V0LnNjYWxlYmFyVGV4dE9mZnNldF9bMF1cclxuICAgICAgICBjb25zdCB0ZXh0T2Zmc2V0WSA9IG91dC5zY2FsZWJhclRleHRPZmZzZXRfWzFdXHJcbiAgICAgICAgY29uc3QgcGl4ZWxTaXplTSA9IG91dC5wb3NpdGlvbl8uelxyXG4gICAgICAgIGNvbnN0IG1heExlbmd0aE0gPSBtYXhMZW5ndGhQaXggKiBwaXhlbFNpemVNXHJcbiAgICAgICAgY29uc3QgbmljZUxlbmd0aE0gPSBuaWNlU2NhbGVCYXJMZW5ndGgobWF4TGVuZ3RoTSlcclxuICAgICAgICBjb25zdCBuaWNlTGVuZ3RoUGl4ZWwgPSBuaWNlTGVuZ3RoTVswXSAvIHBpeGVsU2l6ZU1cclxuICAgICAgICBjb25zdCBzY2FsZUJhclN0YXJ0RGlnaXQgPSBuaWNlTGVuZ3RoTVsxXVxyXG4gICAgICAgIGNvbnN0IHN1YmRpdmlzaW9uTmJzID0ge1xyXG4gICAgICAgICAgICAxOiA0LFxyXG4gICAgICAgICAgICAyOiAyLFxyXG4gICAgICAgICAgICA1OiA1LFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGViYXJHcm91cCA9IG91dFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhcicpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7b3V0LnNjYWxlYmFyUG9zaXRpb25fWzBdfSwke291dC5zY2FsZWJhclBvc2l0aW9uX1sxXX0pYClcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgbWF4TGVuZ3RoUGl4ICsgMjApXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2NhbGViYXJIZWlnaHRfKVxyXG5cclxuICAgICAgICAvLyB0b3AgbGluZSBmdWxsIHdpZHRoXHJcbiAgICAgICAgLy8gc2NhbGViYXJHcm91cFxyXG4gICAgICAgIC8vICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAvLyAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgIC8vICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0KVxyXG4gICAgICAgIC8vICAgICAuYXR0cigneTEnLCAxKVxyXG4gICAgICAgIC8vICAgICAuYXR0cigneDInLCBuaWNlTGVuZ3RoUGl4ZWwgKyBtYXJnaW5MZWZ0KVxyXG4gICAgICAgIC8vICAgICAuYXR0cigneTInLCAxKVxyXG5cclxuICAgICAgICAvL2JvdHRvbSBsaW5lIGZ1bGwgd2lkdGhcclxuICAgICAgICAvLyBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgLy8gICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd5MScsIG91dC5zY2FsZWJhclNlZ21lbnRIZWlnaHRfKVxyXG4gICAgICAgIC8vICAgICAuYXR0cigneDInLCBuaWNlTGVuZ3RoUGl4ZWwgKyBtYXJnaW5MZWZ0KVxyXG4gICAgICAgIC8vICAgICAuYXR0cigneTInLCBvdXQuc2NhbGViYXJTZWdtZW50SGVpZ2h0XylcclxuXHJcbiAgICAgICAgLy9maXJzdCB0aWNrXHJcbiAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCBvdXQuc2NhbGViYXJUaWNrSGVpZ2h0XylcclxuXHJcbiAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW5MZWZ0ICsgdGV4dE9mZnNldFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8gKyB0ZXh0T2Zmc2V0WSlcclxuICAgICAgICAgICAgLnRleHQoJzAnKVxyXG5cclxuICAgICAgICAvL21pZGRsZSB0aWNrc1xyXG4gICAgICAgIGNvbnN0IHN1YmRpdmlzaW9uTmIgPSBzdWJkaXZpc2lvbk5ic1tzY2FsZUJhclN0YXJ0RGlnaXRdXHJcbiAgICAgICAgY29uc3QgZGl2aXNpb25XaWR0aCA9IG5pY2VMZW5ndGhQaXhlbCAvIHN1YmRpdmlzaW9uTmJcclxuICAgICAgICBjb25zdCBkaXZpc2lvbk1pbldpZHRoID0gMTVcclxuICAgICAgICBjb25zdCBtaWRsaW5lWSA9IG91dC5zY2FsZWJhclNlZ21lbnRIZWlnaHRfIC8gMiArIDFcclxuICAgICAgICBpZiAoZGl2aXNpb25XaWR0aCA+PSBkaXZpc2lvbk1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3ViZGl2aXNpb25OYjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfKVxyXG4gICAgICAgICAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW5MZWZ0ICsgdGV4dE9mZnNldFggKyBpICogZGl2aXNpb25XaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfICsgdGV4dE9mZnNldFkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZ2V0U2NhbGViYXJMYWJlbCgobmljZUxlbmd0aE1bMF0gLyBzdWJkaXZpc2lvbk5iKSAqIGkpKVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZSBlbS1zY2FsZWJhci1taWRsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgbWFyZ2luTGVmdCArIG91dC5zY2FsZWJhclN0cm9rZVdpZHRoXyAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIG1pZGxpbmVZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBtaWRsaW5lWSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHgxID0gbWFyZ2luTGVmdCArIG91dC5zY2FsZWJhclN0cm9rZVdpZHRoXyAvIDIgKyAoaSAtIDEpICogZGl2aXNpb25XaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4MSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZSBlbS1zY2FsZWJhci1taWRsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGZpbmFsIG1pZGxpbmUgc2VnbWVudCAobGFzdCBzZWdtZW50KVxyXG4gICAgICAgICAgICBpZiAoZGl2aXNpb25XaWR0aCA+PSBkaXZpc2lvbk1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUgZW0tc2NhbGViYXItbWlkbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgbWFyZ2luTGVmdCArIChzdWJkaXZpc2lvbk5iIC0gMSkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIG1pZGxpbmVZKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQgKyBzdWJkaXZpc2lvbk5iICogZGl2aXNpb25XaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBtaWRsaW5lWSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSBmdWxsLWxlbmd0aCBob3Jpem9udGFsIG1pZC1saW5lXHJcbiAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUgZW0tc2NhbGViYXItbWlkbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC0gMSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIG1pZGxpbmVZKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgbWFyZ2luTGVmdCArIG91dC5zY2FsZWJhclN0cm9rZVdpZHRoXyAvIDIgKyBkaXZpc2lvbldpZHRoICogc3ViZGl2aXNpb25OYilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG1pZGxpbmVZKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sYXN0IHRpY2tcclxuICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfKVxyXG4gICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbmljZUxlbmd0aFBpeGVsICsgbWFyZ2luTGVmdCArIHRleHRPZmZzZXRYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfICsgdGV4dE9mZnNldFkpXHJcbiAgICAgICAgICAgIC50ZXh0KGdldFNjYWxlYmFyTGFiZWwobmljZUxlbmd0aE1bMF0pICsgb3V0LnNjYWxlYmFyVW5pdHNfKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5pY2VTY2FsZUJhckxlbmd0aCA9IGZ1bmN0aW9uIChzY2FsZUJhckxlbmd0aCkge1xyXG4gICAgICAgIC8vY29tcHV0ZSB0aGUgJ25pY2UnIHBvd2VyIG9mIHRlblxyXG4gICAgICAgIGNvbnN0IHBvdzEwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc2NhbGVCYXJMZW5ndGgpIC8gTWF0aC5sb2coMTApKSlcclxuXHJcbiAgICAgICAgLy9jaGVjayBpZiA1IHRpbWVzIHRoaXMgdmFsdWUgZml0c1xyXG4gICAgICAgIGlmICg1ICogcG93MTAgPD0gc2NhbGVCYXJMZW5ndGgpIHJldHVybiBbNSAqIHBvdzEwLCA1XVxyXG5cclxuICAgICAgICAvL2NoZWNrIGlmIDIgdGltZXMgdGhpcyB2YWx1ZSBmaXRzXHJcbiAgICAgICAgaWYgKDIgKiBwb3cxMCA8PSBzY2FsZUJhckxlbmd0aCkgcmV0dXJuIFsyICogcG93MTAsIDJdXHJcblxyXG4gICAgICAgIC8vcmV0dXJucyB0aGUgcG93ZXIgb2YgdGVuXHJcbiAgICAgICAgcmV0dXJuIFtwb3cxMCwgMV1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZXRTY2FsZWJhckxhYmVsID0gZnVuY3Rpb24gKHZhbHVlTSkge1xyXG4gICAgICAgIGlmICh2YWx1ZU0gPCAwLjAxKSByZXR1cm4gdmFsdWVNICogMTAwMCArICdtbSdcclxuICAgICAgICBpZiAodmFsdWVNIDwgMSkgcmV0dXJuIHZhbHVlTSAqIDEwMCArICdjbSdcclxuICAgICAgICBpZiAodmFsdWVNIDwgMTAwMCkgcmV0dXJuIHZhbHVlTSAqIDEgKyAnbSdcclxuICAgICAgICByZXR1cm4gdmFsdWVNIC8gMTAwMFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqIERlZmF1bHQgZ2VvY2VudGVyIHBvc2l0aW9ucyBhbmQgcGl4ZWxTaXplIChmb3IgZGVmYXVsdCB3aWR0aCA9IDgwMHB4KSBmb3IgdGVycml0b3JpZXMgYW5kIHByb2plY3Rpb25zLiAqL1xyXG5jb25zdCBfZGVmYXVsdFBvc2l0aW9uID0ge1xyXG4gICAgRVVSXzMwMzU6IHsgZ2VvQ2VudGVyOiBbNDc5MDAwMCwgMzQyMDAwMF0sIHBpeGVsU2l6ZTogNjQwMCB9LFxyXG4gICAgSUNfMzI2Mjg6IHsgZ2VvQ2VudGVyOiBbNDQzNDY4LCAzMTQ1NjQ3XSwgcGl4ZWxTaXplOiAxMDAwIH0sXHJcbiAgICBHUF8zMjYyMDogeyBnZW9DZW50ZXI6IFs2Njk0OTgsIDE3ODQ1NTJdLCBwaXhlbFNpemU6IDEzMCB9LFxyXG4gICAgTVFfMzI2MjA6IHsgZ2VvQ2VudGVyOiBbNzE2NTIxLCAxNjIxMzIyXSwgcGl4ZWxTaXplOiAxMzAgfSxcclxuICAgIEdGXzMyNjIyOiB7IGdlb0NlbnRlcjogWzI2Njg1MiwgNDQ0MDc0XSwgcGl4ZWxTaXplOiA1MDAgfSxcclxuICAgIFJFXzMyNzQwOiB7IGdlb0NlbnRlcjogWzM0ODAxMSwgNzY2MTYyN10sIHBpeGVsU2l6ZTogMTMwIH0sXHJcbiAgICBZVF8zMjczODogeyBnZW9DZW50ZXI6IFs1MTY1NDksIDg1ODM5MjBdLCBwaXhlbFNpemU6IDcwIH0sXHJcbiAgICBNVF8zMDM1OiB7IGdlb0NlbnRlcjogWzQ3MTk3NTUsIDE0NDE3MDFdLCBwaXhlbFNpemU6IDcwIH0sXHJcbiAgICBQVDIwXzMyNjI2OiB7IGdlb0NlbnRlcjogWzM5NzQxOCwgNDI3MTQ3MV0sIHBpeGVsU2l6ZTogMTUwMCB9LFxyXG4gICAgUFQzMF8zMjYyODogeyBnZW9DZW50ZXI6IFszMzM1ODYsIDM2MjI3MDZdLCBwaXhlbFNpemU6IDE1MCB9LFxyXG4gICAgTElfMzAzNTogeyBnZW9DZW50ZXI6IFs0Mjg3MDYwLCAyNjcyMDAwXSwgcGl4ZWxTaXplOiA0MCB9LFxyXG4gICAgSVNfMzAzNTogeyBnZW9DZW50ZXI6IFszMDExODA0LCA0OTYwMDAwXSwgcGl4ZWxTaXplOiA3MDAgfSxcclxuICAgIFNKX1NWXzMwMzU6IHsgZ2VvQ2VudGVyOiBbNDU3MDAwMCwgNjE2MDE1Nl0sIHBpeGVsU2l6ZTogODAwIH0sXHJcbiAgICBTSl9KTV8zMDM1OiB7IGdlb0NlbnRlcjogWzM2NDc3NjIsIDU0MDgzMDBdLCBwaXhlbFNpemU6IDEwMCB9LFxyXG4gICAgQ0FSSUJfMzI2MjA6IHsgZ2VvQ2VudGVyOiBbNjM2MzQ1LCAxNjY5NDM5XSwgcGl4ZWxTaXplOiA1MDAgfSxcclxuICAgIFdPUkxEXzU0MDMwOiB7IGdlb0NlbnRlcjogWzE0LCAxN10sIHBpeGVsU2l6ZTogOTAwMCB9LFxyXG59XHJcbiIsImltcG9ydCB7IGdldFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4vdXRpbHMnXHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdHRlcm5GaWxsKG1hcCwgY29uZmlncyA9IFtdKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlncykpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ3BhdHRlcm5GaWxsIGV4cGVjdHMgYW4gYXJyYXkgb2YgY29uZmlncycpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRlZnMgPSBtYXAuc3ZnKCkuc2VsZWN0KCdkZWZzJylcclxuICAgIGlmIChkZWZzLmVtcHR5KCkpIHtcclxuICAgICAgICBkZWZzID0gbWFwLnN2ZygpLmFwcGVuZCgnZGVmcycpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlcGFyZTogbWFwIGVhY2ggcmVnaW9uSWQgdG8gYW4gYXJyYXkgb2YgcGF0dGVybklkc1xyXG4gICAgY29uc3QgcmVnaW9uVG9QYXR0ZXJuSWRzID0ge31cclxuXHJcbiAgICBjb25maWdzLmZvckVhY2goKGNvbmZpZykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgcGF0dGVybiA9ICdoYXRjaGluZycsIHJlZ2lvbklkcyA9IFtdLCBjb2xvciA9ICcjMDAwJywgc3Ryb2tlV2lkdGggPSAxLCBjdXN0b21QYXR0ZXJuIH0gPSBjb25maWdcclxuXHJcbiAgICAgICAgbGV0IHBhdHRlcm5JZFxyXG5cclxuICAgICAgICBpZiAoY3VzdG9tUGF0dGVybikge1xyXG4gICAgICAgICAgICBjb25zdCBpZE1hdGNoID0gY3VzdG9tUGF0dGVybi5tYXRjaCgvaWQ9WydcIl0oW14nXCJdKylbJ1wiXS8pXHJcbiAgICAgICAgICAgIGlmIChpZE1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuSWQgPSBpZE1hdGNoWzFdXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5zdmcoKS5zZWxlY3QoYCMke3BhdHRlcm5JZH1gKS5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5ub2RlKCkuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBjdXN0b21QYXR0ZXJuKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjdXN0b21QYXR0ZXJuIG11c3QgaW5jbHVkZSBhbiBpZCBhdHRyaWJ1dGUuJylcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JLZXkgPSBjb2xvci5yZXBsYWNlKCcjJywgJycpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgcGF0dGVybklkID0gYCR7cGF0dGVybn0tJHtjb2xvcktleX0tc3cke3N0cm9rZVdpZHRofWBcclxuICAgICAgICAgICAgZGVmaW5lUGF0dGVybihtYXAsIHBhdHRlcm5JZCwgcGF0dGVybiwgY29sb3IsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnLnBhdHRlcm5JZCA9IHBhdHRlcm5JZFxyXG5cclxuICAgICAgICByZWdpb25JZHMuZm9yRWFjaCgocmVnaW9uSWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFyZWdpb25Ub1BhdHRlcm5JZHNbcmVnaW9uSWRdKSB7XHJcbiAgICAgICAgICAgICAgICByZWdpb25Ub1BhdHRlcm5JZHNbcmVnaW9uSWRdID0gW11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWdpb25Ub1BhdHRlcm5JZHNbcmVnaW9uSWRdLnB1c2gocGF0dGVybklkKVxyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIEFwcGx5IGFsbCBwYXR0ZXJucyBmb3IgZWFjaCByZWdpb24gKHN0YWNraW5nIHRoZW0pXHJcbiAgICBtYXAuc3ZnKClcclxuICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZD8ucHJvcGVydGllcz8uaWRcclxuICAgICAgICAgICAgY29uc3QgcGF0dGVybklkcyA9IHJlZ2lvblRvUGF0dGVybklkc1tpZF1cclxuXHJcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuSWRzICYmIHBhdHRlcm5JZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHNlbGVjdCh0aGlzKVxyXG5cclxuICAgICAgICAgICAgICAgIHBhdHRlcm5JZHMuZm9yRWFjaCgocGF0dGVybklkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBvcmlnaW5hbC5ub2RlKCkuY2xvbmVOb2RlKHRydWUpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdChjbG9uZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBgdXJsKCMke3BhdHRlcm5JZH0pYClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAob3JpZ2luYWwuYXR0cignY2xhc3MnKSB8fCAnJykgKyAnIHBhdHRlcm4tZmlsbC1vdmVybGF5JylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuYXBwZW5kKCgpID0+IGNsb25lKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZVBhdHRlcm4obWFwLCBwYXR0ZXJuSWQsIHBhdHRlcm5OYW1lLCBjb2xvciwgc3Ryb2tlV2lkdGgpIHtcclxuICAgIGNvbnN0IGRlZnMgPSBtYXAuc3ZnKCkuc2VsZWN0KCdkZWZzJylcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICAgbWFwXHJcbiAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0KGAjJHtDU1MuZXNjYXBlKHBhdHRlcm5JZCl9YClcclxuICAgICAgICAgICAgLmVtcHR5KClcclxuICAgICkge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBkZWZzLmFwcGVuZCgncGF0dGVybicpLmF0dHIoJ2lkJywgcGF0dGVybklkKS5hdHRyKCdwYXR0ZXJuVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKS5hdHRyKCd3aWR0aCcsIDgpLmF0dHIoJ2hlaWdodCcsIDgpXHJcblxyXG4gICAgICAgIGlmIChwYXR0ZXJuTmFtZSA9PT0gJ2hhdGNoaW5nJykge1xyXG4gICAgICAgICAgICBwYXR0ZXJuLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCAnTS0xLDEgbDIsLTIgTTAsOCBsOCwtOCBNNyw5IGwyLC0yJykuYXR0cignc3Ryb2tlJywgY29sb3IpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgIH0gZWxzZSBpZiAocGF0dGVybk5hbWUgPT09ICdjcm9zc2hhdGNoJykge1xyXG4gICAgICAgICAgICBwYXR0ZXJuLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCAnTTAsMCBsOCw4IE04LDAgbC04LDgnKS5hdHRyKCdzdHJva2UnLCBjb2xvcikuYXR0cignc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuTmFtZSA9PT0gJ2RvdHMnKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4uYXBwZW5kKCdjaXJjbGUnKS5hdHRyKCdjeCcsIDQpLmF0dHIoJ2N5JywgNCkuYXR0cigncicsIHN0cm9rZVdpZHRoKS5hdHRyKCdmaWxsJywgY29sb3IpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIHBhdHRlcm4gXCIke3BhdHRlcm5OYW1lfVwiLCBkZWZhdWx0aW5nIHRvIGhhdGNoaW5nLmApXHJcbiAgICAgICAgICAgIHBhdHRlcm4uYXBwZW5kKCdwYXRoJykuYXR0cignZCcsICdNLTEsMSBsMiwtMiBNMCw4IGw4LC04IE03LDkgbDIsLTInKS5hdHRyKCdzdHJva2UnLCBjb2xvcikuYXR0cignc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImV4cG9ydCBjb25zdCBhcHBlbmRTdGFtcCA9IChzdGFtcENvbmZpZywgbWFwKSA9PiB7XHJcbiAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICBjb25zdCBleGlzdGluZyA9IG1hcC5zdmdfLnNlbGVjdCgnI2VtLXN0YW1wJylcclxuICAgICAgICBleGlzdGluZy5yZW1vdmUoKVxyXG5cclxuICAgICAgICBpZiAoc3RhbXBDb25maWcpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gbWFwLnN2Z18uYXBwZW5kKCdnJykuYXR0cignaWQnLCAnZW0tc3RhbXAnKVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcuc2l6ZSkgc3RhbXBDb25maWcuc2l6ZSA9IDYwXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcueCkgc3RhbXBDb25maWcueCA9IDIzMFxyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLnkpIHN0YW1wQ29uZmlnLnkgPSAxMDBcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy50ZXh0Q29sb3IpIHN0YW1wQ29uZmlnLnRleHRDb2xvciA9ICcjMDAwJ1xyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLnN0YW1wQ29sb3IpIHN0YW1wQ29uZmlnLnN0YW1wQ29sb3IgPSAnIzAwMCdcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy5zdHJva2VXaWR0aCkgc3RhbXBDb25maWcuc3Ryb2tlV2lkdGggPSAxXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcubGluZUhlaWdodCkgc3RhbXBDb25maWcubGluZUhlaWdodCA9IDE1XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBjaXJjbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBzdGFtcENvbmZpZy5zaXplKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4Jywgc3RhbXBDb25maWcueClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHN0YW1wQ29uZmlnLnkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tc3RhbXAtY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0YW1wQ29uZmlnLnN0YW1wQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgc3RhbXBDb25maWcuc3Ryb2tlV2lkdGgpXHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgdGV4dFxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gc3RhbXBDb25maWcudGV4dFxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IE1hdGguc3FydChtZWFzdXJlV2lkdGgodGV4dC50cmltKCkpICogc3RhbXBDb25maWcubGluZUhlaWdodClcclxuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBnZXRMaW5lcyhnZXRXb3Jkcyh0ZXh0LnRyaW0oKSksIHRhcmdldFdpZHRoKVxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0UmFkaXVzID0gZ2V0VGV4dFJhZGl1cyhsaW5lcywgc3RhbXBDb25maWcubGluZUhlaWdodClcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBpbnNpZGUgY2lyY2xlXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgc3RhbXBDb25maWcudGV4dENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXN0YW1wLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtzdGFtcENvbmZpZy54fSwke3N0YW1wQ29uZmlnLnl9KSBzY2FsZSgke3N0YW1wQ29uZmlnLnNpemUgLyB0ZXh0UmFkaXVzfSlgKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndHNwYW4nKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEobGluZXMpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndHNwYW4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4gKGkgLSBsaW5lcy5sZW5ndGggLyAyICsgMC44KSAqIHN0YW1wQ29uZmlnLmxpbmVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoZCkgPT4gZC50ZXh0LnJlcGxhY2VBbGwoJ34nLCAnICcpLnJlcGxhY2VBbGwoJ8K2JywgJycpKSAvLyBSZW1vdmVzIMK2IChsaW5lIGJyZWFrZXIpIGFuZCB+IChub24gYnJlYWtpbmcgc3BhY2UpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vLyBTcGxpdHRpbmcgYnkgYm90aCBzcGFjZXMgYW5kIHBpbGNyb3dzXHJcbmNvbnN0IGdldFdvcmRzID0gKHRleHQpID0+IHtcclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgICAgLnNwbGl0KC8oPzw9wrYpfFxccysvZylcclxuICAgICAgICAubWFwKCh3b3JkKSA9PiB3b3JkLnRyaW0oKSlcclxuICAgICAgICAuZmlsdGVyKCh3b3JkKSA9PiB3b3JkLmxlbmd0aCA+IDApXHJcbn1cclxuXHJcbi8vIENvbXB1dGVzIHRleHQgd2lkdGhcclxuY29uc3QgbWVhc3VyZVdpZHRoID0gKHRleHQpID0+IHtcclxuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJylcclxuICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICd0ZXh0JylcclxuXHJcbiAgICB0ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IHRleHRcclxuICAgIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0RWxlbWVudClcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKVxyXG5cclxuICAgIGNvbnN0IHdpZHRoID0gdGV4dEVsZW1lbnQuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKClcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnKVxyXG5cclxuICAgIHJldHVybiB3aWR0aCArIDEwXHJcbn1cclxuXHJcbi8vIENvbXB1dGUgdGV4dCByYWRpdXNcclxuY29uc3QgZ2V0VGV4dFJhZGl1cyA9IChsaW5lcywgbGluZUhlaWdodCkgPT4ge1xyXG4gICAgbGV0IHJhZGl1cyA9IDBcclxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgZHkgPSAoTWF0aC5hYnMoaSAtIG4gLyAyICsgMC41KSArIDAuNSkgKiBsaW5lSGVpZ2h0XHJcbiAgICAgICAgY29uc3QgZHggPSBsaW5lc1tpXS53aWR0aCAvIDJcclxuICAgICAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIE1hdGguc3FydChkeCAqKiAyICsgZHkgKiogMikpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmFkaXVzXHJcbn1cclxuXHJcbi8vIEhhbmRsZXMgZm9yY2VkIGxpbmUgYnJlYWtzXHJcbmNvbnN0IGdldExpbmVzID0gKHdvcmRzLCB0YXJnZXRXaWR0aCkgPT4ge1xyXG4gICAgbGV0IGxpbmVzID0gW11cclxuICAgIGxldCBsaW5lID0geyB3aWR0aDogMCwgdGV4dDogJycgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gd29yZHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKHdvcmRzW2ldID09PSAnwrYnKSB7XHJcbiAgICAgICAgICAgIC8vIFB1c2ggY3VycmVudCBsaW5lIChpZiBpdCBoYXMgdGV4dClcclxuICAgICAgICAgICAgaWYgKGxpbmUudGV4dCkgbGluZXMucHVzaChsaW5lKVxyXG4gICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBlbXB0eSBsaW5lXHJcbiAgICAgICAgICAgIGxpbmUgPSB7IHdpZHRoOiAwLCB0ZXh0OiAnJyB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGluZVRleHQxID0gKGxpbmUudGV4dCA/IGxpbmUudGV4dCArICcgJyA6ICcnKSArIHdvcmRzW2ldXHJcbiAgICAgICAgbGV0IGxpbmVXaWR0aDEgPSBtZWFzdXJlV2lkdGgobGluZVRleHQxKVxyXG5cclxuICAgICAgICBpZiAoKGxpbmUud2lkdGggKyBsaW5lV2lkdGgxKSAvIDIgPCB0YXJnZXRXaWR0aCkge1xyXG4gICAgICAgICAgICBsaW5lLndpZHRoID0gbGluZVdpZHRoMVxyXG4gICAgICAgICAgICBsaW5lLnRleHQgPSBsaW5lVGV4dDFcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpXHJcbiAgICAgICAgICAgIGxpbmUgPSB7IHdpZHRoOiBtZWFzdXJlV2lkdGgod29yZHNbaV0pLCB0ZXh0OiB3b3Jkc1tpXSB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChsaW5lLnRleHQpIGxpbmVzLnB1c2gobGluZSkgLy8gUHVzaCBsYXN0IGxpbmUgaWYgaXQgZXhpc3RzXHJcblxyXG4gICAgcmV0dXJuIGxpbmVzXHJcbn1cclxuIiwiaW1wb3J0IHsganNvbiwgY3N2IH0gZnJvbSAnZDMtZmV0Y2gnXHJcbmltcG9ydCB7IGdldEVzdGF0RGF0YVVSTCB9IGZyb20gJy4vdXRpbHMnXHJcbmltcG9ydCBKU09Oc3RhdCBmcm9tICdqc29uc3RhdC10b29sa2l0J1xyXG5pbXBvcnQgeyBjc3ZUb0luZGV4LCBqc29uc3RhdFRvSW5kZXggfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIEEgc3RhdGlzdGljYWwgZGF0YXNldCwgdG8gYmUgdXNlZCBmb3IgYSBzdGF0aXN0aWNhbCBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdERhdGEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIHN0YXQgZGF0YSBvYmplY3RcclxuICAgIGNvbnN0IG91dCA9IHt9XHJcblxyXG4gICAgb3V0Ll9fZGF0YSA9IHVuZGVmaW5lZCAvL2ZvciBkZWJ1Z2dpbmdcclxuXHJcbiAgICAvL291dC5tYXhOdW1iZXJPZkRlY2ltYWxzSW5EYXRhc2V0ID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RhdGlzdGljYWwgdmFsdWVzLCBpbmRleGVkIGJ5IE5VVFMgaWQuXHJcbiAgICAgKiBFYWNoIHN0YXQgdmFsdWUgaXMgYW4gb2JqZWN0IHt2YWx1ZSxzdGF0dXN9LlxyXG4gICAgICovXHJcbiAgICBvdXQuX2RhdGFfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHN0YXQgdmFsdWUge3ZhbHVlLHN0YXR1c30gZnJvbSBhIG51dHMgaWQuXHJcbiAgICAgKiBJZiBubyBhcmd1bWVudCBpcyBzcGVjaWZpZWQsIHJldHVybnMgdGhlIGVudGlyZSBpbmRleC5cclxuICAgICAqIEBwYXJhbSB7Kn0gbnV0c0lkXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXQgPSAobnV0c0lkKSA9PiB7XHJcbiAgICAgICAgaWYgKCFudXRzSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5fZGF0YV9cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3V0Ll9kYXRhXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5fZGF0YV9bbnV0c0lkXVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzdGF0IHZhbHVlIGZyb20gYSBudXRzIGlkLlxyXG4gICAgICogQHBhcmFtIHsqfSBudXRzSWRcclxuICAgICAqL1xyXG4gICAgb3V0LmdldFZhbHVlID0gKG51dHNJZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHMgPSBvdXQuZ2V0KG51dHNJZClcclxuICAgICAgICByZXR1cm4gcyA/IHMudmFsdWUgOiB1bmRlZmluZWRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHN0YXQgdmFsdWUgZnJvbSBhIG51dHMgaWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG51dHNJZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3QgfHwgU3RyaW5nIHx8IE51bWJlcn0gc3RhdCBUaGUgbmV3IHN0YXRpc3RpY2FsIGRhdGEuIFRoZSBmb3JtYXQgY2FuIGJlIGVpdGhlciB7dmFsdWU6MzQuMzI0LHN0YXR1czpcImVcIn0gb3IgYSB0aGUgdmFsdWUgb25seS5cclxuICAgICAqL1xyXG4gICAgb3V0LnNldCA9IChudXRzSWQsIHN0YXQpID0+IHtcclxuICAgICAgICBvdXQuX2RhdGFfID0gb3V0Ll9kYXRhXyB8fCB7fVxyXG4gICAgICAgIGNvbnN0IHMgPSBvdXQuX2RhdGFfW251dHNJZF1cclxuXHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHMudmFsdWUgPSBzdGF0LnZhbHVlXHJcbiAgICAgICAgICAgICAgICBzLnN0YXR1cyA9IHN0YXQuc3RhdHVzXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBiZSBjYXJlZnVsIGhlcmUgc2V0dGluZyB2YWx1ZXMgaGVyZSwgd2UgbmVlZCB0byBtYWludGFpbiBzdHJpbmdzIHdpdGggdHJhaWxpbmcgemVyb3MgYmVjYXVzZSBpbiBKU09OIDEuMCA9PT0gMSBhbmQgdGhleSBhcmUgcmVtb3ZlZC4gVXNlciBtaWdodCB3YW50IHN0YXRzIGxhYmVscyB3aXRoIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgcy52YWx1ZSA9IHN0YXRcclxuICAgICAgICAgICAgICAgIC8vcy52YWx1ZSA9IGlzTmFOKCtzdGF0KSA/IHN0YXQgOiArc3RhdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYmUgY2FyZWZ1bCBoZXJlIHNldHRpbmcgdmFsdWVzIGhlcmUsIHdlIG5lZWQgdG8gbWFpbnRhaW4gc3RyaW5ncyB3aXRoIHRyYWlsaW5nIHplcm9zIGJlY2F1c2UgaW4gSlNPTiAxLjAgPT09IDEgYW5kIHRoZXkgYXJlIHJlbW92ZWQuIFVzZXIgbWlnaHQgd2FudCBzdGF0cyBsYWJlbHMgd2l0aCB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgb3V0Ll9kYXRhX1tudXRzSWRdID0gc3RhdC52YWx1ZSA/IHN0YXQgOiB7IHZhbHVlOiBzdGF0IH1cclxuICAgICAgICAgICAgLy9vdXQuX2RhdGFfW251dHNJZF0gPSBzdGF0LnZhbHVlID8gc3RhdCA6IHsgdmFsdWU6IGlzTmFOKCtzdGF0KSA/IHN0YXQgOiArc3RhdH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHN0YXRpc3RpY2FsIGRhdGEsIGFscmVhZHkgaW5kZXhlZCBieSBudXRzSWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgU29tZXRoaW5nIGxpa2U6IHsgXCJQVFwiOjAuMiwgXCJMVVwiOjAuNiwgLi4ufSwgb3Igd2l0aCBzdGF0dXM6IHsgXCJQVFwiOiB7dmFsdWU6MC4yLCBzdGF0dXM6XCJlXCJ9LCBcIkxVXCI6MC42LCAuLi59XHJcbiAgICAgKi9cclxuICAgIG91dC5zZXREYXRhID0gKGRhdGEpID0+IHtcclxuICAgICAgICBvdXQuX19kYXRhID0gZGF0YSAvLyBmb3IgZGVidWdnaW5nXHJcbiAgICAgICAgb3V0Ll9kYXRhXyA9IHt9IC8vIG92ZXJ3cml0ZSBleGlzdGluZyBkYXRhXHJcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgobnV0c0lkKSA9PiBvdXQuc2V0KG51dHNJZCwgZGF0YVtudXRzSWRdKSlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9lZyBmb3Igc3BhcmtsaW5lc1xyXG4gICAgb3V0LnNldE1hbnVhbE11bHRpRGF0ZSA9IGZ1bmN0aW9uIChkYXRhT2JqZWN0KSB7XHJcbiAgICAgICAgb3V0Ll9kYXRhXyA9IG91dC5fZGF0YV8gfHwge31cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCByZWdpb25JZCBpbiBkYXRhT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZU1hcCA9IGRhdGFPYmplY3RbcmVnaW9uSWRdXHJcbiAgICAgICAgICAgIG91dC5fZGF0YV9bcmVnaW9uSWRdID0ge31cclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGF0ZSBpbiBkYXRlVmFsdWVNYXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0ZVZhbHVlTWFwW2RhdGVdXHJcbiAgICAgICAgICAgICAgICBvdXQuX2RhdGFfW3JlZ2lvbklkXVtkYXRlXSA9IHsgdmFsdWU6IHZhbHVlIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm4gYWxsIHN0YXQgdmFsdWVzIGFzIGFuIGFycmF5LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNsYXNzaWZ5IHRoZSB2YWx1ZXMuICovXHJcbiAgICBvdXQuZ2V0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG91dC5fZGF0YV8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0Ll9kYXRhXylcclxuICAgICAgICAgICAgICAgIC5tYXAoKHMpID0+IHMudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzID09IDAgfHwgcylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybiBzdGF0IHVuaXF1ZSB2YWx1ZXMuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGNhdGVnb3JpY2FsIG1hcHMuICovXHJcbiAgICBvdXQuZ2V0VW5pcXVlVmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dC5fZGF0YV8pXHJcbiAgICAgICAgICAgIC5tYXAoKHMpID0+IHMudmFsdWUpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0sIGksIGFyKSA9PiBhci5pbmRleE9mKGl0ZW0pID09PSBpKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgbWluIHZhbHVlLiAqL1xyXG4gICAgb3V0LmdldE1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3V0Ll9kYXRhXykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhvdXQuX2RhdGFfKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IHMgPT0gMCB8fCAocyAmJiBzICE9PSAnOicpKVxyXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2KSA9PiBNYXRoLm1pbihhY2MsIHYpKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBHZXQgbWF4IHZhbHVlLiAqL1xyXG4gICAgb3V0LmdldE1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3V0Ll9kYXRhXykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhvdXQuX2RhdGFfKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IHMgPT0gMCB8fCAocyAmJiBzICE9PSAnOicpKVxyXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2KSA9PiBNYXRoLm1heChhY2MsIHYpKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hlY2sgaWYgdGhlIHN0YXQgZGF0YSBpcyByZWFkeS4gKi9cclxuICAgIG91dC5pc1JlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBvdXQuX2RhdGFfICE9IHVuZGVmaW5lZFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTb21lIG1ldGFkYXRhICovXHJcbiAgICBvdXQubWV0YWRhdGEgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL2EgdGV4dCBmb3IgdGhlIHN0YXRpdGljcyB1bml0IG9mIG1lYXN1cmUsIHRvIGJlIHNob3duIGluIHRoZSB0b29sdGlwXHJcbiAgICBvdXQudW5pdFRleHRfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBzdGF0IGRhdGEgZnJvbSByZW1vdGUgZGF0YSBzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gbnV0c0xldmVsXHJcbiAgICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIG91dC5yZXRyaWV2ZUZyb21SZW1vdGUgPSBmdW5jdGlvbiAobnV0c0xldmVsLCBsYW5nLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChvdXQuZXVyb3N0YXREYXRhc2V0Q29kZV8pIHVwZGF0ZUV1cm9iYXNlKG51dHNMZXZlbCwgbGFuZywgY2FsbGJhY2spXHJcbiAgICAgICAgZWxzZSBpZiAob3V0LmNzdlVSTF8pIHVwZGF0ZUNTVihjYWxsYmFjaylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPIGRlY29tcG9zZSBpbnRvIEV1cm9iYXNlL2pzb25zdGF0IGFuZCBDU1YgdHlwZXMgP1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXVyb2Jhc2UvanNvbnN0YXQgZGF0YSBzb3VyY2VcclxuICAgICAqIFNlZSBodHRwczovL2VjLmV1cm9wYS5ldS9ldXJvc3RhdC93ZWIvanNvbi1hbmQtdW5pY29kZS13ZWItc2VydmljZXMvZ2V0dGluZy1zdGFydGVkL3Jlc3QtcmVxdWVzdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqIFRoZSBFdXJvYmFzZSBkYXRhc2V0IGNvZGUgKi9cclxuICAgIG91dC5ldXJvc3RhdERhdGFzZXRDb2RlXyA9IHVuZGVmaW5lZFxyXG4gICAgLyoqIFRoZSBFdXJvYmFzZSBjb2RlICovXHJcbiAgICBvdXQuZmlsdGVyc18gPSB7IGxhc3RUaW1lUGVyaW9kOiAxIH1cclxuICAgIC8qKiBUaGUgcHJlY2lzaW9uIChudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMpICovXHJcbiAgICBvdXQucHJlY2lzaW9uXyA9IDJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBwcm9taXNlIGZvciBFdXJvYmFzZS9qc29uc3RhdCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRFdXJvYmFzZVByb21pc2UgPSBmdW5jdGlvbiAobnV0c0xldmVsLCBsYW5nKSB7XHJcbiAgICAgICAgLy9zZXQgcHJlY2lzaW9uIC8vREVQUkVDQVRFRCAxNi8xMS8yMDIxIGh0dHBzOi8vZWMuZXVyb3BhLmV1L2V1cm9zdGF0L29ubGluZS1oZWxwL3B1YmxpYy9lbi9OQVZJR0FUSU9OX1dERFNUcmFuc2xhdG9yX21pZ3JhdGlvbl9lbi8jREVDT01NSVNTSU9OXHJcbiAgICAgICAgLy9vdXQuZmlsdGVyc19bXCJwcmVjaXNpb25cIl0gPSBvdXQucHJlY2lzaW9uXztcclxuICAgICAgICAvL3NlbGVjdCBvbmx5IHJlcXVpcmVkIGdlbyBncm91cHMsIGRlcGVuZGluZyBvbiB0aGUgc3BlY2lmaWVkIG51dHMgbGV2ZWxcclxuICAgICAgICBpZiAoIW91dC5maWx0ZXJzXy5nZW8pIHtcclxuICAgICAgICAgICAgb3V0LmZpbHRlcnNfWydnZW9MZXZlbCddID0gbnV0c0xldmVsICsgJycgPT09ICcwJyA/ICdjb3VudHJ5JyA6ICdudXRzJyArIG51dHNMZXZlbFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9mb3JjZSBmaWx0ZXJpbmcgb2YgZXVyby1nZW8tYWdncmVnYXRlc1xyXG4gICAgICAgIC8vb3V0LmZpbHRlcnNfW1wiZmlsdGVyTm9uR2VvXCJdID0gMTsgLy9ERVBSRUNBVEVEIDE2LzExLzIwMjFcclxuXHJcbiAgICAgICAgLy9yZXRyaWV2ZSBzdGF0IGRhdGEgZnJvbSBFdXJvc3RhdCBBUElcclxuICAgICAgICByZXR1cm4ganNvbihnZXRFc3RhdERhdGFVUkwob3V0LmV1cm9zdGF0RGF0YXNldENvZGVfLCBvdXQuZmlsdGVyc18sIGxhbmcpKVxyXG4gICAgfVxyXG5cclxuICAgIC8vZm9yIGV1cm9iYXNlIHN0YXRpc3RpY2FsIGRhdGEgdG8gcmV0cmlldmUgZnJvbSBFdXJvc3RhdCBBUElcclxuICAgIGNvbnN0IHVwZGF0ZUV1cm9iYXNlID0gZnVuY3Rpb24gKG51dHNMZXZlbCwgbGFuZywgY2FsbGJhY2spIHtcclxuICAgICAgICAvL2VyYXNlIHByZXZpb3VzIGRhdGFcclxuICAgICAgICBvdXQuX2RhdGFfID0gbnVsbFxyXG5cclxuICAgICAgICBnZXRFdXJvYmFzZVByb21pc2UobnV0c0xldmVsLCBsYW5nKS50aGVuKGZ1bmN0aW9uIChkYXRhX19fKSB7XHJcbiAgICAgICAgICAgIC8vZGVjb2RlIHN0YXQgZGF0YVxyXG4gICAgICAgICAgICBjb25zdCBqc2QgPSBKU09Oc3RhdChkYXRhX19fKVxyXG5cclxuICAgICAgICAgICAgLy9zdG9yZSBqc29uc3RhdCBtZXRhZGF0YVxyXG4gICAgICAgICAgICBvdXQubWV0YWRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDoganNkLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgaHJlZjoganNkLmhyZWYsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGpzZC5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkOiBqc2QudXBkYXRlZCxcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbjoganNkLmV4dGVuc2lvbixcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQubWV0YWRhdGEudGltZSA9IGpzZC5EaW1lbnNpb24oJ3RpbWUnKS5pZFswXVxyXG5cclxuICAgICAgICAgICAgLy9pbmRleFxyXG4gICAgICAgICAgICBvdXQuX2RhdGFfID0ganNvbnN0YXRUb0luZGV4KGpzZClcclxuICAgICAgICAgICAgLy9UT0RPOiB1c2UgbWF5YmUgaHR0cHM6Ly9naXRodWIuY29tL2JhZG9zYS9KU09OLXN0YXQvYmxvYi9tYXN0ZXIvdXRpbHMvZnJvbXRhYmxlLm1kIHRvIGJ1aWxkIGRpcmVjdGx5IGFuIGluZGV4ID9cclxuXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHRpbWUgc3RhbXAgb2YgdGhlIGpzb25zdGF0IGRhdGFzZXQuXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHQgPSBvdXQuZmlsdGVyc18udGltZVxyXG4gICAgICAgIGlmICh0KSByZXR1cm4gdFxyXG4gICAgICAgIGlmICghb3V0Ll9kYXRhXykgcmV0dXJuXHJcbiAgICAgICAgcmV0dXJuIG91dC5tZXRhZGF0YS50aW1lXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDU1YgZGF0YSBzb3VyY2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKiBUaGUgQ1NWIGZpbGUgVVJMICovXHJcbiAgICBvdXQuY3N2VVJMXyA9IHVuZGVmaW5lZFxyXG4gICAgLyoqIFRoZSBDU1YgY29sdW1uIHdpdGggdGhlIE5VVFMgaWRzICovXHJcbiAgICBvdXQuZ2VvQ29sXyA9ICdnZW8nXHJcbiAgICAvKiogVGhlIENTViBjb2x1bW4gd2l0aCB0aGUgc3RhdGlzdGljYWwgdmFsdWVzICovXHJcbiAgICBvdXQudmFsdWVDb2xfID0gJ3ZhbHVlJ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHByb21pc2UgZm9yIENTViBkYXRhLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRDU1ZQcm9taXNlID0gZnVuY3Rpb24gKG51dHNMZXZlbCkge1xyXG4gICAgICAgIHJldHVybiBjc3Yob3V0LmNzdlVSTF8pXHJcbiAgICB9XHJcblxyXG4gICAgLy9mb3Igc3RhdGlzdGljYWwgZGF0YSB0byByZXRyaWV2ZSBmcm9tIENTViBmaWxlXHJcbiAgICBjb25zdCB1cGRhdGVDU1YgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAvL2VyYXNlIHByZXZpb3VzIGRhdGFcclxuICAgICAgICBvdXQuX2RhdGFfID0gbnVsbFxyXG5cclxuICAgICAgICAvL3JldHJpZXZlIGNzdiBkYXRhXHJcbiAgICAgICAgZ2V0Q1NWUHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24gKGRhdGFfX18pIHtcclxuICAgICAgICAgICAgLy9kZWNvZGUgc3RhdCBkYXRhXHJcbiAgICAgICAgICAgIG91dC5fZGF0YV8gPSBjc3ZUb0luZGV4KGRhdGFfX18sIG91dC5nZW9Db2xfLCBvdXQudmFsdWVDb2xfKVxyXG5cclxuICAgICAgICAgICAgLy9zdG9yZSBzb21lIG1ldGFkYXRhXHJcbiAgICAgICAgICAgIG91dC5tZXRhZGF0YSA9IHsgaHJlZjogb3V0LmNzdlVSTF8gfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7Wyd1bml0VGV4dF8nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIG91dFtrZXkgKyAnXyddID0gY29uZmlnW2tleV1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgYXBwbHlJbmxpbmVTdHlsZXNGcm9tQ1NTLCBmbGFncywgc2VyaWFsaXplLCByYXN0ZXJpemUsIGdldERvd25sb2FkVVJMIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0ICogYXMgTWFwVGVtcGxhdGUgZnJvbSAnLi9tYXAtdGVtcGxhdGUnXHJcbmltcG9ydCAqIGFzIFN0YXRpc3RpY2FsRGF0YSBmcm9tICcuL3N0YXQtZGF0YSdcclxuaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQnXHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0ICogYXMgdHAgZnJvbSAnLi4vdG9vbHRpcC90b29sdGlwJ1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IHN0YXRpc3RpY2FsIG1hcDogQSBtYXAgdGVtcGxhdGUgd2l0aCBzdGF0aXN0aWNhbCBkYXRhLCB3aXRob3V0IGFueSBwYXJ0aWN1bGFyIHN0eWxpbmcgcnVsZS5cclxuICpcclxuICogQHBhcmFtIHsqfSB3aXRoQ2VudGVyUG9pbnRzIFNldCB0byB0cnVlIChvciAxKSB0byBhZGQgcmVnaW9ucyBjZW50ZXIgcG9pbnRzIHRvIHRoZSBtYXAgdGVtcGxhdGUsIHRvIGJlIHVzZWQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2xzIG1hcHMgZm9yIGV4YW1wbGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdE1hcCA9IGZ1bmN0aW9uIChjb25maWcsIHdpdGhDZW50ZXJQb2ludHMsIG1hcFR5cGUpIHtcclxuICAgIC8vYnVpbGQgc3RhdCBtYXAgZnJvbSBtYXAgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IE1hcFRlbXBsYXRlLm1hcFRlbXBsYXRlKGNvbmZpZywgd2l0aENlbnRlclBvaW50cywgbWFwVHlwZSlcclxuXHJcbiAgICAvL3N0YXRpc3RpY2FsIGRhdGFcclxuXHJcbiAgICAvL3RoZSBzdGF0aXN0aWNhbCBkYXRhIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAvL0EgbWFwIGNhbiBoYXZlIHNldmVyYWwgc3RhdCBkYXRhc2V0cy4gVGhpcyBpcyBhIGRpY3Rpb25hcnkgb2YgYWxsIHN0YXQgY29uZmlndXJhdGlvblxyXG4gICAgb3V0LnN0YXRfID0geyBkZWZhdWx0OiB1bmRlZmluZWQgfVxyXG4gICAgb3V0LnN0YXQgPSBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIC8vbm8gYXJndW1lbnQ6IGdldHRlciAtIHJldHVybiB0aGUgZGVmYXVsdCBzdGF0XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnN0YXRfWydkZWZhdWx0J11cclxuICAgICAgICAvL3R3byBhcmd1bWVudHM6IHNldHRlciAtIHNldCB0aGUgY29uZmlnIGsgd2l0aCB2YWx1ZSB2XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICBvdXQuc3RhdF9ba10gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9vbmUgc3RyaW5nIGFyZ3VtZW50OiBnZXR0ZXIgLSByZXR1cm4gdGhlIGNvbmZpZyBrXHJcbiAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJyB8fCBrIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gb3V0LnN0YXRfW2tdXHJcbiAgICAgICAgLy9vbmUgbm9uLXN0cmluZyBhcmd1bWVudDogc2V0dGVyIC0gc2V0IHRoZSBlbnRpcmUgZGljdGlvbm5hcnlcclxuICAgICAgICBvdXQuc3RhdF8gPSBrLmRlZmF1bHQgPyBrIDogeyBkZWZhdWx0OiBrIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy90aGUgc3RhdGlzdGljYWwgZGF0YSwgcmV0cmlldmVkIGZyb20gdGhlIGNvbmZpZyBpbmZvcm1hdGlvbi4gQXMgYSBkaWN0aW9uYXJ5LlxyXG4gICAgb3V0LnN0YXREYXRhXyA9IHtcclxuICAgICAgICBkZWZhdWx0OiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSxcclxuICAgICAgICBjb2xvcjogU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKCksXHJcbiAgICAgICAgc2l6ZTogU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKCksXHJcbiAgICAgICAgdjE6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLFxyXG4gICAgICAgIHYyOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSwgLy9iaXZhcmlhdGVcclxuICAgICAgICB2MzogU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKCksIC8vdHJpdmFyaWF0ZVxyXG4gICAgfVxyXG4gICAgb3V0LnN0YXREYXRhID0gZnVuY3Rpb24gKGssIHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuc3RhdERhdGFfWydkZWZhdWx0J11cclxuXHJcbiAgICAgICAgLy8gbGF6eSBjcmVhdGUgaWYgbm90IGV4aXN0XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKCFvdXQuc3RhdERhdGFfW2tdKSBvdXQuc3RhdERhdGFfW2tdID0gU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKClcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5zdGF0RGF0YV9ba11cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldHRlclxyXG4gICAgICAgIG91dC5zdGF0RGF0YV9ba10gPSB2XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vdGVzdCBmb3Igbm8gZGF0YSBjYXNlXHJcbiAgICBvdXQubm9EYXRhVGV4dF8gPSAnTm8gZGF0YSBhdmFpbGFibGUnXHJcbiAgICAvL2xhbmdhZ2UgKGN1cnJlbnRseSB1c2VkIG9ubHkgZm9yIGV1cm9zdGF0IGRhdGEgQVBJKVxyXG4gICAgb3V0Lmxhbmd1YWdlXyA9ICdlbidcclxuICAgIC8vdHJhbnNpdGlvbiB0aW1lIGZvciByZW5kZXJpbmdcclxuICAgIG91dC50cmFuc2l0aW9uRHVyYXRpb25fID0gNTAwXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHVuZGVmaW5lZFxyXG4gICAgLy9mb3IgbWFwcyB1c2luZyBzcGVjaWFsIGZpbGwgcGF0dGVybnMsIHRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRvIGRlZmluZSB0aGVtIGluIHRoZSBTVkcgaW1hZ2UgLSBTZWUgZnVuY3Rpb25zOiBnZXRGaWxsUGF0dGVybkxlZ2VuZCBhbmQgZ2V0RmlsbFBhdHRlcm5EZWZpbml0aW9uRnVuXHJcbiAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8gPSB1bmRlZmluZWRcclxuICAgIC8vYSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBtYXAgYnVpbGQgaXMgY29tcGxldGUuXHJcbiAgICBvdXQuY2FsbGJhY2tfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9sZWdlbmQgY29uZmlndXJhdGlvblxyXG4gICAgb3V0LmxlZ2VuZF8gPSB1bmRlZmluZWRcclxuICAgIC8vbGVnZW5kIG9iamVjdFxyXG4gICAgb3V0LmxlZ2VuZE9ial8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7WydsZWdlbmRfJywgJ2xlZ2VuZE9ial8nLCAnbm9EYXRhVGV4dF8nLCAnbGFuZ3VhZ2VfJywgJ3RyYW5zaXRpb25EdXJhdGlvbl8nLCAndG9vbHRpcFRleHRfJywgJ2ZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fJywgJ2NhbGxiYWNrXyddLmZvckVhY2goXHJcbiAgICAgICAgZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIClcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKSBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBpZiAob3V0W2tleV0gJiYgY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuXHJcbiAgICAvLyBvdmVycmlkZSBsZWdlbmQgZm9yIHVwZGF0aW5nIGFmdGVyIGJ1aWxkXHJcbiAgICBvdXQubGVnZW5kID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQubGVnZW5kX1xyXG5cclxuICAgICAgICAvLyBjbGVhciBleGlzdGluZyBsZWdlbmRcclxuICAgICAgICBpZiAodiA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmQgPSBvdXQubGVnZW5kT2JqKClcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVnZW5kU3ZnID0gc2VsZWN0KCcjJyArIGxlZ2VuZC5zdmdJZClcclxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRTdmcuc2l6ZSgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFN2Zy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dC5sZWdlbmRfID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vc2V0IG5ldyBsZWdlbmQgY29uZmlnXHJcbiAgICAgICAgb3V0LmxlZ2VuZF8gPSB2XHJcbiAgICAgICAgLy91cGRhdGUgaWYgZXhpc3RpbmcgbGVnZW5kXHJcbiAgICAgICAgaWYgKG91dC5sZWdlbmRPYmpfKSBvdXQudXBkYXRlTGVnZW5kKClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LnVwZGF0ZUxlZ2VuZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKG91dC5sZWdlbmRPYmpfKSBvdXQubGVnZW5kT2JqKCkudXBkYXRlKClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCB0aGUgbWFwLlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbmNlLCBwcmVmZXJhYmx5IGFmdGVyIHRoZSBtYXAgYXR0cmlidXRlcyBoYXZlIGJlZW4gc2V0IHRvIHNvbWUgaW5pdGlhbCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIG91dC5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3V0LnByb2plY3Rpb25GdW5jdGlvbl8pIG91dC5wcm9qKCc0MzI2JykgLy93aGVuIHVzaW5nIGN1c3RvbSBkMyBwcm9qZWN0aW9uIGZ1bmN0aW9uIGFsd2F5cyByZXF1ZXN0IE5VVFMySlNPTiBpbiBXR1M4NFxyXG5cclxuICAgICAgICAvL2J1aWxkIG1hcCB0ZW1wbGF0ZSBiYXNlXHJcbiAgICAgICAgb3V0LmJ1aWxkTWFwVGVtcGxhdGVCYXNlKClcclxuXHJcbiAgICAgICAgLy9hZGQgYWRkaXRpb25hbCBmaWx0ZXJzIGZvciBmaWxsIHBhdHRlcm5zIGZvciBleGFtcGxlXHJcbiAgICAgICAgaWYgKG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXykge1xyXG4gICAgICAgICAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8ob3V0LnN2ZygpLCBvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICBpZiAob3V0LmxlZ2VuZCgpKSB7XHJcbiAgICAgICAgICAgIG91dC5idWlsZExlZ2VuZCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RlZmluZSB0b29sdGlwXHJcbiAgICAgICAgLy9wcmVwYXJlIG1hcCB0b29sdGlwXHJcbiAgICAgICAgaWYgKG91dC50b29sdGlwXykge1xyXG4gICAgICAgICAgICBvdXQuX3Rvb2x0aXAgPSB0cC50b29sdGlwKG91dC50b29sdGlwXylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL25vIGNvbmZpZyBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XHJcbiAgICAgICAgICAgIG91dC5fdG9vbHRpcCA9IHRwLnRvb2x0aXAoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sYXVuY2ggZ2VvIGRhdGEgcmV0cmlldmFsXHJcbiAgICAgICAgb3V0LnVwZGF0ZUdlb0RhdGEoKVxyXG5cclxuICAgICAgICAvL2xhdW5jaCBzdGF0IGRhdGEgcmV0cmlldmFsXHJcbiAgICAgICAgb3V0LnVwZGF0ZVN0YXREYXRhKClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIG91dC5idWlsZExlZ2VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2NyZWF0ZSBsZWdlbmQgb2JqZWN0XHJcbiAgICAgICAgb3V0LmxlZ2VuZE9iaihvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IoKShvdXQsIG91dC5sZWdlbmQoKSkpXHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gb3V0LmxlZ2VuZE9iaigpXHJcblxyXG4gICAgICAgIC8vZ2V0IGxlZ2VuZCBzdmcuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBjcmVhdGUgaXQgZW1iZWRlZCB3aXRoaW4gdGhlIG1hcFxyXG4gICAgICAgIGxldCBsZWdlbmRTdmcgPSBzZWxlY3QoJyMnICsgbGVnZW5kLnN2Z0lkKVxyXG4gICAgICAgIGlmIChsZWdlbmRTdmcuc2l6ZSgpID09IDApIHtcclxuICAgICAgICAgICAgLy9nZXQgbGVnZW5kIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBsZWdlbmQueCA9PSB1bmRlZmluZWQgPyBvdXQud2lkdGgoKSAtIDEwMCAtIGxlZ2VuZC5ib3hQYWRkaW5nIDogbGVnZW5kLnhcclxuICAgICAgICAgICAgY29uc3QgeSA9IGxlZ2VuZC55ID09IHVuZGVmaW5lZCA/IGxlZ2VuZC5ib3hQYWRkaW5nIDogbGVnZW5kLnlcclxuXHJcbiAgICAgICAgICAgIC8vYnVpbGQgbGVnZW5kIFNWRyBpbiBhIG5ldyBncm91cFxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgbGVnZW5kLnN2Z0lkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZWdlbmQuYnVpbGQoKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVjayBpZiBhbGwgc3RhdCBkYXRhc2V0cyBoYXZlIGJlZW4gbG9hZGVkLiAqL1xyXG4gICAgY29uc3QgaXNTdGF0RGF0YVJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG91dC5zdGF0RGF0YV8pIHtcclxuICAgICAgICAgICAgY29uc3QgaGFzQ29uZmlnID0gISFvdXQuc3RhdF9ba2V5XVxyXG4gICAgICAgICAgICBjb25zdCBoYXNNYW51YWxEYXRhID0gISEob3V0LnN0YXREYXRhX1trZXldICYmIG91dC5zdGF0RGF0YV9ba2V5XS5nZXQoKSlcclxuXHJcbiAgICAgICAgICAgIGlmICghaGFzQ29uZmlnICYmICFoYXNNYW51YWxEYXRhKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoIW91dC5zdGF0RGF0YV9ba2V5XS5pc1JlYWR5KCkpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGF1bmNoIG1hcCBnZW8gZGF0YSByZXRyaWV2YWwsIGFuZCBtYWtlL3VwZGF0ZSB0aGUgbWFwIG9uY2UgcmVjZWl2ZWQuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGF0dHJpYnV0ZXMgcmVsYXRlZCB0byB0aGUgbWFwIGdlb21ldHJpZXMgaGF2ZSBjaGFuZ2VkLCB0byByZXRyaWV2ZSB0aGlzIG5ldyBkYXRhIGFuZCByZWZyZXNoIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGVHZW9EYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVHZW9NYXBUZW1wbGF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vaWYgc3RhdCBkYXRhc2V0cyBoYXZlIG5vdCBiZWVuIGxvYWRlZCwgd2FpdCBhZ2FpblxyXG4gICAgICAgICAgICBpZiAoIWlzU3RhdERhdGFSZWFkeSgpKSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgIC8vcHJvY2VlZCB3aXRoIG1hcCBjb25zdHJ1Y3Rpb25cclxuICAgICAgICAgICAgb3V0LnVwZGF0ZVN0YXRWYWx1ZXMoKVxyXG4gICAgICAgICAgICAvL2V4ZWN1dGUgY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAgICAgICAgaWYgKG91dC5jYWxsYmFjaygpKSBvdXQuY2FsbGJhY2soKShvdXQpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGF1bmNoIG1hcCBnZW8gc3RhdCBkYXRhc2V0cyByZXRyaWV2YWwsIGFuZCBtYWtlL3VwZGF0ZSB0aGUgbWFwIG9uY2UgcmVjZWl2ZWQuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHNwZWNpZmljYXRpb25zIG9uIHRoZSBzdGF0IGRhdGEgc291cmNlcyBhdHRhY2hlZCB0byB0aGUgbWFwIGhhdmUgY2hhbmdlZCwgdG8gcmV0cmlldmUgdGhpcyBuZXcgZGF0YSBhbmQgcmVmcmVzaCB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlU3RhdERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgc3RhdEtleSBpbiBvdXQuc3RhdF8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gb3V0LnN0YXQoc3RhdEtleSlcclxuICAgICAgICAgICAgY29uc3QgbWFudWFsRGF0YSA9IG91dC5zdGF0RGF0YShzdGF0S2V5KS5nZXQ/LigpXHJcblxyXG4gICAgICAgICAgICAvLyBTa2lwIGlmIG5laXRoZXIgc3RhdCBjb25maWcgbm9yIG1hbnVhbCBkYXRhXHJcbiAgICAgICAgICAgIGlmICghY29uZmlnICYmICFtYW51YWxEYXRhKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbmZpZywgYnVpbGQgdGhlIHN0YXREYXRhIG9iamVjdCAob3IgcmVwbGFjZSBleGlzdGluZylcclxuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdERhdGEgPSBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoY29uZmlnKVxyXG4gICAgICAgICAgICAgICAgb3V0LnN0YXREYXRhKHN0YXRLZXksIHN0YXREYXRhKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExhdW5jaCByZW1vdGUgcmV0cmlldmFsXHJcbiAgICAgICAgICAgICAgICBsZXQgbmwgPSBvdXQubnV0c0xldmVsX1xyXG4gICAgICAgICAgICAgICAgaWYgKG5sID09PSAnbWl4ZWQnKSBubCA9IDBcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0RGF0YS5yZXRyaWV2ZUZyb21SZW1vdGUobmwsIG91dC5sYW5ndWFnZSgpLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXQuR2VvbWV0cmllcy5pc0dlb1JlYWR5KCkpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdGF0RGF0YVJlYWR5KCkpIHJldHVyblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvdXQudXBkYXRlU3RhdFZhbHVlcygpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5jYWxsYmFjaygpKSBvdXQuY2FsbGJhY2soKShvdXQpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlL3VwZGF0ZSB0aGUgbWFwIHdpdGggbmV3IHN0YXQgZGF0YS5cclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc3RhdCBkYXRhIGF0dGFjaGVkIHRvIHRoZSBtYXAgaGF2ZSBjaGFuZ2VkLCB0byByZWZyZXNoIHRoZSBtYXAuXHJcbiAgICAgKiBJZiB0aGUgc3RhdCBkYXRhIHNvdXJjZXMgaGF2ZSBjaGFuZ2VkLCBjYWxsICp1cGRhdGVTdGF0RGF0YSogaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZVN0YXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy91cGRhdGUgY2xhc3NpZmljYXRpb24gYW5kIHN0eWxlc1xyXG4gICAgICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbigpXHJcbiAgICAgICAgb3V0LnVwZGF0ZVN0eWxlKClcclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kLCBpZiBhbnlcclxuICAgICAgICBpZiAob3V0LmxlZ2VuZF8gJiYgb3V0LmxlZ2VuZE9iaigpKSBvdXQubGVnZW5kT2JqKCkudXBkYXRlKClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgbWV0aG9kLlxyXG4gICAgICogTWFrZS91cGRhdGUgdGhlIG1hcCBhZnRlciBjbGFzc2lmaWNhdGlvbiBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjaGFuZ2VkLlxyXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBudW1iZXIgb2YgY2xhc3Nlcywgb3IgdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZCBoYXMgY2hhbmdlZCwgY2FsbCB0aGlzIG1ldGhvZCB0byB1cGRhdGUgdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgdXBkYXRlQ2xhc3NpZmljYXRpb24gZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBtZXRob2QuXHJcbiAgICAgKiBNYWtlL3VwZGF0ZSB0aGUgbWFwIGFmdGVyIHN0eWxpbmcgYXR0cmlidXRlcyBoYXZlIGJlZW4gY2hhbmdlZC5cclxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGUgc3R5bGUgKGNvbG9yPykgZm9yIG9uZSBsZWdlbmQgZWxlbWVudCBoYXMgY2hhbmdlZCwgY2FsbCB0aGlzIG1ldGhvZCB0byB1cGRhdGUgdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgdXBkYXRlU3R5bGUgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBtZXRob2QuXHJcbiAgICAgKiBGdW5jdGlvbiB3aGljaCByZXR1cm4gdGhlIGxlZ2VuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgZ2V0TGVnZW5kQ29uc3RydWN0b3IgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJylcclxuICAgICAgICByZXR1cm4gTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIHRpbWUgc3RhbXAgb2YgdGhlIG1hcCwgZXZlbiBpZiBub3Qgc3BlY2lmaWVkIGluIHRoZSBkaW1lbnNpb24gaW5pdGlhbGx5LlxyXG4gICAgICogVGhpcyBhcHBsaWVzIG9ubHkgZm9yIHN0YXQgZGF0YSByZXRyaWV2ZWQgZnJvbSBFdXJvc3RhdCBBUEkuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgd2hlbiB0aGUgZGF0YSByZXRyaWV2ZWQgaXMgdGhlIGZyZXNoZXN0LCBhbmQgb25lIHdhbnRzIHRvIGtub3cgd2hhdCB0aGlzIGRhdGUgaXMsIGZvciBleGFtcGxlIHRvIGRpc3BsYXkgaXQgaW4gdGhlIG1hcCB0aXRsZS5cclxuICAgICAqL1xyXG4gICAgb3V0LmdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dC5zdGF0RGF0YSgnZGVmYXVsdCcpLmdldFRpbWUoKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvbWUgbWFwIGF0dHJpYnV0ZXMgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBVUkwgcGFyYW1ldGVyczpcclxuICAgICAqIFwid1wiOndpZHRoLCBcImhcIjpoZWlnaHQsIFwieFwiOnhHZW9DZW50ZXIsIFwieVwiOnlHZW9DZW50ZXIsIFwielwiOnBpeEdlb1NpemUsIFwic1wiOnNjYWxlLCBcImx2bFwiOm51dHMgbGV2ZWwsIFwidGltZVwiOnRpbWUsXHJcbiAgICAgKiBcInByb2pcIjpDUlMsIFwiZ2VvXCI6Z2VvIHRlcnJpdG9yeSwgXCJueVwiOm51dHMgdmVyc2lvbiwgXCJsYW5ndWFnZVwiOmxhbmdhZ2UsIFwibnVtYmVyT2ZDbGFzc2VzXCI6Y2xhc3MgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIG91dC5zZXRGcm9tVVJMID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBnZXRVUkxQYXJhbWV0ZXJzKClcclxuICAgICAgICBpZiAob3B0cy53KSBvdXQud2lkdGgob3B0cy53KVxyXG4gICAgICAgIGlmIChvcHRzLmgpIG91dC5oZWlnaHQob3B0cy5oKVxyXG4gICAgICAgIGlmIChvcHRzLnggJiYgb3B0cy55KSBvdXQuZ2VvQ2VudGVyKFtvcHRzLngsIG9wdHMueV0pXHJcbiAgICAgICAgaWYgKG9wdHMueikgb3V0LnBpeGVsU2l6ZShvcHRzLnopXHJcbiAgICAgICAgaWYgKG9wdHMucykgb3V0LnNjYWxlKG9wdHMucylcclxuICAgICAgICBpZiAob3B0cy5sdmwpIG91dC5udXRzTGV2ZWwob3B0cy5sdmwpXHJcbiAgICAgICAgaWYgKG9wdHMudGltZSkge1xyXG4gICAgICAgICAgICBvdXQuZmlsdGVyc18udGltZSA9IG9wdHMudGltZVxyXG4gICAgICAgICAgICBkZWxldGUgb3V0LmZpbHRlcnNfLmxhc3RUaW1lUGVyaW9kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLnByb2opIG91dC5wcm9qKG9wdHMucHJvailcclxuICAgICAgICBpZiAob3B0cy5nZW8pIG91dC5nZW8ob3B0cy5nZW8pXHJcbiAgICAgICAgaWYgKG9wdHMubnkpIG91dC5udXRzWWVhcihvcHRzLm55KVxyXG4gICAgICAgIGlmIChvcHRzLmxhbmd1YWdlKSBvdXQubGFuZ3VhZ2Uob3B0cy5sYW5ndWFnZSlcclxuICAgICAgICBpZiAob3B0cy5udW1iZXJPZkNsYXNzZXMpIG91dC5udW1iZXJPZkNsYXNzZXMoK29wdHMubnVtYmVyT2ZDbGFzc2VzKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBleHBvcnRNYXBUb1NWR1xyXG4gICAgICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgdGhlIGN1cnJlbnQgbWFwIHdpdGggc3R5bGluZyB0byBTVkcgYW5kIGRvd25sb2FkcyBpdFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgb3V0LmV4cG9ydE1hcFRvU1ZHID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENsb25lIHRoZSBvcmlnaW5hbCBTVkcgbm9kZSB0byBhdm9pZCBtb2RpZnlpbmcgdGhlIERPTVxyXG4gICAgICAgIGNvbnN0IHN2Z05vZGVDbG9uZSA9IG91dC5zdmdfLm5vZGUoKS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgICAvLyBBZGQgWE1MIG5hbWVzcGFjZXMgaWYgbm90IGFscmVhZHkgcHJlc2VudFxyXG4gICAgICAgIGlmICghc3ZnTm9kZUNsb25lLmhhc0F0dHJpYnV0ZSgneG1sbnMnKSkge1xyXG4gICAgICAgICAgICBzdmdOb2RlQ2xvbmUuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3ZnTm9kZUNsb25lLmhhc0F0dHJpYnV0ZSgneG1sbnM6eGxpbmsnKSkge1xyXG4gICAgICAgICAgICBzdmdOb2RlQ2xvbmUuc2V0QXR0cmlidXRlKCd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGFwcGVuZCB0aGUgY2xvbmUgdG8gdGhlIGRvY3VtZW50IHRvIGNvbXB1dGUgc3R5bGVzXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgQ1NTIHRvIGlubGluZSBzdHlsZXMgYmVmb3JlIHNhdmluZyB0aGUgU1ZHXHJcbiAgICAgICAgYXBwbHlJbmxpbmVTdHlsZXNGcm9tQ1NTKHN2Z05vZGVDbG9uZSlcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjbG9uZWQgU1ZHIGZyb20gdGhlIGRvY3VtZW50IGFmdGVyIGFwcGx5aW5nIHN0eWxlc1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnTm9kZUNsb25lKVxyXG5cclxuICAgICAgICBjb25zdCBzdmdVcmwgPSBnZXREb3dubG9hZFVSTChzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIGRvd25sb2FkIGxpbmsgYW5kIHRyaWdnZXIgZG93bmxvYWRcclxuICAgICAgICBjb25zdCBkb3dubG9hZExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcclxuICAgICAgICBkb3dubG9hZExpbmsuaHJlZiA9IHN2Z1VybFxyXG4gICAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9ICdldXJvc3RhdG1hcC5zdmcnXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZExpbmspXHJcbiAgICAgICAgZG93bmxvYWRMaW5rLmNsaWNrKClcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkTGluaylcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGV4cG9ydE1hcFRvUE5HXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRXhwb3J0cyB0aGUgY3VycmVudCBtYXAgd2l0aCBzdHlsaW5nIHRvIFBORyBhbmQgZG93bmxvYWRzIGl0XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBvdXQuZXhwb3J0TWFwVG9QTkcgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IHN2Z05vZGVDbG9uZSA9IG91dC5zdmdfLm5vZGUoKS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgICAvLyBDb252ZXJ0IENTUyB0byBpbmxpbmUgc3R5bGVzIGJlZm9yZSBzYXZpbmcgdGhlIFNWR1xyXG4gICAgICAgIGFwcGx5SW5saW5lU3R5bGVzRnJvbUNTUyhzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMTogU2VyaWFsaXplIHRoZSBTVkcgbm9kZSB0byBhIHN0cmluZ1xyXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpXHJcbiAgICAgICAgY29uc3Qgc3ZnU3RyaW5nID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMjogQ3JlYXRlIGEgQmxvYiBmcm9tIHRoZSBzZXJpYWxpemVkIFNWR1xyXG4gICAgICAgIGNvbnN0IHN2Z0Jsb2IgPSBuZXcgQmxvYihbc3ZnU3RyaW5nXSwgeyB0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04JyB9KVxyXG5cclxuICAgICAgICAvLyBTdGVwIDM6IENyZWF0ZSBhIFVSTCBmb3IgdGhlIEJsb2JcclxuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN2Z0Jsb2IpXHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIGZyb20gdGhlIFNWR1xyXG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgc3ZnTm9kZUNsb25lLmdldEF0dHJpYnV0ZSgnd2lkdGgnKVxyXG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdmdOb2RlQ2xvbmUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxyXG5cclxuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVkcgd2lkdGggb3IgaGVpZ2h0IGF0dHJpYnV0ZXMgYXJlIG1pc3Npbmcgb3IgaW52YWxpZC4nKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCA0OiBDcmVhdGUgYW4gSW1hZ2UgZWxlbWVudCBhbmQgbG9hZCB0aGUgQmxvYiBVUkxcclxuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxyXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFN0ZXAgNTogRHJhdyB0aGUgaW1hZ2Ugb24gYSBjYW52YXNcclxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcGFyc2VGbG9hdCh3aWR0aCkgLy8gU2V0IGNhbnZhcyB3aWR0aCBmcm9tIFNWRydzIHdpZHRoIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQpIC8vIFNldCBjYW52YXMgaGVpZ2h0IGZyb20gU1ZHJ3MgaGVpZ2h0IGF0dHJpYnV0ZVxyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCA2OiBDb252ZXJ0IHRoZSBjYW52YXMgdG8gYSBQTkcgYmxvYlxyXG4gICAgICAgICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChwbmdCbG9iKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGVwIDc6IERvd25sb2FkIHRoZSBQTkcgZmlsZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG5nVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChwbmdCbG9iKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuaHJlZiA9IHBuZ1VybFxyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRMaW5rLmRvd25sb2FkID0gJ2V1cm9zdGF0LW1hcC5wbmcnXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkTGluaylcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5jbGljaygpXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkTGluaylcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBVUkxzXHJcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcclxuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwocG5nVXJsKVxyXG4gICAgICAgICAgICB9LCAnaW1hZ2UvcG5nJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgaW1hZ2Ugc291cmNlIHRvIHRoZSBCbG9iIFVSTFxyXG4gICAgICAgIGltZy5zcmMgPSB1cmxcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgc29tZSBVUkwgcGFyYW1ldGVycywgd2hpY2ggY291bGQgYmUgdGhlbiByZXVzZWQgYXMgbWFwIGRlZmluaXRpb24gcGFyYW1ldGVycy5cclxuICogVGhpcyBhbGxvdyBhIHF1aWNrIG1hcCBjdXN0b21pc2F0aW9uIGJ5IHNpbXBseSBhZGRpbmcgYW5kIGNoYW5naW5nIHNvbWUgVVJMIHBhcmFtZXRlcnMuXHJcbiAqIFNlZSBtYXAgbWV0aG9kOiBzZXRGcm9tVVJMKC4uLilcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVUkxQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgcHMgPSB7fVxyXG4gICAgY29uc3QgcCA9IFsndycsICdoJywgJ3gnLCAneScsICd6JywgJ3MnLCAnbHZsJywgJ3RpbWUnLCAncHJvaicsICdnZW8nLCAnbnknLCAnbGFuZ3VhZ2UnLCAnc2wnLCAnbnVtYmVyT2ZDbGFzc2VzJ11cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykgcHNbcFtpXV0gPSBnZXRVUkxQYXJhbWV0ZXJCeU5hbWUocFtpXSlcclxuICAgIHJldHVybiBwc1xyXG59XHJcbiIsIi8vIGUuZy4gdG8gYmUgdXNlZCB3aXRoIGRlcHJlY2F0ZWQgLnN0eWxlKCkgZnVuY3Rpb25zLiBUaGV5IHdpbGwgbm93IHVwZGF0ZSBDU1MgY2xhc3Nlcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNTU1J1bGUoc2VsZWN0b3IsIHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgLy8gVmFsaWRhdGUgdGhlIHNlbGVjdG9yXHJcbiAgICBpZiAoIXNlbGVjdG9yLnN0YXJ0c1dpdGgoJy4nKSAmJiAhc2VsZWN0b3Iuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yOiBNdXN0IHN0YXJ0IHdpdGggXCIuXCIgZm9yIGNsYXNzZXMgb3IgXCIjXCIgZm9yIElEcy4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIHRoZSBydWxlIGFscmVhZHkgZXhpc3RzIGluIGFueSBzdHlsZXNoZWV0XHJcbiAgICBjb25zdCBzdHlsZVNoZWV0cyA9IEFycmF5LmZyb20oZG9jdW1lbnQuc3R5bGVTaGVldHMpXHJcbiAgICBmb3IgKGNvbnN0IHN0eWxlU2hlZXQgb2Ygc3R5bGVTaGVldHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IHN0eWxlU2hlZXQuY3NzUnVsZXMgfHwgc3R5bGVTaGVldC5ydWxlc1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yVGV4dCA9PT0gc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb3BlcnR5IGlmIHRoZSBydWxlIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGVbcHJvcGVydHldID0gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gU29tZSBzdHlsZXNoZWV0cyAoZS5nLiwgY3Jvc3Mtb3JpZ2luKSBtYXkgbm90IGJlIGFjY2Vzc2libGVcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgYWNjZXNzIHJ1bGVzIGluIHN0eWxlc2hlZXQ6YCwgZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHJ1bGUgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IHN0eWxlc2hlZXQgYW5kIGFkZCBpdFxyXG4gICAgbGV0IGN1c3RvbVNoZWV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1c3RvbS1zdHlsZXMnKVxyXG4gICAgaWYgKCFjdXN0b21TaGVldCkge1xyXG4gICAgICAgIGN1c3RvbVNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxyXG4gICAgICAgIGN1c3RvbVNoZWV0LmlkID0gJ2N1c3RvbS1zdHlsZXMnXHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjdXN0b21TaGVldClcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIG5ldyBydWxlIHRvIHRoZSBjdXN0b20gc3R5bGVzaGVldFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjdXN0b21TaGVldC5zaGVldC5pbnNlcnRSdWxlKGAke3NlbGVjdG9yfSB7ICR7cHJvcGVydHl9OiAke3ZhbHVlfTsgfWAsIGN1c3RvbVNoZWV0LnNoZWV0LmNzc1J1bGVzLmxlbmd0aClcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaW5zZXJ0IHJ1bGU6ICR7c2VsZWN0b3J9IHsgJHtwcm9wZXJ0eX06ICR7dmFsdWV9OyB9YCwgZSlcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldEZvbnRTaXplRnJvbUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGNsYXNzXHJcbiAgICBjb25zdCB0ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICB0ZW1wRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWVcclxuXHJcbiAgICAvLyBBcHBseSBpbmxpbmUgc3R5bGVzIHRvIG1pbmltaXplIGxheW91dCBpbnRlcmZlcmVuY2VcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0bydcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5saW5lSGVpZ2h0ID0gJ25vcm1hbCdcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gJ2luaXRpYWwnXHJcblxyXG4gICAgLy8gQXBwZW5kIGRpcmVjdGx5IHRvIHRoZSBib2R5XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBFbGVtZW50KVxyXG5cclxuICAgIC8vIEdldCB0aGUgY29tcHV0ZWQgZm9udC1zaXplIHByb3BlcnR5IGFuZCBwYXJzZSBpdCB0byBhIG51bWJlclxyXG4gICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRlbXBFbGVtZW50KS5mb250U2l6ZSlcclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGJvZHlcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQpXHJcblxyXG4gICAgcmV0dXJuIGZvbnRTaXplIHx8IDBcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldENTU1Byb3BlcnR5RnJvbUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgcHJvcGVydHlOYW1lKSB7XHJcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgY2xhc3NcclxuICAgIGNvbnN0IHRlbXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIHRlbXBFbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxyXG5cclxuICAgIC8vIEFwcGx5IGlubGluZSBzdHlsZXMgdG8gbWluaW1pemUgbGF5b3V0IGludGVyZmVyZW5jZVxyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUud2lkdGggPSAnYXV0bydcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQgPSAnbm9ybWFsJ1xyXG5cclxuICAgIC8vIEFwcGVuZCBkaXJlY3RseSB0byB0aGUgYm9keVxyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRWxlbWVudClcclxuXHJcbiAgICAvLyBHZXQgdGhlIGNvbXB1dGVkIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcclxuICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZW1wRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpXHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZWxlbWVudCBmcm9tIHRoZSBkb2N1bWVudCBib2R5XHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KVxyXG5cclxuICAgIHJldHVybiBwcm9wZXJ0eVZhbHVlIHx8IG51bGxcclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhbGwgQ1NTIHJ1bGVzIGRlZmluZWQgaW4gdGhlIGRvY3VtZW50XHJcbmZ1bmN0aW9uIGdldEFsbENTU1J1bGVzKCkge1xyXG4gICAgbGV0IGNzc1J1bGVzID0gW11cclxuICAgIGZvciAobGV0IHNoZWV0IG9mIGRvY3VtZW50LnN0eWxlU2hlZXRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gU29tZSBzdHlsZXNoZWV0cyBtYXkgbm90IGJlIGFjY2Vzc2libGUgZHVlIHRvIENPUlMsIHNvIHdlIGNhdGNoIGFueSBlcnJvcnNcclxuICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBzaGVldC5jc3NSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgY3NzUnVsZXMucHVzaChydWxlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBhY2Nlc3Mgc3R5bGVzaGVldDonLCBzaGVldC5ocmVmLCBlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjc3NSdWxlc1xyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGV4cGxpY2l0bHkgZGVmaW5lZCBzdHlsZXMgZnJvbSBDU1MgZm9yIGFuIGVsZW1lbnRcclxuZnVuY3Rpb24gZ2V0U3R5bGVzRnJvbUNTUyhlbGVtZW50KSB7XHJcbiAgICBsZXQgbWF0Y2hlZFJ1bGVzID0gW11cclxuICAgIGNvbnN0IGNzc1J1bGVzID0gZ2V0QWxsQ1NTUnVsZXMoKVxyXG5cclxuICAgIGNzc1J1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudC5tYXRjaGVzKHJ1bGUuc2VsZWN0b3JUZXh0KSkge1xyXG4gICAgICAgICAgICBtYXRjaGVkUnVsZXMucHVzaChydWxlLnN0eWxlKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy8gQ3JlYXRlIGFuIG9iamVjdCBvZiB0aGUgZXhwbGljaXRseSBzZXQgc3R5bGVzXHJcbiAgICBsZXQgZXhwbGljaXRTdHlsZXMgPSB7fVxyXG4gICAgbWF0Y2hlZFJ1bGVzLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHN0eWxlW2ldXHJcbiAgICAgICAgICAgIGV4cGxpY2l0U3R5bGVzW3Byb3BlcnR5XSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gZXhwbGljaXRTdHlsZXNcclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGlubGluZSBzdHlsZXMgZXhwbGljaXRseSBzZXQgaW4gQ1NTLiBVc2VmdWwgZm9yIGV4cG9ydGluZyBTVkdzIHdpdGggQ1NTIHN0eWxlcy5cclxuZXhwb3J0IGNvbnN0IGFwcGx5SW5saW5lU3R5bGVzRnJvbUNTUyA9IChzdmdFbGVtZW50KSA9PiB7XHJcbiAgICBjb25zdCBhbGxFbGVtZW50cyA9IHN2Z0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpXHJcblxyXG4gICAgYWxsRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNzc1N0eWxlcyA9IGdldFN0eWxlc0Zyb21DU1MoZWxlbWVudClcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgZWFjaCBleHBsaWNpdGx5IGRlZmluZWQgQ1NTIHN0eWxlIGFzIGFuIGlubGluZSBzdHlsZVxyXG4gICAgICAgIE9iamVjdC5rZXlzKGNzc1N0eWxlcykuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjc3NTdHlsZXNbcHJvcGVydHldXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcHJvcGVydHkgYWxyZWFkeSBoYXMgYW4gaW5saW5lIHN0eWxlXHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW5saW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXHJcblxyXG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nSW5saW5lU3R5bGUgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIG5vIGV4aXN0aW5nIGlubGluZSBzdHlsZSwgc2V0IHRoZSBuZXcgc3R5bGVcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBHZW9KU09OIGZlYXR1cmUgcmVwcmVzZW50aW5nIGEgYm91bmRpbmcgYm94LCB3aXRoIG11bHRpcG9pbnQgZ2VvbWV0cnkuXHJcbiAqIFRoaXMgYm91bmRpbmcgYm94IGlzIGFuIGFycmF5IGxpa2UgdGhlIG9uZSBpbiB0b3BvanNvbiBiYm94IGVsZW1lbnQuXHJcbiAqIFt4bWluLHltaW4seG1heCx5bWF4XVxyXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgdG8gY2FsbCBkMy5maXRTaXplKFt3LCBoXSwgZ2V0VG9wb0pTT05FeHRlbnRBc0dlb0pTT04odG9wby5iYm94KSkpXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gYmIgVGhlIGJvdW5kaW5nIGJveCBbeG1pbix5bWluLHhtYXgseW1heF0uIEZvciB0b3BvanNvbiBkYXRhLCBqdXN0IGdpdmUgdGhlIHRvcG9qc29uLmJib3ggZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRCQk9YQXNHZW9KU09OID0gZnVuY3Rpb24gKGJiKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcclxuICAgICAgICBnZW9tZXRyeToge1xyXG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlQb2ludCcsXHJcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXHJcbiAgICAgICAgICAgICAgICBbYmJbMF0sIGJiWzFdXSxcclxuICAgICAgICAgICAgICAgIFtiYlsyXSwgYmJbM11dLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0sXHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIGluZGV4aW5nXHJcblxyXG4vKipcclxuICogSW5kZXggSlNPTlN0YXQgc3RhdCB2YWx1ZXMgYnkgJ2dlbycgY29kZS5cclxuICogUmV0dXJuIGEgc3RydWN0dXJlIGxpa2U6IHtnZW86e3ZhbHVlOjAsc3RhdHVzOlwiXCJ9fVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGpzRGF0YSBUaGUgSlNPTlN0YXQgZGF0YSB0byBpbmRleFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGpzb25zdGF0VG9JbmRleCA9IGZ1bmN0aW9uIChqc0RhdGEpIHtcclxuICAgIGNvbnN0IGluZCA9IHt9XHJcbiAgICBjb25zdCBnZW9zID0ganNEYXRhLkRpbWVuc2lvbignZ2VvJykuaWRcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2Vvcy5sZW5ndGg7IGkrKykgaW5kW2dlb3NbaV1dID0ganNEYXRhLkRhdGEoaSlcclxuICAgIHJldHVybiBpbmRcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGV4IENTViBzdGF0IHZhbHVlcyBieSAnZ2VvJyBjb2RlLlxyXG4gKiBSZXR1cm4gYSBzdHJ1Y3R1cmUgbGlrZToge2dlbzp7dmFsdWU6MCxzdGF0dXM6XCJcIn19XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY3N2RGF0YSBUaGUgQ1NWIGRhdGEgdG8gaW5kZXhcclxuICogQHBhcmFtIHsqfSBnZW9Db2wgVGhlIG5hbWUgb2YgdGhlIGdlbyBjb2x1bW4gaW4gdGhlIENTViBkYXRhXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVDb2wgVGhlIG5hbWUgb2YgdGhlIHN0YXRpc3RpY2FsIHZhbHVlIGNvbHVtbiBpbiB0aGUgQ1NWIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY3N2VG9JbmRleCA9IGZ1bmN0aW9uIChjc3ZEYXRhLCBnZW9Db2wsIHZhbHVlQ29sKSB7XHJcbiAgICBjb25zdCBpbmQgPSB7fVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3ZEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IGNzdkRhdGFbaV1cclxuICAgICAgICBjb25zdCB2ID0gZFt2YWx1ZUNvbF1cclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgaW5kW2RbZ2VvQ29sXV0gPSB7IHZhbHVlOiAnOicsIHN0YXR1czogJycgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZFtkW2dlb0NvbF1dID0geyB2YWx1ZTogaXNOYU4oK3YpID8gdiA6ICt2LCBzdGF0dXM6ICcnIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5kXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBzdHJpbmcgd2l0aCBzcGFjZSBhcyB0aG91c2FuZCBzZXBhcmF0b3JcclxuICogQGZ1bmN0aW9uIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yID0gZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgcmV0dXJuIG51bWJlci50b0xvY2FsZVN0cmluZygnZW4nKS5yZXBsYWNlKC8sL2dpLCAnICcpXHJcbn1cclxuXHJcbi8vUkVTVCBBUElcclxuZXhwb3J0IGNvbnN0IGdldEVzdGF0UmVzdERhdGFVUkxCYXNlID0gJ2h0dHBzOi8vZWMuZXVyb3BhLmV1L2V1cm9zdGF0L2FwaS9kaXNzZW1pbmF0aW9uL3N0YXRpc3RpY3MvMS4wL2RhdGEvJ1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIFVSTCB0byBmZXRjaCBkYXRhIGZyb20gZXVyb2Jhc2UgUkVTVCBBUEkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0Q29kZSBUaGUgRXVyb2Jhc2UgZGF0YXNldCBjb2RlXHJcbiAqIEBwYXJhbSB7b2JqZWN0PX0gZmlsdGVycyBUaGUgZmlsdGVyIHBhcmFtZXRlcnMgYXMgZm9yIGV4YW1wbGU6IHtrZXk6dmFsdWUsa2V5Olt2YWx1ZTEsdmFsdWUyLHZhbHVlM119XHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gbGFuZ1xyXG4gKiBAcGFyYW0ge251bWJlcj19IGZvcm1hdFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHZlcnNpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRFc3RhdERhdGFVUkwgPSBmdW5jdGlvbiAoZGF0YXNldENvZGUsIGZpbHRlcnMsIGxhbmcsIGZvcm1hdCkge1xyXG4gICAgbGFuZyA9IGxhbmcgfHwgJ2VuJ1xyXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICdqc29uJ1xyXG4gICAgdmFyIHVybCA9IFtdXHJcbiAgICB1cmwucHVzaChnZXRFc3RhdFJlc3REYXRhVVJMQmFzZSwgZGF0YXNldENvZGUsICc/JywgJ2Zvcm1hdD0nLCBmb3JtYXQsICcmbGFuZz0nLCBsYW5nKVxyXG4gICAgaWYgKGZpbHRlcnMpXHJcbiAgICAgICAgZm9yICh2YXIgcGFyYW0gaW4gZmlsdGVycykge1xyXG4gICAgICAgICAgICB2YXIgbyA9IGZpbHRlcnNbcGFyYW1dXHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHVybC5wdXNoKCcmJywgcGFyYW0sICc9Jywgb1tpXSlcclxuICAgICAgICAgICAgZWxzZSB1cmwucHVzaCgnJicsIHBhcmFtLCAnPScsIG8pXHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHVybC5qb2luKCcnKVxyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVUkxQYXJhbWV0ZXJCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpXHJcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdbXFxcXD8mXScgKyBuYW1lICsgJz0oW14mI10qKScpLFxyXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKGxvY2F0aW9uLnNlYXJjaClcclxuICAgIHJldHVybiAhcmVzdWx0cyA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSlcclxufVxyXG5cclxuLy9mbGFnc1xyXG5leHBvcnQgY29uc3QgZmxhZ3MgPSB7XHJcbiAgICBiOiAnYnJlYWsgaW4gdGltZSBzZXJpZXMnLFxyXG4gICAgYzogJ2NvbmZpZGVudGlhbCcsXHJcbiAgICBkOiAnZGVmaW5pdGlvbiBkaWZmZXJzLCBzZWUgbWV0YWRhdGEnLFxyXG4gICAgZTogJ2VzdGltYXRlZCcsXHJcbiAgICBmOiAnZm9yZWNhc3QnLFxyXG4gICAgbjogJ25vdCBzaWduaWZpY2FudCcsXHJcbiAgICBwOiAncHJvdmlzaW9uYWwnLFxyXG4gICAgcjogJ3JldmlzZWQnLFxyXG4gICAgczogJ0V1cm9zdGF0IGVzdGltYXRlJyxcclxuICAgIHU6ICdsb3cgcmVsaWFiaWxpdHknLFxyXG4gICAgejogJ25vdCBhcHBsaWNhYmxlJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBFeGVjdXRlcyBhIGZ1bmN0aW9uIGZvciBhbGwgaW5zZXQgbWFwcy4gU29tZSBpbnNldHMgbWlnaHQgYmUgZXh0ZXJuYWwgU1ZHcyB3aGljaCBpcyB3aHkgdGhpcyBmdW5jdGlvbiB3YXMgY3JlYXRlZC5cclxuICogQHBhcmFtIHsqfSBpbnNldHMgbWFwLmluc2V0c1xyXG4gKiBAcGFyYW0geyp9IG1haW5TdmdJZCB0aGUgSUQgb2YgdGhlIG1hcCdzIHN2Z1xyXG4gKiBAcGFyYW0geyp9IGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGluc2V0XHJcbiAqIEBwYXJhbSB7Kn0gW3BhcmFtZXRlcj1udWxsXSB0aGUgcGFyYW1ldGVyIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7Kn0gW3BhcmFtZXRlcjI9bnVsbF0gdGhlIHBhcmFtZXRlciB0byBwYXNzIHRvIHRoZSBjYWxsYmFja1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGV4ZWN1dGVGb3JBbGxJbnNldHMgPSBmdW5jdGlvbiAoaW5zZXRzLCBtYWluU3ZnSWQsIGNhbGxiYWNrLCBwYXJhbWV0ZXIgPSBudWxsLCBwYXJhbWV0ZXIyID0gbnVsbCkge1xyXG4gICAgZm9yIChjb25zdCBnZW8gaW4gaW5zZXRzKSB7XHJcbiAgICAgICAgY29uc3QgaW5zZXRHcm91cCA9IGluc2V0c1tnZW9dXHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc2V0R3JvdXApKSB7XHJcbiAgICAgICAgICAgIGluc2V0R3JvdXAuZm9yRWFjaCgoaW5zZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgYXJyYXlzIGZvciBtdWx0aXBsZSBpbnNldHMgd2l0aCB0aGUgc2FtZSBnZW9cclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2V0LmZvckVhY2goKG5lc3RlZEluc2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRJbnNldC5zdmdJZF8gIT09IG1haW5TdmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmVzdGVkSW5zZXQsIHBhcmFtZXRlciwgcGFyYW1ldGVyMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNldC5zdmdJZF8gIT09IG1haW5TdmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnNldCwgcGFyYW1ldGVyLCBwYXJhbWV0ZXIyKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjYWxsYmFjayB0byB1bmlxdWUgaW5zZXRcclxuICAgICAgICAgICAgaWYgKGluc2V0R3JvdXAuc3ZnSWRfICE9PSBtYWluU3ZnSWQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc2V0R3JvdXAsIHBhcmFtZXRlciwgcGFyYW1ldGVyMilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZUZpcnN0TGV0dGVyID0gKHN0cmluZykgPT4gYCR7c3RyaW5nLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCl9JHtzdHJpbmcuc2xpY2UoMSl9YFxyXG5cclxuZXhwb3J0IGNvbnN0IGxvd2VyQ2FzZUFsbFdvcmRzRXhjZXB0Rmlyc3RMZXR0ZXJzID0gKHN0cmluZykgPT5cclxuICAgIHN0cmluZy5yZXBsYWNlQWxsKC9cXFMqL2csICh3b3JkKSA9PiBgJHt3b3JkLnNsaWNlKDAsIDEpfSR7d29yZC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpfWApXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG93bmxvYWRVUkwoc3ZnTm9kZSkge1xyXG4gICAgLy8gQ3JlYXRlIFhNTCBoZWFkZXIgdG8gZW5zdXJlIHRoZSBTVkcgaXMgcmVjb2duaXplZCBwcm9wZXJseVxyXG4gICAgY29uc3QgeG1sSGVhZGVyID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cIm5vXCI/PlxcbidcclxuXHJcbiAgICAvLyBjcmVhdGUgYmxvYlxyXG4gICAgY29uc3Qgc3ZnQ29udGVudCA9IHhtbEhlYWRlciArIHN2Z05vZGUub3V0ZXJIVE1MXHJcbiAgICBjb25zdCBzdmdCbG9iID0gbmV3IEJsb2IoW3N2Z0NvbnRlbnRdLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgnIH0pXHJcbiAgICBjb25zdCBzdmdVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN2Z0Jsb2IpXHJcbiAgICByZXR1cm4gc3ZnVXJsXHJcbn1cclxuXHJcbi8vIFJhc3Rlcml6ZSBmdW5jdGlvbiB3aXRoIGFkZGl0aW9uYWwgZXJyb3IgaGFuZGxpbmdcclxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShzdmcpIHtcclxuICAgIGNvbnN0IHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xyXG4gICAgY29uc3QgeGxpbmtucyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xyXG4gICAgY29uc3Qgc3ZnbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXHJcbiAgICBjb25zdCBmcmFnbWVudCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmICsgJyMnXHJcbiAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHN2ZywgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIG51bGwsIGZhbHNlKVxyXG4gICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHdhbGtlci5jdXJyZW50Tm9kZS5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlLmluY2x1ZGVzKGZyYWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IGF0dHIudmFsdWUucmVwbGFjZShmcmFnbWVudCwgJyMnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3ZnLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCAneG1sbnMnLCBzdmducylcclxuICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyh4bWxucywgJ3htbG5zOnhsaW5rJywgeGxpbmtucylcclxuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgd2luZG93LlhNTFNlcmlhbGl6ZXIoKVxyXG4gICAgY29uc3Qgc3RyaW5nID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmcpXHJcbiAgICByZXR1cm4gbmV3IEJsb2IoW3N0cmluZ10sIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWwnIH0pXHJcbn1cclxuXHJcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL3NhdmluZy1zdlxyXG4vL3N2ZyB0byBjYW52YXMgYmxvYiBwcm9taXNlXHJcbmV4cG9ydCBmdW5jdGlvbiByYXN0ZXJpemUoc3ZnKSB7XHJcbiAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0XHJcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHksIG4pID0+ICgocmVzb2x2ZSA9IHkpLCAocmVqZWN0ID0gbikpKVxyXG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKVxyXG4gICAgaW1hZ2Uub25lcnJvciA9IHJlamVjdFxyXG4gICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlY3QgPSBzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGhcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHRcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpXHJcbiAgICAgICAgY29udGV4dC5jYW52YXMudG9CbG9iKHJlc29sdmUpXHJcbiAgICB9XHJcbiAgICBpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHNlcmlhbGl6ZShzdmcpKVxyXG4gICAgcmV0dXJuIHByb21pc2VcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIFVSTCBwYXJhbWV0ZXIgYnkgbmFtZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUpIHtcclxuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKVxyXG4gICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgbmFtZSArICc9KFteJiNdKiknKSxcclxuICAgICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpXHJcbiAgICByZXR1cm4gIXJlc3VsdHMgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBoZXhUb1JnYiA9IChoZXgpID0+IHtcclxuICAgIGhleCA9IGhleC5yZXBsYWNlKCcjJywgJycpXHJcbiAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgIGhleCA9IGhleFxyXG4gICAgICAgICAgICAuc3BsaXQoJycpXHJcbiAgICAgICAgICAgIC5tYXAoKGgpID0+IGggKyBoKVxyXG4gICAgICAgICAgICAuam9pbignJylcclxuICAgIH1cclxuICAgIGNvbnN0IGludCA9IHBhcnNlSW50KGhleCwgMTYpXHJcbiAgICByZXR1cm4gWyhpbnQgPj4gMTYpICYgMjU1LCAoaW50ID4+IDgpICYgMjU1LCBpbnQgJiAyNTVdXHJcbn1cclxuXHJcbi8vYmxlbmRzIHR3byBjb2xvcnMgdXNpbmcgJ211bHRpcGx5JyBibGVuZGluZyBtb2RlLiBSZXR1cm5zIHRoZSBibGVuZGVkIGNvbG9yIGFzIGFuIFJHQiBzdHJpbmdcclxuZXhwb3J0IGNvbnN0IG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleCA9IChjb2xvcnMpID0+IHtcclxuICAgIC8vIENvbnZlcnQgaGV4IGNvbG9yIHRvIFJHQlxyXG4gICAgY29uc3QgaGV4VG9SZ2IgPSAoaGV4KSA9PiB7XHJcbiAgICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoJyMnLCAnJylcclxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICBoZXggPSBoZXhcclxuICAgICAgICAgICAgICAgIC5zcGxpdCgnJylcclxuICAgICAgICAgICAgICAgIC5tYXAoKGgpID0+IGggKyBoKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGludCA9IHBhcnNlSW50KGhleCwgMTYpXHJcbiAgICAgICAgcmV0dXJuIFsoaW50ID4+IDE2KSAmIDI1NSwgKGludCA+PiA4KSAmIDI1NSwgaW50ICYgMjU1XVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgUkdCIHRvIGhleFxyXG4gICAgY29uc3QgcmdiVG9IZXggPSAoW3IsIGcsIGJdKSA9PiBgIyR7W3IsIGcsIGJdLm1hcCgoYykgPT4gYy50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyl9YFxyXG5cclxuICAgIC8vIENvbnZlcnQgYWxsIGhleCBjb2xvcnMgdG8gUkdCIGFycmF5c1xyXG4gICAgY29uc3QgcmdiQ29sb3JzID0gY29sb3JzLm1hcChoZXhUb1JnYilcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSByZXN1bHQgd2l0aCB0aGUgZmlyc3QgY29sb3JcclxuICAgIGxldCBibGVuZGVkID0gWy4uLnJnYkNvbG9yc1swXV1cclxuXHJcbiAgICAvLyBTZXF1ZW50aWFsbHkgbXVsdGlwbHkgZWFjaCBjb2xvciB3aXRoIHRoZSByZXN1bHRcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmdiQ29sb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYmxlbmRlZCA9IGJsZW5kZWQubWFwKCh2LCBpZHgpID0+IE1hdGgucm91bmQoKHYgLyAyNTUpICogKHJnYkNvbG9yc1tpXVtpZHhdIC8gMjU1KSAqIDI1NSkpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBibGVuZGVkIGNvbG9yIGFzIGEgaGV4IGNvZGVcclxuICAgIHJldHVybiByZ2JUb0hleChibGVuZGVkKVxyXG59XHJcblxyXG4vLyBjb252ZXJ0IHJlY3QgYXR0cmlidXRlcyBpbnRvIGFuIFNWRyBwYXRoIHN0cmluZ1xyXG4vLyB1c2VkIGZvciB3b3JrYXJvdW5kIHdoZXJlYnkgY2xpcFBhdGhzIHdoaWNoIHVzZSByZWN0IGVsZW1lbnRzIGRvIG5vdCB3b3JrIGluIGFkb2JlIGlsbHVzdHJhdG9yXHJcbmV4cG9ydCBjb25zdCBjb252ZXJ0UmVjdGFuZ2xlc1RvUGF0aHMgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KHgsIDEwKVxyXG4gICAgdmFyIHkgPSBwYXJzZUZsb2F0KHksIDEwKVxyXG4gICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh3aWR0aCwgMTApXHJcbiAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQsIDEwKVxyXG5cclxuICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB3aWR0aCA8IDAgfHwgaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgIHJldHVybiAnJ1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnTScgKyB4ICsgJywnICsgeSArICdMJyArICh4ICsgd2lkdGgpICsgJywnICsgeSArICcgJyArICh4ICsgd2lkdGgpICsgJywnICsgKHkgKyBoZWlnaHQpICsgJyAnICsgeCArICcsJyArICh5ICsgaGVpZ2h0KSArICd6J1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZCA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgIGxldCByLCBnLCBiXHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGVsZW1lbnQgdG8gaGFuZGxlIG5hbWVkIGNvbG9yc1xyXG4gICAgaWYgKCFiYWNrZ3JvdW5kQ29sb3Iuc3RhcnRzV2l0aCgncmdiJykgJiYgIWJhY2tncm91bmRDb2xvci5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgICBjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgICB0ZW1wRGl2LnN0eWxlLmNvbG9yID0gYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRGl2KVxyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZW1wRGl2KS5jb2xvclxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVtcERpdilcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBjb21wdXRlZENvbG9yIC8vIENvbnZlcnQgbmFtZWQgY29sb3IgdG8gUkdCXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIGhleCBjb2xvcnMgbGlrZSAnI0ZGRkZGRicgb3IgJyNGRkYnXHJcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgIGxldCBoZXggPSBiYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgnIycsICcnKVxyXG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIGhleCA9IGhleFxyXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoYykgPT4gYyArIGMpXHJcbiAgICAgICAgICAgICAgICAuam9pbignJylcclxuICAgICAgICB9XHJcbiAgICAgICAgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMCwgMiksIDE2KVxyXG4gICAgICAgIGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDIsIDQpLCAxNilcclxuICAgICAgICBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpXHJcbiAgICB9XHJcbiAgICAvLyBIYW5kbGUgUkdCIGNvbG9ycyBsaWtlICdyZ2IoMjU1LDI1NSwyNTUpJ1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gYmFja2dyb3VuZENvbG9yLm1hdGNoKC9cXGQrL2cpXHJcbiAgICAgICAgciA9IHBhcnNlSW50KHJnYlswXSlcclxuICAgICAgICBnID0gcGFyc2VJbnQocmdiWzFdKVxyXG4gICAgICAgIGIgPSBwYXJzZUludChyZ2JbMl0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGx1bWluYW5jZVxyXG4gICAgY29uc3QgbHVtaW5hbmNlID0gMC4yMTI2ICogKHIgLyAyNTUpICsgMC43MTUyICogKGcgLyAyNTUpICsgMC4wNzIyICogKGIgLyAyNTUpXHJcblxyXG4gICAgLy8gUmV0dXJuIGJsYWNrIGZvciBsaWdodCBiYWNrZ3JvdW5kcywgd2hpdGUgZm9yIGRhcmsgYmFja2dyb3VuZHNcclxuICAgIHJldHVybiBsdW1pbmFuY2UgPiAwLjUgPyAnYmxhY2snIDogJ3doaXRlJ1xyXG59XHJcblxyXG4vLyBnZXQgY3NzIHNlbGVjdG9yLiBEaWZmZXJlbnQgbWFwcyBoYXZlIGRpZmZlcmVudCBzZWxlY3RvcnMgZm9yIHRoZWlyIHJlZ2lvbnMuXHJcbmV4cG9ydCBjb25zdCBnZXRSZWdpb25zU2VsZWN0b3IgPSAobWFwKSA9PiB7XHJcbiAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHJldHVybiAnI2VtLXVzZXItcmVnaW9ucyBwYXRoJ1xyXG4gICAgaWYgKG1hcC5ncmlkQ2FydG9ncmFtXykgcmV0dXJuICcjZW0tZ3JpZC1jb250YWluZXIgLmVtLWdyaWQtY2VsbCdcclxuICAgIGlmIChtYXAuZ2VvXyA9PT0gJ1dPUkxEJykgcmV0dXJuICcjZW0td29ybGRyZyBwYXRoJ1xyXG4gICAgcmV0dXJuICcjZW0tbnV0c3JnIHBhdGg6bm90KCNlbS1jbnRyZy1SUyk6bm90KCNlbS1jbnRyZy1FTCksICNlbS1jbnRyZyBwYXRoOm5vdCgjZW0tY250cmctUlMpOm5vdCgjZW0tY250cmctRUwpJ1xyXG59XHJcblxyXG4vLyBnZXQgY3NzIHNlbGVjdG9yIGZvciBsZWdlbmQgbW91c2UgaG92ZXIuIERpZmZlcmVudCBtYXBzIGhhdmUgZGlmZmVyZW50IHNlbGVjdG9ycyBmb3IgdGhlaXIgcmVnaW9uc1xyXG5leHBvcnQgY29uc3QgZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yID0gKG1hcCkgPT4ge1xyXG4gICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSByZXR1cm4gJyNlbS11c2VyLXJlZ2lvbnMnXHJcbiAgICBpZiAobWFwLmdyaWRDYXJ0b2dyYW1fKSByZXR1cm4gJyNlbS1ncmlkLWNvbnRhaW5lcidcclxuICAgIGlmIChtYXAuZ2VvXyA9PT0gJ1dPUkxEJykgcmV0dXJuICcjZW0td29ybGRyZydcclxuICAgIHJldHVybiAnI2VtLW51dHNyZywgI2VtLWNudHJnJ1xyXG59XHJcbiIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbm9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgKiBhcyBDaG9yb3BsZXRoIGZyb20gJy4vbWFwdHlwZXMvbWFwLWNob3JvcGxldGgnXHJcbmltcG9ydCAqIGFzIFByb3BvcnRpb25hbFN5bWJvbCBmcm9tICcuL21hcHR5cGVzL21hcC1wcm9wb3J0aW9uYWwtc3ltYm9scydcclxuaW1wb3J0ICogYXMgQ2F0ZWdvcmljYWwgZnJvbSAnLi9tYXB0eXBlcy9tYXAtY2F0ZWdvcmljYWwnXHJcbmltcG9ydCAqIGFzIEJpdmFyaWF0ZUNob3JvcGxldGggZnJvbSAnLi9tYXB0eXBlcy9tYXAtY2hvcm9wbGV0aC1iaXZhcmlhdGUnXHJcbmltcG9ydCAqIGFzIFRyaXZhcmlhdGVDaG9yb3BsZXRoIGZyb20gJy4vbWFwdHlwZXMvbWFwLWNob3JvcGxldGgtdHJpdmFyaWF0ZSdcclxuaW1wb3J0ICogYXMgU3RyaXBlQ29tcG9zaXRpb24gZnJvbSAnLi9tYXB0eXBlcy9tYXAtc3RyaXBlLWNvbXBvc2l0aW9uJ1xyXG5pbXBvcnQgKiBhcyBQaWVDaGFydHMgZnJvbSAnLi9tYXB0eXBlcy9tYXAtcGllY2hhcnRzJ1xyXG5pbXBvcnQgKiBhcyBTcGFya2xpbmVzIGZyb20gJy4vbWFwdHlwZXMvbWFwLXNwYXJrbGluZXMnXHJcbmltcG9ydCAqIGFzIEZsb3dNYXAgZnJvbSAnLi9tYXB0eXBlcy9tYXAtZmxvdydcclxuaW1wb3J0ICogYXMgbXQgZnJvbSAnLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgeyBERUZBVUxUTEFCRUxTIH0gZnJvbSAnLi9jb3JlL2xhYmVscydcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYSBldXJvc3RhdC1tYXAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHR5cGUgVGhlIHR5cGUgb2YgbWFwICgnY2gnIGZvciBjaG9yb3BsZXRoLCBldGMuKVxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuIEV4LjogeyB0aXRsZTogXCJNYXAgdGl0bGVcIiwgZ2VvQ2VudGVyOiBbMjMzLDY1NF0sIC4uLn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnKSB7XHJcbiAgICAvL2Nob3JvcGxldGggbWFwXHJcbiAgICBpZiAodHlwZSA9PSAnY2hvcm9wbGV0aCcgfHwgdHlwZSA9PSAnY2gnKSByZXR1cm4gQ2hvcm9wbGV0aC5tYXAoY29uZmlnKVxyXG4gICAgLy9jYXRlZ29yaWNhbCBtYXBcclxuICAgIGlmICh0eXBlID09ICdjYXRlZ29yaWNhbCcgfHwgdHlwZSA9PSAnY3QnKSByZXR1cm4gQ2F0ZWdvcmljYWwubWFwKGNvbmZpZylcclxuICAgIC8vcHJvcG9ydGlvbm5hbCBzeW1ib2xzIG1hcFxyXG4gICAgaWYgKHR5cGUgPT0gJ3Byb3BvcnRpb25hbFN5bWJvbCcgfHwgdHlwZSA9PSAncHMnKSByZXR1cm4gUHJvcG9ydGlvbmFsU3ltYm9sLm1hcChjb25maWcpXHJcbiAgICAvL2JpdmFyaWF0ZSBjaG9yb3BsZXRoXHJcbiAgICBpZiAodHlwZSA9PSAnYml2YXJpYXRlQ2hvcm9wbGV0aCcgfHwgdHlwZSA9PSAnY2hiaScpIHJldHVybiBCaXZhcmlhdGVDaG9yb3BsZXRoLm1hcChjb25maWcpXHJcbiAgICAvL3RyaXZhcmlhdGUgY2hvcm9wbGV0aFxyXG4gICAgaWYgKHR5cGUgPT0gJ3RyaXZhcmlhdGVDaG9yb3BsZXRoJyB8fCB0eXBlID09ICdjaGJpJykgcmV0dXJuIFRyaXZhcmlhdGVDaG9yb3BsZXRoLm1hcChjb25maWcpXHJcbiAgICAvL3N0cmlwZXMgY29tcG9zaXRpb25cclxuICAgIGlmICh0eXBlID09ICdzdHJpcGVDb21wb3NpdGlvbicgfHwgdHlwZSA9PSAnc2NvbXAnKSByZXR1cm4gU3RyaXBlQ29tcG9zaXRpb24ubWFwKGNvbmZpZylcclxuICAgIC8vcHJvcG9ydGlvbmFsIHBpZSBjaGFydHNcclxuICAgIGlmICh0eXBlID09ICdwaWVDaGFydCcgfHwgdHlwZSA9PSAncGllJykgcmV0dXJuIFBpZUNoYXJ0cy5tYXAoY29uZmlnKVxyXG4gICAgLy9zcGFya2xpbmUgbWFwc1xyXG4gICAgaWYgKHR5cGUgPT0gJ3NwYXJrbGluZScgfHwgdHlwZSA9PSAnc3BhcmsnIHx8IHR5cGUgPT0gJ3NwYXJrbGluZXMnKSByZXR1cm4gU3BhcmtsaW5lcy5tYXAoY29uZmlnKVxyXG4gICAgLy9mbG93IG1hcHNcclxuICAgIGlmICh0eXBlID09ICdmbG93JyB8fCB0eXBlID09ICdmbG93bWFwJykgcmV0dXJuIEZsb3dNYXAubWFwKGNvbmZpZylcclxuXHJcbiAgICAvL2FkZCBuZXcgbWFwIHR5cGVzIGhlcmVcclxuICAgIC8vaWYodHlwZSA9PSBcIlhYXCIpIHJldHVybiBtYXBYWC5tYXAoY29uZmlnKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnVW5leHBlY3RlZCBtYXAgdHlwZTogJyArIHR5cGUpXHJcbiAgICByZXR1cm4gbXQuc3RhdE1hcChjb25maWcsIHRydWUsIHR5cGUpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBidWlsZHMgZmlsbCBwYXR0ZXJucyBzdHlsZS5cclxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGhhcyBmb3IgYXJndW1lbnRzIHRoZSBTVkcgZWxlbWVudCB3aGVyZSB0byB1c2UgdGhlIGZpbGwgcGF0dGVybiwgYW5kIHRoZSBudW1iZXIgb2YgY2xhc3Nlcy5cclxuICpcclxuICogQHBhcmFtIHsqfSBvcHRzIFZhcmlvdXMgcGFyYW1ldGVycyBvbiB0aGUgZmlsbCBwYXR0ZXJuLlxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RmlsbFBhdHRlcm5EZWZpbml0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgb3B0cyA9IG9wdHMgfHwge31cclxuICAgIG9wdHMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICdjaXJjbGUnXHJcbiAgICBjb25zdCBwcyA9IG9wdHMucGF0dGVyblNpemUgfHwgNVxyXG4gICAgY29uc3Qgc21pbiA9IG9wdHMubWluU2l6ZSB8fCAxXHJcbiAgICBjb25zdCBzbWF4ID0gb3B0cy5tYXhTaXplIHx8IDUuNVxyXG4gICAgb3B0cy5iY2tDb2xvciA9IG9wdHMuYmNrQ29sb3IgfHwgJ3doaXRlJ1xyXG4gICAgb3B0cy5zeW1iQ29sb3IgPSBvcHRzLnN5bWJDb2xvciB8fCAnYmxhY2snXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN2ZywgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgLy9jbGVhciBwcmV2aW91c1xyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5lbS1maWxsLXBhdHRlcm4nKS5yZW1vdmUoKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2kgPSBzbWluICsgKChzbWF4IC0gc21pbikgKiBpKSAvIChudW1iZXJPZkNsYXNzZXMgLSAxKVxyXG4gICAgICAgICAgICBjb25zdCBwYXR0ID0gc3ZnXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1maWxsLXBhdHRlcm4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3BhdHRlcm5fJyArIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsICcwJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJzAnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgcHMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgcHMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncGF0dGVyblVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcclxuICAgICAgICAgICAgcGF0dC5hcHBlbmQoJ3JlY3QnKS5hdHRyKCd4JywgMCkuYXR0cigneScsIDApLmF0dHIoJ3dpZHRoJywgcHMpLmF0dHIoJ2hlaWdodCcsIHBzKS5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKS5zdHlsZSgnZmlsbCcsIG9wdHMuYmNrQ29sb3IpXHJcbiAgICAgICAgICAgIGlmIChvcHRzLnNoYXBlID09ICdzcXVhcmUnKVxyXG4gICAgICAgICAgICAgICAgcGF0dC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2kpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG9wdHMuc3ltYkNvbG9yKVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwYXR0LmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBwcyAqIDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBwcyAqIDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIHNpICogMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG9wdHMuc3ltYkNvbG9yKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gREVGQVVMVExBQkVMU1xyXG59XHJcblxyXG5pbXBvcnQgeyB2ZXJzaW9uIGFzIHBrZ1ZlcnNpb24gfSBmcm9tICcuLi9wYWNrYWdlLmpzb24nXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gcGtnVmVyc2lvblxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCB7IGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQtcGF0dGVybi1maWxsJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBjYXRlZ29yaWNhbCBtYXBzXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy90aGUgd2lkdGggb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZVdpZHRoID0gMTNcclxuICAgIC8vdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlSGVpZ2h0ID0gMTVcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlUGFkZGluZyA9IDVcclxuICAgIC8vdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGVnZW5kIGxhYmVsXHJcbiAgICBvdXQubGFiZWxGb250U2l6ZSA9IDEyXHJcbiAgICAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbGFiZWxcclxuICAgIG91dC5sYWJlbE9mZnNldCA9IDVcclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhID0gdHJ1ZVxyXG4gICAgLy9ubyBkYXRhIGxhYmVsIHRleHRcclxuICAgIG91dC5ub0RhdGFUZXh0ID0gJ05vIGRhdGEnXHJcbiAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIHRoZSBsZWdlbmQgZWxlbWVudHMgbWFudWFsbHkgYXMgYW4gYXJyYXlcclxuICAgIG91dC5vcmRlciA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgaWYgKG91dC5sZ2cubm9kZSgpICYmIG91dC5tYXAuY2xhc3NpZmllcl8pIHtcclxuICAgICAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgdGl0bGVcclxuICAgICAgICAgICAgaWYgKG91dC50aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2dldCBjYXRlZ29yeSBjb2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBkb21haW4gPSBtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpID8gT2JqZWN0LmtleXMobWFwLmNsYXNzVG9GaWxsU3R5bGUoKSkgOiBtYXAuY2xhc3NpZmllcl8uZG9tYWluKClcclxuICAgICAgICAgICAgY29uc3QgZWNscyA9IG91dC5vcmRlciA/IG91dC5vcmRlciA6IGRvbWFpblxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlY2xzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoZSBjbGFzc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsXyA9IGVjbHNbaV1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IG1hcC5jbGFzc2lmaWVyXyhlY2xfKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbENvbG9yID0gbWFwLmNsYXNzVG9GaWxsU3R5bGVfW2VjbF9dXHJcblxyXG4gICAgICAgICAgICAgICAgLy90aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyA6IDApICsgaSAqIChvdXQuc2hhcGVIZWlnaHQgKyBvdXQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBoaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbGFiZWxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChtYXAuY2xhc3NUb1RleHQoKSA/IG1hcC5jbGFzc1RvVGV4dCgpW2VjbF9dIDogZWNsXylcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgICAgICBpZiAob3V0Lm5vRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArIGVjbHMubGVuZ3RoICogKG91dC5zaGFwZUhlaWdodCArIG91dC5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtYXAubm9EYXRhRmlsbFN0eWxlXylcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIHVuaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgLy8nbm8gZGF0YScgbGFiZWxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQubm9EYXRhVGV4dClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHBhdHRlcm4gZmlsbCBsZWdlbmQgaXRlbXMgQkVMT1cgdGhlIG1haW4gbGVnZW5kXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBjaG9yb3BsZXRoIGxlZ2VuZCBib3hcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gb3V0LmxnZy5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodFxyXG4gICAgICAgICAgICBhcHBlbmRQYXR0ZXJuRmlsbExlZ2VuZChtYXAsIG91dC5sZ2csIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlV2lkdGg6IG91dC5zaGFwZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgc2hhcGVIZWlnaHQ6IG91dC5zaGFwZUhlaWdodCxcclxuICAgICAgICAgICAgICAgIGxhYmVsT2Zmc2V0OiBvdXQubGFiZWxPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBib3hQYWRkaW5nOiBvdXQuYm94UGFkZGluZyxcclxuICAgICAgICAgICAgICAgIG9mZnNldFk6IGxlZ2VuZEhlaWdodCArIG91dC5ib3hQYWRkaW5nICsgNSwgLy8gPDwgdGhpcyBzaGlmdHMgcGF0dGVybiBsZWdlbmQgZG93blxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIG91dC5zZXRCb3hEaW1lbnNpb24oKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHJlZ2lvbnMgdG8gd2hpdGVcclxuICAgICAgICBhbGxSZWdpb25zLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWdpb25zID0gYWxsUmVnaW9ucy5maWx0ZXIoXCJbZWNsPSdcIiArIGVjbCArIFwiJ11cIilcclxuICAgICAgICBzZWxlY3RlZFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHJlZ2lvbnNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCByZWdpb25zIHRvIHRoZWlyIG9yaWdpbmFsIGNvbG9ycyBvbiBtb3VzZW91dFxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKCdbZWNsXScpXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCByZWdpb24ncyBvcmlnaW5hbCBjb2xvciBmcm9tIHRoZSBmaWxsX19fIGF0dHJpYnV0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgbGluZSB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgY2hvcm9wbGV0aC1iaXZhcmlhdGUgbWFwc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vc2l6ZVxyXG4gICAgb3V0LnNxdWFyZVNpemUgPSAxMDBcclxuXHJcbiAgICAvL29yaWVudGF0aW9uXHJcbiAgICBvdXQucm90YXRpb24gPSAwXHJcblxyXG4gICAgLy9sYWJlbHNcclxuICAgIG91dC5sYWJlbDEgPSAnVmFyaWFibGUgMSdcclxuICAgIG91dC5sYWJlbDIgPSAnVmFyaWFibGUgMidcclxuXHJcbiAgICAvL2dldCB0aGUgZm9udCBzaXplIG9mIHRoZSB0ZXh0c1xyXG4gICAgb3V0LmF4aXNUaXRsZUZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlJylcclxuXHJcbiAgICAvL2JyZWFrc1xyXG4gICAgb3V0LmJyZWFrczEgPSB1bmRlZmluZWRcclxuICAgIG91dC5icmVha3MyID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuc2hvd0JyZWFrcyA9IGZhbHNlIC8vIGlmIHNldCB0byB0cnVlIGFuZCBicmVha3MxIGFuZCBicmVha3MyIGFyZSB1bmRlZmluZWQgdGhlbiBicmVha3MgYXJlIGF1dG9tYXRpY2FsbHkgZGVmaW5lZFxyXG4gICAgb3V0LnRpY2tMZW5ndGggPSA1IC8vIGxlbmd0aCBvZiB0aGUgdGlja3NcclxuXHJcbiAgICAvL2F4aXNcclxuICAgIG91dC55QXhpc0xhYmVsc09mZnNldCA9IHsgeDogMCwgeTogMCB9XHJcbiAgICBvdXQueEF4aXNMYWJlbHNPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfVxyXG5cclxuICAgIC8vYXhpcyB0aXRsZXNcclxuICAgIG91dC55QXhpc1RpdGxlT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH1cclxuICAgIG91dC54QXhpc1RpdGxlT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH1cclxuXHJcbiAgICAvL3Nob3cgbm8gZGF0YVxyXG4gICAgb3V0Lm5vRGF0YSA9IHRydWVcclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhU2hhcGVIZWlnaHQgPSAyMFxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlV2lkdGggPSAyNVxyXG5cclxuICAgIC8vbm8gZGF0YSB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubm9EYXRhVGV4dCA9ICdObyBkYXRhJ1xyXG5cclxuICAgIC8vb3ZlcnJpZGUgcGFkZGluZ1xyXG4gICAgb3V0LmJveFBhZGRpbmcgPSBvdXQubGFiZWxGb250U2l6ZVxyXG5cclxuICAgIC8vYWRkIGV4dHJhIGRpc3RhbmNlIGJldHdlZW4gbGVnZW5kIGFuZCBubyBkYXRhIGl0ZW1cclxuICAgIG91dC5ub0RhdGFZT2Zmc2V0ID0gMzBcclxuXHJcbiAgICAvL2Fycm93c1xyXG4gICAgb3V0LmF4aXNBcnJvd3MgPSB0cnVlIC8vIGlmIHNldCB0byB0cnVlLCBhcnJvd3MgYXJlIGRyYXduIGF0IHRoZSBlbmQgb2YgdGhlIGF4ZXNcclxuICAgIG91dC5hcnJvd0hlaWdodCA9IDE1XHJcbiAgICBvdXQuYXJyb3dXaWR0aCA9IDE0XHJcbiAgICBvdXQuYXJyb3dQYWRkaW5nID0gMTAgLy8gcGFkZGluZyBiZXR3ZWVuIGFycm93IGFuZCBheGlzIGxhYmVsXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICAvLyBIb3Jpem9udGFsIHNoaWZ0IHRvIG1vdmUgZXZlcnl0aGluZyByaWdodCAoYWRqdXN0IHRoaXMgdmFsdWUgYXMgbmVlZGVkKVxyXG4gICAgICAgIG91dC5faG9yaXpvbnRhbE9mZnNldCA9IG91dC5heGlzVGl0bGVGb250U2l6ZSArIG91dC5hcnJvd1BhZGRpbmcgLy8gQWRqdXN0IHRoaXMgdmFsdWUgdG8gbW92ZSB0aGUgd2hvbGUgbGVnZW5kIHRvIHRoZSByaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIG91dC5sZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vIERyYXcgdGl0bGVcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5sZ2dcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHhjICsgb3V0Ll9ob3Jpem9udGFsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgIG91dC5feSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKVxyXG5cclxuICAgICAgICAvLyBTcXVhcmUgZ3JvdXAgd2l0aCBob3Jpem9udGFsIG9mZnNldFxyXG4gICAgICAgIGFkZFNxdWFyZXMoKVxyXG5cclxuICAgICAgICAvLyBzZXQgYnJlYWtzIGlmIHVzZXIgaGFzbnQgZGVmaW5lZCB0aGVtIGJ1dCBoYXMgZW5hYmxlZCB0aGVtXHJcbiAgICAgICAgaWYgKCFvdXQuYnJlYWtzMSAmJiAhb3V0LmJyZWFrczIgJiYgb3V0LnNob3dCcmVha3MpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHF1YW50aWxlcyBmb3IgdGhlIGZpcnN0IHZhcmlhYmxlIChYIGF4aXMpIGFuZCB0cnVuY2F0ZSB0byBvbmUgZGVjaW1hbCBwbGFjZVxyXG4gICAgICAgICAgICBvdXQuYnJlYWtzMSA9IG1hcC5jbGFzc2lmaWVyMV8ucXVhbnRpbGVzKCkubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDApKSlcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBxdWFudGlsZXMgZm9yIHRoZSBzZWNvbmQgdmFyaWFibGUgKFkgYXhpcykgYW5kIHRydW5jYXRlIHRvIG9uZSBkZWNpbWFsIHBsYWNlXHJcbiAgICAgICAgICAgIG91dC5icmVha3MyID0gbWFwLmNsYXNzaWZpZXIyXy5xdWFudGlsZXMoKS5tYXAoKHZhbHVlKSA9PiBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQoMCkpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBicmVha3MgbGFiZWxzIDEgKFggYXhpcylcclxuICAgICAgICBhZGRCcmVha0xhYmVscygpXHJcblxyXG4gICAgICAgIG91dC5feEF4aXNBcnJvd1kgPSAwXHJcbiAgICAgICAgb3V0Ll95QXhpc0Fycm93WCA9IDBcclxuICAgICAgICBpZiAob3V0LmF4aXNBcnJvd3MpIHtcclxuICAgICAgICAgICAgYWRkQXhpc0Fycm93cygpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGRBeGlzVGl0bGVzKClcclxuXHJcbiAgICAgICAgLy8gQXJyb3cgZGVmc1xyXG4gICAgICAgIG91dC5sZ2dcclxuICAgICAgICAgICAgLmFwcGVuZCgnZGVmcycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ21hcmtlcicpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYDAgMCAke291dC5hcnJvd1dpZHRofSAke291dC5hcnJvd0hlaWdodH1gKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnYXJyb3doZWFkJylcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlgnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigncmVmWScsIDUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIG91dC5hcnJvd1dpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0Jywgb3V0LmFycm93SGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTSAwIDAgTCA1IDUgTCAwIDEwJylcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlci11bml0cycsICdzdHJva2VXaWR0aCcpXHJcblxyXG4gICAgICAgIC8vICdObyBkYXRhJyBsZWdlbmQgYm94XHJcbiAgICAgICAgaWYgKG91dC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgYWRkTm9EYXRhRWxlbWVudCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTm9EYXRhRWxlbWVudCgpIHtcclxuICAgICAgICBjb25zdCBub0RhdGFZT2Zmc2V0ID1cclxuICAgICAgICAgICAgb3V0LnJvdGF0aW9uID09PSAwID8gb3V0Lm5vRGF0YVlPZmZzZXQgKyBvdXQuc3F1YXJlU2l6ZSAvIG91dC5tYXAubnVtYmVyT2ZDbGFzc2VzXyArIG91dC5hcnJvd0hlaWdodCAvIDIgOiBvdXQubm9EYXRhWU9mZnNldFxyXG5cclxuICAgICAgICBsZXQgbm9EYXRhWSA9XHJcbiAgICAgICAgICAgIG91dC5yb3RhdGlvbiA9PT0gMCA/IG91dC5feSArIG91dC5zcXVhcmVTaXplICsgbm9EYXRhWU9mZnNldCA6IG91dC5feSArIDEuNDE0MiAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmcgKiAyICsgbm9EYXRhWU9mZnNldFxyXG5cclxuICAgICAgICBvdXQubGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLW5vZGF0YScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQubm9EYXRhU2hhcGVXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgbm9EYXRhWSArIChvdXQucm90YXRpb24gPT0gMCA/IDAgOiAtMTApKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQubm9EYXRhU2hhcGVXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5ub0RhdGFTaGFwZUhlaWdodClcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgb3V0Lm1hcC5ub0RhdGFGaWxsU3R5bGUoKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25zID0gb3V0Lm1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcgPyBzZWxlY3RBbGwoJyNlbS1udXRzcmcnKSA6IHNlbGVjdCgnI2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSByZWdpb25zLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgJ3JlZCcpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuUmcgPSBvdXQubWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJyA/IHNlbGVjdEFsbCgnI2VtLW51dHNyZycpIDogc2VsZWN0KCcjZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IG5SZy5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIilcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIG91dC5tYXAubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgb3V0LmxnZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1ub2RhdGEtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0Lm5vRGF0YVNoYXBlV2lkdGggKyAob3V0Lm5vRGF0YVNoYXBlV2lkdGggLyAyICsgNSkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgbm9EYXRhWSArIG91dC5ub0RhdGFTaGFwZUhlaWdodCAqIDAuNSArIDEgKyAob3V0LnJvdGF0aW9uID09IDAgPyAwIDogLTEwKSlcclxuICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkU3F1YXJlcygpIHtcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDbGFzc2VzID0gb3V0Lm1hcC5udW1iZXJPZkNsYXNzZXMoKVxyXG4gICAgICAgIGNvbnN0IHN6ID0gb3V0LnNxdWFyZVNpemUgLyBudW1iZXJPZkNsYXNzZXNcclxuICAgICAgICBjb25zdCB4YyA9IG91dC5yb3RhdGlvbiA9PT0gMCA/IDAgOiAwLjcwNzEgKiBvdXQuc3F1YXJlU2l6ZSArIG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFggPSAwXHJcblxyXG4gICAgICAgIGNvbnN0IHNxdWFyZSA9IGxnZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JpdmFyaWF0ZS1zcXVhcmVzLWNoYXJ0JylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgICAgICAgIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZyArIG91dC5faG9yaXpvbnRhbE9mZnNldH0sJHt4YyArIG91dC5feX0pIHJvdGF0ZSgke291dC5yb3RhdGlvbn0pIHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nfSwwKWBcclxuICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAvLyBEcmF3IHJlY3RhbmdsZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2xhc3NlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtYmVyT2ZDbGFzc2VzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBudW1iZXJPZkNsYXNzZXMgLSBpIC0gMVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsMiA9IG51bWJlck9mQ2xhc3NlcyAtIGogLSAxXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsID0gb3V0Lm1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoZWNsMSwgZWNsMilcclxuXHJcbiAgICAgICAgICAgICAgICBzcXVhcmVcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXNxdWFyZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBpbml0aWFsWCArIChudW1iZXJPZkNsYXNzZXMgLSAxIC0gaSkgKiBzeilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGogKiBzeilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzeilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc3opXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZmlsbClcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wxLCBlY2wyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbDEsIGVjbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnJhaXNlKCkgLy8gcmFpc2UgbGVnZW5kIHNxdWFyZSB0byBhdm9pZCBzdHJva2UgaXNzdWVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgZWNsMSwgZWNsMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZyYW1lXHJcbiAgICAgICAgc3F1YXJlXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWZyYW1lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBpbml0aWFsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc3F1YXJlU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zcXVhcmVTaXplKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC43KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEJyZWFrTGFiZWxzKCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0gb3V0LnJvdGF0aW9uID09PSAwID8gMCA6IDAuNzA3MSAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBjb25zdCBpbml0aWFsWCA9IDBcclxuICAgICAgICBjb25zdCBudW1iZXJPZkNsYXNzZXMgPSBvdXQubWFwLm51bWJlck9mQ2xhc3NlcygpXHJcbiAgICAgICAgY29uc3Qgc3ogPSBvdXQuc3F1YXJlU2l6ZSAvIG51bWJlck9mQ2xhc3Nlc1xyXG5cclxuICAgICAgICAvLyBncm91cCB3aXRoIGhvcml6b250YWwgb2Zmc2V0XHJcbiAgICAgICAgY29uc3QgYnJlYWtMYWJlbHMgPSBvdXQubGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYml2YXJpYXRlLWJyZWFrLWxhYmVscycpXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICAgICAgICBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmcgKyBvdXQuX2hvcml6b250YWxPZmZzZXR9LCR7eGMgKyBvdXQuX3l9KSByb3RhdGUoJHtvdXQucm90YXRpb259KSB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZ30sMClgXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBpZiAob3V0LmJyZWFrczEpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuYnJlYWtzMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGluaXRpYWxYICsgc3ogKiAoaSArIDEpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gb3V0LnNxdWFyZVNpemUgKyBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrTGFiZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHggKyBvdXQueEF4aXNMYWJlbHNPZmZzZXQueCApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnhBeGlzTGFiZWxzT2Zmc2V0LnkgKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KG91dC5icmVha3MxW2ldKVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrTGFiZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS10aWNrJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgb3V0LnNxdWFyZVNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgb3V0LnNxdWFyZVNpemUgKyBvdXQudGlja0xlbmd0aClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBicmVha3MgbGFiZWxzIDIgKFkgYXhpcylcclxuICAgICAgICBpZiAob3V0LmJyZWFrczIpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuYnJlYWtzMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGluaXRpYWxYXHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gc3ogKiAoaSArIDIpIC0gc3pcclxuXHJcbiAgICAgICAgICAgICAgICBicmVha0xhYmVsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtdGljay1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4ICsgb3V0LnlBeGlzTGFiZWxzT2Zmc2V0LngpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5IC0gb3V0LnlBeGlzTGFiZWxzT2Zmc2V0LnkgLSAob3V0LnRpY2tMZW5ndGggKyAyKSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChbLi4ub3V0LmJyZWFrczJdLnJldmVyc2UoKVtpXSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHJvdGF0ZSgtOTAsICR7eH0sICR7eX0pYClcclxuXHJcbiAgICAgICAgICAgICAgICBicmVha0xhYmVsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtdGljaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4IC0gb3V0LnRpY2tMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEF4aXNUaXRsZXMoKSB7XHJcbiAgICAgICAgY29uc3QgeGMgPSBvdXQucm90YXRpb24gPT09IDAgPyAwIDogMC43MDcxICogb3V0LnNxdWFyZVNpemUgKyBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxYID0gMFxyXG5cclxuICAgICAgICBjb25zdCBheGlzVGl0bGVzID0gb3V0LmxnZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JpdmFyaWF0ZS1heGlzLXRpdGxlcycpXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICAgICAgICBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmcgKyBvdXQuX2hvcml6b250YWxPZmZzZXR9LCR7eGMgKyBvdXQuX3l9KSByb3RhdGUoJHtvdXQucm90YXRpb259KSB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZ30sMClgXHJcbiAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgLy8gWCBheGlzIHRpdGxlXHJcbiAgICAgICAgbGV0IHhBeGlzVGl0bGVZID0gb3V0LnNxdWFyZVNpemUgKyBvdXQueEF4aXNMYWJlbHNPZmZzZXQueSArIChvdXQuYXhpc0Fycm93cyA/IG91dC5hcnJvd1BhZGRpbmcgKyBvdXQuYXJyb3dIZWlnaHQgOiA3KVxyXG4gICAgICAgIGxldCB4QXhpc1RpdGxlWCA9IGluaXRpYWxYXHJcbiAgICAgICAgaWYgKG91dC5zaG93QnJlYWtzIHx8IChvdXQuYnJlYWtzMSAmJiBvdXQuYnJlYWtzMikpIHhBeGlzVGl0bGVZICs9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1iaXZhcmlhdGUtdGljay1sYWJlbCcpIC8vIG1vdmUgb3ZlciBmb3IgdGljayBsYWJlbHNcclxuICAgICAgICBpZiAob3V0LnhBeGlzVGl0bGVPZmZzZXQpIHhBeGlzVGl0bGVZICs9IG91dC54QXhpc1RpdGxlT2Zmc2V0LnlcclxuICAgICAgICBpZiAob3V0LnhBeGlzVGl0bGVPZmZzZXQpIHhBeGlzVGl0bGVYICs9IG91dC54QXhpc1RpdGxlT2Zmc2V0LnhcclxuICAgICAgICBheGlzVGl0bGVzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUgZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUteCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgeEF4aXNUaXRsZVgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeEF4aXNUaXRsZVkpXHJcbiAgICAgICAgICAgIC50ZXh0KG91dC5sYWJlbDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcclxuICAgICAgICAgICAgLmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsICdoYW5naW5nJylcclxuXHJcbiAgICAgICAgLy8gWSBheGlzIHRpdGxlXHJcbiAgICAgICAgbGV0IHlBeGlzVGl0bGVZID0gKG91dC5heGlzQXJyb3dzID8gb3V0Ll95QXhpc0Fycm93WCAtIG91dC5hcnJvd1BhZGRpbmcgOiA3KSArIChvdXQucm90YXRpb24gPT0gLTQ1ID8gLTQgOiAtMTApIC8vIGFkanVzdCBmb3Igcm90YXRpb25cclxuICAgICAgICBpZiAob3V0LnNob3dCcmVha3MgfHwgKG91dC5icmVha3MxICYmIG91dC5icmVha3MyKSkgeEF4aXNUaXRsZVkgKz0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJykgLy8gbW92ZSBvdmVyIGZvciB0aWNrIGxhYmVsc1xyXG4gICAgICAgIGxldCB5QXhpc1RpdGxlWCA9IC1vdXQuc3F1YXJlU2l6ZVxyXG4gICAgICAgIC8vbWFudWFsIG9mZnNldHNcclxuICAgICAgICBpZiAob3V0LnlBeGlzVGl0bGVPZmZzZXQpIHlBeGlzVGl0bGVZICs9IG91dC55QXhpc1RpdGxlT2Zmc2V0LnlcclxuICAgICAgICBpZiAob3V0LnlBeGlzVGl0bGVPZmZzZXQpIHlBeGlzVGl0bGVYICs9IG91dC55QXhpc1RpdGxlT2Zmc2V0LnhcclxuICAgICAgICBheGlzVGl0bGVzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUgZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUteScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgeUF4aXNUaXRsZVgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeUF4aXNUaXRsZVkpXHJcbiAgICAgICAgICAgIC50ZXh0KG91dC5sYWJlbDIpXHJcbiAgICAgICAgICAgIC5zdHlsZSgndHJhbnNmb3JtJywgb3V0LnJvdGF0aW9uIDwgMCA/IGB0cmFuc2xhdGUoJHtvdXQuYXhpc0Fycm93cyA/IC01MSA6IC0xNX1weCwgOTVweCkgcm90YXRlKDkwZGVnKWAgOiAncm90YXRlKC05MGRlZyknKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEF4aXNBcnJvd3MoKSB7XHJcbiAgICAgICAgY29uc3QgeGMgPSBvdXQucm90YXRpb24gPT09IDAgPyAwIDogMC43MDcxICogb3V0LnNxdWFyZVNpemUgKyBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxYID0gMFxyXG5cclxuICAgICAgICAvLyBncm91cCB3aXRoIGhvcml6b250YWwgb2Zmc2V0XHJcbiAgICAgICAgY29uc3QgYXhpc0Fycm93cyA9IG91dC5sZ2dcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdiaXZhcmlhdGUtYXhpcy1hcnJvd3MnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICAgICAgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nICsgb3V0Ll9ob3Jpem9udGFsT2Zmc2V0fSwke3hjICsgb3V0Ll95fSkgcm90YXRlKCR7b3V0LnJvdGF0aW9ufSkgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmd9LDApYFxyXG4gICAgICAgICAgICApXHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBYIGF4aXMgYXJyb3dcclxuICAgICAgICBvdXQuX3hBeGlzQXJyb3dZID0gb3V0LnNxdWFyZVNpemUgKyBvdXQudGlja0xlbmd0aCArIG91dC5hcnJvd1BhZGRpbmdcclxuICAgICAgICBpZiAob3V0LnNob3dCcmVha3MgfHwgKG91dC5icmVha3MxICYmIG91dC5icmVha3MyKSkgb3V0Ll94QXhpc0Fycm93WSArPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKSAvIDEuNSAvLyBtb3ZlIG92ZXIgZm9yIHRpY2sgbGFiZWxzXHJcblxyXG4gICAgICAgIGF4aXNBcnJvd3NcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtYXhpcy1hcnJvdycpXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ2QnLFxyXG4gICAgICAgICAgICAgICAgbGluZSgpKFtcclxuICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbFgsIG91dC5feEF4aXNBcnJvd1ldLFxyXG4gICAgICAgICAgICAgICAgICAgIFtpbml0aWFsWCArIG91dC5zcXVhcmVTaXplLCBvdXQuX3hBeGlzQXJyb3dZXSxcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXItZW5kJywgJ3VybCgjYXJyb3doZWFkKScpXHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBZIGF4aXMgYXJyb3dcclxuICAgICAgICBvdXQuX3lBeGlzQXJyb3dYID0gLW91dC50aWNrTGVuZ3RoIC0gb3V0LmFycm93UGFkZGluZ1xyXG4gICAgICAgIGlmIChvdXQuc2hvd0JyZWFrcyB8fCAob3V0LmJyZWFrczEgJiYgb3V0LmJyZWFrczIpKSBvdXQuX3lBeGlzQXJyb3dYIC09IG91dC5sYWJlbEZvbnRTaXplIC8gMiAvLyBtb3ZlIG92ZXIgZm9yIHRpY2sgbGFiZWxzXHJcblxyXG4gICAgICAgIGF4aXNBcnJvd3NcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtYXhpcy1hcnJvdycpXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ2QnLFxyXG4gICAgICAgICAgICAgICAgbGluZSgpKFtcclxuICAgICAgICAgICAgICAgICAgICBbb3V0Ll95QXhpc0Fycm93WCwgb3V0LnNxdWFyZVNpemVdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtvdXQuX3lBeGlzQXJyb3dYLCAwXSxcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXItZW5kJywgJ3VybCgjYXJyb3doZWFkKScpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHJlZ2lvbnMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsMSwgZWNsMikge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoYFtlY2wxXWApXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVnaW9ucyB0byB3aGl0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBhbGxSZWdpb25zLmZpbHRlcihgW2VjbDE9JyR7ZWNsMX0nXWApLmZpbHRlcihgW2VjbDI9JyR7ZWNsMn0nXWApXHJcbiAgICAgICAgc2VsZWN0ZWRSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgcmVnaW9ucyB0byB0aGVpciBvcmlnaW5hbCBjb2xvcnMgb24gbW91c2VvdXRcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKGBbZWNsMV1gKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldEZvbnRTaXplRnJvbUNsYXNzLCBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXggfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBjaG9yb3BsZXRoLXRyaXZhcmlhdGUgbWFwc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy8gRGVmYXVsdCBzZXR0aW5nc1xyXG4gICAgb3V0LndpZHRoID0gMjMwXHJcbiAgICBvdXQuaGVpZ2h0ID0gMjMwXHJcblxyXG4gICAgb3V0LmxhYmVsMSA9ICdWYXJpYWJsZSAxJ1xyXG4gICAgb3V0LmxhYmVsMiA9ICdWYXJpYWJsZSAyJ1xyXG4gICAgb3V0LmxhYmVsMyA9ICdWYXJpYWJsZSAzJyAvLyBBZGQgYSBsYWJlbCBmb3IgdGhlIHRoaXJkIHZhcmlhYmxlXHJcbiAgICBvdXQuYXhpc1RpdGxlRm9udFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUnKVxyXG4gICAgb3V0LnNob3dCcmVha3MgPSBmYWxzZVxyXG4gICAgb3V0Lm5vRGF0YSA9IHRydWVcclxuICAgIG91dC5ub0RhdGFTaGFwZUhlaWdodCA9IDIwXHJcbiAgICBvdXQubm9EYXRhU2hhcGVXaWR0aCA9IDI1XHJcbiAgICBvdXQubm9EYXRhVGV4dCA9ICdObyBkYXRhJ1xyXG4gICAgb3V0LmJveFBhZGRpbmcgPSA2MCAvLyBkZXBlbmRzIG9uIHZhcmlhYmxlIDEgbGFiZWwgbGVuZ3RoIHJlYWxseVxyXG4gICAgb3V0Lm5vRGF0YVlPZmZzZXQgPSAyMFxyXG4gICAgb3V0LmFycm93SGVpZ2h0ID0gMTVcclxuICAgIG91dC5hcnJvd1dpZHRoID0gMTRcclxuICAgIG91dC5hcnJvd1BhZGRpbmcgPSAxMFxyXG5cclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlIHRoZSB1cGRhdGUgbWV0aG9kIHRvIGhhbmRsZSB0cml2YXJpYXRlIGxlZ2VuZHNcclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDbGFzc2VzID0gb3V0Lm1hcC5udW1iZXJPZkNsYXNzZXMoKVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvLyBEcmF3IGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgcGFkZGluZyB0byB0aGUgbWFpbiA8Zz4gZ3JvdXBcclxuICAgICAgICBjb25zdCBwYWRkZWRHcm91cCA9IGxnZy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmd9LCAke291dC5ib3hQYWRkaW5nfSlgKVxyXG5cclxuICAgICAgICAvLyBEcmF3IHRpdGxlXHJcbiAgICAgICAgaWYgKG91dC50aXRsZSkge1xyXG4gICAgICAgICAgICBwYWRkZWRHcm91cFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMCkgLy8gU3RhcnQgYXQgMCB3aXRoaW4gdGhlIHBhZGRlZCBncm91cFxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQudGl0bGVGb250U2l6ZSkgLy8gVmVydGljYWwgcG9zaXRpb25pbmdcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC50aXRsZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgdGhlIHRyaXZhcmlhdGUgVmVubiBkaWFncmFtXHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gW291dC5sYWJlbDEsIG91dC5sYWJlbDIsIG91dC5sYWJlbDNdXHJcbiAgICAgICAgY29uc3QgY29sb3JzID0gW291dC5tYXAuY29sb3IxXywgb3V0Lm1hcC5jb2xvcjJfLCBvdXQubWFwLmNvbG9yM19dXHJcblxyXG4gICAgICAgIGRyYXdUcml2YXJpYXRlVmVubkRpYWdyYW0ocGFkZGVkR3JvdXAsIGNvbG9ycywgbGFiZWxzKVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgdHJpdmFyaWF0ZSAoVmVubiBEaWFncmFtKSBvciBiaXZhcmlhdGUgKGdyaWQpIGxlZ2VuZFxyXG4gICAgICAgIC8vIGlmIChudW1iZXJPZkNsYXNzZXMgPT09IDcpIHtcclxuICAgICAgICAvLyAgICAgZHJhd1RyaXZhcmlhdGVWZW5uRGlhZ3JhbShsZ2csIG91dClcclxuICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICBkcmF3VHJpdmFyaWF0ZVRlcm5hcnlQbG90KGxnZywgb3V0LCBudW1iZXJPZkNsYXNzZXMpXHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd1RyaXZhcmlhdGVWZW5uRGlhZ3JhbShjb250YWluZXIsIGNvbG9ycywgbGFiZWxzKSB7XHJcbiAgICAvL3NwZWNzIGZvciBDaXJjbGUgMVxyXG4gICAgY29uc3QgeENlbnRlcjEgPSA1MFxyXG4gICAgY29uc3QgeUNlbnRlcjEgPSA1MFxyXG4gICAgY29uc3QgY2lyY2xlUmFkID0gMzBcclxuXHJcbiAgICAvL2RyYXcgQ2lyY2xlIDFcclxuICAgIC8vIGNvbnN0IGNpcmNsZTEgPSBjb250YWluZXJcclxuICAgIC8vICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgLy8gICAgIC5hdHRyKCdyJywgY2lyY2xlUmFkKVxyXG4gICAgLy8gICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4Q2VudGVyMSArICcsJyArIHlDZW50ZXIxICsgJyknKVxyXG5cclxuICAgIC8vYWRkJ2wgc3BlY3MgZm9yIENpcmNsZSAyXHJcbiAgICBjb25zdCBvZmZzZXRGYWN0b3IgPSAxLjJcclxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldEZhY3RvciAqIGNpcmNsZVJhZFxyXG4gICAgY29uc3QgeENlbnRlcjIgPSB4Q2VudGVyMSArIG9mZnNldFxyXG4gICAgY29uc3QgeUNlbnRlcjIgPSB5Q2VudGVyMSAvL2NyZWF0aW5nIG5ldyB2YXIgZm9yIGNsYXJpdHlcclxuXHJcbiAgICAvL2RyYXcgQ2lyY2xlIDJcclxuICAgIC8vIGNvbnN0IGNpcmNsZTIgPSBjb250YWluZXJcclxuICAgIC8vICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgLy8gICAgIC5hdHRyKCdyJywgY2lyY2xlUmFkKVxyXG4gICAgLy8gICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4Q2VudGVyMiArICcsJyArIHlDZW50ZXIyICsgJyknKVxyXG5cclxuICAgIC8vYWRkJ2wgc3BlY3MgZm9yIENpcmNsZSAzXHJcbiAgICBjb25zdCB4Q2VudGVyMyA9IHhDZW50ZXIxICsgb2Zmc2V0IC8gMlxyXG4gICAgY29uc3QgeUNlbnRlcjMgPSB5Q2VudGVyMSArIChNYXRoLnNxcnQoMykgKiBvZmZzZXQpIC8gMlxyXG5cclxuICAgIC8vZHJhdyBDaXJjbGUgM1xyXG4gICAgLy8gY29uc3QgY2lyY2xlMyA9IGNvbnRhaW5lclxyXG4gICAgLy8gICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAvLyAgICAgLmF0dHIoJ3InLCBjaXJjbGVSYWQpXHJcbiAgICAvLyAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHhDZW50ZXIzICsgJywnICsgeUNlbnRlcjMgKyAnKScpXHJcblxyXG4gICAgLy9jb21wdXRlIGZpcnN0IHBvaW50cyBvZiBpbnRlcnNlY3Rpb25cclxuICAgIGNvbnN0IHRyaUhlaWdodCA9IE1hdGguc3FydChjaXJjbGVSYWQgKiogMiAtIChvZmZzZXQgLyAyKSAqKiAyKVxyXG4gICAgLy9vdXRlciBpbnRlcnNlY3Rpb24gb2YgQ2lyY2xlcyAxIGFuZCAyXHJcbiAgICBjb25zdCB4SXNlY3QxID0geENlbnRlcjNcclxuICAgIGNvbnN0IHlJc2VjdDEgPSB5Q2VudGVyMSAtIHRyaUhlaWdodFxyXG4gICAgLy9pbm5lciBpbnRlcnNlY3Rpb24gb2YgQ2lyY2xlcyAxIGFuZCAyXHJcbiAgICBjb25zdCB4SXNlY3Q0ID0geENlbnRlcjNcclxuICAgIGNvbnN0IHlJc2VjdDQgPSB5Q2VudGVyMSArIHRyaUhlaWdodFxyXG5cclxuICAgIC8vdHJlYXQgXCJ0cmlIZWlnaHRcIiBhcyB0aGUgaHlwb3RlbmV1c2Ugb2YgYSAzMC42MC45MCB0cmlhbmdsZS5cclxuICAgIC8vdGhpcyB0ZWxscyB1cyB0aGUgc2hpZnQgZnJvbSB0aGUgbWlkcG9pbnQgb2YgYSBsZWcgb2YgdGhlIHRyaWFuZ2xlXHJcbiAgICAvL3RvIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cclxuICAgIGNvbnN0IHhEZWx0YSA9ICh0cmlIZWlnaHQgKiBNYXRoLnNxcnQoMykpIC8gMlxyXG4gICAgY29uc3QgeURlbHRhID0gdHJpSGVpZ2h0IC8gMlxyXG5cclxuICAgIGNvbnN0IHhNaWRwb2ludEMxQzMgPSAoeENlbnRlcjEgKyB4Q2VudGVyMykgLyAyXHJcbiAgICBjb25zdCB4TWlkcG9pbnRDMkMzID0gKHhDZW50ZXIyICsgeENlbnRlcjMpIC8gMlxyXG4gICAgY29uc3QgeU1pZHBvaW50Qm90aCA9ICh5Q2VudGVyMSArIHlDZW50ZXIzKSAvIDJcclxuXHJcbiAgICAvL2ZpbmQgdGhlIHJlc3Qgb2YgdGhlIHBvaW50cyBvZiBpbnRlcnNlY3Rpb25cclxuICAgIGNvbnN0IHhJc2VjdDIgPSB4TWlkcG9pbnRDMUMzIC0geERlbHRhXHJcbiAgICBjb25zdCB5SXNlY3QyID0geU1pZHBvaW50Qm90aCArIHlEZWx0YVxyXG4gICAgY29uc3QgeElzZWN0MyA9IHhNaWRwb2ludEMyQzMgKyB4RGVsdGFcclxuICAgIGNvbnN0IHlJc2VjdDMgPSB5TWlkcG9pbnRCb3RoICsgeURlbHRhXHJcblxyXG4gICAgY29uc3QgeElzZWN0NSA9IHhNaWRwb2ludEMxQzMgKyB4RGVsdGFcclxuICAgIGNvbnN0IHlJc2VjdDUgPSB5TWlkcG9pbnRCb3RoIC0geURlbHRhXHJcbiAgICBjb25zdCB4SXNlY3Q2ID0geE1pZHBvaW50QzJDMyAtIHhEZWx0YVxyXG4gICAgY29uc3QgeUlzZWN0NiA9IHlNaWRwb2ludEJvdGggLSB5RGVsdGFcclxuXHJcbiAgICBjb25zdCB4UG9pbnRzID0gW3hJc2VjdDEsIHhJc2VjdDIsIHhJc2VjdDMsIHhJc2VjdDQsIHhJc2VjdDUsIHhJc2VjdDZdXHJcbiAgICBjb25zdCB5UG9pbnRzID0gW3lJc2VjdDEsIHlJc2VjdDIsIHlJc2VjdDMsIHlJc2VjdDQsIHlJc2VjdDUsIHlJc2VjdDZdXHJcblxyXG4gICAgY29uc3QgbWFrZUlyb25TaGFwZXMgPSAoW3gxLCB4MiwgeDMsIHkxLCB5MiwgeTNdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGBNICR7eDF9ICR7eTF9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDEgJHt4Mn0gJHt5Mn1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMCAke3gzfSAke3kzfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAxICR7eDF9ICR7eTF9YFxyXG4gICAgICAgIHJldHVybiBwYXRoXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWFrZVN1blNoYXBlcyA9IChbeDEsIHgyLCB4MywgeTEsIHkyLCB5M10pID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gYE0gJHt4MX0gJHt5MX1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMCAke3gyfSAke3kyfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAwICR7eDN9ICR7eTN9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAxIDEgJHt4MX0gJHt5MX1gXHJcbiAgICAgICAgcmV0dXJuIHBhdGhcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtYWtlUm91bmRlZFRyaSA9IChbeDEsIHgyLCB4MywgeTEsIHkyLCB5M10pID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gYE0gJHt4MX0gJHt5MX1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMSAke3gyfSAke3kyfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAxICR7eDN9ICR7eTN9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDEgJHt4MX0gJHt5MX1gXHJcbiAgICAgICAgcmV0dXJuIHBhdGhcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpcm9uUG9pbnRzID0gW1xyXG4gICAgICAgIFsxLCA1LCA2XSxcclxuICAgICAgICBbMywgNCwgNV0sXHJcbiAgICAgICAgWzIsIDYsIDRdLFxyXG4gICAgXVxyXG4gICAgY29uc3Qgc3VuUG9pbnRzID0gW1xyXG4gICAgICAgIFszLCA1LCAxXSxcclxuICAgICAgICBbMiwgNCwgM10sXHJcbiAgICAgICAgWzEsIDYsIDJdLFxyXG4gICAgXVxyXG4gICAgY29uc3Qgcm91bmRlZFRyaVBvaW50cyA9IFtbNSwgNCwgNl1dXHJcblxyXG4gICAgLy8gbWFpbiBjaXJjbGVzIChyYXcgY29sb3JzKVxyXG4gICAgc3VuUG9pbnRzLmZvckVhY2goKHBvaW50cywgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBwdEN5Y2xlID0gcG9pbnRzLm1hcCgoaSkgPT4geFBvaW50c1tpIC0gMV0pLmNvbmNhdChwb2ludHMubWFwKChpKSA9PiB5UG9pbnRzW2kgLSAxXSkpXHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBtYWtlU3VuU2hhcGVzKHB0Q3ljbGUpXHJcblxyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgc2hhcGUpLmF0dHIoJ2NsYXNzJywgJ3NlZ21lbnQnKS5hdHRyKCdmaWxsJywgY29sb3JzW2luZGV4XSkuYXR0cignb3BhY2l0eScsIDEpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIGZpcnN0IGludGVyc2VjdHMgKGNvbWJpbmF0aW9uIG9mIDIgY29sb3JzKVxyXG4gICAgaXJvblBvaW50cy5mb3JFYWNoKChwb2ludHMsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHRDeWNsZSA9IHBvaW50cy5tYXAoKGkpID0+IHhQb2ludHNbaSAtIDFdKS5jb25jYXQocG9pbnRzLm1hcCgoaSkgPT4geVBvaW50c1tpIC0gMV0pKVxyXG4gICAgICAgIGNvbnN0IHNoYXBlID0gbWFrZUlyb25TaGFwZXMocHRDeWNsZSlcclxuXHJcbiAgICAgICAgbGV0IGNvbG9yXHJcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcclxuICAgICAgICAgICAgY29sb3IgPSBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yc1syXSwgY29sb3JzWzBdXSkgLy8gcGluayArIGN5YW5cclxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09IDEpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yc1sxXSwgY29sb3JzWzBdXSkgLy8gY3lhbiArIHllbGxvd1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT0gMikge1xyXG4gICAgICAgICAgICBjb2xvciA9IG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3JzWzFdLCBjb2xvcnNbMl1dKSAvLyBwaW5rICsgeWVsbG93XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250YWluZXIuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHNoYXBlKS5hdHRyKCdjbGFzcycsICdzZWdtZW50JykuYXR0cignZmlsbCcsIGNvbG9yKS5hdHRyKCdvcGFjaXR5JywgMSlcclxuICAgIH0pXHJcblxyXG4gICAgLy8gbnVjbGV1cyAoY29tYmluYXRpb24gb2YgYWxsIDMgY29sb3JzKVxyXG4gICAgcm91bmRlZFRyaVBvaW50cy5mb3JFYWNoKChwb2ludHMsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHRDeWNsZSA9IHBvaW50cy5tYXAoKGkpID0+IHhQb2ludHNbaSAtIDFdKS5jb25jYXQocG9pbnRzLm1hcCgoaSkgPT4geVBvaW50c1tpIC0gMV0pKVxyXG4gICAgICAgIGNvbnN0IHNoYXBlID0gbWFrZVJvdW5kZWRUcmkocHRDeWNsZSlcclxuICAgICAgICBjb25zdCBjb2xvciA9IG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChjb2xvcnMpXHJcblxyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgc2hhcGUpLmF0dHIoJ2NsYXNzJywgJ3NlZ21lbnQnKS5hdHRyKCdmaWxsJywgY29sb3IpLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgfSlcclxuXHJcbiAgICBjb250YWluZXJcclxuICAgICAgICAuc2VsZWN0QWxsKCdwYXRoLnNlZ21lbnQnKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmF0dHIoJ29wYWNpdHknLCAwLjgpLmR1cmF0aW9uKDUwMClcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cignb3BhY2l0eScsIDEpLmR1cmF0aW9uKDUwMClcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vIGxhYmVsIGludGVyc2VjdHNcclxuICAgIGNvbnN0IHlPZmZzZXQgPSBjb250YWluZXJcclxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAudGV4dChsYWJlbHNbMF0pXHJcbiAgICAgICAgLmF0dHIoJ3gnLCB4Q2VudGVyMSAtIGNpcmNsZVJhZCAtIDMpXHJcbiAgICAgICAgLmF0dHIoJ3knLCB4Q2VudGVyMSlcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAndmVubi1sYWJlbCcpXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICBjb250YWluZXJcclxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAudGV4dChsYWJlbHNbMV0pXHJcbiAgICAgICAgLmF0dHIoJ3gnLCB4Q2VudGVyMiArIGNpcmNsZVJhZCArIDMpXHJcbiAgICAgICAgLmF0dHIoJ3knLCB5Q2VudGVyMilcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAndmVubi1sYWJlbCcpXHJcbiAgICBjb250YWluZXJcclxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAudGV4dChsYWJlbHNbMl0pXHJcbiAgICAgICAgLmF0dHIoJ3gnLCB4Q2VudGVyMylcclxuICAgICAgICAuYXR0cigneScsIHlDZW50ZXIzICsgY2lyY2xlUmFkICsgMTUpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Zlbm4tbGFiZWwnKVxyXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG59XHJcblxyXG4vKipcclxuICogRHJhd3MgYSB0cml2YXJpYXRlIGxlZ2VuZCBhcyBhIFZlbm4gRGlhZ3JhbVxyXG4gKi9cclxuZnVuY3Rpb24gZHJhd1RyaXZhcmlhdGVWZW5uRGlhZ3JhbTIoc3ZnLCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBsYWJlbHMsIGNvbG9ycykge1xyXG4gICAgY29uc3QgcmFkaXVzID0gY29udGFpbmVyV2lkdGggLyA1IC8vIFJhZGl1cyBvZiBlYWNoIGNpcmNsZVxyXG4gICAgY29uc3QgY2VudGVyWCA9IGNvbnRhaW5lcldpZHRoIC8gMlxyXG4gICAgY29uc3QgY2VudGVyWSA9IGNvbnRhaW5lckhlaWdodCAvIDJcclxuICAgIGNvbnN0IG9mZnNldCA9IHJhZGl1cyAvIDEuNVxyXG5cclxuICAgIC8vIERlZmluZSBjaXJjbGUgcG9zaXRpb25zXHJcbiAgICBjb25zdCBjaXJjbGVzID0gW1xyXG4gICAgICAgIHsgaWQ6ICdjaXJjbGUxJywgY3g6IGNlbnRlclggLSBvZmZzZXQsIGN5OiBjZW50ZXJZLCBsYWJlbDogbGFiZWxzWzBdLCBjb2xvcjogY29sb3JzWzBdIH0sXHJcbiAgICAgICAgeyBpZDogJ2NpcmNsZTInLCBjeDogY2VudGVyWCArIG9mZnNldCwgY3k6IGNlbnRlclksIGxhYmVsOiBsYWJlbHNbMV0sIGNvbG9yOiBjb2xvcnNbMV0gfSxcclxuICAgICAgICB7IGlkOiAnY2lyY2xlMycsIGN4OiBjZW50ZXJYLCBjeTogY2VudGVyWSArIG9mZnNldCAqIDEuNSwgbGFiZWw6IGxhYmVsc1syXSwgY29sb3I6IGNvbG9yc1syXSB9LFxyXG4gICAgXVxyXG5cclxuICAgIC8vIERyYXcgY2lyY2xlc1xyXG4gICAgY2lyY2xlcy5mb3JFYWNoKCh7IGlkLCBjeCwgY3ksIGxhYmVsLCBjb2xvciB9LCBpbmRleCkgPT4ge1xyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ2NpcmNsZScpLmF0dHIoJ2lkJywgaWQpLmF0dHIoJ2N4JywgY3gpLmF0dHIoJ2N5JywgY3kpLmF0dHIoJ3InLCByYWRpdXMpLnN0eWxlKCdmaWxsJywgY29sb3IpLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuXHJcbiAgICAgICAgLy8gQWRkIGxhYmVscyB3aXRoIHNwZWNpZmljIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgY29uc3QgbGFiZWxYID1cclxuICAgICAgICAgICAgaW5kZXggPT09IDBcclxuICAgICAgICAgICAgICAgID8gY3ggLSByYWRpdXMgLSAxMCAvLyBMZWZ0IG9mIHRoZSBmaXJzdCBjaXJjbGVcclxuICAgICAgICAgICAgICAgIDogaW5kZXggPT09IDFcclxuICAgICAgICAgICAgICAgICAgPyBjeCArIHJhZGl1cyArIDEwIC8vIFJpZ2h0IG9mIHRoZSBzZWNvbmQgY2lyY2xlXHJcbiAgICAgICAgICAgICAgICAgIDogY3ggLy8gQmVsb3cgdGhlIHRoaXJkIGNpcmNsZVxyXG5cclxuICAgICAgICBjb25zdCBsYWJlbFkgPSBpbmRleCA8IDIgPyBjeSA6IGN5ICsgcmFkaXVzICsgMjAgLy8gU2FtZSB5IGZvciBmaXJzdCB0d28gY2lyY2xlcywgYmVsb3cgZm9yIHRoZSB0aGlyZFxyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBsYWJlbFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgbGFiZWxZKVxyXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCBpbmRleCA8IDIgPyAoaW5kZXggPT09IDAgPyAnZW5kJyA6ICdzdGFydCcpIDogJ21pZGRsZScpIC8vIEFkanVzdCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Zlbm4tbGFiZWwnKVxyXG4gICAgICAgICAgICAudGV4dChsYWJlbClcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCAnMTJweCcpXHJcbiAgICB9KVxyXG59XHJcblxyXG4vKipcclxuICogRHJhd3MgYSB0cml2YXJpYXRlIGxlZ2VuZCBhcyBhIHRlcm5hcnkgcGxvdFxyXG4gKi9cclxuZnVuY3Rpb24gZHJhd1RyaXZhcmlhdGVUZXJuYXJ5UGxvdChsZ2csIG91dCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICBjb25zdCBzaXplID0gb3V0LnNxdWFyZVNpemUgLy8gU2l6ZSBvZiB0aGUgbGVnZW5kIGFyZWFcclxuICAgIGNvbnN0IHBhZGRpbmcgPSAyMCAvLyBQYWRkaW5nIGFyb3VuZCB0aGUgcGxvdFxyXG4gICAgY29uc3QgcmFkaXVzID0gNSAvLyBSYWRpdXMgb2YgZWFjaCBjbGFzcyBwb2ludFxyXG4gICAgY29uc3QgdHJpYW5nbGVIZWlnaHQgPSAoTWF0aC5zcXJ0KDMpIC8gMikgKiBzaXplXHJcblxyXG4gICAgY29uc3QgdGVybmFyeUdyb3VwID0gbGdnXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RyaXZhcmlhdGUtdGVybmFyeS1wbG90JylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nICsgc2l6ZSAvIDJ9LCAke291dC5ib3hQYWRkaW5nICsgdHJpYW5nbGVIZWlnaHQgLyAyfSlgKVxyXG5cclxuICAgIC8vIERyYXcgdGhlIHRyaWFuZ2xlXHJcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtcclxuICAgICAgICB7IHg6IDAsIHk6IC10cmlhbmdsZUhlaWdodCAvIDIgfSwgLy8gVG9wIHZlcnRleCAoVmFyaWFibGUgMSlcclxuICAgICAgICB7IHg6IC1zaXplIC8gMiwgeTogdHJpYW5nbGVIZWlnaHQgLyAyIH0sIC8vIEJvdHRvbS1sZWZ0IHZlcnRleCAoVmFyaWFibGUgMilcclxuICAgICAgICB7IHg6IHNpemUgLyAyLCB5OiB0cmlhbmdsZUhlaWdodCAvIDIgfSwgLy8gQm90dG9tLXJpZ2h0IHZlcnRleCAoVmFyaWFibGUgMylcclxuICAgIF1cclxuXHJcbiAgICB0ZXJuYXJ5R3JvdXBcclxuICAgICAgICAuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAuYXR0cigncG9pbnRzJywgdmVydGljZXMubWFwKChkKSA9PiBgJHtkLnh9LCR7ZC55fWApLmpvaW4oJyAnKSlcclxuICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuXHJcbiAgICAvLyBMYWJlbCB0aGUgdmVydGljZXNcclxuICAgIGNvbnN0IGxhYmVscyA9IFtvdXQubGFiZWwxLCBvdXQubGFiZWwyLCBvdXQubGFiZWwzXVxyXG4gICAgdmVydGljZXMuZm9yRWFjaCgodmVydGV4LCBpKSA9PiB7XHJcbiAgICAgICAgdGVybmFyeUdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHZlcnRleC54KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHZlcnRleC55IC0gKGkgPT09IDAgPyAxMCA6IC0yMCkpIC8vIE9mZnNldCBsYWJlbHNcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Rlcm5hcnktbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgLnRleHQobGFiZWxzW2ldKVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBQbG90IHRoZSBwb2ludHMgaW5zaWRlIHRoZSB0ZXJuYXJ5IHBsb3RcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bWJlck9mQ2xhc3NlcyAtIGk7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCBrID0gbnVtYmVyT2ZDbGFzc2VzIC0gaSAtIGogLSAxIC8vIEVuc3VyZSBzdW0gb2YgaSArIGogKyBrID0gbnVtYmVyT2ZDbGFzc2VzIC0gMVxyXG4gICAgICAgICAgICBjb25zdCB4ID0gKChqIC0gaykgKiBzaXplKSAvICgyICogKG51bWJlck9mQ2xhc3NlcyAtIDEpKSAvLyBIb3Jpem9udGFsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSAoaSAqIC10cmlhbmdsZUhlaWdodCkgLyAobnVtYmVyT2ZDbGFzc2VzIC0gMSkgLy8gVmVydGljYWwgcG9zaXRpb25cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGwgPSBvdXQubWFwLmNsYXNzVG9GaWxsU3R5bGUoKShpLCBqLCBrKVxyXG5cclxuICAgICAgICAgICAgdGVybmFyeUdyb3VwXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgeClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIHJhZGl1cylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZmlsbClcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgaSwgaiwgaylcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgaSwgaiwgaylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBpLCBqLCBrKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpZ2hsaWdodCBzZWxlY3RlZCByZWdpb25zIG9uIG1vdXNlb3ZlclxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGVjbDEsIGVjbDIpIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChgW2VjbDFdYClcclxuXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZWdpb25zIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5zdHlsZSgnZmlsbCcsICd3aGl0ZScpXHJcblxyXG4gICAgICAgIC8vIEhpZ2hsaWdodCBvbmx5IHRoZSBzZWxlY3RlZCByZWdpb25zIGJ5IHJlc3RvcmluZyB0aGVpciBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUmVnaW9ucyA9IGFsbFJlZ2lvbnMuZmlsdGVyKGBbZWNsMT0nJHtlY2wxfSddYCkuZmlsdGVyKGBbZWNsMj0nJHtlY2wyfSddYClcclxuICAgICAgICBzZWxlY3RlZFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHJlZ2lvbnNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCByZWdpb25zIHRvIHRoZWlyIG9yaWdpbmFsIGNvbG9ycyBvbiBtb3VzZW91dFxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKGBbZWNsMV1gKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCB7IHNjYWxlQmFuZCwgc2NhbGVMaW5lYXIgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgYXhpc0xlZnQsIGF4aXNCb3R0b20gfSBmcm9tICdkMy1heGlzJ1xyXG5pbXBvcnQgeyBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4vbGVnZW5kJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuaW1wb3J0IHsgYXBwZW5kUGF0dGVybkZpbGxMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC1wYXR0ZXJuLWZpbGwnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIGNob3JvcGxldGggbWFwc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgKGluaGVyaXQpXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICBvdXQubGFiZWxUeXBlID0gJ3RocmVzaG9sZHMnIC8vIHRocmVzaG9sZHMgfHwgcmFuZ2VzXHJcbiAgICAvL3RoZSBvcmRlciBvZiB0aGUgbGVnZW5kIGVsZW1lbnRzLiBTZXQgdG8gZmFsc2UgdG8gaW52ZXJ0LlxyXG4gICAgb3V0LmFzY2VuZGluZyA9IHRydWVcclxuICAgIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVXaWR0aCA9IDI1XHJcbiAgICAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZUhlaWdodCA9IDIwXHJcbiAgICAvL3RoZSBzZXBhcmF0aW9uIGxpbmUgbGVuZ3RoXHJcbiAgICBvdXQuc2VwTGluZUxlbmd0aCA9IG91dC5zaGFwZVdpZHRoXHJcbiAgICAvL3RpY2sgbGluZSBsZW5ndGggaW4gcGl4ZWxzXHJcbiAgICBvdXQudGlja0xlbmd0aCA9IDRcclxuICAgIC8vdGhlIG51bWJlciBvZiBkZWNpbWFsIGZvciB0aGUgbGVnZW5kIGxhYmVsc1xyXG4gICAgb3V0LmRlY2ltYWxzID0gMFxyXG4gICAgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubGFiZWxPZmZzZXQgPSAzXHJcbiAgICAvL2xhYmVsRm9ybWF0dGVyIGZ1bmN0aW9uXHJcbiAgICBvdXQubGFiZWxGb3JtYXR0ZXIgPSBudWxsXHJcbiAgICAvLyBtYW51YWxseSBkZWZpbmUgbGFiZWxzXHJcbiAgICBvdXQubGFiZWxzID0gbnVsbFxyXG5cclxuICAgIC8vIEhpc3RvZ3JhbSBjb25maWcgYXMgbmVzdGVkIG9iamVjdFxyXG4gICAgb3V0Lmhpc3RvZ3JhbSA9IG51bGxcclxuXHJcbiAgICAvL2RpdmVyZ2luZyBsaW5lXHJcbiAgICBvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnBvaW50T2ZEaXZlcmdlbmNlID0gdW5kZWZpbmVkXHJcbiAgICBvdXQucG9pbnRPZkRpdmVyZ2VuY2VQYWRkaW5nID0gN1xyXG4gICAgb3V0LmRpdmVyZ2luZ0xpbmVMZW5ndGggPSB1bmRlZmluZWRcclxuICAgIG91dC5kaXZlcmdpbmdBcnJvd0xlbmd0aCA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhID0gdHJ1ZVxyXG4gICAgLy9ubyBkYXRhIHRleHQgbGFiZWxcclxuICAgIG91dC5ub0RhdGFUZXh0ID0gJ05vIGRhdGEnXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hpc3RvZ3JhbScgJiYgdHlwZW9mIGNvbmZpZ1trZXldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgb3V0Lmhpc3RvZ3JhbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNob3dDb3VudHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNob3dQZXJjZW50YWdlczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxSb3RhdGlvbjogMCxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbEZvcm1hdDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZy5oaXN0b2dyYW0sXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGlmIChvdXQubGdnLm5vZGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94IGFuZCB0aXRsZSBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgICBvdXQubWFrZUJhY2tncm91bmRCb3goKVxyXG4gICAgICAgICAgICBpZiAob3V0LnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3NzRm9udFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIGNzc0ZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KG91dC50aXRsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9leGl0IGVhcmx5IGlmIG5vIGNsYXNzaWZpZXJcclxuICAgICAgICAgICAgaWYgKCFtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGRlZmF1bHQgcG9pbnQgb2YgZGl2ZXJnZW5jZSBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCAmJiAhb3V0LnBvaW50T2ZEaXZlcmdlbmNlKSBvdXQucG9pbnRPZkRpdmVyZ2VuY2UgPSBtYXAubnVtYmVyT2ZDbGFzc2VzXyAvIDJcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQuaGlzdG9ncmFtKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVIaXN0b2dyYW1MZWdlbmQoKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5sYWJlbFR5cGUgPT09ICdyYW5nZXMnKSBjcmVhdGVSYW5nZXNMZWdlbmQoKVxyXG4gICAgICAgICAgICAgICAgZWxzZSBjcmVhdGVUaHJlc2hvbGRzTGVnZW5kKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGNob3JvcGxldGggbGVnZW5kIGJveFxyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBvdXQubGdnLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcGF0dGVybiBmaWxsIGxlZ2VuZCBpdGVtcyBCRUxPVyB0aGUgbWFpbiBsZWdlbmRcclxuICAgICAgICAgICAgYXBwZW5kUGF0dGVybkZpbGxMZWdlbmQobWFwLCBvdXQubGdnLCB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVdpZHRoOiBvdXQuc2hhcGVXaWR0aCxcclxuICAgICAgICAgICAgICAgIHNoYXBlSGVpZ2h0OiBvdXQuc2hhcGVIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBsYWJlbE9mZnNldDogb3V0LmxhYmVsT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgYm94UGFkZGluZzogb3V0LmJveFBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiBsZWdlbmRIZWlnaHQgKyBvdXQuYm94UGFkZGluZyArIDUsIC8vIDw8IHRoaXMgc2hpZnRzIHBhdHRlcm4gbGVnZW5kIGRvd25cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRocmVzaG9sZHMoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPVxyXG4gICAgICAgICAgICBtYXAudGhyZXNob2xkc18ubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyBtYXAudGhyZXNob2xkc19cclxuICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbSh7IGxlbmd0aDogbWFwLm51bWJlck9mQ2xhc3Nlc18gfSlcclxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKF8sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jbGFzc2lmaWVyKCkuaW52ZXJ0RXh0ZW50KGluZGV4KVtvdXQuYXNjZW5kaW5nID8gMCA6IDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDEpIC8vIFJlbW92ZSB0aGUgZmlyc3QgZW50cnkgYW5kIHJldHVybiB0aGUgcmVzdCBhcyBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICByZXR1cm4gbWFwLmNvbG9yc19cclxuICAgICAgICAgICAgPyBtYXAuY29sb3JzX1xyXG4gICAgICAgICAgICA6IEFycmF5LmZyb20oeyBsZW5ndGg6IG1hcC5udW1iZXJPZkNsYXNzZXNfIH0pLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoaW5kZXgsIG1hcC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwLnN0YXREYXRhKCkuX2RhdGFfKS5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVGhyZXNob2xkc0xlZ2VuZCgpIHtcclxuICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuICAgICAgICAvLyBMYWJlbCBmb3JtYXR0ZXJcclxuICAgICAgICBjb25zdCBmb3JtYXRMYWJlbCA9IG91dC5sYWJlbEZvcm1hdHRlciB8fCBmb3JtYXQoYC4ke291dC5kZWNpbWFsc31mYClcclxuICAgICAgICBsZXQgYmFzZVkgPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIGJhc2VZID0gYmFzZVkgKyBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLXRpdGxlJykgKyA4IC8vIHRpdGxlIHNpemUgKyBwYWRkaW5nXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm51bWJlck9mQ2xhc3Nlc187IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gYmFzZVkgKyBpICogb3V0LnNoYXBlSGVpZ2h0XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBvdXQuYXNjZW5kaW5nID8gbS5udW1iZXJPZkNsYXNzZXMoKSAtIGkgLSAxIDogaVxyXG4gICAgICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSBtLmNsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG0ubnVtYmVyT2ZDbGFzc2VzXylcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgZm9yIGVhY2ggY2xhc3NcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBzZXBhcmF0aW9uIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZ2cuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXNlcGFyYXRvcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBvdXQuYm94UGFkZGluZyArIG91dC5zZXBMaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aWNrIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZ2cuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNlcExpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBvdXQuYm94UGFkZGluZyArIG91dC5zZXBMaW5lTGVuZ3RoICsgb3V0LnRpY2tMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChpIDwgbS5udW1iZXJPZkNsYXNzZXMoKSAtIDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1hcmsgbGFiZWwgc28gd2UgY2FuIG1vdmUgaXQgaW4gZHJhd0RpdmVyZ2luZ0xpbmVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbGdnXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIE1hdGgubWF4KG91dC5zaGFwZVdpZHRoLCBvdXQuc2VwTGluZUxlbmd0aCArIG91dC50aWNrTGVuZ3RoKSArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8uYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KG91dC5sYWJlbHMgPyBvdXQubGFiZWxzW2ldIDogZm9ybWF0TGFiZWwobS5jbGFzc2lmaWVyKCkuaW52ZXJ0RXh0ZW50KGVjbClbb3V0LmFzY2VuZGluZyA/IDAgOiAxXSkpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbWFyayBsYWJlbCBzbyB3ZSBjYW4gbW92ZSBpdCBpbiBkcmF3RGl2ZXJnaW5nTGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5wb2ludE9mRGl2ZXJnZW5jZUxhYmVsICYmIGkgPT0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlIC0gMSkgbGFiZWwuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsIGVtLWxlZ2VuZC1sYWJlbC1kaXZlcmdlbmNlJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBkaXZlcmdpbmcgbGluZSBpZiBhcHBsaWNhYmxlLiBXZSBkcmF3IGl0IGFmdGVyd2FyZHMgc28gdGhhdCB3ZSBjYW4gY2FsY3VsYXRlIHRoZSBtYXggbGVuZ3RoIG9mIHRoZSBsZWdlbmQgbGFiZWxzIHNvIGl0IGRvZXNudCBjb3ZlciB0aGVtXHJcbiAgICAgICAgaWYgKG91dC5wb2ludE9mRGl2ZXJnZW5jZUxhYmVsKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLm51bWJlck9mQ2xhc3Nlc187IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBiYXNlWSArIGkgKiBvdXQuc2hhcGVIZWlnaHRcclxuICAgICAgICAgICAgICAgIC8vIHBvaW50IG9mIGRpdmVyZ2VuY2UgaW5kaWNhdG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3RGl2ZXJnaW5nTGluZSh5KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAnTm8gZGF0YScgYm94IGFuZCBsYWJlbCBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgaWYgKG91dC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgeSA9IGJhc2VZICsgbS5udW1iZXJPZkNsYXNzZXMoKSAqIG91dC5zaGFwZUhlaWdodCArIG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBvdXQubWFwLm5vRGF0YUZpbGxTdHlsZV8pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlc0xlZ2VuZCgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gb3V0LmxnZ1xyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSBnZXRUaHJlc2hvbGRzKClcclxuICAgICAgICBjb25zdCBkZWZhdWx0TGFiZWxsZXIgPSAobGFiZWwsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHJldHVybiBgPiAke3RocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSAxXX1gIC8vdG9wXHJcbiAgICAgICAgICAgIGlmIChpID09PSB0aHJlc2hvbGRzLmxlbmd0aCkgcmV0dXJuIGA8ICR7dGhyZXNob2xkc1swXX1gIC8vYm90dG9tXHJcbiAgICAgICAgICAgIHJldHVybiBgJHt0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gaSAtIDFdfSAtIDwgJHt0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gaV19ICBgIC8vaW4tYmV0d2VlblxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IG91dC5sYWJlbEZvcm1hdHRlciB8fCBkZWZhdWx0TGFiZWxsZXJcclxuXHJcbiAgICAgICAgbGV0IGJhc2VZID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSBiYXNlWSA9IGJhc2VZICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpICsgOCAvLyB0aXRsZSBzaXplICsgcGFkZGluZ1xyXG5cclxuICAgICAgICAvLyBmb3IgZWFjaCBjbGFzc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLm51bWJlck9mQ2xhc3Nlc187IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgeSA9IGJhc2VZICsgaSAqIG91dC5zaGFwZUhlaWdodFxyXG4gICAgICAgICAgICBjb25zdCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gb3V0LmFzY2VuZGluZyA/IG1hcC5udW1iZXJPZkNsYXNzZXMoKSAtIGkgLSAxIDogaVxyXG4gICAgICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSBtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgbWFwLm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Db250YWluZXIgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0nKVxyXG5cclxuICAgICAgICAgICAgLy8gc2hpZnQgbGVnZW5kIGl0ZW1zIGRvd24gYWZ0ZXIgcG9pbnQgb2YgZGl2ZXJnZW5jZSBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCAmJiBpID49IG91dC5wb2ludE9mRGl2ZXJnZW5jZSkgeSArPSBvdXQucG9pbnRPZkRpdmVyZ2VuY2VQYWRkaW5nXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZpbGxDb2xvcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5yYWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBzZXBhcmF0aW9uIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1zZXBhcmF0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2VwTGluZUxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgbGFiZWxzXHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgTWF0aC5tYXgob3V0LnNoYXBlV2lkdGgsIG91dC5zZXBMaW5lTGVuZ3RoICsgb3V0LnRpY2tMZW5ndGgpICsgb3V0LmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LmxhYmVscyA/IG91dC5sYWJlbHNbaV0gOiBsYWJlbEZvcm1hdHRlcihtYXAuY2xhc3NpZmllcigpLmludmVydEV4dGVudChlY2wpW291dC5hc2NlbmRpbmcgPyAwIDogMV0sIGkpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBkaXZlcmdpbmcgbGluZSBpZiBhcHBsaWNhYmxlLiBXZSBkcmF3IGl0IGFmdGVyd2FyZHMgc28gdGhhdCB3ZSBjYW4gY2FsY3VsYXRlIHRoZSBtYXggbGVuZ3RoIG9mIHRoZSBsZWdlbmQgbGFiZWxzIHNvIGl0IGRvZXNudCBjb3ZlciB0aGVtXHJcbiAgICAgICAgaWYgKG91dC5wb2ludE9mRGl2ZXJnZW5jZUxhYmVsKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLm51bWJlck9mQ2xhc3Nlc187IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBiYXNlWSArIGkgKiBvdXQuc2hhcGVIZWlnaHRcclxuICAgICAgICAgICAgICAgIC8vIHBvaW50IG9mIGRpdmVyZ2VuY2UgaW5kaWNhdG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3RGl2ZXJnaW5nTGluZSh5KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAnTm8gZGF0YScgYm94IGFuZCBsYWJlbCBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgaWYgKG91dC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9EYXRhSXRlbUNvbnRhaW5lciA9IGNvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaXRlbScpXHJcbiAgICAgICAgICAgIGxldCB5ID0gYmFzZVkgKyBtYXAubnVtYmVyT2ZDbGFzc2VzKCkgKiBvdXQuc2hhcGVIZWlnaHQgKyBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICAvL2lmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIHkgKz0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlUGFkZGluZyAvLyBzaGlmdCBsZWdlbmQgaXRlbXMgZG93biBhZnRlciBwb2ludCBvZiBkaXZlcmdlbmNlXHJcbiAgICAgICAgICAgIG5vRGF0YUl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBvdXQubWFwLm5vRGF0YUZpbGxTdHlsZV8pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykucmFpc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMobWFwLmluc2V0VGVtcGxhdGVzXywgbWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhtYXAuaW5zZXRUZW1wbGF0ZXNfLCBtYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgbm9EYXRhSXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdEaXZlcmdpbmdMaW5lKHkpIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdlbmNlLWNvbnRhaW5lcicpXHJcbiAgICAgICAgY29uc3QgbWFya2VySGVpZ2h0ID0gNlxyXG4gICAgICAgIGNvbnN0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGlmIChvdXQubGFiZWxUeXBlID09ICdyYW5nZXMnKSB5ID0geSArIG91dC5wb2ludE9mRGl2ZXJnZW5jZVBhZGRpbmcgLyAyIC8vIG1vdmUgdG8gdGhlIG1pZGRsZSBvZiB0aGUgc3BhY2UgYmV0d2VlbiBsZWdlbmQgaXRlbVxyXG4gICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IG91dC5sZ2dcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5ub2RlcygpXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKG1heCwgbm9kZSkgPT4gTWF0aC5tYXgobWF4LCBub2RlLmdldEJCb3goKS53aWR0aCksIDApXHJcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IG91dC5kaXZlcmdpbmdMaW5lTGVuZ3RoIHx8IG1heExhYmVsTGVuZ3RoICsgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIDEwIC8vICsgcGFkZGluZ1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBob3Jpem9udGFsIGRpdmVyZ2VuY2UgbGluZVxyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgeClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCArIGxpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtZGl2ZXJnaW5nLWxpbmUnKVxyXG5cclxuICAgICAgICAvLyBkaXZlcmdlbmNlIGxpbmUgd2l0aCB1cCBhbmQgZG93biBhcnJvd3NcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbC5zcGxpdCgnfCcpXHJcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkxpbmVMZW5ndGggPSBvdXQuZGl2ZXJnaW5nQXJyb3dMZW5ndGggfHwgMzBcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uTGluZVggPSB4ICsgbGluZUxlbmd0aFxyXG4gICAgICAgICAgICAvLyBBZGQgYXJyb3doZWFkIG1hcmtlciBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGRlZnMgPSBjb250YWluZXIuYXBwZW5kKCdkZWZzJylcclxuICAgICAgICAgICAgZGVmcy5hcHBlbmQoJ21hcmtlcicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnYXJyb3doZWFkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIG1hcmtlckhlaWdodClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCBtYXJrZXJIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncmVmWCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncmVmWScsIG1hcmtlckhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgYDAgMCwgJHttYXJrZXJIZWlnaHR9ICR7bWFya2VySGVpZ2h0IC8gMn0sIDAgJHttYXJrZXJIZWlnaHR9YClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuXHJcbiAgICAgICAgICAgIC8vIFVwd2FyZCBsaW5lIHdpdGggYXJyb3doZWFkXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGRpcmVjdGlvbkxpbmVYKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGRpcmVjdGlvbkxpbmVYKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSAtIGRpcmVjdGlvbkxpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG5cclxuICAgICAgICAgICAgLy8gRG93bndhcmQgbGluZSB3aXRoIGFycm93aGVhZFxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdpbmctbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkgKyBkaXJlY3Rpb25MaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCAndXJsKCNhcnJvd2hlYWQpJylcclxuXHJcbiAgICAgICAgICAgIC8vIExhYmVscyBmb3IgdXB3YXJkIGFuZCBkb3dud2FyZCBsaW5lc1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGRpcmVjdGlvbkxpbmVYICsgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgLSBkaXJlY3Rpb25MaW5lTGVuZ3RoICsgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGxhYmVsc1swXSlcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZGlyZWN0aW9uTGluZVggKyAxMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIGRpcmVjdGlvbkxpbmVMZW5ndGggLSAxMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQobGFiZWxzWzFdKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGp1c3QgdGhlIHNpbmdsZSBsYWJlbFxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdpbmctbGFiZWwgZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeCArIGxpbmVMZW5ndGggKyA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbW92ZSB0aHJlc2hvbGQgbGFiZWwgb3V0IG9mIHRoZSB3YXkgb2YgdGhlIGxpbmVcclxuICAgICAgICBpZiAob3V0LmxhYmVsVHlwZSA9PSAndGhyZXNob2xkcycpIHtcclxuICAgICAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGl0IHRvIGVuZCBvZiBsaW5lXHJcbiAgICAgICAgICAgICAgICBvdXQubGdnLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbC1kaXZlcmdlbmNlJykuYXR0cigneCcsIHggKyBsaW5lTGVuZ3RoICsgMTApXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGljayBsaW5lXHJcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd4MScsIHggKyBsaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLmF0dHIoJ3gyJywgeCArIGxpbmVMZW5ndGggKyA1KVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBpdCBzbyBpdCBkb2VzbnQgY2xhc2ggd2l0aCBwb2ludE9mRGl2ZXJnZW5jZUxhYmVsXHJcbiAgICAgICAgICAgICAgICBvdXQubGdnLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbC1kaXZlcmdlbmNlJykucmVtb3ZlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVIaXN0b2dyYW1MZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IGdldFRocmVzaG9sZHMoKVxyXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IGdldENvbG9ycygpXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldERhdGEoKVxyXG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gb3V0Lmhpc3RvZ3JhbS5vcmllbnRhdGlvbiB8fCAnaG9yaXpvbnRhbCdcclxuICAgICAgICBjb25zdCBzaG93Q291bnRzID0gb3V0Lmhpc3RvZ3JhbS5zaG93Q291bnRzXHJcbiAgICAgICAgY29uc3Qgc2hvd1BlcmNlbnRhZ2VzID0gb3V0Lmhpc3RvZ3JhbS5zaG93UGVyY2VudGFnZXNcclxuICAgICAgICBjb25zdCBsYWJlbFJvdGF0aW9uID0gb3V0Lmhpc3RvZ3JhbS5sYWJlbFJvdGF0aW9uIHx8IDBcclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdCA9IG91dC5oaXN0b2dyYW0ubGFiZWxGb3JtYXRcclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IG91dC5oaXN0b2dyYW0ubGFiZWxGb3JtYXR0ZXJcclxuXHJcbiAgICAgICAgbGV0IGNvdW50cyA9IG5ldyBBcnJheShtYXAubnVtYmVyT2ZDbGFzc2VzXykuZmlsbCgwKVxyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2xhc3NJbmRleCA9IG1hcC5jbGFzc2lmaWVyKCkodmFsdWUpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xhc3NJbmRleCA9PT0gJ251bWJlcicgJiYgY2xhc3NJbmRleCA+PSAwICYmIGNsYXNzSW5kZXggPCBjb3VudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudHNbY2xhc3NJbmRleF0rK1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRDb3VudHMgPSBjb3VudHMuc2xpY2UoKS5yZXZlcnNlKClcclxuICAgICAgICBjb25zdCB0b3RhbCA9IGNvdW50cy5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgZCwgMClcclxuICAgICAgICBjb25zdCByZXZlcnNlZFBlcmNlbnRhZ2VzID0gcmV2ZXJzZWRDb3VudHMubWFwKChkKSA9PiAodG90YWwgPiAwID8gKGQgLyB0b3RhbCkgKiAxMDAgOiAwKSlcclxuXHJcbiAgICAgICAgY29uc3QgbGdnID0gb3V0LmxnZ1xyXG4gICAgICAgIGNvbnN0IGJhc2VZID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnRpdGxlID8gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpICsgMzggOiAzMClcclxuICAgICAgICBjb25zdCBzdmdXaWR0aCA9IDMwMFxyXG4gICAgICAgIGNvbnN0IHN2Z0hlaWdodCA9IDMwMFxyXG4gICAgICAgIGNvbnN0IGJhckdyb3VwID0gbGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1oaXN0b2dyYW0nKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7YmFzZVl9KWApXHJcblxyXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICBkcmF3VmVydGljYWxIaXN0b2dyYW0oYmFyR3JvdXApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZHJhd0hvcml6b250YWxIaXN0b2dyYW0oYmFyR3JvdXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkcmF3VmVydGljYWxIaXN0b2dyYW0oYmFyR3JvdXApIHtcclxuICAgICAgICAgICAgY29uc3QgbWFyZ2luID0geyB0b3A6IDIwLCByaWdodDogNjAsIGJvdHRvbTogNDAsIGxlZnQ6IDE1MCB9XHJcbiAgICAgICAgICAgIGNvbnN0IHlTY2FsZSA9IHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKHJldmVyc2VkQ291bnRzLm1hcCgoXywgaSkgPT4gaSkpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoW21hcmdpbi50b3AsIHN2Z0hlaWdodCAtIG1hcmdpbi5ib3R0b21dKVxyXG4gICAgICAgICAgICAgICAgLnBhZGRpbmcoMC4xKVxyXG4gICAgICAgICAgICBjb25zdCB4U2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBtYXgocmV2ZXJzZWRDb3VudHMpXSlcclxuICAgICAgICAgICAgICAgIC5uaWNlKClcclxuICAgICAgICAgICAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHN2Z1dpZHRoIC0gbWFyZ2luLnJpZ2h0XSlcclxuXHJcbiAgICAgICAgICAgIC8vIEJhcnNcclxuICAgICAgICAgICAgYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocmV2ZXJzZWRDb3VudHMpXHJcbiAgICAgICAgICAgICAgICAuam9pbigncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWhpc3RvZ3JhbS1iYXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoXywgaSkgPT4geVNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB5U2NhbGUuYmFuZHdpZHRoKCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCkgPT4geFNjYWxlKGQpIC0gbWFyZ2luLmxlZnQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIChfLCBpKSA9PiBjb2xvcnNbY29sb3JzLmxlbmd0aCAtIGkgLSAxXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wnLCAoXywgaSkgPT4gaSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgaGFuZGxlTW91c2VPdmVyKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGhhbmRsZU1vdXNlT3V0KVxyXG5cclxuICAgICAgICAgICAgLy8gQmFyIGxhYmVsc1xyXG4gICAgICAgICAgICBpZiAoc2hvd0NvdW50cyB8fCBzaG93UGVyY2VudGFnZXMpIHtcclxuICAgICAgICAgICAgICAgIGJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dC5lbS1oaXN0b2dyYW0tbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHJldmVyc2VkQ291bnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsIGVtLWhpc3RvZ3JhbS1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCkgPT4geFNjYWxlKGQpICsgNSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIChfLCBpKSA9PiB5U2NhbGUoaSkgKyB5U2NhbGUuYmFuZHdpZHRoKCkgLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgICAgICAudGV4dCgoXywgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxGb3JtYXR0ZXIocmV2ZXJzZWRQZXJjZW50YWdlc1tpXSwgcmV2ZXJzZWRDb3VudHNbaV0sIGkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3dQZXJjZW50YWdlcyA/IGAke3JldmVyc2VkUGVyY2VudGFnZXNbaV0udG9GaXhlZCgxKX0lYCA6IHJldmVyc2VkQ291bnRzW2ldXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXhpc1xyXG4gICAgICAgICAgICBiYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tbGVnZW5kLWhpc3RvZ3JhbS15LWF4aXMnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sIDApYClcclxuICAgICAgICAgICAgICAgIC5jYWxsKFxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNMZWZ0KHlTY2FsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplT3V0ZXIoMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KChfLCBpKSA9PiBmb3JtYXRUaWNrTGFiZWwoaSkpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkcmF3SG9yaXpvbnRhbEhpc3RvZ3JhbShiYXJHcm91cCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJnaW4gPSB7IHRvcDogMjAsIHJpZ2h0OiA2MCwgYm90dG9tOiA0MCwgbGVmdDogMTAgfVxyXG4gICAgICAgICAgICBjb25zdCB4U2NhbGUgPSBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihyZXZlcnNlZENvdW50cy5tYXAoKF8sIGkpID0+IGkpKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFttYXJnaW4ubGVmdCwgc3ZnV2lkdGggLSBtYXJnaW4ucmlnaHRdKVxyXG4gICAgICAgICAgICAgICAgLnBhZGRpbmcoMC4xKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgeVNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgbWF4KHJldmVyc2VkQ291bnRzKV0pXHJcbiAgICAgICAgICAgICAgICAubmljZSgpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoW3N2Z0hlaWdodCAtIG1hcmdpbi5ib3R0b20sIG1hcmdpbi50b3BdKVxyXG5cclxuICAgICAgICAgICAgLy8gQmFyc1xyXG4gICAgICAgICAgICBiYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShyZXZlcnNlZENvdW50cylcclxuICAgICAgICAgICAgICAgIC5qb2luKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaGlzdG9ncmFtLWJhcicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIChfLCBpKSA9PiB4U2NhbGUoaSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB4U2NhbGUuYmFuZHdpZHRoKCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQpID0+IHN2Z0hlaWdodCAtIG1hcmdpbi5ib3R0b20gLSB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIChfLCBpKSA9PiBjb2xvcnNbY29sb3JzLmxlbmd0aCAtIGkgLSAxXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wnLCAoXywgaSkgPT4gaSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgaGFuZGxlTW91c2VPdmVyKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGhhbmRsZU1vdXNlT3V0KVxyXG5cclxuICAgICAgICAgICAgLy8gQmFyIGxhYmVscyAoY2VudGVyZWQpXHJcbiAgICAgICAgICAgIGlmIChzaG93Q291bnRzIHx8IHNob3dQZXJjZW50YWdlcykge1xyXG4gICAgICAgICAgICAgICAgYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0LmVtLWhpc3RvZ3JhbS1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEocmV2ZXJzZWRDb3VudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwgZW0taGlzdG9ncmFtLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChfLCBpKSA9PiB4U2NhbGUoaSkgKyB4U2NhbGUuYmFuZHdpZHRoKCkgLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+IHlTY2FsZShkKSAtIDUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoKF8sIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKHJldmVyc2VkUGVyY2VudGFnZXNbaV0sIHJldmVyc2VkQ291bnRzW2ldLCBpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG93UGVyY2VudGFnZXMgPyBgJHtyZXZlcnNlZFBlcmNlbnRhZ2VzW2ldLnRvRml4ZWQoMSl9JWAgOiByZXZlcnNlZENvdW50c1tpXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEF4aXMgKG9ubHkgZm9yIGxhYmVsVHlwZSA9PT0gJ3RocmVzaG9sZHMnKVxyXG4gICAgICAgICAgICBjb25zdCBheGlzR3JvdXAgPSBiYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tbGVnZW5kLWhpc3RvZ3JhbS14LWF4aXMnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tfSlgKVxyXG5cclxuICAgICAgICAgICAgaWYgKG91dC5sYWJlbFR5cGUgPT09ICd0aHJlc2hvbGRzJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW11cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRocmVzaG9sZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYW5kSW5kZXggPSB0aHJlc2hvbGRzLmxlbmd0aCAtIGkgLSAxXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHhTY2FsZShiYW5kSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkgcG9zaXRpb25zLnB1c2goeCArIHhTY2FsZS5iYW5kd2lkdGgoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZGFyeVNjYWxlID0gc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIHN2Z1dpZHRoXSkucmFuZ2UoWzAsIHN2Z1dpZHRoXSlcclxuXHJcbiAgICAgICAgICAgICAgICBheGlzR3JvdXAuY2FsbChcclxuICAgICAgICAgICAgICAgICAgICBheGlzQm90dG9tKGJvdW5kYXJ5U2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrVmFsdWVzKHBvc2l0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoKF8sIGkpID0+IChsYWJlbEZvcm1hdCA/IGxhYmVsRm9ybWF0KHRocmVzaG9sZHNbaV0sIGkpIDogdGhyZXNob2xkc1tpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja1NpemVPdXRlcigwKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXhpc0dyb3VwLmNhbGwoYXhpc0JvdHRvbSh4U2NhbGUpLnRpY2tTaXplT3V0ZXIoMCkudGlja1NpemUoMCkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGF4aXNHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsIGVtLXRpY2stbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHJvdGF0ZSgtJHtsYWJlbFJvdGF0aW9ufSlgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0VGlja0xhYmVsKGkpIHtcclxuICAgICAgICAgICAgaWYgKG91dC5sYWJlbFR5cGUgPT09ICd0aHJlc2hvbGRzJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnJlYWtJbmRleCA9IHRocmVzaG9sZHMubGVuZ3RoIC0gaSAtIDFcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW2JyZWFrSW5kZXhdID8/ICcnXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIGA+ICR7dGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIDFdfWBcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aHJlc2hvbGRzLmxlbmd0aCkgcmV0dXJuIGA8ICR7dGhyZXNob2xkc1swXX1gXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIGkgLSAxXX0gLSA8ICR7dGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIGldfWBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VPdmVyKF8sIGkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRJbmRleCA9IGNvbG9ycy5sZW5ndGggLSAxIC0gcGFyc2VJbnQoZWNsLCAxMClcclxuICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIHJldmVyc2VkSW5kZXgpXHJcbiAgICAgICAgICAgIGlmIChtYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU91dChfLCBpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKS5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKVxyXG4gICAgICAgICAgICBpZiAobWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhtYXAuaW5zZXRUZW1wbGF0ZXNfLCBtYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKCdbZWNsXScpXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVnaW9ucyB0byB3aGl0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBhbGxSZWdpb25zLmZpbHRlcihcIltlY2w9J1wiICsgZWNsICsgXCInXVwiKVxyXG4gICAgICAgIHNlbGVjdGVkUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9kZXByZWNhdGVkXHJcbiAgICBvdXQubGFiZWxEZWNOYiA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdsYWJlbERlY05iIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIGRlY2ltYWxzIGluc3RlYWQuJyksIG91dClcclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ2QzLWZvcm1hdCdcclxuXHJcbi8vc2V0IGxlZ2VuZCBsYWJlbHMgbG9jYWxlXHJcbmZvcm1hdERlZmF1bHRMb2NhbGUoe1xyXG4gICAgZGVjaW1hbDogJy4nLFxyXG4gICAgdGhvdXNhbmRzOiAnICcsXHJcbiAgICBncm91cGluZzogWzNdLFxyXG4gICAgY3VycmVuY3k6IFsnJywgJ+KCrCddLFxyXG59KVxyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9sIG1hcFxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgY29uZmlnc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gY29uZmlnW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNvbG9yTGVnZW5kID09IGZhbHNlKSBvdXQuY29sb3JMZWdlbmQgPSBmYWxzZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGxlZ2VuZCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmIChtLmxlZ2VuZF8pXHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBtLmxlZ2VuZF8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ2NvbG9yTGVnZW5kJyB8fCBrZXkgPT0gJ3NpemVMZWdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIG0ubGVnZW5kX1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5sZWdlbmRfW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV1bcF0gPSBtLmxlZ2VuZF9ba2V5XVtwXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRba2V5XSA9IG0ubGVnZW5kX1trZXldXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgYnVpbGRGbG93TGVnZW5kKClcclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgd2hpY2ggaWxsdXN0cmF0ZXMgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgZmxvdyBzeW1ib2wgc2l6ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gY29udGFpbmVyIHBhcmVudCBsZWdlbmQgb2JqZWN0IGZyb20gY29yZS9sZWdlbmQuanNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRGbG93TGVnZW5kKG0pIHt9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kKG1hcCwgY29udGFpbmVyLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBzaGFwZVdpZHRoID0gMjUsXHJcbiAgICAgICAgc2hhcGVIZWlnaHQgPSAyMCxcclxuICAgICAgICBsYWJlbE9mZnNldCA9IDMsXHJcbiAgICAgICAgYm94UGFkZGluZyA9IDUsXHJcbiAgICAgICAgb2Zmc2V0WSA9IDAsIC8vIDw8IG5ld1xyXG4gICAgfSA9IG9wdGlvbnNcclxuXHJcbiAgICBpZiAoIW1hcC5wYXR0ZXJuRmlsbF8pIHJldHVyblxyXG5cclxuICAgIG1hcC5wYXR0ZXJuRmlsbF8uZm9yRWFjaCgoY2ZnLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGlmICghY2ZnLmxlZ2VuZExhYmVsKSByZXR1cm4gLy8gc2tpcCBpZiBubyBsYWJlbFxyXG5cclxuICAgICAgICBjb25zdCB5ID0gb2Zmc2V0WSArIGluZGV4ICogKHNoYXBlSGVpZ2h0ICsgYm94UGFkZGluZylcclxuXHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGNvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaXRlbSBwYXR0ZXJuLWZpbGwtbGVnZW5kJylcclxuXHJcbiAgICAgICAgY29uc3QgcGF0dGVybkNvbG9yID0gY2ZnLmNvbG9yIHx8ICcjMDAwJyAvLyBmYWxsYmFjayB0byBibGFjayBpZiBubyBjb2xvciBwcm92aWRlZFxyXG4gICAgICAgIGNvbnN0IGlzV2hpdGVQYXR0ZXJuID0gcGF0dGVybkNvbG9yLnRvTG93ZXJDYXNlKCkgPT09ICcjZmZmJyB8fCBwYXR0ZXJuQ29sb3IudG9Mb3dlckNhc2UoKSA9PT0gJ3doaXRlJ1xyXG5cclxuICAgICAgICAvLyBBZGQgYmFja2dyb3VuZCBpZiBwYXR0ZXJuIGlzIHdoaXRlXHJcbiAgICAgICAgaWYgKGlzV2hpdGVQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uYXBwZW5kKCdyZWN0JykuYXR0cigneCcsIGJveFBhZGRpbmcpLmF0dHIoJ3knLCB5KS5hdHRyKCd3aWR0aCcsIHNoYXBlV2lkdGgpLmF0dHIoJ2hlaWdodCcsIHNoYXBlSGVpZ2h0KS5hdHRyKCdmaWxsJywgJyNkZGQnKSAvLyBsaWdodCBncmF5IGJhY2tncm91bmRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBwYXR0ZXJuIG92ZXJsYXlcclxuICAgICAgICBpdGVtLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgYm94UGFkZGluZylcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgYHVybCgjJHtjZmcucGF0dGVybklkIHx8IGNmZy5wYXR0ZXJufSlgKVxyXG5cclxuICAgICAgICAvLyBBZGQgbGFiZWxcclxuICAgICAgICBpdGVtLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIGJveFBhZGRpbmcgKyBzaGFwZVdpZHRoICsgbGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIHNoYXBlSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC50ZXh0KGNmZy5sZWdlbmRMYWJlbClcclxuICAgIH0pXHJcbn1cclxuIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IG1heCB9IGZyb20gJ2QzLWFycmF5J1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldEZvbnRTaXplRnJvbUNsYXNzIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbCBtYXBcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IGZvciB0aGUgbWFwXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICAvL3NwYWNpbmcgYmV0d2VlbiBjb2xvciAmIHNpemUgbGVnZW5kcyAoaWYgYXBwbGljYWJsZSlcclxuICAgIG91dC5sZWdlbmRTcGFjaW5nID0gMTVcclxuXHJcbiAgICAvL3NpemUgbGVnZW5kIGNvbmZpZyAobGVnZW5kIGlsbHVzdHJhdGluZyB0aGUgdmFsdWVzIG9mIGRpZmZlcmVudCBwaWUgc2l6ZXMpXHJcbiAgICBvdXQuc2l6ZUxlZ2VuZCA9IHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICB0aXRsZVBhZGRpbmc6IDMwLCAvL3BhZGRpbmcgYmV0d2VlbiB0aXRsZSBhbmQgYm9keVxyXG4gICAgICAgIHZhbHVlczogbnVsbCxcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbG91ciBsZWdlbmQgY29uZmlnIChsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSB2YWx1ZXMgb2YgZGlmZmVyZW50IHBpZSBjb2xvdXJzKVxyXG4gICAgb3V0LmNvbG9yTGVnZW5kID0ge1xyXG4gICAgICAgIHRpdGxlOiBudWxsLFxyXG4gICAgICAgIGxhYmVsT2Zmc2V0OiA1LCAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbGFiZWxcclxuICAgICAgICBzaGFwZVdpZHRoOiAyNSwgLy90aGUgd2lkdGggb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgICAgICBzaGFwZUhlaWdodDogMjAsIC8vdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgICAgIHNoYXBlUGFkZGluZzogNSwgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICAgICAgbm9EYXRhOiB0cnVlLCAvL3Nob3cgbm8gZGF0YVxyXG4gICAgICAgIG5vRGF0YVRleHQ6ICdObyBkYXRhJywgLy9ubyBkYXRhIGxhYmVsIHRleHRcclxuICAgIH1cclxuXHJcbiAgICBvdXQuX3NpemVMZWdlbmRIZWlnaHQgPSAwXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT0gJ2NvbG9yTGVnZW5kJyB8fCBrZXkgPT0gJ3NpemVMZWdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIGluIG91dFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9vdmVycmlkZSBlYWNoIHByb3BlcnR5IGluIHNpemUgYW5kIGNvbG9yIGxlZ2VuZCBjb25maWdzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldW3BdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV1bcF0gPSBjb25maWdba2V5XVtwXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgLy8gbGVnZW5kIGZvciBzaXplc1xyXG4gICAgICAgIGlmIChtYXAuc2l6ZUNsYXNzaWZpZXJfKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkU2l6ZUxlZ2VuZCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBsZWdlbmQgZm9yIHBzIGNvbG9yIHZhbHVlc1xyXG4gICAgICAgIGJ1aWxkQ29sb3JMZWdlbmQoKVxyXG5cclxuICAgICAgICAvL3NldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICBvdXQuc2V0Qm94RGltZW5zaW9uKClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBhIGxlZ2VuZCB3aGljaCBpbGx1c3RyYXRlcyB0aGUgc3RhdGlzdGljYWwgdmFsdWVzIG9mIGRpZmZlcmVudCBwaWUgY2hhcnQgc2l6ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG0gbWFwXHJcbiAgICAgKiBAcGFyYW0geyp9IGxnZyBwYXJlbnQgbGVnZW5kIG9iamVjdCBmcm9tIGNvcmUvbGVnZW5kLmpzXHJcbiAgICAgKiBAcGFyYW0geyp9IGNvbmZpZyBzaXplIGxlZ2VuZCBjb25maWcgb2JqZWN0IChzaXplTGVnZW5kIG9iamVjdCBzcGVjaWZpZWQgYXMgcHJvcGVydHkgb2YgbGVnZW5kKCkgY29uZmlnIG9iamVjdClcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRTaXplTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBjb25maWcgPSBvdXQuc2l6ZUxlZ2VuZFxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tcGllLXNpemUtbGVnZW5kJylcclxuXHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gbWFwLnNpemVDbGFzc2lmaWVyXy5kb21haW4oKVxyXG5cclxuICAgICAgICAvLyBBc3NpZ24gZGVmYXVsdCBjaXJjbGUgcmFkaWkgaWYgbm9uZSBzcGVjaWZpZWQgYnkgdXNlclxyXG4gICAgICAgIGlmICghY29uZmlnLnZhbHVlcykge1xyXG4gICAgICAgICAgICBjb25maWcudmFsdWVzID0gW01hdGguZmxvb3IoZG9tYWluWzFdKSwgTWF0aC5mbG9vcihkb21haW5bMF0pXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIGNpcmNsZSBzaXplIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgbGVnZW5kXHJcbiAgICAgICAgbGV0IG1heFNpemUgPSBtYXAuc2l6ZUNsYXNzaWZpZXJfKG1heChjb25maWcudmFsdWVzKSlcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSB0aXRsZSB0byB0aGUgY29udGFpbmVyIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGlmICghY29uZmlnLnRpdGxlICYmIG91dC50aXRsZSkgY29uZmlnLnRpdGxlID0gb3V0LnRpdGxlIC8vIEFsbG93IHJvb3QgbGVnZW5kIHRpdGxlXHJcbiAgICAgICAgbGV0IHRpdGxlSGVpZ2h0ID0gMCAvLyBUaGlzIHdpbGwgYmUgYWRqdXN0ZWQgYmFzZWQgb24gd2hldGhlciB0aGUgdGl0bGUgZXhpc3RzXHJcbiAgICAgICAgaWYgKGNvbmZpZy50aXRsZSkge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApIC8vIFBvc2l0aW9uIHRoZSB0aXRsZSBhdCB0aGUgbGVmdCBlZGdlXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnRpdGxlRm9udFNpemUpIC8vIFRpdGxlIGF0IHRvcCwgd2l0aGluIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgIC50ZXh0KGNvbmZpZy50aXRsZSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aXRsZSBoZWlnaHQgKHVzaW5nIHRoZSB0aXRsZSBmb250IHNpemUgYXMgYSBwcm94eSlcclxuICAgICAgICAgICAgdGl0bGVIZWlnaHQgPSBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nICsgY29uZmlnLnRpdGxlUGFkZGluZ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm93IHBvc2l0aW9uIHRoZSBjaXJjbGVzICoqYmVsb3cqKiB0aGUgdGl0bGVcclxuICAgICAgICBsZXQgeSA9IHRpdGxlSGVpZ2h0ICsgb3V0LmJveFBhZGRpbmcgKyBtYXhTaXplICogMiAvLyBQb3NpdGlvbiBjaXJjbGVzIGFmdGVyIHRpdGxlIGhlaWdodFxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgdGhlIGxlZ2VuZCBjaXJjbGVzXHJcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbXMgPSBjb250YWluZXJcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgIC5kYXRhKGNvbmZpZy52YWx1ZXMpXHJcbiAgICAgICAgICAgIC5qb2luKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZS1zaXplLWxlZ2VuZC1pdGVtJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXhTaXplICsgb3V0LmJveFBhZGRpbmd9LCAke3l9KWApIC8vIER5bmFtaWNhbGx5IG1vdmUgdGhlIGNpcmNsZXMgZG93blxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgY2lyY2xlcyB0byBlYWNoIGdyb3VwXHJcbiAgICAgICAgbGVnZW5kSXRlbXNcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZS1zaXplLWxlZ2VuZC1jaXJjbGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignY3knLCAoZCkgPT4gLW1hcC5zaXplQ2xhc3NpZmllcl8oZCkpIC8vIFBvc2l0aW9uIGNpcmNsZXMgYmFzZWQgb24gdGhlaXIgc2l6ZVxyXG4gICAgICAgICAgICAuYXR0cigncicsIG1hcC5zaXplQ2xhc3NpZmllcl8pIC8vIFJhZGl1cyBpcyBjYWxjdWxhdGVkIGZyb20gc2l6ZSBjbGFzc2lmaWVyXHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBsYWJlbHMgdG8gZWFjaCBncm91cFxyXG4gICAgICAgIGxlZ2VuZEl0ZW1zXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gLTIgKiBtYXAuc2l6ZUNsYXNzaWZpZXJfKGQpIC0gb3V0LmxhYmVsRm9udFNpemUgLSAyKSAvLyBQb3NpdGlvbiBsYWJlbHMgcmVsYXRpdmUgdG8gY2lyY2xlc1xyXG4gICAgICAgICAgICAuYXR0cigneCcsIDMwKSAvLyBTZXQgdGhlIHgtcG9zaXRpb24gZm9yIHRoZSBsYWJlbHNcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzEuMmVtJylcclxuICAgICAgICAgICAgLmF0dHIoJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiBkLnRvTG9jYWxlU3RyaW5nKCdlbicpLnJlcGxhY2UoLywvZ2ksICcgJykpIC8vIEZvcm1hdCB0aGUgbGFiZWwgdGV4dFxyXG5cclxuICAgICAgICAvLyBBZGQgbGluZXMgcG9pbnRpbmcgdG8gdGhlIHRvcCBvZiB0aGUgY29ycmVzcG9uZGluZyBjaXJjbGVcclxuICAgICAgICBsZWdlbmRJdGVtc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZS1zaXplLWxlZ2VuZC1saW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgMilcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgMzApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIChkKSA9PiAtMiAqIG1hcC5zaXplQ2xhc3NpZmllcl8oZCkpIC8vIFBvc2l0aW9uIGxpbmVzIHJlbGF0aXZlIHRvIGNpcmNsZXNcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQpID0+IC0yICogbWFwLnNpemVDbGFzc2lmaWVyXyhkKSkgLy8gU2FtZSBwb3NpdGlvbiBmb3IgdGhlIHkyIHRvIG1ha2UgYSBob3Jpem9udGFsIGxpbmVcclxuXHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgaGVpZ2h0IHZhbHVlIGZvciBwb3NpdGlvbmluZyB0aGUgY29sb3IgbGVnZW5kIChpZiBuZWVkZWQpXHJcbiAgICAgICAgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ID0geVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBhIGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiB0aGUgcGllIGNoYXJ0cycgZGlmZmVyZW50IGNvbG91cnNcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ29sb3JMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG91dC5jb2xvckxlZ2VuZFxyXG4gICAgICAgIC8vY29udGFpbmVyXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gb3V0LmxnZy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1waWUtY29sb3ItbGVnZW5kJylcclxuXHJcbiAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgaWYgKGNvbmZpZy50aXRsZSkge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuX3NpemVMZWdlbmRIZWlnaHQgKyBvdXQubGVnZW5kU3BhY2luZyArIG91dC5ib3hQYWRkaW5nICsgb3V0LnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAudGV4dChjb25maWcudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGVsZW1lbnRzIGZvciBjbGFzc2VzOiByZWN0YW5nbGUgKyBsYWJlbFxyXG4gICAgICAgIGxldCBpID0gMFxyXG4gICAgICAgIGNvbnN0IHNjcyA9IG1hcC5jYXRDb2xvcnMoKVxyXG4gICAgICAgIGZvciAobGV0IGNvZGUgaW4gc2NzKSB7XHJcbiAgICAgICAgICAgIC8vdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCB5ID1cclxuICAgICAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZEhlaWdodCArXHJcbiAgICAgICAgICAgICAgICBvdXQubGVnZW5kU3BhY2luZyArXHJcbiAgICAgICAgICAgICAgICBvdXQuYm94UGFkZGluZyArXHJcbiAgICAgICAgICAgICAgICAoY29uZmlnLnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyA6IDApICtcclxuICAgICAgICAgICAgICAgIGkgKiAoY29uZmlnLnNoYXBlSGVpZ2h0ICsgY29uZmlnLnNoYXBlUGFkZGluZylcclxuICAgICAgICAgICAgLy90aGUgY29sb3JcclxuICAgICAgICAgICAgY29uc3QgY29sID0gbWFwLmNhdENvbG9ycygpW2NvZGVdIHx8ICdsaWdodGdyYXknXHJcblxyXG4gICAgICAgICAgICAvL3JlY3RhbmdsZVxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjb25maWcuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjb25maWcuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBzY3NbY29kZV0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgY29kZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgY29uZmlnLnNoYXBlV2lkdGggKyBjb25maWcubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBjb25maWcuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KG1hcC5jYXRMYWJlbHMoKVtjb2RlXSB8fCBjb2RlKVxyXG5cclxuICAgICAgICAgICAgaSsrXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLydubyBkYXRhJyBsZWdlbmQgYm94XHJcbiAgICAgICAgaWYgKGNvbmZpZy5ub0RhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgeSA9XHJcbiAgICAgICAgICAgICAgICBvdXQuX3NpemVMZWdlbmRIZWlnaHQgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmxlZ2VuZFNwYWNpbmcgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmJveFBhZGRpbmcgK1xyXG4gICAgICAgICAgICAgICAgKGNvbmZpZy50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArXHJcbiAgICAgICAgICAgICAgICBpICogKGNvbmZpZy5zaGFwZUhlaWdodCArIGNvbmZpZy5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAvL3JlY3RhbmdsZVxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjb25maWcuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjb25maWcuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtYXAubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8nbm8gZGF0YScgbGFiZWxcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIGNvbmZpZy5zaGFwZVdpZHRoICsgY29uZmlnLmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgY29uZmlnLnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgLnRleHQoY29uZmlnLm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpZ2hsaWdodCBzZWxlY3RlZCBzZWdtZW50cyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBjb2RlKSB7XHJcbiAgICAgICAgY29uc3QgYWxsU2VnbWVudHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJy5waWVjaGFydCcpLnNlbGVjdEFsbCgncGF0aFtjb2RlXScpXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgc2VnbWVudHMgdG8gd2hpdGVcclxuICAgICAgICBhbGxTZWdtZW50cy5zdHlsZSgnZmlsbCcsICd3aGl0ZScpXHJcblxyXG4gICAgICAgIC8vIEhpZ2hsaWdodCBvbmx5IHRoZSBzZWxlY3RlZCBzZWdtZW50cyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFNlZ21lbnRzID0gYWxsU2VnbWVudHMuZmlsdGVyKFwicGF0aFtjb2RlPSdcIiArIGNvZGUgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsZWN0ZWRTZWdtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgc2VnbWVudHNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCBzZWdtZW50cyB0byB0aGVpciBvcmlnaW5hbCBjb2xvcnMgb24gbW91c2VvdXRcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBjb25zdCBhbGxTZWdtZW50cyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnLnBpZWNoYXJ0Jykuc2VsZWN0QWxsKCdwYXRoW2NvZGVdJylcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHNlZ21lbnRzJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxTZWdtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4vbGVnZW5kJ1xyXG5pbXBvcnQgeyBzeW1ib2xzTGlicmFyeSB9IGZyb20gJy4uL21hcHR5cGVzL21hcC1wcm9wb3J0aW9uYWwtc3ltYm9scydcclxuaW1wb3J0IHsgc3ltYm9sIH0gZnJvbSAnZDMtc2hhcGUnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldEZvbnRTaXplRnJvbUNsYXNzLCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBmb3JtYXREZWZhdWx0TG9jYWxlIH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuXHJcbi8vc2V0IGxlZ2VuZCBsYWJlbHMgbG9jYWxlXHJcbmZvcm1hdERlZmF1bHRMb2NhbGUoe1xyXG4gICAgZGVjaW1hbDogJy4nLFxyXG4gICAgdGhvdXNhbmRzOiAnICcsXHJcbiAgICBncm91cGluZzogWzNdLFxyXG4gICAgY3VycmVuY3k6IFsnJywgJ+KCrCddLFxyXG59KVxyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9sIG1hcFxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIG91dC5hc2NlbmRpbmcgPSBmYWxzZSAvL3RoZSBvcmRlciBvZiB0aGUgbGVnZW5kIGVsZW1lbnRzLiBTZXQgdG8gZmFsc2UgdG8gaW52ZXJ0LlxyXG4gICAgb3V0LmxlZ2VuZFNwYWNpbmcgPSAzNSAvL3NwYWNpbmcgYmV0d2VlbiBjb2xvciAmIHNpemUgbGVnZW5kcyAoaWYgYXBwbGljYWJsZSlcclxuICAgIG91dC5sYWJlbEZvbnRTaXplID0gMTIgLy90aGUgZm9udCBzaXplIG9mIHRoZSBsZWdlbmQgbGFiZWxzXHJcblxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlV2lkdGggPSAyNVxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlSGVpZ2h0ID0gMjBcclxuXHJcbiAgICAvL3NpemUgbGVnZW5kIGNvbmZpZyAobGVnZW5kIGlsbHVzdHJhdGluZyB0aGUgdmFsdWVzIG9mIGRpZmZlcmVudCBzeW1ib2wgc2l6ZXMpXHJcbiAgICBvdXQuc2l6ZUxlZ2VuZCA9IHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxMixcclxuICAgICAgICB0aXRsZVBhZGRpbmc6IDUsIC8vcGFkZGluZyBiZXR3ZWVuIHRpdGxlIGFuZCBsZWdlbmQgYm9keVxyXG4gICAgICAgIHZhbHVlczogdW5kZWZpbmVkLCAvL21hbnVhbGx5IGRlZmluZSByYXcgZGF0YSB2YWx1ZXNcclxuICAgICAgICBjZWxsTmI6IDMsIC8vbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBsZWdlbmRcclxuICAgICAgICBzaGFwZVBhZGRpbmc6IDUsIC8vdGhlIHkgZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBsZWdlbmQgc2hhcGUgZWxlbWVudHNcclxuICAgICAgICBzaGFwZU9mZnNldDogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgc2hhcGVGaWxsOiAnd2hpdGUnLFxyXG4gICAgICAgIHNoYXBlU3Ryb2tlOiBudWxsLFxyXG4gICAgICAgIGxhYmVsT2Zmc2V0OiB7IHg6IDEwLCB5OiAwIH0sIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxlZ2VuZCBib3ggZWxlbWVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBsYWJlbFxyXG4gICAgICAgIGRlY2ltYWxzOiAwLCAvL3RoZSBudW1iZXIgb2YgZGVjaW1hbCBmb3IgdGhlIGxlZ2VuZCBsYWJlbHNcclxuICAgICAgICBsYWJlbEZvcm1hdHRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIF90b3RhbEJhcnNIZWlnaHQ6IDAsXHJcbiAgICAgICAgX3RvdGFsRDNTeW1ib2xzSGVpZ2h0OiAwLFxyXG4gICAgICAgIG5vRGF0YTogZmFsc2UsIC8vIHNob3cgbm8gZGF0YSBsZWdlbmQgaXRlbVxyXG4gICAgICAgIG5vRGF0YVRleHQ6ICdObyBkYXRhJywgLy9ubyBkYXRhIHRleHQgbGFiZWxcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb2xvciBsZWdlbmQgY29uZmlnIChsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSBkYXRhLWRyaXZlbiBjb2xvdXIgY2xhc3NlcylcclxuICAgIG91dC5jb2xvckxlZ2VuZCA9IHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxMixcclxuICAgICAgICB0aXRsZVBhZGRpbmc6IDEwLCAvL3BhZGRpbmcgYmV0d2VlbiB0aXRsZSBhbmQgbGVnZW5kIGJvZHlcclxuICAgICAgICBtYXJnaW5Ub3A6IDMwLCAvLyBtYXJnaW4gdG9wIChkaXN0YW5jZSBiZXR3ZWVuIGNvbG9yIGFuZCBzaXplIGxlZ2VuZClcclxuICAgICAgICBzaGFwZVdpZHRoOiAyNSwgLy90aGUgd2lkdGggb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgICAgICBzaGFwZUhlaWdodDogMjAsIC8vdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgICAgIHNoYXBlUGFkZGluZzogMSwgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBsZWdlbmQgc2hhcGUgZWxlbWVudHMgaW4gdGhlIGNvbG9yIGxlZ2VuZFxyXG4gICAgICAgIGxhYmVsT2Zmc2V0OiB7IHg6IDUsIHk6IDAgfSwgLy9kaXN0YW5jZSAoeCkgYmV0d2VlbiBsYWJlbCB0ZXh0IGFuZCBpdHMgY29ycmVzcG9uZGluZyBzaGFwZSBlbGVtZW50XHJcbiAgICAgICAgZGVjaW1hbHM6IDAsIC8vdGhlIG51bWJlciBvZiBkZWNpbWFsIGZvciB0aGUgbGVnZW5kIGxhYmVsc1xyXG4gICAgICAgIGxhYmVsRm9ybWF0dGVyOiB1bmRlZmluZWQsIC8vIHVzZXItZGVmaW5lZCBkMyBmb3JtYXQgZnVuY3Rpb25cclxuICAgICAgICBsYWJlbFR5cGU6ICd0aHJlc2hvbGRzJywgLy8gdHlwZSBvZiBsYWJlbHMgdG8gc2hvdzogdGhyZXNob2xkcyBvciByYW5nZXNcclxuICAgICAgICBsYWJlbHM6IG51bGwsIC8vIHVzZXItZGVmaW5lZCBsYWJlbHMgZm9yIGVhY2ggY2xhc3NcclxuICAgICAgICBub0RhdGE6IHRydWUsIC8vc2hvdyBubyBkYXRhXHJcbiAgICAgICAgbm9EYXRhVGV4dDogJ05vIGRhdGEnLCAvL25vIGRhdGEgdGV4dCBsYWJlbFxyXG4gICAgICAgIHNlcExpbmVMZW5ndGg6IDI0LCAvLyAvL3RoZSBzZXBhcmF0aW9uIGxpbmUgbGVuZ3RoXHJcbiAgICAgICAgc2VwTGluZVN0cm9rZTogJ2JsYWNrJywgLy90aGUgc2VwYXJhdGlvbiBsaW5lIGNvbG9yXHJcbiAgICAgICAgc2VwTGluZVN0cm9rZVdpZHRoOiAxLCAvL3RoZSBzZXBhcmF0aW9uIGxpbmUgd2lkdGhcclxuICAgICAgICB0aWNrTGVuZ3RoOiA1LCAvLyB0aHJlc2hvbGQgdGlja3MgbGVuZ3RoIGluIHB4XHJcbiAgICB9XHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT0gJ2NvbG9yTGVnZW5kJyB8fCBrZXkgPT0gJ3NpemVMZWdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIGluIG91dFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9vdmVycmlkZSBlYWNoIHByb3BlcnR5IGluIHNpemUgYW5kIGNvbG9yIGxlZ2VuZCBjb25maWdzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldW3BdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV1bcF0gPSBjb25maWdba2V5XVtwXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuY29sb3JMZWdlbmQgPT0gZmFsc2UpIG91dC5jb2xvckxlZ2VuZCA9IGZhbHNlXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGlmIChvdXQubGdnLm5vZGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcblxyXG4gICAgICAgICAgICAvL3JlbW92ZSBwcmV2aW91cyBjb250ZW50XHJcbiAgICAgICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgICAgICBvdXQubWFrZUJhY2tncm91bmRCb3goKVxyXG5cclxuICAgICAgICAgICAgLy8gcmVzZXQgaGVpZ2h0IGNvdW50ZXJzXHJcbiAgICAgICAgICAgIG91dC5zaXplTGVnZW5kLl90b3RhbEJhcnNIZWlnaHQgPSAwXHJcbiAgICAgICAgICAgIG91dC5zaXplTGVnZW5kLl90b3RhbEQzU3ltYm9sc0hlaWdodCA9IDBcclxuXHJcbiAgICAgICAgICAgIC8vIGxlZ2VuZCBmb3Igc2l6ZVxyXG4gICAgICAgICAgICBvdXQuX3NpemVMZWdlbmROb2RlID0gbGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3NpemUtbGVnZW5kLWNvbnRhaW5lcicpXHJcbiAgICAgICAgICAgIGlmIChtLmNsYXNzaWZpZXJTaXplXykge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRTaXplTGVnZW5kKG0sIG91dC5zaXplTGVnZW5kKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGxlZ2VuZCBmb3IgcHMgY29sb3IgdmFsdWVzXHJcbiAgICAgICAgICAgIG91dC5fY29sb3JMZWdlbmROb2RlID0gbGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2NvbG9yLWxlZ2VuZC1jb250YWluZXInKVxyXG5cclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gaXQgYmVsb3cgc2l6ZSBsZWdlbmRcclxuICAgICAgICAgICAgaWYgKG91dC5fc2l6ZUxlZ2VuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG91dC5fY29sb3JMZWdlbmROb2RlLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwke291dC5fc2l6ZUxlZ2VuZE5vZGUubm9kZSgpLmdldEJCb3goKS5oZWlnaHR9KWApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChtLmNsYXNzaWZpZXJDb2xvcl8gJiYgb3V0LmNvbG9yTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZENvbG9yTGVnZW5kKG0sIG91dC5jb2xvckxlZ2VuZClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIG91dC5zZXRCb3hEaW1lbnNpb24oKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBhIGxlZ2VuZCB3aGljaCBpbGx1c3RyYXRlcyB0aGUgc3RhdGlzdGljYWwgdmFsdWVzIG9mIGRpZmZlcmVudCBzeW1ib2wgc2l6ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gY29udGFpbmVyIHBhcmVudCBsZWdlbmQgb2JqZWN0IGZyb20gY29yZS9sZWdlbmQuanNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRTaXplTGVnZW5kKG0pIHtcclxuICAgICAgICBpZiAoIW0ucHNDdXN0b21TVkdfICYmIG0ucHNTaGFwZV8gPT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgYnVpbGRDaXJjbGVMZWdlbmQobSwgb3V0LnNpemVMZWdlbmQpXHJcbiAgICAgICAgICAgIGlmIChvdXQuc2l6ZUxlZ2VuZC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodCArIDI1XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcbiAgICAgICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5zaXplTGVnZW5kLm5vRGF0YVRleHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfSBlbHNlIGlmIChtLnBzU2hhcGVfID09ICdzcGlrZScpIHtcclxuICAgICAgICAgICAgYnVpbGRTcGlrZUxlZ2VuZChtLCBvdXQuc2l6ZUxlZ2VuZClcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RlZmluZSBmb3JtYXQgZm9yIGxhYmVsc1xyXG4gICAgICAgIGxldCBsYWJlbEZvcm1hdHRlciA9IG91dC5zaXplTGVnZW5kLmxhYmVsRm9ybWF0dGVyIHx8IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvclxyXG4gICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSkge1xyXG4gICAgICAgICAgICBvdXQuX3NpemVMZWdlbmROb2RlXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5zaXplTGVnZW5kLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGRvbWFpbiA9IG0uY2xhc3NpZmllclNpemVfLmRvbWFpbigpXHJcbiAgICAgICAgbGV0IG1heFZhbCA9IGRvbWFpblsxXSAvL21heGltdW0gdmFsdWUgb2YgZGF0YXNldCAodXNlZCBmb3IgZmlyc3Qgb3IgbGFzdCBzeW1ib2wgYnkgZGVmYXVsdClcclxuXHJcbiAgICAgICAgLy8gaWYgdXNlciBkZWZpbmVzIHZhbHVlcyBmb3IgbGVnZW5kIG1hbnVhbGx5XHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLnZhbHVlcykge1xyXG4gICAgICAgICAgICBvdXQuc2l6ZUxlZ2VuZC5jZWxsTmIgPSBvdXQuc2l6ZUxlZ2VuZC52YWx1ZXMubGVuZ3RoXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGVsZW1lbnRzIGZvciBjbGFzc2VzOiBzeW1ib2wgKyBsYWJlbFxyXG5cclxuICAgICAgICAvLyBmb3IgY3VzdG9tIHBhdGhzXHJcbiAgICAgICAgbS5jdXN0b21TeW1ib2xzID0geyBub2RlSGVpZ2h0czogMCB9IC8vIHNhdmUgc29tZSBjdXN0b20gc2V0dGluZ3MgZm9yIGJ1aWxkQ3VzdG9tU1ZHSXRlbVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG91dC5zaXplTGVnZW5kLmNlbGxOYiArIDE7IGkrKykge1xyXG4gICAgICAgICAgICAvL2RlZmluZSBjbGFzcyBudW1iZXJcclxuICAgICAgICAgICAgY29uc3QgYyA9IG91dC5hc2NlbmRpbmcgPyBvdXQuc2l6ZUxlZ2VuZC5jZWxsTmIgLSBpICsgMSA6IGlcclxuICAgICAgICAgICAgLy9kZWZpbmUgcmF3IHZhbHVlXHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBvdXQuc2l6ZUxlZ2VuZC52YWx1ZXMgPyBvdXQuc2l6ZUxlZ2VuZC52YWx1ZXNbYyAtIDFdIDogbWF4VmFsIC8gY1xyXG4gICAgICAgICAgICAvL2NhbGN1bGF0ZSBzaGFwZSBzaXplXHJcbiAgICAgICAgICAgIGxldCBzeW1ib2xTaXplID0gbS5jbGFzc2lmaWVyU2l6ZV8odmFsKVxyXG5cclxuICAgICAgICAgICAgaWYgKG0ucHNTaGFwZV8gPT0gJ2JhcicpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkQmFyc0l0ZW0obWFwLCB2YWwsIHN5bWJvbFNpemUsIGksIGxhYmVsRm9ybWF0dGVyKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG0ucHNTaGFwZV8gPT0gJ2N1c3RvbScgfHwgbS5wc0N1c3RvbVNWR18pIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkQ3VzdG9tU1ZHSXRlbShtYXAsIHZhbCwgc3ltYm9sU2l6ZSwgaSwgbGFiZWxGb3JtYXR0ZXIpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZEQzU3ltYm9sSXRlbShtYXAsIHZhbCwgc3ltYm9sU2l6ZSwgaSwgbGFiZWxGb3JtYXR0ZXIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvdXQuc2l6ZUxlZ2VuZC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgbGV0IHkgPSBvdXQuX3NpemVMZWdlbmROb2RlLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHkgKz0gb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0ICsgNVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbm8tZGF0YS1sZWdlbmQnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG5cclxuICAgICAgICAgICAgYnVpbGROb0RhdGFMZWdlbmQoY29udGFpbmVyLCBvdXQuc2l6ZUxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZFNwaWtlTGVnZW5kKG1hcCwgc2l6ZUxlZ2VuZENvbmZpZykge1xyXG4gICAgICAgIGNvbnN0IHNwaWtlID0gKGxlbmd0aCwgd2lkdGggPSBtYXAucHNTcGlrZVdpZHRoXykgPT4gYE0key13aWR0aCAvIDJ9LDBMMCwkey1sZW5ndGh9TCR7d2lkdGggLyAyfSwwYFxyXG5cclxuICAgICAgICBsZXQgbWF4U2l6ZSA9IG1hcC5jbGFzc2lmaWVyU2l6ZV8obWFwLmNsYXNzaWZpZXJTaXplXy5kb21haW4oKVsxXSlcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHZhbHVlcyBmb3IgdGhlIGxlZ2VuZFxyXG4gICAgICAgIGxldCBsZWdlbmRWYWx1ZXMgPSBvdXQuc2l6ZUxlZ2VuZC52YWx1ZXMgfHwgbWFwLmNsYXNzaWZpZXJTaXplXy50aWNrcyg0KS5zbGljZSgxKSAvLyBVc2UgdXNlci1kZWZpbmVkIHZhbHVlcyBvciBkZWZhdWx0IHRpY2tzXHJcblxyXG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC1sYWJlbCcpIC8vIEFkanVzdCBmb250IHNpemVcclxuICAgICAgICBjb25zdCBsYWJlbFNwYWNpbmcgPSBmb250U2l6ZSAtIDIgLy8gRW5zdXJlIGxhYmVscyBhcmUganVzdCBiZWxvdyB0aGUgc3Bpa2VzXHJcblxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IG91dC5fc2l6ZUxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1zcGlrZS1sZWdlbmQnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nICsgNX0sMClgKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIGAke2ZvbnRTaXplfXB4YClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgpXHJcbiAgICAgICAgICAgIC5kYXRhKGxlZ2VuZFZhbHVlcykgLy8gTm93IHVzZXMgdXNlci1kZWZpbmVkIHZhbHVlcyBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgICAuam9pbignZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4gYHRyYW5zbGF0ZSgkezQwICogaSArIG91dC5ib3hQYWRkaW5nfSwke21heFNpemUgKyA1fSlgKSAvLyBJbmNyZWFzZSBzcGFjaW5nXHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBzcGlrZXNcclxuICAgICAgICBsZWdlbmRcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgbWFwLnBzRmlsbF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCBtYXAucHNGaWxsT3BhY2l0eV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBtYXAucHNTdHJva2VfKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgbWFwLnBzU3Ryb2tlV2lkdGhfKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIChkKSA9PiBzcGlrZShtYXAuY2xhc3NpZmllclNpemVfKGQpKSkgLy8gQ29ycmVjdGx5IG1hcHMgdmFsdWVzIHRvIHNwaWtlIHNpemVcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGxhYmVscyBkaXJlY3RseSBiZWxvdyBlYWNoIHNwaWtlXHJcbiAgICAgICAgbGVnZW5kXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgbGFiZWxTcGFjaW5nKSAvLyBFbnN1cmUgdGV4dCBpcyByaWdodCBiZWxvdyBzcGlrZXNcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IG1hcC5jbGFzc2lmaWVyU2l6ZV8udGlja0Zvcm1hdCg0LCAncycpKGQpKVxyXG5cclxuICAgICAgICAvLyDwn5S5IEFkZCBcIk5vIERhdGFcIiBpdGVtIHdpdGggbW9yZSBzcGFjaW5nXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgbGFzdExhYmVsWSA9IG1heFNpemUgKyBsYWJlbFNwYWNpbmcgKyBmb250U2l6ZSArIDUgLy8gQWRqdXN0IHBvc2l0aW9uIGJlbG93IHRoZSBsYWJlbHNcclxuICAgICAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke2xhc3RMYWJlbFl9KWApXHJcbiAgICAgICAgICAgIGJ1aWxkTm9EYXRhTGVnZW5kKGNvbnRhaW5lciwgb3V0LnNpemVMZWdlbmQubm9EYXRhVGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgZnVuY3Rpb24gYnVpbGROb0RhdGFMZWdlbmQoY29udGFpbmVyLCBub0RhdGFUZXh0KSB7XHJcbiAgICAgICAgbGV0IG0gPSBvdXQubWFwXHJcblxyXG4gICAgICAgIC8vYXBwZW5kIHN5bWJvbCAmIHN0eWxlXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuY29sb3JMZWdlbmQgPyBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aCA6IG91dC5ub0RhdGFTaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LmNvbG9yTGVnZW5kID8gb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0IDogb3V0Lm5vRGF0YVNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgJ25kJylcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8nbm8gZGF0YScgbGFiZWxcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAuYXR0cigneCcsIG91dC5jb2xvckxlZ2VuZCA/IG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoICsgb3V0LmNvbG9yTGVnZW5kLmxhYmVsT2Zmc2V0LnggOiBvdXQubm9EYXRhU2hhcGVXaWR0aCArIDUpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmNvbG9yTGVnZW5kID8gb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0IC8gMiA6IG91dC5ub0RhdGFTaGFwZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgIC50ZXh0KG5vRGF0YVRleHQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGVjbCkge1xyXG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSB0aGlzIHRvIGVzdGF0IGxvZ2ljIG9mIG1ha2luZyBhbGwgb3RoZXIgY2xhc3NlcyB0cmFuc3BhcmVudD9cclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IHNlbCA9IG1hcC5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChcIltlY2w9J1wiICsgZWNsICsgXCInXVwiKVxyXG4gICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG1hcC5ob3ZlckNvbG9yKCkpXHJcbiAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IHNlbCA9IG1hcC5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChcIltlY2w9J1wiICsgZWNsICsgXCInXVwiKVxyXG4gICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYnVpbGRzIGEgc2l6ZSBsZWdlbmQgaXRlbSBmb3IgcHJvcG9ydGlvbmFsIEQzIHNoYXBlcyAoZS5nLiBzcXVhcmUsIHRyaWFuZ2xlLCBzdGFyKVxyXG4gICAgICogQHBhcmFtIHsqfSBtIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN5bWJvbFNpemUgdGhlIHNpemUgb2YgdGhlIHN5bWJvbCBpdGVtXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRDNTeW1ib2xJdGVtKG0sIHZhbHVlLCBzeW1ib2xTaXplLCBpbmRleCwgbGFiZWxGb3JtYXR0ZXIpIHtcclxuICAgICAgICBsZXQgc3ltYm9sSGVpZ2h0ID0gb3V0Lm1hcC5wc1NoYXBlXyA9PSAndHJpYW5nbGUnIHx8IG91dC5tYXAucHNTaGFwZV8gPT0gJ2RpYW1vbmQnID8gc3ltYm9sU2l6ZSA6IHN5bWJvbFNpemUgLyAyXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLl90b3RhbEQzU3ltYm9sc0hlaWdodCA9PSAwKSBvdXQuc2l6ZUxlZ2VuZC5fdG90YWxEM1N5bWJvbHNIZWlnaHQgKz0gc3ltYm9sSGVpZ2h0ICsgb3V0LmJveFBhZGRpbmcgLy9hZGQgZmlyc3QgaXRlbSBoZWlnaHQgdG8geVxyXG4gICAgICAgIGxldCBtYXhTaXplID0gbS5jbGFzc2lmaWVyU2l6ZV8obS5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClbMV0pXHJcbiAgICAgICAgLy8geCBhbmQgeSBwb3NpdGlvbiBvZiBpdGVtIGluIGxlZ2VuZFxyXG4gICAgICAgIGxldCB4ID0gbWF4U2l6ZVxyXG4gICAgICAgIGxldCB5ID1cclxuICAgICAgICAgICAgKG91dC5zaXplTGVnZW5kLnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuc2l6ZUxlZ2VuZC50aXRsZVBhZGRpbmcgOiAwKSArXHJcbiAgICAgICAgICAgIG91dC5zaXplTGVnZW5kLl90b3RhbEQzU3ltYm9sc0hlaWdodCArXHJcbiAgICAgICAgICAgIChvdXQuc2l6ZUxlZ2VuZC5zaGFwZVBhZGRpbmcgKiBpbmRleCAtIDEpXHJcblxyXG4gICAgICAgIG91dC5zaXplTGVnZW5kLl90b3RhbEQzU3ltYm9sc0hlaWdodCArPSBzeW1ib2xTaXplXHJcblxyXG4gICAgICAgIC8vY29udGFpbmVyIGZvciBzeW1ib2wgYW5kIGxhYmVsXHJcbiAgICAgICAgbGV0IGl0ZW1Db250YWluZXIgPSBvdXQuX3NpemVMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApLmF0dHIoJ2NsYXNzJywgJ2VtLXNpemUtbGVnZW5kLWl0ZW0nKVxyXG5cclxuICAgICAgICAvLyBkcmF3IEQzIHN5bWJvbFxyXG4gICAgICAgIGxldCBzaGFwZSA9IGdldFNoYXBlKClcclxuICAgICAgICBsZXQgZCA9IHNoYXBlLnNpemUoc3ltYm9sU2l6ZSAqIHN5bWJvbFNpemUpKClcclxuICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAvLyAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYClcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHNlY29uZGFyeSBzdGF0IHZhcmlhYmxlIGlzIHVzZWQgZm9yIHN5bWJvbCBjb2xvdXJpbmcsIHRoZW4gZG9udCBjb2xvdXIgdGhlIGxlZ2VuZCBzeW1ib2xzIHVzaW5nIHBzRmlsbCgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5jbGFzc2lmaWVyQ29sb3JfID8gb3V0LnNpemVMZWdlbmQuc2hhcGVGaWxsIDogbS5wc0ZpbGxfXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgbS5wc0ZpbGxPcGFjaXR5KCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA6IG0ucHNTdHJva2UoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBtLnBzU3Ryb2tlV2lkdGgoKSlcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZClcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueH0sJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55fSlgXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vbGFiZWwgcG9zaXRpb25cclxuICAgICAgICBsZXQgbGFiZWxYID0gbWF4U2l6ZSAvIDIgKyBvdXQuc2l6ZUxlZ2VuZC5sYWJlbE9mZnNldC54ICsgb3V0LmJveFBhZGRpbmdcclxuXHJcbiAgICAgICAgLy9hcHBlbmQgbGFiZWxcclxuICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBsYWJlbFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgLnRleHQobGFiZWxGb3JtYXR0ZXIodmFsdWUpKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBAcGFyYW0geyp9IG1cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Kn0gc3ltYm9sU2l6ZVxyXG4gICAgICogQHBhcmFtIHsqfSBpbmRleFxyXG4gICAgICogQHBhcmFtIHsqfSBsYWJlbEZvcm1hdHRlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZEN1c3RvbVNWR0l0ZW0obSwgdmFsdWUsIHN5bWJvbFNpemUsIGluZGV4LCBsYWJlbEZvcm1hdHRlcikge1xyXG4gICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmcgLy9zZXQgWCBvZmZzZXRcclxuICAgICAgICBsZXQgeVxyXG5cclxuICAgICAgICAvL2ZpcnN0IGl0ZW1cclxuICAgICAgICBpZiAoIW0uY3VzdG9tU3ltYm9scy5wcmV2U3ltYikge1xyXG4gICAgICAgICAgICB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnNpemVMZWdlbmQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5zaXplTGVnZW5kLnRpdGxlUGFkZGluZyA6IDApICsgMjBcclxuICAgICAgICAgICAgbS5jdXN0b21TeW1ib2xzLmluaXRpYWxUcmFuc2xhdGVZID0geVxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMucHJldlNjYWxlID0gc3ltYm9sU2l6ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9mb2xsb3dpbmcgaXRlbXNcclxuICAgICAgICBpZiAobS5jdXN0b21TeW1ib2xzLnByZXZTeW1iKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmV2Tm9kZSA9IG0uY3VzdG9tU3ltYm9scy5wcmV2U3ltYi5ub2RlKClcclxuICAgICAgICAgICAgbGV0IGJib3ggPSBwcmV2Tm9kZS5nZXRCQm94KClcclxuICAgICAgICAgICAgbS5jdXN0b21TeW1ib2xzLm5vZGVIZWlnaHRzID0gbS5jdXN0b21TeW1ib2xzLm5vZGVIZWlnaHRzICsgYmJveC5oZWlnaHQgKiBtLmN1c3RvbVN5bWJvbHMucHJldlNjYWxlXHJcbiAgICAgICAgICAgIHkgPSBtLmN1c3RvbVN5bWJvbHMuaW5pdGlhbFRyYW5zbGF0ZVkgKyBtLmN1c3RvbVN5bWJvbHMubm9kZUhlaWdodHMgKyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVBhZGRpbmcgKiAoaW5kZXggLSAxKVxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMucHJldlNjYWxlID0gc3ltYm9sU2l6ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb250YWluZXIgZm9yIHN5bWJvbCBhbmQgbGFiZWxcclxuICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgIC8vIGRyYXcgc3RhbmRhcmQgc3ltYm9sXHJcbiAgICAgICAgbS5jdXN0b21TeW1ib2xzLnByZXZTeW1iID0gaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNpemUtbGVnZW5kLXN5bWJvbCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBzZWNvbmRhcnkgc3RhdCB2YXJpYWJsZSBpcyB1c2VkIGZvciBzeW1ib2wgY29sb3VyaW5nLCB0aGVuIGRvbnQgY29sb3VyIHRoZSBsZWdlbmQgc3ltYm9scyB1c2luZyBwc0ZpbGwoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG0uY2xhc3NpZmllckNvbG9yXyA/IG91dC5zaXplTGVnZW5kLnNoYXBlRmlsbCA6IG0ucHNGaWxsX1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIG0ucHNGaWxsT3BhY2l0eSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIG91dC5zaXplTGVnZW5kLnNoYXBlU3Ryb2tlID8gb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgOiBtLnBzU3Ryb2tlKCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgbS5wc1N0cm9rZVdpZHRoKCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC41KVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmh0bWwob3V0Lm1hcC5wc0N1c3RvbVNWR18pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5wc0N1c3RvbVNWR18pIHJldHVybiBgdHJhbnNsYXRlKCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueH0sJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55fSkgc2NhbGUoJHtzeW1ib2xTaXplfSlgXHJcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBgdHJhbnNsYXRlKCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueH0sJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55fSlgXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vbGFiZWwgcG9zaXRpb25cclxuICAgICAgICBsZXQgbGFiZWxYID0geCArIG0uY2xhc3NpZmllclNpemVfKG0uY2xhc3NpZmllclNpemVfLmRvbWFpbigpWzBdKSArIG91dC5zaXplTGVnZW5kLmxhYmVsT2Zmc2V0LnhcclxuICAgICAgICBsZXQgbGFiZWxZID0gb3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueSAvIDIgKyAxIC8veSArIG91dC5zaXplTGVnZW5kLmxhYmVsT2Zmc2V0LnlcclxuXHJcbiAgICAgICAgLy9hcHBlbmQgbGFiZWxcclxuICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBsYWJlbFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgbGFiZWxZKVxyXG4gICAgICAgICAgICAudGV4dChsYWJlbEZvcm1hdHRlcih2YWx1ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gbVxyXG4gICAgICogQHBhcmFtIHsqfSBzeW1ib2xTaXplXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQmFyc0l0ZW0obSwgdmFsdWUsIHN5bWJvbFNpemUsIGluZGV4LCBsYWJlbEZvcm1hdHRlcikge1xyXG4gICAgICAgIC8vIGZvciB2ZXJ0aWNhbCBiYXJzIHdlIGRvbnQgdXNlIGEgZHluYW1pYyBYIG9mZnNldCBiZWNhdXNlIGFsbCBiYXJzIGhhdmUgdGhlIHNhbWUgd2lkdGhcclxuICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgLy93ZSBhbHNvIGRvbnQgbmVlZCB0aGUgeSBvZmZzZXRcclxuICAgICAgICBsZXQgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC5zaXplTGVnZW5kLnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuc2l6ZUxlZ2VuZC50aXRsZVBhZGRpbmcgOiAwKSArIG91dC5zaXplTGVnZW5kLl90b3RhbEJhcnNIZWlnaHQgKyAxMFxyXG5cclxuICAgICAgICBvdXQuc2l6ZUxlZ2VuZC5fdG90YWxCYXJzSGVpZ2h0ICs9IHN5bWJvbFNpemUgKyAxMFxyXG5cclxuICAgICAgICAvL3NldCBzaGFwZSBzaXplIGFuZCBkZWZpbmUgJ2QnIGF0dHJpYnV0ZVxyXG4gICAgICAgIGxldCBzaGFwZSA9IGdldFNoYXBlKClcclxuICAgICAgICBsZXQgZCA9IHNoYXBlLnNpemUoc3ltYm9sU2l6ZSAqIHN5bWJvbFNpemUpKClcclxuXHJcbiAgICAgICAgLy9jb250YWluZXIgZm9yIHN5bWJvbCBhbmQgbGFiZWxcclxuICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgIC8vIGRyYXcgYmFyIHN5bWJvbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBzZWNvbmRhcnkgc3RhdCB2YXJpYWJsZSBpcyB1c2VkIGZvciBzeW1ib2wgY29sb3VyaW5nLCB0aGVuIGRvbnQgY29sb3VyIHRoZSBsZWdlbmQgc3ltYm9scyB1c2luZyBwc0ZpbGwoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG0uY2xhc3NpZmllckNvbG9yXyA/IG91dC5zaXplTGVnZW5kLnNoYXBlRmlsbCA6IG0ucHNGaWxsX1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIG0ucHNGaWxsT3BhY2l0eSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIG91dC5zaXplTGVnZW5kLnNoYXBlU3Ryb2tlID8gb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgOiBtLnBzU3Ryb2tlKCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgbS5wc1N0cm9rZVdpZHRoKCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC41KVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYXAucHNDdXN0b21TVkdfKSByZXR1cm4gYHRyYW5zbGF0ZSgke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnh9LCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueX0pIHNjYWxlKCR7c3ltYm9sU2l6ZX0pYFxyXG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gYHRyYW5zbGF0ZSgke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnh9LCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueX0pYFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIC8vbGFiZWwgcG9zaXRpb25cclxuICAgICAgICBsZXQgbGFiZWxYID0geCArIG91dC5tYXAucHNCYXJXaWR0aF8gKyBvdXQuc2l6ZUxlZ2VuZC5sYWJlbE9mZnNldC54XHJcbiAgICAgICAgbGV0IGxhYmVsWSA9IHN5bWJvbFNpemUgLyAyICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueVxyXG5cclxuICAgICAgICAvL2FwcGVuZCBsYWJlbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAuYXR0cigneCcsIGxhYmVsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBsYWJlbFkpXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsRm9ybWF0dGVyKHZhbHVlKSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBidWlsZHMgYSBuZXN0ZWQgY2lyY2xlIGxlZ2VuZCBmb3IgcHJvcG9ydGlvbmFsIGNpcmNsZXNcclxuICAgICAqIEBwYXJhbSB7Kn0gbSBtYXBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRDaXJjbGVMZWdlbmQobSkge1xyXG4gICAgICAgIC8vYXNzaWduIGRlZmF1bHQgY2lyY2xlIHJhZGl1c2VzIGlmIG5vbmUgc3BlY2lmaWVkIGJ5IHVzZXJcclxuICAgICAgICBsZXQgZG9tYWluID0gbS5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClcclxuICAgICAgICBpZiAoIW91dC5zaXplTGVnZW5kLnZhbHVlcykge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGxlZ2VuZCB2YWx1ZXNcclxuICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kVmFsdWVzID0gW01hdGguZmxvb3IoZG9tYWluWzFdKSwgTWF0aC5mbG9vcihkb21haW5bMV0gLyAyKSwgTWF0aC5mbG9vcihkb21haW5bMF0pXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVzZXIgZGVmaW5lZCBsZWdlbmQgdmFsdWVzXHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZFZhbHVlcyA9IG91dC5zaXplTGVnZW5kLnZhbHVlc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgaWYgKCFvdXQuc2l6ZUxlZ2VuZC50aXRsZSAmJiBvdXQudGl0bGUpIG91dC5zaXplTGVnZW5kLnRpdGxlID0gb3V0LnRpdGxlIC8vaWYgdW5zcGVjaWZpZWQsIHNldCBzaXplIGxlZ2VuZCB0aXRsZSBhcyByb290IGxlZ2VuZCB0aXRsZVxyXG4gICAgICAgIGlmIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSkge1xyXG4gICAgICAgICAgICBvdXQuX3NpemVMZWdlbmROb2RlXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5zaXplTGVnZW5kLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG1heFJhZGl1cyA9IG0uY2xhc3NpZmllclNpemVfKG1heChvdXQuX3NpemVMZWdlbmRWYWx1ZXMpKSAvL21heGltdW0gY2lyY2xlIHJhZGl1cyB0byBiZSBzaG93biBpbiBsZWdlbmRcclxuICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nICsgbWF4UmFkaXVzXHJcbiAgICAgICAgbGV0IHkgPSBvdXQuYm94UGFkZGluZyArIG1heFJhZGl1cyAqIDIgKyAob3V0LnNpemVMZWdlbmQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5zaXplTGVnZW5kLnRpdGxlUGFkZGluZyA6IDApICsgMjBcclxuXHJcbiAgICAgICAgbGV0IGl0ZW1Db250YWluZXIgPSBvdXQuX3NpemVMZWdlbmROb2RlXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYClcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NpcmNsZS1sZWdlbmQnKVxyXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAncmlnaHQnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAgICAgLmRhdGEob3V0Ll9zaXplTGVnZW5kVmFsdWVzLmZpbHRlcigoZCkgPT4gbS5jbGFzc2lmaWVyU2l6ZV8oZCkpKSAvLyBGaWx0ZXIgZGF0YSBiZWZvcmUgYmluZGluZ1xyXG4gICAgICAgICAgICAuam9pbignZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgIC8vY2lyY2xlc1xyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1jaXJjbGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignY3knLCAoZCkgPT4gLW0uY2xhc3NpZmllclNpemVfKGQpKVxyXG4gICAgICAgICAgICAuYXR0cigncicsIG0uY2xhc3NpZmllclNpemVfKVxyXG5cclxuICAgICAgICAvL2xhYmVsc1xyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IC0xIC0gMiAqIG0uY2xhc3NpZmllclNpemVfKGQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIG1heFJhZGl1cyArIDUpXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC50b0xvY2FsZVN0cmluZygnZW4nKS5yZXBsYWNlKC8sL2dpLCAnICcpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgLy9saW5lIHBvaW50aW5nIHRvIHRvcCBvZiBjb3JyZXNwb25kaW5nIGNpcmNsZTpcclxuICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknLCAyKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdncmV5JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgMilcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gLTEgLSAyICogbS5jbGFzc2lmaWVyU2l6ZV8oZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB5XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIG1heFJhZGl1cyArIDUpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IC0xIC0gMiAqIG0uY2xhc3NpZmllclNpemVfKGQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgb2YgZGlmZmVyZW50IHN5bWJvbCBjb2xvdXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBtIG1hcFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZENvbG9yTGVnZW5kKG0pIHtcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLmxhYmVsVHlwZSA9PT0gJ3JhbmdlcycpIHtcclxuICAgICAgICAgICAgYnVpbGRDb2xvclJhbmdlc0xlZ2VuZChtKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1aWxkQ29sb3JUaHJlc2hvbGRzTGVnZW5kKG0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbG9yVGhyZXNob2xkcygpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9XHJcbiAgICAgICAgICAgIG1hcC5wc1RocmVzaG9sZHNfLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gbWFwLnBzVGhyZXNob2xkc19cclxuICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbSh7IGxlbmd0aDogbWFwLnBzQ2xhc3Nlc18gfSlcclxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKF8sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jbGFzc2lmaWVyQ29sb3JfLmludmVydEV4dGVudChpbmRleClbb3V0LmFzY2VuZGluZyA/IDAgOiAxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgxKSAvLyBSZW1vdmUgdGhlIGZpcnN0IGVudHJ5IGFuZCByZXR1cm4gdGhlIHJlc3QgYXMgYW4gYXJyYXlcclxuICAgICAgICByZXR1cm4gdGhyZXNob2xkc1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ29sb3JSYW5nZXNMZWdlbmQobSkge1xyXG4gICAgICAgIGNvbnN0IGYgPSBvdXQuY29sb3JMZWdlbmQubGFiZWxGb3JtYXR0ZXIgfHwgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yXHJcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IGdldENvbG9yVGhyZXNob2xkcygpXHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDbGFzc2VzID0gbS5wc0NsYXNzZXNfXHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5fY29sb3JMZWdlbmROb2RlXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuY29sb3JMZWdlbmQubWFyZ2luVG9wKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LmNvbG9yTGVnZW5kLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeCA9IG91dC5ib3hQYWRkaW5nXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHkgPVxyXG4gICAgICAgICAgICAgICAgb3V0LnRpdGxlRm9udFNpemUgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmNvbG9yTGVnZW5kLnRpdGxlUGFkZGluZyArXHJcbiAgICAgICAgICAgICAgICBvdXQuY29sb3JMZWdlbmQubWFyZ2luVG9wICtcclxuICAgICAgICAgICAgICAgIGkgKiAob3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0ICsgb3V0LmNvbG9yTGVnZW5kLnNoYXBlUGFkZGluZylcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IG91dC5hc2NlbmRpbmcgPyBpIDogbnVtYmVyT2ZDbGFzc2VzIC0gaSAtIDFcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Db250YWluZXIgPSBvdXQuX2NvbG9yTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgICAgICAvLyBSZWN0YW5nbGVcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbS5wc0NsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG51bWJlck9mQ2xhc3NlcykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIExhYmVsXHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aCArIG91dC5jb2xvckxlZ2VuZC5sYWJlbE9mZnNldC54KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQubGFiZWxzKSByZXR1cm4gb3V0LmNvbG9yTGVnZW5kLmxhYmVsc1tpXSAvLyB1c2VyLWRlZmluZWQgbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHJldHVybiBgPiAke2YodGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIDFdKX1gXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHRocmVzaG9sZHMubGVuZ3RoKSByZXR1cm4gYDwgJHtmKHRocmVzaG9sZHNbMF0pfWBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7Zih0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gaSAtIDFdKX0gLSA8ICR7Zih0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gaV0pfWBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPcHRpb25hbGx5IGFkZCBuby1kYXRhXHJcbiAgICAgICAgaWYgKG91dC5jb2xvckxlZ2VuZC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgbGV0IHkgPSBvdXQudGl0bGVGb250U2l6ZSArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3AgKyBudW1iZXJPZkNsYXNzZXMgKiBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgKyAyMCAvLyBhZGQgMjAgdG8gc2VwYXJhdGUgaXQgZnJvbSB0aGUgcmVzdFxyXG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb3V0Ll9jb2xvckxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbm8tZGF0YS1sZWdlbmQnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG5cclxuICAgICAgICAgICAgYnVpbGROb0RhdGFMZWdlbmQoY29udGFpbmVyLCBvdXQuY29sb3JMZWdlbmQubm9EYXRhVGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRDb2xvclRocmVzaG9sZHNMZWdlbmQobSkge1xyXG4gICAgICAgIC8vZGVmaW5lIGZvcm1hdCBmb3IgbGFiZWxzXHJcbiAgICAgICAgY29uc3QgbGFiZWxGb3JtYXR0ZXIgPSBvdXQuY29sb3JMZWdlbmQubGFiZWxGb3JtYXR0ZXIgfHwgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yXHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5fY29sb3JMZWdlbmROb2RlXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuY29sb3JMZWdlbmQubWFyZ2luVG9wKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LmNvbG9yTGVnZW5kLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geCBwb3NpdGlvbiBvZiBjb2xvciBsZWdlbmQgY2VsbHNcclxuICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcblxyXG4gICAgICAgIC8vZHJhdyBsZWdlbmQgZWxlbWVudHMgZm9yIGNsYXNzZXM6IHJlY3RhbmdsZSArIGxhYmVsXHJcbiAgICAgICAgbGV0IG51bWJlck9mQ2xhc3NlcyA9IG0ucHNDbGFzc2VzX1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2xhc3NlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmNvbG9yTGVnZW5kLnRpdGxlUGFkZGluZyArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3AgKyBpICogb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0IC8vIGFjY291bnQgZm9yIHRpdGxlICsgbWFyZ2luXHJcblxyXG4gICAgICAgICAgICAvL3RoZSBjbGFzcyBudW1iZXIsIGRlcGVuZGluZyBvbiBvcmRlclxyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBvdXQuYXNjZW5kaW5nID8gaSA6IG51bWJlck9mQ2xhc3NlcyAtIGkgLSAxXHJcblxyXG4gICAgICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fY29sb3JMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgICAgIC8vYXBwZW5kIHN5bWJvbCAmIHN0eWxlXHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG0ucHNDbGFzc1RvRmlsbFN0eWxlKCkoZWNsLCBudW1iZXJPZkNsYXNzZXMpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LmNvbG9yTGVnZW5kLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vc2VwYXJhdGlvbiBsaW5lXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtc2VwYXJhdG9yJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgMCArIG91dC5jb2xvckxlZ2VuZC5zZXBMaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIDApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aWNrIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aWNrJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG91dC5jb2xvckxlZ2VuZC5zZXBMaW5lTGVuZ3RoICsgb3V0LmNvbG9yTGVnZW5kLnRpY2tMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgMClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgICAgICBpZiAoaSA8IG51bWJlck9mQ2xhc3NlcyAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmNvbG9yTGVnZW5kLnNlcExpbmVMZW5ndGggKyBvdXQuY29sb3JMZWdlbmQudGlja0xlbmd0aCArIG91dC5jb2xvckxlZ2VuZC5sYWJlbE9mZnNldC54KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuY29sb3JMZWdlbmQubGFiZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG91dC5jb2xvckxlZ2VuZC5sYWJlbHNbaV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGFiZWxGb3JtYXR0ZXIobS5jbGFzc2lmaWVyQ29sb3JfLmludmVydEV4dGVudChvdXQuYXNjZW5kaW5nID8gZWNsICsgMSA6IGVjbCAtIDEpW291dC5hc2NlbmRpbmcgPyAwIDogMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLydubyBkYXRhJyBsZWdlbmQgYm94XHJcbiAgICAgICAgaWYgKG91dC5jb2xvckxlZ2VuZC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgbGV0IHkgPSBvdXQudGl0bGVGb250U2l6ZSArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3AgKyBudW1iZXJPZkNsYXNzZXMgKiBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgKyAyMCAvLyBhZGQgMjAgdG8gc2VwYXJhdGUgaXQgZnJvbSB0aGUgcmVzdFxyXG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb3V0Ll9jb2xvckxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbm8tZGF0YS1sZWdlbmQnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG5cclxuICAgICAgICAgICAgYnVpbGROb0RhdGFMZWdlbmQoY29udGFpbmVyLCBvdXQuY29sb3JMZWdlbmQubm9EYXRhVGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gcmV0dXJucyB0aGUgZDMuc3ltYm9sIG9iamVjdCBjaG9zZW4gYnkgdGhlIHVzZXJcclxuICAgICAqIEByZXR1cm4ge2QzLnNoYXBlIHx8IFNWR31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0U2hhcGUoKSB7XHJcbiAgICAgICAgbGV0IHNoYXBlXHJcbiAgICAgICAgaWYgKG91dC5tYXAucHNDdXN0b21TVkdfKSB7XHJcbiAgICAgICAgICAgIHNoYXBlID0gb3V0Lm1hcC5wc0N1c3RvbVNWR19cclxuICAgICAgICB9IGVsc2UgaWYgKG91dC5tYXAucHNDdXN0b21TaGFwZV8pIHtcclxuICAgICAgICAgICAgc2hhcGUgPSBvdXQubWFwLnBzQ3VzdG9tU2hhcGVfXHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXQubWFwLnBzU2hhcGVfID09ICdiYXInKSB7XHJcbiAgICAgICAgICAgIC8vZm9yIHJlY3RhbmdsZXMsIHdlIHVzZSBhIGN1c3RvbSBkMyBzeW1ib2xcclxuICAgICAgICAgICAgbGV0IGRyYXdSZWN0YW5nbGUgPSAoY29udGV4dCwgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IE1hdGguc3FydChzaXplKVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMClcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIGhlaWdodClcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKG91dC5tYXAucHNCYXJXaWR0aF8sIGhlaWdodClcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKG91dC5tYXAucHNCYXJXaWR0aF8sIDApXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAwKVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNoYXBlID0gc3ltYm9sKCkudHlwZSh7IGRyYXc6IGRyYXdSZWN0YW5nbGUgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgc3ltYm9sVHlwZSA9IHN5bWJvbHNMaWJyYXJ5W291dC5tYXAucHNTaGFwZV9dIHx8IHN5bWJvbHNMaWJyYXJ5WydjaXJjbGUnXVxyXG4gICAgICAgICAgICBzaGFwZSA9IHN5bWJvbCgpLnR5cGUoc3ltYm9sVHlwZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNoYXBlXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHJlZ2lvbnMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsKSB7XHJcbiAgICAgICAgLy9mb3IgcHMsIHRoZSBzeW1ib2xzIGFyZSB0aGUgY2hpbGRyZW4gb2YgZWFjaCBlbS1wcm9wLXN5bWJvbHMgZWxlbWVudFxyXG4gICAgICAgIGNvbnN0IGFsbFN5bWJvbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJyNlbS1wcm9wLXN5bWJvbHMnKS5zZWxlY3RBbGwoJ1tlY2xdJylcclxuXHJcbiAgICAgICAgLy8gU2V0IGFsbCBzeW1ib2xzIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsU3ltYm9scy5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICBzeW1ib2wuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEhpZ2hsaWdodCBvbmx5IHRoZSBzZWxlY3RlZCByZWdpb25zIGJ5IHJlc3RvcmluZyB0aGVpciBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkU3ltYm9scyA9IGFsbFN5bWJvbHMuZmlsdGVyKFwiW2VjbD0nXCIgKyBlY2wgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsZWN0ZWRTeW1ib2xzLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IHNlbGVjdCh0aGlzLmNoaWxkTm9kZXNbMF0pXHJcbiAgICAgICAgICAgIHN5bWJvbC5zdHlsZSgnZmlsbCcsIHN5bWJvbC5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHJlZ2lvbnNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCByZWdpb25zIHRvIHRoZWlyIG9yaWdpbmFsIGNvbG9ycyBvbiBtb3VzZW91dFxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCkge1xyXG4gICAgICAgIC8vZm9yIHBzLCB0aGUgc3ltYm9scyBhcmUgdGhlIGNoaWxkcmVuIG9mIGVhY2ggZW0tcHJvcC1zeW1ib2xzIGVsZW1lbnRcclxuICAgICAgICBjb25zdCBhbGxTeW1ib2xzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJykuc2VsZWN0QWxsKCdbZWNsXScpXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCByZWdpb24ncyBvcmlnaW5hbCBjb2xvciBmcm9tIHRoZSBmaWxsX19fIGF0dHJpYnV0ZVxyXG4gICAgICAgIGFsbFN5bWJvbHMuZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gc2VsZWN0KHRoaXMuY2hpbGROb2Rlc1swXSlcclxuICAgICAgICAgICAgc3ltYm9sLnN0eWxlKCdmaWxsJywgc3ltYm9sLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIGNob3JvcGxldGggbWFwc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVXaWR0aCA9IDI1XHJcbiAgICAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZUhlaWdodCA9IDIwXHJcbiAgICAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZVBhZGRpbmcgPSA1XHJcbiAgICAvL3RoZSBmb250IHNpemUgb2YgdGhlIGxlZ2VuZCBsYWJlbFxyXG4gICAgb3V0LmxhYmVsRm9udFNpemUgPSAxMlxyXG4gICAgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubGFiZWxPZmZzZXQgPSA1XHJcbiAgICAvL3Nob3cgbm8gZGF0YVxyXG4gICAgb3V0Lm5vRGF0YSA9IHRydWVcclxuICAgIC8vbm8gZGF0YSBsYWJlbCB0ZXh0XHJcbiAgICBvdXQubm9EYXRhVGV4dCA9ICdObyBkYXRhJ1xyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgY29uc3QgbSA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBzdmdNYXAgPSBtLnN2ZygpXHJcbiAgICAgICAgY29uc3QgbGdnID0gb3V0LmxnZ1xyXG5cclxuICAgICAgICAvL3JlbW92ZSBwcmV2aW91cyBjb250ZW50XHJcbiAgICAgICAgbGdnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vZHJhdyBsZWdlbmQgYmFja2dyb3VuZCBib3hcclxuICAgICAgICBvdXQubWFrZUJhY2tncm91bmRCb3goKVxyXG5cclxuICAgICAgICAvL2RyYXcgdGl0bGVcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSB7XHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ25kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGVsZW1lbnRzIGZvciBjbGFzc2VzOiByZWN0YW5nbGUgKyBsYWJlbFxyXG4gICAgICAgIGxldCBpID0gMFxyXG4gICAgICAgIGNvbnN0IHNjcyA9IG0uY2F0Q29sb3JzKClcclxuICAgICAgICBmb3IgKGxldCBjb2RlIGluIHNjcykge1xyXG4gICAgICAgICAgICAvL3RoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArIGkgKiAob3V0LnNoYXBlSGVpZ2h0ICsgb3V0LnNoYXBlUGFkZGluZylcclxuXHJcbiAgICAgICAgICAgIC8vdGhlIGNvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IG0uY2F0Q29sb3JzKClbY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuXHJcbiAgICAgICAgICAgIC8vcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBzY3NbY29kZV0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICBzZWwucmFpc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgY29kZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgY29kZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvL2xhYmVsXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAudGV4dChtLmNhdExhYmVscygpW2NvZGVdIHx8IGNvZGUpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdmdNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJyZWN0W2NvZGU9J1wiICsgY29kZSArIFwiJ11cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbS5ob3ZlckNvbG9yKCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBtLmNhdENvbG9ycygpW2NvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdHRlcm4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwicmVjdFtjb2RlPSdcIiArIGNvZGUgKyBcIiddXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNvbClcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBpKytcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vJ25vIGRhdGEnIGxlZ2VuZCBib3hcclxuICAgICAgICBpZiAob3V0Lm5vRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyA6IDApICsgaSAqIChvdXQuc2hhcGVIZWlnaHQgKyBvdXQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG0ubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdmdNYXAuc2VsZWN0KCcjZW0tbnV0c3JnJykuc2VsZWN0QWxsKFwiW25kPSduZCddXCIpLnN0eWxlKCdmaWxsJywgbS5ob3ZlckNvbG9yKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgbS5ob3ZlckNvbG9yKCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzdmdNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnI2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ubm9EYXRhRmlsbFN0eWxlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBtLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vJ25vIGRhdGEnIGxhYmVsXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQubm9EYXRhVGV4dClcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Z01hcC5zZWxlY3QoJyNlbS1udXRzcmcnKS5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIikuc3R5bGUoJ2ZpbGwnLCBtLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHN2Z01hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5ub0RhdGFGaWxsU3R5bGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IGxlZ2VuZCBib3ggZGltZW5zaW9uc1xyXG4gICAgICAgIG91dC5zZXRCb3hEaW1lbnNpb24oKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBjb2RlKSB7XHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgncGF0dGVybicpLnNlbGVjdEFsbCgncmVjdCcpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBjb2xvcnMgaWYgbm90IGFscmVhZHkgc3RvcmVkXHJcbiAgICAgICAgYWxsUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSBzZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICghZWwuYXR0cignZGF0YS1vcmlnaW5hbC1maWxsJykpIHtcclxuICAgICAgICAgICAgICAgIGVsLmF0dHIoJ2RhdGEtb3JpZ2luYWwtZmlsbCcsIGVsLnN0eWxlKCdmaWxsJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLnN0eWxlKCdmaWxsJywgJ3doaXRlJyk7IC8vIFNldCBhbGwgcmVnaW9ucyB0byB3aGl0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKFwicGF0dGVyblwiKS5zZWxlY3RBbGwoXCJyZWN0W2NvZGU9J1wiICsgY29kZSArIFwiJ11cIik7XHJcbiAgICAgICAgc2VsZWN0ZWRSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IHNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgZWwuc3R5bGUoJ2ZpbGwnLCBlbC5hdHRyKCdkYXRhLW9yaWdpbmFsLWZpbGwnKSk7IC8vIFJlc3RvcmUgb3JpZ2luYWwgZmlsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgncGF0dGVybicpLnNlbGVjdEFsbCgncmVjdCcpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIHN0b3JlZCBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IHNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGaWxsID0gZWwuYXR0cignZGF0YS1vcmlnaW5hbC1maWxsJyk7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEZpbGwpIHtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlKCdmaWxsJywgb3JpZ2luYWxGaWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBnZXRGb250U2l6ZUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBldXJvc3RhdC1tYXAgbGVnZW5kLiBUaGlzIGlzIGFuIGFic3RyYWN0IG1ldGhvZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAvL2J1aWxkIGxlZ2VuZCBvYmplY3RcclxuICAgIGNvbnN0IG91dCA9IHt9XHJcblxyXG4gICAgLy9saW5rIG1hcCB0byBsZWdlbmRcclxuICAgIG91dC5tYXAgPSBtYXBcclxuXHJcbiAgICAvL3RoZSBTVkcgd2hlcmUgdG8gbWFrZSB0aGUgbGVnZW5kXHJcbiAgICBvdXQuc3ZnSWQgPSAnbGVnZW5kXycgKyBNYXRoLnJvdW5kKDEwZTE1ICogTWF0aC5yYW5kb20oKSlcclxuICAgIG91dC5zdmcgPSB1bmRlZmluZWRcclxuICAgIG91dC5sZ2cgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3RoZSBsZWdlbmQgZWxlbWVudCBwb3NpdGlvbiwgaW4gY2FzZSBpdCBpcyBlbWJlZGVkIHdpdGhpbiB0aGUgbWFwIFNWR1xyXG4gICAgb3V0LnggPSB1bmRlZmluZWRcclxuICAgIG91dC55ID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy90aGUgbGVnZW5kIGJveFxyXG4gICAgb3V0LmJveFBhZGRpbmcgPSA3XHJcbiAgICBvdXQuYm94T3BhY2l0eSA9IDAuN1xyXG5cclxuICAgIC8vbGVnZW5kIHRpdGxlXHJcbiAgICBvdXQudGl0bGUgPSAnJ1xyXG4gICAgLy8gd2Ugbm93IHVzZSBDU1MgaW5zdGVhZCBvZiBpbmxpbmUgc3R5bGVzXHJcbiAgICBvdXQudGl0bGVGb250U2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgLy8gd2Ugbm93IHVzZSBDU1MgaW5zdGVhZCBvZiBpbmxpbmUgc3R5bGVzXHJcbiAgICBvdXQubGFiZWxGb250U2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1sZWdlbmQtbGFiZWwnKVxyXG5cclxuICAgIC8qKiBCdWlsZCBsZWdlbmQuICovXHJcbiAgICBvdXQuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9zZXQgU1ZHIGVsZW1lbnQgYW5kIGFkZCBtYWluIGRyYXdpbmcgZ3JvdXBcclxuICAgICAgICBvdXQuc3ZnID0gc2VsZWN0KCcjJyArIG91dC5zdmdJZClcclxuICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBsZWdlbmQocylcclxuICAgICAgICBvdXQuc3ZnLnNlbGVjdEFsbCgnI2VtLWxlZ2VuZC0nICsgb3V0LnN2Z0lkKS5yZW1vdmUoKVxyXG4gICAgICAgIC8vIGFwcGVuZCBuZXcgbGVnZW5kIGdyb3VwXHJcbiAgICAgICAgb3V0LmxnZyA9IG91dC5zdmdcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1sZWdlbmQtJyArIG91dC5zdmdJZClcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGxlZ2VuZCBlbGVtZW50LlxyXG4gICAgICogVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QgdG8gYmUgZGVmaW5lZCBmb3IgZWFjaCBzcGVjaWZpYyBsZWdlbmQuXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0xlZ2VuZCB1cGRhdGUgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LnVwZGF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gb3V0LmxnZ1xyXG4gICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjb250ZW50XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgcHJvdmlkZWQgZXh0ZXJuYWwgc3ZnSWQgaGFzIGNoYW5nZWRcclxuICAgICAgICBjb25zdCBsZWdlbmRTVkcgPSBvdXQuc3ZnXHJcbiAgICAgICAgaWYgKGxlZ2VuZFNWRy5hdHRyKCdpZCcpICE9PSBtYXAubGVnZW5kXy5zdmdJZCkge1xyXG4gICAgICAgICAgICBvdXQuYnVpbGQoKSAvLyBzZXRzIG5ldyBzdmcgYW5kIGxnZ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvdXQudXBkYXRlQ29uZmlnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICAvLyBVcGRhdGUgbGVnZW5kIHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKG1hcC5sZWdlbmRfKSB7XHJcbiAgICAgICAgICAgIGRlZXBNZXJnZUV4aXN0aW5nS2V5cyhvdXQsIG1hcC5sZWdlbmRfKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9wc1xyXG4gICAgICAgIC8vIC8vIHVwZGF0ZSBsZWdlbmQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAvLyBpZiAobS5sZWdlbmRfKVxyXG4gICAgICAgIC8vICAgICBmb3IgKGxldCBrZXkgaW4gbS5sZWdlbmRfKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZvciAobGV0IHAgaW4gb3V0W2tleV0pIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgLy9vdmVycmlkZSBlYWNoIHByb3BlcnR5IGluIHNpemUgYW5kIGNvbG9yIGxlZ2VuZCBtLmxlZ2VuZF9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgaWYgKG0ubGVnZW5kX1trZXldW3BdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gbS5sZWdlbmRfW2tleV1bcF1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgb3V0W2tleV0gPSBtLmxlZ2VuZF9ba2V5XVxyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9JdCBwZXJmb3JtcyBhIHNoYWxsb3cgY29weSDigJQgbmVzdGVkIG9iamVjdHMgd2lsbCBiZSBjb3BpZWQgYnkgcmVmZXJlbmNlLCBub3QgZHVwbGljYXRlZC5cclxuICAgIC8vSXQgbW9kaWZpZXMgdGhlIHRhcmdldCBvYmplY3QgKG91dCkgaW4gcGxhY2UuXHJcbiAgICAvL1VzZWZ1bCBmb3IgbWVyZ2luZyBvYmplY3RzIG9yIGV4dGVuZGluZyBleGlzdGluZyBvbmVzLlxyXG4gICAgZnVuY3Rpb24gZGVlcE1lcmdlRXhpc3RpbmdLZXlzKHRhcmdldCwgc291cmNlLCBvcHRpb25zID0ge30sIHNlZW4gPSBuZXcgV2Vha1NldCgpLCBkZXB0aCA9IDApIHtcclxuICAgICAgICBjb25zdCBNQVhfREVQVEggPSBvcHRpb25zLm1heERlcHRoIHx8IDEwMFxyXG5cclxuICAgICAgICBpZiAoc2Vlbi5oYXModGFyZ2V0KSkgcmV0dXJuIHRhcmdldFxyXG4gICAgICAgIHNlZW4uYWRkKHRhcmdldClcclxuXHJcbiAgICAgICAgaWYgKGRlcHRoID4gTUFYX0RFUFRIKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgTWF4IHJlY3Vyc2lvbiBkZXB0aCAoJHtNQVhfREVQVEh9KSByZWFjaGVkLmApXHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkgJiYgdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbCA9IHNvdXJjZVtrZXldXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBmdW5jdGlvbnM6IG92ZXJ3cml0ZSBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VWYWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVZhbFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbmVzdGVkIHBsYWluIG9iamVjdHNcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2VWYWwpICYmIGlzUGxhaW5PYmplY3QodGFyZ2V0VmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZXBNZXJnZUV4aXN0aW5nS2V5cyh0YXJnZXRWYWwsIHNvdXJjZVZhbCwgb3B0aW9ucywgc2VlbiwgZGVwdGggKyAxKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYXJyYXlzOiBvdmVyd3JpdGUgKG9yIG1lcmdlIGlmIG9wdGlvbiBzZXQpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlVmFsKSAmJiBBcnJheS5pc0FycmF5KHRhcmdldFZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9wdGlvbnMubWVyZ2VBcnJheXMgPyBbLi4ubmV3IFNldChbLi4udGFyZ2V0VmFsLCAuLi5zb3VyY2VWYWxdKV0gOiBbLi4uc291cmNlVmFsXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgRGF0ZXNcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVmFsIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbmV3IERhdGUoc291cmNlVmFsLmdldFRpbWUoKSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIFJlZ0V4cFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBSZWdFeHAoc291cmNlVmFsKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgTWFwIGFuZCBTZXRcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVmFsIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgTWFwKHNvdXJjZVZhbClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVmFsIGluc3RhbmNlb2YgU2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgU2V0KHNvdXJjZVZhbClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIHByaW1pdGl2ZXMgYW5kIG90aGVyIHR5cGVzXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXRcclxuICAgIH1cclxuXHJcbiAgICAvLyBIZWxwZXIgdG8gY2hlY2sgZm9yIHBsYWluIG9iamVjdHNcclxuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcclxuICAgIH1cclxuXHJcbiAgICAvKiogRHJhdyBsZWdlbmQgYmFja2dyb3VuZCBib3ggKi9cclxuICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQubGdnLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2lkJywgJ2xlZ2VuZEJSJykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWJhY2tncm91bmQnKS5zdHlsZSgnb3BhY2l0eScsIG91dC5ib3hPcGFjaXR5KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zLCBlbnN1cmluZyBpdCBoYXMgc3VpdGFibGUgZGltZW5zaW9ucyB0byBmaXQgdG8gYWxsIGxlZ2VuZCBncmFwaGljIGVsZW1lbnRzICovXHJcbiAgICBvdXQuc2V0Qm94RGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdXQubGdnLm5vZGUoKSkge1xyXG4gICAgICAgICAgICAvL2dldCBsZWdlbmQgZWxlbWVudHMgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgIGNvbnN0IGJiID0gb3V0LmxnZy5ub2RlKCkuZ2V0QkJveCh7IHN0cm9rZTogdHJ1ZSB9KVxyXG4gICAgICAgICAgICAvL2FwcGx5IHRvIGxlZ2VuZCBib3ggZGltZW5zaW9uc1xyXG4gICAgICAgICAgICBjb25zdCBwID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgb3V0LnN2Z1xyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnI2xlZ2VuZEJSJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgYmIueCAtIHApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGJiLnkgLSBwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYmIud2lkdGggKyAyICogcClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBiYi5oZWlnaHQgKyAyICogcClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCwgc3R5bGUgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlT3JkaW5hbCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBzY2hlbWVTZXQzIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJ1xyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIENhdGVnb3JpY2FsTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2F0ZWdvcmljYWwnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzLCBnZXRSZWdpb25zU2VsZWN0b3IsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBhcHBseVBhdHRlcm5GaWxsIH0gZnJvbSAnLi4vY29yZS9wYXR0ZXJuLWZpbGwnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGNhdGVnb3JpY2FsIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCBmYWxzZSwgJ2N0JylcclxuXHJcbiAgICAvKiogRmlsbCBzdHlsZSBmb3IgZWFjaCBjYXRlZ29yeS9jbGFzcy4gRXguOiB7IHVyYjogXCIjZmRiNDYyXCIsIGludDogXCIjZmZmZmIzXCIsIHJ1cjogXCIjY2NlYmM1XCIgfSAqL1xyXG4gICAgb3V0LmNsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkXHJcbiAgICAvKiogVGV4dCBsYWJlbCBmb3IgZWFjaCBjYXRlZ29yeS9jbGFzcy4gRXguOiB7IFwidXJiXCI6IFwiVXJiYW5cIiwgXCJpbnRcIjogXCJJbnRlcm1lZGlhdGVcIiwgXCJydXJcIjogXCJSdXJhbFwiIH0gKi9cclxuICAgIG91dC5jbGFzc1RvVGV4dF8gPSB1bmRlZmluZWRcclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gdG9vbHRpcFRleHRGdW5DYXRcclxuXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyOiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBjbGFzcyBudW1iZXIgZnJvbSBhIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllcl8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7WydjbGFzc1RvRmlsbFN0eWxlXycsICdjbGFzc1RvVGV4dF8nLCAnbm9EYXRhRmlsbFN0eWxlXycsICd0b29sdGlwVGV4dF8nLCAnY2xhc3NpZmllcl8nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgWydjbGFzc1RvRmlsbFN0eWxlJywgJ2NsYXNzVG9UZXh0JywgJ25vRGF0YUZpbGxTdHlsZScsICd0b29sdGlwVGV4dCcsICdjbGFzc2lmaWVyJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgLy9nZXQgZG9tYWluICh1bmlxdWUgdmFsdWVzKVxyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IG91dC5zdGF0RGF0YSgpLmdldFVuaXF1ZVZhbHVlcygpXHJcblxyXG4gICAgICAgIC8vZ2V0IHJhbmdlIFswLDEsMiwzLC4uLixkb21haW4ubGVuZ3RoLTFdXHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBbLi4uQXJyYXkoZG9tYWluLmxlbmd0aCkua2V5cygpXVxyXG5cclxuICAgICAgICAvL21ha2UgY2xhc3NpZmllclxyXG4gICAgICAgIC8vb25seSB1c2UgdXNlci1kZWZpbmUgY2xhc3Nlc1xyXG4gICAgICAgIGNvbnN0IGN0ZnMgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8gPyBvdXQuY2xhc3NUb0ZpbGxTdHlsZSgpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKGN0ZnMpIHtcclxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKGN0ZnMpXHJcbiAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKFxyXG4gICAgICAgICAgICAgICAgc2NhbGVPcmRpbmFsKClcclxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGNhdGVnb3JpZXMpIC8vIE9ubHkgY2xhc3NpZnkga25vd24gY2F0ZWdvcmllc1xyXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShjYXRlZ29yaWVzLm1hcCgoXywgaSkgPT4gaSkpIC8vIEFzc2lnbiBudW1lcmljYWwgY2xhc3Nlc1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVXNlIGFsbCB1bmlxdWUgdmFsdWVzIGlmIG5vIHVzZXItZGVmaW5lZCBjbGFzc2VzIGV4aXN0XHJcbiAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKHNjYWxlT3JkaW5hbCgpLmRvbWFpbihkb21haW4pLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNsYXNzaWZpZXIgYW5kIHNldCAnZWNsJyBhdHRyaWJ1dGUgdG8gcmVnaW9ucyBiYXNlZCBvbiB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IGNsYXNzaWZ5UmVnaW9ucyA9IChyZWdpb25zKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZ2lvbnMuYXR0cignZWNsJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gJzonKSByZXR1cm4gJ25kJyAvLyBObyBkYXRhXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc05hTih2KSA/IHYgOiArdiAvLyBDb252ZXJ0IG51bWJlcnMsIGtlZXAgc3RyaW5ncyBhcyBpc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIPCflLkgRW5zdXJlIG9ubHkga25vd24gdmFsdWVzIGFyZSBjbGFzc2lmaWVkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2lmaWVyRG9tYWluID0gb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjbGFzc2lmaWVyRG9tYWluLmluY2x1ZGVzKHZhbHVlKSkgcmV0dXJuIC8vIFNraXAgdW5rbm93biB2YWx1ZXNcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNsYXNzaWZpZXIoKSh2YWx1ZSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgY2xhc3NpZnlSZWdpb25zKG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpKVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgbWl4ZWQgTlVUUyBsZXZlbCwgc2VwYXJhdGluZyBOVVRTIGxldmVsIDBcclxuICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbnV0czBSZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgncGF0aC5lbS1udXRzcmcwJylcclxuICAgICAgICAgICAgY2xhc3NpZnlSZWdpb25zKG51dHMwUmVnaW9ucylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2lmIG5vIGNvbG9yIHNwZWNpZmllZCwgdXNlIHNvbWUgZGVmYXVsdCBjb2xvcnNcclxuICAgICAgICBpZiAoIW91dC5jbGFzc1RvRmlsbFN0eWxlKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY3RmcyA9IHt9XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbSA9IG91dC5jbGFzc2lmaWVyKCkuZG9tYWluKClcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20ubGVuZ3RoOyBpKyspIGN0ZnNbZG9tW2ldXSA9IHNjaGVtZVNldDNbaSAlIDEyXVxyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShjdGZzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0c1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlTdHlsZVRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseVN0eWxlVG9NYXAob3V0KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy8gQXBwbHkgY29sb3IgYW5kIGV2ZW50cyB0byByZWdpb25zIGlmIFNWRyBleGlzdHNcclxuICAgICAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBjb25zdCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHRyYW5zaXRpb24gYW5kIHNldCBpbml0aWFsIGZpbGwgY29sb3JzIHdpdGggZGF0YS1kcml2ZW4gbG9naWNcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKG91dC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHJlZ2lvbnNGaWxsRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuZW5kKClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgY29sb3IgZm9yIGVhY2ggcmVnaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdXAgbW91c2UgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMobWFwLCByZWdpb25zKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZm9udCBjb2xvciBmb3IgZ3JpZCBjYXJ0b2dyYW1zIChjb250cmFzdClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LmdyaWRDYXJ0b2dyYW1fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnLmVtLWdyaWQtdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbG9yID0gc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsJywgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZChjZWxsQ29sb3IpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUuZXJyb3IoJ0Vycm9yIGFwcGx5aW5nIHRyYW5zaXRpb24gdG8gcmVnaW9uczonLCBlcnIpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgYWRkaXRpb25hbCBzZXR0aW5ncyBmb3IgbWl4ZWQgTlVUUyBsZXZlbCB2aWV3XHJcbiAgICAgICAgICAgIGlmIChvdXQubnV0c0xldmVsXyA9PT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVNaXhlZE5VVFMobWFwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgbGFiZWxzIGZvciBzdGF0aXN0aWNhbCB2YWx1ZXMgaWYgcmVxdWlyZWRcclxuICAgICAgICAgICAgaWYgKG91dC5sYWJlbHNfKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LmxhYmVsc18udmFsdWVzKSBvdXQudXBkYXRlVmFsdWVzTGFiZWxzKG1hcClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9hZGQgaGF0Y2hpbmcgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChvdXQucGF0dGVybkZpbGxfKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBseVBhdHRlcm5GaWxsKG1hcCwgb3V0LnBhdHRlcm5GaWxsXylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB3aGVuIG1peGluZyBkaWZmZXJlbnQgTlVUUyBsZXZlbHMgKGUuZy4gc2hvd2luZyBOVVRTIDEgYW5kIE5VVFMgMiBkYXRhIHNpbXVsdGFuZW91c2x5KVxyXG4gICAgY29uc3Qgc3R5bGVNaXhlZE5VVFMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VtLWNudHJnJykpIHJldHVybiAvLyBTa2lwIGNvdW50cnkgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVjbCB8fCBsdmwgPT09ICcwJyA/ICdibG9jaycgOiAnbm9uZSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWNsICYmIGx2bCAhPT0gJzAnID8gc3Ryb2tlIHx8ICcjNzc3JyA6IG51bGxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHNlbC5zdHlsZSgnc3Ryb2tlLXdpZHRoJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBlY2wgJiYgbHZsICE9PSAnMCcgPyBzdHJva2VXaWR0aCB8fCAwLjIgOiBudWxsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVnaW9uc0ZpbGxGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgIGNvbnN0IGVjbCA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wnKSAvLyAndGhpcycgcmVmZXJzIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XHJcbiAgICAgICAgaWYgKG91dC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSB7XHJcbiAgICAgICAgICAgIGlmICghZWNsKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJylcclxuICAgICAgICAgICAgaWYgKGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5jbGFzc1RvRmlsbFN0eWxlX1tvdXQuY2xhc3NpZmllcigpLmRvbWFpbigpW2VjbF1dXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG91dC5nZW9fID09PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXb3JsZCB0ZW1wbGF0ZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBvdXQuY250cmdGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gb3V0LmNsYXNzVG9GaWxsU3R5bGVfW291dC5jbGFzc2lmaWVyKCkuZG9tYWluKClbZWNsXV1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxsU3R5bGUgfHwgb3V0LmNudHJnRmlsbFN0eWxlX1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTlVUUyB0ZW1wbGF0ZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRyeUlkID0gcmcucHJvcGVydGllcy5pZC5zbGljZSgwLCAyKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgaWYgKGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NUb0ZpbGxTdHlsZV9bb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVtlY2xdXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zID0gZnVuY3Rpb24gKG1hcCwgcmVnaW9ucykge1xyXG4gICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG1hcC5ob3ZlckNvbG9yXykgLy8gQXBwbHkgaGlnaGxpZ2h0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24ocmcsIG91dCkpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmV2ZXJ0IHRvIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwZWNpZmljIGZ1bmN0aW9uIGZvciB0b29sdGlwIHRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcmcgVGhlIHJlZ2lvbiB0byBzaG93IGluZm9ybWF0aW9uIG9uLlxyXG4gKiBAcGFyYW0geyp9IG1hcCBUaGUgbWFwIGVsZW1lbnRcclxuICovXHJcbmNvbnN0IHRvb2x0aXBUZXh0RnVuQ2F0ID0gZnVuY3Rpb24gKHJnLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcbiAgICBpZiAocmcucHJvcGVydGllcy5pZCkge1xyXG4gICAgICAgIC8vbmFtZSBhbmQgY29kZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+JyArIHJnLnByb3BlcnRpZXMubmEgKyAnICgnICsgcmcucHJvcGVydGllcy5pZCArICcpIDwvZGl2PicpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vcmVnaW9uIG5hbWVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPicgKyByZy5wcm9wZXJ0aWVzLm5hICsgJzwvZGl2PicpXHJcbiAgICB9XHJcbiAgICAvL2dldCBzdGF0IHZhbHVlXHJcbiAgICBjb25zdCBzdiA9IG1hcC5zdGF0RGF0YSgpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgLy9jYXNlIHdoZW4gbm8gZGF0YSBhdmFpbGFibGVcclxuICAgIGlmICghc3YgfHwgKHN2LnZhbHVlICE9IDAgJiYgIXN2LnZhbHVlKSkge1xyXG4gICAgICAgIGJ1Zi5wdXNoKG1hcC5ub0RhdGFUZXh0XylcclxuICAgICAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWwgPSBzdi52YWx1ZVxyXG4gICAgaWYgKG1hcC5jbGFzc1RvVGV4dF8pIHtcclxuICAgICAgICBjb25zdCBsYmwgPSBtYXAuY2xhc3NUb1RleHRfW3ZhbF1cclxuICAgICAgICAvL2Rpc3BsYXkgbGFiZWwgYW5kIHZhbHVlXHJcbiAgICAgICAgYnVmLnB1c2goYFxyXG4gICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIj5cclxuICAgIDx0YWJsZSBjbGFzcz1cIm51dHMtdGFibGVcIj5cclxuICAgIDx0Ym9keT5cclxuICAgIDx0cj5cclxuICAgIDx0ZD5cclxuICAgICR7bGJsID8gbGJsIDogdmFsfVxyXG4gICAgPC90ZD5cclxuICAgIDwvdHI+XHJcbiAgICA8L3Rib2R5PlxyXG4gICAgPC90YWJsZT5cclxuICAgIDwvZGl2PlxyXG5gKVxyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcclxuICAgIH1cclxuICAgIC8vZGlzcGxheSBqdXN0IHZhbHVlXHJcbiAgICBidWYucHVzaChgXHJcbiAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPlxyXG4gICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgPHRib2R5PlxyXG4gICAgPHRyPlxyXG4gICAgPHRkPlxyXG4gICAgJHt2YWx9XHJcbiAgICA8L3RkPlxyXG4gICAgPC90cj5cclxuICAgIDwvdGJvZHk+XHJcbiAgICA8L3RhYmxlPlxyXG4gICAgPC9kaXY+XHJcbmApXHJcbiAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBzY2FsZVF1YW50aWxlIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IGludGVycG9sYXRlUmdiIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgQml2YXJpYXRlTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aC1iaXZhcmlhdGUnXHJcbmltcG9ydCB7IGdldENTU1Byb3BlcnR5RnJvbUNsYXNzLCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IsIGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldFJlZ2lvbnNTZWxlY3RvciwgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgYml2YXJpYXRlIGNob3JvcGxldGggbWFwLlxyXG4gKiBTZWU6IGh0dHBzOi8vZ2lzdGJvay51Y2dpcy5vcmcvYm9rLXRvcGljcy9tdWx0aXZhcmlhdGUtbWFwcGluZ1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIGZhbHNlLCAnY2hiaScpXHJcblxyXG4gICAgLy9udW1iZXIgb2YgY2xhc3NlcyBmb3IgdGhlIGNsYXNzaWZpY2F0aW9uLiBTYW1lIGZvciBib3RoIHZhcmlhYmxlcy5cclxuICAgIG91dC5udW1iZXJPZkNsYXNzZXNfID0gM1xyXG4gICAgLy9zdGV2ZW5zLmdyZWVuYmx1ZVxyXG4gICAgLy9UT0RPIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGRpdmVyZ2luZyBjb2xvciByYW1wcyA/XHJcbiAgICBvdXQuc3RhcnRDb2xvcl8gPSAnI2U4ZThlOCdcclxuICAgIG91dC5jb2xvcjFfID0gJyM3M2FlODAnXHJcbiAgICBvdXQuY29sb3IyXyA9ICcjNmM4M2I1J1xyXG4gICAgb3V0LmVuZENvbG9yXyA9ICcjMmE1YTViJ1xyXG4gICAgLy9hIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3JzIGZvciB0aGUgY2xhc3NlcyBpLGpcclxuICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlXyA9IHVuZGVmaW5lZFxyXG4gICAgLy90aGUgY2xhc3NpZmllcjogYSBmdW5jdGlvbiB3aGljaCByZXR1cm4gYSBjbGFzcyBudW1iZXIgZnJvbSBhIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllcjFfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllcjJfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSB0b29sdGlwVGV4dEZ1bkJpdlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ251bWJlck9mQ2xhc3Nlc18nLFxyXG4gICAgICAgICdzdGFydENvbG9yXycsXHJcbiAgICAgICAgJ2NvbG9yMV8nLFxyXG4gICAgICAgICdjb2xvcjJfJyxcclxuICAgICAgICAnZW5kQ29sb3JfJyxcclxuICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjFfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjJfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFsnbnVtYmVyT2ZDbGFzc2VzJywgJ3N0YXJ0Q29sb3InLCAnY29sb3IxJywgJ2NvbG9yMicsICdlbmRDb2xvcicsICdjbGFzc1RvRmlsbFN0eWxlJywgJ25vRGF0YUZpbGxTdHlsZSddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBtYWluIG1hcCdzIFNWR1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vc2V0IGNsYXNzaWZpZXJzXHJcbiAgICAgICAgY29uc3Qgc2V0dXBDbGFzc2lmaWVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0YXQxID0gb3V0LnN0YXREYXRhKCd2MScpLmdldEFycmF5KClcclxuICAgICAgICAgICAgbGV0IHN0YXQyID0gb3V0LnN0YXREYXRhKCd2MicpLmdldEFycmF5KClcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gWy4uLkFycmF5KG91dC5udW1iZXJPZkNsYXNzZXMoKSkua2V5cygpXVxyXG4gICAgICAgICAgICBpZiAoIW91dC5jbGFzc2lmaWVyMV8pIG91dC5jbGFzc2lmaWVyMShzY2FsZVF1YW50aWxlKCkuZG9tYWluKHN0YXQxKS5yYW5nZShyYW5nZSkpXHJcbiAgICAgICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIyXykgb3V0LmNsYXNzaWZpZXIyKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDIpLnJhbmdlKHJhbmdlKSlcclxuXHJcbiAgICAgICAgICAgIC8vZGVmaW5lIGJpdmFyaWF0ZSBzY2FsZVxyXG4gICAgICAgICAgICBpZiAoIW91dC5jbGFzc1RvRmlsbFN0eWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVCaXZhcmlhdGUob3V0Lm51bWJlck9mQ2xhc3NlcygpLCBvdXQuc3RhcnRDb2xvcigpLCBvdXQuY29sb3IxKCksIG91dC5jb2xvcjIoKSwgb3V0LmVuZENvbG9yKCkpXHJcbiAgICAgICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShzY2FsZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY2xhc3NpZnlSZWdpb25zID0gKHJlZ2lvbnMpID0+IHtcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDEnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJnLnByb3BlcnRpZXMuaWQubGVuZ3RoID09IDQpIGNvbnNvbGUubG9nKHJnKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIxXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMicsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyMl8oK3YpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ25kJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YxID0gb3V0LnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2MiA9IG91dC5zdGF0RGF0YSgndjInKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2MSB8fCAhc3YyKSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IHN2MS52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICB2ID0gc3YyLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY2xhc3NpZmllclxyXG4gICAgICAgIHNldHVwQ2xhc3NpZmllcnMoKVxyXG5cclxuICAgICAgICAvLyBBcHBseSBjbGFzc2lmaWNhdGlvbiBhbmQgYXNzaWduICdlY2wnIGF0dHJpYnV0ZSBiYXNlZCBvbiBtYXAgdHlwZVxyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcikpXHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgbWl4ZWQgTlVUUyBsZXZlbCwgc2VwYXJhdGluZyBOVVRTIGxldmVsIDBcclxuICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBudXRzMFJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICAgICAgY2xhc3NpZnlSZWdpb25zKG51dHMwUmVnaW9ucylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IHN0eWxlIHRvIGluc2V0c1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHNcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5U3R5bGVUb01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlTdHlsZVRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVUb01hcChtYXApIHtcclxuICAgICAgICAvL2FwcGx5IHN0eWxlIHRvIG51dHMgcmVnaW9uc1xyXG5cclxuICAgICAgICAvLyBzZXQgY29sb3VyIG9mIHJlZ2lvbnNcclxuICAgICAgICBpZiAobWFwLnN2ZygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICAgICAgbGV0IHJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMSA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wxJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMSA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDInKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsMSAmJiAhZWNsMikgcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpIC8vIEdJU0NPLTI2NzggLSBsYWNrIG9mIGRhdGEgbm8gbG9uZ2VyIG1lYW5zIG5vIGRhdGEsIGluc3RlYWQgaXQgaXMgZXhwbGljaXRseSBzZXQgdXNpbmcgJzonLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wyID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IG91dC5jbGFzc1RvRmlsbFN0eWxlKCkoK2VjbDEsICtlY2wyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvclxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgY29sb3IgZm9yIGVhY2ggcmVnaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdXAgbW91c2UgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zKG1hcCwgcmVnaW9ucylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb250IGNvbG9yIGZvciBncmlkIGNhcnRvZ3JhbXMgKGNvbnRyYXN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0LmdyaWRDYXJ0b2dyYW1fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC10ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb2xvciA9IHNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKGNlbGxDb2xvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApXHJcblxyXG4gICAgICAgICAgICBpZiAob3V0Lm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVNaXhlZE5VVFMobWFwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gbWl4aW5nIGRpZmZlcmVudCBOVVRTIGxldmVscyAoZS5nLiBzaG93aW5nIE5VVFMgMSBhbmQgTlVUUyAyIGRhdGEgc2ltdWx0YW5lb3VzbHkpXHJcbiAgICBjb25zdCBzdHlsZU1peGVkTlVUUyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBtYXAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbChnZXRSZWdpb25zU2VsZWN0b3IobWFwKSlcclxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VtLWNudHJnJykpIHJldHVybiAvLyBTa2lwIGNvdW50cnkgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wxID0gc2VsLmF0dHIoJ2VjbDEnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsMiA9IHNlbC5hdHRyKCdlY2wyJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBkaXNwbGF5IHZpc2liaWxpdHlzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBlY2wxIHx8IGVjbDIgfHwgbHZsID09PSAnMCdcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBzdHlsZXMgZWZmaWNpZW50bHlcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZGlzcGxheScsIGlzVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZScpXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChlY2wxIHx8IGVjbDIpICYmIGx2bCAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlID0gc2VsLnN0eWxlKCdzdHJva2UnKSB8fCAnIzc3NydcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHNlbC5zdHlsZSgnc3Ryb2tlLXdpZHRoJykgfHwgMC4yXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdzdHJva2UnLCBzdHJva2UpLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBzdHJva2VXaWR0aClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRNb3VzZUV2ZW50c1RvUmVnaW9ucyA9IGZ1bmN0aW9uIChtYXAsIHJlZ2lvbnMpIHtcclxuICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG1hcC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGwgPSBzZWwuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBCaXZhcmlhdGVMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG5jb25zdCBzY2FsZUJpdmFyaWF0ZSA9IGZ1bmN0aW9uIChudW1iZXJPZkNsYXNzZXMsIHN0YXJ0Q29sb3IsIGNvbG9yMSwgY29sb3IyLCBlbmRDb2xvcikge1xyXG4gICAgLy9jb2xvciByYW1wcywgYnkgcm93XHJcbiAgICBjb25zdCBjcyA9IFtdXHJcbiAgICAvL2ludGVycG9sYXRlIGZyb20gZmlyc3QgYW5kIGxhc3QgY29sdW1uc1xyXG4gICAgY29uc3QgcmFtcFMxID0gaW50ZXJwb2xhdGVSZ2Ioc3RhcnRDb2xvciwgY29sb3IxKVxyXG4gICAgY29uc3QgcmFtcDJFID0gaW50ZXJwb2xhdGVSZ2IoY29sb3IyLCBlbmRDb2xvcilcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICBjb25zdCB0ID0gaSAvIChudW1iZXJPZkNsYXNzZXMgLSAxKVxyXG4gICAgICAgIGNvbnN0IGNvbEZ1biA9IGludGVycG9sYXRlUmdiKHJhbXBTMSh0KSwgcmFtcDJFKHQpKVxyXG4gICAgICAgIGNvbnN0IHJvdyA9IFtdXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJPZkNsYXNzZXM7IGorKykgcm93LnB1c2goY29sRnVuKGogLyAobnVtYmVyT2ZDbGFzc2VzIC0gMSkpKVxyXG4gICAgICAgIGNzLnB1c2gocm93KVxyXG4gICAgfVxyXG4gICAgLy9UT0RPIGNvbXB1dGUgb3RoZXIgbWF0cml4IGJhc2VkIG9uIHJvd3MsIGFuZCBhdmVyYWdlIGJvdGg/XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wxLCBlY2wyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNzW2VjbDFdW2VjbDJdXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcGVjaWZpYyBmdW5jdGlvbiBmb3IgdG9vbHRpcCB0ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHJnIFRoZSByZWdpb24gdG8gc2hvdyBpbmZvcm1hdGlvbiBvbi5cclxuICogQHBhcmFtIHsqfSBtYXAgVGhlIG1hcCBlbGVtZW50XHJcbiAqL1xyXG5jb25zdCB0b29sdGlwVGV4dEZ1bkJpdiA9IGZ1bmN0aW9uIChyZywgbWFwKSB7XHJcbiAgICBjb25zdCBidWYgPSBbXVxyXG4gICAgLy9yZWdpb24gbmFtZVxyXG4gICAgY29uc3QgcmVnaW9uTmFtZSA9IHJnLnByb3BlcnRpZXMubmEgfHwgcmcucHJvcGVydGllcy5uYW1lXHJcbiAgICBpZiAocmcucHJvcGVydGllcy5pZCkge1xyXG4gICAgICAgIC8vbmFtZSBhbmQgY29kZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCIgPicgKyByZWdpb25OYW1lICsgJyAoJyArIHJnLnByb3BlcnRpZXMuaWQgKyAnKSA8L2Rpdj4nKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL3JlZ2lvbiBuYW1lXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIiA+JyArIHJlZ2lvbk5hbWUgKyAnPC9kaXY+JylcclxuICAgIH1cclxuXHJcbiAgICAvL3N0YXQgMSB2YWx1ZVxyXG4gICAgY29uc3Qgc3YxID0gbWFwLnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDEgPSBtYXAuc3RhdERhdGEoJ3YxJykudW5pdFRleHQoKVxyXG4gICAgLy9zdGF0IDIgdmFsdWVcclxuICAgIGNvbnN0IHN2MiA9IG1hcC5zdGF0RGF0YSgndjInKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgIGNvbnN0IHVuaXQyID0gbWFwLnN0YXREYXRhKCd2MicpLnVuaXRUZXh0KClcclxuXHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIiBzdHlsZT1cImJhY2tncm91bmQ6ICNmZmZmZmY7Y29sb3I6ICMxNzFhMjI7cGFkZGluZzogNHB4O2ZvbnQtc2l6ZToxNXB4O1wiPlxyXG4gICAgICAgIDx0YWJsZSBjbGFzcz1cIm51dHMtdGFibGVcIj5cclxuICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgPHRyPlxyXG4gICAgICAgIDx0ZD5cclxuICAgICAgICAke3N2MSAmJiBzdjEudmFsdWUgPyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YxLnZhbHVlKSA6ICcnfSAke3VuaXQxICYmIHN2MSAmJiBzdjEudmFsdWUgPyB1bml0MSA6ICcnfVxyXG4gICAgICAgICR7IXN2MSB8fCAoc3YxLnZhbHVlICE9IDAgJiYgIXN2MS52YWx1ZSkgPyBtYXAubm9EYXRhVGV4dF8gOiAnJ31cclxuICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICAgICAgPHRyPlxyXG4gICAgICAgIDx0ZD5cclxuICAgICAgICAke3N2MiAmJiBzdjIudmFsdWUgPyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YyLnZhbHVlKSA6ICcnfSAke3VuaXQyICYmIHN2MiAmJiBzdjIudmFsdWUgPyB1bml0MiA6ICcnfVxyXG4gICAgICAgICR7IXN2MiB8fCAoc3YyLnZhbHVlICE9IDAgJiYgIXN2Mi52YWx1ZSkgPyBtYXAubm9EYXRhVGV4dF8gOiAnJ31cclxuICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICAgICAgPC90Ym9keT5cclxuICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYClcclxuXHJcbiAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBzY2FsZVF1YW50aWxlIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IGludGVycG9sYXRlUmdiIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgVHJpdmFyaWF0ZUxlZ2VuZCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGgtdHJpdmFyaWF0ZSdcclxuaW1wb3J0IHsgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciwgZXhlY3V0ZUZvckFsbEluc2V0cywgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4LCBnZXRSZWdpb25zU2VsZWN0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIHRyaXZhcmlhdGUgY2hvcm9wbGV0aCBtYXAuXHJcbiAqIFNlZTogaHR0cHM6Ly9naXN0Ym9rLnVjZ2lzLm9yZy9ib2stdG9waWNzL211bHRpdmFyaWF0ZS1tYXBwaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgZmFsc2UsICdjaHRyaScpXHJcblxyXG4gICAgLy9udW1iZXIgb2YgY2xhc3NlcyBmb3IgdGhlIGNsYXNzaWZpY2F0aW9uLiBTYW1lIGZvciBib3RoIHZhcmlhYmxlcy5cclxuICAgIG91dC5udW1iZXJPZkNsYXNzZXNfID0gM1xyXG4gICAgLy9zdGV2ZW5zLmdyZWVuYmx1ZVxyXG4gICAgLy9UT0RPIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGRpdmVyZ2luZyBjb2xvciByYW1wcyA/XHJcbiAgICBvdXQuc3RhcnRDb2xvcl8gPSAnI2U4ZThlOCdcclxuICAgIG91dC5jb2xvcjFfID0gJyMwOUY4RkYnXHJcbiAgICBvdXQuY29sb3IyXyA9ICcjRjVEMzAwJ1xyXG4gICAgb3V0LmNvbG9yM18gPSAnI0ZGMTQ5MydcclxuICAgIG91dC5lbmRDb2xvcl8gPSAnIzJhNWE1YidcclxuICAgIC8vYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9ycyBmb3IgdGhlIGNsYXNzZXMgaSxqXHJcbiAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8gPSB1bmRlZmluZWRcclxuICAgIC8vdGhlIGNsYXNzaWZpZXI6IGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuIGEgY2xhc3MgbnVtYmVyIGZyb20gYSBzdGF0IHZhbHVlLlxyXG4gICAgb3V0LmNsYXNzaWZpZXIxXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmNsYXNzaWZpZXIyXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmNsYXNzaWZpZXIzXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSB0b29sdGlwVGV4dEZ1bmN0aW9uVHJpdmFyaWF0ZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ251bWJlck9mQ2xhc3Nlc18nLFxyXG4gICAgICAgICdzdGFydENvbG9yXycsXHJcbiAgICAgICAgJ2NvbG9yMV8nLFxyXG4gICAgICAgICdjb2xvcjJfJyxcclxuICAgICAgICAnY29sb3IzXycsXHJcbiAgICAgICAgJ2VuZENvbG9yXycsXHJcbiAgICAgICAgJ2NsYXNzVG9GaWxsU3R5bGVfJyxcclxuICAgICAgICAnbm9EYXRhRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpZXIxXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpZXIyXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpZXIzXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbJ251bWJlck9mQ2xhc3NlcycsICdzdGFydENvbG9yJywgJ2NvbG9yMScsICdjb2xvcjInLCAnY29sb3IzJywgJ2VuZENvbG9yJywgJ2NsYXNzVG9GaWxsU3R5bGUnLCAnbm9EYXRhRmlsbFN0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9zZXQgY2xhc3NpZmllcnNcclxuICAgICAgICBsZXQgc3RhdDEgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgIGxldCBzdGF0MiA9IG91dC5zdGF0RGF0YSgndjInKS5nZXRBcnJheSgpXHJcbiAgICAgICAgbGV0IHN0YXQzID0gb3V0LnN0YXREYXRhKCd2MycpLmdldEFycmF5KClcclxuXHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBbLi4uQXJyYXkoNykua2V5cygpXVxyXG4gICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIxXykgb3V0LmNsYXNzaWZpZXIxKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDEpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICBpZiAoIW91dC5jbGFzc2lmaWVyMl8pIG91dC5jbGFzc2lmaWVyMihzY2FsZVF1YW50aWxlKCkuZG9tYWluKHN0YXQyKS5yYW5nZShyYW5nZSkpXHJcbiAgICAgICAgaWYgKCFvdXQuY2xhc3NpZmllcjNfKSBvdXQuY2xhc3NpZmllcjMoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihzdGF0MykucmFuZ2UocmFuZ2UpKVxyXG5cclxuICAgICAgICAvL2Fzc2lnbiBjbGFzcyB0byBudXRzIHJlZ2lvbnMsIGJhc2VkIG9uIHRoZWlyIHZhbHVlXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wxJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIxXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMicsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyMl8oK3YpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDMnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjMnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjNfKCt2KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyZWdpb25DbGFzcycsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMScpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMiA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wyJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wzID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDMnKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMSA9PT0gJ25kJyB8fCBlY2wyID09PSAnbmQnIHx8IGVjbDMgPT09ICduZCcpIHJldHVybiAnbmQnIC8vIEhhbmRsZSAnbm8gZGF0YSdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tYmluZSB0aGUgY2xhc3NpZmllciByZXN1bHRzIGludG8gYSBzaW5nbGUgY2xhc3MgKDEtNylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMSAmJiAhZWNsMiAmJiAhZWNsMykgcmV0dXJuIDEgLy8gb25seSB2YXJpYWJsZSAxIHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgZWNsMiAmJiAhZWNsMykgcmV0dXJuIDIgLy8gb25seSB2YXJpYWJsZSAyIHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgIWVjbDIgJiYgZWNsMykgcmV0dXJuIDMgLy8gb25seSB2YXJpYWJsZSAzIHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMSAmJiBlY2wyICYmICFlY2wzKSByZXR1cm4gNCAvLyB2YXJpYWJsZXMgMSAmIDIgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmICFlY2wyICYmIGVjbDMpIHJldHVybiA1IC8vIHZhcmlhYmxlcyAxICYgMyBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlY2wxICYmIGVjbDIgJiYgZWNsMykgcmV0dXJuIDYgLy8gdmFyaWFibGVzIDIgJiAzIHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMSAmJiBlY2wyICYmIGVjbDMpIHJldHVybiA3IC8vIGFsbCBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyAuYXR0cignbmQnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgLy8gICAgIGNvbnN0IHN2MSA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZCkgfHwgb3V0LnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgIC8vICAgICBjb25zdCBzdjIgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgIC8vICAgICBpZiAoIXN2MSB8fCAhc3YyKSByZXR1cm5cclxuICAgICAgICAgICAgLy8gICAgIGxldCB2ID0gc3YxLnZhbHVlXHJcbiAgICAgICAgICAgIC8vICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgIC8vICAgICB2ID0gc3YyLnZhbHVlXHJcbiAgICAgICAgICAgIC8vICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gJydcclxuICAgICAgICAgICAgLy8gfSlcclxuXHJcbiAgICAgICAgICAgIC8vd2hlbiBtaXhpbmcgTlVUUywgbGV2ZWwgMCBpcyBzZXBhcmF0ZWQgZnJvbSB0aGUgcmVzdCAoY2xhc3MgbnV0c3JnMClcclxuICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGguZW0tbnV0c3JnMCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDEnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyMV8oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMicsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjInKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIyXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wzJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MycpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjNfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZGVmaW5lIHRyaXZhcmlhdGUgc2NhbGVcclxuICAgICAgICAgICAgaWYgKCFvdXQuY2xhc3NUb0ZpbGxTdHlsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IHNjYWxlVHJpdmFyaWF0ZShvdXQuY29sb3IxKCksIG91dC5jb2xvcjIoKSwgb3V0LmNvbG9yMygpKVxyXG4gICAgICAgICAgICAgICAgb3V0LmNsYXNzVG9GaWxsU3R5bGUoc2NhbGUpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vd2hlbiBtaXhpbmcgTlVUUywgbGV2ZWwgMCBpcyBzZXBhcmF0ZWQgZnJvbSB0aGUgcmVzdCAodXNpbmcgY2xhc3MgbnV0c3JnMClcclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIG1hcC5zdmdfXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5lbS1udXRzcmcwJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjInKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIxXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjJfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDMnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YzJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyM18oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzY2FsZVRyaXZhcmlhdGUgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIsIGNvbG9yMykge1xyXG4gICAgICAgIC8vIEJsZW5kaW5nIHByaW1hcnkgY29sb3JzIGFuZCB0aGVpciBvdmVybGFwc1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXBDb2xvcnMgPSBbXHJcbiAgICAgICAgICAgIG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3IxLCBjb2xvcjJdKSwgLy8gQ2xhc3MgNCAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMilcclxuICAgICAgICAgICAgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcjIsIGNvbG9yM10pLCAvLyBDbGFzcyA1IChPdmVybGFwIG9mIGNvbG9yMiBhbmQgY29sb3IzKVxyXG4gICAgICAgICAgICBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yMSwgY29sb3IzXSksIC8vIENsYXNzIDYgKE92ZXJsYXAgb2YgY29sb3IxIGFuZCBjb2xvcjMpXHJcbiAgICAgICAgICAgIG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3IxLCBjb2xvcjIsIGNvbG9yM10pLCAvLyBDbGFzcyA3IChPdmVybGFwIG9mIGFsbCB0aHJlZSlcclxuICAgICAgICBdXHJcblxyXG4gICAgICAgIC8vIENsYXNzLXRvLWNvbG9yIG1hcHBpbmdcclxuICAgICAgICBjb25zdCBjbGFzc0NvbG9ycyA9IFtcclxuICAgICAgICAgICAgY29sb3IxLCAvLyBDbGFzcyAxIChGaXJzdCBjb2xvcilcclxuICAgICAgICAgICAgY29sb3IyLCAvLyBDbGFzcyAyIChTZWNvbmQgY29sb3IpXHJcbiAgICAgICAgICAgIGNvbG9yMywgLy8gQ2xhc3MgMyAoVGhpcmQgY29sb3IpXHJcbiAgICAgICAgICAgIG92ZXJsYXBDb2xvcnNbMF0sIC8vIENsYXNzIDQgKE92ZXJsYXAgb2YgY29sb3IxIGFuZCBjb2xvcjIpXHJcbiAgICAgICAgICAgIG92ZXJsYXBDb2xvcnNbMV0sIC8vIENsYXNzIDUgKE92ZXJsYXAgb2YgY29sb3IyIGFuZCBjb2xvcjMpXHJcbiAgICAgICAgICAgIG92ZXJsYXBDb2xvcnNbMl0sIC8vIENsYXNzIDYgKE92ZXJsYXAgb2YgY29sb3IxIGFuZCBjb2xvcjMpXHJcbiAgICAgICAgICAgIG92ZXJsYXBDb2xvcnNbM10sIC8vIENsYXNzIDcgKE92ZXJsYXAgb2YgYWxsIHRocmVlKVxyXG4gICAgICAgIF1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIGZ1bmN0aW9uIHRvIGdldCBjb2xvciBiYXNlZCBvbiByZWdpb24ncyBjbGFzcyAoMSB0byA3KVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2xhc3NJbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NJbmRleCA+PSAxICYmIGNsYXNzSW5kZXggPD0gNykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzQ29sb3JzW2NsYXNzSW5kZXggLSAxXVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgLy8gUmV0dXJuIG51bGwgb3IgYSBkZWZhdWx0IGNvbG9yIGlmIHRoZSBjbGFzc0luZGV4IGlzIG91dCBvZiByYW5nZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgc3R5bGUgdG8gaW5zZXRzXHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0c1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlTdHlsZVRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseVN0eWxlVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vYXBwbHkgc3R5bGUgdG8gbnV0cyByZWdpb25zXHJcblxyXG4gICAgICAgIC8vIHNldCBjb2xvdXIgb2YgcmVnaW9uc1xyXG4gICAgICAgIGlmIChtYXAuc3ZnKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wxID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDEnKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDIgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMicpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMyA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wzJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMSA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMiA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWNsMyA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlY2wxICYmICFlY2wyICYmICFlY2wzKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJykgLy8gR0lTQ08tMjY3OCAtIGxhY2sgb2YgZGF0YSBubyBsb25nZXIgbWVhbnMgbm8gZGF0YSwgaW5zdGVhZCBpdCBpcyBleHBsaWNpdGx5IHNldCB1c2luZyAnOicuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWdpb25DbGFzcyA9IHNlbGVjdCh0aGlzKS5hdHRyKCdyZWdpb25DbGFzcycpXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gb3V0LmNsYXNzVG9GaWxsU3R5bGVfKHJlZ2lvbkNsYXNzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvclxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgY29sb3IgZm9yIGVhY2ggcmVnaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG1hcC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24ocmcsIG91dCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RmlsbCA9IHNlbC5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gVHJpdmFyaWF0ZUxlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmNvbnN0IHN0eWxlTWl4ZWROVVRTID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgbWFwLnN2ZygpXHJcbiAgICAgICAgLnNlbGVjdEFsbChnZXRSZWdpb25zU2VsZWN0b3IobWFwKSlcclxuICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VtLWNudHJnJykpIHJldHVybiAvLyBTa2lwIGNvdW50cnkgcmVnaW9uc1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG4gICAgICAgICAgICBjb25zdCBjb3VudHJ5SWQgPSByZy5wcm9wZXJ0aWVzLmlkLnNsaWNlKDAsIDIpXHJcbiAgICAgICAgICAgIHJldHVybiBlY2wgfHwgbHZsID09PSAnMCcgPyAnYmxvY2snIDogJ25vbmUnXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlID0gc2VsLnN0eWxlKCdzdHJva2UnKVxyXG4gICAgICAgICAgICByZXR1cm4gZWNsICYmIGx2bCAhPT0gJzAnID8gc3Ryb2tlIHx8ICcjNzc3JyA6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHNlbC5zdHlsZSgnc3Ryb2tlLXdpZHRoJylcclxuICAgICAgICAgICAgcmV0dXJuIGVjbCAmJiBsdmwgIT09ICcwJyA/IHN0cm9rZVdpZHRoIHx8IDAuMiA6IG51bGxcclxuICAgICAgICB9KVxyXG59XHJcblxyXG4vKipcclxuICogU3BlY2lmaWMgZnVuY3Rpb24gZm9yIHRvb2x0aXAgdGV4dC5cclxuICpcclxuICogQHBhcmFtIHsqfSByZyBUaGUgcmVnaW9uIHRvIHNob3cgaW5mb3JtYXRpb24gb24uXHJcbiAqIEBwYXJhbSB7Kn0gbWFwIFRoZSBtYXAgZWxlbWVudFxyXG4gKi9cclxuY29uc3QgdG9vbHRpcFRleHRGdW5jdGlvblRyaXZhcmlhdGUgPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgY29uc3QgYnVmID0gW11cclxuICAgIC8vcmVnaW9uIG5hbWVcclxuICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIiA+JyArIHJnLnByb3BlcnRpZXMubmEgKyAnICgnICsgcmcucHJvcGVydGllcy5pZCArICcpIDwvZGl2PicpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vcmVnaW9uIG5hbWVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiID4nICsgcmcucHJvcGVydGllcy5uYSArICc8L2Rpdj4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhdCAxIHZhbHVlXHJcbiAgICBjb25zdCBzdjEgPSBtYXAuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICBjb25zdCB1bml0MSA9IG1hcC5zdGF0RGF0YSgndjEnKS51bml0VGV4dCgpXHJcbiAgICAvL3N0YXQgMiB2YWx1ZVxyXG4gICAgY29uc3Qgc3YyID0gbWFwLnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDIgPSBtYXAuc3RhdERhdGEoJ3YyJykudW5pdFRleHQoKVxyXG4gICAgLy9zdGF0IDMgdmFsdWVcclxuICAgIGNvbnN0IHN2MyA9IG1hcC5zdGF0RGF0YSgndjMnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgIGNvbnN0IHVuaXQzID0gbWFwLnN0YXREYXRhKCd2MicpLnVuaXRUZXh0KClcclxuXHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIiBzdHlsZT1cImJhY2tncm91bmQ6ICNmZmZmZmY7Y29sb3I6ICMxNzFhMjI7cGFkZGluZzogNHB4O2ZvbnQtc2l6ZToxNXB4O1wiPlxyXG4gICAgICAgIDx0YWJsZSBjbGFzcz1cIm51dHMtdGFibGVcIj5cclxuICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgPHRyPlxyXG4gICAgICAgIDx0ZD5cclxuICAgICAgICBWYXJpYWJsZSAxOiAke3N2MSAmJiBzdjEudmFsdWUgPyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YxLnZhbHVlKSA6ICcnfSAke3VuaXQxICYmIHN2MSAmJiBzdjEudmFsdWUgPyB1bml0MSA6ICcnfVxyXG4gICAgICAgICR7IXN2MSB8fCAoc3YxLnZhbHVlICE9IDAgJiYgIXN2MS52YWx1ZSkgPyBtYXAubm9EYXRhVGV4dF8gOiAnJ31cclxuICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICAgICAgPHRyPlxyXG4gICAgICAgIDx0ZD5cclxuICAgICAgICAgVmFyaWFibGUgMjogJHtzdjIgJiYgc3YyLnZhbHVlID8gc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2Mi52YWx1ZSkgOiAnJ30gJHt1bml0MiAmJiBzdjIgJiYgc3YyLnZhbHVlID8gdW5pdDIgOiAnJ31cclxuICAgICAgICAkeyFzdjIgfHwgKHN2Mi52YWx1ZSAhPSAwICYmICFzdjIudmFsdWUpID8gbWFwLm5vRGF0YVRleHRfIDogJyd9XHJcbiAgICAgICAgPC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgICAgIDx0cj5cclxuICAgICAgICA8dGQ+XHJcbiAgICAgICAgIFZhcmlhYmxlIDM6ICR7c3YzICYmIHN2My52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjMudmFsdWUpIDogJyd9ICR7dW5pdDMgJiYgc3YzICYmIHN2My52YWx1ZSA/IHVuaXQzIDogJyd9XHJcbiAgICAgICAgJHshc3YzIHx8IChzdjMudmFsdWUgIT0gMCAmJiAhc3YzLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IG1pbiwgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUsIHNjYWxlUXVhbnRpemUsIHNjYWxlVGhyZXNob2xkIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IGludGVycG9sYXRlWWxHbkJ1IH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJ1xyXG5pbXBvcnQgeyBwaWVjZXdpc2UsIGludGVycG9sYXRlTGFiIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgQ2hvcm9wbGV0aExlZ2VuZCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGgnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldFJlZ2lvbnNTZWxlY3RvciwgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZCwgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuaW1wb3J0IHsgamVua3MsIGNrbWVhbnMgfSBmcm9tICdzaW1wbGUtc3RhdGlzdGljcydcclxuaW1wb3J0IHsgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBhcHBseVBhdHRlcm5GaWxsIH0gZnJvbSAnLi4vY29yZS9wYXR0ZXJuLWZpbGwnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGNocm9yb3BsZXRoIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCBmYWxzZSwgJ2NoJylcclxuXHJcbiAgICAvL3RoZSBudW1iZXIgb2YgY2xhc3Nlc1xyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSA3XHJcbiAgICAvL3RoZSBjbGFzc2lmaWNhdGlvbiBtZXRob2RcclxuICAgIG91dC5jbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSAncXVhbnRpbGUnIC8vIG9yOiBlcXVpbnRlciwgdGhyZXNob2xkXHJcbiAgICAvL3RoZSB0aHJlc2hvbGQsIHdoZW4gdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZCBpcyAndGhyZXNob2xkJ1xyXG4gICAgb3V0LnRocmVzaG9sZHNfID0gWzBdXHJcbiAgICAvL2NvbG9ycyB0byB1c2UgZm9yIGNsYXNzZXNcclxuICAgIG91dC5jb2xvcnNfID0gbnVsbFxyXG4gICAgLy93aGVuIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHksIGVuc3VyZSB0aGUgdGhyZXNob2xkIGFyZSBuaWNlIHJvdW5kZWQgdmFsdWVzXHJcbiAgICBvdXQubWFrZUNsYXNzaWZOaWNlXyA9IHRydWVcclxuICAgIC8vdGhlIGNvbG9yIGZ1bmN0aW9uIFswLDFdIC0+IGNvbG9yXHJcbiAgICBsZXQgZXVyb3N0YXRNdWx0aWh1ZSA9IFsnI0ZGRUI5OScsICcjRDFFOUIwJywgJyM4REQ2QjknLCAnIzU4QzFDMCcsICcjMzc5MkI2JywgJyMxMzQ4OTEnLCAnIzFkMmI2ZiddXHJcbiAgICBvdXQuY29sb3JGdW5jdGlvbl8gPSAodCkgPT4gcGllY2V3aXNlKGludGVycG9sYXRlTGFiLCBldXJvc3RhdE11bHRpaHVlKShNYXRoLm1pbihNYXRoLm1heCgwLCB0KSwgMSkpIC8vIGRlZmF1bHRcclxuICAgIC8vYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIGZyb20gdGhlIGNsYXNzIGlcclxuICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlXyA9IHVuZGVmaW5lZFxyXG4gICAgLy90aGUgY2xhc3NpZmllcjogYSBmdW5jdGlvbiB3aGljaCByZXR1cm4gYSBjbGFzcyBudW1iZXIgZnJvbSBhIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllcl8gPSB1bmRlZmluZWRcclxuICAgIC8vIHNldCB0b29sdGlwIGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gY2hvcm9wbGV0aFRvb2x0aXBGdW5jdGlvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ251bWJlck9mQ2xhc3Nlc18nLFxyXG4gICAgICAgICdjbGFzc2lmaWNhdGlvbk1ldGhvZF8nLFxyXG4gICAgICAgICd0aHJlc2hvbGRzXycsXHJcbiAgICAgICAgJ21ha2VDbGFzc2lmTmljZV8nLFxyXG4gICAgICAgICdjb2xvckZ1bmN0aW9uXycsXHJcbiAgICAgICAgJ2NsYXNzVG9GaWxsU3R5bGVfJyxcclxuICAgICAgICAnbm9EYXRhRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpZXJfJyxcclxuICAgICAgICAnY29sb3JzXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBvZiBzb21lIHNwZWNpYWwgZ2V0dGVycy9zZXR0ZXJzXHJcbiAgICBvdXQuY29sb3JGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuY29sb3JGdW5jdGlvbl9cclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LmNvbG9yRnVuY3Rpb25fID0gdlxyXG4gICAgICAgIC8vIHVwZGF0ZSBjbGFzcyBzdHlsZSBmdW5jdGlvblxyXG4gICAgICAgIGlmIChvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8pIHtcclxuICAgICAgICAgICAgLy8gaWYgZG90IGRlbnNpdHlcclxuICAgICAgICAgICAgb3V0LmNsYXNzVG9GaWxsU3R5bGUoZ2V0RmlsbFBhdHRlcm5MZWdlbmQoKSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRDb2xvckxlZ2VuZChvdXQuY29sb3JGdW5jdGlvbigpLCBvdXQuY29sb3JzXykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuICAgIG91dC50aHJlc2hvbGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC50aHJlc2hvbGRzX1xyXG4gICAgICAgIG91dC50aHJlc2hvbGRzXyA9IHZcclxuICAgICAgICBvdXQubnVtYmVyT2ZDbGFzc2VzKHYubGVuZ3RoICsgMSlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcbiAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fXHJcbiAgICAgICAgb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fID0gdlxyXG4gICAgICAgIGlmIChvdXQuc3ZnKCkpIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXyhvdXQuc3ZnKCksIG91dC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ251bWJlck9mQ2xhc3NlcycsXHJcbiAgICAgICAgICAgICdjbGFzc2lmaWNhdGlvbk1ldGhvZCcsXHJcbiAgICAgICAgICAgICd0aHJlc2hvbGQnLFxyXG4gICAgICAgICAgICAnbWFrZUNsYXNzaWZOaWNlJyxcclxuICAgICAgICAgICAgJ2NvbG9yRnVuY3Rpb24nLFxyXG4gICAgICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdub0RhdGFGaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAnY29sb3JzXycsXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChtYXApIHtcclxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSByYW5nZSBbMCwgMSwgMiwgLi4uLCBuYi0xXVxyXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlUmFuZ2UgPSAobmIpID0+IFsuLi5BcnJheShuYikua2V5cygpXVxyXG5cclxuICAgICAgICAvLyBDb25maWd1cmUgY2xhc3NpZmllciBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgY2xhc3NpZmljYXRpb24gbWV0aG9kXHJcbiAgICAgICAgY29uc3Qgc2V0dXBDbGFzc2lmaWVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBvdXQuc3RhdERhdGEoKS5nZXRBcnJheSgpXHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2VuZXJhdGVSYW5nZShvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAob3V0LmNsYXNzaWZpY2F0aW9uTWV0aG9kXykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncXVhbnRpbGUnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihkYXRhQXJyYXkpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXF1YWwtaW50ZXJ2YWwnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXF1aW50ZXInOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUXVhbnRpemUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbbWluKGRhdGFBcnJheSksIG1heChkYXRhQXJyYXkpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShyYW5nZSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYWtlQ2xhc3NpZk5pY2VfKSBvdXQuY2xhc3NpZmllcigpLm5pY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0aHJlc2hvbGQnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lm51bWJlck9mQ2xhc3NlcyhvdXQudGhyZXNob2xkc18ubGVuZ3RoICsgMSlcclxuICAgICAgICAgICAgICAgICAgICBvdXQuY2xhc3NpZmllcihzY2FsZVRocmVzaG9sZCgpLmRvbWFpbihvdXQudGhyZXNob2xkc18pLnJhbmdlKGdlbmVyYXRlUmFuZ2Uob3V0Lm51bWJlck9mQ2xhc3Nlc18pKSlcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnamVua3MnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgamVua3NCcmVha3MgPSBqZW5rcyhkYXRhQXJyYXksIG91dC5udW1iZXJPZkNsYXNzZXNfKSAvLyBDYWxjdWxhdGUgYnJlYWtzIGZvciBKZW5rc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGplbmtzQnJlYWtzLnNsaWNlKDEsIC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKHNjYWxlVGhyZXNob2xkKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKSAvLyBVc2UgSmVua3MgYnJlYWtzIGluIHNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NrbWVhbnMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNrbWVhbnMgYnJlYWtzLCBleHRyYWN0aW5nIHRoZSBtYXhpbXVtIHZhbHVlIGZyb20gZWFjaCBjbHVzdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2ttZWFuc0JyZWFrcyA9IGNrbWVhbnMoZGF0YUFycmF5LCBvdXQubnVtYmVyT2ZDbGFzc2VzXykubWFwKChjbHVzdGVyKSA9PiBjbHVzdGVyLnBvcCgpKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGRvbWFpbiBmb3Igc2NhbGVUaHJlc2hvbGQgZXhjbHVkaW5nIHRoZSBsYXN0IHZhbHVlLCBhcyBpdCBzZXJ2ZXMgYXMgdGhlIHVwcGVyIGJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gY2ttZWFuc0JyZWFrcy5zbGljZSgwLCAtMSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBja21lYW5zIGJyZWFrcyBpbiB0aGUgc2NhbGVUaHJlc2hvbGQgYW5kIHNldCB0aGUgY2xhc3NpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKHNjYWxlVGhyZXNob2xkKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNsYXNzaWZpZXIgYW5kIHNldCAnZWNsJyBhdHRyaWJ1dGUgdG8gcmVnaW9ucyBiYXNlZCBvbiB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IGNsYXNzaWZ5UmVnaW9ucyA9IChyZWdpb25zKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZ2lvbnMuYXR0cignZWNsJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25EYXRhID0gb3V0LnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lvbkRhdGEpIHJldHVybiAvLyBMYWNrIG9mIGRhdGEgaXMgaGFuZGxlZCBleHBsaWNpdGx5XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlZ2lvbkRhdGEudmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJzonIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyArb3V0LmNsYXNzaWZpZXJfKHZhbHVlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgc2V0dXBDbGFzc2lmaWVyKClcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgY2xhc3NpZmljYXRpb24gYW5kIGFzc2lnbiAnZWNsJyBhdHRyaWJ1dGUgYmFzZWQgb24gbWFwIHR5cGVcclxuICAgICAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICAgICAgY2xhc3NpZnlSZWdpb25zKG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpKVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIG1peGVkIE5VVFMgbGV2ZWwsIHNlcGFyYXRpbmcgTlVUUyBsZXZlbCAwXHJcbiAgICAgICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnV0czBSZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgncGF0aC5lbS1udXRzcmcwJylcclxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5UmVnaW9ucyhudXRzMFJlZ2lvbnMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBzdHlsZSB0byBpbnNldHNcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5U3R5bGVUb01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlTdHlsZVRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVUb01hcChtYXApIHtcclxuICAgICAgICAvLyBEZWZpbmUgZnVuY3Rpb24gdG8gZ2V0IGEgY2xhc3MnIGNvbG9yXHJcbiAgICAgICAgaWYgKG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXykge1xyXG4gICAgICAgICAgICAvLyBEb3QgZGVuc2l0eSBzdHlsZVxyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRGaWxsUGF0dGVybkxlZ2VuZCgpKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENvbG9yIGxlZ2VuZCBzdHlsZVxyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRDb2xvckxlZ2VuZChvdXQuY29sb3JGdW5jdGlvbigpLCBvdXQuY29sb3JzXykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSBjb2xvciBhbmQgZXZlbnRzIHRvIHJlZ2lvbnMgaWYgU1ZHIGV4aXN0c1xyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmQgc2V0IGluaXRpYWwgZmlsbCBjb2xvcnMgd2l0aCBkYXRhLWRyaXZlbiBsb2dpY1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgcmVnaW9uc0ZpbGxGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICByZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBhZGRNb3VzZUV2ZW50c1RvUmVnaW9ucyhtYXAsIHJlZ2lvbnMpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb250IGNvbG9yIGZvciBncmlkIGNhcnRvZ3JhbXMgKGNvbnRyYXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC10ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29sb3IgPSBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKGNlbGxDb2xvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgdHJhbnNpdGlvbiB0byByZWdpb25zOicsIGVycilcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBhZGRpdGlvbmFsIHNldHRpbmdzIGZvciBtaXhlZCBOVVRTIGxldmVsIHZpZXdcclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYWJlbHMgZm9yIHN0YXRpc3RpY2FsIHZhbHVlcyBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICBpZiAob3V0LmxhYmVsc18pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXy52YWx1ZXMpIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMobWFwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2FkZCBoYXRjaGluZyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKG91dC5wYXR0ZXJuRmlsbF8pIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5UGF0dGVybkZpbGwobWFwLCBvdXQucGF0dGVybkZpbGxfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIENob3JvcGxldGhMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiBtaXhpbmcgZGlmZmVyZW50IE5VVFMgbGV2ZWxzIChlLmcuIHNob3dpbmcgTlVUUyAxIGFuZCBOVVRTIDIgZGF0YSBzaW11bHRhbmVvdXNseSlcclxuICAgIGNvbnN0IHN0eWxlTWl4ZWROVVRTID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGRpc3BsYXkgdmlzaWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZWNsIHx8IGx2bCA9PT0gJzAnXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGVzIGVmZmljaWVudGx5XHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2Rpc3BsYXknLCBpc1Zpc2libGUgPyAnYmxvY2snIDogJ25vbmUnKVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlY2wgJiYgbHZsICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpIHx8ICcjNzc3J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKSB8fCAwLjJcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ3N0cm9rZScsIHN0cm9rZSkuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlZ2lvbnNGaWxsRnVuY3Rpb24gPSBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICBjb25zdCBlY2wgPSBzZWxlY3QodGhpcykuYXR0cignZWNsJykgLy8gJ3RoaXMnIHJlZmVycyB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykge1xyXG4gICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG91dC5nZW9fID09PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXb3JsZCB0ZW1wbGF0ZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBvdXQuY250cmdGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gb3V0LmNsYXNzVG9GaWxsU3R5bGVfKGVjbCwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsbFN0eWxlIHx8IG91dC5jbnRyZ0ZpbGxTdHlsZV9cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5VVFMgdGVtcGxhdGUgbG9naWNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50cnlJZCA9IHJnLnByb3BlcnRpZXMuaWQuc2xpY2UoMCwgMilcclxuICAgICAgICAgICAgICAgIGlmICghZWNsKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJylcclxuICAgICAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG91dC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zID0gZnVuY3Rpb24gKG1hcCwgcmVnaW9ucykge1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKSAvLyBBcHBseSBoaWdobGlnaHQgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKSAvLyBSZXZlcnQgdG8gb3JpZ2luYWwgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vL2J1aWxkIGEgY29sb3IgbGVnZW5kIG9iamVjdFxyXG5leHBvcnQgY29uc3QgZ2V0Q29sb3JMZWdlbmQgPSBmdW5jdGlvbiAoY29sb3JGdW5jdGlvbiwgY29sb3JBcnJheSkge1xyXG4gICAgY29sb3JGdW5jdGlvbiA9IGNvbG9yRnVuY3Rpb24gfHwgaW50ZXJwb2xhdGVZbEduQnVcclxuICAgIGlmIChjb2xvckFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3JBcnJheVtlY2xdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9uKGVjbCAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGEgZmlsbCBwYXR0ZXJuIGxlZ2VuZCBvYmplY3QgeyBuZDpcIndoaXRlXCIsIDA6XCJ1cmwoI3BhdHRlcm5fMClcIiwgMTpcInVybCgjcGF0dGVybl8xKVwiLCAuLi4gfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEZpbGxQYXR0ZXJuTGVnZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wpIHtcclxuICAgICAgICByZXR1cm4gJ3VybCgjcGF0dGVybl8nICsgZWNsICsgJyknXHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGNob3JvcGxldGhUb29sdGlwRnVuY3Rpb24gPSBmdW5jdGlvbiAocmVnaW9uLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcblxyXG4gICAgLy8gSGVhZGVyIHdpdGggcmVnaW9uIG5hbWUgYW5kIElEXHJcbiAgICBjb25zdCByZWdpb25OYW1lID0gcmVnaW9uLnByb3BlcnRpZXMubmEgfHwgcmVnaW9uLnByb3BlcnRpZXMubmFtZVxyXG4gICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgYnVmLnB1c2goYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj5cclxuICAgICAgICAgICAgPGI+JHtyZWdpb25OYW1lfTwvYj4ke3JlZ2lvbklkID8gYCAoJHtyZWdpb25JZH0pYCA6ICcnfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYClcclxuXHJcbiAgICAvLyBSZXRyaWV2ZSByZWdpb24ncyBkYXRhIHZhbHVlIGFuZCB1bml0XHJcbiAgICBjb25zdCBzdGF0RGF0YSA9IG1hcC5zdGF0RGF0YSgpXHJcbiAgICBjb25zdCBzdiA9IHN0YXREYXRhLmdldChyZWdpb25JZClcclxuICAgIGNvbnN0IHVuaXQgPSBzdGF0RGF0YS51bml0VGV4dCgpIHx8ICcnXHJcblxyXG4gICAgLy8gTm8gZGF0YSBjYXNlXHJcbiAgICBpZiAoIXN2IHx8IChzdi52YWx1ZSAhPT0gMCAmJiAhc3YudmFsdWUpIHx8IHN2LnZhbHVlID09PSAnOicpIHtcclxuICAgICAgICBidWYucHVzaChgXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0IG5vLWRhdGFcIj5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cIm51dHMtdGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+JHttYXAubm9EYXRhVGV4dF99PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBgKVxyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBEYXRhIGRpc3BsYXlcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPlxyXG4gICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJudXRzLXRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD4ke3NwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdi52YWx1ZSl9ICR7dW5pdH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYClcclxuXHJcbiAgICAvLyBPcHRpb25hbCBzdGF0dXMgZmxhZ1xyXG4gICAgY29uc3Qgc3RhdHVzRmxhZyA9IHN2LnN0YXR1c1xyXG4gICAgaWYgKHN0YXR1c0ZsYWcgJiYgbWFwLnRvb2x0aXBfLnNob3dGbGFncykge1xyXG4gICAgICAgIGNvbnN0IGZsYWdUZXh0ID0gbWFwLnRvb2x0aXBfLnNob3dGbGFncyA9PT0gJ3Nob3J0JyA/IHN0YXR1c0ZsYWcgOiBmbGFnc1tzdGF0dXNGbGFnXSB8fCBzdGF0dXNGbGFnXHJcbiAgICAgICAgYnVmLnB1c2goYCA8c3BhbiBjbGFzcz1cInN0YXR1cy1mbGFnXCI+JHtmbGFnVGV4dH08L3NwYW4+YClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbn1cclxuIiwiLy8gSW1wb3J0IHJlcXVpcmVkIEQzIG1vZHVsZXNcclxuLy8gaW1wb3J0IHsgc2Fua2V5LCBzYW5rZXlMaW5rSG9yaXpvbnRhbCB9IGZyb20gJ2QzLXNhbmtleSdcclxuaW1wb3J0IHsgbGlua0hvcml6b250YWwgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgc3VtLCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2NhbGVMaW5lYXIgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBGbG93TGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtZmxvdydcclxuaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgZ2V0UmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZmxvdyBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgdHJ1ZSwgJ2Zsb3cnKVxyXG4gICAgb3V0LnN0cm9rZVdpZHRoU2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICBvdXQubGFiZWxPZmZzZXRYID0gMTVcclxuICAgIG91dC5sYWJlbE9mZnNldFkgPSA1XHJcbiAgICBvdXQubGFiZWxGb3JtYXR0ZXIgPSAoZCkgPT4gZm9ybWF0KCcuMnMnKShkKVxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IGZsb3dNYXBUb29sdGlwRnVuY3Rpb25cclxuICAgIG91dC5mbG93Q29sb3JfID0gJyM3MmJiNmYnXHJcbiAgICBvdXQuZmxvd092ZXJsYXlDb2xvcnNfID0gWycjYmJkN2VlJywgJyNjN2UzYzYnXSAvLyBleHBvcnRlciwgaW1wb3J0ZXJzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmbG93bWFwLXNwZWNpZmljIHNldHRlcnMvZ2V0dGVyc1xyXG4gICAgICovXHJcbiAgICA7WydmbG93R3JhcGhfJywgJ2Zsb3dDb2xvcl8nLCAnZmxvd092ZXJsYXlDb2xvcnNfJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHR5cGU6IFwiRmVhdHVyZVwiXHJcbiAgICAgICAgLy8gcHJvcGVydGllczogT2JqZWN0IHtpZDogXCJFU1wiLCBuYTogXCJFc3Bhw7FhXCJ9XHJcbiAgICAgICAgLy8gZ2VvbWV0cnk6IE9iamVjdCB7dHlwZTogXCJNdWx0aVBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IEFycmF5KDcpfVxyXG4gICAgICAgIC8vIHNvdXJjZTogXCJGUlwiXHJcbiAgICAgICAgLy8gdGFyZ2V0OiBcIkVTXCJcclxuICAgICAgICAvLyB2YWx1ZTogNDU0MjIzMjcuNTZcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHN0cm9rZSB3aWR0aCBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBvdXQuZmxvd0dyYXBoXy5saW5rc1xyXG4gICAgICAgIG91dC5zdHJva2VXaWR0aFNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFswLCBtYXgoZGF0YSwgKGQpID0+IGQudmFsdWUpXSlcclxuICAgICAgICAgICAgLnJhbmdlKFsyLCAxMF0pXHJcblxyXG4gICAgICAgIGNyZWF0ZUZsb3dNYXBTVkcob3V0LmZsb3dHcmFwaF8pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHt9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL1RPRE86IGRlZmluZSBsZWdlbmRcclxuICAgICAgICByZXR1cm4gRmxvd0xlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY3JlYXRlIGEgbWFwIHdpdGggU2Fua2V5IGRpYWdyYW0gYW5kIG90aGVyIGVsZW1lbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGggLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIGRhdGEgZm9yIHRoZSBtYXBcclxuICAgICAqIGV4YW1wbGVHcmFwaCA9IHtcclxuICAgICAgICAgICAgICAgIG5vZGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogJ0ZSJywgeDogNjgxLjE4NTE4MDA3NTkyNjMsIHk6IDIzMC4zMTEyNDc2MzY0ODU4MyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6ICdERScsIHg6IDgyNC41NDM3NzgyMTU0NDg5LCB5OiAxMjMuNzAzMDI2NDkwMzIxOTkgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBsaW5rczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgc291cmNlOiAnRlInLCB0YXJnZXQ6ICdERScsIHZhbHVlOiA4MjAxODM2OS43MiB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93TWFwU1ZHKGdyYXBoKSB7XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gb3V0LnN2Z19cclxuXHJcbiAgICAgICAgLy8gaWYgbm9kZXMgaW4gdGhlIGdyYXBoIGRvbnQgaGF2ZSBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdGhlbiB1c2UgbnV0czJqc29uIGNlbnRyb2lkcyBpbnN0ZWFkXHJcbiAgICAgICAgYWRkQ29vcmRpbmF0ZXNUb0dyYXBoKGdyYXBoKVxyXG5cclxuICAgICAgICB2YXIgeyBub2RlcywgbGlua3MgfSA9IHNhbmtleShncmFwaClcclxuXHJcbiAgICAgICAgLy8gRGVmaW5lIG1hcmtlciBhbmQgZ3JhZGllbnQgSURzXHJcbiAgICAgICAgY29uc3QgZGVmcyA9IHN2Zy5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgICAgIGNvbnN0IGFycm93SWQgPSBnZW5lcmF0ZVVuaXF1ZUlkKCdhcnJvdycpXHJcbiAgICAgICAgY29uc3QgYXJyb3dPdXRsaW5lSWQgPSBnZW5lcmF0ZVVuaXF1ZUlkKCdhcnJvdy1vdXRsaW5lJylcclxuICAgICAgICBjb25zdCBncmFkaWVudElkcyA9IGxpbmtzLm1hcCgoKSA9PiBnZW5lcmF0ZVVuaXF1ZUlkKCdncmFkaWVudCcpKVxyXG5cclxuICAgICAgICAvLyBBZGQgYXJyb3cgbWFya2Vyc1xyXG4gICAgICAgIGFkZEFycm93TWFya2VyKGRlZnMsIGFycm93SWQsIG91dC5mbG93Q29sb3JfKVxyXG4gICAgICAgIGFkZEFycm93TWFya2VyKGRlZnMsIGFycm93T3V0bGluZUlkLCAnI2ZmZmZmZicpXHJcblxyXG4gICAgICAgIC8vIEFkZCBmbG93IGdyYWRpZW50c1xyXG4gICAgICAgIGFkZEZsb3dHcmFkaWVudHMoZGVmcywgZ3JhZGllbnRJZHMsIGxpbmtzKVxyXG5cclxuICAgICAgICAvLyBEZWZpbmUgb3VyIGNvbnRhaW5lciBTVkdcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBzZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IHNhbmtleUNvbnRhaW5lciA9IHpvb21Hcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93LWNvbnRhaW5lcicpXHJcblxyXG4gICAgICAgIC8vIEFkZCBnZW9ncmFwaGljYWwgbGF5ZXJzXHJcbiAgICAgICAgYWRkT3ZlcmxheVBvbHlnb25zKHNhbmtleUNvbnRhaW5lciwgZ3JhcGgpXHJcblxyXG4gICAgICAgIC8vIEFkZCBTYW5rZXkgZmxvd3NcclxuICAgICAgICBhZGRTYW5rZXlGbG93cyhzYW5rZXlDb250YWluZXIsIGxpbmtzLCBhcnJvd0lkLCBhcnJvd091dGxpbmVJZCwgZ3JhZGllbnRJZHMpXHJcblxyXG4gICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIG5vZGVzIChmaWxsIGdhcHMpXHJcbiAgICAgICAgYWRkRmlsbEdhcHMoc2Fua2V5Q29udGFpbmVyLCBub2RlcylcclxuXHJcbiAgICAgICAgLy8gQWRkIGxhYmVscyB0byBub2Rlc1xyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXykgYWRkTGFiZWxzKHNhbmtleUNvbnRhaW5lciwgbm9kZXMpXHJcblxyXG4gICAgICAgIHJldHVybiBzdmcubm9kZSgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGdlb2dyYXBoaWNhbCBsYXllcnMgKHJlZ2lvbnMsIFBPSSBvdmVybGF5LCBib3JkZXJzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiBTVkcgY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZE92ZXJsYXlQb2x5Z29ucyhzdmcsIGdyYXBoKSB7XHJcbiAgICAgICAgY29uc3QgaW1wb3J0ZXJJZHMgPSBbXVxyXG4gICAgICAgIGNvbnN0IGV4cG9ydGVySWRzID0gW11cclxuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IG91dC5HZW9tZXRyaWVzLmdldFJlZ2lvbkZlYXR1cmVzKClcclxuICAgICAgICBpZiAoZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgZ3JhcGgubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBmZWF0dXJlLnByb3BlcnRpZXMuaWQpIHJldHVybiBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzSW1wb3J0ZXIgPSBncmFwaC5saW5rcy5zb21lKChsaW5rKSA9PiBsaW5rLnNvdXJjZSA9PSBub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ltcG9ydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVySWRzLnB1c2gobm9kZS5pZClcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlcklkcy5wdXNoKG5vZGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjb3VsZCBub3QgZmluZCBnZW9tZXRyeSBmb3InLCBub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy91cGRhdGUgZXhpc3RpbmcgcmVnaW9uIGZpbGxzXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG91dClcclxuICAgICAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG91dC5zdmdfLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHJcbiAgICAgICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCAocmVnaW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydGVySWRzLmluY2x1ZGVzKHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKSkgcmV0dXJuIG91dC5mbG93T3ZlcmxheUNvbG9yc19bMF1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZXJJZHMuaW5jbHVkZXMocmVnaW9uLnByb3BlcnRpZXMuaWQpKSByZXR1cm4gb3V0LmZsb3dPdmVybGF5Q29sb3JzX1sxXVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgbm9kZXMgaW4gdGhlIGdyYXBoIGRvbnQgaGF2ZSBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdGhlbiB1c2UgbnV0czJqc29uIGNlbnRyb2lkcyBpbnN0ZWFkXHJcbiAgICBmdW5jdGlvbiBhZGRDb29yZGluYXRlc1RvR3JhcGgoZ3JhcGgpIHtcclxuICAgICAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZS54ICYmICFub2RlLnkgJiYgb3V0Lkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBvdXQuR2VvbWV0cmllcy5jZW50cm9pZEZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBmZWF0dXJlLnByb3BlcnRpZXMuaWQpIHJldHVybiBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjZW50cm9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbkNvb3JkcyA9IG91dC5fcHJvamVjdGlvbihbY2VudHJvaWQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGNlbnRyb2lkLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXSlcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnggPSBzY3JlZW5Db29yZHNbMF1cclxuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSBzY3JlZW5Db29yZHNbMV1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignY291bGQgbm90IGZpbmQgY29vcmRpbmF0ZXMgZm9yJywgbm9kZS5pZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGNlbnRyb2lkcyBkYXRhLCBjYWxjdWxhdGUgb24gdGhlIGZseVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBvdXQuR2VvbWV0cmllcy5nZXRSZWdpb25GZWF0dXJlcygpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXMuZmluZCgoZmVhdHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09IGZlYXR1cmUucHJvcGVydGllcy5pZCkgcmV0dXJuIGZlYXR1cmVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50cm9pZCA9IGZlYXR1cmUucHJvcGVydGllcy5jZW50cm9pZCB8fCBvdXQuX3BhdGhGdW5jdGlvbi5jZW50cm9pZChmZWF0dXJlKVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuQ29vcmRzID0gb3V0Ll9wcm9qZWN0aW9uKFtjZW50cm9pZFswXSwgY2VudHJvaWRbMV1dKVxyXG4gICAgICAgICAgICAgICAgbm9kZS54ID0gc2NyZWVuQ29vcmRzWzBdXHJcbiAgICAgICAgICAgICAgICBub2RlLnkgPSBzY3JlZW5Db29yZHNbMV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgY29uc29sZS5sb2coZ3JhcGgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgRE9NIElEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gUHJlZml4IGZvciB0aGUgSURcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVuaXF1ZSBJRFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZUlkKHByZWZpeCkge1xyXG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gYXJyb3cgbWFya2VyIHRvIHRoZSBkZWZzIHNlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzIC0gRDMgc2VsZWN0aW9uIG9mIGRlZnNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIE1hcmtlciBJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gRmlsbCBjb2xvciBvZiB0aGUgbWFya2VyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEFycm93TWFya2VyKGRlZnMsIGlkLCBjb2xvcikge1xyXG4gICAgICAgIGRlZnMuYXBwZW5kKCdtYXJrZXInKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCBpZClcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCAxLjUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGNvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsICdNMCwwIHEwLDEsMC41LDEuNSBxLTAuNSwwLjUsLTAuNSwxLjUgcTAuNzUsLTAuNzUsMiwtMS41IHEtMS4yNSwtMC43NSwtMiwtMS41WicpXHJcblxyXG4gICAgICAgIC8vIGFkZCBhIGNvcHkgZm9yIG1vdXNlb3ZlciB3aXRoIGhvdmVyZWQgY29sb3JcclxuICAgICAgICBkZWZzLmFwcGVuZCgnbWFya2VyJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgaWQgKyAnbW91c2VvdmVyJylcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCAxLjUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMCBxMCwxLDAuNSwxLjUgcS0wLjUsMC41LC0wLjUsMS41IHEwLjc1LC0wLjc1LDIsLTEuNSBxLTEuMjUsLTAuNzUsLTIsLTEuNVonKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBsaW5lYXIgZ3JhZGllbnQgZGVmaW5pdGlvbnMgZm9yIGZsb3cgbGlua3NcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzIC0gRDMgc2VsZWN0aW9uIG9mIGRlZnNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdyYWRpZW50SWRzIC0gQXJyYXkgb2YgZ3JhZGllbnQgSURzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5rcyAtIFNhbmtleSBsaW5rcyBkYXRhXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEZsb3dHcmFkaWVudHMoZGVmcywgZ3JhZGllbnRJZHMsIGxpbmtzKSB7XHJcbiAgICAgICAgZGVmcy5zZWxlY3RBbGwoJ2xpbmVhckdyYWRpZW50JylcclxuICAgICAgICAgICAgLmRhdGEobGlua3MpXHJcbiAgICAgICAgICAgIC5qb2luKCdsaW5lYXJHcmFkaWVudCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChfLCBpKSA9PiBncmFkaWVudElkc1tpXSlcclxuICAgICAgICAgICAgLmF0dHIoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCAoZCkgPT4gZC5zb3VyY2UueDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIChkKSA9PiBkLnRhcmdldC54MClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgKGQpID0+IGQueTApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIChkKSA9PiBkLnkxKVxyXG4gICAgICAgICAgICAuY2FsbCgoZykgPT4gZy5hcHBlbmQoJ3N0b3AnKS5hdHRyKCdvZmZzZXQnLCAnNSUnKS5hdHRyKCdzdG9wLWNvbG9yJywgb3V0LmZsb3dPdmVybGF5Q29sb3JzX1swXSkpXHJcbiAgICAgICAgICAgIC5jYWxsKChnKSA9PiBnLmFwcGVuZCgnc3RvcCcpLmF0dHIoJ29mZnNldCcsICc1MCUnKS5hdHRyKCdzdG9wLWNvbG9yJywgb3V0LmZsb3dDb2xvcl8pKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBTYW5rZXkgZmxvd3MgKGxpbmtzIHdpdGggbWFya2VycyBhbmQgZ3JhZGllbnRzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiBTVkdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmtzIC0gU2Fua2V5IGxpbmtzIGRhdGFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcnJvd0lkIC0gQXJyb3cgbWFya2VyIElEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJyb3dPdXRsaW5lSWQgLSBBcnJvdyBvdXRsaW5lIG1hcmtlciBJRFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3JhZGllbnRJZHMgLSBHcmFkaWVudCBJRHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkU2Fua2V5Rmxvd3Moc3ZnLCBsaW5rcywgYXJyb3dJZCwgYXJyb3dPdXRsaW5lSWQsIGdyYWRpZW50SWRzKSB7XHJcbiAgICAgICAgY29uc3QgZmxvd3NHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93cy1ncm91cCcpXHJcblxyXG4gICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmssIGkpID0+IHtcclxuICAgICAgICAgICAgLy8gT3V0bGluZSBwYXRoXHJcbiAgICAgICAgICAgIGZsb3dzR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGxpbmspKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNmZmZmZmYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZsb3ctbGluay1vdXRsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBsaW5rLndpZHRoICsgMS41KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCBgdXJsKCMke2Fycm93T3V0bGluZUlkfSlgKVxyXG5cclxuICAgICAgICAgICAgLy8gTWFpbiBwYXRoXHJcbiAgICAgICAgICAgIGZsb3dzR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGxpbmspKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1saW5rJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBgdXJsKCMke2dyYWRpZW50SWRzW2ldfSlgKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGxpbmsud2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZH0pYClcclxuICAgICAgICAgICAgICAgIC8vIGFkZCBob3ZlciBlZmZlY3RcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3ZlcmVkQ29sb3IgPSBvdXQuaG92ZXJDb2xvcl9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBzdHJva2UgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignc3Ryb2tlJywgaG92ZXJlZENvbG9yKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcmtlci1lbmQgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZCArICdtb3VzZW92ZXInfSlgKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUb29sdGlwIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKGxpbmssIG91dCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgc3Ryb2tlIGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ3N0cm9rZScsIGB1cmwoIyR7Z3JhZGllbnRJZHNbaV19KWApXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgbWFya2VyLWVuZCB0byB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZH0pYClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9vbHRpcCBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHJlY3RhbmdsZXMgdG8gZmlsbCBnYXBzIGxlZnQgYnkgU2Fua2V5IGxpbmtzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnIC0gRDMgc2VsZWN0aW9uIG9mIFNWR1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgLSBTYW5rZXkgbm9kZXMgZGF0YVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRGaWxsR2FwcyhzdmcsIG5vZGVzKSB7XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1mbG93LWZpbGwtaW4tZ2FwcycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZGF0YShub2RlcylcclxuICAgICAgICAgICAgLmpvaW4oJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChkKSA9PiBkLmRlcHRoICYmIGQuaGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiBkLngwIC0gMC41KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiBkLnkwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQpID0+IGQueTEgLSBkLnkwKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIG91dC5mbG93Q29sb3JfKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGxhYmVscyBmb3IgZGF0YSBwb2ludHMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnIC0gRDMgc2VsZWN0aW9uIG9mIHRoZSBTVkcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkTGFiZWxzKHN2Zywgbm9kZXMpIHtcclxuICAgICAgICAvLyBGaWx0ZXIgdGhlIG5vZGVzXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWROb2RlcyA9IG5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS50YXJnZXRMaW5rcyAmJiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbHMnKVxyXG5cclxuICAgICAgICAvLyBBZGQgaGFsbyBlZmZlY3RcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxzU2hhZG93R3JvdXAgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbC1zaGFkb3cnKVxyXG4gICAgICAgICAgICBsYWJlbHNTaGFkb3dHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShmaWx0ZXJlZE5vZGVzKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gJ3N0YXJ0JyA6ICdlbmQnKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gZC54ICsgb3V0LmxhYmVsT2Zmc2V0WCA6IGQueCAtIG91dC5sYWJlbE9mZnNldFgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gZC55ICsgb3V0LmxhYmVsT2Zmc2V0WSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiBvdXQubGFiZWxGb3JtYXR0ZXIoZC52YWx1ZSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgbGFiZWxzXHJcbiAgICAgICAgY29uc3QgbGFiZWxzR3JvdXAgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbCcpXHJcbiAgICAgICAgLy9hZGQgYmFja2dyb3VuZFxyXG4gICAgICAgIC8vIEFkZCBiYWNrZ3JvdW5kIHJlY3RhbmdsZXMgYW5kIHRleHRcclxuICAgICAgICBjb25zdCBsYWJlbEVsZW1lbnRzID0gbGFiZWxzR3JvdXBcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpIC8vIFVzZSBhIGdyb3VwIGZvciBlYWNoIGxhYmVsIHRvIGNvbWJpbmUgcmVjdCBhbmQgdGV4dFxyXG4gICAgICAgICAgICAuZGF0YShmaWx0ZXJlZE5vZGVzKVxyXG4gICAgICAgICAgICAuam9pbignZycpIC8vIEFwcGVuZCBhIGdyb3VwIGZvciBlYWNoIGxhYmVsXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gYHRyYW5zbGF0ZSgke2QueH0sICR7ZC55fSlgKSAvLyBQb3NpdGlvbiBncm91cCBhdCB0aGUgbm9kZVxyXG5cclxuICAgICAgICAvLyBBZGQgdGV4dCBmaXJzdCB0byBjYWxjdWxhdGUgaXRzIHNpemVcclxuICAgICAgICBsYWJlbEVsZW1lbnRzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGFiZWwtdGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIChkKSA9PiAoZC54ID4gZC50YXJnZXRMaW5rc1swXS5zb3VyY2UueCA/ICdzdGFydCcgOiAnZW5kJykpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gb3V0LmxhYmVsT2Zmc2V0WCA6IC1vdXQubGFiZWxPZmZzZXRYKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQubGFiZWxPZmZzZXRZKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gb3V0LmxhYmVsRm9ybWF0dGVyKGQudmFsdWUpKVxyXG5cclxuICAgICAgICAvLyBBZGQgYmFja2dyb3VuZCByZWN0YW5nbGVzIGFmdGVyIHRleHQgaXMgcmVuZGVyZWRcclxuXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfLmJhY2tncm91bmRzKSB7XHJcbiAgICAgICAgICAgIGxhYmVsRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IHNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJveCA9IHRleHRFbGVtZW50Lm5vZGUoKS5nZXRCQm94KCkgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiB0aGUgdGV4dFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdYID0gNSAvLyBIb3Jpem9udGFsIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdZID0gMiAvLyBWZXJ0aWNhbCBwYWRkaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlY3RhbmdsZSBjZW50ZXJlZCBiZWhpbmQgdGhlIHRleHRcclxuICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAndGV4dCcpIC8vIEluc2VydCByZWN0IGJlZm9yZSB0ZXh0IGluIERPTVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGJib3gueCAtIHBhZGRpbmdYKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYmJveC55IC0gcGFkZGluZ1kpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYmJveC53aWR0aCArIDIgKiBwYWRkaW5nWClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYmJveC5oZWlnaHQgKyAyICogcGFkZGluZ1kpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIGFwcGVuZCBhIHJlY3RhbmdsZSBiZWhpbmQgdGhlIGxhYmVsXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRMYWJlbFJlY3QobGFiZWxUZXh0LCBjb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IDUgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDIgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHRleHQgZWxlbWVudCB0byBnZXQgdGhlIHNpemVcclxuICAgICAgICBjb25zdCBiYm94ID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlzaWJpbGl0eScsICdoaWRkZW4nKSAvLyBNYWtlIHRoZSB0ZW1wb3JhcnkgdGV4dCBpbnZpc2libGVcclxuICAgICAgICAgICAgLnRleHQobGFiZWxUZXh0KSAvLyBTZXQgdGhlIGxhYmVsIHRleHQgdG8gZ2V0IGl0cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgLm5vZGUoKVxyXG4gICAgICAgICAgICAuZ2V0QkJveCgpIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBiYm94LndpZHRoXHJcbiAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSBiYm94LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgYWZ0ZXIgZ2V0dGluZyB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdCgndGV4dFt2aXNpYmlsaXR5PVwiaGlkZGVuXCJdJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIHRvIGJlIGNlbnRlcmVkIG9uIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgeCA9IC1sYWJlbFdpZHRoIC8gMiAtIHBhZGRpbmdYIC8vIENlbnRlciB0aGUgcmVjdCBob3Jpem9udGFsbHlcclxuICAgICAgICBjb25zdCB5ID0gLWxhYmVsSGVpZ2h0IC8gMiAtIHBhZGRpbmdZIC8vIENlbnRlciB0aGUgcmVjdCB2ZXJ0aWNhbGx5XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHgpIC8vIFBvc2l0aW9uIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSkgLy8gUG9zaXRpb24gcmVjdCB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGxhYmVsV2lkdGggKyAyICogcGFkZGluZ1gpIC8vIFdpZHRoIG9mIHRoZSByZWN0IHdpdGggcGFkZGluZ1xyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgbGFiZWxIZWlnaHQgKyAyICogcGFkZGluZ1kpIC8vIEhlaWdodCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxhYmVsLWJhY2tncm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZyb20gdGhpcyBwb2ludCBvbiBhbGwgY29kZSBpcyByZWxhdGVkIHdpdGggc3BhdGlhbCBzYW5rZXkuIEFkb3B0ZWQgZnJvbSB0aGlzIG5vdGVib29rOiBodHRwczovL29ic2VydmFibGVocS5jb20vQGJheXJlL2RlY29uc3RydWN0ZWQtc2Fua2V5LWRpYWdyYW1cclxuICAgIC8vIFNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGpvZXdkYXZpZXMvZmxvdy1tYXAtb2YtZXVyb3BlXHJcbiAgICBmdW5jdGlvbiBjbG9uZSh7IG5vZGVzLCBsaW5rcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLm1hcCgoZCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgZCkpLCBsaW5rczogbGlua3MubWFwKChkKSA9PiBPYmplY3QuYXNzaWduKHt9LCBkKSkgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNhbmtleSh7IG5vZGVzLCBsaW5rcyB9KSB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGggPSBjbG9uZSh7IG5vZGVzLCBsaW5rcyB9KVxyXG4gICAgICAgIGNvbXB1dGVOb2RlTGlua3MoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVWYWx1ZXMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVEZXB0aHMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVIZWlnaHRzKGdyYXBoKVxyXG4gICAgICAgIGNvbXB1dGVOb2RlQnJlYWR0aHMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZUxpbmtCcmVhZHRocyhncmFwaClcclxuICAgICAgICByZXR1cm4gZ3JhcGhcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUxpbmtzKHsgbm9kZXMsIGxpbmtzIH0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IFtpLCBub2RlXSBvZiBub2Rlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgbm9kZS5pbmRleCA9IGlcclxuICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcyA9IFtdXHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlQnlJZCA9IG5ldyBNYXAobm9kZXMubWFwKChkLCBpKSA9PiBbaWQoZCwgaSwgbm9kZXMpLCBkXSkpXHJcbiAgICAgICAgZm9yIChjb25zdCBbaSwgbGlua10gb2YgbGlua3MuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGxpbmsuaW5kZXggPSBpXHJcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBsaW5rXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykgc291cmNlID0gbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBzb3VyY2UpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JykgdGFyZ2V0ID0gbGluay50YXJnZXQgPSBmaW5kKG5vZGVCeUlkLCB0YXJnZXQpXHJcbiAgICAgICAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspXHJcbiAgICAgICAgICAgIHRhcmdldC50YXJnZXRMaW5rcy5wdXNoKGxpbmspXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIChsaW5rU29ydCAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gICAgIGZvciAoY29uc3QgeyBzb3VyY2VMaW5rcywgdGFyZ2V0TGlua3MgfSBvZiBub2Rlcykge1xyXG4gICAgICAgIC8vICAgICAgICAgc291cmNlTGlua3Muc29ydChsaW5rU29ydClcclxuICAgICAgICAvLyAgICAgICAgIHRhcmdldExpbmtzLnNvcnQobGlua1NvcnQpXHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZChub2RlQnlJZCwgaWQpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZUJ5SWQuZ2V0KGlkKVxyXG4gICAgICAgIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nOiAnICsgaWQpXHJcbiAgICAgICAgcmV0dXJuIG5vZGVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBuZXcgU2V0KG5vZGVzKVxyXG4gICAgICAgIGxldCBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgbGV0IHggPSAwXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuc2l6ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5kZXB0aCA9IHhcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQgfSBvZiBub2RlLnNvdXJjZUxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5hZGQodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgrK3ggPiBuKSB0aHJvdyBuZXcgRXJyb3IoJ2NpcmN1bGFyIGxpbmsnKVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dFxyXG4gICAgICAgICAgICBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlSGVpZ2h0cyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBuZXcgU2V0KG5vZGVzKVxyXG4gICAgICAgIGxldCBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgbGV0IHggPSAwXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuc2l6ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgc291cmNlIH0gb2Ygbm9kZS50YXJnZXRMaW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKHNvdXJjZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKyt4ID4gbikgdGhyb3cgbmV3IEVycm9yKCdjaXJjdWxhciBsaW5rJylcclxuICAgICAgICAgICAgY3VycmVudCA9IG5leHRcclxuICAgICAgICAgICAgbmV4dCA9IG5ldyBTZXQoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB2ZXJ0aWNhbGx5IHN0YWNrcyBsaW5rcyB3aXRoIHRoZSBzYW1lIG9yaWdpbi4gQ2F1c2VzIGlzc3VlcyBvbiB3b3JsZCBtYXBzXHJcbiAgICAvLyBmdW5jdGlvbiBjb21wdXRlTGlua0JyZWFkdGhzKHsgbm9kZXMgfSkge1xyXG4gICAgLy8gICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgLy8gICAgICAgICBsZXQgeTAgPSBub2RlLnkwOyAgLy8gSW5pdGlhbCB5MCBwb3NpdGlvblxyXG4gICAgLy8gICAgICAgICBsZXQgeTEgPSB5MDtcclxuICAgIC8vICAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIG5vZGUuc291cmNlTGlua3MpIHtcclxuICAgIC8vICAgICAgICAgICAgIGxpbmsueTAgPSB5MCArIGxpbmsud2lkdGggLyAyOyAgLy8gQWRqdXN0aW5nIHkwIGR5bmFtaWNhbGx5XHJcbiAgICAvLyAgICAgICAgICAgICB5MCArPSBsaW5rLndpZHRoOyAgLy8gTW92aW5nIHkwIGRvd24gZm9yIHRoZSBuZXh0IGxpbmtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2Ygbm9kZS50YXJnZXRMaW5rcykge1xyXG4gICAgLy8gICAgICAgICAgICAgbGluay55MSA9IHkxICsgbGluay53aWR0aCAvIDI7XHJcbiAgICAvLyAgICAgICAgICAgICB5MSArPSBsaW5rLndpZHRoO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVMaW5rQnJlYWR0aHMoeyBub2RlcyB9KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIG11bHRpcGxlIGxpbmtzIG9yaWdpbmF0ZSBmcm9tIHRoZSBzYW1lIHNvdXJjZSwgc2V0IHRoZW0gdG8gdGhlIHNhbWUgeTBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpeGVkWTAgPSBub2RlLnkgLy8gVXNlIHRoZSBub2RlJ3MgeSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay55MCA9IGZpeGVkWTAgLy8gRm9yY2UgYWxsIGxpbmtzIHRvIHVzZSB0aGUgc2FtZSB5MFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgZm9yIG90aGVyIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBsZXQgeTAgPSBub2RlLnkwXHJcbiAgICAgICAgICAgICAgICBsZXQgeTEgPSB5MFxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIG5vZGUuc291cmNlTGlua3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rLnkwID0geTAgKyBsaW5rLndpZHRoIC8gMlxyXG4gICAgICAgICAgICAgICAgICAgIHkwICs9IGxpbmsud2lkdGhcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLnRhcmdldExpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay55MSA9IHkxICsgbGluay53aWR0aCAvIDJcclxuICAgICAgICAgICAgICAgICAgICB5MSArPSBsaW5rLndpZHRoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaG9yaXpvbnRhbFNvdXJjZShkKSB7XHJcbiAgICAgICAgcmV0dXJuIFtkLnNvdXJjZS54MSwgZC55MF1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBob3Jpem9udGFsVGFyZ2V0KGQpIHtcclxuICAgICAgICByZXR1cm4gW2QudGFyZ2V0LngwLCBkLnkxXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlVmFsdWVzKHsgbm9kZXMgfSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBub2RlLnZhbHVlID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICBzdW0obm9kZS5zb3VyY2VMaW5rcywgKGQpID0+IGQudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgc3VtKG5vZGUudGFyZ2V0TGlua3MsIChkKSA9PiBkLnZhbHVlKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlb3JkZXJMaW5rcyhub2Rlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBzb3VyY2VMaW5rcywgdGFyZ2V0TGlua3MgfSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBzb3VyY2VMaW5rcy5zb3J0KGFzY2VuZGluZ1RhcmdldFkpXHJcbiAgICAgICAgICAgIHRhcmdldExpbmtzLnNvcnQoYXNjZW5kaW5nU291cmNlWSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXNjZW5kaW5nVGFyZ2V0WSA9IChhLCBiKSA9PiBhLnRhcmdldC55IC0gYi50YXJnZXQueVxyXG4gICAgY29uc3QgYXNjZW5kaW5nU291cmNlWSA9IChhLCBiKSA9PiBhLnNvdXJjZS55IC0gYi5zb3VyY2UueVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlQnJlYWR0aHMoeyBub2RlcyB9KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG91dC5zdHJva2VXaWR0aFNjYWxlKG5vZGUudmFsdWUpXHJcbiAgICAgICAgICAgIG5vZGUueDAgPSBub2RlLngxID0gbm9kZS54XHJcbiAgICAgICAgICAgIG5vZGUueTAgPSBub2RlLnkgLSBoZWlnaHQgLyAyXHJcbiAgICAgICAgICAgIG5vZGUueTEgPSBub2RlLnkwICsgaGVpZ2h0XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLnNvdXJjZUxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLndpZHRoID0gb3V0LnN0cm9rZVdpZHRoU2NhbGUobGluay52YWx1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZW9yZGVyTGlua3Mobm9kZXMpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaWQgPSAoZCkgPT4gZC5pZCAvLyB1c2VkIGluIHNhbmtleSBpbXBvcnRcclxuXHJcbiAgICBjb25zdCBzYW5rZXlMaW5rSG9yaXpvbnRhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbGlua0hvcml6b250YWwoKS5zb3VyY2UoaG9yaXpvbnRhbFNvdXJjZSkudGFyZ2V0KGhvcml6b250YWxUYXJnZXQpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG5jb25zdCBmbG93TWFwVG9vbHRpcEZ1bmN0aW9uID0gZnVuY3Rpb24gKGxpbmssIG1hcCkge1xyXG4gICAgY29uc3QgYnVmID0gW11cclxuXHJcbiAgICAvLyBIZWFkZXIgd2l0aCByZWdpb24gbmFtZSBhbmQgSURcclxuICAgIGNvbnN0IHRpdGxlID0gYCR7bGluay5zb3VyY2UuaWR9ID4gJHtsaW5rLnRhcmdldC5pZH1gXHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPlxyXG4gICAgICAgICAgICA8Yj4ke3RpdGxlfTwvYj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgLy8gVmFsdWVcclxuICAgIGJ1Zi5wdXNoKGA8ZGl2IGNsYXNzPSdlc3RhdC12aXMtdG9vbHRpcC10ZXh0Jz5cclxuICAgICAgICAke2xpbmsudGFyZ2V0LnZhbHVlfVxyXG4gICAgICAgIDwvZGl2PmApXHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNjYWxlU3FydCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgYXJjLCBwaWUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgZXh0ZW50LCBzdW0gfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVPclJkLCBzY2hlbWVDYXRlZ29yeTEwIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJ1xyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIFBpZWNoYXJ0TGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtcGllY2hhcnRzJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRSZWdpb25zU2VsZWN0b3IsIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb3BvcnRpb25hbCBwaWUgY2hhcnQgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIHRydWUsICdwaWUnKVxyXG5cclxuICAgIC8vIHBpZSBjaGFydHNcclxuICAgIG91dC5waWVNaW5SYWRpdXNfID0gNVxyXG4gICAgb3V0LnBpZU1heFJhZGl1c18gPSAxNVxyXG4gICAgb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXNfID0gMFxyXG4gICAgb3V0LnBpZVN0cm9rZUZpbGxfID0gJ3doaXRlJ1xyXG4gICAgb3V0LnBpZVN0cm9rZVdpZHRoXyA9IDAuM1xyXG5cclxuICAgIC8vdG9vbHRpcCBwaWUgY2hhcnRcclxuICAgIG91dC50b29sdGlwUGllUmFkaXVzXyA9IDQwXHJcbiAgICBvdXQudG9vbHRpcFBpZUlubmVyUmFkaXVzXyA9IDBcclxuXHJcbiAgICAvL2NvbG9ycyAtIGluZGV4ZWQgYnkgY2F0ZWdvcnkgY29kZVxyXG4gICAgb3V0LmNhdENvbG9yc18gPSB1bmRlZmluZWRcclxuICAgIC8vbGFiZWxzIC0gaW5kZXhlZCBieSBjYXRlZ29yeSBjb2RlXHJcbiAgICBvdXQuY2F0TGFiZWxzXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vICdvdGhlcicgc2VjdGlvbiBvZiB0aGUgcGllIGNoYXJ0IGZvciB3aGVuICdvdXQudG90YWxDb2RlXycgaXMgZGVmaW5lZCB3aXRoIHN0YXRQaWUoKVxyXG4gICAgb3V0LnBpZU90aGVyQ29sb3JfID0gJyNGRkNDODAnXHJcbiAgICBvdXQucGllT3RoZXJUZXh0XyA9ICdPdGhlcidcclxuXHJcbiAgICAvL3Nob3cgcGllY2hhcnRzIG9ubHkgd2hlbiBkYXRhIGZvciBhbGwgY2F0ZWdvcmllcyBpcyBjb21wbGV0ZS5cclxuICAgIC8vT3RoZXJ3aXNlLCBjb25zaWRlciB0aGUgcmVnaW9ucyBhcyBiZWluZyB3aXRoIG5vIGRhdGEgYXQgYWxsLlxyXG4gICAgb3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlXyA9IGZhbHNlXHJcblxyXG4gICAgb3V0LnNpemVDbGFzc2lmaWVyXyA9IG51bGwgLy9kMyBzY2FsZSBmb3Igc2NhbGluZyBwaWUgc2l6ZXNcclxuICAgIG91dC5zdGF0UGllXyA9IG51bGxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7W1xyXG4gICAgICAgICdjYXRDb2xvcnNfJyxcclxuICAgICAgICAnY2F0TGFiZWxzXycsXHJcbiAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwaWVNYXhSYWRpdXNfJyxcclxuICAgICAgICAncGllTWluUmFkaXVzXycsXHJcbiAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXNfJyxcclxuICAgICAgICAncGllT3RoZXJDb2xvcl8nLFxyXG4gICAgICAgICdwaWVPdGhlclRleHRfJyxcclxuICAgICAgICAncGllU3Ryb2tlRmlsbF8nLFxyXG4gICAgICAgICdwaWVTdHJva2VXaWR0aF8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnY2F0Q29sb3JzJyxcclxuICAgICAgICAgICAgJ2NhdExhYmVscycsXHJcbiAgICAgICAgICAgICdzaG93T25seVdoZW5Db21wbGV0ZScsXHJcbiAgICAgICAgICAgICdub0RhdGFGaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAncGllTWF4UmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZU1pblJhZGl1cycsXHJcbiAgICAgICAgICAgICdwaWVDaGFydElubmVyUmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZU90aGVyQ29sb3InLFxyXG4gICAgICAgICAgICAncGllT3RoZXJUZXh0JyxcclxuICAgICAgICAgICAgJ3BpZVN0cm9rZUZpbGwnLFxyXG4gICAgICAgICAgICAncGllU3Ryb2tlV2lkdGgnLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLyoqIFRoZSBjb2RlcyBvZiB0aGUgY2F0ZWdvcmllcyB0byBjb25zaWRlciBmb3IgdGhlIGNvbXBvc2l0aW9uLiAqL1xyXG4gICAgb3V0LnN0YXRDb2Rlc18gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUaGUgY29kZSBvZiB0aGUgXCJ0b3RhbFwiIGNhdGVnb3J5IGluIHRoZSBldXJvc3RhdCBkYXRhYmFzZSAqL1xyXG4gICAgb3V0LnRvdGFsQ29kZV9fID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRlZmluZSBhIHBpZSBjaGFydCBtYXAgZWFzaWx5LCB3aXRob3V0IHJlcGV0aXRpb24gb2YgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBPbmx5IGZvciBldXJvYmFzZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0IEEgcGF0dGVybiBmb3IgdGhlIHN0YXQgZGF0YSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaW0gVGhlIGRpbWVuc2lvbiAoZGVmaW5lZCBpbiBldXJvc3RhdCBSRVNUIEFQSSkgb2YgdGhlIGNvbXBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29kZXMgVGhlIGNhdGVnb3J5IGNvZGVzIG9mIHRoZSBjb21wb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxzIE9wdGlvbmFsOiBUaGUgbGFiZWxzIGZvciB0aGUgY2F0ZWdvcnkgY29kZXNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBPcHRpb25hbDogVGhlIGNvbG9ycyBmb3IgdGhlIGNhdGVnb3J5XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdENvZGUgT3B0aW9uYWw6IFRoZSBjYXRlZ29yeSBjb2RlIG9mIHRoZSB0b3RhbCAodXNlZCB0byBjYWxjdWxhdGUgdG90YWwgJiBcIm90aGVyXCIgdmFsdWVzIGlmIGNvZGVzIGFycmF5IGRvbnQgcmVwcmVzZW50IGFsbCBwb3NzaWJsZSBjYXRlZ29yaWVzKVxyXG4gICAgICovXHJcbiAgICBvdXQuc3RhdFBpZSA9IGZ1bmN0aW9uIChzdGF0LCBkaW0sIGNvZGVzLCBsYWJlbHMsIGNvbG9ycywgdENvZGUpIHtcclxuICAgICAgICAvL2FkZCBvbmUgZGF0YXNldCAoc3RhdCkgY29uZmlnIGZvciBlYWNoIGNhdGVnb3J5IChjb2RlKVxyXG4gICAgICAgIHN0YXQuZmlsdGVycyA9IHN0YXQuZmlsdGVycyB8fCB7fVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9jYXRlZ29yeSBjb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBjb2Rlc1tpXVxyXG4gICAgICAgICAgICBzdGF0LmZpbHRlcnNbZGltXSA9IGNvZGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHtcclxuICAgICAgICAgICAgICAgIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2NfLmZpbHRlcnMgPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdC5maWx0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBzY18uZmlsdGVyc1trZXldID0gc3RhdC5maWx0ZXJzW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQuc3RhdChjb2RlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgcmV0cmlldmUgYW5kIGFzc2lnbiBjb2xvclxyXG4gICAgICAgICAgICBpZiAoY29sb3JzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzXyA9IG91dC5jYXRDb2xvcnNfIHx8IHt9XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzX1tjb2RlXSA9IGNvbG9yc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChsYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfW2NvZGVdID0gbGFiZWxzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IG91dC5zdGF0Q29kZXNfXHJcbiAgICAgICAgb3V0LnN0YXRDb2Rlc18gPSBjb2Rlc1xyXG5cclxuICAgICAgICAvL3NldCBvdXQudG90YWxDb2RlX1xyXG4gICAgICAgIGlmICh0Q29kZSkge1xyXG4gICAgICAgICAgICBvdXQudG90YWxDb2RlXyA9IHRDb2RlXHJcbiAgICAgICAgICAgIHN0YXQuZmlsdGVyc1tkaW1dID0gdENvZGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIHNjXy5maWx0ZXJzID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQuZmlsdGVycykgc2NfLmZpbHRlcnNba2V5XSA9IHN0YXQuZmlsdGVyc1trZXldXHJcbiAgICAgICAgICAgIG91dC5zdGF0KHRDb2RlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL3doZW4gdG90YWwgY29kZSBpcyB1c2VkLCBhbiAnb3RoZXInIHNlY3Rpb24gaXMgYWRkZWQgdG8gdGhlIHBpZVxyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzX1snb3RoZXInXSA9IG91dC5waWVPdGhlckNvbG9yX1xyXG4gICAgICAgICAgICBvdXQuY2F0TGFiZWxzX1snb3RoZXInXSA9IG91dC5waWVPdGhlclRleHRfXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgLy9pZiBub3QgcHJvdmlkZWQsIGdldCBsaXN0IG9mIHN0YXQgY29kZXMgZnJvbSB0aGUgbWFwIHN0YXQgZGF0YVxyXG4gICAgICAgIGlmICghb3V0LnN0YXRDb2Rlc18pIHtcclxuICAgICAgICAgICAgLy9nZXQgbGlzdCBvZiBzdGF0IGNvZGVzLlxyXG4gICAgICAgICAgICBvdXQuc3RhdENvZGVzXyA9IE9iamVjdC5rZXlzKG91dC5zdGF0RGF0YV8pXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIFwiZGVmYXVsdFwiLCBpZiBwcmVzZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3V0LnN0YXRDb2Rlc18uaW5kZXhPZignZGVmYXVsdCcpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSBvdXQuc3RhdENvZGVzXy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RlZmluZSBzaXplIHNjYWxpbmcgZnVuY3Rpb25cclxuICAgICAgICBsZXQgZG9tYWluID0gZ2V0RGF0YXNldE1heE1pbigpXHJcbiAgICAgICAgaWYgKCFpc05hTihkb21haW5bMF0pKSB7XHJcbiAgICAgICAgICAgIG91dC5zaXplQ2xhc3NpZmllcl8gPSBzY2FsZVNxcnQoKS5kb21haW4oZG9tYWluKS5yYW5nZShbb3V0LnBpZU1pblJhZGl1c18sIG91dC5waWVNYXhSYWRpdXNfXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgYnVpbGQgZGVmYXVsdCBjb2xvciByYW1wXHJcbiAgICAgICAgaWYgKCFvdXQuY2F0Q29sb3JzXykge1xyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzKHt9KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5zdGF0Q29kZXNfLmxlbmd0aDsgaSsrKSBvdXQuY2F0Q29sb3JzX1tvdXQuc3RhdENvZGVzX1tpXV0gPSBzY2hlbWVDYXRlZ29yeTEwW2kgJSAxMF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgaW5pdGlhbGlzZSBjYXRlZ29yeSBsYWJlbHNcclxuICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcblxyXG4gICAgICAgIC8vYnVpbGQgYW5kIGFzc2lnbiBwaWUgY2hhcnRzIHRvIHRoZSByZWdpb25zXHJcbiAgICAgICAgLy9jb2xsZWN0IG51dHMgaWRzIGZyb20gZyBlbGVtZW50cy4gVE9ETzogZmluZCBiZXR0ZXIgd2F5IG9mIHNoYXJpbmcgcmVnaW9ucyB3aXRoIHBpZXNcclxuICAgICAgICBsZXQgcmVnaW9uRmVhdHVyZXMgPSBbXVxyXG4gICAgICAgIGlmIChvdXQuc3ZnXykge1xyXG4gICAgICAgICAgICBsZXQgcyA9IG91dC5zdmdfLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ltID0gcy5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAgICAgc3ltLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbkZlYXR1cmVzLnB1c2gocmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncGllXycgKyByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgcmVnaW9uIGhvdmVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihvdXQpXHJcbiAgICAgICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGFkZFBpZUNoYXJ0c1RvTWFwKHJlZ2lvbkZlYXR1cmVzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNvbXB1dGUgY29tcG9zaXRpb24gZm9yIHJlZ2lvbiBpZCwgZm9yIGVhY2ggY2F0ZWdvcnkuXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGgsIGZvciBlYWNoIGNhdGVnb3J5LCB0aGUgc2hhcmUgWzAsMV0gb2YgdGhlIGNhdGVnb3J5LlxyXG4gICAgICogQHBhcmFtIHsqfSBpZFxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGxldCBjb21wID0ge30sXHJcbiAgICAgICAgICAgIHN1bSA9IDBcclxuICAgICAgICAvL2dldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5LiBDb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL3JldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuc3RhdENvZGVzX1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzID0gb3V0LnN0YXREYXRhKHNjKS5nZXQoaWQpXHJcblxyXG4gICAgICAgICAgICAvL2Nhc2Ugd2hlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xyXG4gICAgICAgICAgICBpZiAoIXMgfHwgKHMudmFsdWUgIT0gMCAmJiAhcy52YWx1ZSkgfHwgaXNOYU4ocy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZWxzZSBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21wW3NjXSA9IHMudmFsdWVcclxuICAgICAgICAgICAgc3VtICs9IHMudmFsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gb3V0LnRvdGFsQ29kZV8gaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIHN1bSBpbnN0ZWFkIG9mIHRoZSBzdW0gb2YgdGhlIHNwZWNpZmllZCBjYXRlZ29yaWVzLlxyXG4gICAgICAgIGlmIChvdXQudG90YWxDb2RlXykge1xyXG4gICAgICAgICAgICBsZXQgcyA9IG91dC5zdGF0RGF0YShvdXQudG90YWxDb2RlXykuZ2V0KGlkKVxyXG4gICAgICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICAgICAgc3VtID0gcy52YWx1ZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VtID09IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jYXNlIHdoZW4gbm8gZGF0YVxyXG4gICAgICAgIGlmIChzdW0gPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL2NvbXB1dGUgcmF0aW9zXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb21wW291dC5zdGF0Q29kZXNfW2ldXSAvPSBzdW1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYWRkIFwib3RoZXJcIiBjYXRlZ29yeSB3aGVuIG91dC50b3RhbENvZGVfIGlzIHVzZWRcclxuICAgICAgICBpZiAob3V0LnRvdGFsQ29kZV8pIHtcclxuICAgICAgICAgICAgbGV0IHRvdGFsUGVyYyA9IDBcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbXApIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsUGVyYyA9IHRvdGFsUGVyYyArIGNvbXBba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbXBbJ290aGVyJ10gPSAxIC0gdG90YWxQZXJjXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGdldERhdGFzZXRNYXhNaW5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXRzIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHRvdGFsIG9mIGFsbCBkaW1lbnNpb25zIGNvbWJpbmVkIGZvciBlYWNoIHJlZ2lvbi4gVXNlZCB0byBkZWZpbmUgdGhlIGRvbWFpbiBvZiB0aGUgcGllIHNpemUgc2NhbGluZyBmdW5jdGlvbi5cclxuICAgICAqIEByZXR1cm5zIFttaW4sbWF4XVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXREYXRhc2V0TWF4TWluKCkge1xyXG4gICAgICAgIGxldCB0b3RhbHMgPSBbXVxyXG4gICAgICAgIGxldCBzZWwgPSBvdXQuc3ZnKCkuc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJykuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykuZGF0YSgpXHJcblxyXG4gICAgICAgIHNlbC5mb3JFYWNoKChyZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaWQgPSByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGdldFJlZ2lvblRvdGFsKGlkKVxyXG4gICAgICAgICAgICBpZiAodG90YWwpIHtcclxuICAgICAgICAgICAgICAgIHRvdGFscy5wdXNoKHRvdGFsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IG1pbm1heCA9IGV4dGVudCh0b3RhbHMpXHJcbiAgICAgICAgcmV0dXJuIG1pbm1heFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFic29sdXRlIHRvdGFsIHZhbHVlIG9mIGNvbWJpbmVkIHN0YXRpc3RpY2FsIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyByZWdpb24uIEUuZyB0b3RhbCBsaXZlc3RvY2tcclxuICAgICAqIEBwYXJhbSB7Kn0gaWQgbnV0cyByZWdpb24gaWRcclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0UmVnaW9uVG90YWwgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgc3VtID0gMFxyXG4gICAgICAgIGxldCBzXHJcbiAgICAgICAgaWYgKG91dC50b3RhbENvZGVfKSB7XHJcbiAgICAgICAgICAgIC8vd2hlbiB0b3RhbCBpcyBhIHN0YXQgY29kZVxyXG4gICAgICAgICAgICBzID0gb3V0LnN0YXREYXRhKG91dC50b3RhbENvZGVfKS5nZXQoaWQpXHJcbiAgICAgICAgICAgIC8vY2FzZSB3aGVuIHNvbWUgZGF0YSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2dldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5LiBDb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LnN0YXRDb2Rlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vcmV0cmlldmUgY29kZSBhbmQgc3RhdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuc3RhdENvZGVzX1tpXVxyXG4gICAgICAgICAgICAgICAgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KGlkKVxyXG4gICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gc29tZSBkYXRhIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN1bSArPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2FzZSB3aGVuIG5vIGRhdGFcclxuICAgICAgICBpZiAoc3VtID09IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gc3VtXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkUGllQ2hhcnRzVG9NYXAocmVnaW9uRmVhdHVyZXMpIHtcclxuICAgICAgICByZWdpb25GZWF0dXJlcy5mb3JFYWNoKChyZWdpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgICAgICAgICAvL3ByZXBhcmUgZGF0YSBmb3IgcGllIGNoYXJ0XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXVxyXG4gICAgICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmVnaW9uSWQpXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXApIGRhdGEucHVzaCh7IGNvZGU6IGtleSwgdmFsdWU6IGNvbXBba2V5XSB9KVxyXG5cclxuICAgICAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICAgICAgLy8gY2FuIGJlIG1vcmUgdGhhbiBvbmUgY2VudGVyIHBvaW50IGZvciBlYWNoIG51dHMgSUQgKGUuZy4gTWFsdGEgd2hlbiBpbmNsdWRlZCBpbiBpbnNldHMpXHJcbiAgICAgICAgICAgIGxldCBub2RlcyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoJyNwaWVfJyArIHJlZ2lvbklkKVxyXG5cclxuICAgICAgICAgICAgLy8gZGVmaW5lIHJhZGl1c1xyXG4gICAgICAgICAgICBjb25zdCByID0gb3V0LnNpemVDbGFzc2lmaWVyXyhnZXRSZWdpb25Ub3RhbChyZWdpb25JZCkpXHJcbiAgICAgICAgICAgIGNvbnN0IGlyID0gb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXNfXHJcblxyXG4gICAgICAgICAgICAvL21ha2UgcGllIGNoYXJ0LiBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9waWUtY2hhcnRcclxuICAgICAgICAgICAgY29uc3QgcGllXyA9IHBpZSgpXHJcbiAgICAgICAgICAgICAgICAuc29ydChudWxsKVxyXG4gICAgICAgICAgICAgICAgLnZhbHVlKChkKSA9PiBkLnZhbHVlKVxyXG4gICAgICAgICAgICBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgb3V0LnBpZVN0cm9rZUZpbGxfKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIG91dC5waWVTdHJva2VXaWR0aF8gKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BpZWNoYXJ0JylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocGllXyhkYXRhKSlcclxuICAgICAgICAgICAgICAgIC5qb2luKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jYXRDb2xvcnNfW2QuZGF0YS5jb2RlXSB8fCAnbGlnaHRncmF5J1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsX19fJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNhdENvbG9yc19bZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NvZGUnLCAoZCkgPT4gZC5kYXRhLmNvZGUpIC8vZm9yIG1vdXNlb3ZlciBsZWdlbmQgaGlnaGxpZ2h0aW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGFyYygpLmlubmVyUmFkaXVzKGlyKS5vdXRlclJhZGl1cyhyKSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYSB0aGljayBzdHJva2Ugd2lkdGggdG8gdGhlIHBhcmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gc2VsZWN0KHNlbC5ub2RlKCkucGFyZW50Tm9kZSlcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKS5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJykgLy8gU2V0IHN0cm9rZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZWdpb24sIG91dCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdHJva2VcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBzZWxlY3Qoc2VsLm5vZGUoKS5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgb3V0LnBpZVN0cm9rZVdpZHRoXykuc3R5bGUoJ3N0cm9rZScsIG91dC5waWVTdHJva2VGaWxsXykgLy8gU2V0IHN0cm9rZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gUGllY2hhcnRMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgICAgIC8vZ2V0IHRvb2x0aXBcclxuICAgICAgICBjb25zdCB0cCA9IHNlbGVjdCgnI3Rvb2x0aXBfZXVyb3N0YXQnKVxyXG5cclxuICAgICAgICAvL2NsZWFyXHJcbiAgICAgICAgdHAuaHRtbCgnJylcclxuICAgICAgICB0cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICBpZiAocmcucHJvcGVydGllcy5pZCkge1xyXG4gICAgICAgICAgICAvL25hbWUgYW5kIGNvZGVcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VzdGF0LXZpcy10b29sdGlwLWJhcicpXHJcbiAgICAgICAgICAgICAgICAuaHRtbChyZy5wcm9wZXJ0aWVzLm5hICsgJyAoJyArIHJnLnByb3BlcnRpZXMuaWQgKyAnKScpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VzdGF0LXZpcy10b29sdGlwLWJhcicpLmh0bWwocmcucHJvcGVydGllcy5uYSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBkYXRhIGZvciBwaWUgY2hhcnRcclxuICAgICAgICBjb25zdCBkYXRhID0gW11cclxuICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wKSBkYXRhLnB1c2goeyBjb2RlOiBrZXksIHZhbHVlOiBjb21wW2tleV0gfSlcclxuXHJcbiAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKS5odG1sKG91dC5ub0RhdGFUZXh0KCkpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICAvLyBzZXQgdGhlIGRpbWVuc2lvbnMgYW5kIG1hcmdpbnMgb2YgdGhlIGdyYXBoXHJcbiAgICAgICAgbGV0IHdpZHRoID0gMTUwXHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDE1MFxyXG4gICAgICAgIGxldCBtYXJnaW4gPSAyNVxyXG5cclxuICAgICAgICAvLyBUaGUgcmFkaXVzIG9mIHRoZSBwaWVwbG90IGlzIGhhbGYgdGhlIHdpZHRoIG9yIGhhbGYgdGhlIGhlaWdodCAoc21hbGxlc3Qgb25lKS4gSSBzdWJ0cmFjdCBhIGJpdCBvZiBtYXJnaW4uXHJcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIC0gbWFyZ2luXHJcblxyXG4gICAgICAgIC8vd2lkdGggPSB0cC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0cC5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtcGllY2hhcnQtY29udGFpbmVyJylcclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtcGllY2hhcnQtc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdib3gnLCBgMCwgMCwgJHt3aWR0aH0sICR7aGVpZ2h0fWApXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0IC0gbWFyZ2luIC8gMilcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB3aWR0aCAvIDIgKyAnLCcgKyBoZWlnaHQgLyAyICsgJyknKVxyXG5cclxuICAgICAgICAvL21ha2UgcGllIGNoYXJ0LiBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9waWUtY2hhcnRcclxuICAgICAgICBjb25zdCBwaWVfID0gcGllKClcclxuICAgICAgICAgICAgLnNvcnQobnVsbClcclxuICAgICAgICAgICAgLnZhbHVlKChkKSA9PiBkLnZhbHVlKVxyXG5cclxuICAgICAgICBjb25zdCBpbm5lckFyYyA9IGFyYygpXHJcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKSAvLyBUaGlzIGlzIHRoZSBzaXplIG9mIHRoZSBkb251dCBob2xlXHJcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgKiAwLjgpXHJcblxyXG4gICAgICAgIC8vIEFub3RoZXIgYXJjIHRoYXQgd29uJ3QgYmUgZHJhd24uIEp1c3QgZm9yIGxhYmVscyBwb3NpdGlvbmluZ1xyXG4gICAgICAgIGNvbnN0IG91dGVyQXJjID0gYXJjKClcclxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuXHJcbiAgICAgICAgY29uc3QgcGllRGF0YSA9IHBpZV8oZGF0YSlcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCdhbGxTbGljZXMnKVxyXG4gICAgICAgICAgICAuZGF0YShwaWVEYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBpbm5lckFyYylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2F0Q29sb3JzKClbZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjcpXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgcG9seWxpbmVzIGJldHdlZW4gY2hhcnQgYW5kIGxhYmVsczpcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCdhbGxQb2x5bGluZXMnKVxyXG4gICAgICAgICAgICAuZGF0YShwaWVEYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwb2x5bGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLmRhdGEudmFsdWUgPiAwLjAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQSA9IGlubmVyQXJjLmNlbnRyb2lkKGQpIC8vIGxpbmUgaW5zZXJ0aW9uIGluIHRoZSBzbGljZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc0IgPSBvdXRlckFyYy5jZW50cm9pZChkKSAvLyBsaW5lIGJyZWFrOiB3ZSB1c2UgdGhlIG90aGVyIGFyYyBnZW5lcmF0b3IgdGhhdCBoYXMgYmVlbiBidWlsdCBvbmx5IGZvciB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpIC8vIExhYmVsIHBvc2l0aW9uID0gYWxtb3N0IHRoZSBzYW1lIGFzIHBvc0JcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWRhbmdsZSA9IGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDIgLy8gd2UgbmVlZCB0aGUgYW5nbGUgdG8gc2VlIGlmIHRoZSBYIHBvc2l0aW9uIHdpbGwgYmUgYXQgdGhlIGV4dHJlbWUgcmlnaHQgb3IgZXh0cmVtZSBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zQ1swXSA9IHJhZGl1cyAqIDAuOTUgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKSAvLyBtdWx0aXBseSBieSAxIG9yIC0xIHRvIHB1dCBpdCBvbiB0aGUgcmlnaHQgb3Igb24gdGhlIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Bvc0EsIHBvc0IsIHBvc0NdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbGFiZWxzOlxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJ2FsbExhYmVscycpXHJcbiAgICAgICAgICAgIC5kYXRhKHBpZURhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuZGF0YS52YWx1ZSA+IDAuMDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IChkLmRhdGEudmFsdWUgKiAxMDApLnRvRml4ZWQoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4obikpIHJldHVybiBuICsgJyUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpXHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgICAgICBwb3NbMF0gPSByYWRpdXMgKiAwLjk5ICogKG1pZGFuZ2xlIDwgTWF0aC5QSSA/IDEgOiAtMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3MgKyAnKSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkYW5nbGUgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG5cclxuICAgICAgICAvLyBhZGQgcmVnaW9uIHZhbHVlcyB0byB0b29sdGlwXHJcbiAgICAgICAgbGV0IGJyZWFrZG93bkRpdiA9IHRwLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnZW0tdG9vbHRpcC1waWVjaGFydC1icmVha2Rvd24nKVxyXG5cclxuICAgICAgICAvLyBzaG93IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBjb2RlIGFuZCBzdGF0IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IHNjID0gb3V0LnN0YXRDb2Rlc19baV1cclxuICAgICAgICAgICAgY29uc3QgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzIGFuZCBzLnZhbHVlIGFyZSB2YWxpZCAoaGFuZGxlIG51bGwsIHVuZGVmaW5lZCwgb3IgMClcclxuICAgICAgICAgICAgaWYgKHMgJiYgcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHMudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdHJpbmcgPSBgPHN0cm9uZz4ke291dC5jYXRMYWJlbHNfW3NjXX08L3N0cm9uZz46ICR7cy52YWx1ZS50b0ZpeGVkKCl9PGJyPmBcclxuICAgICAgICAgICAgICAgIGJyZWFrZG93bkRpdi5odG1sKGJyZWFrZG93bkRpdi5odG1sKCkgKyBzdHJpbmcpIC8vIHNhZmVseSB1cGRhdGUgdGhlIEhUTUxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd3JpdGUgdG90YWwgKGhhbmRsZSBudWxsLCB1bmRlZmluZWQsIG9yIDAgdmFsdWVzIGZvciB0b3RhbClcclxuICAgICAgICBsZXQgdG90YWwgPSBnZXRSZWdpb25Ub3RhbChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgIGlmICh0b3RhbCAhPT0gdW5kZWZpbmVkICYmIHRvdGFsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGJyZWFrZG93bkRpdi5odG1sKGJyZWFrZG93bkRpdi5odG1sKCkgKyBgPHN0cm9uZz5Ub3RhbDwvc3Ryb25nPjogJHt0b3RhbC50b0ZpeGVkKCl9PGJyPmApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzY2FsZVNxcnQsIHNjYWxlTGluZWFyLCBzY2FsZVF1YW50aWxlLCBzY2FsZVF1YW50aXplLCBzY2FsZVRocmVzaG9sZCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBleHRlbnQgfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBpbnRlcnBvbGF0ZU9yUmQgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCB7IGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VNYW55Qm9keSwgZm9yY2VDZW50ZXIsIGZvcmNlQ29sbGlkZSwgZm9yY2VYLCBmb3JjZVkgfSBmcm9tICdkMy1mb3JjZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBQcm9wb3J0aW9uYWxTeW1ib2xMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1wcm9wb3J0aW9uYWwtc3ltYm9scydcclxuaW1wb3J0IHsgc3ltYm9sLCBzeW1ib2xDaXJjbGUsIHN5bWJvbERpYW1vbmQsIHN5bWJvbFN0YXIsIHN5bWJvbENyb3NzLCBzeW1ib2xTcXVhcmUsIHN5bWJvbFRyaWFuZ2xlLCBzeW1ib2xXeWUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yLCBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvcG9ydGlvbmFsIHN5bWJvbCBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgdHJ1ZSwgJ3BzJylcclxuXHJcbiAgICAvL3NoYXBlXHJcbiAgICBvdXQucHNTaGFwZV8gPSAnY2lyY2xlJyAvLyBhY2NlcHRlZCB2YWx1ZXM6IGNpcmNsZSwgYmFyLCBzcXVhcmUsIHN0YXIsIGRpYW1vbmQsIHd5ZSwgY3Jvc3NcclxuICAgIG91dC5wc0N1c3RvbVNoYXBlXyAvLyBzZWUgaHR0cDovL3VzaW5nLWQzanMuY29tLzA1XzEwX3N5bWJvbHMuaHRtbCNoXzY2aUlRNXNKSVRcclxuICAgIG91dC5wc0N1c3RvbVNWR18gLy8gc2VlIGh0dHA6Ly9ibC5vY2tzLm9yZy9qZXNzaWhhbWVsLzk2NDg0OTVcclxuICAgIG91dC5wc1NwaWtlV2lkdGhfID0gNyAvLyAnc3Bpa2UnIHNoYXBlIHdpZHRoc1xyXG4gICAgb3V0LnBzT2Zmc2V0XyA9IHsgeDogMCwgeTogMCB9XHJcblxyXG4gICAgLy9zaXplXHJcbiAgICBvdXQucHNNYXhTaXplXyA9IDMwIC8vIG1heCBzeW1ib2wgc2l6ZVxyXG4gICAgb3V0LnBzTWluU2l6ZV8gPSA1IC8vIG1pbiBzeW1ib2wgc2l6ZVxyXG4gICAgb3V0LnBzQmFyV2lkdGhfID0gMTAgLy9mb3IgdmVydGljYWwgYmFyc1xyXG4gICAgb3V0LnBzTWF4VmFsdWVfID0gdW5kZWZpbmVkIC8vIGFsbG93IHRoZSB1c2VyIHRvIG1hbnVhbGx5IGRlZmluZSB0aGUgZG9tYWluIG9mIHRoZSBzaXppbmcgc2NhbGUuIEUuZy4gaWYgdGhlIHVzZXIgd2FudHMgdG8gdXNlIHRoZSBzYW1lIHNjYWxlIGFjcm9zcyBkaWZmZXJlbnQgbWFwcy5cclxuICAgIG91dC5wc01pblZhbHVlXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnBzU2l6ZVNjYWxlXyA9IHVuZGVmaW5lZCAvLyAnc3FydCcgb3IgJ2xpbmVhcidcclxuXHJcbiAgICAvL2NvbG91clxyXG4gICAgb3V0LnBzRmlsbF8gPSAnIzJkNTBhMCcgLy9zYW1lIGZpbGwgZm9yIGFsbCBzeW1ib2xzIHdoZW4gbm8gdmlzdWFsIHZhcmlhYmxlIChzZXREYXRhKCkpIGZvciAnY29sb3InIGlzIHNwZWNpZmllZFxyXG4gICAgb3V0LnBzRmlsbE9wYWNpdHlfID0gMVxyXG4gICAgb3V0LnBzU3Ryb2tlXyA9ICcjZmZmZmZmJ1xyXG4gICAgb3V0LnBzU3Ryb2tlV2lkdGhfID0gMC4yXHJcbiAgICBvdXQucHNDbGFzc2VzXyA9IDUgLy8gbnVtYmVyIG9mIGNsYXNzZXMgdG8gdXNlIGZvciBjb2xvdXJpbmdcclxuICAgIG91dC5wc0NvbG9yc18gPSBudWxsIC8vY29sb3VycyB0byB1c2UgZm9yIHRocmVzaG9sZCBjb2xvdXJpbmdcclxuICAgIG91dC5wc0NvbG9yRnVuXyA9IGludGVycG9sYXRlT3JSZFxyXG4gICAgb3V0LnBzQ2xhc3NUb0ZpbGxTdHlsZV8gPSB1bmRlZmluZWQgLy9hIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3IgZnJvbSB0aGUgY2xhc3MgaVxyXG5cclxuICAgIC8vdGhlIHRocmVzaG9sZCwgd2hlbiB0aGUgY2xhc3NpZmljYXRpb24gbWV0aG9kIGlzICd0aHJlc2hvbGQnXHJcbiAgICBvdXQucHNUaHJlc2hvbGRzXyA9IFswXVxyXG4gICAgLy90aGUgY2xhc3NpZmljYXRpb24gbWV0aG9kXHJcbiAgICBvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSAncXVhbnRpbGUnIC8vIG9yOiBlcXVpbnRlciwgdGhyZXNob2xkXHJcbiAgICAvL3doZW4gY29tcHV0ZWQgYXV0b21hdGljYWxseSwgZW5zdXJlIHRoZSB0aHJlc2hvbGQgYXJlIG5pY2Ugcm91bmRlZCB2YWx1ZXNcclxuICAgIG91dC5tYWtlQ2xhc3NpZk5pY2VfID0gdHJ1ZVxyXG4gICAgLy9cclxuICAgIC8vdGhlIGNsYXNzaWZpZXI6IGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuIHRoZSBzeW1ib2wgc2l6ZS9jb2xvciBmcm9tIHRoZSBzdGF0IHZhbHVlLlxyXG4gICAgb3V0LmNsYXNzaWZpZXJTaXplXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmNsYXNzaWZpZXJDb2xvcl8gPSB1bmRlZmluZWRcclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gdG9vbHRpcFRleHRGdW5Qc1xyXG5cclxuICAgIC8vZG9ybGluZyBjYXJ0b2dyYW1cclxuICAgIG91dC5kb3JsaW5nXyA9IGZhbHNlXHJcbiAgICBvdXQuZG9ybGluZ1N0cmVuZ3RoXyA9IHsgeDogMSwgeTogMSB9XHJcbiAgICBvdXQuZG9ybGluZ0l0ZXJhdGlvbnNfID0gMVxyXG4gICAgb3V0LnBzQ29kZUxhYmVsc18gPSBmYWxzZSAvLyBzaG93IGNvdW50cnkgY29kZXMgaW4gc3ltYm9sc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ3BzTWF4U2l6ZV8nLFxyXG4gICAgICAgICdwc01pblNpemVfJyxcclxuICAgICAgICAncHNNYXhWYWx1ZV8nLFxyXG4gICAgICAgICdwc01pblZhbHVlXycsXHJcbiAgICAgICAgJ3BzRmlsbF8nLFxyXG4gICAgICAgICdwc0ZpbGxPcGFjaXR5XycsXHJcbiAgICAgICAgJ3BzU3Ryb2tlXycsXHJcbiAgICAgICAgJ3BzU3Ryb2tlV2lkdGhfJyxcclxuICAgICAgICAnY2xhc3NpZmllclNpemVfJyxcclxuICAgICAgICAnY2xhc3NpZmllckNvbG9yXycsXHJcbiAgICAgICAgJ3BzU2hhcGVfJyxcclxuICAgICAgICAncHNDdXN0b21TaGFwZV8nLFxyXG4gICAgICAgICdwc0JhcldpZHRoXycsXHJcbiAgICAgICAgJ3BzQ2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwc0NvbG9yRnVuXycsXHJcbiAgICAgICAgJ3BzU2l6ZVNjYWxlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwc1RocmVzaG9sZHNfJyxcclxuICAgICAgICAncHNDb2xvcnNfJyxcclxuICAgICAgICAncHNDdXN0b21TVkdfJyxcclxuICAgICAgICAncHNPZmZzZXRfJyxcclxuICAgICAgICAncHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8nLFxyXG4gICAgICAgICdwc0NsYXNzZXNfJyxcclxuICAgICAgICAnZG9ybGluZ18nLFxyXG4gICAgICAgICdkb3JsaW5nU3RyZW5ndGhfJyxcclxuICAgICAgICAncHNTcGlrZVdpZHRoXycsXHJcbiAgICAgICAgJ3BzQ29kZUxhYmVsc18nLFxyXG4gICAgICAgICdkb3JsaW5nSXRlcmF0aW9uc18nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAncHNNYXhTaXplJyxcclxuICAgICAgICAgICAgJ3BzTWluU2l6ZScsXHJcbiAgICAgICAgICAgICdwc0ZpbGwnLFxyXG4gICAgICAgICAgICAncHNGaWxsT3BhY2l0eScsXHJcbiAgICAgICAgICAgICdwc1N0cm9rZScsXHJcbiAgICAgICAgICAgICdwc1N0cm9rZVdpZHRoJyxcclxuICAgICAgICAgICAgJ2NsYXNzaWZpZXJTaXplJyxcclxuICAgICAgICAgICAgJ2NsYXNzaWZpZXJDb2xvcicsXHJcbiAgICAgICAgICAgICdwc1NoYXBlJyxcclxuICAgICAgICAgICAgJ3BzQ3VzdG9tU2hhcGUnLFxyXG4gICAgICAgICAgICAncHNCYXJXaWR0aCcsXHJcbiAgICAgICAgICAgICdwc0NsYXNzVG9GaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAncHNDb2xvckZ1bicsXHJcbiAgICAgICAgICAgICdub0RhdGFGaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAncHNUaHJlc2hvbGQnLFxyXG4gICAgICAgICAgICAncHNDb2xvcnMnLFxyXG4gICAgICAgICAgICAncHNDdXN0b21TVkcnLFxyXG4gICAgICAgICAgICAncHNPZmZzZXQnLFxyXG4gICAgICAgICAgICAncHNDbGFzc2lmaWNhdGlvbk1ldGhvZCcsXHJcbiAgICAgICAgICAgICdwc0NsYXNzZXMnLFxyXG4gICAgICAgICAgICAnZG9ybGluZ0l0ZXJhdGlvbnNfJyxcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgb2Ygc29tZSBzcGVjaWFsIGdldHRlcnMvc2V0dGVyc1xyXG4gICAgb3V0LnBzQ29sb3JGdW4gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5wc0NvbG9yRnVuX1xyXG4gICAgICAgIG91dC5wc0NvbG9yRnVuXyA9IHZcclxuICAgICAgICBvdXQucHNDbGFzc1RvRmlsbFN0eWxlXyA9IGdldENvbG9yTGVnZW5kKG91dC5wc0NvbG9yRnVuXywgb3V0LnBzQ29sb3JzXylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcbiAgICBvdXQucHNUaHJlc2hvbGRzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQucHNUaHJlc2hvbGRzX1xyXG4gICAgICAgIG91dC5wc1RocmVzaG9sZHNfID0gdlxyXG4gICAgICAgIG91dC5wc0NsYXNzZXModi5sZW5ndGggKyAxKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vZGVmaW5lIGNsYXNzaWZpZXJzIGZvciBzaXppbmcgYW5kIGNvbG91cmluZyAob3V0LmNsYXNzaWZpZXJTaXplXyAmIG91dC5jbGFzc2lmaWVyQ29sb3JfKVxyXG4gICAgICAgIGRlZmluZUNsYXNzaWZpZXJzKClcclxuXHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBtYWluIG1hcCdzIFNWR1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYXNzaWducyBhIGNvbG9yIHRvIGVhY2ggc3ltYm9sLCBiYXNlZCBvbiB0aGVpciBzdGF0aXN0aWNhbCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHsqfSBtYXBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG1hcCkge1xyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBpZiAob3V0LmNsYXNzaWZpZXJDb2xvcl8pIHtcclxuICAgICAgICAgICAgICAgIC8vYXNzaWduIGNvbG9yIGNsYXNzIHRvIGVhY2ggc3ltYm9sLCBiYXNlZCBvbiB0aGVpciB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgdGhlIHN5bWJvbCBwYXRoIGhhc250IGJlZW4gYXBwZW5kZWQuIE9ubHkgdGhlIHBhcmVudCBnIGVsZW1lbnQgKC5lbS1jZW50cm9pZClcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRGF0YSA9IG1hcC5zdGF0RGF0YSgnY29sb3InKVxyXG4gICAgICAgICAgICAgICAgbWFwLnN2Z18uc2VsZWN0QWxsKCcuZW0tY2VudHJvaWQnKS5hdHRyKCdlY2wnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IGNvbG9yRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSArb3V0LmNsYXNzaWZpZXJDb2xvcl8oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gZGVmaW5lcyBjbGFzc2lmaWVyIGZ1bmN0aW9ucyAob3V0LmNsYXNzaWZpZXJDb2xvciBhbmQgb3V0LmNsYXNzaWZpZXJTaXplKSBmb3IgYm90aCBzeW1ib2wgc2l6ZSBhbmQgY29sb3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVmaW5lQ2xhc3NpZmllcnMoKSB7XHJcbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgc2NhbGVcclxuICAgICAgICBpZiAoIW91dC5wc1NpemVTY2FsZV8pIHtcclxuICAgICAgICAgICAgaWYgKG91dC5wc1NoYXBlXyA9PSAnc3Bpa2UnKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQucHNTaXplU2NhbGVfID0gJ2xpbmVhcidcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dC5wc1NpemVTY2FsZV8gPSAnc3FydCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zaW1wbHkgcmV0dXJuIHRoZSBhcnJheSBbMCwxLDIsMywuLi4sbmItMV1cclxuICAgICAgICBjb25zdCBnZXRBID0gZnVuY3Rpb24gKG5iKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbLi4uQXJyYXkobmIpLmtleXMoKV1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHVzZSBzaXplIGRhdGFzZXRcclxuICAgICAgICBsZXQgcmF3RGF0YSA9IG91dC5zdGF0RGF0YSgnc2l6ZScpLmdldEFycmF5KCkgfHwgb3V0LnN0YXREYXRhKCkuZ2V0QXJyYXkoKVxyXG4gICAgICAgIGxldCBkYXRhID0gcmF3RGF0YS5maWx0ZXIoKGQpID0+IHR5cGVvZiBkID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oZCkgJiYgaXNGaW5pdGUoZCkpXHJcbiAgICAgICAgbGV0IFttaW5WYWwsIG1heFZhbF0gPSBleHRlbnQoZGF0YSlcclxuICAgICAgICBsZXQgbWluID0gb3V0LnBzTWluVmFsdWVfID8/IG1pblZhbFxyXG4gICAgICAgIGxldCBtYXggPSBvdXQucHNNYXhWYWx1ZV8gPz8gbWF4VmFsXHJcbiAgICAgICAgbGV0IHNpemVEb21haW4gPSBkYXRhID8gW21pbiwgbWF4XSA6IFtvdXQuc3RhdERhdGEoKS5nZXRNaW4oKSwgb3V0LnN0YXREYXRhKCkuZ2V0TWF4KCldXHJcblxyXG4gICAgICAgIGxldCBzY2FsZSA9IG91dC5wc1NpemVTY2FsZV8gPT0gJ3NxcnQnID8gc2NhbGVTcXJ0IDogc2NhbGVMaW5lYXJcclxuICAgICAgICBvdXQuY2xhc3NpZmllclNpemUoc2NhbGUoKS5kb21haW4oc2l6ZURvbWFpbikucmFuZ2UoW291dC5wc01pblNpemVfLCBvdXQucHNNYXhTaXplX10pKVxyXG5cclxuICAgICAgICAvLyBjb2xvdXJcclxuICAgICAgICBpZiAob3V0LnN0YXREYXRhKCdjb2xvcicpLmdldEFycmF5KCkpIHtcclxuICAgICAgICAgICAgLy91c2Ugc3VpdGFibGUgY2xhc3NpZmljYXRpb24gdHlwZSBmb3IgY29sb3VyaW5nXHJcbiAgICAgICAgICAgIGlmIChvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPT09ICdxdWFudGlsZScpIHtcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aWxlLXNjYWxlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3V0LnN0YXREYXRhKCdjb2xvcicpLmdldEFycmF5KClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0QShvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyQ29sb3Ioc2NhbGVRdWFudGlsZSgpLmRvbWFpbihkb21haW4pLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPT09ICdlcXVpbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aXplLXNjYWxlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3V0LnN0YXREYXRhKCdjb2xvcicpLmdldEFycmF5KClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0QShvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyQ29sb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVRdWFudGl6ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oW21pbihkb21haW4pLCBtYXgoZG9tYWluKV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShyYW5nZSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFrZUNsYXNzaWZOaWNlXykgb3V0LmNsYXNzaWZpZXJDb2xvcigpLm5pY2UoKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9PT0gJ3RocmVzaG9sZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3RocmVzaG9sZC1zY2FsZXNcclxuICAgICAgICAgICAgICAgIG91dC5wc0NsYXNzZXMob3V0LnBzVGhyZXNob2xkcygpLmxlbmd0aCArIDEpXHJcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGdldEEob3V0LnBzQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgICAgICBvdXQuY2xhc3NpZmllckNvbG9yKHNjYWxlVGhyZXNob2xkKCkuZG9tYWluKG91dC5wc1RocmVzaG9sZHMoKSkucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBwcm9wb3J0aW9uYWwgc3ltYm9sIHN0eWxpbmcgdG8gYSBtYXAgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBtYXBcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVUb01hcChtYXApIHtcclxuICAgICAgICAvL3NlZSBodHRwczovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzQzNDIwNDUgYW5kIGh0dHBzOi8vYm9zdC5vY2tzLm9yZy9taWtlL2J1YmJsZS1tYXAvXHJcbiAgICAgICAgLy9kZWZpbmUgc3R5bGUgcGVyIGNsYXNzXHJcbiAgICAgICAgaWYgKCFvdXQucHNDbGFzc1RvRmlsbFN0eWxlKCkpIG91dC5wc0NsYXNzVG9GaWxsU3R5bGUoZ2V0Q29sb3JMZWdlbmQob3V0LnBzQ29sb3JGdW5fLCBvdXQucHNDb2xvcnNfKSlcclxuXHJcbiAgICAgICAgLy8gaWYgc2l6ZSBkYXRhc2V0IG5vdCBkZWZpbmVkIHRoZW4gdXNlIGRlZmF1bHRcclxuICAgICAgICBsZXQgc2l6ZURhdGEgPSBtYXAuc3RhdERhdGEoJ3NpemUnKS5nZXRBcnJheSgpID8gbWFwLnN0YXREYXRhKCdzaXplJykgOiBtYXAuc3RhdERhdGEoKVxyXG5cclxuICAgICAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICAgICAgLy9jbGVhciBwcmV2aW91cyBjZW50cm9pZHNcclxuICAgICAgICAgICAgbGV0IHByZXZTeW1ib2xzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCc6bm90KCNlbS1pbnNldHMtZ3JvdXApIGcuZW0tY2VudHJvaWQgPiAqJylcclxuICAgICAgICAgICAgcHJldlN5bWJvbHMucmVtb3ZlKClcclxuXHJcbiAgICAgICAgICAgIC8vICdzbWFsbCcgY2VudHJvaWRzIG9uIHRvcCBvZiBiaWcgb25lc1xyXG4gICAgICAgICAgICB1cGRhdGVTeW1ib2xzRHJhd09yZGVyKG1hcClcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGVuZCBzeW1ib2xzIHRvIGNlbnRyb2lkc1xyXG4gICAgICAgICAgICBsZXQgc3ltYlxyXG4gICAgICAgICAgICBpZiAob3V0LnBzQ3VzdG9tU1ZHXykge1xyXG4gICAgICAgICAgICAgICAgc3ltYiA9IGFwcGVuZEN1c3RvbVN5bWJvbHNUb01hcChtYXAsIHNpemVEYXRhKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5wc1NoYXBlXyA9PSAnYmFyJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYiA9IGFwcGVuZEJhcnNUb01hcChtYXAsIHNpemVEYXRhKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5wc1NoYXBlXyA9PSAnY2lyY2xlJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYiA9IGFwcGVuZENpcmNsZXNUb01hcChtYXAsIHNpemVEYXRhKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5wc1NoYXBlXyA9PSAnc3Bpa2UnKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kU3Bpa2VzVG9NYXAobWFwLCBzaXplRGF0YSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNpcmNsZSwgY3Jvc3MsIHN0YXIsIHRyaWFuZ2xlLCBkaWFtb25kLCBzcXVhcmUsIHd5ZSBvciBjdXN0b21cclxuICAgICAgICAgICAgICAgIHN5bWIgPSBhcHBlbmREM1N5bWJvbHNUb01hcChtYXAsIHNpemVEYXRhKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBkb3JsaW5nIGNhcnRvZ3JhbVxyXG4gICAgICAgICAgICBpZiAob3V0LmRvcmxpbmdfKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBseURvcmxpbmdGb3JjZShtYXAsIHNpemVEYXRhKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaW11bGF0aW9uKSBzdG9wU2ltdWxhdGlvbigpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFwcGVuZExhYmVsc1RvU3ltYm9scyhtYXAsIHNpemVEYXRhKVxyXG5cclxuICAgICAgICAgICAgLy8gc2V0IHN0eWxlIG9mIHN5bWJvbHNcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblxyXG4gICAgICAgICAgICBpZiAobWFwLmdlb18gIT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkU3ltYm9sc1RvTWl4ZWROVVRTKG1hcCwgc2l6ZURhdGEsIHJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgJ25kJyBjbGFzcyB0byBubyBkYXRhIGZvciBsZWdlbmQgaXRlbSBob3ZlclxyXG4gICAgICAgICAgICAgICAgcmVnaW9ucy5hdHRyKCdlY2wnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YgfHwgKCFzdi52YWx1ZSAmJiBzdiAhPT0gMCAmJiBzdi52YWx1ZSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk8gSU5QVVRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChzdiAmJiBzdi52YWx1ZSkgfHwgKHN2ICYmIHN2LnZhbHVlID09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdi52YWx1ZSA9PSAnOicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERBVEEgTk9UIEFWQUlMQUJMRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNldFN5bWJvbFN0eWxlcyhzeW1iKVxyXG5cclxuICAgICAgICAgICAgYWRkTW91c2VFdmVudHMobWFwKVxyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGxhYmVscyBmb3Igc3RhdGlzdGljYWwgdmFsdWVzIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXz8udmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQudXBkYXRlVmFsdWVzTGFiZWxzKG1hcClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFwXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXBwZW5kTGFiZWxzVG9TeW1ib2xzID0gZnVuY3Rpb24gKG1hcCwgc2l6ZURhdGEpIHtcclxuICAgICAgICBsZXQgc3ltYm9sQ29udGFpbmVycyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgIC8vY291bnRyeSBjb2RlIGxhYmVsc1xyXG4gICAgICAgIGlmIChvdXQucHNDb2RlTGFiZWxzXykge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudHJ5Q29kZUxhYmVsID0gc3ltYm9sQ29udGFpbmVyc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0/LnZhbHVlICE9PSAnOicgJiYgZGF0dW0/LnZhbHVlICE9IG51bGwgLy8gSWdub3JlIGAnOidgLCBgbnVsbGAsIGFuZCBgdW5kZWZpbmVkYFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNpcmNsZS1jb2RlLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bT8udmFsdWUgPT09ICc6JyA/ICcnIDogZC5wcm9wZXJ0aWVzLmlkIC8vIEhpZGUgdGV4dCBpZiB2YWx1ZSBpcyAnOidcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ3NhbnMtc2VyaWYnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByYWRpdXNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gZGF0dW0gPyBvdXQuY2xhc3NpZmllclNpemVfKGRhdHVtLnZhbHVlKSA6IDBcclxuICAgICAgICAgICAgICAgICAgICAvLyBzaXplIGFkanVzdG1lbnQgZmFjdG9yIGRlcGVuZHMgb24gc3ltYm9sIHR5cGUsIGFuZCB3aGV0aGVyIHN0YXQgdmFsdWVzIGFyZSBhbHNvIGFkZGVkIHRvIHRoZSBjaXJjbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IG91dC5sYWJlbHNfPy52YWx1ZXMgJiYgc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZCk/LnZhbHVlID8gMC44IDogMC45XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5wc1NoYXBlXyA9PT0gJ3NxdWFyZScpIGZhY3RvciA9IGZhY3RvciAtIDAuNFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtyYWRpdXMgKiBmYWN0b3J9cHhgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKG91dC5wc0ZpbGxfKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIChkKSA9PiAob3V0LmxhYmVsc18/LnZhbHVlcyAmJiBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKT8udmFsdWUgPyAnLTAuM2VtJyA6ICcwJykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3N0YXQgbGFiZWxzXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfPy52YWx1ZXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdExhYmVscyA9IHN5bWJvbENvbnRhaW5lcnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtPy52YWx1ZSAhPT0gJzonICYmIGRhdHVtPy52YWx1ZSAhPSBudWxsIC8vIElnbm9yZSBgJzonYCwgYG51bGxgLCBhbmQgYHVuZGVmaW5lZGBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jaXJjbGUtc3RhdC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0dW0/LnZhbHVlKSByZXR1cm4gZGF0dW0udmFsdWVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ3NhbnMtc2VyaWYnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByYWRpdXNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gZGF0dW0gPyBvdXQuY2xhc3NpZmllclNpemVfKGRhdHVtLnZhbHVlKSA6IDBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7cmFkaXVzICogMC40fXB4YFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZChvdXQucHNGaWxsXykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAoZCkgPT4gKG91dC5wc0NvZGVMYWJlbHNfID8gJzAuNmVtJyA6ICcwJykpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZE1vdXNlRXZlbnRzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIGxldCBzeW1ib2xzID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgc3ltYm9sc1xyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMuY2hpbGROb2Rlc1swXSlcclxuICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBvdXQuaG92ZXJDb2xvcl8pXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24ocmcsIG91dCkpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMuY2hpbGROb2Rlc1swXSlcclxuICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0ZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBuZXdGaWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gc2V0cyBjb2xvci9zdHJva2Uvb3BhY2l0eSBzdHlsZXMgb2YgYWxsIHN5bWJvbHNcclxuICAgICAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBzeW1iIHN5bWJvbHMgZDMgc2VsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNldFN5bWJvbFN0eWxlcyhzeW1iKSB7XHJcbiAgICAgICAgc3ltYi5zdHlsZSgnZmlsbC1vcGFjaXR5Jywgb3V0LnBzRmlsbE9wYWNpdHkoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBvdXQucHNTdHJva2UoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBvdXQucHNTdHJva2VXaWR0aCgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LmNsYXNzaWZpZXJDb2xvcl8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZvciBwcywgZWNsIGF0dHJpYnV0ZSBiZWxvbmdzIHRvIHRoZSBwYXJlbnQgZy5lbS1jZW50cm9pZCBub2RlIGNyZWF0ZWQgaW4gbWFwLXRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbCB8fCBlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlXyB8fCAnZ3JheSdcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBvdXQucHNDbGFzc1RvRmlsbFN0eWxlXyhlY2wsIG91dC5wc0NsYXNzZXNfKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvclxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0LnBzRmlsbF9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGxfX18nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsbCA9IHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsbCAvLyBzYXZlIGZvciBsZWdlbmQgbW91c2VvdmVyXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVXBkYXRlcyB0aGUgZHJhdyBvcmRlciBvZiB0aGUgc3ltYm9scyBhY2NvcmRpbmcgdG8gdGhlaXIgZGF0YSB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTeW1ib2xzRHJhd09yZGVyKG1hcCkge1xyXG4gICAgICAgIGNvbnN0IGdjcCA9IG1hcC5zdmdfLnNlbGVjdCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgY29uc3Qgc2l6ZURhdGEgPSBtYXAuc3RhdERhdGEoJ3NpemUnKT8uZ2V0QXJyYXk/LigpID8gbWFwLnN0YXREYXRhKCdzaXplJykgOiBtYXAuc3RhdERhdGEoKVxyXG5cclxuICAgICAgICAvLyAxLiBGaWx0ZXIgYW5kIHNvcnQgZmVhdHVyZXMgd2l0aCBkYXRhXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkID0gbWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzaXplRGF0YS5nZXQ/LihmLnByb3BlcnRpZXMuaWQpPy52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ICE9IG51bGwgJiYgdiAhPT0gJzonXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZURhdGEuZ2V0KGIucHJvcGVydGllcy5pZCkudmFsdWUgLSBzaXplRGF0YS5nZXQoYS5wcm9wZXJ0aWVzLmlkKS52YWx1ZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIDIuIENsZWFyIGFuZCByZWJpbmRcclxuICAgICAgICAgICAgZ2NwLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgICAgICBnY3Auc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHNvcnRlZCwgKGQpID0+IGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jZW50cm9pZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gJ3BzJyArIGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gYHRyYW5zbGF0ZSgke2QucHJvcGVydGllcy5jZW50cm9pZFswXS50b0ZpeGVkKDMpfSwke2QucHJvcGVydGllcy5jZW50cm9pZFsxXS50b0ZpeGVkKDMpfSlgKVxyXG5cclxuICAgICAgICAgICAgLy8gMy4gYWRkIHRoZSBlY2wgYXR0cmlidXRlIGJhY2sgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgZyBlbGVtZW50c1xyXG4gICAgICAgICAgICBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSAvL1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRTcGlrZXNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgLy9UaGUgc3Bpa2UgZnVuY3Rpb24gY3JlYXRlcyBhIHRyaWFuZ3VsYXIgcGF0aCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoIChoZWlnaHQpIHdpdGggYSBiYXNlIHdpZHRoIG9mIDcgcGl4ZWxzLlxyXG4gICAgICAgIGNvbnN0IHNwaWtlID0gKGxlbmd0aCwgd2lkdGggPSBvdXQucHNTcGlrZVdpZHRoXykgPT4gYE0key13aWR0aCAvIDJ9LDBMMCwkey1sZW5ndGh9TCR7d2lkdGggLyAyfSwwYFxyXG4gICAgICAgIGxldCBzeW1ib2xDb250YWluZXJzID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBjaXJjbGVzIHRvIGVhY2ggc3ltYm9sIGNvbnRhaW5lclxyXG4gICAgICAgIGNvbnN0IHNwaWtlcyA9IHN5bWJvbENvbnRhaW5lcnNcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0dW0gPyBvdXQuY2xhc3NpZmllclNpemVfKGRhdHVtLnZhbHVlKSA6IDBcclxuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gc3Bpa2UodmFsdWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCkgPT4gZC5jb2xvciB8fCAnc3RlZWxibHVlJykgLy8gQWRqdXN0IGNvbG9yIGFzIG5lZWRlZFxyXG4gICAgICAgICAgICAvLy5hdHRyKCdmaWxsJywgbWFwLnBzRmlsbF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCBtYXAucHNGaWxsT3BhY2l0eV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBtYXAucHNTdHJva2VfKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgbWFwLnBzU3Ryb2tlV2lkdGhfKVxyXG5cclxuICAgICAgICByZXR1cm4gc3Bpa2VzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQXBwZW5kcyA8Y2lyY2xlPiBlbGVtZW50cyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcCBTVkdcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBzaXplRGF0YSBzdGF0aXN0aWNhbCBkYXRhIGZvciBzaXplIGUuZy4gbWFwLnN0YXREYXRhKCdzaXplJylcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFwcGVuZENpcmNsZXNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgLy8gQXBwZW5kIGNpcmNsZXMgdG8gZWFjaCBzeW1ib2wgY29udGFpbmVyXHJcbiAgICAgICAgY29uc3QgY2lyY2xlcyA9IG1hcFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bSAmJiBkYXR1bS52YWx1ZSAhPT0gJzonICYmIGRhdHVtLnZhbHVlICE9IG51bGxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gb3V0LmNsYXNzaWZpZXJTaXplXyhkYXR1bS52YWx1ZSlcclxuICAgICAgICAgICAgICAgIGlmIChyYWRpdXMgPCAwKSBjb25zb2xlLmVycm9yKCdOZWdhdGl2ZSByYWRpdXMgZm9yIGNpcmNsZTonLCBkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocmFkaXVzKSkgY29uc29sZS5lcnJvcignTmFOIHJhZGl1cyBmb3IgY2lyY2xlOicsIGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIHJldHVybiByYWRpdXNcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZXNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseURvcmxpbmdGb3JjZShtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgbGV0IHN5bWJvbENvbnRhaW5lcnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuXHJcbiAgICAgICAgaWYgKG91dC5zaW11bGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHN0b3BTaW11bGF0aW9uKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGZvcmNlIHNpbXVsYXRpb25cclxuICAgICAgICBjb25zb2xlLmxvZygnbmV3IGRvcmxpbmcgc2ltdWxhdGlvbicpXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24gPSBmb3JjZVNpbXVsYXRpb24obWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcylcclxuICAgICAgICAgICAgLmZvcmNlKFxyXG4gICAgICAgICAgICAgICAgJ3gnLFxyXG4gICAgICAgICAgICAgICAgZm9yY2VYKChkKSA9PiBkLnByb3BlcnRpZXMuY2VudHJvaWRbMF0pLnN0cmVuZ3RoKG91dC5kb3JsaW5nU3RyZW5ndGhfLngpIC8vIFN0cm9uZ2VyIHB1bGwgdG8gb3JpZ2luYWwgeFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5mb3JjZShcclxuICAgICAgICAgICAgICAgICd5JyxcclxuICAgICAgICAgICAgICAgIGZvcmNlWSgoZCkgPT4gZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzFdKS5zdHJlbmd0aChvdXQuZG9ybGluZ1N0cmVuZ3RoXy55KSAvLyBTdHJvbmdlciBwdWxsIHRvIG9yaWdpbmFsIHlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuZm9yY2UoXHJcbiAgICAgICAgICAgICAgICAnY29sbGlkZScsXHJcbiAgICAgICAgICAgICAgICBmb3JjZUNvbGxpZGUoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LnBzU2hhcGVfID09PSAnc3F1YXJlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNpemUgLyAyKSAqIE1hdGguU1FSVDIgLy8gQWRqdXN0IGZvciBkaWFnb25hbCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZSAvLyBEZWZhdWx0IGZvciBjaXJjbGVzXHJcbiAgICAgICAgICAgICAgICB9KS5pdGVyYXRpb25zKG91dC5kb3JsaW5nSXRlcmF0aW9uc18pIC8vIE1vcmUgaXRlcmF0aW9ucyB0byBpbXByb3ZlIGNvbGxpc2lvbiBoYW5kbGluZ1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC8vLmFscGhhVGFyZ2V0KDAuMykgLy8gSGVscHMga2VlcCBjZW50cm9pZHMgYW5jaG9yZWRcclxuICAgICAgICAgICAgLm9uKCd0aWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGVsZW1lbnRzIHdpdGggdGhlIG5ldyBwb3NpdGlvbnMgYW5kIHJhZGlpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2xDb250YWluZXJzLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiAndHJhbnNsYXRlKCcgKyBkLnggKyAnLCcgKyBkLnkgKyAnKScpXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vb3V0LnNpbXVsYXRpb24uYWxwaGEoMSkucmVzdGFydCgpIC8vIEVuc3VyZXMgc2ltdWxhdGlvbiBzdGFydHMgd2l0aCBmdWxsIHN0cmVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RvcFNpbXVsYXRpb24oKSB7XHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24uc3RvcCgpIC8vIFN0b3BzIHRoZSBpbnRlcm5hbCB0aWNrIGxvb3BcclxuICAgICAgICBvdXQuc2ltdWxhdGlvbi5vbigndGljaycsIG51bGwpIC8vIFJlbW92ZSB0aWNrIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24ub24oJ2VuZCcsIG51bGwpIC8vIFJlbW92ZSBlbmQgZXZlbnQgbGlzdGVuZXJcclxuICAgICAgICBvdXQuc2ltdWxhdGlvbiA9IG51bGwgLy8gUmVtb3ZlIHJlZmVyZW5jZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGVuZHMgPHBhdGg+IGVsZW1lbnRzIGNvbnRhaW5pbmcgc3ltYm9scyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcCBTVkdcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBzaXplRGF0YSBlLmcuIG1hcC5zdGF0RGF0YSgnc2l6ZScpXHJcbiAgICAgKiBAcmV0dXJuIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBlbmREM1N5bWJvbHNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChyZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmIChzdiAmJiBzdi52YWx1ZSAhPT0gJzonKSByZXR1cm4gcmdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BzJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHNpemVcclxuICAgICAgICAgICAgICAgIGlmICghc2l6ZURhdGEpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmIChzdiAhPSAwICYmICFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oK3N2LnZhbHVlKSB8fCAwXHJcblxyXG4gICAgICAgICAgICAgICAgLy9hcHBseSBzaXplIHRvIHNoYXBlXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnBzQ3VzdG9tU2hhcGVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dC5wc0N1c3RvbVNoYXBlXy5zaXplKHNpemUgKiBzaXplKSgpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbFR5cGUgPSBzeW1ib2xzTGlicmFyeVtvdXQucHNTaGFwZV9dIHx8IHN5bWJvbHNMaWJyYXJ5WydjaXJjbGUnXVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2woKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudHlwZShzeW1ib2xUeXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2l6ZShzaXplICogc2l6ZSkoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGVuZHMgPHJlY3Q+IGVsZW1lbnRzIGNvbnRhaW5pbmcgYmFycyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcCBTVkdcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBzaXplRGF0YSBlLmcuIG1hcC5zdGF0RGF0YSgnc2l6ZScpXHJcbiAgICAgKiBAcmV0dXJuIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRCYXJzVG9NYXAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIG1hcFxyXG4gICAgICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tcHJvcC1zeW1ib2xzJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChyZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN2ICYmIHN2LnZhbHVlICE9PSAnOicpIHJldHVybiByZ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5wc0JhcldpZHRoXylcclxuICAgICAgICAgICAgICAgIC8vZm9yIHZlcnRpY2FsIGJhcnMgd2Ugc2NhbGUgdGhlIGhlaWdodCBhdHRyaWJ1dGUgdXNpbmcgdGhlIGNsYXNzaWZpZXJcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YgfHwgIXN2LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2ID0gb3V0LmNsYXNzaWZpZXJTaXplXygrc3YudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBiUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgkey10aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDJ9YCArIGAsIC0ke3RoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKX0pYFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gdG8gdXNlIHRyYW5zaXRpb25zIHdlIG5lZWQgdG8gcmVmYWN0b3IgdGhlIGRyYXdpbmcgZnVuY3Rpb25zIHRvIHByb21pc2VzIGUuZy4gYXBwZW5kQmFyc1RvTWFwKCkudGhlbigoKT0+e30pXHJcbiAgICAgICAgICAgIC8vdGhpcyBpcyBiZWNhdXNlIC5hdHRyKCdmaWxsX19fJywgZnVuY3Rpb24gKCkge3NlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcpfSkgZG9lc250IHdvcmsgdW5sZXNzIHlvdSBleGVjdXRlIGl0IGFmdGVyIHRoZSB0cmFuc2l0aW9uIGVuZHMuXHJcbiAgICAgICAgICAgIC8vIGUuZy5cclxuICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAvLyAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAvLyAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAocmcpIHt9KVxyXG4gICAgICAgICAgICAvLyAuZW5kKClcclxuICAgICAgICAgICAgLy8gLnRoZW4oKVxyXG4gICAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIGN1c3RvbSBTVkcgc3ltYm9scyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcFxyXG4gICAgICogQHBhcmFtIHsqfSBtYXBcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGFcclxuICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFwcGVuZEN1c3RvbVN5bWJvbHNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc3YgJiYgc3YudmFsdWUgIT09ICc6JykgcmV0dXJuIHJnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwcycpXHJcbiAgICAgICAgICAgIC5odG1sKG91dC5wc0N1c3RvbVNWR18pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHNpemVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oK3N2LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke291dC5wc09mZnNldF8ueCAqIHNpemV9LCR7b3V0LnBzT2Zmc2V0Xy55ICogc2l6ZX0pIHNjYWxlKCR7c2l6ZX0pYFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGFkZHMgcHJvcG9ydGlvbmFsIHN5bWJvbHMgdG8gZWFjaCByZWdpb25zIGluIGEgbWFwIHdpdGggbWl4ZWQgTlVUUyBsZXZlbHMgKElNQUdFKVxyXG4gICAgICogQHBhcmFtIHsqfSBtYXBcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGFcclxuICAgICAqIEBwYXJhbSB7Kn0gcmVnaW9uc1xyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkU3ltYm9sc1RvTWl4ZWROVVRTKG1hcCwgc2l6ZURhdGEsIHJlZ2lvbnMpIHtcclxuICAgICAgICAvLyB0b2dnbGUgZGlzcGxheSBvZiBtaXhlZCBOVVRTIGxldmVsc1xyXG4gICAgICAgIHJlZ2lvbnMuc3R5bGUoJ2Rpc3BsYXknLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VtLWNudHJnJykpIHJldHVybiAvLyBTa2lwIGNvdW50cnkgcmVnaW9uc1xyXG4gICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICBpZiAoIXN2IHx8ICghc3YudmFsdWUgJiYgc3YgIT09IDAgJiYgc3YudmFsdWUgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBzeW1ib2wgZm9yIG5vIGRhdGFcclxuICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSdcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXAuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Jsb2NrJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gbnV0cyBib3JkZXIgc3Ryb2tlXHJcbiAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsdmwgPSBzZWwuYXR0cignbHZsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHNlbC5zdHlsZSgnc3Ryb2tlJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICFzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobHZsICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cm9rZSB8fCAnIzc3NydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBudXRzIGJvcmRlciBzdHJva2Ugd2lkdGhcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHNlbC5zdHlsZSgnc3Ryb2tlLXdpZHRoJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICFzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGx2bCAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJva2VXaWR0aCB8fCAnIzc3NydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHN0eWxlIHRvIGluc2V0c1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHNcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdlbyBpbiBvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb10ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXRzIHdpdGggc2FtZSBnZW8gdGhhdCBkbyBub3Qgc2hhcmUgdGhlIHNhbWUgcGFyZW50IGluc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIDIgZGlmZmVyZW50IGluc2V0cyB3aXRoIHRoZSBzYW1lIGdlby4gRS5nLiAzIGluc2V0cyBmb3IgUFQyMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV0ubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dW2ldW2NdLnN2Z0lkXyAhPT0gb3V0LnN2Z0lkXykgYXBwbHlTdHlsZVRvTWFwKG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXVtjXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV0uc3ZnSWRfICE9PSBvdXQuc3ZnSWRfKSBhcHBseVN0eWxlVG9NYXAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmlxdWUgaW5zZXQgZ2VvX1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb10uc3ZnSWRfICE9PSBvdXQuc3ZnSWRfKSBhcHBseVN0eWxlVG9NYXAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gUHJvcG9ydGlvbmFsU3ltYm9sTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLy9idWlsZCBhIGNvbG9yIGxlZ2VuZCBvYmplY3RcclxuZXhwb3J0IGNvbnN0IGdldENvbG9yTGVnZW5kID0gZnVuY3Rpb24gKGNvbG9yRnVuLCBjb2xvckFycmF5KSB7XHJcbiAgICBjb2xvckZ1biA9IGNvbG9yRnVuIHx8IGludGVycG9sYXRlT3JSZFxyXG4gICAgaWYgKGNvbG9yQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckFycmF5W2VjbF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuKGVjbCAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBnaXZlIGEgZDMgc3ltYm9sIGZyb20gYSBzaGFwZSBuYW1lXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3ltYm9sc0xpYnJhcnkgPSB7XHJcbiAgICBjcm9zczogc3ltYm9sQ3Jvc3MsXHJcbiAgICBzcXVhcmU6IHN5bWJvbFNxdWFyZSxcclxuICAgIGRpYW1vbmQ6IHN5bWJvbERpYW1vbmQsXHJcbiAgICB0cmlhbmdsZTogc3ltYm9sVHJpYW5nbGUsXHJcbiAgICBzdGFyOiBzeW1ib2xTdGFyLFxyXG4gICAgd3llOiBzeW1ib2xXeWUsXHJcbiAgICBjaXJjbGU6IHN5bWJvbENpcmNsZSxcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwZWNpZmljIGZ1bmN0aW9uIGZvciB0b29sdGlwIHRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcmcgVGhlIHJlZ2lvbiB0byBzaG93IGluZm9ybWF0aW9uIG9uLlxyXG4gKiBAcGFyYW0geyp9IG1hcCBUaGUgbWFwIGVsZW1lbnRcclxuICovXHJcbmNvbnN0IHRvb2x0aXBUZXh0RnVuUHMgPSBmdW5jdGlvbiAocmVnaW9uLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcblxyXG4gICAgLy8gSGVhZGVyIHdpdGggcmVnaW9uIG5hbWUgYW5kIElEXHJcbiAgICBjb25zdCByZWdpb25OYW1lID0gcmVnaW9uLnByb3BlcnRpZXMubmFcclxuICAgIGNvbnN0IHJlZ2lvbklkID0gcmVnaW9uLnByb3BlcnRpZXMuaWRcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+XHJcbiAgICAgICAgICAgIDxiPiR7cmVnaW9uTmFtZX08L2I+JHtyZWdpb25JZCA/IGAgKCR7cmVnaW9uSWR9KWAgOiAnJ31cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgLy9zdGF0IDEgdmFsdWVcclxuICAgIGNvbnN0IHYxID0gbWFwLnN0YXREYXRhKCdzaXplJykuZ2V0QXJyYXkoKSA/IG1hcC5zdGF0RGF0YSgnc2l6ZScpIDogbWFwLnN0YXREYXRhKClcclxuICAgIGNvbnN0IHN2MSA9IHYxLmdldChyZWdpb24ucHJvcGVydGllcy5pZClcclxuICAgIGlmICghc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSkgYnVmLnB1c2gobWFwLm5vRGF0YVRleHRfKVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy91bml0IDFcclxuICAgICAgICBjb25zdCB1bml0MSA9IHYxLnVuaXRUZXh0KClcclxuICAgICAgICBidWYucHVzaChgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIj4ke3NwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpfSAke3VuaXQxID8gdW5pdDEgOiAnICd9PC9kaXY+YClcclxuICAgIH1cclxuXHJcbiAgICAvL3N0YXQgMiB2YWx1ZVxyXG4gICAgaWYgKG1hcC5zdGF0RGF0YSgnY29sb3InKS5nZXRBcnJheSgpKSB7XHJcbiAgICAgICAgY29uc3Qgc3YyID0gbWFwLnN0YXREYXRhKCdjb2xvcicpLmdldChyZWdpb24ucHJvcGVydGllcy5pZClcclxuICAgICAgICBpZiAoIXN2MiB8fCAoc3YyLnZhbHVlICE9IDAgJiYgIXN2Mi52YWx1ZSkpIGJ1Zi5wdXNoKG1hcC5ub0RhdGFUZXh0XylcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9zdGF0IDJcclxuICAgICAgICAgICAgY29uc3QgdW5pdDIgPSBtYXAuc3RhdERhdGEoJ2NvbG9yJykudW5pdFRleHQoKVxyXG4gICAgICAgICAgICBidWYucHVzaChgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIj4ke3NwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjIudmFsdWUpfSAke3VuaXQyID8gdW5pdDIgOiAnICd9PC9kaXY+YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCwgY3JlYXRlIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVTcXJ0IH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IGxpbmUsIGFyZWEgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgZXh0ZW50LCBtaW4sIG1heCB9IGZyb20gJ2QzLWFycmF5J1xyXG5pbXBvcnQgeyBheGlzQm90dG9tLCBheGlzTGVmdCwgYXhpc1JpZ2h0IH0gZnJvbSAnZDMtYXhpcydcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBsZ2NoIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aCdcclxuaW1wb3J0IHsgZ2V0UmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuaW1wb3J0ICogYXMgU3RhdGlzdGljYWxEYXRhIGZyb20gJy4uL2NvcmUvc3RhdC1kYXRhJ1xyXG4vKipcclxuICogUmV0dXJucyBhIHNwYXJrbGluZSBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgdHJ1ZSwgJ3NwYXJrJylcclxuXHJcbiAgICBvdXQuc3BhcmtMaW5lQ29sb3JfID0gJ2JsYWNrJ1xyXG4gICAgb3V0LnNwYXJrQXJlYUNvbG9yXyA9ICcjNDFhZmFhJ1xyXG4gICAgb3V0LnNwYXJrTGluZVdpZHRoXyA9IDMwXHJcbiAgICBvdXQuc3BhcmtMaW5lSGVpZ2h0XyA9IDIwXHJcbiAgICBvdXQuc3BhcmtMaW5lU3Ryb2tlV2lkdGhfID0gMC40XHJcbiAgICBvdXQuc3BhcmtMaW5lT3BhY2l0eV8gPSAwLjZcclxuICAgIG91dC5zcGFya1R5cGVfID0gJ2xpbmUnXHJcbiAgICBvdXQuc3BhcmtMaW5lQ2lyY2xlUmFkaXVzXyA9IDBcclxuICAgIG91dC5zcGFya1Rvb2x0aXBDaGFydF8gPSB7XHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBoZWlnaHQ6IDUwLFxyXG4gICAgICAgIG1hcmdpbjogeyBsZWZ0OiA2MCwgcmlnaHQ6IDQwLCB0b3A6IDQwLCBib3R0b206IDQwIH0sXHJcbiAgICAgICAgY2lyY2xlUmFkaXVzOiAxLjUsXHJcbiAgICB9XHJcblxyXG4gICAgLy9zaG93IHNwYXJrbGluZXMgb25seSB3aGVuIGRhdGEgZm9yIGFsbCBkYXRlcyBpcyBjb21wbGV0ZS5cclxuICAgIC8vT3RoZXJ3aXNlLCBjb25zaWRlciB0aGUgcmVnaW9ucyBhcyBiZWluZyB3aXRoIG5vIGRhdGEgYXQgYWxsLlxyXG4gICAgb3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlXyA9IGZhbHNlXHJcbiAgICBvdXQuc3BhcmtMaW5lQ2hhcnRGdW5jdGlvbl8gPSB1bmRlZmluZWRcclxuXHJcbiAgICBvdXQuc3RhdFNwYXJrXyA9IG51bGxcclxuICAgIG91dC5zcGFya0hlaWdodENsYXNzaWZpZXJfID0gbnVsbFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ3NwYXJrTGluZUNvbG9yXycsXHJcbiAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlXycsXHJcbiAgICAgICAgJ3NwYXJrVHlwZV8nLFxyXG4gICAgICAgICdzcGFya0xpbmVXaWR0aF8nLFxyXG4gICAgICAgICdzcGFya0xpbmVIZWlnaHRfJyxcclxuICAgICAgICAnc3BhcmtMaW5lU3Ryb2tlV2lkdGhfJyxcclxuICAgICAgICAnc3BhcmtMaW5lT3BhY2l0eV8nLFxyXG4gICAgICAgICdzcGFya0xpbmVDaXJjbGVSYWRpdXNfJyxcclxuICAgICAgICAnc3BhcmtMaW5lQXJlYUNvbG9yXycsXHJcbiAgICAgICAgJ3NwYXJrVG9vbHRpcENoYXJ0XycsXHJcbiAgICAgICAgJ3NwYXJrTGluZUNoYXJ0RnVuY3Rpb25fJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ3NwYXJrTGluZUNvbG9yJyxcclxuICAgICAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlJyxcclxuICAgICAgICAgICAgJ3NwYXJrVHlwZScsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVXaWR0aCcsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVIZWlnaHQnLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lU3Ryb2tlV2lkdGgnLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lT3BhY2l0eScsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVDaXJjbGVSYWRpdXNfJyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZUFyZWFDb2xvcicsXHJcbiAgICAgICAgICAgICdzcGFya1Rvb2x0aXBDaGFydF8nLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lQ2hhcnRGdW5jdGlvbl8nLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy8gQWxsb3cgdXNlcnMgbWFudWFsbHkgYWRkIHNwYXJrbGluZSBkYXRhXHJcbiAgICBvdXQuc3BhcmtsaW5lRGF0YV8gPSB1bmRlZmluZWRcclxuICAgIG91dC5zcGFya2xpbmVEYXRhID0gZnVuY3Rpb24gKGRhdGFPYmplY3QpIHtcclxuICAgICAgICBjb25zdCBkYXRlcyA9IE9iamVjdC5rZXlzKGRhdGFPYmplY3RbT2JqZWN0LmtleXMoZGF0YU9iamVjdClbMF1dKVxyXG4gICAgICAgIG91dC5fc3RhdERhdGVzID0gZGF0ZXNcclxuXHJcbiAgICAgICAgZGF0ZXMuZm9yRWFjaCgoZGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0RGF0YSA9IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpXHJcbiAgICAgICAgICAgIGNvbnN0IHBlckRhdGVWYWx1ZXMgPSB7fVxyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCByZWdpb25JZCBpbiBkYXRhT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25WYWx1ZXMgPSBkYXRhT2JqZWN0W3JlZ2lvbklkXVxyXG4gICAgICAgICAgICAgICAgcGVyRGF0ZVZhbHVlc1tyZWdpb25JZF0gPSByZWdpb25WYWx1ZXNbZGF0ZV1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RhdERhdGEuc2V0RGF0YShwZXJEYXRlVmFsdWVzKVxyXG4gICAgICAgICAgICBvdXQuc3RhdERhdGEoZGF0ZSwgc3RhdERhdGEpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0byBkZWZpbmUgYSBzcGFya2xpbmUgbWFwIGVhc2lseSwgd2l0aG91dCByZXBldGl0aW9uIG9mIGluZm9ybWF0aW9uLlxyXG4gICAgICogT25seSBmb3IgZXVyb2Jhc2UgZGF0YSBzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gc3RhdCBBIHBhdHRlcm4gZm9yIHRoZSBzdGF0IGRhdGEgc291cmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRlcyBUaGUgZGF0ZXMgb2YgdGhlIGNvbXBvc2l0aW9uICh0aW1lIHBhcmFtZXRlcilcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVscyBPcHRpb25hbDogVGhlIGxhYmVscyBmb3IgdGhlIGRhdGVzXHJcbiAgICAgKi9cclxuICAgIG91dC5zdGF0U3BhcmsgPSBmdW5jdGlvbiAoc3RhdCwgZGF0ZXMsIGxhYmVscykge1xyXG4gICAgICAgIC8vYWRkIG9uZSBkYXRhc2V0IGNvbmZpZyBmb3IgZWFjaCBjYXRlZ29yeVxyXG4gICAgICAgIHN0YXQuZmlsdGVycyA9IHN0YXQuZmlsdGVycyB8fCB7fVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9jYXRlZ29yeSBjb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBkYXRlc1tpXVxyXG4gICAgICAgICAgICBzdGF0LmZpbHRlcnMudGltZSA9IGRhdGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIHNjXy5maWx0ZXJzID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQuZmlsdGVycykgc2NfLmZpbHRlcnNba2V5XSA9IHN0YXQuZmlsdGVyc1trZXldXHJcbiAgICAgICAgICAgIG91dC5zdGF0KGRhdGUsIHNjXylcclxuXHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChsYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfW2RhdGVdID0gbGFiZWxzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IHN0YXRDb2Rlc1xyXG4gICAgICAgIG91dC5fc3RhdERhdGVzID0gZGF0ZXNcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgY29kZXMgb2YgdGhlIGNhdGVnb3JpZXMgdG8gY29uc2lkZXIgZm9yIHRoZSBjb21wb3NpdGlvbi4gKi9cclxuICAgIG91dC5fc3RhdERhdGVzID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBjb21wdXRlIGNvbXBvc2l0aW9uIGZvciByZWdpb24gaWQsIGZvciBlYWNoIGRhdGUuXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGgsIGZvciBlYWNoIGRhdGUsIGl0cyBzdGF0aXN0aWNhbCB2YWx1ZSBmb3IgdGhlIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIHsqfSBpZFxyXG4gICAgICogQHJldHVybnMgW3tkYXRlLHZhbHVlfV1cclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0Q29tcG9zaXRpb24gPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgY29tcCA9IFtdLFxyXG4gICAgICAgICAgICBzdW0gPSAwXHJcblxyXG4gICAgICAgIC8vIEdldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5IGFuZCBjb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuX3N0YXREYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBjb2RlIGFuZCBzdGF0IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBvdXQuX3N0YXREYXRlc1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzID0gb3V0LnN0YXREYXRhKGRhdGUpLmdldChpZClcclxuXHJcbiAgICAgICAgICAgIC8vIENhc2Ugd2hlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xyXG4gICAgICAgICAgICBpZiAoIXMgfHwgKHMudmFsdWUgIT0gMCAmJiAhcy52YWx1ZSkgfHwgaXNOYU4ocy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZWxzZSBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21wLnB1c2goeyBkYXRlOiBkYXRlLCB2YWx1ZTogcy52YWx1ZSB9KVxyXG4gICAgICAgICAgICBzdW0gKz0gcy52YWx1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FzZSB3aGVuIG5vIGRhdGFcclxuICAgICAgICBpZiAoc3VtID09IDApIHJldHVybiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHllYXItb24teWVhciBwZXJjZW50YWdlIGNoYW5nZVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29tcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gY29tcFtpIC0gMV0udmFsdWVcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY29tcFtpXS52YWx1ZVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2UgY2hhbmdlIGZyb20gcHJldmlvdXMgdmFsdWVcclxuICAgICAgICAgICAgY29tcFtpXS5wZXJjZW50YWdlQ2hhbmdlID0gcHJldmlvdXNWYWx1ZSA9PT0gMCA/IDAuMDAxIDogKChjdXJyZW50VmFsdWUgLSBwcmV2aW91c1ZhbHVlKSAvIHByZXZpb3VzVmFsdWUpICogMTAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgZmlyc3QgZGF0YSBwb2ludCBkb2Vzbid0IGhhdmUgYSBwcmV2aW91cyB2YWx1ZSB0byBjb21wYXJlIHdpdGhcclxuICAgICAgICAvL2NvbXBbMF0ucGVyY2VudGFnZUNoYW5nZSA9IDAuMDAxIC8vIG9yIHlvdSBjYW4gbGVhdmUgaXQgdW5kZWZpbmVkIG9yIG51bGwsIGRlcGVuZGluZyBvbiBob3cgeW91IHdhbnQgdG8gaGFuZGxlIGl0XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2lmIG5vdCBwcm92aWRlZCwgZ2V0IGxpc3Qgb2Ygc3RhdCBjb2RlcyBmcm9tIHRoZSBtYXAgc3RhdCBkYXRhXHJcbiAgICAgICAgaWYgKCFvdXQuX3N0YXREYXRlcykge1xyXG4gICAgICAgICAgICAvL2dldCBsaXN0IG9mIHN0YXQgY29kZXMuXHJcbiAgICAgICAgICAgIG91dC5fc3RhdERhdGVzID0gT2JqZWN0LmtleXMob3V0LnN0YXREYXRhXylcclxuICAgICAgICAgICAgLy9yZW1vdmUgXCJkZWZhdWx0XCIsIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvdXQuX3N0YXREYXRlcy5pbmRleE9mKCdkZWZhdWx0JylcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIG91dC5fc3RhdERhdGVzLnNwbGljZShpbmRleCwgMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRlZmluZSBzaXplIHNjYWxpbmcgZnVuY3Rpb25cclxuICAgICAgICAvLyBEZWZpbmUgdGhlIGRvbWFpbiBjb3JyZWN0bHkgZm9yIHRoZSBsb2cgc2NhbGVcclxuICAgICAgICBvdXQuZG9tYWluID0gZ2V0RGF0YXNldE1heE1pbigpIC8vIEF2b2lkIDAgZm9yIGxvZyBzY2FsZVxyXG5cclxuICAgICAgICAvLyBmb3IgYXJlYSBjaGFydHNcclxuICAgICAgICBvdXQud2lkdGhDbGFzc2lmaWVyXyA9IHNjYWxlU3FydCgpLmRvbWFpbihvdXQuZG9tYWluKS5yYW5nZShbMCwgb3V0LnNwYXJrTGluZVdpZHRoX10pXHJcbiAgICAgICAgb3V0LmhlaWdodENsYXNzaWZpZXJfID0gc2NhbGVTcXJ0KCkuZG9tYWluKG91dC5kb21haW4pLnJhbmdlKFswLCBvdXQuc3BhcmtMaW5lSGVpZ2h0X10pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vYnVpbGQgYW5kIGFzc2lnbiBwaWUgY2hhcnRzIHRvIHRoZSByZWdpb25zXHJcbiAgICAgICAgLy9jb2xsZWN0IG51dHMgaWRzIGZyb20gZyBlbGVtZW50cy4gVE9ETzogZmluZCBiZXR0ZXIgd2F5IG9mIGdldHRpbmcgSURzXHJcbiAgICAgICAgbGV0IG51dHNJZHMgPSBbXVxyXG4gICAgICAgIGxldCBzID0gb3V0LnN2ZygpLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgbGV0IHN5bSA9IHMuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykuYXR0cignaWQnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgbnV0c0lkcy5wdXNoKHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgIHJldHVybiAnc3BhcmtfJyArIHJnLnByb3BlcnRpZXMuaWRcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBzZXQgcmVnaW9uIGhvdmVyIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3Iob3V0KVxyXG4gICAgICAgIGxldCByZWdpb25zID0gb3V0LnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBvdXQuaG92ZXJDb2xvcl8pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldENvbXBvc2l0aW9uKHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRGaWxsID0gc2VsLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0ZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIGFkZFNwYXJrTGluZXNUb01hcChudXRzSWRzKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTcGFya0xpbmVzVG9NYXAoaWRzKSB7XHJcbiAgICAgICAgaWRzLmZvckVhY2goKG51dHNpZCkgPT4ge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBzdmcgZm9yIHNwYXJrbGluZVxyXG4gICAgICAgICAgICAvLyBjYW4gYmUgbW9yZSB0aGFuIG9uZSBjZW50ZXIgcG9pbnQgZm9yIGVhY2ggbnV0cyBJRCAoZS5nLiBNYWx0YSB3aGVuIGluY2x1ZGVkIGluIGluc2V0cylcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBvdXQuc3ZnKCkuc2VsZWN0KCcjc3BhcmtfJyArIG51dHNpZClcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBnZXRDb21wb3NpdGlvbihudXRzaWQpXHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlU3BhcmtMaW5lQ2hhcnQobm9kZSwgZGF0YSwgb3V0LnNwYXJrTGluZVdpZHRoXywgb3V0LnNwYXJrTGluZUhlaWdodF8pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNwYXJrTGluZUNoYXJ0KG5vZGUsIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGlzRm9yVG9vbHRpcCA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gY2FsbCBjdXN0b20gdXNlciBmdW5jdGlvbiB0byBkcmF3IHRoZSBzcGFya2xpbmVcclxuICAgICAgICBpZiAob3V0LnNwYXJrTGluZUNoYXJ0RnVuY3Rpb25fICYmIG91dC5zcGFya0xpbmVDaGFydEZ1bmN0aW9uXyAhPT0gY3JlYXRlU3BhcmtMaW5lQ2hhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5zcGFya0xpbmVDaGFydEZ1bmN0aW9uXyhub2RlLCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBpc0ZvclRvb2x0aXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB4U2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oWzAsIG91dC5fc3RhdERhdGVzLmxlbmd0aCAtIDFdKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAuNSwgd2lkdGggLSAwLjVdKVxyXG5cclxuICAgICAgICBjb25zdCBtaW5WYWx1ZSA9IG1pbihkYXRhLm1hcCgoZCkgPT4gZC52YWx1ZSkpIHx8IDBcclxuICAgICAgICBjb25zdCBtYXhWYWx1ZSA9IG1heChkYXRhLm1hcCgoZCkgPT4gZC52YWx1ZSkpIHx8IDFcclxuXHJcbiAgICAgICAgY29uc3QgeVNjYWxlID0gc2NhbGVMaW5lYXIoKS5kb21haW4oW21pblZhbHVlLCBtYXhWYWx1ZV0pLnJhbmdlKFtoZWlnaHQsIDBdKVxyXG5cclxuICAgICAgICBjb25zdCBzY2FsZWREYXRhID0gZGF0YS5tYXAoKGQsIGkpID0+ICh7XHJcbiAgICAgICAgICAgIC4uLmQsXHJcbiAgICAgICAgICAgIHNjYWxlZFhWYWx1ZTogeFNjYWxlKGkpLFxyXG4gICAgICAgICAgICBzY2FsZWRZVmFsdWU6IHlTY2FsZShkLnZhbHVlKSxcclxuICAgICAgICB9KSlcclxuXHJcbiAgICAgICAgY29uc3QgemVyb1kgPSB5U2NhbGUoMClcclxuXHJcbiAgICAgICAgaWYgKGlzRm9yVG9vbHRpcCkge1xyXG4gICAgICAgICAgICAvLyBYLWF4aXMgYXQgYm90dG9tXHJcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzLXgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtoZWlnaHR9KWApXHJcbiAgICAgICAgICAgICAgICAuY2FsbChcclxuICAgICAgICAgICAgICAgICAgICBheGlzQm90dG9tKHhTY2FsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tzKG91dC5fc3RhdERhdGVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoKGQsIGkpID0+IG91dC5fc3RhdERhdGVzW2ldKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHgnLCAnLS44ZW0nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4xNWVtJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKC02NSknKVxyXG5cclxuICAgICAgICAgICAgLy8gWS1heGlzIHdpdGggcmF3IHZhbHVlIGxhYmVsc1xyXG4gICAgICAgICAgICBub2RlLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2F4aXMteScpLmNhbGwoYXhpc0xlZnQoeVNjYWxlKS50aWNrcyg1KSlcclxuXHJcbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgemVybyByZWZlcmVuY2UgbGluZSDihpIgb25seSBpZiBtaW4gPCAwIGFuZCBtYXggPiAwXHJcbiAgICAgICAgICAgIGlmIChtaW5WYWx1ZSA8IDAgJiYgbWF4VmFsdWUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB6ZXJvWSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB6ZXJvWSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2dyYXknKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzIsMicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxpbmVHZW5lcmF0b3IgPSBsaW5lKClcclxuICAgICAgICAgICAgLngoKGQpID0+IGQuc2NhbGVkWFZhbHVlKVxyXG4gICAgICAgICAgICAueSgoZCkgPT4gZC5zY2FsZWRZVmFsdWUpXHJcblxyXG4gICAgICAgIGlmIChvdXQuc3BhcmtUeXBlXyA9PT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXR1bShzY2FsZWREYXRhKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCB0eXBlb2Ygb3V0LnNwYXJrQXJlYUNvbG9yXyA9PT0gJ2Z1bmN0aW9uJyA/IChkLCBpKSA9PiBvdXQuc3BhcmtBcmVhQ29sb3JfKGQsIGkpIDogb3V0LnNwYXJrQXJlYUNvbG9yXylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIG91dC5zcGFya0xpbmVPcGFjaXR5XylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAwLjMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICAgICAnZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJlYSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC54KChkKSA9PiBkLnNjYWxlZFhWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnkwKHplcm9ZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAueTEoKGQpID0+IGQuc2NhbGVkWVZhbHVlKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbm9kZS5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0dW0oc2NhbGVkRGF0YSlcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5Jywgb3V0LnNwYXJrTGluZU9wYWNpdHlfKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgdHlwZW9mIG91dC5zcGFya0xpbmVDb2xvcl8gPT09ICdmdW5jdGlvbicgPyAoZCwgaSkgPT4gb3V0LnNwYXJrTGluZUNvbG9yXyhkLCBpKSA6IG91dC5zcGFya0xpbmVDb2xvcl8pXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCcsXHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3V0LnNwYXJrTGluZVN0cm9rZVdpZHRoXyA9PT0gJ2Z1bmN0aW9uJyA/IChkLCBpKSA9PiBvdXQuc3BhcmtMaW5lU3Ryb2tlV2lkdGhfKGQsIGkpIDogb3V0LnNwYXJrTGluZVN0cm9rZVdpZHRoXyArICdweCdcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGxpbmVHZW5lcmF0b3IpXHJcblxyXG4gICAgICAgIG5vZGUuc2VsZWN0QWxsKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAuZGF0YShzY2FsZWREYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignY3gnLCAoZCkgPT4gZC5zY2FsZWRYVmFsdWUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIChkKSA9PiBkLnNjYWxlZFlWYWx1ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBvdXQuc3BhcmtMaW5lQ2lyY2xlUmFkaXVzXylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAncmVkJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdub25lJylcclxuICAgIH1cclxuXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZWdpb24sIG1hcCkge1xyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdXHJcblxyXG4gICAgICAgIGNvbnN0IHJlZ2lvbk5hbWUgPSByZWdpb24ucHJvcGVydGllcy5uYVxyXG4gICAgICAgIGNvbnN0IHJlZ2lvbklkID0gcmVnaW9uLnByb3BlcnRpZXMuaWRcclxuICAgICAgICBidWYucHVzaChgXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGI+JHtyZWdpb25OYW1lfTwvYj4ke3JlZ2lvbklkID8gYCAoJHtyZWdpb25JZH0pYCA6ICcnfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIGApXHJcblxyXG4gICAgICAgIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gb3V0LnNwYXJrVG9vbHRpcENoYXJ0Xy5oZWlnaHRcclxuICAgICAgICBjb25zdCBjaGFydFdpZHRoID0gb3V0LnNwYXJrVG9vbHRpcENoYXJ0Xy53aWR0aFxyXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IG91dC5zcGFya1Rvb2x0aXBDaGFydF8ubWFyZ2luXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldENvbXBvc2l0aW9uKHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKVxyXG5cclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBUb3RhbCBTVkcgc2l6ZSAoaW5jbHVkaW5nIG1hcmdpbnMpXHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSBjaGFydFdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHRcclxuICAgICAgICAgICAgY29uc3QgdG90YWxIZWlnaHQgPSBjaGFydEhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tXHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgZGV0YWNoZWQgZGl2XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZSgnZGl2JykuYXR0cignY2xhc3MnLCAnZW0tdG9vbHRpcC1jaGFydC1jb250YWluZXInKVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFNWRyB3aXRoIGZ1bGwgc2l6ZVxyXG4gICAgICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXIuYXBwZW5kKCdzdmcnKS5hdHRyKCdjbGFzcycsICdlbS10b29sdGlwLWNoYXJ0LXN2ZycpLmF0dHIoJ3dpZHRoJywgdG90YWxXaWR0aCkuYXR0cignaGVpZ2h0JywgdG90YWxIZWlnaHQpXHJcblxyXG4gICAgICAgICAgICAvLyBJbm5lciBncm91cCB3aGVyZSBjaGFydCBpcyBkcmF3blxyXG4gICAgICAgICAgICBjb25zdCBnID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sICR7bWFyZ2luLnRvcH0pYClcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgc3BhcmtsaW5lIGRyYXdpbmcgb24gdGhlIGlubmVyIGFyZWEgb25seVxyXG4gICAgICAgICAgICBjcmVhdGVTcGFya0xpbmVDaGFydChnLCBkYXRhLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgdHJ1ZSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdG9vbHRpcCBidWZmZXJcclxuICAgICAgICAgICAgYnVmLnB1c2goY29udGFpbmVyLm5vZGUoKS5vdXRlckhUTUwpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gZ2V0RGF0YXNldE1heE1pblxyXG4gICAgICogQGRlc2NyaXB0aW9uIGdldHMgdGhlIG1heGltdW0gYW5kIG1pbmltdW0gdmFsdWVzIG9mIGFsbCBkYXRlcyBmb3IgZWFjaCByZWdpb24uIFVzZWQgdG8gZGVmaW5lIHRoZSBkb21haW4gb2YgdGhlIHNwYXJrbGluZSBZIGF4aXMuXHJcbiAgICAgKiBAcmV0dXJucyBbbWluLG1heF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YXNldE1heE1pbigpIHtcclxuICAgICAgICBjb25zdCBtYXhzID0gW11cclxuICAgICAgICBjb25zdCBzZWwgPSBvdXQuc3ZnKCkuc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJykuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykuZGF0YSgpXHJcblxyXG4gICAgICAgIHNlbC5mb3JFYWNoKChyZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IHJnLnByb3BlcnRpZXMuaWRcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uTWF4ID0gZ2V0UmVnaW9uTWF4KGlkKVxyXG4gICAgICAgICAgICBpZiAocmVnaW9uTWF4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG1heHMucHVzaChyZWdpb25NYXgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBpZiAobWF4cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFswLCAxXSAvLyBmYWxsYmFjayBpZiBubyBkYXRhIGZvdW5kXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXh0ZW50KG1heHMpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWJzb2x1dGUgdG90YWwgdmFsdWUgb2YgY29tYmluZWQgc3RhdGlzdGljYWwgdmFsdWVzIGZvciBhIHNwZWNpZmljIHJlZ2lvbi4gRS5nIHRvdGFsIGxpdmVzdG9ja1xyXG4gICAgICogQHBhcmFtIHsqfSBpZCBudXRzIHJlZ2lvbiBpZFxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRSZWdpb25NYXggPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgbWF4ID0gMFxyXG5cclxuICAgICAgICAvLyBnZXQgc3RhdCB2YWx1ZSBmb3IgZWFjaCBkYXRlIGFuZCBmaW5kIHRoZSBtYXhcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5fc3RhdERhdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBvdXQuX3N0YXREYXRlc1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzdGF0RGF0YSA9IG91dC5zdGF0RGF0YShkYXRlKVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzdGF0RGF0YSB8fCB0eXBlb2Ygc3RhdERhdGEuZ2V0ICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcyA9IHN0YXREYXRhLmdldChpZClcclxuICAgICAgICAgICAgaWYgKCFzIHx8IChzLnZhbHVlICE9PSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocy52YWx1ZSA+IG1heCkgbWF4ID0gcy52YWx1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1heCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgIHJldHVybiBtYXhcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vVE9ETyBkZWZpbmUgbGVnZW5kXHJcbiAgICAgICAgcmV0dXJuIGxnY2gubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vL2J1aWxkIGEgY29sb3IgbGVnZW5kIG9iamVjdFxyXG5leHBvcnQgY29uc3QgZ2V0Q29sb3JMZWdlbmQgPSBmdW5jdGlvbiAoY29sb3JGdW4pIHtcclxuICAgIGNvbG9yRnVuID0gY29sb3JGdW4gfHwgaW50ZXJwb2xhdGVZbE9yUmRcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZWNsLCBudW1iZXJPZkNsYXNzZXMpIHtcclxuICAgICAgICByZXR1cm4gY29sb3JGdW4oZWNsIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpKVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgYXJjLCBwaWUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgc2NoZW1lQ2F0ZWdvcnkxMCB9IGZyb20gJ2QzLXNjYWxlLWNocm9tYXRpYydcclxuLy9zY2hlbWVTZXQzIHNjaGVtZURhcmsyIHNjaGVtZVBhc3RlbDEgc2NoZW1lVGFibGVhdTEwXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgU3RyaXBlQ29tcG9zaXRpb25MZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1zdHJpcGUtY29tcG9zaXRpb24nXHJcbmltcG9ydCB7IGdldENTU1Byb3BlcnR5RnJvbUNsYXNzLCBnZXRSZWdpb25zU2VsZWN0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG4vKipcclxuICogUmV0dXJuIGEgc3RyaXBlIGNvbXBvc2l0aW9uIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCBmYWxzZSwgJ3Njb21wJylcclxuXHJcbiAgICAvL3dpZHRoIG9mIHRoZSBzdHJpcGVzIHNlcmllXHJcbiAgICBvdXQuc3RyaXBlV2lkdGhfID0gNTBcclxuICAgIC8vb3JpZW50YXRpb24gLSB2ZXJ0aWNhbCBieSBkZWZhdWx0XHJcbiAgICBvdXQuc3RyaXBlT3JpZW50YXRpb25fID0gMFxyXG5cclxuICAgIC8vY29sb3JzIC0gaW5kZXhlZCBieSBjYXRlZ29yeSBjb2RlXHJcbiAgICBvdXQuY2F0Q29sb3JzXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9sYWJlbHMgLSBpbmRleGVkIGJ5IGNhdGVnb3J5IGNvZGVcclxuICAgIG91dC5jYXRMYWJlbHNfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9zaG93IHN0cmlwZXMgb25seSB3aGVuIGRhdGEgZm9yIGFsbCBjYXRlZ29yaWVzIGlzIGNvbXBsZXRlLlxyXG4gICAgLy9PdGhlcndpc2UsIGNvbnNpZGVyIHRoZSByZWdpb25zIGFzIGJlaW5nIHdpdGggbm8gZGF0YSBhdCBhbGwuXHJcbiAgICBvdXQuc2hvd09ubHlXaGVuQ29tcGxldGVfID0gZmFsc2VcclxuXHJcbiAgICAvL3Rvb2x0aXAgcGllIGNoYXJ0XHJcbiAgICBvdXQucGllQ2hhcnRSYWRpdXNfID0gNDBcclxuICAgIG91dC5waWVDaGFydElubmVyUmFkaXVzXyA9IDE1XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnc3RyaXBlV2lkdGhfJyxcclxuICAgICAgICAnc3RyaXBlT3JpZW50YXRpb25fJyxcclxuICAgICAgICAnY2F0Q29sb3JzXycsXHJcbiAgICAgICAgJ2NhdExhYmVsc18nLFxyXG4gICAgICAgICdzaG93T25seVdoZW5Db21wbGV0ZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAncGllQ2hhcnRSYWRpdXNfJyxcclxuICAgICAgICAncGllQ2hhcnRJbm5lclJhZGl1c18nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnc3RyaXBlV2lkdGgnLFxyXG4gICAgICAgICAgICAnc3RyaXBlT3JpZW50YXRpb24nLFxyXG4gICAgICAgICAgICAnY2F0Q29sb3JzJyxcclxuICAgICAgICAgICAgJ2NhdExhYmVscycsXHJcbiAgICAgICAgICAgICdzaG93T25seVdoZW5Db21wbGV0ZScsXHJcbiAgICAgICAgICAgICdub0RhdGFGaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAncGllQ2hhcnRSYWRpdXMnLFxyXG4gICAgICAgICAgICAncGllQ2hhcnRJbm5lclJhZGl1cycsXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdG8gZGVmaW5lIGEgc3RyaXBlIG1hcCBlYXNpbHksIHdpdGhvdXQgcmVwZXRpdGlvbiBvZiBpbmZvcm1hdGlvbi5cclxuICAgICAqIE9ubHkgZm9yIGV1cm9iYXNlIGRhdGEgc291cmNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHN0YXQgQSBwYXR0ZXJuIGZvciB0aGUgc3RhdCBkYXRhIHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRpbSBUaGUgZGltZW5zaW9uIG9mIHRoZSBjb21wb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvZGVzIFRoZSBjYXRlZ29yeSBjb2RlcyBvZiB0aGUgY29tcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVscyBPcHRpb25hbDogVGhlIGxhYmVscyBmb3IgdGhlIGNhdGVnb3J5IGNvZGVzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgT3B0aW9uYWw6IFRoZSBjb2xvcnMgZm9yIHRoZSBjYXRlZ29yeVxyXG4gICAgICovXHJcbiAgICBvdXQuc3RhdENvbXAgPSBmdW5jdGlvbiAoc3RhdCwgZGltLCBjb2RlcywgbGFiZWxzLCBjb2xvcnMpIHtcclxuICAgICAgICAvL2FkZCBvbmUgZGF0YXNldCBjb25maWcgZm9yIGVhY2ggY2F0ZWdvcnlcclxuICAgICAgICBzdGF0LmZpbHRlcnMgPSBzdGF0LmZpbHRlcnMgfHwge31cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vY2F0ZWdvcnkgY29kZVxyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gY29kZXNbaV1cclxuICAgICAgICAgICAgc3RhdC5maWx0ZXJzW2RpbV0gPSBjb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IHNjXyA9IHt9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0KSBzY19ba2V5XSA9IHN0YXRba2V5XVxyXG4gICAgICAgICAgICBzY18uZmlsdGVycyA9IHt9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0LmZpbHRlcnMpIHNjXy5maWx0ZXJzW2tleV0gPSBzdGF0LmZpbHRlcnNba2V5XVxyXG4gICAgICAgICAgICBvdXQuc3RhdChjb2RlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgcmV0cmlldmUgYW5kIGFzc2lnbiBjb2xvclxyXG4gICAgICAgICAgICBpZiAoY29sb3JzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzXyA9IG91dC5jYXRDb2xvcnNfIHx8IHt9XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzX1tjb2RlXSA9IGNvbG9yc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChsYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfW2NvZGVdID0gbGFiZWxzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IHN0YXRDb2Rlc1xyXG4gICAgICAgIHN0YXRDb2RlcyA9IGNvZGVzXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGNvZGVzIG9mIHRoZSBjYXRlZ29yaWVzIHRvIGNvbnNpZGVyIGZvciB0aGUgY29tcG9zaXRpb24uICovXHJcbiAgICBsZXQgc3RhdENvZGVzID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBjb21wdXRlIGNvbXBvc2l0aW9uIGZvciByZWdpb24gaWQsIGZvciBlYWNoIGNhdGVnb3J5LlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoLCBmb3IgZWFjaCBjYXRlZ29yeSwgdGhlIHNoYXJlIFswLDFdIG9mIHRoZSBjYXRlZ29yeS5cclxuICAgICAqIEBwYXJhbSB7Kn0gaWRcclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0Q29tcG9zaXRpb24gPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgY29tcCA9IHt9LFxyXG4gICAgICAgICAgICBzdW0gPSAwXHJcbiAgICAgICAgLy9nZXQgc3RhdCB2YWx1ZSBmb3IgZWFjaCBjYXRlZ29yeS4gQ29tcHV0ZSB0aGUgc3VtLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdENvZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vcmV0cmlldmUgY29kZSBhbmQgc3RhdCB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBzYyA9IHN0YXRDb2Rlc1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzID0gb3V0LnN0YXREYXRhKHNjKS5nZXQoaWQpXHJcblxyXG4gICAgICAgICAgICAvL2Nhc2Ugd2hlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xyXG4gICAgICAgICAgICBpZiAoIXMgfHwgKHMudmFsdWUgIT0gMCAmJiAhcy52YWx1ZSkgfHwgaXNOYU4ocy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZWxzZSBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21wW3NjXSA9IHMudmFsdWVcclxuICAgICAgICAgICAgc3VtICs9IHMudmFsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2FzZSB3aGVuIG5vIGRhdGFcclxuICAgICAgICBpZiAoc3VtID09IDApIHJldHVybiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHJhdGlvc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdENvZGVzLmxlbmd0aDsgaSsrKSBjb21wW3N0YXRDb2Rlc1tpXV0gLz0gc3VtXHJcblxyXG4gICAgICAgIHJldHVybiBjb21wXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2lmIG5vdCBwcm92aWRlZCwgZ2V0IGxpc3Qgb2Ygc3RhdCBjb2RlcyBmcm9tIHRoZSBtYXAgc3RhdCBkYXRhXHJcbiAgICAgICAgaWYgKCFzdGF0Q29kZXMpIHtcclxuICAgICAgICAgICAgLy9nZXQgbGlzdCBvZiBzdGF0IGNvZGVzLlxyXG4gICAgICAgICAgICBzdGF0Q29kZXMgPSBPYmplY3Qua2V5cyhvdXQuc3RhdERhdGFfKVxyXG4gICAgICAgICAgICAvL3JlbW92ZSBcImRlZmF1bHRcIiwgaWYgcHJlc2VudFxyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRDb2Rlcy5pbmRleE9mKCdkZWZhdWx0JylcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHN0YXRDb2Rlcy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2lmIG5vdCBzcGVjaWZpZWQsIGJ1aWxkIGRlZmF1bHQgY29sb3IgcmFtcFxyXG4gICAgICAgIGlmICghb3V0LmNhdENvbG9ycygpKSB7XHJcbiAgICAgICAgICAgIG91dC5jYXRDb2xvcnMoe30pXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdENvZGVzLmxlbmd0aDsgaSsrKSBvdXQuY2F0Q29sb3JzKClbc3RhdENvZGVzW2ldXSA9IHNjaGVtZUNhdGVnb3J5MTBbaSAlIDEwXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiBub3Qgc3BlY2lmaWVkLCBpbml0aWFsaXNlIGNhdGVnb3J5IGxhYmVsc1xyXG4gICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuXHJcbiAgICAgICAgLy9idWlsZCBhbmQgYXNzaWduIHRleHR1cmUgdG8gdGhlIHJlZ2lvbnNcclxuICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbChnZXRSZWdpb25zU2VsZWN0b3Iob3V0KSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlbS1jbnRyZycpKSByZXR1cm4gLy8gU2tpcCBjb3VudHJ5IHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZC5wcm9wZXJ0aWVzLmlkXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb21wdXRlIGNvbXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGlvbiA9IGdldENvbXBvc2l0aW9uKGlkKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY2FzZSB3aGVuIG5vIG9yIG1pc3NpbmcgZGF0YVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb3NpdGlvbikgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuXHJcbiAgICAgICAgICAgICAgICAvL21ha2Ugc3RyaXBlIHBhdHRlcm5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHQgPSBvdXRcclxuICAgICAgICAgICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAncGF0dGVybl8nICsgaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAnMCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAnMCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnN0cmlwZVdpZHRoKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BhdHRlcm5Vbml0cycsICd1c2VyU3BhY2VPblVzZScpXHJcbiAgICAgICAgICAgICAgICAvL3VzZSBvcmllbnRhdGlvbiwgaWYgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnN0cmlwZU9yaWVudGF0aW9uKCkpIHBhdHQuYXR0cigncGF0dGVyblRyYW5zZm9ybScsICdyb3RhdGUoJyArIG91dC5zdHJpcGVPcmllbnRhdGlvbigpICsgJyknKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vYmFja2dyb3VuZFxyXG4gICAgICAgICAgICAgICAgcGF0dC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnN0cmlwZVdpZHRoKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ2xpZ2h0Z3JheScpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHN0cmlwZXMsIG9uZSBwZXIgY2F0ZWdvcnlcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gMFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSBpbiBjb21wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHN0cmlwZSBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGR4ID0gY29tcG9zaXRpb25bY29kZV1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWR4KSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGR4ICo9IG91dC5zdHJpcGVXaWR0aCgpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHN0cmlwZSBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IG91dC5jYXRDb2xvcnMoKVtjb2RlXSB8fCAnbGlnaHRncmF5J1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FkZCBzdHJpcGUgdG8gcGF0dGVybjogYSB0aGluIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NvZGUnLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjb2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJhbnNpdGlvbiBhbG9uZyB4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKG91dC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZHgpXHJcbiAgICAgICAgICAgICAgICAgICAgeCArPSBkeFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHBhdHRlcm4gcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VybCgjcGF0dGVybl8nICsgaWQgKyAnKSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ25kJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhZ2V0Q29tcG9zaXRpb24oZC5wcm9wZXJ0aWVzLmlkKSA/ICduZCcgOiAnJ1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBzZXQgcmVnaW9uIGhvdmVyIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3Iob3V0KVxyXG4gICAgICAgIGxldCByZWdpb25zID0gb3V0LnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBvdXQuaG92ZXJDb2xvcl8pXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24ocmcsIG91dCkpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RmlsbCA9IHNlbC5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmlsbCA9IHNlbC5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gU3RyaXBlQ29tcG9zaXRpb25MZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgICAgIC8vZ2V0IHRvb2x0aXBcclxuICAgICAgICBjb25zdCB0cCA9IHNlbGVjdCgnI3Rvb2x0aXBfZXVyb3N0YXQnKVxyXG5cclxuICAgICAgICAvL2NsZWFyXHJcbiAgICAgICAgdHAuaHRtbCgnJylcclxuICAgICAgICB0cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL3dyaXRlIHJlZ2lvbiBuYW1lXHJcbiAgICAgICAgY29uc3QgcmVnaW9uTmFtZSA9IHJnLnByb3BlcnRpZXMubmEgfHwgcmcucHJvcGVydGllcy5uYW1lXHJcbiAgICAgICAgaWYgKHJnLnByb3BlcnRpZXMuaWQpIHtcclxuICAgICAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgICAgIHRwLmFwcGVuZCgnZGl2JykuaHRtbCgnPGI+JyArIHJlZ2lvbk5hbWUgKyAnPC9iPiAoJyArIHJnLnByb3BlcnRpZXMuaWQgKyAnKSA8YnI+JylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL3JlZ2lvbiBuYW1lXHJcbiAgICAgICAgICAgIHRwLmFwcGVuZCgnZGl2JykuaHRtbCgnPGI+JyArIHJlZ2lvbk5hbWUgKyAnPC9iPjxicj4nKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9wcmVwYXJlIGRhdGEgZm9yIHBpZSBjaGFydFxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXVxyXG4gICAgICAgIGNvbnN0IGNvbXAgPSBnZXRDb21wb3NpdGlvbihyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXApIGRhdGEucHVzaCh7IGNvZGU6IGtleSwgdmFsdWU6IGNvbXBba2V5XSB9KVxyXG5cclxuICAgICAgICAvL2Nhc2Ugb2YgcmVnaW9ucyB3aXRoIG5vIGRhdGFcclxuICAgICAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmh0bWwob3V0Lm5vRGF0YVRleHQoKSlcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NyZWF0ZSBzdmcgZm9yIHBpZSBjaGFydFxyXG4gICAgICAgIGNvbnN0IHIgPSBvdXQucGllQ2hhcnRSYWRpdXMoKSxcclxuICAgICAgICAgICAgaXIgPSBvdXQucGllQ2hhcnRJbm5lclJhZGl1cygpXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gdHBcclxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCBbLXIsIC1yLCAyICogciwgMiAqIHJdKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAyICogcilcclxuXHJcbiAgICAgICAgLy9tYWtlIHBpZSBjaGFydC4gU2VlIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AZDMvcGllLWNoYXJ0XHJcbiAgICAgICAgY29uc3QgcGllXyA9IHBpZSgpXHJcbiAgICAgICAgICAgIC5zb3J0KG51bGwpXHJcbiAgICAgICAgICAgIC52YWx1ZSgoZCkgPT4gZC52YWx1ZSlcclxuICAgICAgICBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdkYXJrZ3JheScpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0YShwaWVfKGRhdGEpKVxyXG4gICAgICAgICAgICAuam9pbigncGF0aCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNhdENvbG9ycygpW2QuZGF0YS5jb2RlXSB8fCAnbGlnaHRncmF5J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGFyYygpLmlubmVyUmFkaXVzKGlyKS5vdXRlclJhZGl1cyhyKSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdG9vbHRpcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fVxyXG4gICAgY29uZmlnLmNvbnRhaW5lcklkID0gY29uZmlnLmNvbnRhaW5lcklkIHx8ICdtYXAnXHJcbiAgICBjb25maWcuZGl2ID0gY29uZmlnLmRpdiB8fCAndG9vbHRpcF9ldXJvc3RhdCdcclxuICAgIGNvbmZpZy5tYXhXaWR0aCA9IGNvbmZpZy5tYXhXaWR0aCB8fCAnMjAwcHgnXHJcbiAgICBjb25maWcuZm9udFNpemUgPSBjb25maWcuZm9udFNpemUgfHwgJzE0cHgnXHJcbiAgICBjb25maWcuYmFja2dyb3VuZCA9IGNvbmZpZy5iYWNrZ3JvdW5kIHx8ICd3aGl0ZSdcclxuICAgIGNvbmZpZy5wYWRkaW5nID0gY29uZmlnLnBhZGRpbmcgfHwgJzBweCdcclxuICAgIGNvbmZpZy5ib3JkZXIgPSBjb25maWcuYm9yZGVyIHx8ICcwcHgnXHJcbiAgICBjb25maWcuYm9yZGVyUmFkaXVzID0gY29uZmlnLmJvcmRlclJhZGl1cyB8fCAnMHB4J1xyXG4gICAgY29uZmlnLmJveFNoYWRvdyA9IGNvbmZpZy5ib3hTaGFkb3cgfHwgJzBweCAwcHggMHB4IGdyZXknXHJcblxyXG4gICAgY29uZmlnLnRyYW5zaXRpb25EdXJhdGlvbiA9IGNvbmZpZy50cmFuc2l0aW9uRHVyYXRpb24gfHwgMFxyXG4gICAgY29uZmlnLnhPZmZzZXQgPSBjb25maWcueE9mZnNldCB8fCAzMFxyXG4gICAgY29uZmlnLnlPZmZzZXQgPSBjb25maWcueU9mZnNldCB8fCAyMFxyXG5cclxuICAgIGxldCB0b29sdGlwXHJcblxyXG4gICAgZnVuY3Rpb24gbXkoKSB7XHJcbiAgICAgICAgdG9vbHRpcCA9IHNlbGVjdCgnIycgKyBjb25maWcuZGl2KVxyXG4gICAgICAgIGlmICh0b29sdGlwLmVtcHR5KCkpIHRvb2x0aXAgPSBzZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ2RpdicpLmF0dHIoJ2lkJywgY29uZmlnLmRpdilcclxuXHJcbiAgICAgICAgdG9vbHRpcC5hdHRyKCdjbGFzcycsICd0b29sdGlwLWV1cm9zdGF0JylcclxuICAgIH1cclxuXHJcbiAgICBteS5tb3VzZW92ZXIgPSBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICAgIGlmIChodG1sKSB0b29sdGlwLmh0bWwoaHRtbClcclxuICAgICAgICBsZXQgeCA9IGV2ZW50LnBhZ2VYXHJcbiAgICAgICAgbGV0IHkgPSBldmVudC5wYWdlWVxyXG4gICAgICAgIG15LmVuc3VyZVRvb2x0aXBPblNjcmVlbih4LCB5KVxyXG4gICAgfVxyXG5cclxuICAgIG15Lm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGxldCB4ID0gZXZlbnQucGFnZVhcclxuICAgICAgICBsZXQgeSA9IGV2ZW50LnBhZ2VZXHJcbiAgICAgICAgdGhpcy5lbnN1cmVUb29sdGlwT25TY3JlZW4oeCwgeSlcclxuICAgIH1cclxuXHJcbiAgICBteS5tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0b29sdGlwLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgIH1cclxuXHJcbiAgICBteS5zdHlsZSA9IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRvb2x0aXAuc3R5bGUoaylcclxuICAgICAgICB0b29sdGlwLnN0eWxlKGssIHYpXHJcbiAgICAgICAgcmV0dXJuIG15XHJcbiAgICB9XHJcblxyXG4gICAgbXkuYXR0ciA9IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRvb2x0aXAuYXR0cihrKVxyXG4gICAgICAgIHRvb2x0aXAuYXR0cihrLCB2KVxyXG4gICAgICAgIHJldHVybiBteVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGVuc3VyZVRvb2x0aXBPblNjcmVlblxyXG4gICAgICogQGRlc2NyaXB0aW9uIFByZXZlbnRzIHRoZSB0b29sdGlwIGZyb20gb3ZlcmZsb3dpbmcgb2ZmIHNjcmVlblxyXG4gICAgICovXHJcbiAgICBteS5lbnN1cmVUb29sdGlwT25TY3JlZW4gPSBmdW5jdGlvbiAoZXZlbnRYLCBldmVudFkpIHtcclxuICAgICAgICB0b29sdGlwLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICBsZXQgbm9kZSA9IHRvb2x0aXAubm9kZSgpXHJcblxyXG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGV2ZW50WCArIGNvbmZpZy54T2Zmc2V0ICsgJ3B4J1xyXG4gICAgICAgIG5vZGUuc3R5bGUudG9wID0gZXZlbnRZIC0gY29uZmlnLnlPZmZzZXQgKyAncHgnXHJcblxyXG4gICAgICAgIGxldCBwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25maWcuY29udGFpbmVySWQpXHJcbiAgICAgICAgbGV0IHJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgLy8gZ2V0IHRoZSBib3VuZGluZyByZWN0YW5nbGVcclxuICAgICAgICBsZXQgcGFyZW50V2lkdGggPSByZWN0LndpZHRoXHJcbiAgICAgICAgbGV0IHBhcmVudEhlaWdodCA9IHJlY3QuaGVpZ2h0XHJcblxyXG4gICAgICAgIC8vdG9vIGZhciByaWdodFxyXG4gICAgICAgIC8vdGFraW5nIGludG8gYWNjb3VudCBvZmYgc2NyZWVuIHNwYWNlIGJ1dCBzaG91bGRudCBiZVxyXG4gICAgICAgIGlmIChub2RlLm9mZnNldExlZnQgPiByZWN0LmxlZnQgKyBwYXJlbnRXaWR0aCAtIG5vZGUuY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgbGV0IGxlZnQgPSBldmVudFggLSBub2RlLmNsaWVudFdpZHRoIC0gY29uZmlnLnhPZmZzZXRcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCdcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbW91c2UgY292ZXJzIHRvb2x0aXBcclxuICAgICAgICAgICAgaWYgKG5vZGUub2Zmc2V0TGVmdCArIG5vZGUuY2xpZW50V2lkdGggPiBldmVudFgpIHtcclxuICAgICAgICAgICAgICAgIC8vbW92ZSB0b29sdGlwIGxlZnQgc28gaXQgZG9lc250IGNvdmVyIG1vdXNlXHJcbiAgICAgICAgICAgICAgICBsZXQgbGVmdDIgPSBldmVudFggLSBub2RlLmNsaWVudFdpZHRoIC0gY29uZmlnLnhPZmZzZXRcclxuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQyICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUudG9wID0gbm9kZS5vZmZzZXRUb3AgKyBjb25maWcueU9mZnNldCArIFwicHhcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdG9vIGZhciBkb3duXHJcbiAgICAgICAgaWYgKG5vZGUub2Zmc2V0VG9wICsgbm9kZS5jbGllbnRIZWlnaHQgPiByZWN0LnRvcCArIHBhcmVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBub2RlLnN0eWxlLnRvcCA9IG5vZGUub2Zmc2V0VG9wIC0gbm9kZS5jbGllbnRIZWlnaHQgKyAncHgnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG15KClcclxuICAgIHJldHVybiBteVxyXG59XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsImltcG9ydCAnLi9jc3MvaW5kZXguY3NzJ1xyXG5leHBvcnQgKiBmcm9tICcuL2V1cm9zdGF0LW1hcCdcclxuLy9leHBvcnQgeyBzdGF0RGF0YSB9IGZyb20gXCIuL2NvcmUvc3RhdC1kYXRhLmpzXCI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==